source_filename = "base.l"

declare {i64, i1} @llvm.uadd.with.overflow.i64(i64, i64)
declare {i64, i1} @llvm.usub.with.overflow.i64(i64, i64)
declare i64 @llvm.fshl.i64(i64, i64, i64)
declare i64 @llvm.fshr.i64(i64, i64, i64)
declare void @llvm.memcpy.p0i8.p0i8.i64(i8*, i8*, i64, i1)
declare void @llvm.memset.p0i8.i64(i8*, i8, i64, i1)
declare i8* @llvm.stacksave()
declare void @llvm.stackrestore(i8*)

@$AV0 = global i8* null
@$AV = global i8** null
@$PilHome = global i8* null
@$PilLen = global i64 0
@$UsrHome = global i8* null
@$UsrLen = global i64 0
@$Heaps = global i64 0
@$Avail = global i64 0
@$Extern = global i64 0
@$ExtCnt = global i64 1
@$ExtSkip = global i64 0
@$Current = global i8* null
@$Coroutines = global i8* null
@$StkBrk = global i8* null
@$StkLimit = global i8* null
@$StkSizeT = global i64 262144
@$StkSize = global i64 65536
@$Stdin = global i8* null
@$Stdout = global i8* null
@$LinePtr = global i8* null
@$LineBuf = global i8* null
@$LinePrmt = global i8* null
@$ReplPrmt = global i8* null
@$ContPrmt = global i8* null
@$Ret = global i64 0
@$TtyPid = global i32 0
@$InFDs = global i32 0
@$InFiles = global i8** null
@$OutFiles = global i8** null
@$InFile = global i8* null
@$OutFile = global i8* null
@$Chr = global i32 0
@$IoCnt = global i32 0
@$IoIx = global i64 0
@$IoChar = global i64 0
@$Put = global void(i8)* null
@$Get = global i32()* null
@$PutBin = global void(i8)* null
@$GetBin = global i32()* null
@$OutFDs = global i32 0
@$Nfds = global i32 0
@$Poll = global i64* null
@$SeedL = global i64 0
@$SeedH = global i64 0
@$USec = global i64 0
@$TickU = global i64 0
@$TickS = global i64 0
@$Child = global i8* null
@$Children = global i32 0
@$Slot = global i32 0
@$Spkr = global i32 0
@$Mic = global i32 0
@$SpMiPipe = global [2 x i32] [
  i32 0,
  i32 0
]
@$Talking = global i32 0
@$Hear = global i32 0
@$Tell = global i32 0
@$TellBuf = global i8* null
@$Ptr = global i8* null
@$End = global i8* null
@$BufX = global i8* null
@$PtrX = global i8* null
@$EndX = global i8* null
@$ExtN = global i32 0
@$Extn = global i32 0
@$StrP = global i64* null
@$GcCount = global i64 65536
@$DbFiles = global i8* null
@$DbFile = global i8* null
@$DBs = global i32 0
@$MaxBlkSize = global i32 0
@$DbBlock = global i8* null
@$BlkIndex = global i64 0
@$BlkLink = global i64 0
@$BlkPtr = global i8* null
@$BlkEnd = global i8* null
@$DbJnl = global i8* null
@$DbLog = global i8* null
@$Signal = global [16 x i32] [
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0
]
@SymTab = global [876 x i64] [
  ; # [0] NIL
  i64 79992034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 0,
  ; # [32] ~
  i64 2018,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 48) to i64),
  ; # [80] pico
  i64 29900576514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 64) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 88) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64),
  ; # [144] priv
  i64 31785953026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 128) to i64),
  ; # [160] *OS
  i64 87356066,
  i64 0,
  ; # [176] *CPU
  i64 22901174946,
  i64 0,
  ; # [192] *Pid
  i64 26953974434,
  i64 0,
  ; # [208] *PPid
  i64 6900217610914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [224] *DB
  i64 69485218,
  i64 0,
  ; # [240] meth
  i64 28039337682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64,i64)* @__meth to i8*), i32 2) to i64),
  ; # [256] quote
  i64 6971922536210,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_quote to i8*), i32 2) to i64),
  ; # [272] T
  i64 1346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64),
  ; # [288] N
  i64 1250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [304] C
  i64 1074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [320] S
  i64 1330,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [336] B
  i64 1058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [352] I
  i64 1170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [368] P
  i64 1282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [384] W
  i64 1394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 0,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [416] *Solo
  i64 7656969679522,
  i64 2,
  ; # [432] @
  i64 1026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [448] @@
  i64 263170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [464] @@@
  i64 67372034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [480] This
  i64 30980605250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [496] *Prompt
  i64 524395401951117986,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [512] *Zap
  i64 30166852258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [528] *Ext
  i64 31264625314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [544] *Scl
  i64 29095178914,
  i64 2,
  ; # [560] *Rule
  i64 6969781199522,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [576] *Class
  i64 2031030286693026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [592] *Run
  i64 29650920098,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [608] *Hup
  i64 30187750050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [624] *Sig1
  i64 3395013653154,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [640] *Sig2
  i64 3463733129890,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [656] *Winch
  i64 1836420215173794,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [672] *TStp1
  i64 869744923460258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [688] *TStp2
  i64 887337109504674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [704] *Term
  i64 7521130857122,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [720] ^
  i64 1506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [736] *Err
  i64 30721462946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [752] *Msg
  i64 27769754274,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [768] *Uni
  i64 28301415074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [784] *Fork
  i64 7383702332066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [800] *Bye
  i64 27239129762,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [816] *Dbg
  i64 27751891618,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [832] complete
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 852) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 7310579611546251107,
  i64 2,
  ; # [864] gc
  i64 407154,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_gc to i8*), i32 2) to i64),
  ; # [880] format
  i64 2047388749854306,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_format to i8*), i32 2) to i64),
  ; # [896] +
  i64 690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_add to i8*), i32 2) to i64),
  ; # [912] -
  i64 722,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sub to i8*), i32 2) to i64),
  ; # [928] inc
  i64 104261266,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_inc to i8*), i32 2) to i64),
  ; # [944] dec
  i64 104224322,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dec to i8*), i32 2) to i64),
  ; # [960] *
  i64 674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mul to i8*), i32 2) to i64),
  ; # [976] */
  i64 193186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mulDiv to i8*), i32 2) to i64),
  ; # [992] /
  i64 754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_div to i8*), i32 2) to i64),
  ; # [1008] %
  i64 594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rem to i8*), i32 2) to i64),
  ; # [1024] >>
  i64 254946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_shr to i8*), i32 2) to i64),
  ; # [1040] rev
  i64 124147490,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rev to i8*), i32 2) to i64),
  ; # [1056] lt0
  i64 50808514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lt0 to i8*), i32 2) to i64),
  ; # [1072] le0
  i64 50747074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_le0 to i8*), i32 2) to i64),
  ; # [1088] ge0
  i64 50746994,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ge0 to i8*), i32 2) to i64),
  ; # [1104] gt0
  i64 50808434,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_gt0 to i8*), i32 2) to i64),
  ; # [1120] abs
  i64 120989202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_abs to i8*), i32 2) to i64),
  ; # [1136] bit?
  i64 17033500194,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitQ to i8*), i32 2) to i64),
  ; # [1152] &
  i64 610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitAnd to i8*), i32 2) to i64),
  ; # [1168] |
  i64 1986,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitOr to i8*), i32 2) to i64),
  ; # [1184] x|
  i64 509826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitXor to i8*), i32 2) to i64),
  ; # [1200] sqrt
  i64 31258515250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sqrt to i8*), i32 2) to i64),
  ; # [1216] seed
  i64 26949867314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_seed to i8*), i32 2) to i64),
  ; # [1232] hash
  i64 28038272642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_hash to i8*), i32 2) to i64),
  ; # [1248] rand
  i64 26959288098,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rand to i8*), i32 2) to i64),
  ; # [1264] name
  i64 27226674914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_name to i8*), i32 2) to i64),
  ; # [1280] nsp
  i64 117913314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nsp to i8*), i32 2) to i64),
  ; # [1296] sp?
  i64 66520882,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_spQ to i8*), i32 2) to i64),
  ; # [1312] pat?
  i64 17033467650,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_patQ to i8*), i32 2) to i64),
  ; # [1328] fun?
  i64 17027257954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_funQ to i8*), i32 2) to i64),
  ; # [1344] getd
  i64 26965595762,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_getd to i8*), i32 2) to i64),
  ; # [1360] all
  i64 113690130,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_all to i8*), i32 2) to i64),
  ; # [1376] symbols
  i64 519821567523788594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_symbols to i8*), i32 2) to i64),
  ; # [1392] intern
  i64 1943001719301778,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_intern to i8*), i32 2) to i64),
  ; # [1408] ====
  i64 16438776786,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_hide to i8*), i32 2) to i64),
  ; # [1424] box?
  i64 17037719074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_boxQ to i8*), i32 2) to i64),
  ; # [1440] str?
  i64 17031448370,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_strQ to i8*), i32 2) to i64),
  ; # [1456] zap
  i64 117839778,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_zap to i8*), i32 2) to i64),
  ; # [1472] chop
  i64 30181590578,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_chop to i8*), i32 2) to i64),
  ; # [1488] pack
  i64 28826801922,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pack to i8*), i32 2) to i64),
  ; # [1504] glue
  i64 27235108466,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_glue to i8*), i32 2) to i64),
  ; # [1520] text
  i64 31264757570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_text to i8*), i32 2) to i64),
  ; # [1536] pre?
  i64 17017808642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_preQ to i8*), i32 2) to i64),
  ; # [1552] sub?
  i64 17014675250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_subQ to i8*), i32 2) to i64),
  ; # [1568] val
  i64 113645410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_val to i8*), i32 2) to i64),
  ; # [1584] set
  i64 122050354,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_set to i8*), i32 2) to i64),
  ; # [1600] setq
  i64 30455256882,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_setq to i8*), i32 2) to i64),
  ; # [1616] swap
  i64 30166972210,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_swap to i8*), i32 2) to i64),
  ; # [1632] xchg
  i64 27758311298,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_xchg to i8*), i32 2) to i64),
  ; # [1648] on
  i64 452338,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_on to i8*), i32 2) to i64),
  ; # [1664] off
  i64 107374322,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_off to i8*), i32 2) to i64),
  ; # [1680] onOff
  i64 7036850333426,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_onOff to i8*), i32 2) to i64),
  ; # [1696] zero
  i64 29916288930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_zero to i8*), i32 2) to i64),
  ; # [1712] one
  i64 106358514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_one to i8*), i32 2) to i64),
  ; # [1728] default
  i64 524325579192161858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_default to i8*), i32 2) to i64),
  ; # [1744] push
  i64 28038354690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_push to i8*), i32 2) to i64),
  ; # [1760] push1
  i64 3395292714754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_push1 to i8*), i32 2) to i64),
  ; # [1776] push1q
  i64 1991312315733762,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_push1q to i8*), i32 2) to i64),
  ; # [1792] pop
  i64 117896962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pop to i8*), i32 2) to i64),
  ; # [1808] ++
  i64 176818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_popq to i8*), i32 2) to i64),
  ; # [1824] shift
  i64 7998950246194,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_shift to i8*), i32 2) to i64),
  ; # [1840] cut
  i64 122115634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cut to i8*), i32 2) to i64),
  ; # [1856] del
  i64 113661506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_del to i8*), i32 2) to i64),
  ; # [1872] queue
  i64 6972180485906,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_queue to i8*), i32 2) to i64),
  ; # [1888] fifo
  i64 29903722082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fifo to i8*), i32 2) to i64),
  ; # [1904] rid
  i64 105289506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rid to i8*), i32 2) to i64),
  ; # [1920] enum
  i64 29382600274,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_enum to i8*), i32 2) to i64),
  ; # [1936] enum?
  i64 4358709634642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_enumQ to i8*), i32 2) to i64),
  ; # [1952] idx
  i64 126240402,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_idx to i8*), i32 2) to i64),
  ; # [1968] lup
  i64 117921474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lup to i8*), i32 2) to i64),
  ; # [1984] put
  i64 122115842,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_put to i8*), i32 2) to i64),
  ; # [2000] get
  i64 122050162,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_get to i8*), i32 2) to i64),
  ; # [2016] prop
  i64 30181631746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prop to i8*), i32 2) to i64),
  ; # [2032] ;
  i64 946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_semicol to i8*), i32 2) to i64),
  ; # [2048] =:
  i64 238546,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_setCol to i8*), i32 2) to i64),
  ; # [2064] :
  i64 930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_col to i8*), i32 2) to i64),
  ; # [2080] ::
  i64 238498,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_propCol to i8*), i32 2) to i64),
  ; # [2096] putl
  i64 29113145090,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_putl to i8*), i32 2) to i64),
  ; # [2112] getl
  i64 29113079410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_getl to i8*), i32 2) to i64),
  ; # [2128] wipe
  i64 27229853554,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_wipe to i8*), i32 2) to i64),
  ; # [2144] meta
  i64 26160289490,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_meta to i8*), i32 2) to i64),
  ; # [2160] low?
  i64 17036670658,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lowQ to i8*), i32 2) to i64),
  ; # [2176] upp?
  i64 17029334866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_uppQ to i8*), i32 2) to i64),
  ; # [2192] lowc
  i64 26700347074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lowc to i8*), i32 2) to i64),
  ; # [2208] uppc
  i64 26693011282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_uppc to i8*), i32 2) to i64),
  ; # [2224] fold
  i64 26957248098,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fold to i8*), i32 2) to i64),
  ; # [2240] path
  i64 28039321346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_path to i8*), i32 2) to i64),
  ; # [2256] wait
  i64 31249012594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_wait to i8*), i32 2) to i64),
  ; # [2272] sync
  i64 26690950962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sync to i8*), i32 2) to i64),
  ; # [2288] hear
  i64 30703769218,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_hear to i8*), i32 2) to i64),
  ; # [2304] tell
  i64 29104691010,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_tell to i8*), i32 2) to i64),
  ; # [2320] poll
  i64 29104731906,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_poll to i8*), i32 2) to i64),
  ; # [2336] read
  i64 26945672994,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_read to i8*), i32 2) to i64),
  ; # [2352] key
  i64 127293106,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_key to i8*), i32 2) to i64),
  ; # [2368] peek
  i64 28828915458,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_peek to i8*), i32 2) to i64),
  ; # [2384] char
  i64 30703781426,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_char to i8*), i32 2) to i64),
  ; # [2400] skip
  i64 30175311666,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_skip to i8*), i32 2) to i64),
  ; # [2416] eol
  i64 113702482,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eol to i8*), i32 2) to i64),
  ; # [2432] eof
  i64 107411026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eof to i8*), i32 2) to i64),
  ; # [2448] from
  i64 29376325218,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_from to i8*), i32 2) to i64),
  ; # [2464] till
  i64 29104707394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_till to i8*), i32 2) to i64),
  ; # [2480] line
  i64 27227756226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_line to i8*), i32 2) to i64),
  ; # [2496] in
  i64 452242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_in to i8*), i32 2) to i64),
  ; # [2512] out
  i64 122115826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_out to i8*), i32 2) to i64),
  ; # [2528] err
  i64 120006226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_err to i8*), i32 2) to i64),
  ; # [2544] ctl
  i64 113722930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ctl to i8*), i32 2) to i64),
  ; # [2560] input
  i64 8002984142482,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_input to i8*), i32 2) to i64),
  ; # [2576] output
  i64 2048763946817266,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_output to i8*), i32 2) to i64),
  ; # [2592] fd
  i64 411234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fd to i8*), i32 2) to i64),
  ; # [2608] pipe
  i64 27229853442,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pipe to i8*), i32 2) to i64),
  ; # [2624] open
  i64 29634266866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_open to i8*), i32 2) to i64),
  ; # [2640] close
  i64 6971654063666,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_close to i8*), i32 2) to i64),
  ; # [2656] echo
  i64 29905794642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_echo to i8*), i32 2) to i64),
  ; # [2672] prin
  i64 29638469378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prin to i8*), i32 2) to i64),
  ; # [2688] prinl
  i64 7451341956866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prinl to i8*), i32 2) to i64),
  ; # [2704] space
  i64 6967344432946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_space to i8*), i32 2) to i64),
  ; # [2720] print
  i64 8001097770754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_print to i8*), i32 2) to i64),
  ; # [2736] printsp
  i64 506434260758374146,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_printsp to i8*), i32 2) to i64),
  ; # [2752] println
  i64 497303916201322242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_println to i8*), i32 2) to i64),
  ; # [2768] flush
  i64 7177818785378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_flush to i8*), i32 2) to i64),
  ; # [2784] rewind
  i64 1766806057801506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rewind to i8*), i32 2) to i64),
  ; # [2800] ext
  i64 122127954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ext to i8*), i32 2) to i64),
  ; # [2816] plio
  i64 29906880258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_plio to i8*), i32 2) to i64),
  ; # [2832] rd
  i64 411426,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rd to i8*), i32 2) to i64),
  ; # [2848] pr
  i64 468738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pr to i8*), i32 2) to i64),
  ; # [2864] wr
  i64 468850,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_wr to i8*), i32 2) to i64),
  ; # [2880] any
  i64 127329810,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_any to i8*), i32 2) to i64),
  ; # [2896] sym
  i64 114792242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sym to i8*), i32 2) to i64),
  ; # [2912] str
  i64 120014642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_str to i8*), i32 2) to i64),
  ; # [2928] load
  i64 26945713858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_load to i8*), i32 2) to i64),
  ; # [2944] ext?
  i64 17033561682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extQ to i8*), i32 2) to i64),
  ; # [2960] rollback
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 2980) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rollback to i8*), i32 2) to i64),
  i64 7738135660106379122,
  i64 2,
  ; # [2992] extern
  i64 1943001719342674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extern to i8*), i32 2) to i64),
  ; # [3008] pool
  i64 29107877634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pool to i8*), i32 2) to i64),
  ; # [3024] pool2
  i64 3465081714434,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pool2 to i8*), i32 2) to i64),
  ; # [3040] journal
  i64 488102791669544610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_journal to i8*), i32 2) to i64),
  ; # [3056] id
  i64 411282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_id to i8*), i32 2) to i64),
  ; # [3072] blk
  i64 112641570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_blk to i8*), i32 2) to i64),
  ; # [3088] seq
  i64 118904626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_seq to i8*), i32 2) to i64),
  ; # [3104] lieu
  i64 31513286338,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lieu to i8*), i32 2) to i64),
  ; # [3120] lock
  i64 28826859202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lock to i8*), i32 2) to i64),
  ; # [3136] touch
  i64 7173523830594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_touch to i8*), i32 2) to i64),
  ; # [3152] commit
  i64 2047938500425266,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_commit to i8*), i32 2) to i64),
  ; # [3168] mark
  i64 28842530514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mark to i8*), i32 2) to i64),
  ; # [3184] free
  i64 27218355810,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_free to i8*), i32 2) to i64),
  ; # [3200] dbck
  i64 28826805826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dbck to i8*), i32 2) to i64),
  ; # [3216] apply
  i64 8344165615122,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_apply to i8*), i32 2) to i64),
  ; # [3232] pass
  i64 30991062786,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pass to i8*), i32 2) to i64),
  ; # [3248] fun
  i64 115824226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fun to i8*), i32 2) to i64),
  ; # [3264] maps
  i64 30987917010,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_maps to i8*), i32 2) to i64),
  ; # [3280] map
  i64 117839570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_map to i8*), i32 2) to i64),
  ; # [3296] mapc
  i64 26692949714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapc to i8*), i32 2) to i64),
  ; # [3312] maplist
  i64 524447902824011474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_maplist to i8*), i32 2) to i64),
  ; # [3328] mapcar
  i64 2012201691256530,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapcar to i8*), i32 2) to i64),
  ; # [3344] mapcon
  i64 1942795019753170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapcon to i8*), i32 2) to i64),
  ; # [3360] mapcan
  i64 1941832947078866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapcan to i8*), i32 2) to i64),
  ; # [3376] filter
  i64 2012481128404578,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_filter to i8*), i32 2) to i64),
  ; # [3392] extract
  i64 524165879706388050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extract to i8*), i32 2) to i64),
  ; # [3408] seek
  i64 28828915506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_seek to i8*), i32 2) to i64),
  ; # [3424] find
  i64 26959320674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_find to i8*), i32 2) to i64),
  ; # [3440] pick
  i64 28826834690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pick to i8*), i32 2) to i64),
  ; # [3456] fully
  i64 8344161441378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fully to i8*), i32 2) to i64),
  ; # [3472] cnt
  i64 122086962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cnt to i8*), i32 2) to i64),
  ; # [3488] sum
  i64 114775858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sum to i8*), i32 2) to i64),
  ; # [3504] maxi
  i64 28311951058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_maxi to i8*), i32 2) to i64),
  ; # [3520] mini
  i64 28301498066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mini to i8*), i32 2) to i64),
  ; # [3536] fish
  i64 28038305378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fish to i8*), i32 2) to i64),
  ; # [3552] by
  i64 497186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_by to i8*), i32 2) to i64),
  ; # [3568] as
  i64 472594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_as to i8*), i32 2) to i64),
  ; # [3584] lit
  i64 122066626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lit to i8*), i32 2) to i64),
  ; # [3600] eval
  i64 29093226066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eval to i8*), i32 2) to i64),
  ; # [3616] run
  i64 115824418,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_run to i8*), i32 2) to i64),
  ; # [3632] def
  i64 107370050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_def to i8*), i32 2) to i64),
  ; # [3648] de
  i64 415298,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_de to i8*), i32 2) to i64),
  ; # [3664] dm
  i64 448066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dm to i8*), i32 2) to i64),
  ; # [3680] box
  i64 126285346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_box to i8*), i32 2) to i64),
  ; # [3696] new
  i64 125196002,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_new to i8*), i32 2) to i64),
  ; # [3712] type
  i64 27229919042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_type to i8*), i32 2) to i64),
  ; # [3728] isa
  i64 102184594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_isa to i8*), i32 2) to i64),
  ; # [3744] method
  i64 1766874505696978,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_method to i8*), i32 2) to i64),
  ; # [3760] send
  i64 26959304498,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_send to i8*), i32 2) to i64),
  ; # [3776] try
  i64 127346498,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_try to i8*), i32 2) to i64),
  ; # [3792] super
  i64 7861250250546,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_super to i8*), i32 2) to i64),
  ; # [3808] extra
  i64 6696513013330,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extra to i8*), i32 2) to i64),
  ; # [3824] and
  i64 105309714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_and to i8*), i32 2) to i64),
  ; # [3840] or
  i64 468722,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_or to i8*), i32 2) to i64),
  ; # [3856] nand
  i64 26959288034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nand to i8*), i32 2) to i64),
  ; # [3872] nor
  i64 119994082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nor to i8*), i32 2) to i64),
  ; # [3888] xor
  i64 119994242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_xor to i8*), i32 2) to i64),
  ; # [3904] bool
  i64 29107877410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bool to i8*), i32 2) to i64),
  ; # [3920] not
  i64 122091234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_not to i8*), i32 2) to i64),
  ; # [3936] nil
  i64 113678050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nil to i8*), i32 2) to i64),
  ; # [3952] t
  i64 1858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_t to i8*), i32 2) to i64),
  ; # [3968] prog
  i64 27765712642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prog to i8*), i32 2) to i64),
  ; # [3984] prog1
  i64 3395020072706,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prog1 to i8*), i32 2) to i64),
  ; # [4000] prog2
  i64 3463739549442,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prog2 to i8*), i32 2) to i64),
  ; # [4016] if
  i64 419474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_if to i8*), i32 2) to i64),
  ; # [4032] ifn
  i64 115762834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ifn to i8*), i32 2) to i64),
  ; # [4048] if2
  i64 52848274,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_if2 to i8*), i32 2) to i64),
  ; # [4064] when
  i64 29634234226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_when to i8*), i32 2) to i64),
  ; # [4080] unless
  i64 2031031360612178,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_unless to i8*), i32 2) to i64),
  ; # [4096] cond
  i64 26959345202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cond to i8*), i32 2) to i64),
  ; # [4112] nond
  i64 26959345378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nond to i8*), i32 2) to i64),
  ; # [4128] case
  i64 27232966194,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_case to i8*), i32 2) to i64),
  ; # [4144] casq
  i64 30454191666,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_casq to i8*), i32 2) to i64),
  ; # [4160] state
  i64 6971907852082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_state to i8*), i32 2) to i64),
  ; # [4176] while
  i64 6969768707954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_while to i8*), i32 2) to i64),
  ; # [4192] until
  i64 7450011297618,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_until to i8*), i32 2) to i64),
  ; # [4208] at
  i64 476690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_at to i8*), i32 2) to i64),
  ; # [4224] do
  i64 456258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_do to i8*), i32 2) to i64),
  ; # [4240] loop
  i64 30181619394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_loop to i8*), i32 2) to i64),
  ; # [4256] for
  i64 119993954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_for to i8*), i32 2) to i64),
  ; # [4272] with
  i64 28039354226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_with to i8*), i32 2) to i64),
  ; # [4288] bind
  i64 26959320610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bind to i8*), i32 2) to i64),
  ; # [4304] job
  i64 103216802,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_job to i8*), i32 2) to i64),
  ; # [4320] let
  i64 122050242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_let to i8*), i32 2) to i64),
  ; # [4336] let?
  i64 17033483970,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_letQ to i8*), i32 2) to i64),
  ; # [4352] use
  i64 106379090,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_use to i8*), i32 2) to i64),
  ; # [4368] buf
  i64 107435554,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_buf to i8*), i32 2) to i64),
  ; # [4384] catch
  i64 7173522724402,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_catch to i8*), i32 2) to i64),
  ; # [4400] throw
  i64 8207534032706,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_throw to i8*), i32 2) to i64),
  ; # [4416] finally
  i64 546842958862128738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_finally to i8*), i32 2) to i64),
  ; # [4432] co
  i64 456242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_co to i8*), i32 2) to i64),
  ; # [4448] yield
  i64 6901045041042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_yield to i8*), i32 2) to i64),
  ; # [4464] !
  i64 530,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_break to i8*), i32 2) to i64),
  ; # [4480] e
  i64 1618,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_e to i8*), i32 2) to i64),
  ; # [4496] $
  i64 578,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_trace to i8*), i32 2) to i64),
  ; # [4512] exec
  i64 26681509458,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_exec to i8*), i32 2) to i64),
  ; # [4528] call
  i64 29104674354,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_call to i8*), i32 2) to i64),
  ; # [4544] ipid
  i64 26954106514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ipid to i8*), i32 2) to i64),
  ; # [4560] opid
  i64 26954106610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_opid to i8*), i32 2) to i64),
  ; # [4576] kill
  i64 29104707250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_kill to i8*), i32 2) to i64),
  ; # [4592] fork
  i64 28842587746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fork to i8*), i32 2) to i64),
  ; # [4608] detach
  i64 1836416737105474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_detach to i8*), i32 2) to i64),
  ; # [4624] bye
  i64 106403362,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bye to i8*), i32 2) to i64),
  ; # [4640] car
  i64 119936562,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_car to i8*), i32 2) to i64),
  ; # [4656] cdr
  i64 119948850,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdr to i8*), i32 2) to i64),
  ; # [4672] caar
  i64 30703752754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caar to i8*), i32 2) to i64),
  ; # [4688] cadr
  i64 30706898482,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadr to i8*), i32 2) to i64),
  ; # [4704] cdar
  i64 30703765042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdar to i8*), i32 2) to i64),
  ; # [4720] cddr
  i64 30706910770,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddr to i8*), i32 2) to i64),
  ; # [4736] caaar
  i64 7860160697906,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaar to i8*), i32 2) to i64),
  ; # [4752] caadr
  i64 7860966004274,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caadr to i8*), i32 2) to i64),
  ; # [4768] cadar
  i64 7860163843634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadar to i8*), i32 2) to i64),
  ; # [4784] caddr
  i64 7860969150002,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caddr to i8*), i32 2) to i64),
  ; # [4800] cdaar
  i64 7860160710194,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaar to i8*), i32 2) to i64),
  ; # [4816] cdadr
  i64 7860966016562,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdadr to i8*), i32 2) to i64),
  ; # [4832] cddar
  i64 7860163855922,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddar to i8*), i32 2) to i64),
  ; # [4848] cdddr
  i64 7860969162290,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdddr to i8*), i32 2) to i64),
  ; # [4864] caaaar
  i64 2012201138656818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaaar to i8*), i32 2) to i64),
  ; # [4880] caaadr
  i64 2012407297087026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaadr to i8*), i32 2) to i64),
  ; # [4896] caadar
  i64 2012201943963186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caadar to i8*), i32 2) to i64),
  ; # [4912] caaddr
  i64 2012408102393394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaddr to i8*), i32 2) to i64),
  ; # [4928] cadaar
  i64 2012201141802546,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadaar to i8*), i32 2) to i64),
  ; # [4944] cadadr
  i64 2012407300232754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadadr to i8*), i32 2) to i64),
  ; # [4960] caddar
  i64 2012201947108914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caddar to i8*), i32 2) to i64),
  ; # [4976] cadddr
  i64 2012408105539122,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadddr to i8*), i32 2) to i64),
  ; # [4992] cdaaar
  i64 2012201138669106,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaaar to i8*), i32 2) to i64),
  ; # [5008] cdaadr
  i64 2012407297099314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaadr to i8*), i32 2) to i64),
  ; # [5024] cdadar
  i64 2012201943975474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdadar to i8*), i32 2) to i64),
  ; # [5040] cdaddr
  i64 2012408102405682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaddr to i8*), i32 2) to i64),
  ; # [5056] cddaar
  i64 2012201141814834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddaar to i8*), i32 2) to i64),
  ; # [5072] cddadr
  i64 2012407300245042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddadr to i8*), i32 2) to i64),
  ; # [5088] cdddar
  i64 2012201947121202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdddar to i8*), i32 2) to i64),
  ; # [5104] cddddr
  i64 2012408105551410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddddr to i8*), i32 2) to i64),
  ; # [5120] nth
  i64 109528802,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nth to i8*), i32 2) to i64),
  ; # [5136] con
  i64 115799602,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_con to i8*), i32 2) to i64),
  ; # [5152] cons
  i64 30985877042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cons to i8*), i32 2) to i64),
  ; # [5168] conc
  i64 26690909746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_conc to i8*), i32 2) to i64),
  ; # [5184] circ
  i64 26695079474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_circ to i8*), i32 2) to i64),
  ; # [5200] rot
  i64 122091298,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rot to i8*), i32 2) to i64),
  ; # [5216] list
  i64 31259530946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_list to i8*), i32 2) to i64),
  ; # [5232] need
  i64 26949867234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_need to i8*), i32 2) to i64),
  ; # [5248] range
  i64 6968431744802,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_range to i8*), i32 2) to i64),
  ; # [5264] full
  i64 29104756322,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_full to i8*), i32 2) to i64),
  ; # [5280] make
  i64 27224577746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_make to i8*), i32 2) to i64),
  ; # [5296] made
  i64 27217237714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_made to i8*), i32 2) to i64),
  ; # [5312] chain
  i64 7587430303282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_chain to i8*), i32 2) to i64),
  ; # [5328] link
  i64 28838368962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_link to i8*), i32 2) to i64),
  ; # [5344] yoke
  i64 27224635282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_yoke to i8*), i32 2) to i64),
  ; # [5360] copy
  i64 32598586930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_copy to i8*), i32 2) to i64),
  ; # [5376] mix
  i64 126260946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mix to i8*), i32 2) to i64),
  ; # [5392] append
  i64 1766804976764434,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_append to i8*), i32 2) to i64),
  ; # [5408] delete
  i64 1784809475429954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_delete to i8*), i32 2) to i64),
  ; # [5424] delq
  i64 30446868034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_delq to i8*), i32 2) to i64),
  ; # [5440] replace
  i64 456611883680945954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_replace to i8*), i32 2) to i64),
  ; # [5456] insert
  i64 2048554834519698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_insert to i8*), i32 2) to i64),
  ; # [5472] remove
  i64 1784949599786786,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_remove to i8*), i32 2) to i64),
  ; # [5488] place
  i64 6967344416514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_place to i8*), i32 2) to i64),
  ; # [5504] strip
  i64 7724887131954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_strip to i8*), i32 2) to i64),
  ; # [5520] split
  i64 7999758731058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_split to i8*), i32 2) to i64),
  ; # [5536] reverse
  i64 456894525016004386,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_reverse to i8*), i32 2) to i64),
  ; # [5552] flip
  i64 30175315554,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_flip to i8*), i32 2) to i64),
  ; # [5568] trim
  i64 29370033986,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_trim to i8*), i32 2) to i64),
  ; # [5584] clip
  i64 30175315506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_clip to i8*), i32 2) to i64),
  ; # [5600] head
  i64 26945672834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_head to i8*), i32 2) to i64),
  ; # [5616] tail
  i64 29101528898,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_tail to i8*), i32 2) to i64),
  ; # [5632] stem
  i64 29365847858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_stem to i8*), i32 2) to i64),
  ; # [5648] fin
  i64 115775074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fin to i8*), i32 2) to i64),
  ; # [5664] last
  i64 31259498178,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_last to i8*), i32 2) to i64),
  ; # [5680] ==
  i64 250834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eq to i8*), i32 2) to i64),
  ; # [5696] n==
  i64 64214754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_neq to i8*), i32 2) to i64),
  ; # [5712] =
  i64 978,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_equal to i8*), i32 2) to i64),
  ; # [5728] <>
  i64 254914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nequal to i8*), i32 2) to i64),
  ; # [5744] =0
  i64 197586,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eq0 to i8*), i32 2) to i64),
  ; # [5760] =1
  i64 201682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eq1 to i8*), i32 2) to i64),
  ; # [5776] =T
  i64 345042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eqT to i8*), i32 2) to i64),
  ; # [5792] n0
  i64 198370,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_neq0 to i8*), i32 2) to i64),
  ; # [5808] nT
  i64 345826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_neqT to i8*), i32 2) to i64),
  ; # [5824] <
  i64 962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lt to i8*), i32 2) to i64),
  ; # [5840] <=
  i64 250818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_le to i8*), i32 2) to i64),
  ; # [5856] >
  i64 994,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_gt to i8*), i32 2) to i64),
  ; # [5872] >=
  i64 250850,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ge to i8*), i32 2) to i64),
  ; # [5888] max
  i64 126228178,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_max to i8*), i32 2) to i64),
  ; # [5904] min
  i64 115775186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_min to i8*), i32 2) to i64),
  ; # [5920] atom
  i64 29376333330,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_atom to i8*), i32 2) to i64),
  ; # [5936] pair
  i64 30712141570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pair to i8*), i32 2) to i64),
  ; # [5952] circ?
  i64 4356022113842,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_circQ to i8*), i32 2) to i64),
  ; # [5968] lst?
  i64 17033541314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lstQ to i8*), i32 2) to i64),
  ; # [5984] num?
  i64 17026209506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_numQ to i8*), i32 2) to i64),
  ; # [6000] sym?
  i64 17026225970,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_symQ to i8*), i32 2) to i64),
  ; # [6016] flg?
  i64 17019881058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_flgQ to i8*), i32 2) to i64),
  ; # [6032] member
  i64 2012476297598674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_member to i8*), i32 2) to i64),
  ; # [6048] memq
  i64 30447916754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_memq to i8*), i32 2) to i64),
  ; # [6064] mmeq
  i64 30439560914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mmeq to i8*), i32 2) to i64),
  ; # [6080] sect
  i64 31242737458,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sect to i8*), i32 2) to i64),
  ; # [6096] diff
  i64 27487802946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_diff to i8*), i32 2) to i64),
  ; # [6112] index
  i64 8273554499218,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_index to i8*), i32 2) to i64),
  ; # [6128] offset
  i64 2047665225754354,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_offset to i8*), i32 2) to i64),
  ; # [6144] prior
  i64 7863927252738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prior to i8*), i32 2) to i64),
  ; # [6160] length
  i64 1837586572531394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_length to i8*), i32 2) to i64),
  ; # [6176] size
  i64 27240339250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_size to i8*), i32 2) to i64),
  ; # [6192] bytes
  i64 7929973937698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bytes to i8*), i32 2) to i64),
  ; # [6208] assoc
  i64 6833145591314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_assoc to i8*), i32 2) to i64),
  ; # [6224] rassoc
  i64 1749285271377698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rassoc to i8*), i32 2) to i64),
  ; # [6240] asoq
  i64 30450071058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_asoq to i8*), i32 2) to i64),
  ; # [6256] rasoq
  i64 7795218192162,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rasoq to i8*), i32 2) to i64),
  ; # [6272] rank
  i64 28838336290,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rank to i8*), i32 2) to i64),
  ; # [6288] match
  i64 7173522724562,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_match to i8*), i32 2) to i64),
  ; # [6304] fill
  i64 29104707170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fill to i8*), i32 2) to i64),
  ; # [6320] prove
  i64 6972459394818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prove to i8*), i32 2) to i64),
  ; # [6336] ->
  i64 254674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_arrow to i8*), i32 2) to i64),
  ; # [6352] unify
  i64 8342547654482,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_unify to i8*), i32 2) to i64),
  ; # [6368] group
  i64 7728105203314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_group to i8*), i32 2) to i64),
  ; # [6384] sort
  i64 31258507058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sort to i8*), i32 2) to i64),
  ; # [6400] tty
  i64 127354690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_tty to i8*), i32 2) to i64),
  ; # [6416] raw
  i64 125179682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_raw to i8*), i32 2) to i64),
  ; # [6432] alarm
  i64 7521126762002,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_alarm to i8*), i32 2) to i64),
  ; # [6448] sigio
  i64 7656156075826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sigio to i8*), i32 2) to i64),
  ; # [6464] kids
  i64 30975366834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_kids to i8*), i32 2) to i64),
  ; # [6480] protect
  i64 524166155115898626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_protect to i8*), i32 2) to i64),
  ; # [6496] heap
  i64 30166898306,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_heap to i8*), i32 2) to i64),
  ; # [6512] stack
  i64 7379661309746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_stack to i8*), i32 2) to i64),
  ; # [6528] byte
  i64 27234113058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_byte to i8*), i32 2) to i64),
  ; # [6544] env
  i64 124184146,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_env to i8*), i32 2) to i64),
  ; # [6560] date
  i64 27234014786,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_date to i8*), i32 2) to i64),
  ; # [6576] time
  i64 27226707778,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_time to i8*), i32 2) to i64),
  ; # [6592] usec
  i64 26681489234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_usec to i8*), i32 2) to i64),
  ; # [6608] quit
  i64 31249094418,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_quit to i8*), i32 2) to i64),
  ; # [6624] sys
  i64 121083698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sys to i8*), i32 2) to i64),
  ; # [6640] pwd
  i64 105346818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pwd to i8*), i32 2) to i64),
  ; # [6656] cd
  i64 411186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cd to i8*), i32 2) to i64),
  ; # [6672] ctty
  i64 32602801714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ctty to i8*), i32 2) to i64),
  ; # [6688] cmd
  i64 105305650,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cmd to i8*), i32 2) to i64),
  ; # [6704] dir
  i64 119969346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dir to i8*), i32 2) to i64),
  ; # [6720] info
  i64 29903742610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_info to i8*), i32 2) to i64),
  ; # [6736] file
  i64 27225658978,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_file to i8*), i32 2) to i64),
  ; # [6752] argv
  i64 31783855634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_argv to i8*), i32 2) to i64),
  ; # [6768] opt
  i64 122095346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_opt to i8*), i32 2) to i64),
  ; # [6784] errno
  i64 7657509824082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_errno to i8*), i32 2) to i64),
  ; # [6800] %@
  i64 262738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nat to i8*), i32 2) to i64),
  ; # [6816] native
  i64 1784947996497634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_native to i8*), i32 2) to i64),
  ; # [6832] struct
  i64 2047528336312114,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_struct to i8*), i32 2) to i64),
  ; # [6848] lisp
  i64 30185789122,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lisp to i8*), i32 2) to i64),
  ; # [6864] args
  i64 30978549266,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_args to i8*), i32 2) to i64),
  ; # [6880] next
  i64 31264757474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_next to i8*), i32 2) to i64),
  ; # [6896] arg
  i64 108471826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_arg to i8*), i32 2) to i64),
  ; # [6912] rest
  i64 31259514658,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rest to i8*), i32 2) to i64),
  ; # [6928] adr
  i64 119948818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_adr to i8*), i32 2) to i64),
  ; # [6944] trail
  i64 7449991391042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_trail to i8*), i32 2) to i64),
  ; # [6960] up
  i64 460626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_up to i8*), i32 2) to i64),
  ; # [6976] history
  i64 546948723242342018,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_history to i8*), i32 2) to i64),
  ; # [6992] version
  i64 497355938196772706,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_version to i8*), i32 2) to i64)
], align 16
@gcData = global [53 x i64] [
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 96) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
], align 8
@cbFuns = global [24 x i64] [
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb1 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb2 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb3 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb4 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb5 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb6 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb7 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb8 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb9 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb10 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb11 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb12 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb13 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb14 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb15 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb16 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb17 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb18 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb19 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb20 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb21 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb22 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb23 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb24 to i64)
], align 8
@env = global [18 x i64] [
  i64 0,
  i64 0,
  i64 0,
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i64* null to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 0,
  i64 0,
  i64 0,
  i64 0,
  i64 sext (i32 0 to i64),
  i64 sext (i32 0 to i64)
], align 8
@$Cell = global [2 x i64] [
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
]
@$Version = global [3 x i64] [
  i64 354,
  i64 98,
  i64 162
], align 8
@$TBuf = global [2 x i8] [
  i8 5,
  i8 84
]
@$Month = global [13 x i8] [
  i8 31,
  i8 31,
  i8 28,
  i8 31,
  i8 30,
  i8 31,
  i8 30,
  i8 31,
  i8 31,
  i8 30,
  i8 31,
  i8 30,
  i8 31
]
@$Repl = global i1 0
@$PRepl = global i1 0
@$Jam = global i1 0
@$InBye = global i1 0
@$Sync = global i1 0
@$Empty = constant [1 x i8] c"\00"
@$Delim = constant [16 x i8] c" \09\0A\0D\22'(),[]`{}~\00"
declare i8* @malloc(i64)
declare i8* @realloc(i8*, i64)
declare void @free(i8*)
declare i32 @fork()
declare i8* @getenv(i8*)
declare i32 @setenv(i8*, i8*, i32)
declare i8* @getcwd(i8*, i64)
declare i32 @chdir(i8*)
declare i32 @getpid()
declare i32 @getpgrp()
declare i32 @setsid()
declare i32 @alarm(i32)
declare i32 @setpgid(i32, i32)
declare i32 @execvp(i8*, i8**)
declare i32 @isatty(i32)
declare i32 @openpty(i32*, i32*, i8*, i8*, i8*)
declare i32 @login_tty(i32)
declare i32 @tcgetattr(i32, i8*)
declare i32 @tcgetpgrp(i32)
declare i32 @tcsetpgrp(i32, i32)
declare i64 @read(i32, i8*, i64)
declare i64 @write(i32, i8*, i64)
declare i64 @pread(i32, i8*, i64, i64)
declare i64 @pwrite(i32, i8*, i64, i64)
declare i32 @fread(i8*, i64, i64, i8*)
declare i32 @fwrite(i8*, i64, i64, i8*)
declare i32 @putc_unlocked(i32, i8*)
declare i32 @getc_unlocked(i8*)
declare i8* @fopen(i8*, i8*)
declare i32 @fflush(i8*)
declare i32 @feof(i8*)
declare i32 @fclose(i8*)
declare i32 @fileno(i8*)
declare i32 @fsync(i32)
declare i32 @pipe(i32*)
declare i32 @memcmp(i8*, i8*, i64)
declare i64 @strlen(i8*)
declare i8* @strcpy(i8*, i8*)
declare i8* @strdup(i8*)
declare i32 @strcmp(i8*, i8*)
declare i8* @strchr(i8*, i32)
declare i8* @strrchr(i8*, i32)
declare i8* @dlsym(i8*, i8*)
declare i8* @dlerror()
declare i32 @dup(i32)
declare i32 @dup2(i32, i32)
declare i32 @close(i32)
declare i8* @signal(i32, i8*)
declare i32 @waitpid(i32, i32*, i32)
declare i32 @poll(i64*, i32, i64)
declare i32 @setjmp(i8*)
declare void @longjmp(i8*, i32)
declare i32 @kill(i32, i32)
declare void @exit(i32)
declare void @add_history(i8*)
declare i8*** @history_list()
declare void @clear_history()
@TgOS = external global i8
@TgCPU = external global i8
@PipeBufSize = external global i32
@Fsign = external global i1
@Fdigit = external global i64
declare i8* @stderrMsg(i8*, i8*)
declare i32 @gPrintf(i8*, i32, i8*, i8*)
declare i8* @strErrno()
declare i32 @openRd(i8*)
declare i32 @openWr(i8*)
declare i32 @openRdWr(i8*)
declare i32 @openRdWrExcl(i8*)
declare i32 @openRdWrCreate(i8*)
declare i32 @openRdWrAppend(i8*)
declare i32 @openWrAppend(i8*)
declare i1 @fseekOfs(i8*, i32)
declare i1 @fseek0(i8*)
declare i1 @seek0(i32)
declare i1 @truncate0(i32)
declare i32 @socketPair(i32*)
declare i32 @fcntlCloExec(i32)
declare void @fcntlSetFl(i32, i32)
declare i32 @nonBlocking(i32)
declare void @fcntlSetOwn(i32, i32)
declare i8* @getDir(i8*)
declare void @initReadline()
declare i8* @gReadline(i8*)
declare void @rlHide()
declare void @rlShow()
declare void @rlSigBeg()
declare void @rlSigEnd()
declare i8* @currentLine()
@Sig = external global i32
@SigDfl = external global i8*
@SigIgn = external global i8*
declare i32 @gSignal(i32)
declare void @sigUnblock(i32)
declare void @iSignal(i32, i8*)
declare void @sigChld(i32)
declare i32 @waitWuntraced(i32, i32*)
declare i32 @wifStopped(i32*)
declare i32 @nErrno()
declare i32 @gErrno()
@Tio = external global i1
@OrgTermio = external global i8
@Termio = external global i8*
declare void @stopTerm()
declare void @setRaw()
declare void @setCooked()
declare i1 @reopenTty(i8*)
declare i64 @getUsec(i1)
declare i64 @getMsec()
declare i64 @getDate()
declare i64 @getGmDate()
declare i64 @getTime()
declare i64 @getGmTime()
declare i8* @ulimStk()
declare i64 @fileInfo(i1, i8*, i64*)
declare void @pollIn(i32, i64*)
declare void @pollOut(i32, i64*)
declare void @pollIgn(i64*)
declare i32 @gPoll(i64*, i32, i64)
declare i1 @readyIn(i64*)
declare i1 @readyOut(i64*)
declare i32 @rdLock(i32, i64, i64, i1)
declare i32 @wrLock(i32, i64, i64, i1)
declare i32 @unLock(i32, i64, i64)
declare i32 @getLock(i32, i64, i64)
@JmpBufSize = external global i64
@QuitRst = external global i8
declare i8* @dlOpen(i8*)
declare i8* @ffiPrep(i8*, i8*, i64)
declare i64 @ffiCall(i8*, i64)
declare i64 @boxFloat(i32, i64)
declare i64 @boxFlt()
declare i64 @boxDouble(i64, i64)
declare i64 @boxDbl()
declare void @bufFloat(i64, i64, i8*)
declare void @bufDouble(i64, i64, i8*)
declare i1 @isLowc(i32)
declare i1 @isUppc(i32)
declare i1 @isLetterOrDigit(i32)
declare i32 @toUpperCase(i32)
declare i32 @toLowerCase(i32)

define i64 @execAt(i64) align 8 {
$1:
; # (let At (save (val $At)) (exec Prg) (set $At At))
; # (val $At)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %2 = load i64, i64* %1
; # (save (val $At))
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %2, i64* %7
  %8 = add i64 %6, 8
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %10
; # (exec Prg)
  br label %$2
$2:
  %11 = phi i64 [%0, %$1], [%23, %$5] ; # Prg
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
  %16 = and i64 %13, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$3, label %$4
$3:
  %18 = phi i64 [%15, %$2] ; # Prg
  %19 = call i64 @evList(i64 %13)
  br label %$4
$4:
  %20 = phi i64 [%15, %$2], [%18, %$3] ; # Prg
  %21 = and i64 %20, 15
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$6, label %$5
$5:
  %23 = phi i64 [%20, %$4] ; # Prg
  br label %$2
$6:
  %24 = phi i64 [%20, %$4] ; # Prg
  %25 = phi i64 [0, %$4] ; # ->
; # (set $At At)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %2, i64* %26
; # (drop *Safe)
  %27 = inttoptr i64 %6 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %30
  ret i64 %2
}

define i64 @runAt(i64) align 8 {
$1:
; # (let At (save (val $At)) (prog1 (run Prg) (set $At At)))
; # (val $At)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %2 = load i64, i64* %1
; # (save (val $At))
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %2, i64* %7
  %8 = add i64 %6, 8
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %10
; # (prog1 (run Prg) (set $At At))
; # (run Prg)
  br label %$2
$2:
  %11 = phi i64 [%0, %$1], [%33, %$11] ; # Prg
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
  %16 = and i64 %15, 15
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$5, label %$3
$5:
  %18 = phi i64 [%15, %$2] ; # Prg
  %19 = and i64 %13, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$8, label %$7
$8:
  br label %$6
$7:
  %21 = and i64 %13, 8
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$10, label %$9
$10:
  %23 = inttoptr i64 %13 to i64*
  %24 = load i64, i64* %23
  br label %$6
$9:
  %25 = call i64 @evList(i64 %13)
  br label %$6
$6:
  %26 = phi i64 [%13, %$8], [%24, %$10], [%25, %$9] ; # ->
  br label %$4
$3:
  %27 = phi i64 [%15, %$2] ; # Prg
  %28 = and i64 %13, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$12, label %$11
$12:
  %30 = phi i64 [%27, %$3] ; # Prg
  %31 = call i64 @evList(i64 %13)
  %32 = icmp ne i64 %31, 0
  br label %$11
$11:
  %33 = phi i64 [%27, %$3], [%30, %$12] ; # Prg
  %34 = phi i1 [0, %$3], [%32, %$12] ; # ->
  br label %$2
$4:
  %35 = phi i64 [%18, %$6] ; # Prg
  %36 = phi i64 [%26, %$6] ; # ->
; # (set $At At)
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %2, i64* %37
; # (drop *Safe)
  %38 = inttoptr i64 %6 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  ret i64 %36
}

define i64 @wrnl() align 8 {
$1:
; # (write 1 ($ "^J") 1)
  %0 = call i64 @write(i32 1, i8* bitcast ([2 x i8]* @$1 to i8*), i64 1)
  ret i64 %0
}

define i64 @dbg(i64, i64) align 8 {
$1:
; # (let (Out (val $OutFile) Put (val (i8** $Put))) (set $OutFile (va...
; # (val $OutFile)
  %2 = load i8*, i8** @$OutFile
; # (i8** $Put)
  %3 = bitcast void(i8)** @$Put to i8**
; # (val (i8** $Put))
  %4 = load i8*, i8** %3
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %5 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %6 = getelementptr i8*, i8** %5, i32 2
  %7 = load i8*, i8** %6
  store i8* %7, i8** @$OutFile
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$Put
; # (outWord N)
  call void @outWord(i64 %0)
; # (when X (space) (print X))
  %8 = icmp ne i64 %1, 0
  br i1 %8, label %$2, label %$3
$2:
; # (space)
  call void @space()
; # (print X)
  call void @print(i64 %1)
  br label %$3
$3:
; # (newline)
  call void @newline()
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %9 = bitcast void(i8)** @$Put to i8**
  store i8* %4, i8** %9
  store i8* %2, i8** @$OutFile
  ret i64 %1
}

define void @stop(i8*) align 8 {
$1:
; # ((coroutine Crt) tag 0)
  %1 = ptrtoint i8* %0 to i64
  %2 = inttoptr i64 %1 to i64*
  store i64 0, i64* %2
; # (while ((coroutine Crt) nxt) (setq Crt @))
  br label %$2
$2:
  %3 = phi i8* [%0, %$1], [%6, %$3] ; # Crt
; # ((coroutine Crt) nxt)
  %4 = getelementptr i8, i8* %3, i32 16
  %5 = bitcast i8* %4 to i8**
  %6 = load i8*, i8** %5
  %7 = icmp ne i8* %6, null
  br i1 %7, label %$3, label %$4
$3:
  %8 = phi i8* [%3, %$2] ; # Crt
  br label %$2
$4:
  %9 = phi i8* [%3, %$2] ; # Crt
; # (until ((coroutine Crt) tag) (setq Crt ((coroutine Crt) prv)) ((c...
  br label %$5
$5:
  %10 = phi i8* [%9, %$4], [%18, %$6] ; # Crt
; # ((coroutine Crt) tag)
  %11 = ptrtoint i8* %10 to i64
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$6
$6:
  %15 = phi i8* [%10, %$5] ; # Crt
; # ((coroutine Crt) prv)
  %16 = getelementptr i8, i8* %15, i32 8
  %17 = bitcast i8* %16 to i8**
  %18 = load i8*, i8** %17
; # ((coroutine Crt) nxt null)
  %19 = getelementptr i8, i8* %18, i32 16
  %20 = bitcast i8* %19 to i8**
  store i8* null, i8** %20
  br label %$5
$7:
  %21 = phi i8* [%10, %$5] ; # Crt
  ret void
}

define void @unwind(i8*) align 8 {
$1:
; # (let (Ca (val $Catch) Bnd (val $Bind)) (while Ca (let Ca: (caFram...
; # (val $Catch)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (val $Bind)
  %2 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %3 = load i64, i64* %2
; # (while Ca (let Ca: (caFrame Ca) (while (and Bnd (<> Bnd (Ca: (env...
  br label %$2
$2:
  %4 = phi i8* [%1, %$1], [%183, %$36] ; # Ca
  %5 = phi i64 [%3, %$1], [%181, %$36] ; # Bnd
  %6 = icmp ne i8* %4, null
  br i1 %6, label %$3, label %$4
$3:
  %7 = phi i8* [%4, %$2] ; # Ca
  %8 = phi i64 [%5, %$2] ; # Bnd
; # (let Ca: (caFrame Ca) (while (and Bnd (<> Bnd (Ca: (env $Bind any...
; # (while (and Bnd (<> Bnd (Ca: (env $Bind any)))) (set (val 2 Bnd) ...
  br label %$5
$5:
  %9 = phi i8* [%7, %$3], [%23, %$8] ; # Ca
  %10 = phi i64 [%8, %$3], [%33, %$8] ; # Bnd
; # (and Bnd (<> Bnd (Ca: (env $Bind any))))
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$7, label %$6
$7:
  %12 = phi i8* [%9, %$5] ; # Ca
  %13 = phi i64 [%10, %$5] ; # Bnd
; # (Ca: (env $Bind any))
  %14 = getelementptr i8, i8* %7, i32 32
  %15 = getelementptr i8, i8* %14, i32 8
  %16 = ptrtoint i8* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
; # (<> Bnd (Ca: (env $Bind any)))
  %19 = icmp ne i64 %13, %18
  br label %$6
$6:
  %20 = phi i8* [%9, %$5], [%12, %$7] ; # Ca
  %21 = phi i64 [%10, %$5], [%13, %$7] ; # Bnd
  %22 = phi i1 [0, %$5], [%19, %$7] ; # ->
  br i1 %22, label %$8, label %$9
$8:
  %23 = phi i8* [%20, %$6] ; # Ca
  %24 = phi i64 [%21, %$6] ; # Bnd
; # (set (val 2 Bnd) (val Bnd))
; # (val 2 Bnd)
  %25 = inttoptr i64 %24 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (val Bnd)
  %28 = inttoptr i64 %24 to i64*
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %27 to i64*
  store i64 %29, i64* %30
; # (val 3 Bnd)
  %31 = inttoptr i64 %24 to i64*
  %32 = getelementptr i64, i64* %31, i32 2
  %33 = load i64, i64* %32
  br label %$5
$9:
  %34 = phi i8* [%20, %$6] ; # Ca
  %35 = phi i64 [%21, %$6] ; # Bnd
; # (until (== (val $CtlFrames) (Ca: (env $CtlFrames i8*))) (popCtlFi...
  br label %$10
$10:
  %36 = phi i8* [%34, %$9], [%44, %$11] ; # Ca
  %37 = phi i64 [%35, %$9], [%45, %$11] ; # Bnd
; # (val $CtlFrames)
  %38 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 56) to i8**)
; # (Ca: (env $CtlFrames i8*))
  %39 = getelementptr i8, i8* %7, i32 32
  %40 = getelementptr i8, i8* %39, i32 56
  %41 = bitcast i8* %40 to i8**
  %42 = load i8*, i8** %41
; # (== (val $CtlFrames) (Ca: (env $CtlFrames i8*)))
  %43 = icmp eq i8* %38, %42
  br i1 %43, label %$12, label %$11
$11:
  %44 = phi i8* [%36, %$10] ; # Ca
  %45 = phi i64 [%37, %$10] ; # Bnd
; # (popCtlFiles)
  call void @popCtlFiles()
  br label %$10
$12:
  %46 = phi i8* [%36, %$10] ; # Ca
  %47 = phi i64 [%37, %$10] ; # Bnd
; # (until (== (val $ErrFrames) (Ca: (env $ErrFrames i8*))) (popErrFi...
  br label %$13
$13:
  %48 = phi i8* [%46, %$12], [%56, %$14] ; # Ca
  %49 = phi i64 [%47, %$12], [%57, %$14] ; # Bnd
; # (val $ErrFrames)
  %50 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 48) to i8**)
; # (Ca: (env $ErrFrames i8*))
  %51 = getelementptr i8, i8* %7, i32 32
  %52 = getelementptr i8, i8* %51, i32 48
  %53 = bitcast i8* %52 to i8**
  %54 = load i8*, i8** %53
; # (== (val $ErrFrames) (Ca: (env $ErrFrames i8*)))
  %55 = icmp eq i8* %50, %54
  br i1 %55, label %$15, label %$14
$14:
  %56 = phi i8* [%48, %$13] ; # Ca
  %57 = phi i64 [%49, %$13] ; # Bnd
; # (popErrFiles)
  call void @popErrFiles()
  br label %$13
$15:
  %58 = phi i8* [%48, %$13] ; # Ca
  %59 = phi i64 [%49, %$13] ; # Bnd
; # (unless (== (val $OutFrames) (Ca: (env $OutFrames i8*))) (loop (p...
; # (val $OutFrames)
  %60 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (Ca: (env $OutFrames i8*))
  %61 = getelementptr i8, i8* %7, i32 32
  %62 = getelementptr i8, i8* %61, i32 40
  %63 = bitcast i8* %62 to i8**
  %64 = load i8*, i8** %63
; # (== (val $OutFrames) (Ca: (env $OutFrames i8*)))
  %65 = icmp eq i8* %60, %64
  br i1 %65, label %$17, label %$16
$16:
  %66 = phi i8* [%58, %$15] ; # Ca
  %67 = phi i64 [%59, %$15] ; # Bnd
; # (loop (popOutFiles) (? (== (val $OutFrames) (Ca: (env $OutFrames ...
  br label %$18
$18:
  %68 = phi i8* [%66, %$16], [%76, %$19] ; # Ca
  %69 = phi i64 [%67, %$16], [%77, %$19] ; # Bnd
; # (popOutFiles)
  call void @popOutFiles()
; # (? (== (val $OutFrames) (Ca: (env $OutFrames i8*))))
; # (val $OutFrames)
  %70 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (Ca: (env $OutFrames i8*))
  %71 = getelementptr i8, i8* %7, i32 32
  %72 = getelementptr i8, i8* %71, i32 40
  %73 = bitcast i8* %72 to i8**
  %74 = load i8*, i8** %73
; # (== (val $OutFrames) (Ca: (env $OutFrames i8*)))
  %75 = icmp eq i8* %70, %74
  br i1 %75, label %$20, label %$19
$19:
  %76 = phi i8* [%68, %$18] ; # Ca
  %77 = phi i64 [%69, %$18] ; # Bnd
  br label %$18
$20:
  %78 = phi i8* [%68, %$18] ; # Ca
  %79 = phi i64 [%69, %$18] ; # Bnd
  %80 = phi i64 [0, %$18] ; # ->
; # (tosOutFile)
  call void @tosOutFile()
  br label %$17
$17:
  %81 = phi i8* [%58, %$15], [%78, %$20] ; # Ca
  %82 = phi i64 [%59, %$15], [%79, %$20] ; # Bnd
; # (unless (== (val $InFrames) (Ca: (env $InFrames i8*))) (loop (pop...
; # (val $InFrames)
  %83 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (Ca: (env $InFrames i8*))
  %84 = getelementptr i8, i8* %7, i32 32
  %85 = getelementptr i8, i8* %84, i32 32
  %86 = bitcast i8* %85 to i8**
  %87 = load i8*, i8** %86
; # (== (val $InFrames) (Ca: (env $InFrames i8*)))
  %88 = icmp eq i8* %83, %87
  br i1 %88, label %$22, label %$21
$21:
  %89 = phi i8* [%81, %$17] ; # Ca
  %90 = phi i64 [%82, %$17] ; # Bnd
; # (loop (popInFiles) (? (== (val $InFrames) (Ca: (env $InFrames i8*...
  br label %$23
$23:
  %91 = phi i8* [%89, %$21], [%99, %$24] ; # Ca
  %92 = phi i64 [%90, %$21], [%100, %$24] ; # Bnd
; # (popInFiles)
  call void @popInFiles()
; # (? (== (val $InFrames) (Ca: (env $InFrames i8*))))
; # (val $InFrames)
  %93 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (Ca: (env $InFrames i8*))
  %94 = getelementptr i8, i8* %7, i32 32
  %95 = getelementptr i8, i8* %94, i32 32
  %96 = bitcast i8* %95 to i8**
  %97 = load i8*, i8** %96
; # (== (val $InFrames) (Ca: (env $InFrames i8*)))
  %98 = icmp eq i8* %93, %97
  br i1 %98, label %$25, label %$24
$24:
  %99 = phi i8* [%91, %$23] ; # Ca
  %100 = phi i64 [%92, %$23] ; # Bnd
  br label %$23
$25:
  %101 = phi i8* [%91, %$23] ; # Ca
  %102 = phi i64 [%92, %$23] ; # Bnd
  %103 = phi i64 [0, %$23] ; # ->
; # (tosInFile)
  call void @tosInFile()
  br label %$22
$22:
  %104 = phi i8* [%81, %$17], [%101, %$25] ; # Ca
  %105 = phi i64 [%82, %$17], [%102, %$25] ; # Bnd
; # (let (Src (val $Current) Dst (Ca: co)) (unless Dst (setq Dst (val...
; # (val $Current)
  %106 = load i8*, i8** @$Current
; # (Ca: co)
  %107 = getelementptr i8, i8* %7, i32 24
  %108 = bitcast i8* %107 to i8**
  %109 = load i8*, i8** %108
; # (unless Dst (setq Dst (val $Coroutines)))
  %110 = icmp ne i8* %109, null
  br i1 %110, label %$27, label %$26
$26:
  %111 = phi i8* [%104, %$22] ; # Ca
  %112 = phi i64 [%105, %$22] ; # Bnd
  %113 = phi i8* [%109, %$22] ; # Dst
; # (val $Coroutines)
  %114 = load i8*, i8** @$Coroutines
  br label %$27
$27:
  %115 = phi i8* [%104, %$22], [%111, %$26] ; # Ca
  %116 = phi i64 [%105, %$22], [%112, %$26] ; # Bnd
  %117 = phi i8* [%109, %$22], [%114, %$26] ; # Dst
; # (unless (== Src Dst) (stop Src) (let Crt: (coroutine (set $Curren...
; # (== Src Dst)
  %118 = icmp eq i8* %106, %117
  br i1 %118, label %$29, label %$28
$28:
  %119 = phi i8* [%115, %$27] ; # Ca
  %120 = phi i64 [%116, %$27] ; # Bnd
  %121 = phi i8* [%117, %$27] ; # Dst
; # (stop Src)
  call void @stop(i8* %106)
; # (let Crt: (coroutine (set $Current Dst)) (set $StkLimit (+ (Crt: ...
; # (set $Current Dst)
  store i8* %121, i8** @$Current
; # (set $StkLimit (+ (Crt: lim) 4096))
; # (Crt: lim)
  %122 = getelementptr i8, i8* %121, i32 40
  %123 = bitcast i8* %122 to i8**
  %124 = load i8*, i8** %123
; # (+ (Crt: lim) 4096)
  %125 = getelementptr i8, i8* %124, i32 4096
  store i8* %125, i8** @$StkLimit
; # (set $At (Crt: at))
; # (Crt: at)
  %126 = getelementptr i8, i8* %121, i32 48
  %127 = ptrtoint i8* %126 to i64
  %128 = inttoptr i64 %127 to i64*
  %129 = load i64, i64* %128
  %130 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %129, i64* %130
  br label %$29
$29:
  %131 = phi i8* [%115, %$27], [%119, %$28] ; # Ca
  %132 = phi i64 [%116, %$27], [%120, %$28] ; # Bnd
  %133 = phi i8* [%117, %$27], [%121, %$28] ; # Dst
; # (Ca:)
; # (getCaEnv (Ca:))
  %134 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i8*
  %135 = getelementptr i8, i8* %7, i32 32
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %134, i8* %135, i64 144, i1 0)
  %136 = getelementptr i8, i8* %7, i32 176
  %137 = ptrtoint i8* %136 to i64
  %138 = inttoptr i64 %137 to i64*
  %139 = load i64, i64* %138
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %139, i64* %140
  %141 = getelementptr i8, i8* %7, i32 184
  %142 = ptrtoint i8* %141 to i64
  %143 = inttoptr i64 %142 to i64*
  %144 = load i64, i64* %143
  %145 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  store i64 %144, i64* %145
  %146 = getelementptr i8, i8* %7, i32 192
  %147 = ptrtoint i8* %146 to i64
  %148 = inttoptr i64 %147 to i64*
  %149 = load i64, i64* %148
  %150 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %151 = getelementptr i64, i64* %150, i32 1
  store i64 %149, i64* %151
  %152 = getelementptr i8, i8* %7, i32 200
  %153 = ptrtoint i8* %152 to i64
  %154 = inttoptr i64 %153 to i64*
  %155 = load i64, i64* %154
  %156 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  store i64 %155, i64* %156
  %157 = getelementptr i8, i8* %7, i32 208
  %158 = ptrtoint i8* %157 to i64
  %159 = inttoptr i64 %158 to i64*
  %160 = load i64, i64* %159
  %161 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %162 = getelementptr i64, i64* %161, i32 1
  store i64 %160, i64* %162
; # (Ca: fin)
  %163 = getelementptr i8, i8* %7, i32 16
  %164 = ptrtoint i8* %163 to i64
  %165 = inttoptr i64 %164 to i64*
  %166 = load i64, i64* %165
; # (eval (Ca: fin))
  %167 = and i64 %166, 6
  %168 = icmp ne i64 %167, 0
  br i1 %168, label %$32, label %$31
$32:
  br label %$30
$31:
  %169 = and i64 %166, 8
  %170 = icmp ne i64 %169, 0
  br i1 %170, label %$34, label %$33
$34:
  %171 = inttoptr i64 %166 to i64*
  %172 = load i64, i64* %171
  br label %$30
$33:
  %173 = call i64 @evList(i64 %166)
  br label %$30
$30:
  %174 = phi i64 [%166, %$32], [%172, %$34], [%173, %$33] ; # ->
; # (set $Catch (Ca: link))
; # (Ca: link)
  %175 = bitcast i8* %7 to i8**
  %176 = load i8*, i8** %175
  store i8* %176, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (when (== Ca Catch) (ret))
; # (== Ca Catch)
  %177 = icmp eq i8* %131, %0
  br i1 %177, label %$35, label %$36
$35:
  %178 = phi i8* [%131, %$30] ; # Ca
  %179 = phi i64 [%132, %$30] ; # Bnd
; # (ret)
  ret void
$36:
  %180 = phi i8* [%131, %$30] ; # Ca
  %181 = phi i64 [%132, %$30] ; # Bnd
; # (Ca: link)
  %182 = bitcast i8* %7 to i8**
  %183 = load i8*, i8** %182
  br label %$2
$4:
  %184 = phi i8* [%4, %$2] ; # Ca
  %185 = phi i64 [%5, %$2] ; # Bnd
; # (while Bnd (set (val 2 Bnd) (val Bnd)) (setq Bnd (val 3 Bnd)))
  br label %$37
$37:
  %186 = phi i8* [%184, %$4], [%189, %$38] ; # Ca
  %187 = phi i64 [%185, %$4], [%199, %$38] ; # Bnd
  %188 = icmp ne i64 %187, 0
  br i1 %188, label %$38, label %$39
$38:
  %189 = phi i8* [%186, %$37] ; # Ca
  %190 = phi i64 [%187, %$37] ; # Bnd
; # (set (val 2 Bnd) (val Bnd))
; # (val 2 Bnd)
  %191 = inttoptr i64 %190 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
; # (val Bnd)
  %194 = inttoptr i64 %190 to i64*
  %195 = load i64, i64* %194
  %196 = inttoptr i64 %193 to i64*
  store i64 %195, i64* %196
; # (val 3 Bnd)
  %197 = inttoptr i64 %190 to i64*
  %198 = getelementptr i64, i64* %197, i32 2
  %199 = load i64, i64* %198
  br label %$37
$39:
  %200 = phi i8* [%186, %$37] ; # Ca
  %201 = phi i64 [%187, %$37] ; # Bnd
; # (set $Bind 0)
  %202 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 0, i64* %202
; # (while (val $CtlFrames) (popCtlFiles))
  br label %$40
$40:
  %203 = phi i8* [%200, %$39], [%207, %$41] ; # Ca
  %204 = phi i64 [%201, %$39], [%208, %$41] ; # Bnd
; # (val $CtlFrames)
  %205 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 56) to i8**)
  %206 = icmp ne i8* %205, null
  br i1 %206, label %$41, label %$42
$41:
  %207 = phi i8* [%203, %$40] ; # Ca
  %208 = phi i64 [%204, %$40] ; # Bnd
; # (popCtlFiles)
  call void @popCtlFiles()
  br label %$40
$42:
  %209 = phi i8* [%203, %$40] ; # Ca
  %210 = phi i64 [%204, %$40] ; # Bnd
; # (while (val $ErrFrames) (popErrFiles))
  br label %$43
$43:
  %211 = phi i8* [%209, %$42], [%215, %$44] ; # Ca
  %212 = phi i64 [%210, %$42], [%216, %$44] ; # Bnd
; # (val $ErrFrames)
  %213 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 48) to i8**)
  %214 = icmp ne i8* %213, null
  br i1 %214, label %$44, label %$45
$44:
  %215 = phi i8* [%211, %$43] ; # Ca
  %216 = phi i64 [%212, %$43] ; # Bnd
; # (popErrFiles)
  call void @popErrFiles()
  br label %$43
$45:
  %217 = phi i8* [%211, %$43] ; # Ca
  %218 = phi i64 [%212, %$43] ; # Bnd
; # (unless (== (val $OutFrames) (val $Stdout)) (loop (popOutFiles) (...
; # (val $OutFrames)
  %219 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (val $Stdout)
  %220 = load i8*, i8** @$Stdout
; # (== (val $OutFrames) (val $Stdout))
  %221 = icmp eq i8* %219, %220
  br i1 %221, label %$47, label %$46
$46:
  %222 = phi i8* [%217, %$45] ; # Ca
  %223 = phi i64 [%218, %$45] ; # Bnd
; # (loop (popOutFiles) (? (== (val $OutFrames) (val $Stdout))))
  br label %$48
$48:
  %224 = phi i8* [%222, %$46], [%229, %$49] ; # Ca
  %225 = phi i64 [%223, %$46], [%230, %$49] ; # Bnd
; # (popOutFiles)
  call void @popOutFiles()
; # (? (== (val $OutFrames) (val $Stdout)))
; # (val $OutFrames)
  %226 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (val $Stdout)
  %227 = load i8*, i8** @$Stdout
; # (== (val $OutFrames) (val $Stdout))
  %228 = icmp eq i8* %226, %227
  br i1 %228, label %$50, label %$49
$49:
  %229 = phi i8* [%224, %$48] ; # Ca
  %230 = phi i64 [%225, %$48] ; # Bnd
  br label %$48
$50:
  %231 = phi i8* [%224, %$48] ; # Ca
  %232 = phi i64 [%225, %$48] ; # Bnd
  %233 = phi i64 [0, %$48] ; # ->
; # (tosOutFile)
  call void @tosOutFile()
  br label %$47
$47:
  %234 = phi i8* [%217, %$45], [%231, %$50] ; # Ca
  %235 = phi i64 [%218, %$45], [%232, %$50] ; # Bnd
; # (unless (== (val $InFrames) (val $Stdin)) (loop (popInFiles) (? (...
; # (val $InFrames)
  %236 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (val $Stdin)
  %237 = load i8*, i8** @$Stdin
; # (== (val $InFrames) (val $Stdin))
  %238 = icmp eq i8* %236, %237
  br i1 %238, label %$52, label %$51
$51:
  %239 = phi i8* [%234, %$47] ; # Ca
  %240 = phi i64 [%235, %$47] ; # Bnd
; # (loop (popInFiles) (? (== (val $InFrames) (val $Stdin))))
  br label %$53
$53:
  %241 = phi i8* [%239, %$51], [%246, %$54] ; # Ca
  %242 = phi i64 [%240, %$51], [%247, %$54] ; # Bnd
; # (popInFiles)
  call void @popInFiles()
; # (? (== (val $InFrames) (val $Stdin)))
; # (val $InFrames)
  %243 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (val $Stdin)
  %244 = load i8*, i8** @$Stdin
; # (== (val $InFrames) (val $Stdin))
  %245 = icmp eq i8* %243, %244
  br i1 %245, label %$55, label %$54
$54:
  %246 = phi i8* [%241, %$53] ; # Ca
  %247 = phi i64 [%242, %$53] ; # Bnd
  br label %$53
$55:
  %248 = phi i8* [%241, %$53] ; # Ca
  %249 = phi i64 [%242, %$53] ; # Bnd
  %250 = phi i64 [0, %$53] ; # ->
; # (tosInFile)
  call void @tosInFile()
  br label %$52
$52:
  %251 = phi i8* [%234, %$47], [%248, %$55] ; # Ca
  %252 = phi i64 [%235, %$47], [%249, %$55] ; # Bnd
  ret void
}

define void @finish(i32) align 8 {
$1:
; # (setCooked)
  call void @setCooked()
; # (exit N)
  call void @exit(i32 %0)
  unreachable
}

define void @giveup(i8*, i8*) align 8 {
$1:
; # (stderrMsg Fmt Msg)
  %2 = call i8* @stderrMsg(i8* %0, i8* %1)
; # (finish 1)
  call void @finish(i32 1)
  unreachable
}

define void @bye(i32) align 8 {
$1:
; # (unless (val $InBye) (set $InBye YES) (unwind null) (exec (val $B...
; # (val $InBye)
  %1 = load i1, i1* @$InBye
  br i1 %1, label %$3, label %$2
$2:
; # (set $InBye YES)
  store i1 1, i1* @$InBye
; # (unwind null)
  call void @unwind(i8* null)
; # (val $Bye)
  %2 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 808) to i64) to i64*
  %3 = load i64, i64* %2
; # (exec (val $Bye))
  br label %$4
$4:
  %4 = phi i64 [%3, %$2], [%16, %$7] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %6, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$5, label %$6
$5:
  %11 = phi i64 [%8, %$4] ; # Prg
  %12 = call i64 @evList(i64 %6)
  br label %$6
$6:
  %13 = phi i64 [%8, %$4], [%11, %$5] ; # Prg
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$7
$7:
  %16 = phi i64 [%13, %$6] ; # Prg
  br label %$4
$8:
  %17 = phi i64 [%13, %$6] ; # Prg
  %18 = phi i64 [0, %$6] ; # ->
  br label %$3
$3:
; # (flushAll)
  call void @flushAll()
; # (finish N)
  call void @finish(i32 %0)
  unreachable
}

define void @execErr(i8*) align 8 {
$1:
; # (stderrMsg ($ "%s: Can't exec^J") Cmd)
  %1 = call i8* @stderrMsg(i8* bitcast ([16 x i8]* @$2 to i8*), i8* %0)
; # (exit 127)
  call void @exit(i32 127)
  unreachable
}

define i8* @alloc(i8*, i64) align 8 {
$1:
; # (unless (realloc Ptr Siz) (giveup ($ "No memory") null))
; # (realloc Ptr Siz)
  %2 = call i8* @realloc(i8* %0, i64 %1)
  %3 = icmp ne i8* %2, null
  br i1 %3, label %$3, label %$2
$2:
; # (giveup ($ "No memory") null)
  call void @giveup(i8* bitcast ([10 x i8]* @$3 to i8*), i8* null)
  unreachable
$3:
  ret i8* %2
}

define void @heapAlloc() align 8 {
$1:
; # (let (H (any (alloc null (* 8 (inc HEAP)))) P (ofs H HEAP) A (val...
; # (inc HEAP)
; # (* 8 (inc HEAP))
; # (alloc null (* 8 (inc HEAP)))
  %0 = call i8* @alloc(i8* null, i64 1048584)
; # (any (alloc null (* 8 (inc HEAP))))
  %1 = ptrtoint i8* %0 to i64
; # (ofs H HEAP)
  %2 = add i64 %1, 1048576
; # (val $Avail)
  %3 = load i64, i64* @$Avail
; # (set P (val $Heaps) $Heaps H)
; # (val $Heaps)
  %4 = load i64, i64* @$Heaps
  %5 = inttoptr i64 %2 to i64*
  store i64 %4, i64* %5
  store i64 %1, i64* @$Heaps
; # (loop (set (setq P (ofs P -2)) A) (? (== (setq A P) H)))
  br label %$2
$2:
  %6 = phi i64 [%2, %$1], [%11, %$3] ; # P
  %7 = phi i64 [%3, %$1], [%12, %$3] ; # A
; # (set (setq P (ofs P -2)) A)
; # (ofs P -2)
  %8 = add i64 %6, -16
  %9 = inttoptr i64 %8 to i64*
  store i64 %7, i64* %9
; # (? (== (setq A P) H))
; # (== (setq A P) H)
  %10 = icmp eq i64 %8, %1
  br i1 %10, label %$4, label %$3
$3:
  %11 = phi i64 [%8, %$2] ; # P
  %12 = phi i64 [%8, %$2] ; # A
  br label %$2
$4:
  %13 = phi i64 [%8, %$2] ; # P
  %14 = phi i64 [%8, %$2] ; # A
  %15 = phi i64 [0, %$2] ; # ->
; # (set $Avail A)
  store i64 %14, i64* @$Avail
  ret void
}

define void @sig(i32) align 8 {
$1:
; # (if (val $TtyPid) (kill @ N) (set $Signal (+ (val $Signal) 1)) (l...
; # (val $TtyPid)
  %1 = load i32, i32* @$TtyPid
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (kill @ N)
  %3 = call i32 @kill(i32 %1, i32 %0)
  br label %$4
$3:
; # (set $Signal (+ (val $Signal) 1))
; # (val $Signal)
  %4 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (+ (val $Signal) 1)
  %5 = add i32 %4, 1
  store i32 %5, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (let P (ofs $Signal (gSignal N)) (set P (+ (val P) 1)))
; # (gSignal N)
  %6 = call i32 @gSignal(i32 %0)
; # (ofs $Signal (gSignal N))
  %7 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 %6
; # (set P (+ (val P) 1))
; # (val P)
  %8 = load i32, i32* %7
; # (+ (val P) 1)
  %9 = add i32 %8, 1
  store i32 %9, i32* %7
  br label %$4
$4:
  %10 = phi i32 [%3, %$2], [%9, %$3] ; # ->
  ret void
}

define void @sigTerm(i32) align 8 {
$1:
; # (if (val $TtyPid) (kill @ N) (set $Signal (+ (val $Signal) 1)) (l...
; # (val $TtyPid)
  %1 = load i32, i32* @$TtyPid
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (kill @ N)
  %3 = call i32 @kill(i32 %1, i32 %0)
  br label %$4
$3:
; # (set $Signal (+ (val $Signal) 1))
; # (val $Signal)
  %4 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (+ (val $Signal) 1)
  %5 = add i32 %4, 1
  store i32 %5, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (let P (ofs $Signal (gSignal (val SIGTERM Sig))) (set P (+ (val P...
; # (val SIGTERM Sig)
  %6 = getelementptr i32, i32* @Sig, i32 6
  %7 = load i32, i32* %6
; # (gSignal (val SIGTERM Sig))
  %8 = call i32 @gSignal(i32 %7)
; # (ofs $Signal (gSignal (val SIGTERM Sig)))
  %9 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 %8
; # (set P (+ (val P) 1))
; # (val P)
  %10 = load i32, i32* %9
; # (+ (val P) 1)
  %11 = add i32 %10, 1
  store i32 %11, i32* %9
  br label %$4
$4:
  %12 = phi i32 [%3, %$2], [%11, %$3] ; # ->
  ret void
}

define void @sighandler(i64) align 8 {
$1:
; # (unless (val $Protect) (set $Protect 1) (let P T (loop (cond ((va...
; # (val $Protect)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
; # (set $Protect 1)
  store i32 1, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (let P T (loop (cond ((val (setq P (ofs $Signal SIGIO))) (set P (...
; # (loop (cond ((val (setq P (ofs $Signal SIGIO))) (set P (dec @)) (...
  br label %$4
$4:
; # (cond ((val (setq P (ofs $Signal SIGIO))) (set P (dec @)) (set $S...
; # (ofs $Signal SIGIO)
  %3 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 15
; # (val (setq P (ofs $Signal SIGIO)))
  %4 = load i32, i32* %3
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %$7, label %$6
$7:
  %6 = phi i32* [%3, %$4] ; # P
; # (set P (dec @))
; # (dec @)
  %7 = sub i32 %4, 1
  store i32 %7, i32* %6
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %8 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %9 = sub i32 %8, 1
  store i32 %9, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (val $Sigio)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %11 = load i64, i64* %10
; # (execAt (val $Sigio))
  %12 = call i64 @execAt(i64 %11)
  br label %$5
$6:
  %13 = phi i32* [%3, %$4] ; # P
; # (ofs $Signal SIGUSR1)
  %14 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 3
; # (val (setq P (ofs $Signal SIGUSR1)))
  %15 = load i32, i32* %14
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i32* [%14, %$6] ; # P
; # (set P (dec @))
; # (dec @)
  %18 = sub i32 %15, 1
  store i32 %18, i32* %17
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %19 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %20 = sub i32 %19, 1
  store i32 %20, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (val $Sig1)
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 632) to i64) to i64*
  %22 = load i64, i64* %21
; # (execAt (val $Sig1))
  %23 = call i64 @execAt(i64 %22)
  br label %$5
$8:
  %24 = phi i32* [%14, %$6] ; # P
; # (ofs $Signal SIGUSR2)
  %25 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 4
; # (val (setq P (ofs $Signal SIGUSR2)))
  %26 = load i32, i32* %25
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$11, label %$10
$11:
  %28 = phi i32* [%25, %$8] ; # P
; # (set P (dec @))
; # (dec @)
  %29 = sub i32 %26, 1
  store i32 %29, i32* %28
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %30 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %31 = sub i32 %30, 1
  store i32 %31, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (val $Sig2)
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 648) to i64) to i64*
  %33 = load i64, i64* %32
; # (execAt (val $Sig2))
  %34 = call i64 @execAt(i64 %33)
  br label %$5
$10:
  %35 = phi i32* [%25, %$8] ; # P
; # (ofs $Signal SIGALRM)
  %36 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 6
; # (val (setq P (ofs $Signal SIGALRM)))
  %37 = load i32, i32* %36
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %$13, label %$12
$13:
  %39 = phi i32* [%36, %$10] ; # P
; # (set P (dec @))
; # (dec @)
  %40 = sub i32 %37, 1
  store i32 %40, i32* %39
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %41 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %42 = sub i32 %41, 1
  store i32 %42, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (val $Alarm)
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 24) to i64) to i64*
  %44 = load i64, i64* %43
; # (execAt (val $Alarm))
  %45 = call i64 @execAt(i64 %44)
  br label %$5
$12:
  %46 = phi i32* [%36, %$10] ; # P
; # (ofs $Signal SIGHUP)
  %47 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 1
; # (val (setq P (ofs $Signal SIGHUP)))
  %48 = load i32, i32* %47
  %49 = icmp ne i32 %48, 0
  br i1 %49, label %$15, label %$14
$15:
  %50 = phi i32* [%47, %$12] ; # P
; # (set P (dec @))
; # (dec @)
  %51 = sub i32 %48, 1
  store i32 %51, i32* %50
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %52 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %53 = sub i32 %52, 1
  store i32 %53, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (val $Hup)
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 616) to i64) to i64*
  %55 = load i64, i64* %54
; # (execAt (val $Hup))
  %56 = call i64 @execAt(i64 %55)
  br label %$5
$14:
  %57 = phi i32* [%47, %$12] ; # P
; # (ofs $Signal SIGINT)
  %58 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 2
; # (val (setq P (ofs $Signal SIGINT)))
  %59 = load i32, i32* %58
  %60 = icmp ne i32 %59, 0
  br i1 %60, label %$17, label %$16
$17:
  %61 = phi i32* [%58, %$14] ; # P
; # (set P (dec @))
; # (dec @)
  %62 = sub i32 %59, 1
  store i32 %62, i32* %61
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %63 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %64 = sub i32 %63, 1
  store i32 %64, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (unless (val $PRepl) (wrnl) (rlSigBeg) (brkLoad (if Exe @ $Nil)) ...
; # (val $PRepl)
  %65 = load i1, i1* @$PRepl
  br i1 %65, label %$19, label %$18
$18:
  %66 = phi i32* [%61, %$17] ; # P
; # (wrnl)
  %67 = call i64 @wrnl()
; # (rlSigBeg)
  call void @rlSigBeg()
; # (if Exe @ $Nil)
  %68 = icmp ne i64 %0, 0
  br i1 %68, label %$20, label %$21
$20:
  %69 = phi i32* [%66, %$18] ; # P
  br label %$22
$21:
  %70 = phi i32* [%66, %$18] ; # P
  br label %$22
$22:
  %71 = phi i32* [%69, %$20], [%70, %$21] ; # P
  %72 = phi i64 [%0, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
; # (brkLoad (if Exe @ $Nil))
  %73 = call i64 @brkLoad(i64 %72)
; # (rlSigEnd)
  call void @rlSigEnd()
  br label %$19
$19:
  %74 = phi i32* [%61, %$17], [%71, %$22] ; # P
  br label %$5
$16:
  %75 = phi i32* [%58, %$14] ; # P
; # (ofs $Signal SIGWINCH)
  %76 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 14
; # (val (setq P (ofs $Signal SIGWINCH)))
  %77 = load i32, i32* %76
  %78 = icmp ne i32 %77, 0
  br i1 %78, label %$24, label %$23
$24:
  %79 = phi i32* [%76, %$16] ; # P
; # (set P (dec @))
; # (dec @)
  %80 = sub i32 %77, 1
  store i32 %80, i32* %79
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %81 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %82 = sub i32 %81, 1
  store i32 %82, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (val $Winch)
  %83 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 664) to i64) to i64*
  %84 = load i64, i64* %83
; # (execAt (val $Winch))
  %85 = call i64 @execAt(i64 %84)
  br label %$5
$23:
  %86 = phi i32* [%76, %$16] ; # P
; # (ofs $Signal SIGTSTP)
  %87 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 11
; # (val (setq P (ofs $Signal SIGTSTP)))
  %88 = load i32, i32* %87
  %89 = icmp ne i32 %88, 0
  br i1 %89, label %$26, label %$25
$26:
  %90 = phi i32* [%87, %$23] ; # P
; # (set P (dec @))
; # (dec @)
  %91 = sub i32 %88, 1
  store i32 %91, i32* %90
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %92 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %93 = sub i32 %92, 1
  store i32 %93, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (rlSigBeg)
  call void @rlSigBeg()
; # (val $TStp1)
  %94 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 680) to i64) to i64*
  %95 = load i64, i64* %94
; # (execAt (val $TStp1))
  %96 = call i64 @execAt(i64 %95)
; # (stopTerm)
  call void @stopTerm()
; # (val SIGTSTP Sig)
  %97 = getelementptr i32, i32* @Sig, i32 10
  %98 = load i32, i32* %97
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %99 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGTSTP Sig) (fun sig))
  call void @iSignal(i32 %98, i8* %99)
; # (val $TStp2)
  %100 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 696) to i64) to i64*
  %101 = load i64, i64* %100
; # (execAt (val $TStp2))
  %102 = call i64 @execAt(i64 %101)
; # (rlSigEnd)
  call void @rlSigEnd()
  br label %$5
$25:
  %103 = phi i32* [%87, %$23] ; # P
; # (ofs $Signal SIGTERM)
  %104 = getelementptr i32, i32* bitcast ([16 x i32]* @$Signal to i32*), i32 7
; # (val (setq P (ofs $Signal SIGTERM)))
  %105 = load i32, i32* %104
  %106 = icmp ne i32 %105, 0
  br i1 %106, label %$28, label %$27
$28:
  %107 = phi i32* [%104, %$25] ; # P
; # (if (nil? (run (val $Term))) (let (Cld (val $Child) <Cld (ofs Cld...
; # (val $Term)
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 712) to i64) to i64*
  %109 = load i64, i64* %108
; # (run (val $Term))
  br label %$29
$29:
  %110 = phi i64 [%109, %$28], [%132, %$38] ; # Prg
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
  %113 = getelementptr i64, i64* %111, i32 1
  %114 = load i64, i64* %113
  %115 = and i64 %114, 15
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$32, label %$30
$32:
  %117 = phi i64 [%114, %$29] ; # Prg
  %118 = and i64 %112, 6
  %119 = icmp ne i64 %118, 0
  br i1 %119, label %$35, label %$34
$35:
  br label %$33
$34:
  %120 = and i64 %112, 8
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$37, label %$36
$37:
  %122 = inttoptr i64 %112 to i64*
  %123 = load i64, i64* %122
  br label %$33
$36:
  %124 = call i64 @evList(i64 %112)
  br label %$33
$33:
  %125 = phi i64 [%112, %$35], [%123, %$37], [%124, %$36] ; # ->
  br label %$31
$30:
  %126 = phi i64 [%114, %$29] ; # Prg
  %127 = and i64 %112, 15
  %128 = icmp eq i64 %127, 0
  br i1 %128, label %$39, label %$38
$39:
  %129 = phi i64 [%126, %$30] ; # Prg
  %130 = call i64 @evList(i64 %112)
  %131 = icmp ne i64 %130, 0
  br label %$38
$38:
  %132 = phi i64 [%126, %$30], [%129, %$39] ; # Prg
  %133 = phi i1 [0, %$30], [%131, %$39] ; # ->
  br label %$29
$31:
  %134 = phi i64 [%117, %$33] ; # Prg
  %135 = phi i64 [%125, %$33] ; # ->
; # (nil? (run (val $Term)))
  %136 = icmp eq i64 %135, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %136, label %$40, label %$41
$40:
  %137 = phi i32* [%107, %$31] ; # P
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %138 = load i8*, i8** @$Child
; # (val $Children)
  %139 = load i32, i32* @$Children
; # (* (val $Children) (child T))
  %140 = mul i32 %139, 28
; # (ofs Cld (* (val $Children) (child T)))
  %141 = getelementptr i8, i8* %138, i32 %140
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (and (Cld: pid) ...
  br label %$43
$43:
  %142 = phi i32* [%137, %$40], [%167, %$49] ; # P
  %143 = phi i8* [%138, %$40], [%170, %$49] ; # Cld
  %144 = phi i1 [0, %$40], [%169, %$49] ; # Flg
; # (== Cld <Cld)
  %145 = icmp eq i8* %143, %141
  br i1 %145, label %$45, label %$44
$44:
  %146 = phi i32* [%142, %$43] ; # P
  %147 = phi i8* [%143, %$43] ; # Cld
  %148 = phi i1 [%144, %$43] ; # Flg
; # (let Cld: (child Cld) (when (and (Cld: pid) (=0 (kill @ (val SIGT...
; # (when (and (Cld: pid) (=0 (kill @ (val SIGTERM Sig)))) (setq Flg ...
; # (and (Cld: pid) (=0 (kill @ (val SIGTERM Sig))))
; # (Cld: pid)
  %149 = getelementptr i8, i8* %147, i32 16
  %150 = bitcast i8* %149 to i32*
  %151 = load i32, i32* %150
  %152 = icmp ne i32 %151, 0
  br i1 %152, label %$47, label %$46
$47:
  %153 = phi i32* [%146, %$44] ; # P
  %154 = phi i8* [%147, %$44] ; # Cld
  %155 = phi i1 [%148, %$44] ; # Flg
; # (val SIGTERM Sig)
  %156 = getelementptr i32, i32* @Sig, i32 6
  %157 = load i32, i32* %156
; # (kill @ (val SIGTERM Sig))
  %158 = call i32 @kill(i32 %151, i32 %157)
; # (=0 (kill @ (val SIGTERM Sig)))
  %159 = icmp eq i32 %158, 0
  br label %$46
$46:
  %160 = phi i32* [%146, %$44], [%153, %$47] ; # P
  %161 = phi i8* [%147, %$44], [%154, %$47] ; # Cld
  %162 = phi i1 [%148, %$44], [%155, %$47] ; # Flg
  %163 = phi i1 [0, %$44], [%159, %$47] ; # ->
  br i1 %163, label %$48, label %$49
$48:
  %164 = phi i32* [%160, %$46] ; # P
  %165 = phi i8* [%161, %$46] ; # Cld
  %166 = phi i1 [%162, %$46] ; # Flg
  br label %$49
$49:
  %167 = phi i32* [%160, %$46], [%164, %$48] ; # P
  %168 = phi i8* [%161, %$46], [%165, %$48] ; # Cld
  %169 = phi i1 [%162, %$46], [1, %$48] ; # Flg
; # (ofs Cld (child T))
  %170 = getelementptr i8, i8* %168, i32 28
  br label %$43
$45:
  %171 = phi i32* [%142, %$43] ; # P
  %172 = phi i8* [%143, %$43] ; # Cld
  %173 = phi i1 [%144, %$43] ; # Flg
; # (? Flg)
  br i1 %173, label %$51, label %$50
$50:
  %174 = phi i32* [%171, %$45] ; # P
  %175 = phi i8* [%172, %$45] ; # Cld
  %176 = phi i1 [%173, %$45] ; # Flg
; # (set $Signal 0)
  store i32 0, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (rlSigBeg)
  call void @rlSigBeg()
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$41:
  %177 = phi i32* [%107, %$31] ; # P
; # (set P (dec (val P)))
; # (val P)
  %178 = load i32, i32* %177
; # (dec (val P))
  %179 = sub i32 %178, 1
  store i32 %179, i32* %177
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %180 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %181 = sub i32 %180, 1
  store i32 %181, i32* bitcast ([16 x i32]* @$Signal to i32*)
  br label %$42
$42:
  %182 = phi i32* [%177, %$41] ; # P
  %183 = phi i32 [%181, %$41] ; # ->
  br label %$5
$27:
  %184 = phi i32* [%104, %$25] ; # P
  br label %$5
$5:
  %185 = phi i32* [%6, %$7], [%17, %$9], [%28, %$11], [%39, %$13], [%50, %$15], [%74, %$19], [%79, %$24], [%90, %$26], [%182, %$42], [%184, %$27] ; # P
; # (? (=0 (val $Signal)))
; # (val $Signal)
  %186 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
; # (=0 (val $Signal))
  %187 = icmp eq i32 %186, 0
  br i1 %187, label %$51, label %$52
$52:
  %188 = phi i32* [%185, %$5] ; # P
  br label %$4
$51:
  %189 = phi i32* [%171, %$45], [%185, %$5] ; # P
  %190 = phi i64 [0, %$45], [0, %$5] ; # ->
; # (set $Protect 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
  br label %$3
$3:
  ret void
}

define void @err(i64, i64, i8*, i8*) align 8 {
$1:
; # (set $Up (if Exe @ $Nil))
; # (if Exe @ $Nil)
  %4 = icmp ne i64 %0, 0
  br i1 %4, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %5 = phi i64 [%0, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64) to i64*
  store i64 %5, i64* %6
; # (when X (link (push X NIL)))
  %7 = icmp ne i64 %1, 0
  br i1 %7, label %$5, label %$6
$5:
; # (push X NIL)
  %8 = alloca i64, i64 2, align 16
  %9 = ptrtoint i64* %8 to i64
  %10 = inttoptr i64 %9 to i64*
  store i64 %1, i64* %10
; # (link (push X NIL))
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %12 = load i64, i64* %11
  %13 = inttoptr i64 %9 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  store i64 %12, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %9, i64* %15
  br label %$6
$6:
; # (let Msg (b8 240) (gPrintf Msg 240 Fmt Arg) (when (val Msg) (set ...
; # (b8 240)
  %16 = alloca i8, i64 240
; # (gPrintf Msg 240 Fmt Arg)
  %17 = call i32 @gPrintf(i8* %16, i32 240, i8* %2, i8* %3)
; # (when (val Msg) (set $Msg (mkStr Msg)) (let Ca (val $Catch) (whil...
; # (val Msg)
  %18 = load i8, i8* %16
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %$7, label %$8
$7:
; # (set $Msg (mkStr Msg))
; # (mkStr Msg)
  %20 = call i64 @mkStr(i8* %16)
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 760) to i64) to i64*
  store i64 %20, i64* %21
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (let Tag (Ca...
; # (val $Catch)
  %22 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (let Tag (Ca: tag) (when Tag (whi...
  br label %$9
$9:
  %23 = phi i8* [%22, %$7], [%69, %$13] ; # Ca
  %24 = icmp ne i8* %23, null
  br i1 %24, label %$10, label %$11
$10:
  %25 = phi i8* [%23, %$9] ; # Ca
; # (let Ca: (caFrame Ca) (let Tag (Ca: tag) (when Tag (while (pair T...
; # (let Tag (Ca: tag) (when Tag (while (pair Tag) (when (subStr (car...
; # (Ca: tag)
  %26 = getelementptr i8, i8* %25, i32 8
  %27 = ptrtoint i8* %26 to i64
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (when Tag (while (pair Tag) (when (subStr (car Tag) (val $Msg)) (...
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$12, label %$13
$12:
  %31 = phi i8* [%25, %$10] ; # Ca
  %32 = phi i64 [%29, %$10] ; # Tag
; # (while (pair Tag) (when (subStr (car Tag) (val $Msg)) (unwind (Ca...
  br label %$14
$14:
  %33 = phi i8* [%31, %$12], [%59, %$18] ; # Ca
  %34 = phi i64 [%32, %$12], [%63, %$18] ; # Tag
; # (pair Tag)
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$15, label %$16
$15:
  %37 = phi i8* [%33, %$14] ; # Ca
  %38 = phi i64 [%34, %$14] ; # Tag
; # (when (subStr (car Tag) (val $Msg)) (unwind (Ca:)) (set $Ret (if ...
; # (car Tag)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (val $Msg)
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 760) to i64) to i64*
  %42 = load i64, i64* %41
; # (subStr (car Tag) (val $Msg))
  %43 = call i1 @subStr(i64 %40, i64 %42)
  br i1 %43, label %$17, label %$18
$17:
  %44 = phi i8* [%37, %$15] ; # Ca
  %45 = phi i64 [%38, %$15] ; # Tag
; # (Ca:)
; # (unwind (Ca:))
  call void @unwind(i8* %25)
; # (set $Ret (if (nil? (car Tag)) (val $Msg) @))
; # (if (nil? (car Tag)) (val $Msg) @)
; # (car Tag)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (nil? (car Tag))
  %48 = icmp eq i64 %47, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %48, label %$19, label %$20
$19:
  %49 = phi i8* [%44, %$17] ; # Ca
  %50 = phi i64 [%45, %$17] ; # Tag
; # (val $Msg)
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 760) to i64) to i64*
  %52 = load i64, i64* %51
  br label %$21
$20:
  %53 = phi i8* [%44, %$17] ; # Ca
  %54 = phi i64 [%45, %$17] ; # Tag
  br label %$21
$21:
  %55 = phi i8* [%49, %$19], [%53, %$20] ; # Ca
  %56 = phi i64 [%50, %$19], [%54, %$20] ; # Tag
  %57 = phi i64 [%52, %$19], [%47, %$20] ; # ->
  store i64 %57, i64* @$Ret
; # (Ca: (rst))
  %58 = getelementptr i8, i8* %25, i32 216
; # (longjmp (Ca: (rst)) 1)
  call void @longjmp(i8* %58, i32 1)
  unreachable
$18:
  %59 = phi i8* [%37, %$15] ; # Ca
  %60 = phi i64 [%38, %$15] ; # Tag
; # (shift Tag)
  %61 = inttoptr i64 %60 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
  br label %$14
$16:
  %64 = phi i8* [%33, %$14] ; # Ca
  %65 = phi i64 [%34, %$14] ; # Tag
  br label %$13
$13:
  %66 = phi i8* [%25, %$10], [%64, %$16] ; # Ca
  %67 = phi i64 [%29, %$10], [%65, %$16] ; # Tag
; # (Ca: link)
  %68 = bitcast i8* %25 to i8**
  %69 = load i8*, i8** %68
  br label %$9
$11:
  %70 = phi i8* [%23, %$9] ; # Ca
  br label %$8
$8:
; # (flushAll)
  call void @flushAll()
; # (set $Chr (set $ExtN 0))
; # (set $ExtN 0)
  store i32 0, i32* @$ExtN
  store i32 0, i32* @$Chr
; # (set $Break 0)
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 16) to i64) to i64*
  store i64 0, i64* %71
; # (set $LinePtr null)
  store i8* null, i8** @$LinePtr
; # (set $Alarm (set $Sigio $Nil))
; # (set $Sigio $Nil)
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %72
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 24) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %73
; # (b8 (ioFrame T))
  %74 = alloca i8, i64 28
; # (val $OutFiles)
  %75 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %76 = getelementptr i8*, i8** %75, i32 2
  %77 = load i8*, i8** %76
; # (pushOutFile (b8 (ioFrame T)) (val 3 (val $OutFiles)) 0)
  call void @pushOutFile(i8* %74, i8* %77, i32 0)
; # (let In: (inFile (val $InFile)) (when (and (In:) (In: name)) (cal...
; # (val $InFile)
  %78 = load i8*, i8** @$InFile
; # (when (and (In:) (In: name)) (call $Put (char "[")) (outString (I...
; # (and (In:) (In: name))
; # (In:)
  %79 = icmp ne i8* %78, null
  br i1 %79, label %$23, label %$22
$23:
; # (In: name)
  %80 = bitcast i8* %78 to i8**
  %81 = load i8*, i8** %80
  %82 = icmp ne i8* %81, null
  br label %$22
$22:
  %83 = phi i1 [0, %$8], [%82, %$23] ; # ->
  br i1 %83, label %$24, label %$25
$24:
; # (call $Put (char "["))
  %84 = load void(i8)*, void(i8)** @$Put
  call void %84(i8 91)
; # (In: name)
  %85 = bitcast i8* %78 to i8**
  %86 = load i8*, i8** %85
; # (outString (In: name))
  call void @outString(i8* %86)
; # (call $Put (char ":"))
  %87 = load void(i8)*, void(i8)** @$Put
  call void %87(i8 58)
; # (In: src)
  %88 = getelementptr i8, i8* %78, i32 20
  %89 = bitcast i8* %88 to i32*
  %90 = load i32, i32* %89
; # (i64 (In: src))
  %91 = sext i32 %90 to i64
; # (outWord (i64 (In: src)))
  call void @outWord(i64 %91)
; # (call $Put (char "]"))
  %92 = load void(i8)*, void(i8)** @$Put
  call void %92(i8 93)
; # (space)
  call void @space()
  br label %$25
$25:
; # (when Exe (outString ($ "!? ")) (print Exe) (newline))
  %93 = icmp ne i64 %0, 0
  br i1 %93, label %$26, label %$27
$26:
; # (outString ($ "!? "))
  call void @outString(i8* bitcast ([4 x i8]* @$4 to i8*))
; # (print Exe)
  call void @print(i64 %0)
; # (newline)
  call void @newline()
  br label %$27
$27:
; # (when X (print X) (outString ($ " -- ")))
  %94 = icmp ne i64 %1, 0
  br i1 %94, label %$28, label %$29
$28:
; # (print X)
  call void @print(i64 %1)
; # (outString ($ " -- "))
  call void @outString(i8* bitcast ([5 x i8]* @$5 to i8*))
  br label %$29
$29:
; # (when (val Msg) (outString Msg) (newline) (unless (or (nil? (val ...
; # (val Msg)
  %95 = load i8, i8* %16
  %96 = icmp ne i8 %95, 0
  br i1 %96, label %$30, label %$31
$30:
; # (outString Msg)
  call void @outString(i8* %16)
; # (newline)
  call void @newline()
; # (unless (or (nil? (val $Err)) (val $Jam)) (set $Jam YES) (execAt ...
; # (or (nil? (val $Err)) (val $Jam))
; # (val $Err)
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  %98 = load i64, i64* %97
; # (nil? (val $Err))
  %99 = icmp eq i64 %98, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %99, label %$32, label %$33
$33:
; # (val $Jam)
  %100 = load i1, i1* @$Jam
  br label %$32
$32:
  %101 = phi i1 [1, %$30], [%100, %$33] ; # ->
  br i1 %101, label %$35, label %$34
$34:
; # (set $Jam YES)
  store i1 1, i1* @$Jam
; # (val $Err)
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  %103 = load i64, i64* %102
; # (execAt (val $Err))
  %104 = call i64 @execAt(i64 %103)
; # (set $Jam NO)
  store i1 0, i1* @$Jam
  br label %$35
$35:
; # (unless (and ((inFile (val (val $InFiles))) tty) ((outFile (val 2...
; # (and ((inFile (val (val $InFiles))) tty) ((outFile (val 2 (val $O...
; # (val $InFiles)
  %105 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %106 = load i8*, i8** %105
; # ((inFile (val (val $InFiles))) tty)
  %107 = getelementptr i8, i8* %106, i32 4128
  %108 = bitcast i8* %107 to i1*
  %109 = load i1, i1* %108
  br i1 %109, label %$37, label %$36
$37:
; # (val $OutFiles)
  %110 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %111 = getelementptr i8*, i8** %110, i32 1
  %112 = load i8*, i8** %111
; # ((outFile (val 2 (val $OutFiles))) tty)
  %113 = getelementptr i8, i8* %112, i32 4104
  %114 = bitcast i8* %113 to i1*
  %115 = load i1, i1* %114
  br label %$36
$36:
  %116 = phi i1 [0, %$35], [%115, %$37] ; # ->
  br i1 %116, label %$39, label %$38
$38:
; # (bye 1)
  call void @bye(i32 1)
  unreachable
$39:
; # (repl 0 ($ "? ") $Nil)
  %117 = call i64 @repl(i64 0, i8* bitcast ([3 x i8]* @$6 to i8*), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$31
$31:
; # (unwind null)
  call void @unwind(i8* null)
; # (unless (val $StkLimit) (set $StkLimit (val $StkBrk)))
; # (val $StkLimit)
  %118 = load i8*, i8** @$StkLimit
  %119 = icmp ne i8* %118, null
  br i1 %119, label %$41, label %$40
$40:
; # (set $StkLimit (val $StkBrk))
; # (val $StkBrk)
  %120 = load i8*, i8** @$StkBrk
  store i8* %120, i8** @$StkLimit
  br label %$41
$41:
; # (set $Link 0 $Protect 0 $Next $Nil $Make 0 $Yoke 0 $Trace 0 $Put ...
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 0, i64* %121
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %122
  %123 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 0, i64* %123
  %124 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 0, i64* %124
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 136) to i32*)
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$Put
; # (fun (i32) _getStdin)
  store i32()* @_getStdin, i32()** @$Get
; # (longjmp QuitRst 1)
  call void @longjmp(i8* @QuitRst, i32 1)
  unreachable
}

define void @stkErr(i64) align 8 {
$1:
; # (set $StkLimit null)
  store i8* null, i8** @$StkLimit
; # (err Exe 0 ($ "Stack overflow") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([15 x i8]* @$7 to i8*), i8* null)
  unreachable
}

define void @argErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Bad argument") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([13 x i8]* @$8 to i8*), i8* null)
  unreachable
}

define void @cntErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Small number expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([22 x i8]* @$9 to i8*), i8* null)
  unreachable
}

define void @numErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Number expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([16 x i8]* @$10 to i8*), i8* null)
  unreachable
}

define void @symErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Symbol expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([16 x i8]* @$11 to i8*), i8* null)
  unreachable
}

define void @charErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Char expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([14 x i8]* @$12 to i8*), i8* null)
  unreachable
}

define void @extErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "External symbol expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([25 x i8]* @$13 to i8*), i8* null)
  unreachable
}

define void @nameErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Name expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([14 x i8]* @$14 to i8*), i8* null)
  unreachable
}

define void @atomErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Atom expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([14 x i8]* @$15 to i8*), i8* null)
  unreachable
}

define void @pairErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Cons pair expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([19 x i8]* @$16 to i8*), i8* null)
  unreachable
}

define void @lstErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "List expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([14 x i8]* @$17 to i8*), i8* null)
  unreachable
}

define void @varErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Variable expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([18 x i8]* @$18 to i8*), i8* null)
  unreachable
}

define void @itemErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Item not found") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([15 x i8]* @$19 to i8*), i8* null)
  unreachable
}

define void @protErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Protected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([10 x i8]* @$20 to i8*), i8* null)
  unreachable
}

define void @lockErr() align 8 {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "File lock: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$21 to i8*), i8* %0)
  unreachable
}

define void @forkErr(i64) align 8 {
$1:
; # (err Exe 0 ($ "Can't fork") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([11 x i8]* @$22 to i8*), i8* null)
  unreachable
}

define void @symNspErr(i64, i64) align 8 {
$1:
; # (err Exe X ($ "Bad symbol namespace") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([21 x i8]* @$23 to i8*), i8* null)
  unreachable
}

define i64 @xCnt(i64, i64) align 8 {
$1:
; # (let N (int (needCnt Exe X)) (if (sign? X) (- N) N))
; # (needCnt Exe X)
  %2 = and i64 %1, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  call void @cntErr(i64 %0, i64 %1)
  unreachable
$3:
; # (int (needCnt Exe X))
  %4 = lshr i64 %1, 4
; # (if (sign? X) (- N) N)
; # (sign? X)
  %5 = and i64 %1, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$4, label %$5
$4:
; # (- N)
  %7 = sub i64 0, %4
  br label %$6
$5:
  br label %$6
$6:
  %8 = phi i64 [%7, %$4], [%4, %$5] ; # ->
  ret i64 %8
}

define i64 @evCnt(i64, i64) align 8 {
$1:
; # (car X)
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (eval (car X))
  %4 = and i64 %3, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
  br label %$2
$3:
  %6 = and i64 %3, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
  %8 = inttoptr i64 %3 to i64*
  %9 = load i64, i64* %8
  br label %$2
$5:
  %10 = call i64 @evList(i64 %3)
  br label %$2
$2:
  %11 = phi i64 [%3, %$4], [%9, %$6], [%10, %$5] ; # ->
; # (xCnt Exe (eval (car X)))
  %12 = call i64 @xCnt(i64 %0, i64 %11)
  ret i64 %12
}

define i64 @evLst(i64) align 8 {
$1:
; # (let X (eval (car Exe)) (unless (or (pair X) (nil? X)) (lstErr Ex...
; # (car Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (eval (car Exe))
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$4, label %$3
$4:
  br label %$2
$3:
  %5 = and i64 %2, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  %7 = inttoptr i64 %2 to i64*
  %8 = load i64, i64* %7
  br label %$2
$5:
  %9 = call i64 @evList(i64 %2)
  br label %$2
$2:
  %10 = phi i64 [%2, %$4], [%8, %$6], [%9, %$5] ; # ->
; # (unless (or (pair X) (nil? X)) (lstErr Exe X))
; # (or (pair X) (nil? X))
; # (pair X)
  %11 = and i64 %10, 15
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %$7, label %$8
$8:
; # (nil? X)
  %13 = icmp eq i64 %10, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %14 = phi i1 [1, %$2], [%13, %$8] ; # ->
  br i1 %14, label %$10, label %$9
$9:
; # (lstErr Exe X)
  call void @lstErr(i64 %0, i64 %10)
  unreachable
$10:
  ret i64 %10
}

define i64 @xSym(i64) align 8 {
$1:
; # (if (symb? X) X (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (...
; # (symb? X)
  %1 = xor i64 %0, 8
  %2 = and i64 %1, 14
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (pack X P) (consS...
; # (push 4 NIL ZERO NIL)
  %4 = alloca i64, i64 4, align 16
  store i64 4, i64* %4
  %5 = getelementptr i64, i64* %4, i32 2
  store i64 2, i64* %5
; # (ofs P 2)
  %6 = getelementptr i64, i64* %4, i32 2
; # (link (ofs P 2) T)
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %7 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %12
; # (pack X P)
  call void @pack(i64 %0, i64* %4)
; # (val 3 P)
  %13 = getelementptr i64, i64* %4, i32 2
  %14 = load i64, i64* %13
; # (consStr (val 3 P))
  %15 = call i64 @consStr(i64 %14)
; # (drop *Safe)
  %16 = inttoptr i64 %7 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %19
  br label %$4
$4:
  %20 = phi i64 [%0, %$2], [%15, %$3] ; # ->
  ret i64 %20
}

define i64 @evSym(i64) align 8 {
$1:
; # (car Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (eval (car Exe))
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$4, label %$3
$4:
  br label %$2
$3:
  %5 = and i64 %2, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  %7 = inttoptr i64 %2 to i64*
  %8 = load i64, i64* %7
  br label %$2
$5:
  %9 = call i64 @evList(i64 %2)
  br label %$2
$2:
  %10 = phi i64 [%2, %$4], [%8, %$6], [%9, %$5] ; # ->
; # (xSym (eval (car Exe)))
  %11 = call i64 @xSym(i64 %10)
  ret i64 %11
}

define i64 @xName(i64, i64) align 8 {
$1:
; # (cond ((nil? Sym) ZERO) ((sym? (val (tail Sym))) (nameErr Exe Sym...
; # (nil? Sym)
  %2 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %2, label %$4, label %$3
$4:
  br label %$2
$3:
; # (tail Sym)
  %3 = add i64 %1, -8
; # (val (tail Sym))
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (sym? (val (tail Sym)))
  %6 = and i64 %5, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
; # (nameErr Exe Sym)
  call void @nameErr(i64 %0, i64 %1)
  unreachable
$5:
; # (name @)
  br label %$7
$7:
  %8 = phi i64 [%5, %$5], [%14, %$8] ; # Tail
  %9 = and i64 %8, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$9, label %$8
$8:
  %11 = phi i64 [%8, %$7] ; # Tail
  %12 = inttoptr i64 %11 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  %14 = load i64, i64* %13
  br label %$7
$9:
  %15 = phi i64 [%8, %$7] ; # Tail
  br label %$2
$2:
  %16 = phi i64 [2, %$4], [%15, %$9] ; # ->
  ret i64 %16
}

define i64 @circ(i64) align 8 {
$1:
; # (if (atom X) 0 (let Y X (loop (set Y (| (val Y) 1)) (? (atom (shi...
; # (atom X)
  %1 = and i64 %0, 15
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i64 [%0, %$1] ; # X
  br label %$4
$3:
  %4 = phi i64 [%0, %$1] ; # X
; # (let Y X (loop (set Y (| (val Y) 1)) (? (atom (shift Y)) (loop (s...
; # (loop (set Y (| (val Y) 1)) (? (atom (shift Y)) (loop (set X (& (...
  br label %$5
$5:
  %5 = phi i64 [%4, %$3], [%71, %$12] ; # X
  %6 = phi i64 [%4, %$3], [%72, %$12] ; # Y
; # (set Y (| (val Y) 1))
; # (val Y)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (| (val Y) 1)
  %9 = or i64 %8, 1
  %10 = inttoptr i64 %6 to i64*
  store i64 %9, i64* %10
; # (? (atom (shift Y)) (loop (set X (& (val X) -2)) (? (atom (shift ...
; # (shift Y)
  %11 = inttoptr i64 %6 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
; # (atom (shift Y))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$6
$8:
  %16 = phi i64 [%5, %$5] ; # X
  %17 = phi i64 [%13, %$5] ; # Y
; # (loop (set X (& (val X) -2)) (? (atom (shift X))))
  br label %$9
$9:
  %18 = phi i64 [%16, %$8], [%29, %$10] ; # X
  %19 = phi i64 [%17, %$8], [%30, %$10] ; # Y
; # (set X (& (val X) -2))
; # (val X)
  %20 = inttoptr i64 %18 to i64*
  %21 = load i64, i64* %20
; # (& (val X) -2)
  %22 = and i64 %21, -2
  %23 = inttoptr i64 %18 to i64*
  store i64 %22, i64* %23
; # (? (atom (shift X)))
; # (shift X)
  %24 = inttoptr i64 %18 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$11, label %$10
$10:
  %29 = phi i64 [%26, %$9] ; # X
  %30 = phi i64 [%19, %$9] ; # Y
  br label %$9
$11:
  %31 = phi i64 [%26, %$9] ; # X
  %32 = phi i64 [%19, %$9] ; # Y
  %33 = phi i64 [0, %$9] ; # ->
  br label %$7
$6:
  %34 = phi i64 [%5, %$5] ; # X
  %35 = phi i64 [%13, %$5] ; # Y
; # (? (& (val Y) 1) (until (== X Y) (set X (& (val X) -2)) (shift X)...
; # (val Y)
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
; # (& (val Y) 1)
  %38 = and i64 %37, 1
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$13, label %$12
$13:
  %40 = phi i64 [%34, %$6] ; # X
  %41 = phi i64 [%35, %$6] ; # Y
; # (until (== X Y) (set X (& (val X) -2)) (shift X))
  br label %$14
$14:
  %42 = phi i64 [%40, %$13], [%53, %$15] ; # X
  %43 = phi i64 [%41, %$13], [%46, %$15] ; # Y
; # (== X Y)
  %44 = icmp eq i64 %42, %43
  br i1 %44, label %$16, label %$15
$15:
  %45 = phi i64 [%42, %$14] ; # X
  %46 = phi i64 [%43, %$14] ; # Y
; # (set X (& (val X) -2))
; # (val X)
  %47 = inttoptr i64 %45 to i64*
  %48 = load i64, i64* %47
; # (& (val X) -2)
  %49 = and i64 %48, -2
  %50 = inttoptr i64 %45 to i64*
  store i64 %49, i64* %50
; # (shift X)
  %51 = inttoptr i64 %45 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  br label %$14
$16:
  %54 = phi i64 [%42, %$14] ; # X
  %55 = phi i64 [%43, %$14] ; # Y
; # (loop (set X (& (val X) -2)) (? (== Y (shift X))))
  br label %$17
$17:
  %56 = phi i64 [%54, %$16], [%66, %$18] ; # X
  %57 = phi i64 [%55, %$16], [%67, %$18] ; # Y
; # (set X (& (val X) -2))
; # (val X)
  %58 = inttoptr i64 %56 to i64*
  %59 = load i64, i64* %58
; # (& (val X) -2)
  %60 = and i64 %59, -2
  %61 = inttoptr i64 %56 to i64*
  store i64 %60, i64* %61
; # (? (== Y (shift X)))
; # (shift X)
  %62 = inttoptr i64 %56 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (== Y (shift X))
  %65 = icmp eq i64 %57, %64
  br i1 %65, label %$19, label %$18
$18:
  %66 = phi i64 [%64, %$17] ; # X
  %67 = phi i64 [%57, %$17] ; # Y
  br label %$17
$19:
  %68 = phi i64 [%64, %$17] ; # X
  %69 = phi i64 [%57, %$17] ; # Y
  %70 = phi i64 [0, %$17] ; # ->
  br label %$7
$12:
  %71 = phi i64 [%34, %$6] ; # X
  %72 = phi i64 [%35, %$6] ; # Y
  br label %$5
$7:
  %73 = phi i64 [%31, %$11], [%68, %$19] ; # X
  %74 = phi i64 [%32, %$11], [%69, %$19] ; # Y
  %75 = phi i64 [0, %$11], [%69, %$19] ; # ->
  br label %$4
$4:
  %76 = phi i64 [%3, %$2], [%73, %$7] ; # X
  %77 = phi i64 [0, %$2], [%75, %$7] ; # ->
  ret i64 %77
}

define i64 @funq(i64) align 8 {
$1:
; # (cond ((cnt? X) X) ((or (big? X) (sym? X)) 0) ((circ X) 0) (T (le...
; # (cnt? X)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
  br label %$2
$3:
  %4 = phi i64 [%0, %$1] ; # X
; # (or (big? X) (sym? X))
; # (big? X)
  %5 = and i64 %4, 4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$6
$6:
  %7 = phi i64 [%4, %$3] ; # X
; # (sym? X)
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
  br label %$5
$5:
  %10 = phi i64 [%4, %$3], [%7, %$6] ; # X
  %11 = phi i1 [1, %$3], [%9, %$6] ; # ->
  br i1 %11, label %$8, label %$7
$8:
  %12 = phi i64 [%10, %$5] ; # X
  br label %$2
$7:
  %13 = phi i64 [%10, %$5] ; # X
; # (circ X)
  %14 = call i64 @circ(i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$10, label %$9
$10:
  %16 = phi i64 [%13, %$7] ; # X
  br label %$2
$9:
  %17 = phi i64 [%13, %$7] ; # X
; # (let Y (cdr X) (loop (? (atom Y) (cond ((not (nil? Y)) 0) ((nil? ...
; # (cdr X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (loop (? (atom Y) (cond ((not (nil? Y)) 0) ((nil? (setq X (car X)...
  br label %$11
$11:
  %21 = phi i64 [%17, %$9], [%150, %$40] ; # X
  %22 = phi i64 [%20, %$9], [%151, %$40] ; # Y
; # (? (atom Y) (cond ((not (nil? Y)) 0) ((nil? (setq X (car X))) $T)...
; # (atom Y)
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$14, label %$12
$14:
  %25 = phi i64 [%21, %$11] ; # X
  %26 = phi i64 [%22, %$11] ; # Y
; # (cond ((not (nil? Y)) 0) ((nil? (setq X (car X))) $T) ((== X $Til...
; # (nil? Y)
  %27 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %28 = icmp eq i1 %27, 0
  br i1 %28, label %$17, label %$16
$17:
  %29 = phi i64 [%25, %$14] ; # X
  %30 = phi i64 [%26, %$14] ; # Y
  br label %$15
$16:
  %31 = phi i64 [%25, %$14] ; # X
  %32 = phi i64 [%26, %$14] ; # Y
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (nil? (setq X (car X)))
  %35 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %35, label %$19, label %$18
$19:
  %36 = phi i64 [%34, %$16] ; # X
  %37 = phi i64 [%32, %$16] ; # Y
  br label %$15
$18:
  %38 = phi i64 [%34, %$16] ; # X
  %39 = phi i64 [%32, %$16] ; # Y
; # (== X $Tilde)
  %40 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64)
  br i1 %40, label %$21, label %$20
$21:
  %41 = phi i64 [%38, %$18] ; # X
  %42 = phi i64 [%39, %$18] ; # Y
  br label %$15
$20:
  %43 = phi i64 [%38, %$18] ; # X
  %44 = phi i64 [%39, %$18] ; # Y
; # (circ (setq Y X))
  %45 = call i64 @circ(i64 %43)
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$23, label %$22
$23:
  %47 = phi i64 [%43, %$20] ; # X
  %48 = phi i64 [%43, %$20] ; # Y
  br label %$15
$22:
  %49 = phi i64 [%43, %$20] ; # X
  %50 = phi i64 [%43, %$20] ; # Y
; # (loop (? (atom Y) (if (or (num? Y) (t? Y)) 0 X)) (? (or (not (sym...
  br label %$24
$24:
  %51 = phi i64 [%49, %$22], [%93, %$36] ; # X
  %52 = phi i64 [%50, %$22], [%94, %$36] ; # Y
; # (? (atom Y) (if (or (num? Y) (t? Y)) 0 X))
; # (atom Y)
  %53 = and i64 %52, 15
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$27, label %$25
$27:
  %55 = phi i64 [%51, %$24] ; # X
  %56 = phi i64 [%52, %$24] ; # Y
; # (if (or (num? Y) (t? Y)) 0 X)
; # (or (num? Y) (t? Y))
; # (num? Y)
  %57 = and i64 %56, 6
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$28, label %$29
$29:
  %59 = phi i64 [%55, %$27] ; # X
  %60 = phi i64 [%56, %$27] ; # Y
; # (t? Y)
  %61 = icmp eq i64 %60, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br label %$28
$28:
  %62 = phi i64 [%55, %$27], [%59, %$29] ; # X
  %63 = phi i64 [%56, %$27], [%60, %$29] ; # Y
  %64 = phi i1 [1, %$27], [%61, %$29] ; # ->
  br i1 %64, label %$30, label %$31
$30:
  %65 = phi i64 [%62, %$28] ; # X
  %66 = phi i64 [%63, %$28] ; # Y
  br label %$32
$31:
  %67 = phi i64 [%62, %$28] ; # X
  %68 = phi i64 [%63, %$28] ; # Y
  br label %$32
$32:
  %69 = phi i64 [%65, %$30], [%67, %$31] ; # X
  %70 = phi i64 [%66, %$30], [%68, %$31] ; # Y
  %71 = phi i64 [0, %$30], [%67, %$31] ; # ->
  br label %$26
$25:
  %72 = phi i64 [%51, %$24] ; # X
  %73 = phi i64 [%52, %$24] ; # Y
; # (? (or (not (symb? (++ Y))) (nil? @) (t? @)) 0)
; # (or (not (symb? (++ Y))) (nil? @) (t? @))
; # (++ Y)
  %74 = inttoptr i64 %73 to i64*
  %75 = load i64, i64* %74
  %76 = getelementptr i64, i64* %74, i32 1
  %77 = load i64, i64* %76
; # (symb? (++ Y))
  %78 = xor i64 %75, 8
  %79 = and i64 %78, 14
  %80 = icmp eq i64 %79, 0
; # (not (symb? (++ Y)))
  %81 = icmp eq i1 %80, 0
  br i1 %81, label %$33, label %$34
$34:
  %82 = phi i64 [%72, %$25] ; # X
  %83 = phi i64 [%77, %$25] ; # Y
; # (nil? @)
  %84 = icmp eq i64 %75, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %84, label %$33, label %$35
$35:
  %85 = phi i64 [%82, %$34] ; # X
  %86 = phi i64 [%83, %$34] ; # Y
; # (t? @)
  %87 = icmp eq i64 %75, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br label %$33
$33:
  %88 = phi i64 [%72, %$25], [%82, %$34], [%85, %$35] ; # X
  %89 = phi i64 [%77, %$25], [%83, %$34], [%86, %$35] ; # Y
  %90 = phi i1 [1, %$25], [1, %$34], [%87, %$35] ; # ->
  br i1 %90, label %$37, label %$36
$37:
  %91 = phi i64 [%88, %$33] ; # X
  %92 = phi i64 [%89, %$33] ; # Y
  br label %$26
$36:
  %93 = phi i64 [%88, %$33] ; # X
  %94 = phi i64 [%89, %$33] ; # Y
  br label %$24
$26:
  %95 = phi i64 [%69, %$32], [%91, %$37] ; # X
  %96 = phi i64 [%70, %$32], [%92, %$37] ; # Y
  %97 = phi i64 [%71, %$32], [0, %$37] ; # ->
  br label %$15
$15:
  %98 = phi i64 [%29, %$17], [%36, %$19], [%41, %$21], [%47, %$23], [%95, %$26] ; # X
  %99 = phi i64 [%30, %$17], [%37, %$19], [%42, %$21], [%48, %$23], [%96, %$26] ; # Y
  %100 = phi i64 [0, %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$19], [0, %$21], [0, %$23], [%97, %$26] ; # ->
  br label %$13
$12:
  %101 = phi i64 [%21, %$11] ; # X
  %102 = phi i64 [%22, %$11] ; # Y
; # (let Z (++ Y) (if (pair Z) (if (num? (car Z)) (? (pair Y) 0) (? (...
; # (++ Y)
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
  %105 = getelementptr i64, i64* %103, i32 1
  %106 = load i64, i64* %105
; # (if (pair Z) (if (num? (car Z)) (? (pair Y) 0) (? (or (nil? (car ...
; # (pair Z)
  %107 = and i64 %104, 15
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %$38, label %$39
$38:
  %109 = phi i64 [%101, %$12] ; # X
  %110 = phi i64 [%106, %$12] ; # Y
; # (if (num? (car Z)) (? (pair Y) 0) (? (or (nil? (car Z)) (t? (car ...
; # (car Z)
  %111 = inttoptr i64 %104 to i64*
  %112 = load i64, i64* %111
; # (num? (car Z))
  %113 = and i64 %112, 6
  %114 = icmp ne i64 %113, 0
  br i1 %114, label %$41, label %$42
$41:
  %115 = phi i64 [%109, %$38] ; # X
  %116 = phi i64 [%110, %$38] ; # Y
; # (? (pair Y) 0)
; # (pair Y)
  %117 = and i64 %116, 15
  %118 = icmp eq i64 %117, 0
  br i1 %118, label %$45, label %$44
$45:
  %119 = phi i64 [%115, %$41] ; # X
  %120 = phi i64 [%116, %$41] ; # Y
  br label %$13
$44:
  %121 = phi i64 [%115, %$41] ; # X
  %122 = phi i64 [%116, %$41] ; # Y
  br label %$43
$42:
  %123 = phi i64 [%109, %$38] ; # X
  %124 = phi i64 [%110, %$38] ; # Y
; # (? (or (nil? (car Z)) (t? (car Z))) 0)
; # (or (nil? (car Z)) (t? (car Z)))
; # (car Z)
  %125 = inttoptr i64 %104 to i64*
  %126 = load i64, i64* %125
; # (nil? (car Z))
  %127 = icmp eq i64 %126, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %127, label %$46, label %$47
$47:
  %128 = phi i64 [%123, %$42] ; # X
  %129 = phi i64 [%124, %$42] ; # Y
; # (car Z)
  %130 = inttoptr i64 %104 to i64*
  %131 = load i64, i64* %130
; # (t? (car Z))
  %132 = icmp eq i64 %131, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br label %$46
$46:
  %133 = phi i64 [%123, %$42], [%128, %$47] ; # X
  %134 = phi i64 [%124, %$42], [%129, %$47] ; # Y
  %135 = phi i1 [1, %$42], [%132, %$47] ; # ->
  br i1 %135, label %$49, label %$48
$49:
  %136 = phi i64 [%133, %$46] ; # X
  %137 = phi i64 [%134, %$46] ; # Y
  br label %$13
$48:
  %138 = phi i64 [%133, %$46] ; # X
  %139 = phi i64 [%134, %$46] ; # Y
  br label %$43
$43:
  %140 = phi i64 [%121, %$44], [%138, %$48] ; # X
  %141 = phi i64 [%122, %$44], [%139, %$48] ; # Y
  br label %$40
$39:
  %142 = phi i64 [%101, %$12] ; # X
  %143 = phi i64 [%106, %$12] ; # Y
; # (? (not (nil? Y)) 0)
; # (nil? Y)
  %144 = icmp eq i64 %143, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %145 = icmp eq i1 %144, 0
  br i1 %145, label %$51, label %$50
$51:
  %146 = phi i64 [%142, %$39] ; # X
  %147 = phi i64 [%143, %$39] ; # Y
  br label %$13
$50:
  %148 = phi i64 [%142, %$39] ; # X
  %149 = phi i64 [%143, %$39] ; # Y
  br label %$40
$40:
  %150 = phi i64 [%140, %$43], [%148, %$50] ; # X
  %151 = phi i64 [%141, %$43], [%149, %$50] ; # Y
  br label %$11
$13:
  %152 = phi i64 [%98, %$15], [%119, %$45], [%136, %$49], [%146, %$51] ; # X
  %153 = phi i64 [%99, %$15], [%120, %$45], [%137, %$49], [%147, %$51] ; # Y
  %154 = phi i64 [%100, %$15], [0, %$45], [0, %$49], [0, %$51] ; # ->
  br label %$2
$2:
  %155 = phi i64 [%3, %$4], [%12, %$8], [%16, %$10], [%152, %$13] ; # X
  %156 = phi i64 [%3, %$4], [0, %$8], [0, %$10], [%154, %$13] ; # ->
  ret i64 %156
}

define i64 @_tty(i64) align 8 {
$1:
; # (let (Out (val $OutFile) Put (val (i8** $Put))) (set $OutFile (va...
; # (val $OutFile)
  %1 = load i8*, i8** @$OutFile
; # (i8** $Put)
  %2 = bitcast void(i8)** @$Put to i8**
; # (val (i8** $Put))
  %3 = load i8*, i8** %2
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %4 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %5 = getelementptr i8*, i8** %4, i32 2
  %6 = load i8*, i8** %5
  store i8* %6, i8** @$OutFile
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$Put
; # (rlHide)
  call void @rlHide()
; # (prog1 (run (cdr Exe)) (flush (val $OutFile)) (rlShow) (set (i8**...
; # (cdr Exe)
  %7 = inttoptr i64 %0 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
; # (run (cdr Exe))
  br label %$2
$2:
  %10 = phi i64 [%9, %$1], [%32, %$11] ; # Prg
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
  %13 = getelementptr i64, i64* %11, i32 1
  %14 = load i64, i64* %13
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$5, label %$3
$5:
  %17 = phi i64 [%14, %$2] ; # Prg
  %18 = and i64 %12, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$8:
  br label %$6
$7:
  %20 = and i64 %12, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$9
$10:
  %22 = inttoptr i64 %12 to i64*
  %23 = load i64, i64* %22
  br label %$6
$9:
  %24 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %25 = phi i64 [%12, %$8], [%23, %$10], [%24, %$9] ; # ->
  br label %$4
$3:
  %26 = phi i64 [%14, %$2] ; # Prg
  %27 = and i64 %12, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$12, label %$11
$12:
  %29 = phi i64 [%26, %$3] ; # Prg
  %30 = call i64 @evList(i64 %12)
  %31 = icmp ne i64 %30, 0
  br label %$11
$11:
  %32 = phi i64 [%26, %$3], [%29, %$12] ; # Prg
  %33 = phi i1 [0, %$3], [%31, %$12] ; # ->
  br label %$2
$4:
  %34 = phi i64 [%17, %$6] ; # Prg
  %35 = phi i64 [%25, %$6] ; # ->
; # (val $OutFile)
  %36 = load i8*, i8** @$OutFile
; # (flush (val $OutFile))
  %37 = call i1 @flush(i8* %36)
; # (rlShow)
  call void @rlShow()
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %38 = bitcast void(i8)** @$Put to i8**
  store i8* %3, i8** %38
  store i8* %1, i8** @$OutFile
  ret i64 %35
}

define i64 @_raw(i64) align 8 {
$1:
; # (let X (cdr Exe) (cond ((atom X) (if (val Termio) $T $Nil)) ((nil...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (if (val Termio) $T $Nil)) ((nil? (eval (car X)))...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
; # (if (val Termio) $T $Nil)
; # (val Termio)
  %6 = load i8*, i8** @Termio
  %7 = icmp ne i8* %6, null
  br i1 %7, label %$5, label %$6
$5:
  br label %$7
$6:
  br label %$7
$7:
  %8 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$5], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$6] ; # ->
  br label %$2
$3:
; # (car X)
  %9 = inttoptr i64 %3 to i64*
  %10 = load i64, i64* %9
; # (eval (car X))
  %11 = and i64 %10, 6
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$10, label %$9
$10:
  br label %$8
$9:
  %13 = and i64 %10, 8
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$12, label %$11
$12:
  %15 = inttoptr i64 %10 to i64*
  %16 = load i64, i64* %15
  br label %$8
$11:
  %17 = call i64 @evList(i64 %10)
  br label %$8
$8:
  %18 = phi i64 [%10, %$10], [%16, %$12], [%17, %$11] ; # ->
; # (nil? (eval (car X)))
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %19, label %$14, label %$13
$14:
; # (setCooked)
  call void @setCooked()
  br label %$2
$13:
; # (setRaw)
  call void @setRaw()
  br label %$2
$2:
  %20 = phi i64 [%8, %$7], [%18, %$14], [%18, %$13] ; # ->
  ret i64 %20
}

define i64 @_alarm(i64) align 8 {
$1:
; # (let X (cdr Exe) (prog1 (cnt (i64 (alarm (i32 (evCnt Exe X))))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog1 (cnt (i64 (alarm (i32 (evCnt Exe X))))) (set $Alarm (cdr X...
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (i32 (evCnt Exe X))
  %5 = trunc i64 %4 to i32
; # (alarm (i32 (evCnt Exe X)))
  %6 = call i32 @alarm(i32 %5)
; # (i64 (alarm (i32 (evCnt Exe X))))
  %7 = sext i32 %6 to i64
; # (cnt (i64 (alarm (i32 (evCnt Exe X)))))
  %8 = shl i64 %7, 4
  %9 = or i64 %8, 2
; # (set $Alarm (cdr X))
; # (cdr X)
  %10 = inttoptr i64 %3 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 24) to i64) to i64*
  store i64 %12, i64* %13
  ret i64 %9
}

define i64 @_sigio(i64) align 8 {
$1:
; # (let (X (cdr Exe) Fd (evCnt Exe X)) (set $Sigio (cdr X)) (fcntlSe...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (set $Sigio (cdr X))
; # (cdr X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  store i64 %7, i64* %8
; # (i32 Fd)
  %9 = trunc i64 %4 to i32
; # (val $Pid)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 200) to i64) to i64*
  %11 = load i64, i64* %10
; # (int (val $Pid))
  %12 = lshr i64 %11, 4
; # (i32 (int (val $Pid)))
  %13 = trunc i64 %12 to i32
; # (fcntlSetOwn (i32 Fd) (i32 (int (val $Pid))))
  call void @fcntlSetOwn(i32 %9, i32 %13)
; # (cnt Fd)
  %14 = shl i64 %4, 4
  %15 = or i64 %14, 2
  ret i64 %15
}

define i64 @_kids(i64) align 8 {
$1:
; # (let (X $Nil Cld (val $Child) <Cld (ofs Cld (* (val $Children) (c...
; # (val $Child)
  %1 = load i8*, i8** @$Child
; # (val $Children)
  %2 = load i32, i32* @$Children
; # (* (val $Children) (child T))
  %3 = mul i32 %2, 28
; # (ofs Cld (* (val $Children) (child T)))
  %4 = getelementptr i8, i8* %1, i32 %3
; # (until (== Cld <Cld) (when ((child Cld) pid) (setq X (cons (cnt (...
  br label %$2
$2:
  %5 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%20, %$6] ; # X
  %6 = phi i8* [%1, %$1], [%22, %$6] ; # Cld
; # (== Cld <Cld)
  %7 = icmp eq i8* %6, %4
  br i1 %7, label %$4, label %$3
$3:
  %8 = phi i64 [%5, %$2] ; # X
  %9 = phi i8* [%6, %$2] ; # Cld
; # (when ((child Cld) pid) (setq X (cons (cnt (i64 @)) X)))
; # ((child Cld) pid)
  %10 = getelementptr i8, i8* %9, i32 16
  %11 = bitcast i8* %10 to i32*
  %12 = load i32, i32* %11
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %$5, label %$6
$5:
  %14 = phi i64 [%8, %$3] ; # X
  %15 = phi i8* [%9, %$3] ; # Cld
; # (i64 @)
  %16 = sext i32 %12 to i64
; # (cnt (i64 @))
  %17 = shl i64 %16, 4
  %18 = or i64 %17, 2
; # (cons (cnt (i64 @)) X)
  %19 = call i64 @cons(i64 %18, i64 %14)
  br label %$6
$6:
  %20 = phi i64 [%8, %$3], [%19, %$5] ; # X
  %21 = phi i8* [%9, %$3], [%15, %$5] ; # Cld
; # (ofs Cld (child T))
  %22 = getelementptr i8, i8* %21, i32 28
  br label %$2
$4:
  %23 = phi i64 [%5, %$2] ; # X
  %24 = phi i8* [%6, %$2] ; # Cld
  ret i64 %23
}

define i64 @_protect(i64) align 8 {
$1:
; # (let X (cdr Exe) (prog2 (set $Protect (+ (val $Protect) 1)) (run ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog2 (set $Protect (+ (val $Protect) 1)) (run X) (set $Protect ...
; # (set $Protect (+ (val $Protect) 1))
; # (val $Protect)
  %4 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (+ (val $Protect) 1)
  %5 = add i32 %4, 1
  store i32 %5, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (run X)
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%28, %$11] ; # Prg
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
  %9 = getelementptr i64, i64* %7, i32 1
  %10 = load i64, i64* %9
  %11 = and i64 %10, 15
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$5, label %$3
$5:
  %13 = phi i64 [%10, %$2] ; # Prg
  %14 = and i64 %8, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$7
$8:
  br label %$6
$7:
  %16 = and i64 %8, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$10, label %$9
$10:
  %18 = inttoptr i64 %8 to i64*
  %19 = load i64, i64* %18
  br label %$6
$9:
  %20 = call i64 @evList(i64 %8)
  br label %$6
$6:
  %21 = phi i64 [%8, %$8], [%19, %$10], [%20, %$9] ; # ->
  br label %$4
$3:
  %22 = phi i64 [%10, %$2] ; # Prg
  %23 = and i64 %8, 15
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%22, %$3] ; # Prg
  %26 = call i64 @evList(i64 %8)
  %27 = icmp ne i64 %26, 0
  br label %$11
$11:
  %28 = phi i64 [%22, %$3], [%25, %$12] ; # Prg
  %29 = phi i1 [0, %$3], [%27, %$12] ; # ->
  br label %$2
$4:
  %30 = phi i64 [%13, %$6] ; # Prg
  %31 = phi i64 [%21, %$6] ; # ->
; # (set $Protect (- (val $Protect) 1))
; # (val $Protect)
  %32 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (- (val $Protect) 1)
  %33 = sub i32 %32, 1
  store i32 %33, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
  ret i64 %31
}

define i64 @_heap(i64) align 8 {
$1:
; # (if (nil? (eval (cadr Exe))) (let (N 1 P (val $Heaps)) (while (se...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
; # (let (N 1 P (val $Heaps)) (while (setq P (val (ofs P HEAP))) (inc...
; # (val $Heaps)
  %15 = load i64, i64* @$Heaps
; # (while (setq P (val (ofs P HEAP))) (inc 'N))
  br label %$10
$10:
  %16 = phi i64 [1, %$7], [%24, %$11] ; # N
  %17 = phi i64 [%15, %$7], [%23, %$11] ; # P
; # (ofs P HEAP)
  %18 = add i64 %17, 1048576
; # (val (ofs P HEAP))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$12
$11:
  %22 = phi i64 [%16, %$10] ; # N
  %23 = phi i64 [%20, %$10] ; # P
; # (inc 'N)
  %24 = add i64 %22, 1
  br label %$10
$12:
  %25 = phi i64 [%16, %$10] ; # N
  %26 = phi i64 [%20, %$10] ; # P
; # (cnt N)
  %27 = shl i64 %25, 4
  %28 = or i64 %27, 2
  br label %$9
$8:
; # (let (N 0 P (val $Avail)) (while P (inc 'N) (setq P (car P))) (cn...
; # (val $Avail)
  %29 = load i64, i64* @$Avail
; # (while P (inc 'N) (setq P (car P)))
  br label %$13
$13:
  %30 = phi i64 [0, %$8], [%35, %$14] ; # N
  %31 = phi i64 [%29, %$8], [%37, %$14] ; # P
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$14, label %$15
$14:
  %33 = phi i64 [%30, %$13] ; # N
  %34 = phi i64 [%31, %$13] ; # P
; # (inc 'N)
  %35 = add i64 %33, 1
; # (car P)
  %36 = inttoptr i64 %34 to i64*
  %37 = load i64, i64* %36
  br label %$13
$15:
  %38 = phi i64 [%30, %$13] ; # N
  %39 = phi i64 [%31, %$13] ; # P
; # (- 20 4)
; # (shr N (- 20 4))
  %40 = lshr i64 %38, 16
; # (cnt (shr N (- 20 4)))
  %41 = shl i64 %40, 4
  %42 = or i64 %41, 2
  br label %$9
$9:
  %43 = phi i64 [%28, %$12], [%42, %$15] ; # ->
  ret i64 %43
}

define i64 @_stack(i64) align 8 {
$1:
; # (let (X (cdr Exe) Crt (val $Coroutines)) (if (or (atom X) (and Cr...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $Coroutines)
  %4 = load i8*, i8** @$Coroutines
; # (if (or (atom X) (and Crt ((coroutine Crt) nxt))) (let R (cnt (sh...
; # (or (atom X) (and Crt ((coroutine Crt) nxt)))
; # (atom X)
  %5 = and i64 %3, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$2, label %$3
$3:
  %7 = phi i64 [%3, %$1] ; # X
  %8 = phi i8* [%4, %$1] ; # Crt
; # (and Crt ((coroutine Crt) nxt))
  %9 = icmp ne i8* %8, null
  br i1 %9, label %$5, label %$4
$5:
  %10 = phi i64 [%7, %$3] ; # X
  %11 = phi i8* [%8, %$3] ; # Crt
; # ((coroutine Crt) nxt)
  %12 = getelementptr i8, i8* %11, i32 16
  %13 = bitcast i8* %12 to i8**
  %14 = load i8*, i8** %13
  %15 = icmp ne i8* %14, null
  br label %$4
$4:
  %16 = phi i64 [%7, %$3], [%10, %$5] ; # X
  %17 = phi i8* [%8, %$3], [%11, %$5] ; # Crt
  %18 = phi i1 [0, %$3], [%15, %$5] ; # ->
  br label %$2
$2:
  %19 = phi i64 [%3, %$1], [%16, %$4] ; # X
  %20 = phi i8* [%4, %$1], [%17, %$4] ; # Crt
  %21 = phi i1 [1, %$1], [%18, %$4] ; # ->
  br i1 %21, label %$6, label %$7
$6:
  %22 = phi i64 [%19, %$2] ; # X
  %23 = phi i8* [%20, %$2] ; # Crt
; # (let R (cnt (shr (val $StkSize) 10)) (while Crt (let Crt: (corout...
; # (val $StkSize)
  %24 = load i64, i64* @$StkSize
; # (shr (val $StkSize) 10)
  %25 = lshr i64 %24, 10
; # (cnt (shr (val $StkSize) 10))
  %26 = shl i64 %25, 4
  %27 = or i64 %26, 2
; # (while Crt (let Crt: (coroutine Crt) (when (Crt: tag) (let P (Crt...
  br label %$9
$9:
  %28 = phi i64 [%22, %$6], [%73, %$13] ; # X
  %29 = phi i8* [%23, %$6], [%78, %$13] ; # Crt
  %30 = phi i64 [%27, %$6], [%75, %$13] ; # R
  %31 = icmp ne i8* %29, null
  br i1 %31, label %$10, label %$11
$10:
  %32 = phi i64 [%28, %$9] ; # X
  %33 = phi i8* [%29, %$9] ; # Crt
  %34 = phi i64 [%30, %$9] ; # R
; # (let Crt: (coroutine Crt) (when (Crt: tag) (let P (Crt: lim) (whi...
; # (when (Crt: tag) (let P (Crt: lim) (while (== 7 (val P)) (inc 'P)...
; # (Crt: tag)
  %35 = ptrtoint i8* %33 to i64
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$12, label %$13
$12:
  %39 = phi i64 [%32, %$10] ; # X
  %40 = phi i8* [%33, %$10] ; # Crt
  %41 = phi i64 [%34, %$10] ; # R
; # (let P (Crt: lim) (while (== 7 (val P)) (inc 'P)) (setq R (cons2 ...
; # (Crt: lim)
  %42 = getelementptr i8, i8* %33, i32 40
  %43 = bitcast i8* %42 to i8**
  %44 = load i8*, i8** %43
; # (while (== 7 (val P)) (inc 'P))
  br label %$14
$14:
  %45 = phi i64 [%39, %$12], [%51, %$15] ; # X
  %46 = phi i8* [%40, %$12], [%52, %$15] ; # Crt
  %47 = phi i64 [%41, %$12], [%53, %$15] ; # R
  %48 = phi i8* [%44, %$12], [%55, %$15] ; # P
; # (val P)
  %49 = load i8, i8* %48
; # (== 7 (val P))
  %50 = icmp eq i8 7, %49
  br i1 %50, label %$15, label %$16
$15:
  %51 = phi i64 [%45, %$14] ; # X
  %52 = phi i8* [%46, %$14] ; # Crt
  %53 = phi i64 [%47, %$14] ; # R
  %54 = phi i8* [%48, %$14] ; # P
; # (inc 'P)
  %55 = getelementptr i8, i8* %54, i32 1
  br label %$14
$16:
  %56 = phi i64 [%45, %$14] ; # X
  %57 = phi i8* [%46, %$14] ; # Crt
  %58 = phi i64 [%47, %$14] ; # R
  %59 = phi i8* [%48, %$14] ; # P
; # (Crt: tag)
  %60 = ptrtoint i8* %33 to i64
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (Crt: lim)
  %63 = getelementptr i8, i8* %33, i32 40
  %64 = bitcast i8* %63 to i8**
  %65 = load i8*, i8** %64
; # (- P (Crt: lim))
  %66 = ptrtoint i8* %59 to i64
  %67 = ptrtoint i8* %65 to i64
  %68 = sub i64 %66, %67
; # (shr (- P (Crt: lim)) 10)
  %69 = lshr i64 %68, 10
; # (cnt (shr (- P (Crt: lim)) 10))
  %70 = shl i64 %69, 4
  %71 = or i64 %70, 2
; # (cons2 (Crt: tag) (cnt (shr (- P (Crt: lim)) 10)) R)
  %72 = call i64 @cons2(i64 %62, i64 %71, i64 %58)
  br label %$13
$13:
  %73 = phi i64 [%32, %$10], [%56, %$16] ; # X
  %74 = phi i8* [%33, %$10], [%57, %$16] ; # Crt
  %75 = phi i64 [%34, %$10], [%72, %$16] ; # R
; # (Crt: nxt)
  %76 = getelementptr i8, i8* %33, i32 16
  %77 = bitcast i8* %76 to i8**
  %78 = load i8*, i8** %77
  br label %$9
$11:
  %79 = phi i64 [%28, %$9] ; # X
  %80 = phi i8* [%29, %$9] ; # Crt
  %81 = phi i64 [%30, %$9] ; # R
  br label %$8
$7:
  %82 = phi i64 [%19, %$2] ; # X
  %83 = phi i8* [%20, %$2] ; # Crt
; # (let N (evCnt Exe X) (set $StkSize (shl N 10)) (when (pair (shift...
; # (evCnt Exe X)
  %84 = call i64 @evCnt(i64 %0, i64 %82)
; # (set $StkSize (shl N 10))
; # (shl N 10)
  %85 = shl i64 %84, 10
  store i64 %85, i64* @$StkSize
; # (when (pair (shift X)) (set $StkSizeT (shl (evCnt Exe X) 10)))
; # (shift X)
  %86 = inttoptr i64 %82 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
; # (pair (shift X))
  %89 = and i64 %88, 15
  %90 = icmp eq i64 %89, 0
  br i1 %90, label %$17, label %$18
$17:
  %91 = phi i64 [%88, %$7] ; # X
  %92 = phi i8* [%83, %$7] ; # Crt
; # (set $StkSizeT (shl (evCnt Exe X) 10))
; # (evCnt Exe X)
  %93 = call i64 @evCnt(i64 %0, i64 %91)
; # (shl (evCnt Exe X) 10)
  %94 = shl i64 %93, 10
  store i64 %94, i64* @$StkSizeT
  br label %$18
$18:
  %95 = phi i64 [%88, %$7], [%91, %$17] ; # X
  %96 = phi i8* [%83, %$7], [%92, %$17] ; # Crt
; # (when Crt (let (Siz (val $StkSizeT) Stk (stack)) (memset ((corout...
  %97 = icmp ne i8* %96, null
  br i1 %97, label %$19, label %$20
$19:
  %98 = phi i64 [%95, %$18] ; # X
  %99 = phi i8* [%96, %$18] ; # Crt
; # (let (Siz (val $StkSizeT) Stk (stack)) (memset ((coroutine Crt) l...
; # (val $StkSizeT)
  %100 = load i64, i64* @$StkSizeT
; # (stack)
  %101 = call i8* @llvm.stacksave()
; # ((coroutine Crt) lim (stack (ofs Stk (- Siz))))
  %102 = getelementptr i8, i8* %99, i32 40
  %103 = bitcast i8* %102 to i8**
  %104 = sub i64 0, %100
  %105 = getelementptr i8, i8* %101, i64 %104
  call void @llvm.stackrestore(i8* %105)
  store i8* %105, i8** %103
; # (- Siz 256)
  %106 = sub i64 %100, 256
; # (memset ((coroutine Crt) lim (stack (ofs Stk (- Siz)))) 7 (- Siz ...
  call void @llvm.memset.p0i8.i64(i8* align 8 %105, i8 7, i64 %106, i1 0)
; # (stack Stk)
  call void @llvm.stackrestore(i8* %101)
  br label %$20
$20:
  %107 = phi i64 [%95, %$18], [%98, %$19] ; # X
  %108 = phi i8* [%96, %$18], [%99, %$19] ; # Crt
; # (cnt N)
  %109 = shl i64 %84, 4
  %110 = or i64 %109, 2
  br label %$8
$8:
  %111 = phi i64 [%79, %$11], [%107, %$20] ; # X
  %112 = phi i8* [%80, %$11], [%108, %$20] ; # Crt
  %113 = phi i64 [%81, %$11], [%110, %$20] ; # ->
  ret i64 %113
}

define i64 @tmDate(i64, i64, i64) align 8 {
$1:
; # (if (and (gt0 Y) (gt0 M) (>= 12 M) (gt0 D) (or (>= (i64 (val (ofs...
; # (and (gt0 Y) (gt0 M) (>= 12 M) (gt0 D) (or (>= (i64 (val (ofs $Mo...
; # (gt0 Y)
  %3 = icmp sgt i64 %0, 0
  br i1 %3, label %$3, label %$2
$3:
; # (gt0 M)
  %4 = icmp sgt i64 %1, 0
  br i1 %4, label %$4, label %$2
$4:
; # (>= 12 M)
  %5 = icmp uge i64 12, %1
  br i1 %5, label %$5, label %$2
$5:
; # (gt0 D)
  %6 = icmp sgt i64 %2, 0
  br i1 %6, label %$6, label %$2
$6:
; # (or (>= (i64 (val (ofs $Month M))) D) (and (== D 29) (== M 2) (=0...
; # (ofs $Month M)
  %7 = getelementptr i8, i8* bitcast ([13 x i8]* @$Month to i8*), i64 %1
; # (val (ofs $Month M))
  %8 = load i8, i8* %7
; # (i64 (val (ofs $Month M)))
  %9 = zext i8 %8 to i64
; # (>= (i64 (val (ofs $Month M))) D)
  %10 = icmp uge i64 %9, %2
  br i1 %10, label %$7, label %$8
$8:
; # (and (== D 29) (== M 2) (=0 (% Y 4)) (or (% Y 100) (=0 (% Y 400))...
; # (== D 29)
  %11 = icmp eq i64 %2, 29
  br i1 %11, label %$10, label %$9
$10:
; # (== M 2)
  %12 = icmp eq i64 %1, 2
  br i1 %12, label %$11, label %$9
$11:
; # (% Y 4)
  %13 = urem i64 %0, 4
; # (=0 (% Y 4))
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %$12, label %$9
$12:
; # (or (% Y 100) (=0 (% Y 400)))
; # (% Y 100)
  %15 = urem i64 %0, 100
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$13, label %$14
$14:
; # (% Y 400)
  %17 = urem i64 %0, 400
; # (=0 (% Y 400))
  %18 = icmp eq i64 %17, 0
  br label %$13
$13:
  %19 = phi i1 [1, %$12], [%18, %$14] ; # ->
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [0, %$10], [0, %$11], [%19, %$13] ; # ->
  br label %$7
$7:
  %21 = phi i1 [1, %$6], [%20, %$9] ; # ->
  br label %$2
$2:
  %22 = phi i1 [0, %$1], [0, %$3], [0, %$4], [0, %$5], [%21, %$7] ; # ->
  br i1 %22, label %$15, label %$16
$15:
; # (let N (/ (+ (* Y 12) M -3) 12) (cnt (- (+ (/ (+ (* Y 4404) (* M ...
; # (* Y 12)
  %23 = mul i64 %0, 12
; # (+ (* Y 12) M -3)
  %24 = add i64 %23, %1
  %25 = add i64 %24, -3
; # (/ (+ (* Y 12) M -3) 12)
  %26 = udiv i64 %25, 12
; # (* Y 4404)
  %27 = mul i64 %0, 4404
; # (* M 367)
  %28 = mul i64 %1, 367
; # (+ (* Y 4404) (* M 367) -1094)
  %29 = add i64 %27, %28
  %30 = add i64 %29, -1094
; # (/ (+ (* Y 4404) (* M 367) -1094) 12)
  %31 = udiv i64 %30, 12
; # (/ N 4)
  %32 = udiv i64 %26, 4
; # (/ N 400)
  %33 = udiv i64 %26, 400
; # (+ (/ (+ (* Y 4404) (* M 367) -1094) 12) (/ N 4) (/ N 400) D)
  %34 = add i64 %31, %32
  %35 = add i64 %34, %33
  %36 = add i64 %35, %2
; # (* 2 N)
  %37 = mul i64 2, %26
; # (/ N 100)
  %38 = udiv i64 %26, 100
; # (- (+ (/ (+ (* Y 4404) (* M 367) -1094) 12) (/ N 4) (/ N 400) D) ...
  %39 = sub i64 %36, %37
  %40 = sub i64 %39, %38
; # (cnt (- (+ (/ (+ (* Y 4404) (* M 367) -1094) 12) (/ N 4) (/ N 400...
  %41 = shl i64 %40, 4
  %42 = or i64 %41, 2
  br label %$17
$16:
  br label %$17
$17:
  %43 = phi i64 [%42, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$16] ; # ->
  ret i64 %43
}

define i64 @tmTime(i64, i64, i64) align 8 {
$1:
; # (if (and (ge0 H) (ge0 M) (> 60 M) (ge0 S) (> 60 S)) (cnt (+ (* H ...
; # (and (ge0 H) (ge0 M) (> 60 M) (ge0 S) (> 60 S))
; # (ge0 H)
  %3 = icmp sge i64 %0, 0
  br i1 %3, label %$3, label %$2
$3:
; # (ge0 M)
  %4 = icmp sge i64 %1, 0
  br i1 %4, label %$4, label %$2
$4:
; # (> 60 M)
  %5 = icmp ugt i64 60, %1
  br i1 %5, label %$5, label %$2
$5:
; # (ge0 S)
  %6 = icmp sge i64 %2, 0
  br i1 %6, label %$6, label %$2
$6:
; # (> 60 S)
  %7 = icmp ugt i64 60, %2
  br label %$2
$2:
  %8 = phi i1 [0, %$1], [0, %$3], [0, %$4], [0, %$5], [%7, %$6] ; # ->
  br i1 %8, label %$7, label %$8
$7:
; # (* H 3600)
  %9 = mul i64 %0, 3600
; # (* M 60)
  %10 = mul i64 %1, 60
; # (+ (* H 3600) (* M 60) S)
  %11 = add i64 %9, %10
  %12 = add i64 %11, %2
; # (cnt (+ (* H 3600) (* M 60) S))
  %13 = shl i64 %12, 4
  %14 = or i64 %13, 2
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_date(i64) align 8 {
$1:
; # (let X (cdr Exe) (cond ((atom X) (let N (getDate) (tmDate (& N (h...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (let N (getDate) (tmDate (& N (hex "FFFF")) (& (s...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
  %6 = phi i64 [%3, %$1] ; # X
; # (let N (getDate) (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex "F...
; # (getDate)
  %7 = call i64 @getDate()
; # (& N (hex "FFFF"))
  %8 = and i64 %7, 65535
; # (shr N 16)
  %9 = lshr i64 %7, 16
; # (& (shr N 16) (hex "FF"))
  %10 = and i64 %9, 255
; # (shr N 24)
  %11 = lshr i64 %7, 24
; # (& (shr N 24) (hex "FF"))
  %12 = and i64 %11, 255
; # (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex "FF")) (& (shr N 24...
  %13 = call i64 @tmDate(i64 %8, i64 %10, i64 %12)
  br label %$2
$3:
  %14 = phi i64 [%3, %$1] ; # X
; # (car X)
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
; # (eval (car X))
  %17 = and i64 %16, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$7, label %$6
$7:
  br label %$5
$6:
  %19 = and i64 %16, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$9, label %$8
$9:
  %21 = inttoptr i64 %16 to i64*
  %22 = load i64, i64* %21
  br label %$5
$8:
  %23 = call i64 @evList(i64 %16)
  br label %$5
$5:
  %24 = phi i64 [%16, %$7], [%22, %$9], [%23, %$8] ; # ->
; # (t? (eval (car X)))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %25, label %$11, label %$10
$11:
  %26 = phi i64 [%14, %$5] ; # X
; # (let N (getGmDate) (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex ...
; # (getGmDate)
  %27 = call i64 @getGmDate()
; # (& N (hex "FFFF"))
  %28 = and i64 %27, 65535
; # (shr N 16)
  %29 = lshr i64 %27, 16
; # (& (shr N 16) (hex "FF"))
  %30 = and i64 %29, 255
; # (shr N 24)
  %31 = lshr i64 %27, 24
; # (& (shr N 24) (hex "FF"))
  %32 = and i64 %31, 255
; # (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex "FF")) (& (shr N 24...
  %33 = call i64 @tmDate(i64 %28, i64 %30, i64 %32)
  br label %$2
$10:
  %34 = phi i64 [%14, %$5] ; # X
; # (nil? @)
  %35 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %35, label %$13, label %$12
$13:
  %36 = phi i64 [%34, %$10] ; # X
  br label %$2
$12:
  %37 = phi i64 [%34, %$10] ; # X
; # (pair @)
  %38 = and i64 %24, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$15, label %$14
$15:
  %40 = phi i64 [%37, %$12] ; # X
; # (let L @ (tmDate (xCnt Exe (++ L)) (xCnt Exe (++ L)) (xCnt Exe (c...
; # (++ L)
  %41 = inttoptr i64 %24 to i64*
  %42 = load i64, i64* %41
  %43 = getelementptr i64, i64* %41, i32 1
  %44 = load i64, i64* %43
; # (xCnt Exe (++ L))
  %45 = call i64 @xCnt(i64 %0, i64 %42)
; # (++ L)
  %46 = inttoptr i64 %44 to i64*
  %47 = load i64, i64* %46
  %48 = getelementptr i64, i64* %46, i32 1
  %49 = load i64, i64* %48
; # (xCnt Exe (++ L))
  %50 = call i64 @xCnt(i64 %0, i64 %47)
; # (car L)
  %51 = inttoptr i64 %49 to i64*
  %52 = load i64, i64* %51
; # (xCnt Exe (car L))
  %53 = call i64 @xCnt(i64 %0, i64 %52)
; # (tmDate (xCnt Exe (++ L)) (xCnt Exe (++ L)) (xCnt Exe (car L)))
  %54 = call i64 @tmDate(i64 %45, i64 %50, i64 %53)
  br label %$2
$14:
  %55 = phi i64 [%37, %$12] ; # X
; # (let N @ (cond ((pair (shift X)) (tmDate (xCnt Exe N) (evCnt Exe ...
; # (cond ((pair (shift X)) (tmDate (xCnt Exe N) (evCnt Exe X) (evCnt...
; # (shift X)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (pair (shift X))
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$18, label %$17
$18:
  %61 = phi i64 [%58, %$14] ; # X
  %62 = phi i64 [%24, %$14] ; # N
; # (xCnt Exe N)
  %63 = call i64 @xCnt(i64 %0, i64 %62)
; # (evCnt Exe X)
  %64 = call i64 @evCnt(i64 %0, i64 %61)
; # (cdr X)
  %65 = inttoptr i64 %61 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (evCnt Exe (cdr X))
  %68 = call i64 @evCnt(i64 %0, i64 %67)
; # (tmDate (xCnt Exe N) (evCnt Exe X) (evCnt Exe (cdr X)))
  %69 = call i64 @tmDate(i64 %63, i64 %64, i64 %68)
  br label %$16
$17:
  %70 = phi i64 [%58, %$14] ; # X
  %71 = phi i64 [%24, %$14] ; # N
; # (xCnt Exe N)
  %72 = call i64 @xCnt(i64 %0, i64 %71)
; # (lt0 (setq N (xCnt Exe N)))
  %73 = icmp slt i64 %72, 0
  br i1 %73, label %$20, label %$19
$20:
  %74 = phi i64 [%70, %$17] ; # X
  %75 = phi i64 [%72, %$17] ; # N
  br label %$16
$19:
  %76 = phi i64 [%70, %$17] ; # X
  %77 = phi i64 [%72, %$17] ; # N
; # (let Y (/ (- (* N 100) 20) 3652425) (setq N (+ N (- Y (/ Y 4))) Y...
; # (* N 100)
  %78 = mul i64 %77, 100
; # (- (* N 100) 20)
  %79 = sub i64 %78, 20
; # (/ (- (* N 100) 20) 3652425)
  %80 = udiv i64 %79, 3652425
; # (/ Y 4)
  %81 = udiv i64 %80, 4
; # (- Y (/ Y 4))
  %82 = sub i64 %80, %81
; # (+ N (- Y (/ Y 4)))
  %83 = add i64 %77, %82
; # (* N 100)
  %84 = mul i64 %83, 100
; # (- (* N 100) 20)
  %85 = sub i64 %84, 20
; # (/ (- (* N 100) 20) 36525)
  %86 = udiv i64 %85, 36525
; # (* Y 36525)
  %87 = mul i64 %86, 36525
; # (/ (* Y 36525) 100)
  %88 = udiv i64 %87, 100
; # (- N (/ (* Y 36525) 100))
  %89 = sub i64 %83, %88
; # (* (- N (/ (* Y 36525) 100)) 10)
  %90 = mul i64 %89, 10
; # (let (M (/ (- N 5) 306) D (/ (+ N (* M -306) 5) 10)) (if (> 10 M)...
; # (- N 5)
  %91 = sub i64 %90, 5
; # (/ (- N 5) 306)
  %92 = udiv i64 %91, 306
; # (* M -306)
  %93 = mul i64 %92, -306
; # (+ N (* M -306) 5)
  %94 = add i64 %90, %93
  %95 = add i64 %94, 5
; # (/ (+ N (* M -306) 5) 10)
  %96 = udiv i64 %95, 10
; # (if (> 10 M) (inc 'M 3) (inc 'Y) (dec 'M 9))
; # (> 10 M)
  %97 = icmp ugt i64 10, %92
  br i1 %97, label %$21, label %$22
$21:
  %98 = phi i64 [%76, %$19] ; # X
  %99 = phi i64 [%90, %$19] ; # N
  %100 = phi i64 [%86, %$19] ; # Y
  %101 = phi i64 [%92, %$19] ; # M
; # (inc 'M 3)
  %102 = add i64 %101, 3
  br label %$23
$22:
  %103 = phi i64 [%76, %$19] ; # X
  %104 = phi i64 [%90, %$19] ; # N
  %105 = phi i64 [%86, %$19] ; # Y
  %106 = phi i64 [%92, %$19] ; # M
; # (inc 'Y)
  %107 = add i64 %105, 1
; # (dec 'M 9)
  %108 = sub i64 %106, 9
  br label %$23
$23:
  %109 = phi i64 [%98, %$21], [%103, %$22] ; # X
  %110 = phi i64 [%99, %$21], [%104, %$22] ; # N
  %111 = phi i64 [%100, %$21], [%107, %$22] ; # Y
  %112 = phi i64 [%102, %$21], [%108, %$22] ; # M
  %113 = phi i64 [%102, %$21], [%108, %$22] ; # ->
; # (cnt Y)
  %114 = shl i64 %111, 4
  %115 = or i64 %114, 2
; # (cnt M)
  %116 = shl i64 %112, 4
  %117 = or i64 %116, 2
; # (cnt D)
  %118 = shl i64 %96, 4
  %119 = or i64 %118, 2
; # (cons (cnt D) $Nil)
  %120 = call i64 @cons(i64 %119, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cnt M) (cons (cnt D) $Nil))
  %121 = call i64 @cons(i64 %117, i64 %120)
; # (cons (cnt Y) (cons (cnt M) (cons (cnt D) $Nil)))
  %122 = call i64 @cons(i64 %115, i64 %121)
  br label %$16
$16:
  %123 = phi i64 [%61, %$18], [%74, %$20], [%109, %$23] ; # X
  %124 = phi i64 [%62, %$18], [%75, %$20], [%110, %$23] ; # N
  %125 = phi i64 [%69, %$18], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$20], [%122, %$23] ; # ->
  br label %$2
$2:
  %126 = phi i64 [%6, %$4], [%26, %$11], [%36, %$13], [%40, %$15], [%123, %$16] ; # X
  %127 = phi i64 [%13, %$4], [%33, %$11], [%24, %$13], [%54, %$15], [%125, %$16] ; # ->
  ret i64 %127
}

define i64 @_time(i64) align 8 {
$1:
; # (let X (cdr Exe) (cond ((atom X) (cnt (getTime))) ((t? (eval (car...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (cnt (getTime))) ((t? (eval (car X))) (if (lt0 (g...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
  %6 = phi i64 [%3, %$1] ; # X
; # (getTime)
  %7 = call i64 @getTime()
; # (cnt (getTime))
  %8 = shl i64 %7, 4
  %9 = or i64 %8, 2
  br label %$2
$3:
  %10 = phi i64 [%3, %$1] ; # X
; # (car X)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  br label %$5
$6:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$5
$8:
  %19 = call i64 @evList(i64 %12)
  br label %$5
$5:
  %20 = phi i64 [%12, %$7], [%18, %$9], [%19, %$8] ; # ->
; # (t? (eval (car X)))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %21, label %$11, label %$10
$11:
  %22 = phi i64 [%10, %$5] ; # X
; # (if (lt0 (getGmTime)) $Nil (cnt @))
; # (getGmTime)
  %23 = call i64 @getGmTime()
; # (lt0 (getGmTime))
  %24 = icmp slt i64 %23, 0
  br i1 %24, label %$12, label %$13
$12:
  %25 = phi i64 [%22, %$11] ; # X
  br label %$14
$13:
  %26 = phi i64 [%22, %$11] ; # X
; # (cnt @)
  %27 = shl i64 %23, 4
  %28 = or i64 %27, 2
  br label %$14
$14:
  %29 = phi i64 [%25, %$12], [%26, %$13] ; # X
  %30 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%28, %$13] ; # ->
  br label %$2
$10:
  %31 = phi i64 [%10, %$5] ; # X
; # (nil? @)
  %32 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %32, label %$16, label %$15
$16:
  %33 = phi i64 [%31, %$10] ; # X
  br label %$2
$15:
  %34 = phi i64 [%31, %$10] ; # X
; # (pair @)
  %35 = and i64 %20, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$18, label %$17
$18:
  %37 = phi i64 [%34, %$15] ; # X
; # (let L @ (tmTime (xCnt Exe (++ L)) (xCnt Exe (++ L)) (if (pair L)...
; # (++ L)
  %38 = inttoptr i64 %20 to i64*
  %39 = load i64, i64* %38
  %40 = getelementptr i64, i64* %38, i32 1
  %41 = load i64, i64* %40
; # (xCnt Exe (++ L))
  %42 = call i64 @xCnt(i64 %0, i64 %39)
; # (++ L)
  %43 = inttoptr i64 %41 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (xCnt Exe (++ L))
  %47 = call i64 @xCnt(i64 %0, i64 %44)
; # (if (pair L) (xCnt Exe (car L)) 0)
; # (pair L)
  %48 = and i64 %46, 15
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %$19, label %$20
$19:
  %50 = phi i64 [%37, %$18] ; # X
  %51 = phi i64 [%46, %$18] ; # L
; # (car L)
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
; # (xCnt Exe (car L))
  %54 = call i64 @xCnt(i64 %0, i64 %53)
  br label %$21
$20:
  %55 = phi i64 [%37, %$18] ; # X
  %56 = phi i64 [%46, %$18] ; # L
  br label %$21
$21:
  %57 = phi i64 [%50, %$19], [%55, %$20] ; # X
  %58 = phi i64 [%51, %$19], [%56, %$20] ; # L
  %59 = phi i64 [%54, %$19], [0, %$20] ; # ->
; # (tmTime (xCnt Exe (++ L)) (xCnt Exe (++ L)) (if (pair L) (xCnt Ex...
  %60 = call i64 @tmTime(i64 %42, i64 %47, i64 %59)
  br label %$2
$17:
  %61 = phi i64 [%34, %$15] ; # X
; # (let N @ (cond ((pair (shift X)) (tmTime (xCnt Exe N) (evCnt Exe ...
; # (cond ((pair (shift X)) (tmTime (xCnt Exe N) (evCnt Exe X) (if (p...
; # (shift X)
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (pair (shift X))
  %65 = and i64 %64, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$24, label %$23
$24:
  %67 = phi i64 [%64, %$17] ; # X
  %68 = phi i64 [%20, %$17] ; # N
; # (xCnt Exe N)
  %69 = call i64 @xCnt(i64 %0, i64 %68)
; # (evCnt Exe X)
  %70 = call i64 @evCnt(i64 %0, i64 %67)
; # (if (pair (shift X)) (evCnt Exe X) 0)
; # (shift X)
  %71 = inttoptr i64 %67 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
; # (pair (shift X))
  %74 = and i64 %73, 15
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$25, label %$26
$25:
  %76 = phi i64 [%73, %$24] ; # X
  %77 = phi i64 [%68, %$24] ; # N
; # (evCnt Exe X)
  %78 = call i64 @evCnt(i64 %0, i64 %76)
  br label %$27
$26:
  %79 = phi i64 [%73, %$24] ; # X
  %80 = phi i64 [%68, %$24] ; # N
  br label %$27
$27:
  %81 = phi i64 [%76, %$25], [%79, %$26] ; # X
  %82 = phi i64 [%77, %$25], [%80, %$26] ; # N
  %83 = phi i64 [%78, %$25], [0, %$26] ; # ->
; # (tmTime (xCnt Exe N) (evCnt Exe X) (if (pair (shift X)) (evCnt Ex...
  %84 = call i64 @tmTime(i64 %69, i64 %70, i64 %83)
  br label %$22
$23:
  %85 = phi i64 [%64, %$17] ; # X
  %86 = phi i64 [%20, %$17] ; # N
; # (xCnt Exe N)
  %87 = call i64 @xCnt(i64 %0, i64 %86)
; # (lt0 (setq N (xCnt Exe N)))
  %88 = icmp slt i64 %87, 0
  br i1 %88, label %$29, label %$28
$29:
  %89 = phi i64 [%85, %$23] ; # X
  %90 = phi i64 [%87, %$23] ; # N
  br label %$22
$28:
  %91 = phi i64 [%85, %$23] ; # X
  %92 = phi i64 [%87, %$23] ; # N
; # (/ N 3600)
  %93 = udiv i64 %92, 3600
; # (cnt (/ N 3600))
  %94 = shl i64 %93, 4
  %95 = or i64 %94, 2
; # (/ N 60)
  %96 = udiv i64 %92, 60
; # (% (/ N 60) 60)
  %97 = urem i64 %96, 60
; # (cnt (% (/ N 60) 60))
  %98 = shl i64 %97, 4
  %99 = or i64 %98, 2
; # (% N 60)
  %100 = urem i64 %92, 60
; # (cnt (% N 60))
  %101 = shl i64 %100, 4
  %102 = or i64 %101, 2
; # (cons (cnt (% N 60)) $Nil)
  %103 = call i64 @cons(i64 %102, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cnt (% (/ N 60) 60)) (cons (cnt (% N 60)) $Nil))
  %104 = call i64 @cons(i64 %99, i64 %103)
; # (cons (cnt (/ N 3600)) (cons (cnt (% (/ N 60) 60)) (cons (cnt (% ...
  %105 = call i64 @cons(i64 %95, i64 %104)
  br label %$22
$22:
  %106 = phi i64 [%81, %$27], [%89, %$29], [%91, %$28] ; # X
  %107 = phi i64 [%82, %$27], [%90, %$29], [%92, %$28] ; # N
  %108 = phi i64 [%84, %$27], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$29], [%105, %$28] ; # ->
  br label %$2
$2:
  %109 = phi i64 [%6, %$4], [%29, %$14], [%33, %$16], [%57, %$21], [%106, %$22] ; # X
  %110 = phi i64 [%9, %$4], [%30, %$14], [%20, %$16], [%60, %$21], [%108, %$22] ; # ->
  ret i64 %110
}

define i64 @_usec(i64) align 8 {
$1:
; # (if (nil? (eval (cadr Exe))) (- (getUsec YES) (val $USec)) (getUs...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
; # (getUsec YES)
  %15 = call i64 @getUsec(i1 1)
; # (val $USec)
  %16 = load i64, i64* @$USec
; # (- (getUsec YES) (val $USec))
  %17 = sub i64 %15, %16
  br label %$9
$8:
; # (getUsec NO)
  %18 = call i64 @getUsec(i1 0)
  br label %$9
$9:
  %19 = phi i64 [%17, %$7], [%18, %$8] ; # ->
; # (cnt (if (nil? (eval (cadr Exe))) (- (getUsec YES) (val $USec)) (...
  %20 = shl i64 %19, 4
  %21 = or i64 %20, 2
  ret i64 %21
}

define i1 @sharedLib(i64) align 8 {
$1:
; # (let (Nm (xName 0 Sym) S (bufString Nm (b8 (bufSize Nm))) P (strc...
; # (xName 0 Sym)
  %1 = call i64 @xName(i64 0, i64 %0)
; # (bufSize Nm)
  %2 = call i64 @bufSize(i64 %1)
; # (b8 (bufSize Nm))
  %3 = alloca i8, i64 %2
; # (bufString Nm (b8 (bufSize Nm)))
  %4 = call i8* @bufString(i64 %1, i8* %3)
; # (strchr S (char ":"))
  %5 = call i8* @strchr(i8* %4, i32 58)
; # (and P (<> P S) (val 2 P) (let N (val $PilLen) (set P 0) (let (Le...
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$3, label %$2
$3:
; # (<> P S)
  %7 = icmp ne i8* %5, %4
  br i1 %7, label %$4, label %$2
$4:
; # (val 2 P)
  %8 = getelementptr i8, i8* %5, i32 1
  %9 = load i8, i8* %8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %$5, label %$2
$5:
; # (let N (val $PilLen) (set P 0) (let (Len (strlen S) Q (b8 (+ N Le...
; # (val $PilLen)
  %11 = load i64, i64* @$PilLen
; # (set P 0)
  store i8 0, i8* %5
; # (let (Len (strlen S) Q (b8 (+ N Len (+ 4 3 1)))) (if (strchr S (c...
; # (strlen S)
  %12 = call i64 @strlen(i8* %4)
; # (+ 4 3 1)
; # (+ N Len (+ 4 3 1))
  %13 = add i64 %11, %12
  %14 = add i64 %13, 8
; # (b8 (+ N Len (+ 4 3 1)))
  %15 = alloca i8, i64 %14
; # (if (strchr S (char "/")) (strcpy Q S) (when N (memcpy Q (val $Pi...
; # (strchr S (char "/"))
  %16 = call i8* @strchr(i8* %4, i32 47)
  %17 = icmp ne i8* %16, null
  br i1 %17, label %$6, label %$7
$6:
  %18 = phi i64 [%12, %$5] ; # Len
; # (strcpy Q S)
  %19 = call i8* @strcpy(i8* %15, i8* %4)
  br label %$8
$7:
  %20 = phi i64 [%12, %$5] ; # Len
; # (when N (memcpy Q (val $PilHome) N))
  %21 = icmp ne i64 %11, 0
  br i1 %21, label %$9, label %$10
$9:
  %22 = phi i64 [%20, %$7] ; # Len
; # (val $PilHome)
  %23 = load i8*, i8** @$PilHome
; # (memcpy Q (val $PilHome) N)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %23, i64 %11, i1 0)
  br label %$10
$10:
  %24 = phi i64 [%20, %$7], [%22, %$9] ; # Len
; # (ofs Q N)
  %25 = getelementptr i8, i8* %15, i64 %11
; # (strcpy (ofs Q N) ($ "lib/"))
  %26 = call i8* @strcpy(i8* %25, i8* bitcast ([5 x i8]* @$24 to i8*))
; # (+ N 4)
  %27 = add i64 %11, 4
; # (ofs Q (+ N 4))
  %28 = getelementptr i8, i8* %15, i64 %27
; # (strcpy (ofs Q (+ N 4)) S)
  %29 = call i8* @strcpy(i8* %28, i8* %4)
; # (+ Len N 4)
  %30 = add i64 %24, %11
  %31 = add i64 %30, 4
  br label %$8
$8:
  %32 = phi i64 [%18, %$6], [%31, %$10] ; # Len
; # (ofs Q Len)
  %33 = getelementptr i8, i8* %15, i64 %32
; # (strcpy (ofs Q Len) ($ ".so"))
  %34 = call i8* @strcpy(i8* %33, i8* bitcast ([4 x i8]* @$25 to i8*))
; # (and (dlOpen Q) (dlsym @ (inc P)) (prog (set Sym (| (i64 @) 2)) Y...
; # (dlOpen Q)
  %35 = call i8* @dlOpen(i8* %15)
  %36 = icmp ne i8* %35, null
  br i1 %36, label %$12, label %$11
$12:
  %37 = phi i64 [%32, %$8] ; # Len
; # (inc P)
  %38 = getelementptr i8, i8* %5, i32 1
; # (dlsym @ (inc P))
  %39 = call i8* @dlsym(i8* %35, i8* %38)
  %40 = icmp ne i8* %39, null
  br i1 %40, label %$13, label %$11
$13:
  %41 = phi i64 [%37, %$12] ; # Len
; # (set Sym (| (i64 @) 2))
; # (i64 @)
  %42 = ptrtoint i8* %39 to i64
; # (| (i64 @) 2)
  %43 = or i64 %42, 2
  %44 = inttoptr i64 %0 to i64*
  store i64 %43, i64* %44
  br label %$11
$11:
  %45 = phi i64 [%32, %$8], [%37, %$12], [%41, %$13] ; # Len
  %46 = phi i1 [0, %$8], [0, %$12], [1, %$13] ; # ->
  br label %$2
$2:
  %47 = phi i1 [0, %$1], [0, %$3], [0, %$4], [%46, %$11] ; # ->
  ret i1 %47
}

define void @mark(i64) align 8 {
$1:
; # (let Tos 0 (loop (until (cnt? E) (let (P (any (& E -16)) Q (cdr P...
; # (loop (until (cnt? E) (let (P (any (& E -16)) Q (cdr P)) (? (=0 (...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%85, %$17] ; # E
  %2 = phi i64 [0, %$1], [%86, %$17] ; # Tos
; # (until (cnt? E) (let (P (any (& E -16)) Q (cdr P)) (? (=0 (& Q 1)...
  br label %$3
$3:
  %3 = phi i64 [%1, %$2], [%52, %$7] ; # E
  %4 = phi i64 [%2, %$2], [%48, %$7] ; # Tos
; # (cnt? E)
  %5 = and i64 %3, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$4
$4:
  %7 = phi i64 [%3, %$3] ; # E
  %8 = phi i64 [%4, %$3] ; # Tos
; # (let (P (any (& E -16)) Q (cdr P)) (? (=0 (& Q 1))) (set 2 P (set...
; # (& E -16)
  %9 = and i64 %7, -16
; # (any (& E -16))
; # (cdr P)
  %10 = inttoptr i64 %9 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
; # (? (=0 (& Q 1)))
; # (& Q 1)
  %13 = and i64 %12, 1
; # (=0 (& Q 1))
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %$5, label %$6
$6:
  %15 = phi i64 [%7, %$4] ; # E
  %16 = phi i64 [%8, %$4] ; # Tos
  %17 = phi i64 [%12, %$4] ; # Q
; # (set 2 P (setq Q (& Q -2)))
; # (& Q -2)
  %18 = and i64 %17, -2
  %19 = inttoptr i64 %9 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
; # (? (big? E) (until (cnt? Q) (let N (val (big Q)) (? (=0 (& N 1)))...
; # (big? E)
  %21 = and i64 %15, 4
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$8, label %$7
$8:
  %23 = phi i64 [%15, %$6] ; # E
  %24 = phi i64 [%16, %$6] ; # Tos
  %25 = phi i64 [%18, %$6] ; # Q
; # (until (cnt? Q) (let N (val (big Q)) (? (=0 (& N 1))) (setq Q (se...
  br label %$9
$9:
  %26 = phi i64 [%23, %$8], [%39, %$12] ; # E
  %27 = phi i64 [%24, %$8], [%40, %$12] ; # Tos
  %28 = phi i64 [%25, %$8], [%43, %$12] ; # Q
; # (cnt? Q)
  %29 = and i64 %28, 2
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$11, label %$10
$10:
  %31 = phi i64 [%26, %$9] ; # E
  %32 = phi i64 [%27, %$9] ; # Tos
  %33 = phi i64 [%28, %$9] ; # Q
; # (let N (val (big Q)) (? (=0 (& N 1))) (setq Q (set (big Q) (& N -...
; # (big Q)
  %34 = add i64 %33, 4
; # (val (big Q))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (? (=0 (& N 1)))
; # (& N 1)
  %37 = and i64 %36, 1
; # (=0 (& N 1))
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$11, label %$12
$12:
  %39 = phi i64 [%31, %$10] ; # E
  %40 = phi i64 [%32, %$10] ; # Tos
  %41 = phi i64 [%33, %$10] ; # Q
; # (set (big Q) (& N -2))
; # (big Q)
  %42 = add i64 %41, 4
; # (& N -2)
  %43 = and i64 %36, -2
  %44 = inttoptr i64 %42 to i64*
  store i64 %43, i64* %44
  br label %$9
$11:
  %45 = phi i64 [%26, %$9], [%31, %$10] ; # E
  %46 = phi i64 [%27, %$9], [%32, %$10] ; # Tos
  %47 = phi i64 [%28, %$9], [%33, %$10] ; # Q
  br label %$5
$7:
  %48 = phi i64 [%15, %$6] ; # E
  %49 = phi i64 [%16, %$6] ; # Tos
  %50 = phi i64 [%18, %$6] ; # Q
; # (let X E (setq E (val P)) (set P (| Tos 1)) (setq Tos X))
; # (val P)
  %51 = inttoptr i64 %9 to i64*
  %52 = load i64, i64* %51
; # (set P (| Tos 1))
; # (| Tos 1)
  %53 = or i64 %49, 1
  %54 = inttoptr i64 %9 to i64*
  store i64 %53, i64* %54
  br label %$3
$5:
  %55 = phi i64 [%3, %$3], [%7, %$4], [%45, %$11] ; # E
  %56 = phi i64 [%4, %$3], [%8, %$4], [%46, %$11] ; # Tos
; # (loop (let P (any (& Tos -16)) (unless P (ret)) (let Q (val P) (?...
  br label %$13
$13:
  %57 = phi i64 [%55, %$5], [%79, %$16] ; # E
  %58 = phi i64 [%56, %$5], [%82, %$16] ; # Tos
; # (let P (any (& Tos -16)) (unless P (ret)) (let Q (val P) (? (& Q ...
; # (& Tos -16)
  %59 = and i64 %58, -16
; # (any (& Tos -16))
; # (unless P (ret))
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$15, label %$14
$14:
  %61 = phi i64 [%57, %$13] ; # E
  %62 = phi i64 [%58, %$13] ; # Tos
; # (ret)
  ret void
$15:
  %63 = phi i64 [%57, %$13] ; # E
  %64 = phi i64 [%58, %$13] ; # Tos
; # (let Q (val P) (? (& Q 1) (set P E) (setq E (cdr P)) (set 2 P (& ...
; # (val P)
  %65 = inttoptr i64 %59 to i64*
  %66 = load i64, i64* %65
; # (? (& Q 1) (set P E) (setq E (cdr P)) (set 2 P (& Q -2)))
; # (& Q 1)
  %67 = and i64 %66, 1
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$18, label %$16
$18:
  %69 = phi i64 [%63, %$15] ; # E
  %70 = phi i64 [%64, %$15] ; # Tos
; # (set P E)
  %71 = inttoptr i64 %59 to i64*
  store i64 %69, i64* %71
; # (cdr P)
  %72 = inttoptr i64 %59 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (set 2 P (& Q -2))
; # (& Q -2)
  %75 = and i64 %66, -2
  %76 = inttoptr i64 %59 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  store i64 %75, i64* %77
  br label %$17
$16:
  %78 = phi i64 [%63, %$15] ; # E
  %79 = phi i64 [%64, %$15] ; # Tos
; # (let X Tos (setq Tos (cdr P)) (set 2 P E) (setq E X))
; # (cdr P)
  %80 = inttoptr i64 %59 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
; # (set 2 P E)
  %83 = inttoptr i64 %59 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %78, i64* %84
  br label %$13
$17:
  %85 = phi i64 [%74, %$18] ; # E
  %86 = phi i64 [%70, %$18] ; # Tos
  %87 = phi i64 [%75, %$18] ; # ->
  br label %$2
}

define void @gc() align 8 {
$1:
; # (set $DB -ZERO)
  %0 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 232) to i64) to i64*
  store i64 10, i64* %0
; # (let P $Nil (set P (| (val P) 1)) (setq P (ofs P 4)) (loop (set P...
; # (set P (| (val P) 1))
; # (val P)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64) to i64*
  %2 = load i64, i64* %1
; # (| (val P) 1)
  %3 = or i64 %2, 1
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64) to i64*
  store i64 %3, i64* %4
; # (ofs P 4)
  %5 = add i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), 32
; # (loop (set P (| (val P) 1)) (? (== P $LastSym)) (setq P (ofs P 2)...
  br label %$2
$2:
  %6 = phi i64 [%5, %$1], [%13, %$3] ; # P
; # (set P (| (val P) 1))
; # (val P)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (| (val P) 1)
  %9 = or i64 %8, 1
  %10 = inttoptr i64 %6 to i64*
  store i64 %9, i64* %10
; # (? (== P $LastSym))
; # (== P $LastSym)
  %11 = icmp eq i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 7000) to i64)
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i64 [%6, %$2] ; # P
; # (ofs P 2)
  %13 = add i64 %12, 16
  br label %$2
$4:
  %14 = phi i64 [%6, %$2] ; # P
  %15 = phi i64 [0, %$2] ; # ->
; # (let P (val $Heaps) (loop (let C CELLS (loop (set 2 P (| (cdr P) ...
; # (val $Heaps)
  %16 = load i64, i64* @$Heaps
; # (loop (let C CELLS (loop (set 2 P (| (cdr P) 1)) (setq P (ofs P 2...
  br label %$5
$5:
  %17 = phi i64 [%16, %$4], [%37, %$9] ; # P
; # (let C CELLS (loop (set 2 P (| (cdr P) 1)) (setq P (ofs P 2)) (? ...
; # (loop (set 2 P (| (cdr P) 1)) (setq P (ofs P 2)) (? (=0 (dec 'C))...
  br label %$6
$6:
  %18 = phi i64 [%17, %$5], [%29, %$7] ; # P
  %19 = phi i64 [65536, %$5], [%30, %$7] ; # C
; # (set 2 P (| (cdr P) 1))
; # (cdr P)
  %20 = inttoptr i64 %18 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (| (cdr P) 1)
  %23 = or i64 %22, 1
  %24 = inttoptr i64 %18 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
; # (ofs P 2)
  %26 = add i64 %18, 16
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %27 = sub i64 %19, 1
; # (=0 (dec 'C))
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$7
$7:
  %29 = phi i64 [%26, %$6] ; # P
  %30 = phi i64 [%27, %$6] ; # C
  br label %$6
$8:
  %31 = phi i64 [%26, %$6] ; # P
  %32 = phi i64 [%27, %$6] ; # C
  %33 = phi i64 [0, %$6] ; # ->
; # (val P)
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
; # (? (=0 P))
; # (=0 P)
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$10, label %$9
$9:
  %37 = phi i64 [%35, %$8] ; # P
  br label %$5
$10:
  %38 = phi i64 [%35, %$8] ; # P
  %39 = phi i64 [0, %$8] ; # ->
; # (let P (any (gcData)) (loop (mark (val P)) (? (== P $LispEnd)) (s...
; # (i8* $Intern)
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i8*
; # (any (gcData))
  %41 = ptrtoint i8* %40 to i64
; # (loop (mark (val P)) (? (== P $LispEnd)) (setq P (ofs P 1)))
  br label %$11
$11:
  %42 = phi i64 [%41, %$10], [%47, %$12] ; # P
; # (val P)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (mark (val P))
  call void @mark(i64 %44)
; # (? (== P $LispEnd))
; # (== P $LispEnd)
  %45 = icmp eq i64 %42, ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 416) to i64)
  br i1 %45, label %$13, label %$12
$12:
  %46 = phi i64 [%42, %$11] ; # P
; # (ofs P 1)
  %47 = add i64 %46, 8
  br label %$11
$13:
  %48 = phi i64 [%42, %$11] ; # P
  %49 = phi i64 [0, %$11] ; # ->
; # (let P (val $Link) (while P (mark (val P)) (shift P)))
; # (val $Link)
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
; # (while P (mark (val P)) (shift P))
  br label %$14
$14:
  %52 = phi i64 [%51, %$13], [%59, %$15] ; # P
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$15, label %$16
$15:
  %54 = phi i64 [%52, %$14] ; # P
; # (val P)
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (mark (val P))
  call void @mark(i64 %56)
; # (shift P)
  %57 = inttoptr i64 %54 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  br label %$14
$16:
  %60 = phi i64 [%52, %$14] ; # P
; # (let P (val $Bind) (while P (mark (val P)) (mark (val 2 P)) (setq...
; # (val $Bind)
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %62 = load i64, i64* %61
; # (while P (mark (val P)) (mark (val 2 P)) (setq P (val 3 P)))
  br label %$17
$17:
  %63 = phi i64 [%62, %$16], [%73, %$18] ; # P
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$18, label %$19
$18:
  %65 = phi i64 [%63, %$17] ; # P
; # (val P)
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
; # (mark (val P))
  call void @mark(i64 %67)
; # (val 2 P)
  %68 = inttoptr i64 %65 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
; # (mark (val 2 P))
  call void @mark(i64 %70)
; # (val 3 P)
  %71 = inttoptr i64 %65 to i64*
  %72 = getelementptr i64, i64* %71, i32 2
  %73 = load i64, i64* %72
  br label %$17
$19:
  %74 = phi i64 [%63, %$17] ; # P
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (when (Ca: t...
; # (val $Catch)
  %75 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (when (Ca: tag) (mark @)) (mark (...
  br label %$20
$20:
  %76 = phi i8* [%75, %$19], [%111, %$24] ; # Ca
  %77 = icmp ne i8* %76, null
  br i1 %77, label %$21, label %$22
$21:
  %78 = phi i8* [%76, %$20] ; # Ca
; # (let Ca: (caFrame Ca) (when (Ca: tag) (mark @)) (mark (Ca: fin)) ...
; # (when (Ca: tag) (mark @))
; # (Ca: tag)
  %79 = getelementptr i8, i8* %78, i32 8
  %80 = ptrtoint i8* %79 to i64
  %81 = inttoptr i64 %80 to i64*
  %82 = load i64, i64* %81
  %83 = icmp ne i64 %82, 0
  br i1 %83, label %$23, label %$24
$23:
  %84 = phi i8* [%78, %$21] ; # Ca
; # (mark @)
  call void @mark(i64 %82)
  br label %$24
$24:
  %85 = phi i8* [%78, %$21], [%84, %$23] ; # Ca
; # (Ca: fin)
  %86 = getelementptr i8, i8* %78, i32 16
  %87 = ptrtoint i8* %86 to i64
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (mark (Ca: fin))
  call void @mark(i64 %89)
; # (Ca: intrn)
  %90 = getelementptr i8, i8* %78, i32 176
  %91 = ptrtoint i8* %90 to i64
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
; # (mark (Ca: intrn))
  call void @mark(i64 %93)
; # (Ca: trns1)
  %94 = getelementptr i8, i8* %78, i32 184
  %95 = ptrtoint i8* %94 to i64
  %96 = inttoptr i64 %95 to i64*
  %97 = load i64, i64* %96
; # (mark (Ca: trns1))
  call void @mark(i64 %97)
; # (Ca: trns2)
  %98 = getelementptr i8, i8* %78, i32 192
  %99 = ptrtoint i8* %98 to i64
  %100 = inttoptr i64 %99 to i64*
  %101 = load i64, i64* %100
; # (mark (Ca: trns2))
  call void @mark(i64 %101)
; # (Ca: priv1)
  %102 = getelementptr i8, i8* %78, i32 200
  %103 = ptrtoint i8* %102 to i64
  %104 = inttoptr i64 %103 to i64*
  %105 = load i64, i64* %104
; # (mark (Ca: priv1))
  call void @mark(i64 %105)
; # (Ca: priv2)
  %106 = getelementptr i8, i8* %78, i32 208
  %107 = ptrtoint i8* %106 to i64
  %108 = inttoptr i64 %107 to i64*
  %109 = load i64, i64* %108
; # (mark (Ca: priv2))
  call void @mark(i64 %109)
; # (Ca: link)
  %110 = bitcast i8* %78 to i8**
  %111 = load i8*, i8** %110
  br label %$20
$22:
  %112 = phi i8* [%76, %$20] ; # Ca
; # (let Put (val $Output) (while Put (let Put: (putFrame Put) (when ...
; # (val $Output)
  %113 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 72) to i8**)
; # (while Put (let Put: (putFrame Put) (when (Put: char) (mark @)) (...
  br label %$25
$25:
  %114 = phi i8* [%113, %$22], [%125, %$29] ; # Put
  %115 = icmp ne i8* %114, null
  br i1 %115, label %$26, label %$27
$26:
  %116 = phi i8* [%114, %$25] ; # Put
; # (let Put: (putFrame Put) (when (Put: char) (mark @)) (setq Put (P...
; # (when (Put: char) (mark @))
; # (Put: char)
  %117 = getelementptr i8, i8* %116, i32 24
  %118 = ptrtoint i8* %117 to i64
  %119 = inttoptr i64 %118 to i64*
  %120 = load i64, i64* %119
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$28, label %$29
$28:
  %122 = phi i8* [%116, %$26] ; # Put
; # (mark @)
  call void @mark(i64 %120)
  br label %$29
$29:
  %123 = phi i8* [%116, %$26], [%122, %$28] ; # Put
; # (Put: link)
  %124 = bitcast i8* %116 to i8**
  %125 = load i8*, i8** %124
  br label %$25
$27:
  %126 = phi i8* [%114, %$25] ; # Put
; # (let Crt (val $Coroutines) (while Crt (let Crt: (coroutine Crt) (...
; # (val $Coroutines)
  %127 = load i8*, i8** @$Coroutines
; # (while Crt (let Crt: (coroutine Crt) (when (and (Crt: tag) (Crt: ...
  br label %$30
$30:
  %128 = phi i8* [%127, %$27], [%264, %$36] ; # Crt
  %129 = icmp ne i8* %128, null
  br i1 %129, label %$31, label %$32
$31:
  %130 = phi i8* [%128, %$30] ; # Crt
; # (let Crt: (coroutine Crt) (when (and (Crt: tag) (Crt: at)) (mark ...
; # (when (and (Crt: tag) (Crt: at)) (mark (Crt: tag)) (mark (Crt: pr...
; # (and (Crt: tag) (Crt: at))
; # (Crt: tag)
  %131 = ptrtoint i8* %130 to i64
  %132 = inttoptr i64 %131 to i64*
  %133 = load i64, i64* %132
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$34, label %$33
$34:
  %135 = phi i8* [%130, %$31] ; # Crt
; # (Crt: at)
  %136 = getelementptr i8, i8* %130, i32 48
  %137 = ptrtoint i8* %136 to i64
  %138 = inttoptr i64 %137 to i64*
  %139 = load i64, i64* %138
  %140 = icmp ne i64 %139, 0
  br label %$33
$33:
  %141 = phi i8* [%130, %$31], [%135, %$34] ; # Crt
  %142 = phi i1 [0, %$31], [%140, %$34] ; # ->
  br i1 %142, label %$35, label %$36
$35:
  %143 = phi i8* [%141, %$33] ; # Crt
; # (Crt: tag)
  %144 = ptrtoint i8* %130 to i64
  %145 = inttoptr i64 %144 to i64*
  %146 = load i64, i64* %145
; # (mark (Crt: tag))
  call void @mark(i64 %146)
; # (Crt: prg)
  %147 = getelementptr i8, i8* %130, i32 32
  %148 = ptrtoint i8* %147 to i64
  %149 = inttoptr i64 %148 to i64*
  %150 = load i64, i64* %149
; # (mark (Crt: prg))
  call void @mark(i64 %150)
; # (Crt: at)
  %151 = getelementptr i8, i8* %130, i32 48
  %152 = ptrtoint i8* %151 to i64
  %153 = inttoptr i64 %152 to i64*
  %154 = load i64, i64* %153
; # (mark (Crt: at))
  call void @mark(i64 %154)
; # (Crt: intrn)
  %155 = getelementptr i8, i8* %130, i32 240
  %156 = ptrtoint i8* %155 to i64
  %157 = inttoptr i64 %156 to i64*
  %158 = load i64, i64* %157
; # (mark (Crt: intrn))
  call void @mark(i64 %158)
; # (Crt: trns1)
  %159 = getelementptr i8, i8* %130, i32 248
  %160 = ptrtoint i8* %159 to i64
  %161 = inttoptr i64 %160 to i64*
  %162 = load i64, i64* %161
; # (mark (Crt: trns1))
  call void @mark(i64 %162)
; # (Crt: trns2)
  %163 = getelementptr i8, i8* %130, i32 256
  %164 = ptrtoint i8* %163 to i64
  %165 = inttoptr i64 %164 to i64*
  %166 = load i64, i64* %165
; # (mark (Crt: trns2))
  call void @mark(i64 %166)
; # (Crt: priv1)
  %167 = getelementptr i8, i8* %130, i32 264
  %168 = ptrtoint i8* %167 to i64
  %169 = inttoptr i64 %168 to i64*
  %170 = load i64, i64* %169
; # (mark (Crt: priv1))
  call void @mark(i64 %170)
; # (Crt: priv2)
  %171 = getelementptr i8, i8* %130, i32 272
  %172 = ptrtoint i8* %171 to i64
  %173 = inttoptr i64 %172 to i64*
  %174 = load i64, i64* %173
; # (mark (Crt: priv2))
  call void @mark(i64 %174)
; # (let P (Crt: (env $Link any)) (while P (mark (val P)) (shift P)))...
; # (Crt: (env $Link any))
  %175 = getelementptr i8, i8* %130, i32 96
  %176 = ptrtoint i8* %175 to i64
  %177 = inttoptr i64 %176 to i64*
  %178 = load i64, i64* %177
; # (while P (mark (val P)) (shift P))
  br label %$37
$37:
  %179 = phi i8* [%143, %$35], [%182, %$38] ; # Crt
  %180 = phi i64 [%178, %$35], [%188, %$38] ; # P
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$38, label %$39
$38:
  %182 = phi i8* [%179, %$37] ; # Crt
  %183 = phi i64 [%180, %$37] ; # P
; # (val P)
  %184 = inttoptr i64 %183 to i64*
  %185 = load i64, i64* %184
; # (mark (val P))
  call void @mark(i64 %185)
; # (shift P)
  %186 = inttoptr i64 %183 to i64*
  %187 = getelementptr i64, i64* %186, i32 1
  %188 = load i64, i64* %187
  br label %$37
$39:
  %189 = phi i8* [%179, %$37] ; # Crt
  %190 = phi i64 [%180, %$37] ; # P
; # (let P (Crt: (env $Bind any)) (while P (mark (val P)) (mark (val ...
; # (Crt: (env $Bind any))
  %191 = getelementptr i8, i8* %130, i32 96
  %192 = getelementptr i8, i8* %191, i32 8
  %193 = ptrtoint i8* %192 to i64
  %194 = inttoptr i64 %193 to i64*
  %195 = load i64, i64* %194
; # (while P (mark (val P)) (mark (val 2 P)) (setq P (val 3 P)))
  br label %$40
$40:
  %196 = phi i8* [%189, %$39], [%199, %$41] ; # Crt
  %197 = phi i64 [%195, %$39], [%208, %$41] ; # P
  %198 = icmp ne i64 %197, 0
  br i1 %198, label %$41, label %$42
$41:
  %199 = phi i8* [%196, %$40] ; # Crt
  %200 = phi i64 [%197, %$40] ; # P
; # (val P)
  %201 = inttoptr i64 %200 to i64*
  %202 = load i64, i64* %201
; # (mark (val P))
  call void @mark(i64 %202)
; # (val 2 P)
  %203 = inttoptr i64 %200 to i64*
  %204 = getelementptr i64, i64* %203, i32 1
  %205 = load i64, i64* %204
; # (mark (val 2 P))
  call void @mark(i64 %205)
; # (val 3 P)
  %206 = inttoptr i64 %200 to i64*
  %207 = getelementptr i64, i64* %206, i32 2
  %208 = load i64, i64* %207
  br label %$40
$42:
  %209 = phi i8* [%196, %$40] ; # Crt
  %210 = phi i64 [%197, %$40] ; # P
; # (let Ca (Crt: (env $Catch i8*)) (while Ca (let Ca: (caFrame Ca) (...
; # (Crt: (env $Catch i8*))
  %211 = getelementptr i8, i8* %130, i32 96
  %212 = getelementptr i8, i8* %211, i32 24
  %213 = bitcast i8* %212 to i8**
  %214 = load i8*, i8** %213
; # (while Ca (let Ca: (caFrame Ca) (when (Ca: tag) (mark (Ca: tag)))...
  br label %$43
$43:
  %215 = phi i8* [%209, %$42], [%231, %$47] ; # Crt
  %216 = phi i8* [%214, %$42], [%258, %$47] ; # Ca
  %217 = icmp ne i8* %216, null
  br i1 %217, label %$44, label %$45
$44:
  %218 = phi i8* [%215, %$43] ; # Crt
  %219 = phi i8* [%216, %$43] ; # Ca
; # (let Ca: (caFrame Ca) (when (Ca: tag) (mark (Ca: tag))) (mark (Ca...
; # (when (Ca: tag) (mark (Ca: tag)))
; # (Ca: tag)
  %220 = getelementptr i8, i8* %219, i32 8
  %221 = ptrtoint i8* %220 to i64
  %222 = inttoptr i64 %221 to i64*
  %223 = load i64, i64* %222
  %224 = icmp ne i64 %223, 0
  br i1 %224, label %$46, label %$47
$46:
  %225 = phi i8* [%218, %$44] ; # Crt
  %226 = phi i8* [%219, %$44] ; # Ca
; # (Ca: tag)
  %227 = getelementptr i8, i8* %219, i32 8
  %228 = ptrtoint i8* %227 to i64
  %229 = inttoptr i64 %228 to i64*
  %230 = load i64, i64* %229
; # (mark (Ca: tag))
  call void @mark(i64 %230)
  br label %$47
$47:
  %231 = phi i8* [%218, %$44], [%225, %$46] ; # Crt
  %232 = phi i8* [%219, %$44], [%226, %$46] ; # Ca
; # (Ca: fin)
  %233 = getelementptr i8, i8* %219, i32 16
  %234 = ptrtoint i8* %233 to i64
  %235 = inttoptr i64 %234 to i64*
  %236 = load i64, i64* %235
; # (mark (Ca: fin))
  call void @mark(i64 %236)
; # (Ca: intrn)
  %237 = getelementptr i8, i8* %219, i32 176
  %238 = ptrtoint i8* %237 to i64
  %239 = inttoptr i64 %238 to i64*
  %240 = load i64, i64* %239
; # (mark (Ca: intrn))
  call void @mark(i64 %240)
; # (Ca: trns1)
  %241 = getelementptr i8, i8* %219, i32 184
  %242 = ptrtoint i8* %241 to i64
  %243 = inttoptr i64 %242 to i64*
  %244 = load i64, i64* %243
; # (mark (Ca: trns1))
  call void @mark(i64 %244)
; # (Ca: trns2)
  %245 = getelementptr i8, i8* %219, i32 192
  %246 = ptrtoint i8* %245 to i64
  %247 = inttoptr i64 %246 to i64*
  %248 = load i64, i64* %247
; # (mark (Ca: trns2))
  call void @mark(i64 %248)
; # (Ca: priv1)
  %249 = getelementptr i8, i8* %219, i32 200
  %250 = ptrtoint i8* %249 to i64
  %251 = inttoptr i64 %250 to i64*
  %252 = load i64, i64* %251
; # (mark (Ca: priv1))
  call void @mark(i64 %252)
; # (Ca: priv2)
  %253 = getelementptr i8, i8* %219, i32 208
  %254 = ptrtoint i8* %253 to i64
  %255 = inttoptr i64 %254 to i64*
  %256 = load i64, i64* %255
; # (mark (Ca: priv2))
  call void @mark(i64 %256)
; # (Ca: link)
  %257 = bitcast i8* %219 to i8**
  %258 = load i8*, i8** %257
  br label %$43
$45:
  %259 = phi i8* [%215, %$43] ; # Crt
  %260 = phi i8* [%216, %$43] ; # Ca
  br label %$36
$36:
  %261 = phi i8* [%141, %$33], [%259, %$45] ; # Crt
; # (Crt: nxt)
  %262 = getelementptr i8, i8* %130, i32 16
  %263 = bitcast i8* %262 to i8**
  %264 = load i8*, i8** %263
  br label %$30
$32:
  %265 = phi i8* [%128, %$30] ; # Crt
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (any (& (cdr P) -...
; # (val $Extern)
  %266 = load i64, i64* @$Extern
; # (loop (loop (let X (any (& (cdr P) -2)) (set 2 P X) (let Y (any (...
  br label %$48
$48:
  %267 = phi i64 [0, %$32], [%384, %$63] ; # Tos
  %268 = phi i64 [%266, %$32], [%385, %$63] ; # P
; # (loop (let X (any (& (cdr P) -2)) (set 2 P X) (let Y (any (& (cdr...
  br label %$49
$49:
  %269 = phi i64 [%267, %$48], [%286, %$50] ; # Tos
  %270 = phi i64 [%268, %$48], [%280, %$50] ; # P
; # (let X (any (& (cdr P) -2)) (set 2 P X) (let Y (any (& (cdr X) -2...
; # (cdr P)
  %271 = inttoptr i64 %270 to i64*
  %272 = getelementptr i64, i64* %271, i32 1
  %273 = load i64, i64* %272
; # (& (cdr P) -2)
  %274 = and i64 %273, -2
; # (any (& (cdr P) -2))
; # (set 2 P X)
  %275 = inttoptr i64 %270 to i64*
  %276 = getelementptr i64, i64* %275, i32 1
  store i64 %274, i64* %276
; # (let Y (any (& (cdr X) -2)) (set 2 X Y) (? (atom Y)) (let Z P (se...
; # (cdr X)
  %277 = inttoptr i64 %274 to i64*
  %278 = getelementptr i64, i64* %277, i32 1
  %279 = load i64, i64* %278
; # (& (cdr X) -2)
  %280 = and i64 %279, -2
; # (any (& (cdr X) -2))
; # (set 2 X Y)
  %281 = inttoptr i64 %274 to i64*
  %282 = getelementptr i64, i64* %281, i32 1
  store i64 %280, i64* %282
; # (? (atom Y))
; # (atom Y)
  %283 = and i64 %280, 15
  %284 = icmp ne i64 %283, 0
  br i1 %284, label %$51, label %$50
$50:
  %285 = phi i64 [%269, %$49] ; # Tos
  %286 = phi i64 [%270, %$49] ; # P
; # (let Z P (setq P Y) (set 2 X Tos) (setq Tos Z))
; # (set 2 X Tos)
  %287 = inttoptr i64 %274 to i64*
  %288 = getelementptr i64, i64* %287, i32 1
  store i64 %285, i64* %288
  br label %$49
$51:
  %289 = phi i64 [%269, %$49] ; # Tos
  %290 = phi i64 [%270, %$49] ; # P
  %291 = phi i64 [0, %$49] ; # ->
; # (loop (let S (val P) (when (& (val S) 1) (let Tail (val (tail S))...
  br label %$52
$52:
  %292 = phi i64 [%289, %$51], [%381, %$69] ; # Tos
  %293 = phi i64 [%290, %$51], [%382, %$69] ; # P
; # (let S (val P) (when (& (val S) 1) (let Tail (val (tail S)) (unle...
; # (val P)
  %294 = inttoptr i64 %293 to i64*
  %295 = load i64, i64* %294
; # (when (& (val S) 1) (let Tail (val (tail S)) (unless (num? Tail) ...
; # (val S)
  %296 = inttoptr i64 %295 to i64*
  %297 = load i64, i64* %296
; # (& (val S) 1)
  %298 = and i64 %297, 1
  %299 = icmp ne i64 %298, 0
  br i1 %299, label %$53, label %$54
$53:
  %300 = phi i64 [%292, %$52] ; # Tos
  %301 = phi i64 [%293, %$52] ; # P
; # (let Tail (val (tail S)) (unless (num? Tail) (setq Tail (& Tail -...
; # (tail S)
  %302 = add i64 %295, -8
; # (val (tail S))
  %303 = inttoptr i64 %302 to i64*
  %304 = load i64, i64* %303
; # (unless (num? Tail) (setq Tail (& Tail -10)) (until (num? (shift ...
; # (num? Tail)
  %305 = and i64 %304, 6
  %306 = icmp ne i64 %305, 0
  br i1 %306, label %$56, label %$55
$55:
  %307 = phi i64 [%300, %$53] ; # Tos
  %308 = phi i64 [%301, %$53] ; # P
  %309 = phi i64 [%304, %$53] ; # Tail
; # (& Tail -10)
  %310 = and i64 %309, -10
; # (until (num? (shift Tail)) (setq Tail (& Tail -2)))
  br label %$57
$57:
  %311 = phi i64 [%307, %$55], [%319, %$58] ; # Tos
  %312 = phi i64 [%308, %$55], [%320, %$58] ; # P
  %313 = phi i64 [%310, %$55], [%322, %$58] ; # Tail
; # (shift Tail)
  %314 = inttoptr i64 %313 to i64*
  %315 = getelementptr i64, i64* %314, i32 1
  %316 = load i64, i64* %315
; # (num? (shift Tail))
  %317 = and i64 %316, 6
  %318 = icmp ne i64 %317, 0
  br i1 %318, label %$59, label %$58
$58:
  %319 = phi i64 [%311, %$57] ; # Tos
  %320 = phi i64 [%312, %$57] ; # P
  %321 = phi i64 [%316, %$57] ; # Tail
; # (& Tail -2)
  %322 = and i64 %321, -2
  br label %$57
$59:
  %323 = phi i64 [%311, %$57] ; # Tos
  %324 = phi i64 [%312, %$57] ; # P
  %325 = phi i64 [%316, %$57] ; # Tail
  br label %$56
$56:
  %326 = phi i64 [%300, %$53], [%323, %$59] ; # Tos
  %327 = phi i64 [%301, %$53], [%324, %$59] ; # P
  %328 = phi i64 [%304, %$53], [%325, %$59] ; # Tail
; # (add Tail Tail)
  %329 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %328, i64 %328)
  %330 = extractvalue {i64, i1} %329, 1
  %331 = extractvalue {i64, i1} %329, 0
; # (when @@ (mark S))
  br i1 %330, label %$60, label %$61
$60:
  %332 = phi i64 [%326, %$56] ; # Tos
  %333 = phi i64 [%327, %$56] ; # P
  %334 = phi i64 [%328, %$56] ; # Tail
; # (mark S)
  call void @mark(i64 %295)
  br label %$61
$61:
  %335 = phi i64 [%326, %$56], [%332, %$60] ; # Tos
  %336 = phi i64 [%327, %$56], [%333, %$60] ; # P
  %337 = phi i64 [%328, %$56], [%334, %$60] ; # Tail
  br label %$54
$54:
  %338 = phi i64 [%292, %$52], [%335, %$61] ; # Tos
  %339 = phi i64 [%293, %$52], [%336, %$61] ; # P
; # (let X (cdr P) (? (pair (car X)) (let Z P (setq P @) (set X Tos) ...
; # (cdr P)
  %340 = inttoptr i64 %339 to i64*
  %341 = getelementptr i64, i64* %340, i32 1
  %342 = load i64, i64* %341
; # (? (pair (car X)) (let Z P (setq P @) (set X Tos) (setq Tos (| Z ...
; # (car X)
  %343 = inttoptr i64 %342 to i64*
  %344 = load i64, i64* %343
; # (pair (car X))
  %345 = and i64 %344, 15
  %346 = icmp eq i64 %345, 0
  br i1 %346, label %$64, label %$62
$64:
  %347 = phi i64 [%338, %$54] ; # Tos
  %348 = phi i64 [%339, %$54] ; # P
; # (let Z P (setq P @) (set X Tos) (setq Tos (| Z 8)))
; # (set X Tos)
  %349 = inttoptr i64 %342 to i64*
  store i64 %347, i64* %349
; # (| Z 8)
  %350 = or i64 %348, 8
  br label %$63
$62:
  %351 = phi i64 [%338, %$54] ; # Tos
  %352 = phi i64 [%339, %$54] ; # P
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$65
$65:
  %353 = phi i64 [%351, %$62], [%379, %$68] ; # Tos
  %354 = phi i64 [%352, %$62], [%374, %$68] ; # P
; # (unless Tos (goto 1))
  %355 = icmp ne i64 %353, 0
  br i1 %355, label %$67, label %$66
$66:
  %356 = phi i64 [%353, %$65] ; # Tos
  %357 = phi i64 [%354, %$65] ; # P
; # (goto 1)
  br label %$-1
$67:
  %358 = phi i64 [%353, %$65] ; # Tos
  %359 = phi i64 [%354, %$65] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set ...
; # (& Tos 8)
  %360 = and i64 %358, 8
; # (=0 (& Tos 8))
  %361 = icmp eq i64 %360, 0
  br i1 %361, label %$70, label %$68
$70:
  %362 = phi i64 [%358, %$67] ; # Tos
  %363 = phi i64 [%359, %$67] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %364 = inttoptr i64 %362 to i64*
  %365 = getelementptr i64, i64* %364, i32 1
  %366 = load i64, i64* %365
; # (cdr Y)
  %367 = inttoptr i64 %366 to i64*
  %368 = getelementptr i64, i64* %367, i32 1
  %369 = load i64, i64* %368
; # (set 2 Y P)
  %370 = inttoptr i64 %366 to i64*
  %371 = getelementptr i64, i64* %370, i32 1
  store i64 %363, i64* %371
  br label %$69
$68:
  %372 = phi i64 [%358, %$67] ; # Tos
  %373 = phi i64 [%359, %$67] ; # P
; # (& Tos -9)
  %374 = and i64 %372, -9
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %375 = inttoptr i64 %374 to i64*
  %376 = getelementptr i64, i64* %375, i32 1
  %377 = load i64, i64* %376
; # (car Y)
  %378 = inttoptr i64 %377 to i64*
  %379 = load i64, i64* %378
; # (set Y P)
  %380 = inttoptr i64 %377 to i64*
  store i64 %373, i64* %380
  br label %$65
$69:
  %381 = phi i64 [%369, %$70] ; # Tos
  %382 = phi i64 [%362, %$70] ; # P
  %383 = phi i64 [%362, %$70] ; # ->
  br label %$52
$63:
  %384 = phi i64 [%350, %$64] ; # Tos
  %385 = phi i64 [%344, %$64] ; # P
  %386 = phi i64 [%350, %$64] ; # ->
  br label %$48
$71:
; # (: 1 (set $DB $Db1) (when (& (val $Db1) 1) (set $Db1 $Nil (tail $...
  br label %$-1
$-1:
; # (set $DB $Db1)
  %387 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 232) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 408) to i64), i64* %387
; # (when (& (val $Db1) 1) (set $Db1 $Nil (tail $Db1) DB1))
; # (val $Db1)
  %388 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  %389 = load i64, i64* %388
; # (& (val $Db1) 1)
  %390 = and i64 %389, 1
  %391 = icmp ne i64 %390, 0
  br i1 %391, label %$72, label %$73
$72:
; # (set $Db1 $Nil (tail $Db1) DB1)
  %392 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %392
; # (tail $Db1)
  %393 = add i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 408) to i64), -8
  %394 = inttoptr i64 %393 to i64*
  store i64 26, i64* %394
  br label %$73
$73:
; # (let (Tos 0 P (val $Extern)) (: 2 (loop (loop (let X (cdr P) (? (...
; # (val $Extern)
  %395 = load i64, i64* @$Extern
; # (: 2 (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Z P (setq...
  br label %$-2
$-2:
  %396 = phi i64 [0, %$73], [%467, %$85] ; # Tos
  %397 = phi i64 [%395, %$73], [%474, %$85] ; # P
; # (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Z P (setq P @)...
  br label %$74
$74:
  %398 = phi i64 [%396, %$-2], [%602, %$94] ; # Tos
  %399 = phi i64 [%397, %$-2], [%603, %$94] ; # P
; # (loop (let X (cdr P) (? (atom (cdr X))) (let Z P (setq P @) (set ...
  br label %$75
$75:
  %400 = phi i64 [%398, %$74], [%411, %$76] ; # Tos
  %401 = phi i64 [%399, %$74], [%407, %$76] ; # P
; # (let X (cdr P) (? (atom (cdr X))) (let Z P (setq P @) (set 2 X To...
; # (cdr P)
  %402 = inttoptr i64 %401 to i64*
  %403 = getelementptr i64, i64* %402, i32 1
  %404 = load i64, i64* %403
; # (? (atom (cdr X)))
; # (cdr X)
  %405 = inttoptr i64 %404 to i64*
  %406 = getelementptr i64, i64* %405, i32 1
  %407 = load i64, i64* %406
; # (atom (cdr X))
  %408 = and i64 %407, 15
  %409 = icmp ne i64 %408, 0
  br i1 %409, label %$77, label %$76
$76:
  %410 = phi i64 [%400, %$75] ; # Tos
  %411 = phi i64 [%401, %$75] ; # P
; # (let Z P (setq P @) (set 2 X Tos) (setq Tos Z))
; # (set 2 X Tos)
  %412 = inttoptr i64 %404 to i64*
  %413 = getelementptr i64, i64* %412, i32 1
  store i64 %410, i64* %413
  br label %$75
$77:
  %414 = phi i64 [%400, %$75] ; # Tos
  %415 = phi i64 [%401, %$75] ; # P
  %416 = phi i64 [0, %$75] ; # ->
; # (loop (when (& (val (val P)) 1) (set $ExtCnt (- (val $ExtCnt) 1))...
  br label %$78
$78:
  %417 = phi i64 [%414, %$77], [%599, %$100] ; # Tos
  %418 = phi i64 [%415, %$77], [%600, %$100] ; # P
; # (when (& (val (val P)) 1) (set $ExtCnt (- (val $ExtCnt) 1)) (let ...
; # (val P)
  %419 = inttoptr i64 %418 to i64*
  %420 = load i64, i64* %419
; # (val (val P))
  %421 = inttoptr i64 %420 to i64*
  %422 = load i64, i64* %421
; # (& (val (val P)) 1)
  %423 = and i64 %422, 1
  %424 = icmp ne i64 %423, 0
  br i1 %424, label %$79, label %$80
$79:
  %425 = phi i64 [%417, %$78] ; # Tos
  %426 = phi i64 [%418, %$78] ; # P
; # (set $ExtCnt (- (val $ExtCnt) 1))
; # (val $ExtCnt)
  %427 = load i64, i64* @$ExtCnt
; # (- (val $ExtCnt) 1)
  %428 = sub i64 %427, 1
  store i64 %428, i64* @$ExtCnt
; # (let X (cdr P) (when (atom X) (set 2 P (| X 1)) (setq P X) (goto ...
; # (cdr P)
  %429 = inttoptr i64 %426 to i64*
  %430 = getelementptr i64, i64* %429, i32 1
  %431 = load i64, i64* %430
; # (when (atom X) (set 2 P (| X 1)) (setq P X) (goto 4))
; # (atom X)
  %432 = and i64 %431, 15
  %433 = icmp ne i64 %432, 0
  br i1 %433, label %$81, label %$82
$81:
  %434 = phi i64 [%425, %$79] ; # Tos
  %435 = phi i64 [%426, %$79] ; # P
  %436 = phi i64 [%431, %$79] ; # X
; # (set 2 P (| X 1))
; # (| X 1)
  %437 = or i64 %436, 1
  %438 = inttoptr i64 %435 to i64*
  %439 = getelementptr i64, i64* %438, i32 1
  store i64 %437, i64* %439
; # (goto 4)
  br label %$-4
$82:
  %440 = phi i64 [%425, %$79] ; # Tos
  %441 = phi i64 [%426, %$79] ; # P
  %442 = phi i64 [%431, %$79] ; # X
; # (when (atom (car X)) (set 2 P (| X 1)) (setq P (cdr X)) (set 2 X ...
; # (car X)
  %443 = inttoptr i64 %442 to i64*
  %444 = load i64, i64* %443
; # (atom (car X))
  %445 = and i64 %444, 15
  %446 = icmp ne i64 %445, 0
  br i1 %446, label %$83, label %$84
$83:
  %447 = phi i64 [%440, %$82] ; # Tos
  %448 = phi i64 [%441, %$82] ; # P
  %449 = phi i64 [%442, %$82] ; # X
; # (set 2 P (| X 1))
; # (| X 1)
  %450 = or i64 %449, 1
  %451 = inttoptr i64 %448 to i64*
  %452 = getelementptr i64, i64* %451, i32 1
  store i64 %450, i64* %452
; # (cdr X)
  %453 = inttoptr i64 %449 to i64*
  %454 = getelementptr i64, i64* %453, i32 1
  %455 = load i64, i64* %454
; # (set 2 X (| P 1))
; # (| P 1)
  %456 = or i64 %455, 1
  %457 = inttoptr i64 %449 to i64*
  %458 = getelementptr i64, i64* %457, i32 1
  store i64 %456, i64* %458
; # (goto 4)
  br label %$-4
$84:
  %459 = phi i64 [%440, %$82] ; # Tos
  %460 = phi i64 [%441, %$82] ; # P
  %461 = phi i64 [%442, %$82] ; # X
; # (when (atom (cdr X)) (set 2 P (| X 1)) (setq P (car X)) (set 2 X ...
; # (cdr X)
  %462 = inttoptr i64 %461 to i64*
  %463 = getelementptr i64, i64* %462, i32 1
  %464 = load i64, i64* %463
; # (atom (cdr X))
  %465 = and i64 %464, 15
  %466 = icmp ne i64 %465, 0
  br i1 %466, label %$85, label %$86
$85:
  %467 = phi i64 [%459, %$84] ; # Tos
  %468 = phi i64 [%460, %$84] ; # P
  %469 = phi i64 [%461, %$84] ; # X
; # (set 2 P (| X 1))
; # (| X 1)
  %470 = or i64 %469, 1
  %471 = inttoptr i64 %468 to i64*
  %472 = getelementptr i64, i64* %471, i32 1
  store i64 %470, i64* %472
; # (car X)
  %473 = inttoptr i64 %469 to i64*
  %474 = load i64, i64* %473
; # (set 2 X (| (cdr X) 1))
; # (cdr X)
  %475 = inttoptr i64 %469 to i64*
  %476 = getelementptr i64, i64* %475, i32 1
  %477 = load i64, i64* %476
; # (| (cdr X) 1)
  %478 = or i64 %477, 1
  %479 = inttoptr i64 %469 to i64*
  %480 = getelementptr i64, i64* %479, i32 1
  store i64 %478, i64* %480
; # (goto 2)
  br label %$-2
$86:
  %481 = phi i64 [%459, %$84] ; # Tos
  %482 = phi i64 [%460, %$84] ; # P
  %483 = phi i64 [%461, %$84] ; # X
; # (let Y (cdr (shift X)) (when (atom (car Y)) (set P (car X) 2 (cdr...
; # (shift X)
  %484 = inttoptr i64 %483 to i64*
  %485 = getelementptr i64, i64* %484, i32 1
  %486 = load i64, i64* %485
; # (cdr (shift X))
  %487 = inttoptr i64 %486 to i64*
  %488 = getelementptr i64, i64* %487, i32 1
  %489 = load i64, i64* %488
; # (when (atom (car Y)) (set P (car X) 2 (cdr P) (cdr Y)) (goto 3))
; # (car Y)
  %490 = inttoptr i64 %489 to i64*
  %491 = load i64, i64* %490
; # (atom (car Y))
  %492 = and i64 %491, 15
  %493 = icmp ne i64 %492, 0
  br i1 %493, label %$87, label %$88
$87:
  %494 = phi i64 [%481, %$86] ; # Tos
  %495 = phi i64 [%482, %$86] ; # P
  %496 = phi i64 [%486, %$86] ; # X
  %497 = phi i64 [%489, %$86] ; # Y
; # (set P (car X) 2 (cdr P) (cdr Y))
; # (car X)
  %498 = inttoptr i64 %496 to i64*
  %499 = load i64, i64* %498
  %500 = inttoptr i64 %495 to i64*
  store i64 %499, i64* %500
; # (cdr P)
  %501 = inttoptr i64 %495 to i64*
  %502 = getelementptr i64, i64* %501, i32 1
  %503 = load i64, i64* %502
; # (cdr Y)
  %504 = inttoptr i64 %497 to i64*
  %505 = getelementptr i64, i64* %504, i32 1
  %506 = load i64, i64* %505
  %507 = inttoptr i64 %503 to i64*
  %508 = getelementptr i64, i64* %507, i32 1
  store i64 %506, i64* %508
; # (goto 3)
  br label %$-3
$88:
  %509 = phi i64 [%481, %$86] ; # Tos
  %510 = phi i64 [%482, %$86] ; # P
  %511 = phi i64 [%486, %$86] ; # X
  %512 = phi i64 [%489, %$86] ; # Y
; # (car Y)
  %513 = inttoptr i64 %512 to i64*
  %514 = load i64, i64* %513
; # (loop (? (atom (cadr Y)) (set P (car Y) (cdr X) (cddr Y))) (setq ...
  br label %$89
$89:
  %515 = phi i64 [%509, %$88], [%543, %$90] ; # Tos
  %516 = phi i64 [%510, %$88], [%544, %$90] ; # P
  %517 = phi i64 [%511, %$88], [%546, %$90] ; # X
  %518 = phi i64 [%514, %$88], [%523, %$90] ; # Y
; # (? (atom (cadr Y)) (set P (car Y) (cdr X) (cddr Y)))
; # (cadr Y)
  %519 = inttoptr i64 %518 to i64*
  %520 = getelementptr i64, i64* %519, i32 1
  %521 = load i64, i64* %520
  %522 = inttoptr i64 %521 to i64*
  %523 = load i64, i64* %522
; # (atom (cadr Y))
  %524 = and i64 %523, 15
  %525 = icmp ne i64 %524, 0
  br i1 %525, label %$92, label %$90
$92:
  %526 = phi i64 [%515, %$89] ; # Tos
  %527 = phi i64 [%516, %$89] ; # P
  %528 = phi i64 [%517, %$89] ; # X
  %529 = phi i64 [%518, %$89] ; # Y
; # (set P (car Y) (cdr X) (cddr Y))
; # (car Y)
  %530 = inttoptr i64 %529 to i64*
  %531 = load i64, i64* %530
  %532 = inttoptr i64 %527 to i64*
  store i64 %531, i64* %532
; # (cdr X)
  %533 = inttoptr i64 %528 to i64*
  %534 = getelementptr i64, i64* %533, i32 1
  %535 = load i64, i64* %534
; # (cddr Y)
  %536 = inttoptr i64 %529 to i64*
  %537 = getelementptr i64, i64* %536, i32 1
  %538 = load i64, i64* %537
  %539 = inttoptr i64 %538 to i64*
  %540 = getelementptr i64, i64* %539, i32 1
  %541 = load i64, i64* %540
  %542 = inttoptr i64 %535 to i64*
  store i64 %541, i64* %542
  br label %$91
$90:
  %543 = phi i64 [%515, %$89] ; # Tos
  %544 = phi i64 [%516, %$89] ; # P
  %545 = phi i64 [%517, %$89] ; # X
  %546 = phi i64 [%518, %$89] ; # Y
  br label %$89
$91:
  %547 = phi i64 [%526, %$92] ; # Tos
  %548 = phi i64 [%527, %$92] ; # P
  %549 = phi i64 [%528, %$92] ; # X
  %550 = phi i64 [%529, %$92] ; # Y
  %551 = phi i64 [%541, %$92] ; # ->
  br label %$80
$80:
  %552 = phi i64 [%417, %$78], [%547, %$91] ; # Tos
  %553 = phi i64 [%418, %$78], [%548, %$91] ; # P
; # (: 3 (let X (cdr P) (? (pair (car X)) (let Z P (setq P @) (set X ...
  br label %$-3
$-3:
  %554 = phi i64 [%494, %$87], [%552, %$80] ; # Tos
  %555 = phi i64 [%495, %$87], [%553, %$80] ; # P
; # (let X (cdr P) (? (pair (car X)) (let Z P (setq P @) (set X Tos) ...
; # (cdr P)
  %556 = inttoptr i64 %555 to i64*
  %557 = getelementptr i64, i64* %556, i32 1
  %558 = load i64, i64* %557
; # (? (pair (car X)) (let Z P (setq P @) (set X Tos) (setq Tos (| Z ...
; # (car X)
  %559 = inttoptr i64 %558 to i64*
  %560 = load i64, i64* %559
; # (pair (car X))
  %561 = and i64 %560, 15
  %562 = icmp eq i64 %561, 0
  br i1 %562, label %$95, label %$93
$95:
  %563 = phi i64 [%554, %$-3] ; # Tos
  %564 = phi i64 [%555, %$-3] ; # P
; # (let Z P (setq P @) (set X Tos) (setq Tos (| Z 8)))
; # (set X Tos)
  %565 = inttoptr i64 %558 to i64*
  store i64 %563, i64* %565
; # (| Z 8)
  %566 = or i64 %564, 8
  br label %$94
$93:
  %567 = phi i64 [%554, %$-3] ; # Tos
  %568 = phi i64 [%555, %$-3] ; # P
; # (: 4 (loop (unless Tos (goto 5)) (? (=0 (& Tos 8)) (let (X Tos Y ...
  br label %$-4
$-4:
  %569 = phi i64 [%434, %$81], [%447, %$83], [%567, %$93] ; # Tos
  %570 = phi i64 [%436, %$81], [%455, %$83], [%568, %$93] ; # P
; # (loop (unless Tos (goto 5)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$96
$96:
  %571 = phi i64 [%569, %$-4], [%597, %$99] ; # Tos
  %572 = phi i64 [%570, %$-4], [%592, %$99] ; # P
; # (unless Tos (goto 5))
  %573 = icmp ne i64 %571, 0
  br i1 %573, label %$98, label %$97
$97:
  %574 = phi i64 [%571, %$96] ; # Tos
  %575 = phi i64 [%572, %$96] ; # P
; # (goto 5)
  br label %$-5
$98:
  %576 = phi i64 [%571, %$96] ; # Tos
  %577 = phi i64 [%572, %$96] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set ...
; # (& Tos 8)
  %578 = and i64 %576, 8
; # (=0 (& Tos 8))
  %579 = icmp eq i64 %578, 0
  br i1 %579, label %$101, label %$99
$101:
  %580 = phi i64 [%576, %$98] ; # Tos
  %581 = phi i64 [%577, %$98] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %582 = inttoptr i64 %580 to i64*
  %583 = getelementptr i64, i64* %582, i32 1
  %584 = load i64, i64* %583
; # (cdr Y)
  %585 = inttoptr i64 %584 to i64*
  %586 = getelementptr i64, i64* %585, i32 1
  %587 = load i64, i64* %586
; # (set 2 Y P)
  %588 = inttoptr i64 %584 to i64*
  %589 = getelementptr i64, i64* %588, i32 1
  store i64 %581, i64* %589
  br label %$100
$99:
  %590 = phi i64 [%576, %$98] ; # Tos
  %591 = phi i64 [%577, %$98] ; # P
; # (let (X (& Tos -9) Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq ...
; # (& Tos -9)
  %592 = and i64 %590, -9
; # (cdr X)
  %593 = inttoptr i64 %592 to i64*
  %594 = getelementptr i64, i64* %593, i32 1
  %595 = load i64, i64* %594
; # (car Y)
  %596 = inttoptr i64 %595 to i64*
  %597 = load i64, i64* %596
; # (set Y P)
  %598 = inttoptr i64 %595 to i64*
  store i64 %591, i64* %598
  br label %$96
$100:
  %599 = phi i64 [%587, %$101] ; # Tos
  %600 = phi i64 [%580, %$101] ; # P
  %601 = phi i64 [%580, %$101] ; # ->
  br label %$78
$94:
  %602 = phi i64 [%566, %$95] ; # Tos
  %603 = phi i64 [%560, %$95] ; # P
  %604 = phi i64 [%566, %$95] ; # ->
  br label %$74
$102:
; # (: 5 (set $Extern P))
  br label %$-5
$-5:
  %605 = phi i64 [%574, %$97], [%602, %$102] ; # Tos
  %606 = phi i64 [%575, %$97], [%603, %$102] ; # P
; # (set $Extern P)
  store i64 %606, i64* @$Extern
; # (let (Avail 0 Heap (val $Heaps) Cnt (val $GcCount)) (ifn Cnt (let...
; # (val $Heaps)
  %607 = load i64, i64* @$Heaps
; # (val $GcCount)
  %608 = load i64, i64* @$GcCount
; # (ifn Cnt (let H (any $Heaps) (loop (let (A Avail P (ofs Heap (- H...
  %609 = icmp ne i64 %608, 0
  br i1 %609, label %$104, label %$103
$103:
  %610 = phi i64 [0, %$-5] ; # Avail
  %611 = phi i64 [%607, %$-5] ; # Heap
  %612 = phi i64 [%608, %$-5] ; # Cnt
; # (let H (any $Heaps) (loop (let (A Avail P (ofs Heap (- HEAP 2))) ...
; # (any $Heaps)
  %613 = ptrtoint i64* @$Heaps to i64
; # (loop (let (A Avail P (ofs Heap (- HEAP 2))) (setq Cnt CELLS) (lo...
  br label %$106
$106:
  %614 = phi i64 [%610, %$103], [%682, %$115] ; # Avail
  %615 = phi i64 [%611, %$103], [%683, %$115] ; # Heap
  %616 = phi i64 [%612, %$103], [%684, %$115] ; # Cnt
  %617 = phi i64 [%613, %$103], [%685, %$115] ; # H
; # (let (A Avail P (ofs Heap (- HEAP 2))) (setq Cnt CELLS) (loop (wh...
; # (- HEAP 2)
; # (ofs Heap (- HEAP 2))
  %618 = add i64 %615, 1048560
; # (loop (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt)...
  br label %$107
$107:
  %619 = phi i64 [%614, %$106], [%642, %$110] ; # Avail
  %620 = phi i64 [%615, %$106], [%643, %$110] ; # Heap
  %621 = phi i64 [65536, %$106], [%644, %$110] ; # Cnt
  %622 = phi i64 [%617, %$106], [%645, %$110] ; # H
  %623 = phi i64 [%618, %$106], [%647, %$110] ; # P
; # (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt))
; # (cdr P)
  %624 = inttoptr i64 %623 to i64*
  %625 = getelementptr i64, i64* %624, i32 1
  %626 = load i64, i64* %625
; # (& (cdr P) 1)
  %627 = and i64 %626, 1
  %628 = icmp ne i64 %627, 0
  br i1 %628, label %$108, label %$109
$108:
  %629 = phi i64 [%619, %$107] ; # Avail
  %630 = phi i64 [%620, %$107] ; # Heap
  %631 = phi i64 [%621, %$107] ; # Cnt
  %632 = phi i64 [%622, %$107] ; # H
  %633 = phi i64 [%623, %$107] ; # P
; # (set P Avail)
  %634 = inttoptr i64 %633 to i64*
  store i64 %629, i64* %634
; # (dec 'Cnt)
  %635 = sub i64 %631, 1
  br label %$109
$109:
  %636 = phi i64 [%619, %$107], [%633, %$108] ; # Avail
  %637 = phi i64 [%620, %$107], [%630, %$108] ; # Heap
  %638 = phi i64 [%621, %$107], [%635, %$108] ; # Cnt
  %639 = phi i64 [%622, %$107], [%632, %$108] ; # H
  %640 = phi i64 [%623, %$107], [%633, %$108] ; # P
; # (? (== P Heap))
; # (== P Heap)
  %641 = icmp eq i64 %640, %637
  br i1 %641, label %$111, label %$110
$110:
  %642 = phi i64 [%636, %$109] ; # Avail
  %643 = phi i64 [%637, %$109] ; # Heap
  %644 = phi i64 [%638, %$109] ; # Cnt
  %645 = phi i64 [%639, %$109] ; # H
  %646 = phi i64 [%640, %$109] ; # P
; # (ofs P -2)
  %647 = add i64 %646, -16
  br label %$107
$111:
  %648 = phi i64 [%636, %$109] ; # Avail
  %649 = phi i64 [%637, %$109] ; # Heap
  %650 = phi i64 [%638, %$109] ; # Cnt
  %651 = phi i64 [%639, %$109] ; # H
  %652 = phi i64 [%640, %$109] ; # P
  %653 = phi i64 [0, %$109] ; # ->
; # (if Cnt (setq Heap (val (setq H (ofs Heap HEAP)))) (setq Avail A ...
  %654 = icmp ne i64 %650, 0
  br i1 %654, label %$112, label %$113
$112:
  %655 = phi i64 [%648, %$111] ; # Avail
  %656 = phi i64 [%649, %$111] ; # Heap
  %657 = phi i64 [%650, %$111] ; # Cnt
  %658 = phi i64 [%651, %$111] ; # H
  %659 = phi i64 [%652, %$111] ; # P
; # (ofs Heap HEAP)
  %660 = add i64 %656, 1048576
; # (val (setq H (ofs Heap HEAP)))
  %661 = inttoptr i64 %660 to i64*
  %662 = load i64, i64* %661
  br label %$114
$113:
  %663 = phi i64 [%648, %$111] ; # Avail
  %664 = phi i64 [%649, %$111] ; # Heap
  %665 = phi i64 [%650, %$111] ; # Cnt
  %666 = phi i64 [%651, %$111] ; # H
  %667 = phi i64 [%652, %$111] ; # P
; # (inc HEAP)
; # (val (inc HEAP) Heap)
  %668 = inttoptr i64 %664 to i64*
  %669 = getelementptr i64, i64* %668, i32 131072
  %670 = load i64, i64* %669
; # (val H)
  %671 = inttoptr i64 %666 to i64*
  %672 = load i64, i64* %671
; # (i8* (val H))
  %673 = inttoptr i64 %672 to i8*
; # (free (i8* (val H)))
  call void @free(i8* %673)
; # (set H Heap)
  %674 = inttoptr i64 %666 to i64*
  store i64 %670, i64* %674
  br label %$114
$114:
  %675 = phi i64 [%655, %$112], [%614, %$113] ; # Avail
  %676 = phi i64 [%662, %$112], [%670, %$113] ; # Heap
  %677 = phi i64 [%657, %$112], [%665, %$113] ; # Cnt
  %678 = phi i64 [%660, %$112], [%666, %$113] ; # H
  %679 = phi i64 [%659, %$112], [%667, %$113] ; # P
  %680 = phi i64 [%662, %$112], [%670, %$113] ; # ->
; # (? (=0 Heap))
; # (=0 Heap)
  %681 = icmp eq i64 %676, 0
  br i1 %681, label %$116, label %$115
$115:
  %682 = phi i64 [%675, %$114] ; # Avail
  %683 = phi i64 [%676, %$114] ; # Heap
  %684 = phi i64 [%677, %$114] ; # Cnt
  %685 = phi i64 [%678, %$114] ; # H
  br label %$106
$116:
  %686 = phi i64 [%675, %$114] ; # Avail
  %687 = phi i64 [%676, %$114] ; # Heap
  %688 = phi i64 [%677, %$114] ; # Cnt
  %689 = phi i64 [%678, %$114] ; # H
  %690 = phi i64 [0, %$114] ; # ->
; # (set $Avail Avail)
  store i64 %686, i64* @$Avail
  br label %$105
$104:
  %691 = phi i64 [0, %$-5] ; # Avail
  %692 = phi i64 [%607, %$-5] ; # Heap
  %693 = phi i64 [%608, %$-5] ; # Cnt
; # (loop (let P (ofs Heap (- HEAP 2)) (loop (when (& (cdr P) 1) (set...
  br label %$117
$117:
  %694 = phi i64 [%691, %$104], [%732, %$123] ; # Avail
  %695 = phi i64 [%692, %$104], [%733, %$123] ; # Heap
  %696 = phi i64 [%693, %$104], [%734, %$123] ; # Cnt
; # (let P (ofs Heap (- HEAP 2)) (loop (when (& (cdr P) 1) (set P Ava...
; # (- HEAP 2)
; # (ofs Heap (- HEAP 2))
  %697 = add i64 %695, 1048560
; # (loop (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt)...
  br label %$118
$118:
  %698 = phi i64 [%694, %$117], [%718, %$121] ; # Avail
  %699 = phi i64 [%695, %$117], [%719, %$121] ; # Heap
  %700 = phi i64 [%696, %$117], [%720, %$121] ; # Cnt
  %701 = phi i64 [%697, %$117], [%722, %$121] ; # P
; # (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt))
; # (cdr P)
  %702 = inttoptr i64 %701 to i64*
  %703 = getelementptr i64, i64* %702, i32 1
  %704 = load i64, i64* %703
; # (& (cdr P) 1)
  %705 = and i64 %704, 1
  %706 = icmp ne i64 %705, 0
  br i1 %706, label %$119, label %$120
$119:
  %707 = phi i64 [%698, %$118] ; # Avail
  %708 = phi i64 [%699, %$118] ; # Heap
  %709 = phi i64 [%700, %$118] ; # Cnt
  %710 = phi i64 [%701, %$118] ; # P
; # (set P Avail)
  %711 = inttoptr i64 %710 to i64*
  store i64 %707, i64* %711
; # (dec 'Cnt)
  %712 = sub i64 %709, 1
  br label %$120
$120:
  %713 = phi i64 [%698, %$118], [%710, %$119] ; # Avail
  %714 = phi i64 [%699, %$118], [%708, %$119] ; # Heap
  %715 = phi i64 [%700, %$118], [%712, %$119] ; # Cnt
  %716 = phi i64 [%701, %$118], [%710, %$119] ; # P
; # (? (== P Heap))
; # (== P Heap)
  %717 = icmp eq i64 %716, %714
  br i1 %717, label %$122, label %$121
$121:
  %718 = phi i64 [%713, %$120] ; # Avail
  %719 = phi i64 [%714, %$120] ; # Heap
  %720 = phi i64 [%715, %$120] ; # Cnt
  %721 = phi i64 [%716, %$120] ; # P
; # (ofs P -2)
  %722 = add i64 %721, -16
  br label %$118
$122:
  %723 = phi i64 [%713, %$120] ; # Avail
  %724 = phi i64 [%714, %$120] ; # Heap
  %725 = phi i64 [%715, %$120] ; # Cnt
  %726 = phi i64 [%716, %$120] ; # P
  %727 = phi i64 [0, %$120] ; # ->
; # (? (=0 (setq Heap (val (inc HEAP) Heap))))
; # (inc HEAP)
; # (val (inc HEAP) Heap)
  %728 = inttoptr i64 %724 to i64*
  %729 = getelementptr i64, i64* %728, i32 131072
  %730 = load i64, i64* %729
; # (=0 (setq Heap (val (inc HEAP) Heap)))
  %731 = icmp eq i64 %730, 0
  br i1 %731, label %$124, label %$123
$123:
  %732 = phi i64 [%723, %$122] ; # Avail
  %733 = phi i64 [%730, %$122] ; # Heap
  %734 = phi i64 [%725, %$122] ; # Cnt
  br label %$117
$124:
  %735 = phi i64 [%723, %$122] ; # Avail
  %736 = phi i64 [%730, %$122] ; # Heap
  %737 = phi i64 [%725, %$122] ; # Cnt
  %738 = phi i64 [0, %$122] ; # ->
; # (set $Avail Avail)
  store i64 %735, i64* @$Avail
; # (while (ge0 Cnt) (heapAlloc) (dec 'Cnt CELLS))
  br label %$125
$125:
  %739 = phi i64 [%735, %$124], [%743, %$126] ; # Avail
  %740 = phi i64 [%736, %$124], [%744, %$126] ; # Heap
  %741 = phi i64 [%737, %$124], [%746, %$126] ; # Cnt
; # (ge0 Cnt)
  %742 = icmp sge i64 %741, 0
  br i1 %742, label %$126, label %$127
$126:
  %743 = phi i64 [%739, %$125] ; # Avail
  %744 = phi i64 [%740, %$125] ; # Heap
  %745 = phi i64 [%741, %$125] ; # Cnt
; # (heapAlloc)
  call void @heapAlloc()
; # (dec 'Cnt CELLS)
  %746 = sub i64 %745, 65536
  br label %$125
$127:
  %747 = phi i64 [%739, %$125] ; # Avail
  %748 = phi i64 [%740, %$125] ; # Heap
  %749 = phi i64 [%741, %$125] ; # Cnt
  br label %$105
$105:
  %750 = phi i64 [%686, %$116], [%747, %$127] ; # Avail
  %751 = phi i64 [%687, %$116], [%748, %$127] ; # Heap
  %752 = phi i64 [%688, %$116], [%749, %$127] ; # Cnt
  ret void
}

define void @need3() align 8 {
$1:
; # (let P (val $Avail) (unless (and P (setq P (car P)) (car P)) (gc)...
; # (val $Avail)
  %0 = load i64, i64* @$Avail
; # (unless (and P (setq P (car P)) (car P)) (gc))
; # (and P (setq P (car P)) (car P))
  %1 = icmp ne i64 %0, 0
  br i1 %1, label %$3, label %$2
$3:
  %2 = phi i64 [%0, %$1] ; # P
; # (car P)
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$2
$4:
  %6 = phi i64 [%4, %$3] ; # P
; # (car P)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
  %9 = icmp ne i64 %8, 0
  br label %$2
$2:
  %10 = phi i64 [%0, %$1], [%4, %$3], [%6, %$4] ; # P
  %11 = phi i1 [0, %$1], [0, %$3], [%9, %$4] ; # ->
  br i1 %11, label %$6, label %$5
$5:
  %12 = phi i64 [%10, %$2] ; # P
; # (gc)
  call void @gc()
  br label %$6
$6:
  %13 = phi i64 [%10, %$2], [%12, %$5] ; # P
  ret void
}

define i64 @_gc(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (set $At $Nil $At2 $Nil) (if ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (set $At $Nil $At2 $Nil)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %15
; # (if (nil? Y) (gc) (set $GcCount (shl (xCnt Exe Y) 16)) (gc) (set ...
; # (nil? Y)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%3, %$2] ; # X
; # (gc)
  call void @gc()
  br label %$9
$8:
  %18 = phi i64 [%3, %$2] ; # X
; # (set $GcCount (shl (xCnt Exe Y) 16))
; # (xCnt Exe Y)
  %19 = call i64 @xCnt(i64 %0, i64 %13)
; # (shl (xCnt Exe Y) 16)
  %20 = shl i64 %19, 16
  store i64 %20, i64* @$GcCount
; # (gc)
  call void @gc()
; # (set $GcCount (if (atom (shift X)) CELLS (shl (evCnt Exe X) 16)))...
; # (if (atom (shift X)) CELLS (shl (evCnt Exe X) 16))
; # (shift X)
  %21 = inttoptr i64 %18 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (atom (shift X))
  %24 = and i64 %23, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$10, label %$11
$10:
  %26 = phi i64 [%23, %$8] ; # X
  br label %$12
$11:
  %27 = phi i64 [%23, %$8] ; # X
; # (evCnt Exe X)
  %28 = call i64 @evCnt(i64 %0, i64 %27)
; # (shl (evCnt Exe X) 16)
  %29 = shl i64 %28, 16
  br label %$12
$12:
  %30 = phi i64 [%26, %$10], [%27, %$11] ; # X
  %31 = phi i64 [65536, %$10], [%29, %$11] ; # ->
  store i64 %31, i64* @$GcCount
  br label %$9
$9:
  %32 = phi i64 [%17, %$7], [%30, %$12] ; # X
  ret i64 %13
}

define i64 @cons(i64, i64) align 8 {
$1:
; # (let P (val $Avail) (unless P (save2 Car Cdr (gc)) (setq P (val $...
; # (val $Avail)
  %2 = load i64, i64* @$Avail
; # (unless P (save2 Car Cdr (gc)) (setq P (val $Avail)))
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # P
; # (save2 Car Cdr (gc))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %0, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = alloca i64, i64 2, align 16
  %13 = ptrtoint i64* %12 to i64
  %14 = inttoptr i64 %13 to i64*
  store i64 %1, i64* %14
  %15 = add i64 %13, 8
  %16 = inttoptr i64 %15 to i64*
  store i64 %8, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %13, i64* %17
; # (gc)
  call void @gc()
; # drop
  %18 = inttoptr i64 %8 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %21
; # (val $Avail)
  %22 = load i64, i64* @$Avail
  br label %$3
$3:
  %23 = phi i64 [%2, %$1], [%22, %$2] ; # P
; # (set $Avail (car P))
; # (car P)
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  store i64 %25, i64* @$Avail
; # (set P Car)
  %26 = inttoptr i64 %23 to i64*
  store i64 %0, i64* %26
; # (set 2 P Cdr)
  %27 = inttoptr i64 %23 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %1, i64* %28
  ret i64 %23
}

define i64 @cons2(i64, i64, i64) align 8 {
$1:
; # (let P (val $Avail) (when P (let Q (val P) (when Q (set $Avail (c...
; # (val $Avail)
  %3 = load i64, i64* @$Avail
; # (when P (let Q (val P) (when Q (set $Avail (car Q)) (set P Car1) ...
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
; # (let Q (val P) (when Q (set $Avail (car Q)) (set P Car1) (set 2 P...
; # (val P)
  %5 = inttoptr i64 %3 to i64*
  %6 = load i64, i64* %5
; # (when Q (set $Avail (car Q)) (set P Car1) (set 2 P Cdr1) (set Q P...
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$5
$4:
; # (set $Avail (car Q))
; # (car Q)
  %8 = inttoptr i64 %6 to i64*
  %9 = load i64, i64* %8
  store i64 %9, i64* @$Avail
; # (set P Car1)
  %10 = inttoptr i64 %3 to i64*
  store i64 %0, i64* %10
; # (set 2 P Cdr1)
  %11 = inttoptr i64 %3 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  store i64 %1, i64* %12
; # (set Q P)
  %13 = inttoptr i64 %6 to i64*
  store i64 %3, i64* %13
; # (set 2 Q Cdr2)
  %14 = inttoptr i64 %6 to i64*
  %15 = getelementptr i64, i64* %14, i32 1
  store i64 %2, i64* %15
; # (ret Q)
  ret i64 %6
$5:
  br label %$3
$3:
; # (save2 Car1 Cdr1 (save Cdr2 (gc)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %0, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %1, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %19, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (save Cdr2 (gc))
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %30 = load i64, i64* %29
  %31 = alloca i64, i64 2, align 16
  %32 = ptrtoint i64* %31 to i64
  %33 = inttoptr i64 %32 to i64*
  store i64 %2, i64* %33
  %34 = add i64 %32, 8
  %35 = inttoptr i64 %34 to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %36
; # (gc)
  call void @gc()
; # drop
  %37 = inttoptr i64 %32 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %40
; # drop
  %41 = inttoptr i64 %19 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %44
; # (let (P (val $Avail) Q (val P)) (set $Avail (car Q)) (set P Car1)...
; # (val $Avail)
  %45 = load i64, i64* @$Avail
; # (val P)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (set $Avail (car Q))
; # (car Q)
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
  store i64 %49, i64* @$Avail
; # (set P Car1)
  %50 = inttoptr i64 %45 to i64*
  store i64 %0, i64* %50
; # (set 2 P Cdr1)
  %51 = inttoptr i64 %45 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %1, i64* %52
; # (set Q P)
  %53 = inttoptr i64 %47 to i64*
  store i64 %45, i64* %53
; # (set 2 Q Cdr2)
  %54 = inttoptr i64 %47 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %2, i64* %55
  ret i64 %47
}

define i64 @cons3(i64, i64, i64, i64) align 8 {
$1:
; # (let P (val $Avail) (when P (let Q (val P) (when Q (let R (val Q)...
; # (val $Avail)
  %4 = load i64, i64* @$Avail
; # (when P (let Q (val P) (when Q (let R (val Q) (when R (set $Avail...
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
; # (let Q (val P) (when Q (let R (val Q) (when R (set $Avail (car R)...
; # (val P)
  %6 = inttoptr i64 %4 to i64*
  %7 = load i64, i64* %6
; # (when Q (let R (val Q) (when R (set $Avail (car R)) (set P Car1) ...
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$4, label %$5
$4:
; # (let R (val Q) (when R (set $Avail (car R)) (set P Car1) (set 2 P...
; # (val Q)
  %9 = inttoptr i64 %7 to i64*
  %10 = load i64, i64* %9
; # (when R (set $Avail (car R)) (set P Car1) (set 2 P Cdr1) (set Q C...
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$7
$6:
; # (set $Avail (car R))
; # (car R)
  %12 = inttoptr i64 %10 to i64*
  %13 = load i64, i64* %12
  store i64 %13, i64* @$Avail
; # (set P Car1)
  %14 = inttoptr i64 %4 to i64*
  store i64 %0, i64* %14
; # (set 2 P Cdr1)
  %15 = inttoptr i64 %4 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  store i64 %1, i64* %16
; # (set Q Car2)
  %17 = inttoptr i64 %7 to i64*
  store i64 %2, i64* %17
; # (set 2 Q Cdr2)
  %18 = inttoptr i64 %7 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  store i64 %3, i64* %19
; # (set R P)
  %20 = inttoptr i64 %10 to i64*
  store i64 %4, i64* %20
; # (set 2 R Q)
  %21 = inttoptr i64 %10 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %7, i64* %22
; # (ret R)
  ret i64 %10
$7:
  br label %$5
$5:
  br label %$3
$3:
; # (save2 Car1 Cdr1 (save2 Car2 Cdr2 (gc)))
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %24 = load i64, i64* %23
  %25 = alloca i64, i64 2, align 16
  %26 = ptrtoint i64* %25 to i64
  %27 = inttoptr i64 %26 to i64*
  store i64 %0, i64* %27
  %28 = add i64 %26, 8
  %29 = inttoptr i64 %28 to i64*
  store i64 %24, i64* %29
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %1, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %26, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
; # (save2 Car2 Cdr2 (gc))
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %37 = load i64, i64* %36
  %38 = alloca i64, i64 2, align 16
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 %39 to i64*
  store i64 %2, i64* %40
  %41 = add i64 %39, 8
  %42 = inttoptr i64 %41 to i64*
  store i64 %37, i64* %42
  %43 = alloca i64, i64 2, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %3, i64* %45
  %46 = add i64 %44, 8
  %47 = inttoptr i64 %46 to i64*
  store i64 %39, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %48
; # (gc)
  call void @gc()
; # drop
  %49 = inttoptr i64 %39 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %52
; # drop
  %53 = inttoptr i64 %26 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
; # (let (P (val $Avail) Q (val P) R (val Q)) (set $Avail (car R)) (s...
; # (val $Avail)
  %57 = load i64, i64* @$Avail
; # (val P)
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (val Q)
  %60 = inttoptr i64 %59 to i64*
  %61 = load i64, i64* %60
; # (set $Avail (car R))
; # (car R)
  %62 = inttoptr i64 %61 to i64*
  %63 = load i64, i64* %62
  store i64 %63, i64* @$Avail
; # (set P Car1)
  %64 = inttoptr i64 %57 to i64*
  store i64 %0, i64* %64
; # (set 2 P Cdr1)
  %65 = inttoptr i64 %57 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  store i64 %1, i64* %66
; # (set Q Car2)
  %67 = inttoptr i64 %59 to i64*
  store i64 %2, i64* %67
; # (set 2 Q Cdr2)
  %68 = inttoptr i64 %59 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %3, i64* %69
; # (set R P)
  %70 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %70
; # (set 2 R Q)
  %71 = inttoptr i64 %61 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  store i64 %59, i64* %72
  ret i64 %61
}

define i64 @consSym(i64, i64) align 8 {
$1:
; # (let P (val $Avail) (unless P (if Val (save2 Name Val (gc)) (save...
; # (val $Avail)
  %2 = load i64, i64* @$Avail
; # (unless P (if Val (save2 Name Val (gc)) (save Name (gc))) (setq P...
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # P
; # (if Val (save2 Name Val (gc)) (save Name (gc)))
  %5 = icmp ne i64 %1, 0
  br i1 %5, label %$4, label %$5
$4:
  %6 = phi i64 [%4, %$2] ; # P
; # (save2 Name Val (gc))
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = alloca i64, i64 2, align 16
  %10 = ptrtoint i64* %9 to i64
  %11 = inttoptr i64 %10 to i64*
  store i64 %0, i64* %11
  %12 = add i64 %10, 8
  %13 = inttoptr i64 %12 to i64*
  store i64 %8, i64* %13
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %1, i64* %16
  %17 = add i64 %15, 8
  %18 = inttoptr i64 %17 to i64*
  store i64 %10, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %19
; # (gc)
  call void @gc()
; # drop
  %20 = inttoptr i64 %10 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %23
  br label %$6
$5:
  %24 = phi i64 [%4, %$2] ; # P
; # (save Name (gc))
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = alloca i64, i64 2, align 16
  %28 = ptrtoint i64* %27 to i64
  %29 = inttoptr i64 %28 to i64*
  store i64 %0, i64* %29
  %30 = add i64 %28, 8
  %31 = inttoptr i64 %30 to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %32
; # (gc)
  call void @gc()
; # drop
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %35, i64* %36
  br label %$6
$6:
  %37 = phi i64 [%6, %$4], [%24, %$5] ; # P
; # (val $Avail)
  %38 = load i64, i64* @$Avail
  br label %$3
$3:
  %39 = phi i64 [%2, %$1], [%38, %$6] ; # P
; # (set $Avail (car P))
; # (car P)
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
  store i64 %41, i64* @$Avail
; # (set P Name)
  %42 = inttoptr i64 %39 to i64*
  store i64 %0, i64* %42
; # (let S (sym P) (set S (if Val @ S)) S)
; # (sym P)
  %43 = or i64 %39, 8
; # (set S (if Val @ S))
; # (if Val @ S)
  %44 = icmp ne i64 %1, 0
  br i1 %44, label %$7, label %$8
$7:
  %45 = phi i64 [%39, %$3] ; # P
  br label %$9
$8:
  %46 = phi i64 [%39, %$3] ; # P
  br label %$9
$9:
  %47 = phi i64 [%45, %$7], [%46, %$8] ; # P
  %48 = phi i64 [%1, %$7], [%43, %$8] ; # ->
  %49 = inttoptr i64 %43 to i64*
  store i64 %48, i64* %49
  ret i64 %43
}

define i64 @consStr(i64) align 8 {
$1:
; # (if (== Name ZERO) $Nil (tailcall (consSym Name 0)))
; # (== Name ZERO)
  %1 = icmp eq i64 %0, 2
  br i1 %1, label %$2, label %$3
$2:
  br label %$4
$3:
; # (consSym Name 0)
  %2 = tail call i64 @consSym(i64 %0, i64 0)
  br label %$4
$4:
  %3 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%2, %$3] ; # ->
  ret i64 %3
}

define i64 @consExt(i64) align 8 {
$1:
; # (set $ExtCnt (+ (val $ExtCnt) 1))
; # (val $ExtCnt)
  %1 = load i64, i64* @$ExtCnt
; # (+ (val $ExtCnt) 1)
  %2 = add i64 %1, 1
  store i64 %2, i64* @$ExtCnt
; # (sign Name)
  %3 = or i64 %0, 8
; # (consSym (sign Name) $Nil)
  %4 = tail call i64 @consSym(i64 %3, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  ret i64 %4
}

define i64 @boxNum(i64) align 8 {
$1:
; # (let P (val $Avail) (unless P (gc) (setq P (val $Avail))) (set $A...
; # (val $Avail)
  %1 = load i64, i64* @$Avail
; # (unless P (gc) (setq P (val $Avail)))
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i64 [%1, %$1] ; # P
; # (gc)
  call void @gc()
; # (val $Avail)
  %4 = load i64, i64* @$Avail
  br label %$3
$3:
  %5 = phi i64 [%1, %$1], [%4, %$2] ; # P
; # (set $Avail (car P))
; # (car P)
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
  store i64 %7, i64* @$Avail
; # (set P Dig)
  %8 = inttoptr i64 %5 to i64*
  store i64 %0, i64* %8
; # (set 2 P ZERO)
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 2, i64* %10
; # (big P)
  %11 = add i64 %5, 4
  ret i64 %11
}

define i64 @consNum(i64, i64) align 8 {
$1:
; # (let P (val $Avail) (unless P (save Big (gc)) (setq P (val $Avail...
; # (val $Avail)
  %2 = load i64, i64* @$Avail
; # (unless P (save Big (gc)) (setq P (val $Avail)))
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # P
; # (save Big (gc))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %1, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (gc)
  call void @gc()
; # drop
  %13 = inttoptr i64 %8 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %16
; # (val $Avail)
  %17 = load i64, i64* @$Avail
  br label %$3
$3:
  %18 = phi i64 [%2, %$1], [%17, %$2] ; # P
; # (set $Avail (car P))
; # (car P)
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  store i64 %20, i64* @$Avail
; # (set P Dig)
  %21 = inttoptr i64 %18 to i64*
  store i64 %0, i64* %21
; # (set 2 P Big)
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %1, i64* %23
; # (big P)
  %24 = add i64 %18, 4
  ret i64 %24
}

define i64 @box(i64) align 8 {
$1:
; # (if (ge0 N) (box64 N) (sign (box64 (- N))))
; # (ge0 N)
  %1 = icmp sge i64 %0, 0
  br i1 %1, label %$2, label %$3
$2:
; # (box64 N)
  %2 = and i64 %0, 17293822569102704640
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$5, label %$6
$5:
  %4 = call i64 @boxNum(i64 %0)
  br label %$7
$6:
  %5 = shl i64 %0, 4
  %6 = or i64 %5, 2
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%6, %$6] ; # ->
  br label %$4
$3:
; # (- N)
  %8 = sub i64 0, %0
; # (box64 (- N))
  %9 = and i64 %8, 17293822569102704640
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$8, label %$9
$8:
  %11 = call i64 @boxNum(i64 %8)
  br label %$10
$9:
  %12 = shl i64 %8, 4
  %13 = or i64 %12, 2
  br label %$10
$10:
  %14 = phi i64 [%11, %$8], [%13, %$9] ; # ->
; # (sign (box64 (- N)))
  %15 = or i64 %14, 8
  br label %$4
$4:
  %16 = phi i64 [%7, %$7], [%15, %$10] ; # ->
  ret i64 %16
}

define void @divErr(i64) align 8 {
$1:
; # (err Exe 0 ($ "Div/0") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([6 x i8]* @$26 to i8*), i8* null)
  unreachable
}

define i8 @symByte(i64*) align 8 {
$1:
; # (let C (val P) (unless C (let Nm (val 2 P) (cond ((== Nm ZERO) (r...
; # (val P)
  %1 = load i64, i64* %0
; # (unless C (let Nm (val 2 P) (cond ((== Nm ZERO) (ret (i8 0))) ((c...
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i64 [%1, %$1] ; # C
; # (let Nm (val 2 P) (cond ((== Nm ZERO) (ret (i8 0))) ((cnt? Nm) (s...
; # (val 2 P)
  %4 = getelementptr i64, i64* %0, i32 1
  %5 = load i64, i64* %4
; # (cond ((== Nm ZERO) (ret (i8 0))) ((cnt? Nm) (setq C (int Nm)) (s...
; # (== Nm ZERO)
  %6 = icmp eq i64 %5, 2
  br i1 %6, label %$6, label %$5
$6:
  %7 = phi i64 [%3, %$2] ; # C
; # (i8 0)
; # (ret (i8 0))
  ret i8 0
$5:
  %8 = phi i64 [%3, %$2] ; # C
; # (cnt? Nm)
  %9 = and i64 %5, 2
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$8, label %$7
$8:
  %11 = phi i64 [%8, %$5] ; # C
; # (int Nm)
  %12 = lshr i64 %5, 4
; # (set 2 P ZERO)
  %13 = getelementptr i64, i64* %0, i32 1
  store i64 2, i64* %13
  br label %$4
$7:
  %14 = phi i64 [%8, %$5] ; # C
; # (set P (val (dig Nm)))
; # (dig Nm)
  %15 = add i64 %5, -4
; # (val (dig Nm))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
  store i64 %17, i64* %0
; # (set 2 P (val (big Nm)))
; # (big Nm)
  %18 = add i64 %5, 4
; # (val (big Nm))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = getelementptr i64, i64* %0, i32 1
  store i64 %20, i64* %21
  br label %$4
$4:
  %22 = phi i64 [%12, %$8], [%17, %$7] ; # C
  %23 = phi i64 [2, %$8], [%20, %$7] ; # ->
  br label %$3
$3:
  %24 = phi i64 [%1, %$1], [%22, %$4] ; # C
; # (set P (shr C 8))
; # (shr C 8)
  %25 = lshr i64 %24, 8
  store i64 %25, i64* %0
; # (i8 C)
  %26 = trunc i64 %24 to i8
  ret i8 %26
}

define i32 @symChar(i64*) align 8 {
$1:
; # (let C (i32 (symByte P)) (cond ((>= 127 C) C) ((== C (hex "FF")) ...
; # (symByte P)
  %1 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %2 = zext i8 %1 to i32
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (| (shl (if...
; # (>= 127 C)
  %3 = icmp sge i32 127, %2
  br i1 %3, label %$4, label %$3
$4:
  br label %$2
$3:
; # (== C (hex "FF"))
  %4 = icmp eq i32 %2, 255
  br i1 %4, label %$6, label %$5
$6:
; # (i32 TOP)
  br label %$2
$5:
; # (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (hex "10...
; # (& C (hex "20"))
  %5 = and i32 %2, 32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %$8, label %$7
$7:
; # (& C (hex "1F"))
  %7 = and i32 %2, 31
  br label %$9
$8:
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7")) 6)...
; # (& C (hex "10"))
  %8 = and i32 %2, 16
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %$11, label %$10
$10:
; # (& C (hex "0F"))
  %10 = and i32 %2, 15
  br label %$12
$11:
; # (& C (hex "7"))
  %11 = and i32 %2, 7
; # (shl (& C (hex "7")) 6)
  %12 = shl i32 %11, 6
; # (symByte P)
  %13 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %14 = zext i8 %13 to i32
; # (& (i32 (symByte P)) (hex "3F"))
  %15 = and i32 %14, 63
; # (| (shl (& C (hex "7")) 6) (& (i32 (symByte P)) (hex "3F")))
  %16 = or i32 %12, %15
  br label %$12
$12:
  %17 = phi i32 [%10, %$10], [%16, %$11] ; # ->
; # (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7"...
  %18 = shl i32 %17, 6
; # (symByte P)
  %19 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %20 = zext i8 %19 to i32
; # (& (i32 (symByte P)) (hex "3F"))
  %21 = and i32 %20, 63
; # (| (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex ...
  %22 = or i32 %18, %21
  br label %$9
$9:
  %23 = phi i32 [%7, %$7], [%22, %$12] ; # ->
; # (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (he...
  %24 = shl i32 %23, 6
; # (symByte P)
  %25 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %26 = zext i8 %25 to i32
; # (& (i32 (symByte P)) (hex "3F"))
  %27 = and i32 %26, 63
; # (| (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C ...
  %28 = or i32 %24, %27
  br label %$2
$2:
  %29 = phi i32 [%2, %$4], [1114112, %$6], [%28, %$9] ; # ->
  ret i32 %29
}

define void @byteNum(i8, i64*) align 8 {
$1:
; # (let (Cnt (val P) Nm (val 3 P)) (if (cnt? Nm) (cond ((== Cnt 67) ...
; # (val P)
  %2 = load i64, i64* %1
; # (val 3 P)
  %3 = getelementptr i64, i64* %1, i32 2
  %4 = load i64, i64* %3
; # (if (cnt? Nm) (cond ((== Cnt 67) (set 3 P (set 2 P (consNum (shr ...
; # (cnt? Nm)
  %5 = and i64 %4, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$2, label %$3
$2:
; # (cond ((== Cnt 67) (set 3 P (set 2 P (consNum (shr Nm 3) (cnt (i6...
; # (== Cnt 67)
  %7 = icmp eq i64 %2, 67
  br i1 %7, label %$7, label %$6
$7:
; # (set 3 P (set 2 P (consNum (shr Nm 3) (cnt (i64 B)))))
; # (set 2 P (consNum (shr Nm 3) (cnt (i64 B))))
; # (shr Nm 3)
  %8 = lshr i64 %4, 3
; # (i64 B)
  %9 = zext i8 %0 to i64
; # (cnt (i64 B))
  %10 = shl i64 %9, 4
  %11 = or i64 %10, 2
; # (consNum (shr Nm 3) (cnt (i64 B)))
  %12 = call i64 @consNum(i64 %8, i64 %11)
  %13 = getelementptr i64, i64* %1, i32 1
  store i64 %12, i64* %13
  %14 = getelementptr i64, i64* %1, i32 2
  store i64 %12, i64* %14
; # (set P 12)
  store i64 12, i64* %1
  br label %$5
$6:
; # (and (== Cnt 59) (>= B 32))
; # (== Cnt 59)
  %15 = icmp eq i64 %2, 59
  br i1 %15, label %$9, label %$8
$9:
; # (>= B 32)
  %16 = icmp uge i8 %0, 32
  br label %$8
$8:
  %17 = phi i1 [0, %$6], [%16, %$9] ; # ->
  br i1 %17, label %$11, label %$10
$11:
; # (set 3 P (set 2 P (boxNum (| (shr Nm 3) (shl (i64 B) 56)))))
; # (set 2 P (boxNum (| (shr Nm 3) (shl (i64 B) 56))))
; # (shr Nm 3)
  %18 = lshr i64 %4, 3
; # (i64 B)
  %19 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %20 = shl i64 %19, 56
; # (| (shr Nm 3) (shl (i64 B) 56))
  %21 = or i64 %18, %20
; # (boxNum (| (shr Nm 3) (shl (i64 B) 56)))
  %22 = call i64 @boxNum(i64 %21)
  %23 = getelementptr i64, i64* %1, i32 1
  store i64 %22, i64* %23
  %24 = getelementptr i64, i64* %1, i32 2
  store i64 %22, i64* %24
; # (set P 4)
  store i64 4, i64* %1
  br label %$5
$10:
; # (set 3 P (| Nm (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (i64 B)
  %25 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %26 = shl i64 %25, %2
; # (| Nm (shl (i64 B) Cnt))
  %27 = or i64 %4, %26
  %28 = getelementptr i64, i64* %1, i32 2
  store i64 %27, i64* %28
; # (+ Cnt 8)
  %29 = add i64 %2, 8
  store i64 %29, i64* %1
  br label %$5
$5:
  %30 = phi i64 [12, %$7], [4, %$11], [%29, %$10] ; # ->
  br label %$4
$3:
; # (let (Q (val 2 P) N (val (big Q))) (cond ((== Cnt 68) (set 2 P (s...
; # (val 2 P)
  %31 = getelementptr i64, i64* %1, i32 1
  %32 = load i64, i64* %31
; # (big Q)
  %33 = add i64 %32, 4
; # (val (big Q))
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (cond ((== Cnt 68) (set 2 P (set (big Q) (consNum (int N) (cnt (i...
; # (== Cnt 68)
  %36 = icmp eq i64 %2, 68
  br i1 %36, label %$14, label %$13
$14:
; # (set 2 P (set (big Q) (consNum (int N) (cnt (i64 B)))))
; # (set (big Q) (consNum (int N) (cnt (i64 B))))
; # (big Q)
  %37 = add i64 %32, 4
; # (int N)
  %38 = lshr i64 %35, 4
; # (i64 B)
  %39 = zext i8 %0 to i64
; # (cnt (i64 B))
  %40 = shl i64 %39, 4
  %41 = or i64 %40, 2
; # (consNum (int N) (cnt (i64 B)))
  %42 = call i64 @consNum(i64 %38, i64 %41)
  %43 = inttoptr i64 %37 to i64*
  store i64 %42, i64* %43
  %44 = getelementptr i64, i64* %1, i32 1
  store i64 %42, i64* %44
; # (set P 12)
  store i64 12, i64* %1
  br label %$12
$13:
; # (and (== Cnt 60) (>= B 16))
; # (== Cnt 60)
  %45 = icmp eq i64 %2, 60
  br i1 %45, label %$16, label %$15
$16:
; # (>= B 16)
  %46 = icmp uge i8 %0, 16
  br label %$15
$15:
  %47 = phi i1 [0, %$13], [%46, %$16] ; # ->
  br i1 %47, label %$18, label %$17
$18:
; # (set 2 P (set (big Q) (boxNum (| (int N) (shl (i64 B) 56)))))
; # (set (big Q) (boxNum (| (int N) (shl (i64 B) 56))))
; # (big Q)
  %48 = add i64 %32, 4
; # (int N)
  %49 = lshr i64 %35, 4
; # (i64 B)
  %50 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %51 = shl i64 %50, 56
; # (| (int N) (shl (i64 B) 56))
  %52 = or i64 %49, %51
; # (boxNum (| (int N) (shl (i64 B) 56)))
  %53 = call i64 @boxNum(i64 %52)
  %54 = inttoptr i64 %48 to i64*
  store i64 %53, i64* %54
  %55 = getelementptr i64, i64* %1, i32 1
  store i64 %53, i64* %55
; # (set P 4)
  store i64 4, i64* %1
  br label %$12
$17:
; # (set (big Q) (| N (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (big Q)
  %56 = add i64 %32, 4
; # (i64 B)
  %57 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %58 = shl i64 %57, %2
; # (| N (shl (i64 B) Cnt))
  %59 = or i64 %35, %58
  %60 = inttoptr i64 %56 to i64*
  store i64 %59, i64* %60
; # (+ Cnt 8)
  %61 = add i64 %2, 8
  store i64 %61, i64* %1
  br label %$12
$12:
  %62 = phi i64 [12, %$14], [4, %$18], [%61, %$17] ; # ->
  br label %$4
$4:
  %63 = phi i64 [%30, %$5], [%62, %$12] ; # ->
  ret void
}

define void @byteSym(i8, i64*) align 8 {
$1:
; # (let (Cnt (val P) Nm (val 3 P)) (if (cnt? Nm) (if (> 60 Cnt) (set...
; # (val P)
  %2 = load i64, i64* %1
; # (val 3 P)
  %3 = getelementptr i64, i64* %1, i32 2
  %4 = load i64, i64* %3
; # (if (cnt? Nm) (if (> 60 Cnt) (set 3 P (| Nm (shl (i64 B) Cnt)) P ...
; # (cnt? Nm)
  %5 = and i64 %4, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$2, label %$3
$2:
; # (if (> 60 Cnt) (set 3 P (| Nm (shl (i64 B) Cnt)) P (+ Cnt 8)) (se...
; # (> 60 Cnt)
  %7 = icmp ugt i64 60, %2
  br i1 %7, label %$5, label %$6
$5:
; # (set 3 P (| Nm (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (i64 B)
  %8 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %9 = shl i64 %8, %2
; # (| Nm (shl (i64 B) Cnt))
  %10 = or i64 %4, %9
  %11 = getelementptr i64, i64* %1, i32 2
  store i64 %10, i64* %11
; # (+ Cnt 8)
  %12 = add i64 %2, 8
  store i64 %12, i64* %1
  br label %$7
$6:
; # (set 3 P (set 2 P (boxNum (| (int Nm) (shl (i64 B) 56)))))
; # (set 2 P (boxNum (| (int Nm) (shl (i64 B) 56))))
; # (int Nm)
  %13 = lshr i64 %4, 4
; # (i64 B)
  %14 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %15 = shl i64 %14, 56
; # (| (int Nm) (shl (i64 B) 56))
  %16 = or i64 %13, %15
; # (boxNum (| (int Nm) (shl (i64 B) 56)))
  %17 = call i64 @boxNum(i64 %16)
  %18 = getelementptr i64, i64* %1, i32 1
  store i64 %17, i64* %18
  %19 = getelementptr i64, i64* %1, i32 2
  store i64 %17, i64* %19
; # (set P 4)
  store i64 4, i64* %1
  br label %$7
$7:
  %20 = phi i64 [%12, %$5], [4, %$6] ; # ->
  br label %$4
$3:
; # (let (Q (val 2 P) N (val (big Q))) (if (> 60 Cnt) (set (big Q) (|...
; # (val 2 P)
  %21 = getelementptr i64, i64* %1, i32 1
  %22 = load i64, i64* %21
; # (big Q)
  %23 = add i64 %22, 4
; # (val (big Q))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
; # (if (> 60 Cnt) (set (big Q) (| N (shl (i64 B) Cnt)) P (+ Cnt 8)) ...
; # (> 60 Cnt)
  %26 = icmp ugt i64 60, %2
  br i1 %26, label %$8, label %$9
$8:
; # (set (big Q) (| N (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (big Q)
  %27 = add i64 %22, 4
; # (i64 B)
  %28 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %29 = shl i64 %28, %2
; # (| N (shl (i64 B) Cnt))
  %30 = or i64 %25, %29
  %31 = inttoptr i64 %27 to i64*
  store i64 %30, i64* %31
; # (+ Cnt 8)
  %32 = add i64 %2, 8
  store i64 %32, i64* %1
  br label %$10
$9:
; # (set 2 P (set (big Q) (boxNum (| (int N) (shl (i64 B) 56)))))
; # (set (big Q) (boxNum (| (int N) (shl (i64 B) 56))))
; # (big Q)
  %33 = add i64 %22, 4
; # (int N)
  %34 = lshr i64 %25, 4
; # (i64 B)
  %35 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %36 = shl i64 %35, 56
; # (| (int N) (shl (i64 B) 56))
  %37 = or i64 %34, %36
; # (boxNum (| (int N) (shl (i64 B) 56)))
  %38 = call i64 @boxNum(i64 %37)
  %39 = inttoptr i64 %33 to i64*
  store i64 %38, i64* %39
  %40 = getelementptr i64, i64* %1, i32 1
  store i64 %38, i64* %40
; # (set P 4)
  store i64 4, i64* %1
  br label %$10
$10:
  %41 = phi i64 [%32, %$8], [4, %$9] ; # ->
  br label %$4
$4:
  %42 = phi i64 [%20, %$7], [%41, %$10] ; # ->
  ret void
}

define void @charSym(i32, i64*) align 8 {
$1:
; # (cond ((>= 127 C) (byteSym (i8 C) P)) ((== TOP C) (byteSym (hex "...
; # (>= 127 C)
  %2 = icmp sge i32 127, %0
  br i1 %2, label %$4, label %$3
$4:
; # (i8 C)
  %3 = trunc i32 %0 to i8
; # (byteSym (i8 C) P)
  call void @byteSym(i8 %3, i64* %1)
  br label %$2
$3:
; # (== TOP C)
  %4 = icmp eq i32 1114112, %0
  br i1 %4, label %$6, label %$5
$6:
; # (byteSym (hex "FF") P)
  call void @byteSym(i8 255, i64* %1)
  br label %$2
$5:
; # (cond ((> (hex "800") C) (byteSym (i8 (| (hex "C0") (& (shr C 6) ...
; # (> (hex "800") C)
  %5 = icmp sgt i32 2048, %0
  br i1 %5, label %$9, label %$8
$9:
; # (shr C 6)
  %6 = lshr i32 %0, 6
; # (& (shr C 6) (hex "1F"))
  %7 = and i32 %6, 31
; # (| (hex "C0") (& (shr C 6) (hex "1F")))
  %8 = or i32 192, %7
; # (i8 (| (hex "C0") (& (shr C 6) (hex "1F"))))
  %9 = trunc i32 %8 to i8
; # (byteSym (i8 (| (hex "C0") (& (shr C 6) (hex "1F")))) P)
  call void @byteSym(i8 %9, i64* %1)
  br label %$7
$8:
; # (> (hex "10000") C)
  %10 = icmp sgt i32 65536, %0
  br i1 %10, label %$11, label %$10
$11:
; # (shr C 12)
  %11 = lshr i32 %0, 12
; # (& (shr C 12) (hex "0F"))
  %12 = and i32 %11, 15
; # (| (hex "E0") (& (shr C 12) (hex "0F")))
  %13 = or i32 224, %12
; # (i8 (| (hex "E0") (& (shr C 12) (hex "0F"))))
  %14 = trunc i32 %13 to i8
; # (byteSym (i8 (| (hex "E0") (& (shr C 12) (hex "0F")))) P)
  call void @byteSym(i8 %14, i64* %1)
; # (shr C 6)
  %15 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %16 = and i32 %15, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %17 = or i32 128, %16
; # (i8 (| (hex "80") (& (shr C 6) (hex "3F"))))
  %18 = trunc i32 %17 to i8
; # (byteSym (i8 (| (hex "80") (& (shr C 6) (hex "3F")))) P)
  call void @byteSym(i8 %18, i64* %1)
  br label %$7
$10:
; # (shr C 18)
  %19 = lshr i32 %0, 18
; # (& (shr C 18) (hex "07"))
  %20 = and i32 %19, 7
; # (| (hex "F0") (& (shr C 18) (hex "07")))
  %21 = or i32 240, %20
; # (i8 (| (hex "F0") (& (shr C 18) (hex "07"))))
  %22 = trunc i32 %21 to i8
; # (byteSym (i8 (| (hex "F0") (& (shr C 18) (hex "07")))) P)
  call void @byteSym(i8 %22, i64* %1)
; # (shr C 12)
  %23 = lshr i32 %0, 12
; # (& (shr C 12) (hex "3F"))
  %24 = and i32 %23, 63
; # (| (hex "80") (& (shr C 12) (hex "3F")))
  %25 = or i32 128, %24
; # (i8 (| (hex "80") (& (shr C 12) (hex "3F"))))
  %26 = trunc i32 %25 to i8
; # (byteSym (i8 (| (hex "80") (& (shr C 12) (hex "3F")))) P)
  call void @byteSym(i8 %26, i64* %1)
; # (shr C 6)
  %27 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %28 = and i32 %27, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %29 = or i32 128, %28
; # (i8 (| (hex "80") (& (shr C 6) (hex "3F"))))
  %30 = trunc i32 %29 to i8
; # (byteSym (i8 (| (hex "80") (& (shr C 6) (hex "3F")))) P)
  call void @byteSym(i8 %30, i64* %1)
  br label %$7
$7:
; # (& C (hex "3F"))
  %31 = and i32 %0, 63
; # (| (hex "80") (& C (hex "3F")))
  %32 = or i32 128, %31
; # (i8 (| (hex "80") (& C (hex "3F"))))
  %33 = trunc i32 %32 to i8
; # (byteSym (i8 (| (hex "80") (& C (hex "3F")))) P)
  call void @byteSym(i8 %33, i64* %1)
  br label %$2
$2:
  ret void
}

define i64 @zapZero(i64) align 8 {
$1:
; # (let (P (push N) X P Y P Z T) (until (cnt? (setq Z (val (big N)))...
; # (push N)
  %1 = alloca i64, i64 1
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 %2 to i64*
  store i64 %0, i64* %3
; # (until (cnt? (setq Z (val (big N)))) (when (val (dig N)) (setq X ...
  br label %$2
$2:
  %4 = phi i64 [%0, %$1], [%30, %$6] ; # N
  %5 = phi i64 [%2, %$1], [%25, %$6] ; # X
  %6 = phi i64 [%2, %$1], [%28, %$6] ; # Y
; # (big N)
  %7 = add i64 %4, 4
; # (val (big N))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (cnt? (setq Z (val (big N))))
  %10 = and i64 %9, 2
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i64 [%4, %$2] ; # N
  %13 = phi i64 [%5, %$2] ; # X
  %14 = phi i64 [%6, %$2] ; # Y
  %15 = phi i64 [%9, %$2] ; # Z
; # (when (val (dig N)) (setq X Y))
; # (dig N)
  %16 = add i64 %12, -4
; # (val (dig N))
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$5, label %$6
$5:
  %20 = phi i64 [%12, %$3] ; # N
  %21 = phi i64 [%13, %$3] ; # X
  %22 = phi i64 [%14, %$3] ; # Y
  %23 = phi i64 [%15, %$3] ; # Z
  br label %$6
$6:
  %24 = phi i64 [%12, %$3], [%20, %$5] ; # N
  %25 = phi i64 [%13, %$3], [%22, %$5] ; # X
  %26 = phi i64 [%14, %$3], [%22, %$5] ; # Y
  %27 = phi i64 [%15, %$3], [%23, %$5] ; # Z
; # (big N)
  %28 = add i64 %24, 4
; # (val Y)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  br label %$2
$4:
  %31 = phi i64 [%4, %$2] ; # N
  %32 = phi i64 [%5, %$2] ; # X
  %33 = phi i64 [%6, %$2] ; # Y
  %34 = phi i64 [%9, %$2] ; # Z
; # (when (== Z ZERO) (cond ((setq N (val (dig N))) (unless (& N (hex...
; # (== Z ZERO)
  %35 = icmp eq i64 %34, 2
  br i1 %35, label %$7, label %$8
$7:
  %36 = phi i64 [%31, %$4] ; # N
  %37 = phi i64 [%32, %$4] ; # X
  %38 = phi i64 [%33, %$4] ; # Y
  %39 = phi i64 [%34, %$4] ; # Z
; # (cond ((setq N (val (dig N))) (unless (& N (hex "F000000000000000...
; # (dig N)
  %40 = add i64 %36, -4
; # (val (dig N))
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$11, label %$10
$11:
  %44 = phi i64 [%42, %$7] ; # N
  %45 = phi i64 [%37, %$7] ; # X
  %46 = phi i64 [%38, %$7] ; # Y
  %47 = phi i64 [%39, %$7] ; # Z
; # (unless (& N (hex "F000000000000000")) (set Y (cnt N)))
; # (& N (hex "F000000000000000"))
  %48 = and i64 %44, 17293822569102704640
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$13, label %$12
$12:
  %50 = phi i64 [%44, %$11] ; # N
  %51 = phi i64 [%45, %$11] ; # X
  %52 = phi i64 [%46, %$11] ; # Y
  %53 = phi i64 [%47, %$11] ; # Z
; # (set Y (cnt N))
; # (cnt N)
  %54 = shl i64 %50, 4
  %55 = or i64 %54, 2
  %56 = inttoptr i64 %52 to i64*
  store i64 %55, i64* %56
  br label %$13
$13:
  %57 = phi i64 [%44, %$11], [%50, %$12] ; # N
  %58 = phi i64 [%45, %$11], [%51, %$12] ; # X
  %59 = phi i64 [%46, %$11], [%52, %$12] ; # Y
  %60 = phi i64 [%47, %$11], [%53, %$12] ; # Z
  br label %$9
$10:
  %61 = phi i64 [%42, %$7] ; # N
  %62 = phi i64 [%37, %$7] ; # X
  %63 = phi i64 [%38, %$7] ; # Y
  %64 = phi i64 [%39, %$7] ; # Z
; # (val X)
  %65 = inttoptr i64 %62 to i64*
  %66 = load i64, i64* %65
; # (dig (val X))
  %67 = add i64 %66, -4
; # (val (dig (val X)))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (& (setq N (val (dig (val X)))) (hex "F000000000000000"))
  %70 = and i64 %69, 17293822569102704640
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$15, label %$14
$15:
  %72 = phi i64 [%69, %$10] ; # N
  %73 = phi i64 [%62, %$10] ; # X
  %74 = phi i64 [%63, %$10] ; # Y
  %75 = phi i64 [%64, %$10] ; # Z
; # (set (big (val X)) ZERO)
; # (val X)
  %76 = inttoptr i64 %73 to i64*
  %77 = load i64, i64* %76
; # (big (val X))
  %78 = add i64 %77, 4
  %79 = inttoptr i64 %78 to i64*
  store i64 2, i64* %79
  br label %$9
$14:
  %80 = phi i64 [%69, %$10] ; # N
  %81 = phi i64 [%62, %$10] ; # X
  %82 = phi i64 [%63, %$10] ; # Y
  %83 = phi i64 [%64, %$10] ; # Z
; # (set X (cnt N))
; # (cnt N)
  %84 = shl i64 %80, 4
  %85 = or i64 %84, 2
  %86 = inttoptr i64 %81 to i64*
  store i64 %85, i64* %86
  br label %$9
$9:
  %87 = phi i64 [%57, %$13], [%72, %$15], [%80, %$14] ; # N
  %88 = phi i64 [%58, %$13], [%73, %$15], [%81, %$14] ; # X
  %89 = phi i64 [%59, %$13], [%74, %$15], [%82, %$14] ; # Y
  %90 = phi i64 [%60, %$13], [%75, %$15], [%83, %$14] ; # Z
  br label %$8
$8:
  %91 = phi i64 [%31, %$4], [%87, %$9] ; # N
  %92 = phi i64 [%32, %$4], [%88, %$9] ; # X
  %93 = phi i64 [%33, %$4], [%89, %$9] ; # Y
  %94 = phi i64 [%34, %$4], [%90, %$9] ; # Z
; # (val P)
  %95 = inttoptr i64 %2 to i64*
  %96 = load i64, i64* %95
  ret i64 %96
}

define i64 @twiceBig(i64) align 8 {
$1:
; # (let (X N A (val (dig X)) Y (val (big X))) (set (dig X) (shl A 1)...
; # (dig X)
  %1 = add i64 %0, -4
; # (val (dig X))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (big X)
  %4 = add i64 %0, 4
; # (val (big X))
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (set (dig X) (shl A 1))
; # (dig X)
  %7 = add i64 %0, -4
; # (shl A 1)
  %8 = shl i64 %3, 1
  %9 = inttoptr i64 %7 to i64*
  store i64 %8, i64* %9
; # (while (big? Y) (let B (val (dig Y)) (set (dig (setq X Y)) (| (sh...
  br label %$2
$2:
  %10 = phi i64 [%0, %$1], [%17, %$3] ; # X
  %11 = phi i64 [%3, %$1], [%20, %$3] ; # A
  %12 = phi i64 [%6, %$1], [%28, %$3] ; # Y
; # (big? Y)
  %13 = and i64 %12, 4
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$3, label %$4
$3:
  %15 = phi i64 [%10, %$2] ; # X
  %16 = phi i64 [%11, %$2] ; # A
  %17 = phi i64 [%12, %$2] ; # Y
; # (let B (val (dig Y)) (set (dig (setq X Y)) (| (shl B 1) (shl 0 A ...
; # (dig Y)
  %18 = add i64 %17, -4
; # (val (dig Y))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (set (dig (setq X Y)) (| (shl B 1) (shl 0 A 1)))
; # (dig (setq X Y))
  %21 = add i64 %17, -4
; # (shl B 1)
  %22 = shl i64 %20, 1
; # (shl 0 A 1)
  %23 = call i64 @llvm.fshl.i64(i64 0, i64 %16, i64 1)
; # (| (shl B 1) (shl 0 A 1))
  %24 = or i64 %22, %23
  %25 = inttoptr i64 %21 to i64*
  store i64 %24, i64* %25
; # (big Y)
  %26 = add i64 %17, 4
; # (val (big Y))
  %27 = inttoptr i64 %26 to i64*
  %28 = load i64, i64* %27
  br label %$2
$4:
  %29 = phi i64 [%10, %$2] ; # X
  %30 = phi i64 [%11, %$2] ; # A
  %31 = phi i64 [%12, %$2] ; # Y
; # (set (big X) (box64 (| (shl (int Y) 1) (shl 0 A 1))))
; # (big X)
  %32 = add i64 %29, 4
; # (int Y)
  %33 = lshr i64 %31, 4
; # (shl (int Y) 1)
  %34 = shl i64 %33, 1
; # (shl 0 A 1)
  %35 = call i64 @llvm.fshl.i64(i64 0, i64 %30, i64 1)
; # (| (shl (int Y) 1) (shl 0 A 1))
  %36 = or i64 %34, %35
; # (box64 (| (shl (int Y) 1) (shl 0 A 1)))
  %37 = and i64 %36, 17293822569102704640
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$5, label %$6
$5:
  %39 = call i64 @boxNum(i64 %36)
  br label %$7
$6:
  %40 = shl i64 %36, 4
  %41 = or i64 %40, 2
  br label %$7
$7:
  %42 = phi i64 [%39, %$5], [%41, %$6] ; # ->
  %43 = inttoptr i64 %32 to i64*
  store i64 %42, i64* %43
  ret i64 %0
}

define i64 @twice(i64) align 8 {
$1:
; # (if (cnt? N) (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6))...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6)))
; # (add N N)
  %3 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %0, i64 %0)
  %4 = extractvalue {i64, i1} %3, 1
  %5 = extractvalue {i64, i1} %3, 0
; # (if @@ (boxNum (shr N 3)) (x| X 6))
  br i1 %4, label %$5, label %$6
$5:
; # (shr N 3)
  %6 = lshr i64 %0, 3
; # (boxNum (shr N 3))
  %7 = call i64 @boxNum(i64 %6)
  br label %$7
$6:
; # (x| X 6)
  %8 = xor i64 %5, 6
  br label %$7
$7:
  %9 = phi i64 [%7, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (twiceBig N)
  %10 = call i64 @twiceBig(i64 %0)
  br label %$4
$4:
  %11 = phi i64 [%9, %$7], [%10, %$3] ; # ->
  ret i64 %11
}

define i64 @half(i64) align 8 {
$1:
; # (if (cnt? N) (| (& (shr N 1) -10) 2) (let (X N A (shr (val (dig X...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (shr N 1)
  %3 = lshr i64 %0, 1
; # (& (shr N 1) -10)
  %4 = and i64 %3, -10
; # (| (& (shr N 1) -10) 2)
  %5 = or i64 %4, 2
  br label %$4
$3:
; # (let (X N A (shr (val (dig X)) 1) Y (val (big X))) (if (big? Y) (...
; # (dig X)
  %6 = add i64 %0, -4
; # (val (dig X))
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (shr (val (dig X)) 1)
  %9 = lshr i64 %8, 1
; # (big X)
  %10 = add i64 %0, 4
; # (val (big X))
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (if (big? Y) (let Z (val (big Y)) (loop (let B (val (dig Y)) (set...
; # (big? Y)
  %13 = and i64 %12, 4
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$5, label %$6
$5:
  %15 = phi i64 [%0, %$3] ; # X
  %16 = phi i64 [%9, %$3] ; # A
  %17 = phi i64 [%12, %$3] ; # Y
; # (let Z (val (big Y)) (loop (let B (val (dig Y)) (set (dig X) (| (...
; # (big Y)
  %18 = add i64 %17, 4
; # (val (big Y))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (loop (let B (val (dig Y)) (set (dig X) (| (shr B 0 1) A)) (setq ...
  br label %$8
$8:
  %21 = phi i64 [%15, %$5], [%37, %$9] ; # X
  %22 = phi i64 [%16, %$5], [%36, %$9] ; # A
  %23 = phi i64 [%17, %$5], [%38, %$9] ; # Y
  %24 = phi i64 [%20, %$5], [%41, %$9] ; # Z
; # (let B (val (dig Y)) (set (dig X) (| (shr B 0 1) A)) (setq A (shr...
; # (dig Y)
  %25 = add i64 %23, -4
; # (val (dig Y))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (set (dig X) (| (shr B 0 1) A))
; # (dig X)
  %28 = add i64 %21, -4
; # (shr B 0 1)
  %29 = call i64 @llvm.fshr.i64(i64 %27, i64 0, i64 1)
; # (| (shr B 0 1) A)
  %30 = or i64 %29, %22
  %31 = inttoptr i64 %28 to i64*
  store i64 %30, i64* %31
; # (shr B 1)
  %32 = lshr i64 %27, 1
; # (? (cnt? Z))
; # (cnt? Z)
  %33 = and i64 %24, 2
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$10, label %$9
$9:
  %35 = phi i64 [%21, %$8] ; # X
  %36 = phi i64 [%32, %$8] ; # A
  %37 = phi i64 [%23, %$8] ; # Y
  %38 = phi i64 [%24, %$8] ; # Z
; # (big Z)
  %39 = add i64 %38, 4
; # (val (big Z))
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
  br label %$8
$10:
  %42 = phi i64 [%21, %$8] ; # X
  %43 = phi i64 [%32, %$8] ; # A
  %44 = phi i64 [%23, %$8] ; # Y
  %45 = phi i64 [%24, %$8] ; # Z
  %46 = phi i64 [0, %$8] ; # ->
; # (int Z)
  %47 = lshr i64 %45, 4
; # (shr Z 0 1)
  %48 = call i64 @llvm.fshr.i64(i64 %47, i64 0, i64 1)
; # (| (shr Z 0 1) A)
  %49 = or i64 %48, %43
; # (ifn (or (setq Z (shr Z 1)) (& A (hex "F000000000000000"))) (set ...
; # (or (setq Z (shr Z 1)) (& A (hex "F000000000000000")))
; # (shr Z 1)
  %50 = lshr i64 %47, 1
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$11, label %$12
$12:
  %52 = phi i64 [%42, %$10] ; # X
  %53 = phi i64 [%49, %$10] ; # A
  %54 = phi i64 [%44, %$10] ; # Y
  %55 = phi i64 [%50, %$10] ; # Z
; # (& A (hex "F000000000000000"))
  %56 = and i64 %53, 17293822569102704640
  %57 = icmp ne i64 %56, 0
  br label %$11
$11:
  %58 = phi i64 [%42, %$10], [%52, %$12] ; # X
  %59 = phi i64 [%49, %$10], [%53, %$12] ; # A
  %60 = phi i64 [%44, %$10], [%54, %$12] ; # Y
  %61 = phi i64 [%50, %$10], [%55, %$12] ; # Z
  %62 = phi i1 [1, %$10], [%57, %$12] ; # ->
  br i1 %62, label %$14, label %$13
$13:
  %63 = phi i64 [%58, %$11] ; # X
  %64 = phi i64 [%59, %$11] ; # A
  %65 = phi i64 [%60, %$11] ; # Y
  %66 = phi i64 [%61, %$11] ; # Z
; # (set (big X) (cnt A))
; # (big X)
  %67 = add i64 %63, 4
; # (cnt A)
  %68 = shl i64 %64, 4
  %69 = or i64 %68, 2
  %70 = inttoptr i64 %67 to i64*
  store i64 %69, i64* %70
  br label %$15
$14:
  %71 = phi i64 [%58, %$11] ; # X
  %72 = phi i64 [%59, %$11] ; # A
  %73 = phi i64 [%60, %$11] ; # Y
  %74 = phi i64 [%61, %$11] ; # Z
; # (set (dig Y) A)
; # (dig Y)
  %75 = add i64 %73, -4
  %76 = inttoptr i64 %75 to i64*
  store i64 %72, i64* %76
; # (set (big Y) (cnt Z))
; # (big Y)
  %77 = add i64 %73, 4
; # (cnt Z)
  %78 = shl i64 %74, 4
  %79 = or i64 %78, 2
  %80 = inttoptr i64 %77 to i64*
  store i64 %79, i64* %80
  br label %$15
$15:
  %81 = phi i64 [%63, %$13], [%71, %$14] ; # X
  %82 = phi i64 [%64, %$13], [%72, %$14] ; # A
  %83 = phi i64 [%65, %$13], [%73, %$14] ; # Y
  %84 = phi i64 [%66, %$13], [%74, %$14] ; # Z
  %85 = phi i64 [%69, %$13], [%79, %$14] ; # ->
  br label %$7
$6:
  %86 = phi i64 [%0, %$3] ; # X
  %87 = phi i64 [%9, %$3] ; # A
  %88 = phi i64 [%12, %$3] ; # Y
; # (int Y)
  %89 = lshr i64 %88, 4
; # (shr Y 0 1)
  %90 = call i64 @llvm.fshr.i64(i64 %89, i64 0, i64 1)
; # (| (shr Y 0 1) A)
  %91 = or i64 %90, %87
; # (unless (or (setq Y (shr Y 1)) (& A (hex "F000000000000000"))) (r...
; # (or (setq Y (shr Y 1)) (& A (hex "F000000000000000")))
; # (shr Y 1)
  %92 = lshr i64 %89, 1
  %93 = icmp ne i64 %92, 0
  br i1 %93, label %$16, label %$17
$17:
  %94 = phi i64 [%86, %$6] ; # X
  %95 = phi i64 [%91, %$6] ; # A
  %96 = phi i64 [%92, %$6] ; # Y
; # (& A (hex "F000000000000000"))
  %97 = and i64 %95, 17293822569102704640
  %98 = icmp ne i64 %97, 0
  br label %$16
$16:
  %99 = phi i64 [%86, %$6], [%94, %$17] ; # X
  %100 = phi i64 [%91, %$6], [%95, %$17] ; # A
  %101 = phi i64 [%92, %$6], [%96, %$17] ; # Y
  %102 = phi i1 [1, %$6], [%98, %$17] ; # ->
  br i1 %102, label %$19, label %$18
$18:
  %103 = phi i64 [%99, %$16] ; # X
  %104 = phi i64 [%100, %$16] ; # A
  %105 = phi i64 [%101, %$16] ; # Y
; # (cnt A)
  %106 = shl i64 %104, 4
  %107 = or i64 %106, 2
; # (ret (cnt A))
  ret i64 %107
$19:
  %108 = phi i64 [%99, %$16] ; # X
  %109 = phi i64 [%100, %$16] ; # A
  %110 = phi i64 [%101, %$16] ; # Y
; # (set (dig X) A)
; # (dig X)
  %111 = add i64 %108, -4
  %112 = inttoptr i64 %111 to i64*
  store i64 %109, i64* %112
; # (set (big X) (cnt Y))
; # (big X)
  %113 = add i64 %108, 4
; # (cnt Y)
  %114 = shl i64 %110, 4
  %115 = or i64 %114, 2
  %116 = inttoptr i64 %113 to i64*
  store i64 %115, i64* %116
  br label %$7
$7:
  %117 = phi i64 [%81, %$15], [%108, %$19] ; # X
  %118 = phi i64 [%82, %$15], [%109, %$19] ; # A
  %119 = phi i64 [%83, %$15], [%110, %$19] ; # Y
  %120 = phi i64 [%85, %$15], [%115, %$19] ; # ->
  br label %$4
$4:
  %121 = phi i64 [%5, %$2], [%0, %$7] ; # ->
  ret i64 %121
}

define i64 @tenfold(i64) align 8 {
$1:
; # (if (cnt? N) (box64 (* 10 (int N))) (let (X N Lo (mul 10 (val (di...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (int N)
  %3 = lshr i64 %0, 4
; # (* 10 (int N))
  %4 = mul i64 10, %3
; # (box64 (* 10 (int N)))
  %5 = and i64 %4, 17293822569102704640
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$6
$5:
  %7 = call i64 @boxNum(i64 %4)
  br label %$7
$6:
  %8 = shl i64 %4, 4
  %9 = or i64 %8, 2
  br label %$7
$7:
  %10 = phi i64 [%7, %$5], [%9, %$6] ; # ->
  br label %$4
$3:
; # (let (X N Lo (mul 10 (val (dig X))) Hi @@@) (loop (set (dig X) Lo...
; # (dig X)
  %11 = add i64 %0, -4
; # (val (dig X))
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
; # (mul 10 (val (dig X)))
  %14 = zext i64 %13 to i128
  %15 = mul i128 10, %14
  %16 = lshr i128 %15, 64
  %17 = trunc i128 %16 to i64
  %18 = trunc i128 %15 to i64
; # (loop (set (dig X) Lo) (? (cnt? (val (big X))) (set (big X) (box6...
  br label %$8
$8:
  %19 = phi i64 [%0, %$3], [%26, %$9] ; # X
  %20 = phi i64 [%18, %$3], [%56, %$9] ; # Lo
  %21 = phi i64 [%17, %$3], [%58, %$9] ; # Hi
; # (set (dig X) Lo)
; # (dig X)
  %22 = add i64 %19, -4
  %23 = inttoptr i64 %22 to i64*
  store i64 %20, i64* %23
; # (? (cnt? (val (big X))) (set (big X) (box64 (+ Hi (* 10 (int @)))...
; # (big X)
  %24 = add i64 %19, 4
; # (val (big X))
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (cnt? (val (big X)))
  %27 = and i64 %26, 2
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$11, label %$9
$11:
  %29 = phi i64 [%19, %$8] ; # X
  %30 = phi i64 [%20, %$8] ; # Lo
  %31 = phi i64 [%21, %$8] ; # Hi
; # (set (big X) (box64 (+ Hi (* 10 (int @)))))
; # (big X)
  %32 = add i64 %29, 4
; # (int @)
  %33 = lshr i64 %26, 4
; # (* 10 (int @))
  %34 = mul i64 10, %33
; # (+ Hi (* 10 (int @)))
  %35 = add i64 %31, %34
; # (box64 (+ Hi (* 10 (int @))))
  %36 = and i64 %35, 17293822569102704640
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = call i64 @boxNum(i64 %35)
  br label %$14
$13:
  %39 = shl i64 %35, 4
  %40 = or i64 %39, 2
  br label %$14
$14:
  %41 = phi i64 [%38, %$12], [%40, %$13] ; # ->
  %42 = inttoptr i64 %32 to i64*
  store i64 %41, i64* %42
  br label %$10
$9:
  %43 = phi i64 [%19, %$8] ; # X
  %44 = phi i64 [%20, %$8] ; # Lo
  %45 = phi i64 [%21, %$8] ; # Hi
; # (dig X)
  %46 = add i64 %26, -4
; # (val (dig X))
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
; # (mul 10 (val (dig X)))
  %49 = zext i64 %48 to i128
  %50 = mul i128 10, %49
  %51 = lshr i128 %50, 64
  %52 = trunc i128 %51 to i64
  %53 = trunc i128 %50 to i64
; # (add (mul 10 (val (dig X))) Hi)
  %54 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %53, i64 %45)
  %55 = extractvalue {i64, i1} %54, 1
  %56 = extractvalue {i64, i1} %54, 0
; # (+ @@@ @@)
  %57 = zext i1 %55 to i64
  %58 = add i64 %52, %57
  br label %$8
$10:
  %59 = phi i64 [%29, %$14] ; # X
  %60 = phi i64 [%30, %$14] ; # Lo
  %61 = phi i64 [%31, %$14] ; # Hi
  %62 = phi i64 [%41, %$14] ; # ->
  br label %$4
$4:
  %63 = phi i64 [%10, %$7], [%0, %$10] ; # ->
  ret i64 %63
}

define i64 @shlu(i64) align 8 {
$1:
; # (if (cnt? N) (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6))...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6)))
; # (add N N)
  %3 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %0, i64 %0)
  %4 = extractvalue {i64, i1} %3, 1
  %5 = extractvalue {i64, i1} %3, 0
; # (if @@ (boxNum (shr N 3)) (x| X 6))
  br i1 %4, label %$5, label %$6
$5:
; # (shr N 3)
  %6 = lshr i64 %0, 3
; # (boxNum (shr N 3))
  %7 = call i64 @boxNum(i64 %6)
  br label %$7
$6:
; # (x| X 6)
  %8 = xor i64 %5, 6
  br label %$7
$7:
  %9 = phi i64 [%7, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (let (A (val (dig N)) X (boxNum (shl A 1)) Y (val (big N)) R (sav...
; # (dig N)
  %10 = add i64 %0, -4
; # (val (dig N))
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (shl A 1)
  %13 = shl i64 %12, 1
; # (boxNum (shl A 1))
  %14 = call i64 @boxNum(i64 %13)
; # (big N)
  %15 = add i64 %0, 4
; # (val (big N))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (save X)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %14, i64* %22
  %23 = add i64 %21, 8
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %25
; # (while (big? Y) (let B (val (dig Y)) (setq X (set (big X) (boxNum...
  br label %$8
$8:
  %26 = phi i64 [%12, %$3], [%36, %$9] ; # A
  %27 = phi i64 [%14, %$3], [%41, %$9] ; # X
  %28 = phi i64 [%17, %$3], [%45, %$9] ; # Y
; # (big? Y)
  %29 = and i64 %28, 4
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$9, label %$10
$9:
  %31 = phi i64 [%26, %$8] ; # A
  %32 = phi i64 [%27, %$8] ; # X
  %33 = phi i64 [%28, %$8] ; # Y
; # (let B (val (dig Y)) (setq X (set (big X) (boxNum (| (shl B 1) (s...
; # (dig Y)
  %34 = add i64 %33, -4
; # (val (dig Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (set (big X) (boxNum (| (shl B 1) (shl 0 A 1))))
; # (big X)
  %37 = add i64 %32, 4
; # (shl B 1)
  %38 = shl i64 %36, 1
; # (shl 0 A 1)
  %39 = call i64 @llvm.fshl.i64(i64 0, i64 %31, i64 1)
; # (| (shl B 1) (shl 0 A 1))
  %40 = or i64 %38, %39
; # (boxNum (| (shl B 1) (shl 0 A 1)))
  %41 = call i64 @boxNum(i64 %40)
  %42 = inttoptr i64 %37 to i64*
  store i64 %41, i64* %42
; # (big Y)
  %43 = add i64 %33, 4
; # (val (big Y))
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
  br label %$8
$10:
  %46 = phi i64 [%26, %$8] ; # A
  %47 = phi i64 [%27, %$8] ; # X
  %48 = phi i64 [%28, %$8] ; # Y
; # (set (big X) (box64 (| (shl (int Y) 1) (shl 0 A 1))))
; # (big X)
  %49 = add i64 %47, 4
; # (int Y)
  %50 = lshr i64 %48, 4
; # (shl (int Y) 1)
  %51 = shl i64 %50, 1
; # (shl 0 A 1)
  %52 = call i64 @llvm.fshl.i64(i64 0, i64 %46, i64 1)
; # (| (shl (int Y) 1) (shl 0 A 1))
  %53 = or i64 %51, %52
; # (box64 (| (shl (int Y) 1) (shl 0 A 1)))
  %54 = and i64 %53, 17293822569102704640
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$11, label %$12
$11:
  %56 = call i64 @boxNum(i64 %53)
  br label %$13
$12:
  %57 = shl i64 %53, 4
  %58 = or i64 %57, 2
  br label %$13
$13:
  %59 = phi i64 [%56, %$11], [%58, %$12] ; # ->
  %60 = inttoptr i64 %49 to i64*
  store i64 %59, i64* %60
; # (drop *Safe)
  %61 = inttoptr i64 %21 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %63, i64* %64
  br label %$4
$4:
  %65 = phi i64 [%9, %$7], [%14, %$13] ; # ->
  ret i64 %65
}

define i64 @shru(i64) align 8 {
$1:
; # (if (cnt? N) (| (& (shr N 1) -10) 2) (let A (shr (val (dig N)) 1)...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i64 [%0, %$1] ; # N
; # (shr N 1)
  %4 = lshr i64 %3, 1
; # (& (shr N 1) -10)
  %5 = and i64 %4, -10
; # (| (& (shr N 1) -10) 2)
  %6 = or i64 %5, 2
  br label %$4
$3:
  %7 = phi i64 [%0, %$1] ; # N
; # (let A (shr (val (dig N)) 1) (if (big? (setq N (val (big N)))) (l...
; # (dig N)
  %8 = add i64 %7, -4
; # (val (dig N))
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (shr (val (dig N)) 1)
  %11 = lshr i64 %10, 1
; # (if (big? (setq N (val (big N)))) (let (B (val (dig N)) P (boxNum...
; # (big N)
  %12 = add i64 %7, 4
; # (val (big N))
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (big? (setq N (val (big N))))
  %15 = and i64 %14, 4
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$5, label %$6
$5:
  %17 = phi i64 [%14, %$3] ; # N
  %18 = phi i64 [%11, %$3] ; # A
; # (let (B (val (dig N)) P (boxNum (| (shr B 0 1) A)) R (save P)) (l...
; # (dig N)
  %19 = add i64 %17, -4
; # (val (dig N))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (shr B 0 1)
  %22 = call i64 @llvm.fshr.i64(i64 %21, i64 0, i64 1)
; # (| (shr B 0 1) A)
  %23 = or i64 %22, %18
; # (boxNum (| (shr B 0 1) A))
  %24 = call i64 @boxNum(i64 %23)
; # (save P)
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = alloca i64, i64 2, align 16
  %28 = ptrtoint i64* %27 to i64
  %29 = inttoptr i64 %28 to i64*
  store i64 %24, i64* %29
  %30 = add i64 %28, 8
  %31 = inttoptr i64 %30 to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %32
; # (loop (setq A (shr B 1)) (? (cnt? (setq N (val (big N))))) (setq ...
  br label %$8
$8:
  %33 = phi i64 [%17, %$5], [%43, %$9] ; # N
  %34 = phi i64 [%18, %$5], [%44, %$9] ; # A
  %35 = phi i64 [%21, %$5], [%49, %$9] ; # B
  %36 = phi i64 [%24, %$5], [%53, %$9] ; # P
; # (shr B 1)
  %37 = lshr i64 %35, 1
; # (? (cnt? (setq N (val (big N)))))
; # (big N)
  %38 = add i64 %33, 4
; # (val (big N))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (cnt? (setq N (val (big N))))
  %41 = and i64 %40, 2
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$10, label %$9
$9:
  %43 = phi i64 [%40, %$8] ; # N
  %44 = phi i64 [%37, %$8] ; # A
  %45 = phi i64 [%35, %$8] ; # B
  %46 = phi i64 [%36, %$8] ; # P
; # (dig N)
  %47 = add i64 %43, -4
; # (val (dig N))
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (set (big P) (boxNum (| (shr B 0 1) A)))
; # (big P)
  %50 = add i64 %46, 4
; # (shr B 0 1)
  %51 = call i64 @llvm.fshr.i64(i64 %49, i64 0, i64 1)
; # (| (shr B 0 1) A)
  %52 = or i64 %51, %44
; # (boxNum (| (shr B 0 1) A))
  %53 = call i64 @boxNum(i64 %52)
  %54 = inttoptr i64 %50 to i64*
  store i64 %53, i64* %54
  br label %$8
$10:
  %55 = phi i64 [%40, %$8] ; # N
  %56 = phi i64 [%37, %$8] ; # A
  %57 = phi i64 [%35, %$8] ; # B
  %58 = phi i64 [%36, %$8] ; # P
  %59 = phi i64 [0, %$8] ; # ->
; # (int N)
  %60 = lshr i64 %55, 4
; # (shr N 0 1)
  %61 = call i64 @llvm.fshr.i64(i64 %60, i64 0, i64 1)
; # (| (shr N 0 1) A)
  %62 = or i64 %61, %56
; # (set (big P) (ifn (or (setq N (shr N 1)) (& A (hex "F000000000000...
; # (big P)
  %63 = add i64 %58, 4
; # (ifn (or (setq N (shr N 1)) (& A (hex "F000000000000000"))) (cnt ...
; # (or (setq N (shr N 1)) (& A (hex "F000000000000000")))
; # (shr N 1)
  %64 = lshr i64 %60, 1
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$11, label %$12
$12:
  %66 = phi i64 [%64, %$10] ; # N
  %67 = phi i64 [%62, %$10] ; # A
  %68 = phi i64 [%57, %$10] ; # B
  %69 = phi i64 [%58, %$10] ; # P
; # (& A (hex "F000000000000000"))
  %70 = and i64 %67, 17293822569102704640
  %71 = icmp ne i64 %70, 0
  br label %$11
$11:
  %72 = phi i64 [%64, %$10], [%66, %$12] ; # N
  %73 = phi i64 [%62, %$10], [%67, %$12] ; # A
  %74 = phi i64 [%57, %$10], [%68, %$12] ; # B
  %75 = phi i64 [%58, %$10], [%69, %$12] ; # P
  %76 = phi i1 [1, %$10], [%71, %$12] ; # ->
  br i1 %76, label %$14, label %$13
$13:
  %77 = phi i64 [%72, %$11] ; # N
  %78 = phi i64 [%73, %$11] ; # A
  %79 = phi i64 [%74, %$11] ; # B
  %80 = phi i64 [%75, %$11] ; # P
; # (cnt A)
  %81 = shl i64 %78, 4
  %82 = or i64 %81, 2
  br label %$15
$14:
  %83 = phi i64 [%72, %$11] ; # N
  %84 = phi i64 [%73, %$11] ; # A
  %85 = phi i64 [%74, %$11] ; # B
  %86 = phi i64 [%75, %$11] ; # P
; # (prog1 (boxNum A) (set (big @) (cnt N)))
; # (boxNum A)
  %87 = call i64 @boxNum(i64 %84)
; # (set (big @) (cnt N))
; # (big @)
  %88 = add i64 %87, 4
; # (cnt N)
  %89 = shl i64 %83, 4
  %90 = or i64 %89, 2
  %91 = inttoptr i64 %88 to i64*
  store i64 %90, i64* %91
  br label %$15
$15:
  %92 = phi i64 [%77, %$13], [%83, %$14] ; # N
  %93 = phi i64 [%78, %$13], [%84, %$14] ; # A
  %94 = phi i64 [%79, %$13], [%85, %$14] ; # B
  %95 = phi i64 [%80, %$13], [%86, %$14] ; # P
  %96 = phi i64 [%82, %$13], [%87, %$14] ; # ->
  %97 = inttoptr i64 %63 to i64*
  store i64 %96, i64* %97
; # (drop *Safe)
  %98 = inttoptr i64 %28 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %100, i64* %101
  br label %$7
$6:
  %102 = phi i64 [%14, %$3] ; # N
  %103 = phi i64 [%11, %$3] ; # A
; # (int N)
  %104 = lshr i64 %102, 4
; # (shr N 0 1)
  %105 = call i64 @llvm.fshr.i64(i64 %104, i64 0, i64 1)
; # (| (shr N 0 1) A)
  %106 = or i64 %105, %103
; # (ifn (or (setq N (shr N 1)) (& A (hex "F000000000000000"))) (cnt ...
; # (or (setq N (shr N 1)) (& A (hex "F000000000000000")))
; # (shr N 1)
  %107 = lshr i64 %104, 1
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$16, label %$17
$17:
  %109 = phi i64 [%107, %$6] ; # N
  %110 = phi i64 [%106, %$6] ; # A
; # (& A (hex "F000000000000000"))
  %111 = and i64 %110, 17293822569102704640
  %112 = icmp ne i64 %111, 0
  br label %$16
$16:
  %113 = phi i64 [%107, %$6], [%109, %$17] ; # N
  %114 = phi i64 [%106, %$6], [%110, %$17] ; # A
  %115 = phi i1 [1, %$6], [%112, %$17] ; # ->
  br i1 %115, label %$19, label %$18
$18:
  %116 = phi i64 [%113, %$16] ; # N
  %117 = phi i64 [%114, %$16] ; # A
; # (cnt A)
  %118 = shl i64 %117, 4
  %119 = or i64 %118, 2
  br label %$20
$19:
  %120 = phi i64 [%113, %$16] ; # N
  %121 = phi i64 [%114, %$16] ; # A
; # (prog1 (boxNum A) (set (big @) (cnt N)))
; # (boxNum A)
  %122 = call i64 @boxNum(i64 %121)
; # (set (big @) (cnt N))
; # (big @)
  %123 = add i64 %122, 4
; # (cnt N)
  %124 = shl i64 %120, 4
  %125 = or i64 %124, 2
  %126 = inttoptr i64 %123 to i64*
  store i64 %125, i64* %126
  br label %$20
$20:
  %127 = phi i64 [%116, %$18], [%120, %$19] ; # N
  %128 = phi i64 [%117, %$18], [%121, %$19] ; # A
  %129 = phi i64 [%119, %$18], [%122, %$19] ; # ->
  br label %$7
$7:
  %130 = phi i64 [%92, %$15], [%127, %$20] ; # N
  %131 = phi i64 [%93, %$15], [%128, %$20] ; # A
  %132 = phi i64 [%24, %$15], [%129, %$20] ; # ->
  br label %$4
$4:
  %133 = phi i64 [%3, %$2], [%130, %$7] ; # N
  %134 = phi i64 [%6, %$2], [%132, %$7] ; # ->
  ret i64 %134
}

define i64 @andu(i64, i64) align 8 {
$1:
; # (cond ((cnt? A) (& A (if (cnt? B) B (cnt (val (dig B)))))) ((cnt?...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) B (cnt (val (dig B))))
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
  br label %$7
$6:
  %10 = phi i64 [%4, %$4] ; # A
  %11 = phi i64 [%5, %$4] ; # B
; # (dig B)
  %12 = add i64 %11, -4
; # (val (dig B))
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (cnt (val (dig B)))
  %15 = shl i64 %14, 4
  %16 = or i64 %15, 2
  br label %$7
$7:
  %17 = phi i64 [%8, %$5], [%10, %$6] ; # A
  %18 = phi i64 [%9, %$5], [%11, %$6] ; # B
  %19 = phi i64 [%9, %$5], [%16, %$6] ; # ->
; # (& A (if (cnt? B) B (cnt (val (dig B)))))
  %20 = and i64 %4, %19
  br label %$2
$3:
  %21 = phi i64 [%0, %$1] ; # A
  %22 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %23 = and i64 %22, 2
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$9, label %$8
$9:
  %25 = phi i64 [%21, %$3] ; # A
  %26 = phi i64 [%22, %$3] ; # B
; # (dig A)
  %27 = add i64 %25, -4
; # (val (dig A))
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (cnt (val (dig A)))
  %30 = shl i64 %29, 4
  %31 = or i64 %30, 2
; # (& B (cnt (val (dig A))))
  %32 = and i64 %26, %31
  br label %$2
$8:
  %33 = phi i64 [%21, %$3] ; # A
  %34 = phi i64 [%22, %$3] ; # B
; # (let (P (boxNum (& (val (dig A)) (val (dig B)))) R (save P)) (loo...
; # (dig A)
  %35 = add i64 %33, -4
; # (val (dig A))
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
; # (dig B)
  %38 = add i64 %34, -4
; # (val (dig B))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (& (val (dig A)) (val (dig B)))
  %41 = and i64 %37, %40
; # (boxNum (& (val (dig A)) (val (dig B))))
  %42 = call i64 @boxNum(i64 %41)
; # (save P)
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %44 = load i64, i64* %43
  %45 = alloca i64, i64 2, align 16
  %46 = ptrtoint i64* %45 to i64
  %47 = inttoptr i64 %46 to i64*
  store i64 %42, i64* %47
  %48 = add i64 %46, 8
  %49 = inttoptr i64 %48 to i64*
  store i64 %44, i64* %49
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %46, i64* %50
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (set (bi...
  br label %$10
$10:
  %51 = phi i64 [%33, %$8], [%101, %$17] ; # A
  %52 = phi i64 [%34, %$8], [%102, %$17] ; # B
  %53 = phi i64 [%42, %$8], [%112, %$17] ; # P
; # (big A)
  %54 = add i64 %51, 4
; # (val (big A))
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (big B)
  %57 = add i64 %52, 4
; # (val (big B))
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (? (cnt? A) (set (big P) (& A (if (cnt? B) B (cnt (val (dig B))))...
; # (cnt? A)
  %60 = and i64 %56, 2
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$13, label %$11
$13:
  %62 = phi i64 [%56, %$10] ; # A
  %63 = phi i64 [%59, %$10] ; # B
  %64 = phi i64 [%53, %$10] ; # P
; # (set (big P) (& A (if (cnt? B) B (cnt (val (dig B))))))
; # (big P)
  %65 = add i64 %64, 4
; # (if (cnt? B) B (cnt (val (dig B))))
; # (cnt? B)
  %66 = and i64 %63, 2
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$14, label %$15
$14:
  %68 = phi i64 [%62, %$13] ; # A
  %69 = phi i64 [%63, %$13] ; # B
  %70 = phi i64 [%64, %$13] ; # P
  br label %$16
$15:
  %71 = phi i64 [%62, %$13] ; # A
  %72 = phi i64 [%63, %$13] ; # B
  %73 = phi i64 [%64, %$13] ; # P
; # (dig B)
  %74 = add i64 %72, -4
; # (val (dig B))
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
; # (cnt (val (dig B)))
  %77 = shl i64 %76, 4
  %78 = or i64 %77, 2
  br label %$16
$16:
  %79 = phi i64 [%68, %$14], [%71, %$15] ; # A
  %80 = phi i64 [%69, %$14], [%72, %$15] ; # B
  %81 = phi i64 [%70, %$14], [%73, %$15] ; # P
  %82 = phi i64 [%69, %$14], [%78, %$15] ; # ->
; # (& A (if (cnt? B) B (cnt (val (dig B)))))
  %83 = and i64 %62, %82
  %84 = inttoptr i64 %65 to i64*
  store i64 %83, i64* %84
  br label %$12
$11:
  %85 = phi i64 [%56, %$10] ; # A
  %86 = phi i64 [%59, %$10] ; # B
  %87 = phi i64 [%53, %$10] ; # P
; # (? (cnt? B) (set (big P) (& B (cnt (val (dig A))))))
; # (cnt? B)
  %88 = and i64 %86, 2
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$18, label %$17
$18:
  %90 = phi i64 [%85, %$11] ; # A
  %91 = phi i64 [%86, %$11] ; # B
  %92 = phi i64 [%87, %$11] ; # P
; # (set (big P) (& B (cnt (val (dig A)))))
; # (big P)
  %93 = add i64 %92, 4
; # (dig A)
  %94 = add i64 %90, -4
; # (val (dig A))
  %95 = inttoptr i64 %94 to i64*
  %96 = load i64, i64* %95
; # (cnt (val (dig A)))
  %97 = shl i64 %96, 4
  %98 = or i64 %97, 2
; # (& B (cnt (val (dig A))))
  %99 = and i64 %91, %98
  %100 = inttoptr i64 %93 to i64*
  store i64 %99, i64* %100
  br label %$12
$17:
  %101 = phi i64 [%85, %$11] ; # A
  %102 = phi i64 [%86, %$11] ; # B
  %103 = phi i64 [%87, %$11] ; # P
; # (set (big P) (boxNum (& (val (dig A)) (val (dig B)))))
; # (big P)
  %104 = add i64 %103, 4
; # (dig A)
  %105 = add i64 %101, -4
; # (val (dig A))
  %106 = inttoptr i64 %105 to i64*
  %107 = load i64, i64* %106
; # (dig B)
  %108 = add i64 %102, -4
; # (val (dig B))
  %109 = inttoptr i64 %108 to i64*
  %110 = load i64, i64* %109
; # (& (val (dig A)) (val (dig B)))
  %111 = and i64 %107, %110
; # (boxNum (& (val (dig A)) (val (dig B))))
  %112 = call i64 @boxNum(i64 %111)
  %113 = inttoptr i64 %104 to i64*
  store i64 %112, i64* %113
  br label %$10
$12:
  %114 = phi i64 [%79, %$16], [%90, %$18] ; # A
  %115 = phi i64 [%80, %$16], [%91, %$18] ; # B
  %116 = phi i64 [%81, %$16], [%92, %$18] ; # P
  %117 = phi i64 [%83, %$16], [%99, %$18] ; # ->
; # (zapZero R)
  %118 = call i64 @zapZero(i64 %42)
; # (drop *Safe)
  %119 = inttoptr i64 %46 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %121, i64* %122
  br label %$2
$2:
  %123 = phi i64 [%17, %$7], [%25, %$9], [%114, %$12] ; # A
  %124 = phi i64 [%18, %$7], [%26, %$9], [%115, %$12] ; # B
  %125 = phi i64 [%20, %$7], [%32, %$9], [%118, %$12] ; # ->
  ret i64 %125
}

define i64 @oru(i64, i64) align 8 {
$1:
; # (cond ((cnt? A) (if (cnt? B) (| A B) (consNum (| (int A) (val (di...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (| A B) (consNum (| (int A) (val (dig B))) (val (big...
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (| A B)
  %10 = or i64 %8, %9
  br label %$7
$6:
  %11 = phi i64 [%4, %$4] ; # A
  %12 = phi i64 [%5, %$4] ; # B
; # (int A)
  %13 = lshr i64 %11, 4
; # (dig B)
  %14 = add i64 %12, -4
; # (val (dig B))
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
; # (| (int A) (val (dig B)))
  %17 = or i64 %13, %16
; # (big B)
  %18 = add i64 %12, 4
; # (val (big B))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (consNum (| (int A) (val (dig B))) (val (big B)))
  %21 = call i64 @consNum(i64 %17, i64 %20)
  br label %$7
$7:
  %22 = phi i64 [%8, %$5], [%11, %$6] ; # A
  %23 = phi i64 [%9, %$5], [%12, %$6] ; # B
  %24 = phi i64 [%10, %$5], [%21, %$6] ; # ->
  br label %$2
$3:
  %25 = phi i64 [%0, %$1] ; # A
  %26 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %27 = and i64 %26, 2
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$9, label %$8
$9:
  %29 = phi i64 [%25, %$3] ; # A
  %30 = phi i64 [%26, %$3] ; # B
; # (int B)
  %31 = lshr i64 %30, 4
; # (dig A)
  %32 = add i64 %29, -4
; # (val (dig A))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (| (int B) (val (dig A)))
  %35 = or i64 %31, %34
; # (big A)
  %36 = add i64 %29, 4
; # (val (big A))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (consNum (| (int B) (val (dig A))) (val (big A)))
  %39 = call i64 @consNum(i64 %35, i64 %38)
  br label %$2
$8:
  %40 = phi i64 [%25, %$3] ; # A
  %41 = phi i64 [%26, %$3] ; # B
; # (let (P (boxNum (| (val (dig A)) (val (dig B)))) R (save P)) (loo...
; # (dig A)
  %42 = add i64 %40, -4
; # (val (dig A))
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (dig B)
  %45 = add i64 %41, -4
; # (val (dig B))
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (| (val (dig A)) (val (dig B)))
  %48 = or i64 %44, %47
; # (boxNum (| (val (dig A)) (val (dig B))))
  %49 = call i64 @boxNum(i64 %48)
; # (save P)
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = alloca i64, i64 2, align 16
  %53 = ptrtoint i64* %52 to i64
  %54 = inttoptr i64 %53 to i64*
  store i64 %49, i64* %54
  %55 = add i64 %53, 8
  %56 = inttoptr i64 %55 to i64*
  store i64 %51, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %57
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (set (bi...
  br label %$10
$10:
  %58 = phi i64 [%40, %$8], [%115, %$17] ; # A
  %59 = phi i64 [%41, %$8], [%116, %$17] ; # B
  %60 = phi i64 [%49, %$8], [%126, %$17] ; # P
; # (big A)
  %61 = add i64 %58, 4
; # (val (big A))
  %62 = inttoptr i64 %61 to i64*
  %63 = load i64, i64* %62
; # (big B)
  %64 = add i64 %59, 4
; # (val (big B))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (? (cnt? A) (set (big P) (if (cnt? B) (| A B) (consNum (| (int A)...
; # (cnt? A)
  %67 = and i64 %63, 2
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$13, label %$11
$13:
  %69 = phi i64 [%63, %$10] ; # A
  %70 = phi i64 [%66, %$10] ; # B
  %71 = phi i64 [%60, %$10] ; # P
; # (set (big P) (if (cnt? B) (| A B) (consNum (| (int A) (val (dig B...
; # (big P)
  %72 = add i64 %71, 4
; # (if (cnt? B) (| A B) (consNum (| (int A) (val (dig B))) (val (big...
; # (cnt? B)
  %73 = and i64 %70, 2
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$14, label %$15
$14:
  %75 = phi i64 [%69, %$13] ; # A
  %76 = phi i64 [%70, %$13] ; # B
  %77 = phi i64 [%71, %$13] ; # P
; # (| A B)
  %78 = or i64 %75, %76
  br label %$16
$15:
  %79 = phi i64 [%69, %$13] ; # A
  %80 = phi i64 [%70, %$13] ; # B
  %81 = phi i64 [%71, %$13] ; # P
; # (int A)
  %82 = lshr i64 %79, 4
; # (dig B)
  %83 = add i64 %80, -4
; # (val (dig B))
  %84 = inttoptr i64 %83 to i64*
  %85 = load i64, i64* %84
; # (| (int A) (val (dig B)))
  %86 = or i64 %82, %85
; # (big B)
  %87 = add i64 %80, 4
; # (val (big B))
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (consNum (| (int A) (val (dig B))) (val (big B)))
  %90 = call i64 @consNum(i64 %86, i64 %89)
  br label %$16
$16:
  %91 = phi i64 [%75, %$14], [%79, %$15] ; # A
  %92 = phi i64 [%76, %$14], [%80, %$15] ; # B
  %93 = phi i64 [%77, %$14], [%81, %$15] ; # P
  %94 = phi i64 [%78, %$14], [%90, %$15] ; # ->
  %95 = inttoptr i64 %72 to i64*
  store i64 %94, i64* %95
  br label %$12
$11:
  %96 = phi i64 [%63, %$10] ; # A
  %97 = phi i64 [%66, %$10] ; # B
  %98 = phi i64 [%60, %$10] ; # P
; # (? (cnt? B) (set (big P) (consNum (| (int B) (val (dig A))) (val ...
; # (cnt? B)
  %99 = and i64 %97, 2
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$18, label %$17
$18:
  %101 = phi i64 [%96, %$11] ; # A
  %102 = phi i64 [%97, %$11] ; # B
  %103 = phi i64 [%98, %$11] ; # P
; # (set (big P) (consNum (| (int B) (val (dig A))) (val (big A))))
; # (big P)
  %104 = add i64 %103, 4
; # (int B)
  %105 = lshr i64 %102, 4
; # (dig A)
  %106 = add i64 %101, -4
; # (val (dig A))
  %107 = inttoptr i64 %106 to i64*
  %108 = load i64, i64* %107
; # (| (int B) (val (dig A)))
  %109 = or i64 %105, %108
; # (big A)
  %110 = add i64 %101, 4
; # (val (big A))
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
; # (consNum (| (int B) (val (dig A))) (val (big A)))
  %113 = call i64 @consNum(i64 %109, i64 %112)
  %114 = inttoptr i64 %104 to i64*
  store i64 %113, i64* %114
  br label %$12
$17:
  %115 = phi i64 [%96, %$11] ; # A
  %116 = phi i64 [%97, %$11] ; # B
  %117 = phi i64 [%98, %$11] ; # P
; # (set (big P) (boxNum (| (val (dig A)) (val (dig B)))))
; # (big P)
  %118 = add i64 %117, 4
; # (dig A)
  %119 = add i64 %115, -4
; # (val (dig A))
  %120 = inttoptr i64 %119 to i64*
  %121 = load i64, i64* %120
; # (dig B)
  %122 = add i64 %116, -4
; # (val (dig B))
  %123 = inttoptr i64 %122 to i64*
  %124 = load i64, i64* %123
; # (| (val (dig A)) (val (dig B)))
  %125 = or i64 %121, %124
; # (boxNum (| (val (dig A)) (val (dig B))))
  %126 = call i64 @boxNum(i64 %125)
  %127 = inttoptr i64 %118 to i64*
  store i64 %126, i64* %127
  br label %$10
$12:
  %128 = phi i64 [%91, %$16], [%101, %$18] ; # A
  %129 = phi i64 [%92, %$16], [%102, %$18] ; # B
  %130 = phi i64 [%93, %$16], [%103, %$18] ; # P
  %131 = phi i64 [%94, %$16], [%113, %$18] ; # ->
; # (drop *Safe)
  %132 = inttoptr i64 %53 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
  %135 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %134, i64* %135
  br label %$2
$2:
  %136 = phi i64 [%22, %$7], [%29, %$9], [%128, %$12] ; # A
  %137 = phi i64 [%23, %$7], [%30, %$9], [%129, %$12] ; # B
  %138 = phi i64 [%24, %$7], [%39, %$9], [%49, %$12] ; # ->
  ret i64 %138
}

define i64 @xoru(i64, i64) align 8 {
$1:
; # (cond ((cnt? A) (if (cnt? B) (| (x| A B) 2) (zapZero (consNum (x|...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (| (x| A B) 2) (zapZero (consNum (x| (int A) (val (d...
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (x| A B)
  %10 = xor i64 %8, %9
; # (| (x| A B) 2)
  %11 = or i64 %10, 2
  br label %$7
$6:
  %12 = phi i64 [%4, %$4] ; # A
  %13 = phi i64 [%5, %$4] ; # B
; # (int A)
  %14 = lshr i64 %12, 4
; # (dig B)
  %15 = add i64 %13, -4
; # (val (dig B))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (x| (int A) (val (dig B)))
  %18 = xor i64 %14, %17
; # (big B)
  %19 = add i64 %13, 4
; # (val (big B))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (consNum (x| (int A) (val (dig B))) (val (big B)))
  %22 = call i64 @consNum(i64 %18, i64 %21)
; # (zapZero (consNum (x| (int A) (val (dig B))) (val (big B))))
  %23 = call i64 @zapZero(i64 %22)
  br label %$7
$7:
  %24 = phi i64 [%8, %$5], [%12, %$6] ; # A
  %25 = phi i64 [%9, %$5], [%13, %$6] ; # B
  %26 = phi i64 [%11, %$5], [%23, %$6] ; # ->
  br label %$2
$3:
  %27 = phi i64 [%0, %$1] ; # A
  %28 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %29 = and i64 %28, 2
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$9, label %$8
$9:
  %31 = phi i64 [%27, %$3] ; # A
  %32 = phi i64 [%28, %$3] ; # B
; # (int B)
  %33 = lshr i64 %32, 4
; # (dig A)
  %34 = add i64 %31, -4
; # (val (dig A))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (x| (int B) (val (dig A)))
  %37 = xor i64 %33, %36
; # (big A)
  %38 = add i64 %31, 4
; # (val (big A))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (consNum (x| (int B) (val (dig A))) (val (big A)))
  %41 = call i64 @consNum(i64 %37, i64 %40)
; # (zapZero (consNum (x| (int B) (val (dig A))) (val (big A))))
  %42 = call i64 @zapZero(i64 %41)
  br label %$2
$8:
  %43 = phi i64 [%27, %$3] ; # A
  %44 = phi i64 [%28, %$3] ; # B
; # (let (P (boxNum (x| (val (dig A)) (val (dig B)))) R (save P)) (lo...
; # (dig A)
  %45 = add i64 %43, -4
; # (val (dig A))
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (dig B)
  %48 = add i64 %44, -4
; # (val (dig B))
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (x| (val (dig A)) (val (dig B)))
  %51 = xor i64 %47, %50
; # (boxNum (x| (val (dig A)) (val (dig B))))
  %52 = call i64 @boxNum(i64 %51)
; # (save P)
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %54 = load i64, i64* %53
  %55 = alloca i64, i64 2, align 16
  %56 = ptrtoint i64* %55 to i64
  %57 = inttoptr i64 %56 to i64*
  store i64 %52, i64* %57
  %58 = add i64 %56, 8
  %59 = inttoptr i64 %58 to i64*
  store i64 %54, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %56, i64* %60
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (set (bi...
  br label %$10
$10:
  %61 = phi i64 [%43, %$8], [%119, %$17] ; # A
  %62 = phi i64 [%44, %$8], [%120, %$17] ; # B
  %63 = phi i64 [%52, %$8], [%130, %$17] ; # P
; # (big A)
  %64 = add i64 %61, 4
; # (val (big A))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (big B)
  %67 = add i64 %62, 4
; # (val (big B))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (? (cnt? A) (set (big P) (if (cnt? B) (| (x| A B) 2) (consNum (x|...
; # (cnt? A)
  %70 = and i64 %66, 2
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$13, label %$11
$13:
  %72 = phi i64 [%66, %$10] ; # A
  %73 = phi i64 [%69, %$10] ; # B
  %74 = phi i64 [%63, %$10] ; # P
; # (set (big P) (if (cnt? B) (| (x| A B) 2) (consNum (x| (int A) (va...
; # (big P)
  %75 = add i64 %74, 4
; # (if (cnt? B) (| (x| A B) 2) (consNum (x| (int A) (val (dig B))) (...
; # (cnt? B)
  %76 = and i64 %73, 2
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$14, label %$15
$14:
  %78 = phi i64 [%72, %$13] ; # A
  %79 = phi i64 [%73, %$13] ; # B
  %80 = phi i64 [%74, %$13] ; # P
; # (x| A B)
  %81 = xor i64 %78, %79
; # (| (x| A B) 2)
  %82 = or i64 %81, 2
  br label %$16
$15:
  %83 = phi i64 [%72, %$13] ; # A
  %84 = phi i64 [%73, %$13] ; # B
  %85 = phi i64 [%74, %$13] ; # P
; # (int A)
  %86 = lshr i64 %83, 4
; # (dig B)
  %87 = add i64 %84, -4
; # (val (dig B))
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (x| (int A) (val (dig B)))
  %90 = xor i64 %86, %89
; # (big B)
  %91 = add i64 %84, 4
; # (val (big B))
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
; # (consNum (x| (int A) (val (dig B))) (val (big B)))
  %94 = call i64 @consNum(i64 %90, i64 %93)
  br label %$16
$16:
  %95 = phi i64 [%78, %$14], [%83, %$15] ; # A
  %96 = phi i64 [%79, %$14], [%84, %$15] ; # B
  %97 = phi i64 [%80, %$14], [%85, %$15] ; # P
  %98 = phi i64 [%82, %$14], [%94, %$15] ; # ->
  %99 = inttoptr i64 %75 to i64*
  store i64 %98, i64* %99
  br label %$12
$11:
  %100 = phi i64 [%66, %$10] ; # A
  %101 = phi i64 [%69, %$10] ; # B
  %102 = phi i64 [%63, %$10] ; # P
; # (? (cnt? B) (set (big P) (consNum (x| (int B) (val (dig A))) (val...
; # (cnt? B)
  %103 = and i64 %101, 2
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$18, label %$17
$18:
  %105 = phi i64 [%100, %$11] ; # A
  %106 = phi i64 [%101, %$11] ; # B
  %107 = phi i64 [%102, %$11] ; # P
; # (set (big P) (consNum (x| (int B) (val (dig A))) (val (big A))))
; # (big P)
  %108 = add i64 %107, 4
; # (int B)
  %109 = lshr i64 %106, 4
; # (dig A)
  %110 = add i64 %105, -4
; # (val (dig A))
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
; # (x| (int B) (val (dig A)))
  %113 = xor i64 %109, %112
; # (big A)
  %114 = add i64 %105, 4
; # (val (big A))
  %115 = inttoptr i64 %114 to i64*
  %116 = load i64, i64* %115
; # (consNum (x| (int B) (val (dig A))) (val (big A)))
  %117 = call i64 @consNum(i64 %113, i64 %116)
  %118 = inttoptr i64 %108 to i64*
  store i64 %117, i64* %118
  br label %$12
$17:
  %119 = phi i64 [%100, %$11] ; # A
  %120 = phi i64 [%101, %$11] ; # B
  %121 = phi i64 [%102, %$11] ; # P
; # (set (big P) (boxNum (x| (val (dig A)) (val (dig B)))))
; # (big P)
  %122 = add i64 %121, 4
; # (dig A)
  %123 = add i64 %119, -4
; # (val (dig A))
  %124 = inttoptr i64 %123 to i64*
  %125 = load i64, i64* %124
; # (dig B)
  %126 = add i64 %120, -4
; # (val (dig B))
  %127 = inttoptr i64 %126 to i64*
  %128 = load i64, i64* %127
; # (x| (val (dig A)) (val (dig B)))
  %129 = xor i64 %125, %128
; # (boxNum (x| (val (dig A)) (val (dig B))))
  %130 = call i64 @boxNum(i64 %129)
  %131 = inttoptr i64 %122 to i64*
  store i64 %130, i64* %131
  br label %$10
$12:
  %132 = phi i64 [%95, %$16], [%105, %$18] ; # A
  %133 = phi i64 [%96, %$16], [%106, %$18] ; # B
  %134 = phi i64 [%97, %$16], [%107, %$18] ; # P
  %135 = phi i64 [%98, %$16], [%117, %$18] ; # ->
; # (zapZero R)
  %136 = call i64 @zapZero(i64 %52)
; # (drop *Safe)
  %137 = inttoptr i64 %56 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %139, i64* %140
  br label %$2
$2:
  %141 = phi i64 [%24, %$7], [%31, %$9], [%132, %$12] ; # A
  %142 = phi i64 [%25, %$7], [%32, %$9], [%133, %$12] ; # B
  %143 = phi i64 [%26, %$7], [%42, %$9], [%136, %$12] ; # ->
  ret i64 %143
}

define i64 @addu(i64, i64) align 8 {
$1:
; # (cond ((cnt? A) (if (cnt? B) (box64 (+ (int A) (int B))) (xchg 'A...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (box64 (+ (int A) (int B))) (xchg 'A 'B) (goto 1))
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (int A)
  %10 = lshr i64 %8, 4
; # (int B)
  %11 = lshr i64 %9, 4
; # (+ (int A) (int B))
  %12 = add i64 %10, %11
; # (box64 (+ (int A) (int B)))
  %13 = and i64 %12, 17293822569102704640
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$9
$8:
  %15 = call i64 @boxNum(i64 %12)
  br label %$10
$9:
  %16 = shl i64 %12, 4
  %17 = or i64 %16, 2
  br label %$10
$10:
  %18 = phi i64 [%15, %$8], [%17, %$9] ; # ->
  br label %$7
$6:
  %19 = phi i64 [%4, %$4] ; # A
  %20 = phi i64 [%5, %$4] ; # B
; # (xchg 'A 'B)
; # (goto 1)
  br label %$-1
$7:
  %21 = phi i64 [%8, %$10] ; # A
  %22 = phi i64 [%9, %$10] ; # B
  %23 = phi i64 [%18, %$10] ; # ->
  br label %$2
$3:
  %24 = phi i64 [%0, %$1] ; # A
  %25 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %26 = and i64 %25, 2
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$12, label %$11
$12:
  %28 = phi i64 [%24, %$3] ; # A
  %29 = phi i64 [%25, %$3] ; # B
; # (: 1 (let N (val (big A)) (setq B (add (int B) (val (dig A)))) (i...
  br label %$-1
$-1:
  %30 = phi i64 [%20, %$6], [%28, %$12] ; # A
  %31 = phi i64 [%19, %$6], [%29, %$12] ; # B
; # (let N (val (big A)) (setq B (add (int B) (val (dig A)))) (ifn @@...
; # (big A)
  %32 = add i64 %30, 4
; # (val (big A))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (int B)
  %35 = lshr i64 %31, 4
; # (dig A)
  %36 = add i64 %30, -4
; # (val (dig A))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (add (int B) (val (dig A)))
  %39 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %35, i64 %38)
  %40 = extractvalue {i64, i1} %39, 1
  %41 = extractvalue {i64, i1} %39, 0
; # (ifn @@ (consNum B N) (let R (save (setq B (consNum B N))) (loop ...
  br i1 %40, label %$14, label %$13
$13:
  %42 = phi i64 [%30, %$-1] ; # A
  %43 = phi i64 [%41, %$-1] ; # B
  %44 = phi i64 [%34, %$-1] ; # N
; # (consNum B N)
  %45 = call i64 @consNum(i64 %43, i64 %44)
  br label %$15
$14:
  %46 = phi i64 [%30, %$-1] ; # A
  %47 = phi i64 [%41, %$-1] ; # B
  %48 = phi i64 [%34, %$-1] ; # N
; # (let R (save (setq B (consNum B N))) (loop (? (cnt? N) (setq N (a...
; # (consNum B N)
  %49 = call i64 @consNum(i64 %47, i64 %48)
; # (save (setq B (consNum B N)))
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = alloca i64, i64 2, align 16
  %53 = ptrtoint i64* %52 to i64
  %54 = inttoptr i64 %53 to i64*
  store i64 %49, i64* %54
  %55 = add i64 %53, 8
  %56 = inttoptr i64 %55 to i64*
  store i64 %51, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %57
; # (loop (? (cnt? N) (setq N (add N (hex "10"))) (set (big B) (ifn @...
  br label %$16
$16:
  %58 = phi i64 [%46, %$14], [%104, %$23] ; # A
  %59 = phi i64 [%49, %$14], [%109, %$23] ; # B
  %60 = phi i64 [%48, %$14], [%106, %$23] ; # N
; # (? (cnt? N) (setq N (add N (hex "10"))) (set (big B) (ifn @@ N (b...
; # (cnt? N)
  %61 = and i64 %60, 2
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$17
$19:
  %63 = phi i64 [%58, %$16] ; # A
  %64 = phi i64 [%59, %$16] ; # B
  %65 = phi i64 [%60, %$16] ; # N
; # (add N (hex "10"))
  %66 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %65, i64 16)
  %67 = extractvalue {i64, i1} %66, 1
  %68 = extractvalue {i64, i1} %66, 0
; # (set (big B) (ifn @@ N (boxNum (| (int N) (hex "1000000000000000"...
; # (big B)
  %69 = add i64 %64, 4
; # (ifn @@ N (boxNum (| (int N) (hex "1000000000000000"))))
  br i1 %67, label %$21, label %$20
$20:
  %70 = phi i64 [%63, %$19] ; # A
  %71 = phi i64 [%64, %$19] ; # B
  %72 = phi i64 [%68, %$19] ; # N
  br label %$22
$21:
  %73 = phi i64 [%63, %$19] ; # A
  %74 = phi i64 [%64, %$19] ; # B
  %75 = phi i64 [%68, %$19] ; # N
; # (int N)
  %76 = lshr i64 %75, 4
; # (| (int N) (hex "1000000000000000"))
  %77 = or i64 %76, 1152921504606846976
; # (boxNum (| (int N) (hex "1000000000000000")))
  %78 = call i64 @boxNum(i64 %77)
  br label %$22
$22:
  %79 = phi i64 [%70, %$20], [%73, %$21] ; # A
  %80 = phi i64 [%71, %$20], [%74, %$21] ; # B
  %81 = phi i64 [%72, %$20], [%75, %$21] ; # N
  %82 = phi i64 [%72, %$20], [%78, %$21] ; # ->
  %83 = inttoptr i64 %69 to i64*
  store i64 %82, i64* %83
  br label %$18
$17:
  %84 = phi i64 [%58, %$16] ; # A
  %85 = phi i64 [%59, %$16] ; # B
  %86 = phi i64 [%60, %$16] ; # N
; # (let D (val (dig N)) (setq N (val (big N)) D (add D 1)) (? (not @...
; # (dig N)
  %87 = add i64 %86, -4
; # (val (dig N))
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (big N)
  %90 = add i64 %86, 4
; # (val (big N))
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (add D 1)
  %93 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %89, i64 1)
  %94 = extractvalue {i64, i1} %93, 1
  %95 = extractvalue {i64, i1} %93, 0
; # (? (not @@) (set (big B) (consNum D N)))
; # (not @@)
  %96 = icmp eq i1 %94, 0
  br i1 %96, label %$24, label %$23
$24:
  %97 = phi i64 [%84, %$17] ; # A
  %98 = phi i64 [%85, %$17] ; # B
  %99 = phi i64 [%92, %$17] ; # N
  %100 = phi i64 [%95, %$17] ; # D
; # (set (big B) (consNum D N))
; # (big B)
  %101 = add i64 %98, 4
; # (consNum D N)
  %102 = call i64 @consNum(i64 %100, i64 %99)
  %103 = inttoptr i64 %101 to i64*
  store i64 %102, i64* %103
  br label %$18
$23:
  %104 = phi i64 [%84, %$17] ; # A
  %105 = phi i64 [%85, %$17] ; # B
  %106 = phi i64 [%92, %$17] ; # N
  %107 = phi i64 [%95, %$17] ; # D
; # (set (big B) (consNum D N))
; # (big B)
  %108 = add i64 %105, 4
; # (consNum D N)
  %109 = call i64 @consNum(i64 %107, i64 %106)
  %110 = inttoptr i64 %108 to i64*
  store i64 %109, i64* %110
  br label %$16
$18:
  %111 = phi i64 [%79, %$22], [%97, %$24] ; # A
  %112 = phi i64 [%80, %$22], [%98, %$24] ; # B
  %113 = phi i64 [%81, %$22], [%99, %$24] ; # N
  %114 = phi i64 [%82, %$22], [%102, %$24] ; # ->
; # (drop *Safe)
  %115 = inttoptr i64 %53 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  %117 = load i64, i64* %116
  %118 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %117, i64* %118
  br label %$15
$15:
  %119 = phi i64 [%42, %$13], [%111, %$18] ; # A
  %120 = phi i64 [%43, %$13], [%112, %$18] ; # B
  %121 = phi i64 [%44, %$13], [%113, %$18] ; # N
  %122 = phi i64 [%45, %$13], [%49, %$18] ; # ->
  br label %$2
$11:
  %123 = phi i64 [%24, %$3] ; # A
  %124 = phi i64 [%25, %$3] ; # B
; # (let (N (add (val (dig A)) (val (dig B))) C @@ P (boxNum N) R (sa...
; # (dig A)
  %125 = add i64 %123, -4
; # (val (dig A))
  %126 = inttoptr i64 %125 to i64*
  %127 = load i64, i64* %126
; # (dig B)
  %128 = add i64 %124, -4
; # (val (dig B))
  %129 = inttoptr i64 %128 to i64*
  %130 = load i64, i64* %129
; # (add (val (dig A)) (val (dig B)))
  %131 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %127, i64 %130)
  %132 = extractvalue {i64, i1} %131, 1
  %133 = extractvalue {i64, i1} %131, 0
; # (boxNum N)
  %134 = call i64 @boxNum(i64 %133)
; # (save P)
  %135 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %136 = load i64, i64* %135
  %137 = alloca i64, i64 2, align 16
  %138 = ptrtoint i64* %137 to i64
  %139 = inttoptr i64 %138 to i64*
  store i64 %134, i64* %139
  %140 = add i64 %138, 8
  %141 = inttoptr i64 %140 to i64*
  store i64 %136, i64* %141
  %142 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %138, i64* %142
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (if (cnt...
  br label %$25
$25:
  %143 = phi i64 [%123, %$11], [%278, %$35] ; # A
  %144 = phi i64 [%124, %$11], [%279, %$35] ; # B
  %145 = phi i64 [%133, %$11], [%296, %$35] ; # N
  %146 = phi i1 [%132, %$11], [%295, %$35] ; # C
  %147 = phi i64 [%134, %$11], [%298, %$35] ; # P
; # (big A)
  %148 = add i64 %143, 4
; # (val (big A))
  %149 = inttoptr i64 %148 to i64*
  %150 = load i64, i64* %149
; # (big B)
  %151 = add i64 %144, 4
; # (val (big B))
  %152 = inttoptr i64 %151 to i64*
  %153 = load i64, i64* %152
; # (? (cnt? A) (if (cnt? B) (set (big P) (box64 (add (int A) (int B)...
; # (cnt? A)
  %154 = and i64 %150, 2
  %155 = icmp ne i64 %154, 0
  br i1 %155, label %$28, label %$26
$28:
  %156 = phi i64 [%150, %$25] ; # A
  %157 = phi i64 [%153, %$25] ; # B
  %158 = phi i64 [%145, %$25] ; # N
  %159 = phi i1 [%146, %$25] ; # C
  %160 = phi i64 [%147, %$25] ; # P
; # (if (cnt? B) (set (big P) (box64 (add (int A) (int B) C))) (xchg ...
; # (cnt? B)
  %161 = and i64 %157, 2
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$29, label %$30
$29:
  %163 = phi i64 [%156, %$28] ; # A
  %164 = phi i64 [%157, %$28] ; # B
  %165 = phi i64 [%158, %$28] ; # N
  %166 = phi i1 [%159, %$28] ; # C
  %167 = phi i64 [%160, %$28] ; # P
; # (set (big P) (box64 (add (int A) (int B) C)))
; # (big P)
  %168 = add i64 %167, 4
; # (int A)
  %169 = lshr i64 %163, 4
; # (int B)
  %170 = lshr i64 %164, 4
; # (add (int A) (int B) C)
  %171 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %169, i64 %170)
  %172 = extractvalue {i64, i1} %171, 1
  %173 = extractvalue {i64, i1} %171, 0
  %174 = zext i1 %166 to i64
  %175 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %173, i64 %174)
  %176 = extractvalue {i64, i1} %175, 1
  %177 = or i1 %172, %176
  %178 = extractvalue {i64, i1} %175, 0
; # (box64 (add (int A) (int B) C))
  %179 = and i64 %178, 17293822569102704640
  %180 = icmp ne i64 %179, 0
  br i1 %180, label %$32, label %$33
$32:
  %181 = call i64 @boxNum(i64 %178)
  br label %$34
$33:
  %182 = shl i64 %178, 4
  %183 = or i64 %182, 2
  br label %$34
$34:
  %184 = phi i64 [%181, %$32], [%183, %$33] ; # ->
  %185 = inttoptr i64 %168 to i64*
  store i64 %184, i64* %185
  br label %$31
$30:
  %186 = phi i64 [%156, %$28] ; # A
  %187 = phi i64 [%157, %$28] ; # B
  %188 = phi i64 [%158, %$28] ; # N
  %189 = phi i1 [%159, %$28] ; # C
  %190 = phi i64 [%160, %$28] ; # P
; # (xchg 'A 'B)
; # (goto 2)
  br label %$-2
$31:
  %191 = phi i64 [%163, %$34] ; # A
  %192 = phi i64 [%164, %$34] ; # B
  %193 = phi i64 [%165, %$34] ; # N
  %194 = phi i1 [%166, %$34] ; # C
  %195 = phi i64 [%167, %$34] ; # P
  %196 = phi i64 [%184, %$34] ; # ->
  br label %$27
$26:
  %197 = phi i64 [%150, %$25] ; # A
  %198 = phi i64 [%153, %$25] ; # B
  %199 = phi i64 [%145, %$25] ; # N
  %200 = phi i1 [%146, %$25] ; # C
  %201 = phi i64 [%147, %$25] ; # P
; # (? (cnt? B) (: 2 (setq N (add (int B) (val (dig A)) C) C @@) (loo...
; # (cnt? B)
  %202 = and i64 %198, 2
  %203 = icmp ne i64 %202, 0
  br i1 %203, label %$36, label %$35
$36:
  %204 = phi i64 [%197, %$26] ; # A
  %205 = phi i64 [%198, %$26] ; # B
  %206 = phi i64 [%199, %$26] ; # N
  %207 = phi i1 [%200, %$26] ; # C
  %208 = phi i64 [%201, %$26] ; # P
; # (: 2 (setq N (add (int B) (val (dig A)) C) C @@) (loop (setq P (s...
  br label %$-2
$-2:
  %209 = phi i64 [%187, %$30], [%204, %$36] ; # A
  %210 = phi i64 [%186, %$30], [%205, %$36] ; # B
  %211 = phi i64 [%188, %$30], [%206, %$36] ; # N
  %212 = phi i1 [%189, %$30], [%207, %$36] ; # C
  %213 = phi i64 [%190, %$30], [%208, %$36] ; # P
; # (int B)
  %214 = lshr i64 %210, 4
; # (dig A)
  %215 = add i64 %209, -4
; # (val (dig A))
  %216 = inttoptr i64 %215 to i64*
  %217 = load i64, i64* %216
; # (add (int B) (val (dig A)) C)
  %218 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %214, i64 %217)
  %219 = extractvalue {i64, i1} %218, 1
  %220 = extractvalue {i64, i1} %218, 0
  %221 = zext i1 %212 to i64
  %222 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %220, i64 %221)
  %223 = extractvalue {i64, i1} %222, 1
  %224 = or i1 %219, %223
  %225 = extractvalue {i64, i1} %222, 0
; # (loop (setq P (set (big P) (consNum N (setq A (val (big A)))))) (...
  br label %$37
$37:
  %226 = phi i64 [%209, %$-2], [%261, %$40] ; # A
  %227 = phi i64 [%210, %$-2], [%262, %$40] ; # B
  %228 = phi i64 [%225, %$-2], [%271, %$40] ; # N
  %229 = phi i1 [%224, %$-2], [%270, %$40] ; # C
  %230 = phi i64 [%213, %$-2], [%265, %$40] ; # P
; # (set (big P) (consNum N (setq A (val (big A)))))
; # (big P)
  %231 = add i64 %230, 4
; # (big A)
  %232 = add i64 %226, 4
; # (val (big A))
  %233 = inttoptr i64 %232 to i64*
  %234 = load i64, i64* %233
; # (consNum N (setq A (val (big A))))
  %235 = call i64 @consNum(i64 %228, i64 %234)
  %236 = inttoptr i64 %231 to i64*
  store i64 %235, i64* %236
; # (? (not C))
; # (not C)
  %237 = icmp eq i1 %229, 0
  br i1 %237, label %$39, label %$38
$38:
  %238 = phi i64 [%234, %$37] ; # A
  %239 = phi i64 [%227, %$37] ; # B
  %240 = phi i64 [%228, %$37] ; # N
  %241 = phi i1 [%229, %$37] ; # C
  %242 = phi i64 [%235, %$37] ; # P
; # (? (cnt? A) (set (big P) (box64 (+ (int A) C))))
; # (cnt? A)
  %243 = and i64 %238, 2
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$41, label %$40
$41:
  %245 = phi i64 [%238, %$38] ; # A
  %246 = phi i64 [%239, %$38] ; # B
  %247 = phi i64 [%240, %$38] ; # N
  %248 = phi i1 [%241, %$38] ; # C
  %249 = phi i64 [%242, %$38] ; # P
; # (set (big P) (box64 (+ (int A) C)))
; # (big P)
  %250 = add i64 %249, 4
; # (int A)
  %251 = lshr i64 %245, 4
; # (+ (int A) C)
  %252 = zext i1 %248 to i64
  %253 = add i64 %251, %252
; # (box64 (+ (int A) C))
  %254 = and i64 %253, 17293822569102704640
  %255 = icmp ne i64 %254, 0
  br i1 %255, label %$42, label %$43
$42:
  %256 = call i64 @boxNum(i64 %253)
  br label %$44
$43:
  %257 = shl i64 %253, 4
  %258 = or i64 %257, 2
  br label %$44
$44:
  %259 = phi i64 [%256, %$42], [%258, %$43] ; # ->
  %260 = inttoptr i64 %250 to i64*
  store i64 %259, i64* %260
  br label %$39
$40:
  %261 = phi i64 [%238, %$38] ; # A
  %262 = phi i64 [%239, %$38] ; # B
  %263 = phi i64 [%240, %$38] ; # N
  %264 = phi i1 [%241, %$38] ; # C
  %265 = phi i64 [%242, %$38] ; # P
; # (dig A)
  %266 = add i64 %261, -4
; # (val (dig A))
  %267 = inttoptr i64 %266 to i64*
  %268 = load i64, i64* %267
; # (add (val (dig A)) 1)
  %269 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %268, i64 1)
  %270 = extractvalue {i64, i1} %269, 1
  %271 = extractvalue {i64, i1} %269, 0
  br label %$37
$39:
  %272 = phi i64 [%234, %$37], [%245, %$44] ; # A
  %273 = phi i64 [%227, %$37], [%246, %$44] ; # B
  %274 = phi i64 [%228, %$37], [%247, %$44] ; # N
  %275 = phi i1 [%229, %$37], [%248, %$44] ; # C
  %276 = phi i64 [%235, %$37], [%249, %$44] ; # P
  %277 = phi i64 [0, %$37], [%259, %$44] ; # ->
  br label %$27
$35:
  %278 = phi i64 [%197, %$26] ; # A
  %279 = phi i64 [%198, %$26] ; # B
  %280 = phi i64 [%199, %$26] ; # N
  %281 = phi i1 [%200, %$26] ; # C
  %282 = phi i64 [%201, %$26] ; # P
; # (dig A)
  %283 = add i64 %278, -4
; # (val (dig A))
  %284 = inttoptr i64 %283 to i64*
  %285 = load i64, i64* %284
; # (dig B)
  %286 = add i64 %279, -4
; # (val (dig B))
  %287 = inttoptr i64 %286 to i64*
  %288 = load i64, i64* %287
; # (add (val (dig A)) (val (dig B)) C)
  %289 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %285, i64 %288)
  %290 = extractvalue {i64, i1} %289, 1
  %291 = extractvalue {i64, i1} %289, 0
  %292 = zext i1 %281 to i64
  %293 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %291, i64 %292)
  %294 = extractvalue {i64, i1} %293, 1
  %295 = or i1 %290, %294
  %296 = extractvalue {i64, i1} %293, 0
; # (set (big P) (boxNum N))
; # (big P)
  %297 = add i64 %282, 4
; # (boxNum N)
  %298 = call i64 @boxNum(i64 %296)
  %299 = inttoptr i64 %297 to i64*
  store i64 %298, i64* %299
  br label %$25
$27:
  %300 = phi i64 [%191, %$31], [%272, %$39] ; # A
  %301 = phi i64 [%192, %$31], [%273, %$39] ; # B
  %302 = phi i64 [%193, %$31], [%274, %$39] ; # N
  %303 = phi i1 [%194, %$31], [%275, %$39] ; # C
  %304 = phi i64 [%195, %$31], [%276, %$39] ; # P
  %305 = phi i64 [%196, %$31], [%277, %$39] ; # ->
; # (drop *Safe)
  %306 = inttoptr i64 %138 to i64*
  %307 = getelementptr i64, i64* %306, i32 1
  %308 = load i64, i64* %307
  %309 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %308, i64* %309
  br label %$2
$2:
  %310 = phi i64 [%21, %$7], [%119, %$15], [%300, %$27] ; # A
  %311 = phi i64 [%22, %$7], [%120, %$15], [%301, %$27] ; # B
  %312 = phi i64 [%23, %$7], [%122, %$15], [%134, %$27] ; # ->
  ret i64 %312
}

define i64 @sub1(i64, i64) align 8 {
$1:
; # (dig B)
  %2 = add i64 %0, -4
; # (val (dig B))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (int N)
  %5 = lshr i64 %1, 4
; # (sub (val (dig B)) (int N))
  %6 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %4, i64 %5)
  %7 = extractvalue {i64, i1} %6, 1
  %8 = extractvalue {i64, i1} %6, 0
; # (big B)
  %9 = add i64 %0, 4
; # (val (big B))
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
; # (nond (@@ (if (== B ZERO) (box64 N) (consNum N B))) ((big? B) (se...
  br i1 %7, label %$3, label %$4
$4:
  %12 = phi i64 [%11, %$1] ; # B
  %13 = phi i64 [%8, %$1] ; # N
; # (if (== B ZERO) (box64 N) (consNum N B))
; # (== B ZERO)
  %14 = icmp eq i64 %12, 2
  br i1 %14, label %$5, label %$6
$5:
  %15 = phi i64 [%12, %$4] ; # B
  %16 = phi i64 [%13, %$4] ; # N
; # (box64 N)
  %17 = and i64 %16, 17293822569102704640
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$8, label %$9
$8:
  %19 = call i64 @boxNum(i64 %16)
  br label %$10
$9:
  %20 = shl i64 %16, 4
  %21 = or i64 %20, 2
  br label %$10
$10:
  %22 = phi i64 [%19, %$8], [%21, %$9] ; # ->
  br label %$7
$6:
  %23 = phi i64 [%12, %$4] ; # B
  %24 = phi i64 [%13, %$4] ; # N
; # (consNum N B)
  %25 = call i64 @consNum(i64 %24, i64 %23)
  br label %$7
$7:
  %26 = phi i64 [%15, %$10], [%23, %$6] ; # B
  %27 = phi i64 [%16, %$10], [%24, %$6] ; # N
  %28 = phi i64 [%22, %$10], [%25, %$6] ; # ->
  br label %$2
$3:
  %29 = phi i64 [%11, %$1] ; # B
  %30 = phi i64 [%8, %$1] ; # N
; # (big? B)
  %31 = and i64 %29, 4
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$12
$12:
  %33 = phi i64 [%29, %$3] ; # B
  %34 = phi i64 [%30, %$3] ; # N
; # (sub B (hex "10"))
  %35 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %33, i64 16)
  %36 = extractvalue {i64, i1} %35, 1
  %37 = extractvalue {i64, i1} %35, 0
; # (if @@ (sign (cnt (- N))) (zapZero (consNum N B)))
  br i1 %36, label %$13, label %$14
$13:
  %38 = phi i64 [%37, %$12] ; # B
  %39 = phi i64 [%34, %$12] ; # N
; # (- N)
  %40 = sub i64 0, %39
; # (cnt (- N))
  %41 = shl i64 %40, 4
  %42 = or i64 %41, 2
; # (sign (cnt (- N)))
  %43 = or i64 %42, 8
  br label %$15
$14:
  %44 = phi i64 [%37, %$12] ; # B
  %45 = phi i64 [%34, %$12] ; # N
; # (consNum N B)
  %46 = call i64 @consNum(i64 %45, i64 %44)
; # (zapZero (consNum N B))
  %47 = call i64 @zapZero(i64 %46)
  br label %$15
$15:
  %48 = phi i64 [%38, %$13], [%44, %$14] ; # B
  %49 = phi i64 [%39, %$13], [%45, %$14] ; # N
  %50 = phi i64 [%43, %$13], [%47, %$14] ; # ->
  br label %$2
$11:
  %51 = phi i64 [%29, %$3] ; # B
  %52 = phi i64 [%30, %$3] ; # N
; # (let (P (boxNum N B) R (save P)) (loop (setq N (sub (val (dig B))...
; # (boxNum N B)
  %53 = call i64 @boxNum(i64 %52)
; # (save P)
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %53, i64* %58
  %59 = add i64 %57, 8
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %61
; # (loop (setq N (sub (val (dig B)) 1) B (val (big B))) (? (not @@) ...
  br label %$16
$16:
  %62 = phi i64 [%51, %$11], [%97, %$20] ; # B
  %63 = phi i64 [%52, %$11], [%98, %$20] ; # N
  %64 = phi i64 [%53, %$11], [%99, %$20] ; # P
; # (dig B)
  %65 = add i64 %62, -4
; # (val (dig B))
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
; # (sub (val (dig B)) 1)
  %68 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %67, i64 1)
  %69 = extractvalue {i64, i1} %68, 1
  %70 = extractvalue {i64, i1} %68, 0
; # (big B)
  %71 = add i64 %62, 4
; # (val (big B))
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
; # (? (not @@) (set (big P) (consNum N B)))
; # (not @@)
  %74 = icmp eq i1 %69, 0
  br i1 %74, label %$19, label %$17
$19:
  %75 = phi i64 [%73, %$16] ; # B
  %76 = phi i64 [%70, %$16] ; # N
  %77 = phi i64 [%64, %$16] ; # P
; # (set (big P) (consNum N B))
; # (big P)
  %78 = add i64 %77, 4
; # (consNum N B)
  %79 = call i64 @consNum(i64 %76, i64 %75)
  %80 = inttoptr i64 %78 to i64*
  store i64 %79, i64* %80
  br label %$18
$17:
  %81 = phi i64 [%73, %$16] ; # B
  %82 = phi i64 [%70, %$16] ; # N
  %83 = phi i64 [%64, %$16] ; # P
; # (set (big P) (consNum N B))
; # (big P)
  %84 = add i64 %83, 4
; # (consNum N B)
  %85 = call i64 @consNum(i64 %82, i64 %81)
  %86 = inttoptr i64 %84 to i64*
  store i64 %85, i64* %86
; # (? (cnt? B) (set (big P) (sub B (hex "10"))))
; # (cnt? B)
  %87 = and i64 %81, 2
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$21, label %$20
$21:
  %89 = phi i64 [%81, %$17] ; # B
  %90 = phi i64 [%82, %$17] ; # N
  %91 = phi i64 [%85, %$17] ; # P
; # (set (big P) (sub B (hex "10")))
; # (big P)
  %92 = add i64 %91, 4
; # (sub B (hex "10"))
  %93 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %89, i64 16)
  %94 = extractvalue {i64, i1} %93, 1
  %95 = extractvalue {i64, i1} %93, 0
  %96 = inttoptr i64 %92 to i64*
  store i64 %95, i64* %96
  br label %$18
$20:
  %97 = phi i64 [%81, %$17] ; # B
  %98 = phi i64 [%82, %$17] ; # N
  %99 = phi i64 [%85, %$17] ; # P
  br label %$16
$18:
  %100 = phi i64 [%75, %$19], [%89, %$21] ; # B
  %101 = phi i64 [%76, %$19], [%90, %$21] ; # N
  %102 = phi i64 [%77, %$19], [%91, %$21] ; # P
  %103 = phi i64 [%79, %$19], [%95, %$21] ; # ->
; # (zapZero R)
  %104 = call i64 @zapZero(i64 %53)
; # (drop *Safe)
  %105 = inttoptr i64 %57 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %108
  br label %$2
$2:
  %109 = phi i64 [%26, %$7], [%48, %$15], [%100, %$18] ; # B
  %110 = phi i64 [%27, %$7], [%49, %$15], [%101, %$18] ; # N
  %111 = phi i64 [%28, %$7], [%50, %$15], [%104, %$18] ; # ->
  ret i64 %111
}

define i64 @subu(i64, i64) align 8 {
$1:
; # (cond ((cnt? A) (if (cnt? B) (let N (sub A (& B -3)) (if @@ (+ (x...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (let N (sub A (& B -3)) (if @@ (+ (x| N -16) (hex "1...
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (let N (sub A (& B -3)) (if @@ (+ (x| N -16) (hex "18")) N))
; # (& B -3)
  %10 = and i64 %9, -3
; # (sub A (& B -3))
  %11 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %8, i64 %10)
  %12 = extractvalue {i64, i1} %11, 1
  %13 = extractvalue {i64, i1} %11, 0
; # (if @@ (+ (x| N -16) (hex "18")) N)
  br i1 %12, label %$8, label %$9
$8:
  %14 = phi i64 [%8, %$5] ; # A
  %15 = phi i64 [%9, %$5] ; # B
; # (x| N -16)
  %16 = xor i64 %13, -16
; # (+ (x| N -16) (hex "18"))
  %17 = add i64 %16, 24
  br label %$10
$9:
  %18 = phi i64 [%8, %$5] ; # A
  %19 = phi i64 [%9, %$5] ; # B
  br label %$10
$10:
  %20 = phi i64 [%14, %$8], [%18, %$9] ; # A
  %21 = phi i64 [%15, %$8], [%19, %$9] ; # B
  %22 = phi i64 [%17, %$8], [%13, %$9] ; # ->
  br label %$7
$6:
  %23 = phi i64 [%4, %$4] ; # A
  %24 = phi i64 [%5, %$4] ; # B
; # (sub1 B A)
  %25 = call i64 @sub1(i64 %24, i64 %23)
; # (neg (sub1 B A))
  %26 = icmp eq i64 %25, 2
  br i1 %26, label %$11, label %$12
$11:
  br label %$13
$12:
  %27 = xor i64 %25, 8
  br label %$13
$13:
  %28 = phi i64 [%25, %$11], [%27, %$12] ; # ->
  br label %$7
$7:
  %29 = phi i64 [%20, %$10], [%23, %$13] ; # A
  %30 = phi i64 [%21, %$10], [%24, %$13] ; # B
  %31 = phi i64 [%22, %$10], [%28, %$13] ; # ->
  br label %$2
$3:
  %32 = phi i64 [%0, %$1] ; # A
  %33 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %34 = and i64 %33, 2
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = phi i64 [%32, %$3] ; # A
  %37 = phi i64 [%33, %$3] ; # B
; # (sub1 A B)
  %38 = call i64 @sub1(i64 %36, i64 %37)
  br label %$2
$14:
  %39 = phi i64 [%32, %$3] ; # A
  %40 = phi i64 [%33, %$3] ; # B
; # (let (N (sub (val (dig A)) (val (dig B))) C @@ P (boxNum N) R (sa...
; # (dig A)
  %41 = add i64 %39, -4
; # (val (dig A))
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
; # (dig B)
  %44 = add i64 %40, -4
; # (val (dig B))
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (sub (val (dig A)) (val (dig B)))
  %47 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %43, i64 %46)
  %48 = extractvalue {i64, i1} %47, 1
  %49 = extractvalue {i64, i1} %47, 0
; # (boxNum N)
  %50 = call i64 @boxNum(i64 %49)
; # (save P)
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %52 = load i64, i64* %51
  %53 = alloca i64, i64 2, align 16
  %54 = ptrtoint i64* %53 to i64
  %55 = inttoptr i64 %54 to i64*
  store i64 %50, i64* %55
  %56 = add i64 %54, 8
  %57 = inttoptr i64 %56 to i64*
  store i64 %52, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %58
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? B) (setq B ...
  br label %$16
$16:
  %59 = phi i64 [%39, %$14], [%177, %$25] ; # A
  %60 = phi i64 [%40, %$14], [%178, %$25] ; # B
  %61 = phi i64 [%49, %$14], [%195, %$25] ; # N
  %62 = phi i1 [%48, %$14], [%194, %$25] ; # C
  %63 = phi i64 [%50, %$14], [%197, %$25] ; # P
; # (big A)
  %64 = add i64 %59, 4
; # (val (big A))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (big B)
  %67 = add i64 %60, 4
; # (val (big B))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (? (cnt? B) (setq B (int B)) (until (cnt? A) (setq N (sub (val (d...
; # (cnt? B)
  %70 = and i64 %69, 2
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$19, label %$17
$19:
  %72 = phi i64 [%66, %$16] ; # A
  %73 = phi i64 [%69, %$16] ; # B
  %74 = phi i64 [%61, %$16] ; # N
  %75 = phi i1 [%62, %$16] ; # C
  %76 = phi i64 [%63, %$16] ; # P
; # (int B)
  %77 = lshr i64 %73, 4
; # (until (cnt? A) (setq N (sub (val (dig A)) B C) C @@ A (val (big ...
  br label %$20
$20:
  %78 = phi i64 [%72, %$19], [%117, %$24] ; # A
  %79 = phi i64 [%77, %$19], [0, %$24] ; # B
  %80 = phi i64 [%74, %$19], [%119, %$24] ; # N
  %81 = phi i1 [%75, %$19], [%120, %$24] ; # C
  %82 = phi i64 [%76, %$19], [%121, %$24] ; # P
; # (cnt? A)
  %83 = and i64 %78, 2
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$22, label %$21
$21:
  %85 = phi i64 [%78, %$20] ; # A
  %86 = phi i64 [%79, %$20] ; # B
  %87 = phi i64 [%80, %$20] ; # N
  %88 = phi i1 [%81, %$20] ; # C
  %89 = phi i64 [%82, %$20] ; # P
; # (dig A)
  %90 = add i64 %85, -4
; # (val (dig A))
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (sub (val (dig A)) B C)
  %93 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %92, i64 %86)
  %94 = extractvalue {i64, i1} %93, 1
  %95 = extractvalue {i64, i1} %93, 0
  %96 = zext i1 %88 to i64
  %97 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %95, i64 %96)
  %98 = extractvalue {i64, i1} %97, 1
  %99 = or i1 %94, %98
  %100 = extractvalue {i64, i1} %97, 0
; # (big A)
  %101 = add i64 %85, 4
; # (val (big A))
  %102 = inttoptr i64 %101 to i64*
  %103 = load i64, i64* %102
; # (set (big P) (consNum N A))
; # (big P)
  %104 = add i64 %89, 4
; # (consNum N A)
  %105 = call i64 @consNum(i64 %100, i64 %103)
  %106 = inttoptr i64 %104 to i64*
  store i64 %105, i64* %106
; # (unless C (ret (zapZero R)))
  br i1 %99, label %$24, label %$23
$23:
  %107 = phi i64 [%103, %$21] ; # A
  %108 = phi i64 [%86, %$21] ; # B
  %109 = phi i64 [%100, %$21] ; # N
  %110 = phi i1 [%99, %$21] ; # C
  %111 = phi i64 [%105, %$21] ; # P
; # (zapZero R)
  %112 = call i64 @zapZero(i64 %50)
; # (ret (zapZero R))
; # (drop *Safe)
  %113 = inttoptr i64 %54 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  %115 = load i64, i64* %114
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %115, i64* %116
  ret i64 %112
$24:
  %117 = phi i64 [%103, %$21] ; # A
  %118 = phi i64 [%86, %$21] ; # B
  %119 = phi i64 [%100, %$21] ; # N
  %120 = phi i1 [%99, %$21] ; # C
  %121 = phi i64 [%105, %$21] ; # P
  br label %$20
$22:
  %122 = phi i64 [%78, %$20] ; # A
  %123 = phi i64 [%79, %$20] ; # B
  %124 = phi i64 [%80, %$20] ; # N
  %125 = phi i1 [%81, %$20] ; # C
  %126 = phi i64 [%82, %$20] ; # P
; # (int A)
  %127 = lshr i64 %122, 4
  br label %$18
$17:
  %128 = phi i64 [%66, %$16] ; # A
  %129 = phi i64 [%69, %$16] ; # B
  %130 = phi i64 [%61, %$16] ; # N
  %131 = phi i1 [%62, %$16] ; # C
  %132 = phi i64 [%63, %$16] ; # P
; # (? (cnt? A) (setq A (int A)) (loop (setq N (sub A (val (dig B)) C...
; # (cnt? A)
  %133 = and i64 %128, 2
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$26, label %$25
$26:
  %135 = phi i64 [%128, %$17] ; # A
  %136 = phi i64 [%129, %$17] ; # B
  %137 = phi i64 [%130, %$17] ; # N
  %138 = phi i1 [%131, %$17] ; # C
  %139 = phi i64 [%132, %$17] ; # P
; # (int A)
  %140 = lshr i64 %135, 4
; # (loop (setq N (sub A (val (dig B)) C) C @@ P (set (big P) (boxNum...
  br label %$27
$27:
  %141 = phi i64 [%140, %$26], [%165, %$28] ; # A
  %142 = phi i64 [%136, %$26], [%166, %$28] ; # B
  %143 = phi i64 [%137, %$26], [%167, %$28] ; # N
  %144 = phi i1 [%138, %$26], [%168, %$28] ; # C
  %145 = phi i64 [%139, %$26], [%169, %$28] ; # P
; # (dig B)
  %146 = add i64 %142, -4
; # (val (dig B))
  %147 = inttoptr i64 %146 to i64*
  %148 = load i64, i64* %147
; # (sub A (val (dig B)) C)
  %149 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %141, i64 %148)
  %150 = extractvalue {i64, i1} %149, 1
  %151 = extractvalue {i64, i1} %149, 0
  %152 = zext i1 %144 to i64
  %153 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %151, i64 %152)
  %154 = extractvalue {i64, i1} %153, 1
  %155 = or i1 %150, %154
  %156 = extractvalue {i64, i1} %153, 0
; # (set (big P) (boxNum N))
; # (big P)
  %157 = add i64 %145, 4
; # (boxNum N)
  %158 = call i64 @boxNum(i64 %156)
  %159 = inttoptr i64 %157 to i64*
  store i64 %158, i64* %159
; # (? (cnt? (setq B (val (big B)))))
; # (big B)
  %160 = add i64 %142, 4
; # (val (big B))
  %161 = inttoptr i64 %160 to i64*
  %162 = load i64, i64* %161
; # (cnt? (setq B (val (big B))))
  %163 = and i64 %162, 2
  %164 = icmp ne i64 %163, 0
  br i1 %164, label %$29, label %$28
$28:
  %165 = phi i64 [0, %$27] ; # A
  %166 = phi i64 [%162, %$27] ; # B
  %167 = phi i64 [%156, %$27] ; # N
  %168 = phi i1 [%155, %$27] ; # C
  %169 = phi i64 [%158, %$27] ; # P
  br label %$27
$29:
  %170 = phi i64 [0, %$27] ; # A
  %171 = phi i64 [%162, %$27] ; # B
  %172 = phi i64 [%156, %$27] ; # N
  %173 = phi i1 [%155, %$27] ; # C
  %174 = phi i64 [%158, %$27] ; # P
  %175 = phi i64 [0, %$27] ; # ->
; # (int B)
  %176 = lshr i64 %171, 4
  br label %$18
$25:
  %177 = phi i64 [%128, %$17] ; # A
  %178 = phi i64 [%129, %$17] ; # B
  %179 = phi i64 [%130, %$17] ; # N
  %180 = phi i1 [%131, %$17] ; # C
  %181 = phi i64 [%132, %$17] ; # P
; # (dig A)
  %182 = add i64 %177, -4
; # (val (dig A))
  %183 = inttoptr i64 %182 to i64*
  %184 = load i64, i64* %183
; # (dig B)
  %185 = add i64 %178, -4
; # (val (dig B))
  %186 = inttoptr i64 %185 to i64*
  %187 = load i64, i64* %186
; # (sub (val (dig A)) (val (dig B)) C)
  %188 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %184, i64 %187)
  %189 = extractvalue {i64, i1} %188, 1
  %190 = extractvalue {i64, i1} %188, 0
  %191 = zext i1 %180 to i64
  %192 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %190, i64 %191)
  %193 = extractvalue {i64, i1} %192, 1
  %194 = or i1 %189, %193
  %195 = extractvalue {i64, i1} %192, 0
; # (set (big P) (boxNum N))
; # (big P)
  %196 = add i64 %181, 4
; # (boxNum N)
  %197 = call i64 @boxNum(i64 %195)
  %198 = inttoptr i64 %196 to i64*
  store i64 %197, i64* %198
  br label %$16
$18:
  %199 = phi i64 [%127, %$22], [%170, %$29] ; # A
  %200 = phi i64 [%123, %$22], [%176, %$29] ; # B
  %201 = phi i64 [%124, %$22], [%172, %$29] ; # N
  %202 = phi i1 [%125, %$22], [%173, %$29] ; # C
  %203 = phi i64 [%126, %$22], [%174, %$29] ; # P
  %204 = phi i64 [%127, %$22], [%176, %$29] ; # ->
; # (set (big P) (cnt (sub A B C)))
; # (big P)
  %205 = add i64 %203, 4
; # (sub A B C)
  %206 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %199, i64 %200)
  %207 = extractvalue {i64, i1} %206, 1
  %208 = extractvalue {i64, i1} %206, 0
  %209 = zext i1 %202 to i64
  %210 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %208, i64 %209)
  %211 = extractvalue {i64, i1} %210, 1
  %212 = or i1 %207, %211
  %213 = extractvalue {i64, i1} %210, 0
; # (cnt (sub A B C))
  %214 = shl i64 %213, 4
  %215 = or i64 %214, 2
  %216 = inttoptr i64 %205 to i64*
  store i64 %215, i64* %216
; # (ifn @@ (zapZero R) (let Q R (loop (set (dig Q) (x| (val (dig Q))...
  br i1 %212, label %$31, label %$30
$30:
  %217 = phi i64 [%199, %$18] ; # A
  %218 = phi i64 [%200, %$18] ; # B
  %219 = phi i64 [%201, %$18] ; # N
  %220 = phi i1 [%202, %$18] ; # C
  %221 = phi i64 [%203, %$18] ; # P
; # (zapZero R)
  %222 = call i64 @zapZero(i64 %50)
  br label %$32
$31:
  %223 = phi i64 [%199, %$18] ; # A
  %224 = phi i64 [%200, %$18] ; # B
  %225 = phi i64 [%201, %$18] ; # N
  %226 = phi i1 [%202, %$18] ; # C
  %227 = phi i64 [%203, %$18] ; # P
; # (let Q R (loop (set (dig Q) (x| (val (dig Q)) -1)) (? (cnt? (setq...
; # (loop (set (dig Q) (x| (val (dig Q)) -1)) (? (cnt? (setq N (val (...
  br label %$33
$33:
  %228 = phi i64 [%223, %$31], [%245, %$34] ; # A
  %229 = phi i64 [%224, %$31], [%246, %$34] ; # B
  %230 = phi i64 [%225, %$31], [%247, %$34] ; # N
  %231 = phi i1 [%226, %$31], [%248, %$34] ; # C
  %232 = phi i64 [%227, %$31], [%249, %$34] ; # P
  %233 = phi i64 [%50, %$31], [%247, %$34] ; # Q
; # (set (dig Q) (x| (val (dig Q)) -1))
; # (dig Q)
  %234 = add i64 %233, -4
; # (dig Q)
  %235 = add i64 %233, -4
; # (val (dig Q))
  %236 = inttoptr i64 %235 to i64*
  %237 = load i64, i64* %236
; # (x| (val (dig Q)) -1)
  %238 = xor i64 %237, -1
  %239 = inttoptr i64 %234 to i64*
  store i64 %238, i64* %239
; # (? (cnt? (setq N (val (big Q)))))
; # (big Q)
  %240 = add i64 %233, 4
; # (val (big Q))
  %241 = inttoptr i64 %240 to i64*
  %242 = load i64, i64* %241
; # (cnt? (setq N (val (big Q))))
  %243 = and i64 %242, 2
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$35, label %$34
$34:
  %245 = phi i64 [%228, %$33] ; # A
  %246 = phi i64 [%229, %$33] ; # B
  %247 = phi i64 [%242, %$33] ; # N
  %248 = phi i1 [%231, %$33] ; # C
  %249 = phi i64 [%232, %$33] ; # P
  %250 = phi i64 [%233, %$33] ; # Q
  br label %$33
$35:
  %251 = phi i64 [%228, %$33] ; # A
  %252 = phi i64 [%229, %$33] ; # B
  %253 = phi i64 [%242, %$33] ; # N
  %254 = phi i1 [%231, %$33] ; # C
  %255 = phi i64 [%232, %$33] ; # P
  %256 = phi i64 [%233, %$33] ; # Q
  %257 = phi i64 [0, %$33] ; # ->
; # (set (big Q) (x| N -16))
; # (big Q)
  %258 = add i64 %256, 4
; # (x| N -16)
  %259 = xor i64 %253, -16
  %260 = inttoptr i64 %258 to i64*
  store i64 %259, i64* %260
; # (let Q R (loop (set (dig Q) (add (val (dig Q)) 1)) (unless @@ (go...
; # (loop (set (dig Q) (add (val (dig Q)) 1)) (unless @@ (goto 9)) (?...
  br label %$36
$36:
  %261 = phi i64 [%251, %$35], [%292, %$39] ; # A
  %262 = phi i64 [%252, %$35], [%293, %$39] ; # B
  %263 = phi i64 [%253, %$35], [%294, %$39] ; # N
  %264 = phi i1 [%254, %$35], [%295, %$39] ; # C
  %265 = phi i64 [%255, %$35], [%296, %$39] ; # P
  %266 = phi i64 [%50, %$35], [%294, %$39] ; # Q
; # (set (dig Q) (add (val (dig Q)) 1))
; # (dig Q)
  %267 = add i64 %266, -4
; # (dig Q)
  %268 = add i64 %266, -4
; # (val (dig Q))
  %269 = inttoptr i64 %268 to i64*
  %270 = load i64, i64* %269
; # (add (val (dig Q)) 1)
  %271 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %270, i64 1)
  %272 = extractvalue {i64, i1} %271, 1
  %273 = extractvalue {i64, i1} %271, 0
  %274 = inttoptr i64 %267 to i64*
  store i64 %273, i64* %274
; # (unless @@ (goto 9))
  br i1 %272, label %$38, label %$37
$37:
  %275 = phi i64 [%261, %$36] ; # A
  %276 = phi i64 [%262, %$36] ; # B
  %277 = phi i64 [%263, %$36] ; # N
  %278 = phi i1 [%264, %$36] ; # C
  %279 = phi i64 [%265, %$36] ; # P
  %280 = phi i64 [%266, %$36] ; # Q
; # (goto 9)
  br label %$-9
$38:
  %281 = phi i64 [%261, %$36] ; # A
  %282 = phi i64 [%262, %$36] ; # B
  %283 = phi i64 [%263, %$36] ; # N
  %284 = phi i1 [%264, %$36] ; # C
  %285 = phi i64 [%265, %$36] ; # P
  %286 = phi i64 [%266, %$36] ; # Q
; # (? (cnt? (setq N (val (big Q)))))
; # (big Q)
  %287 = add i64 %286, 4
; # (val (big Q))
  %288 = inttoptr i64 %287 to i64*
  %289 = load i64, i64* %288
; # (cnt? (setq N (val (big Q))))
  %290 = and i64 %289, 2
  %291 = icmp ne i64 %290, 0
  br i1 %291, label %$40, label %$39
$39:
  %292 = phi i64 [%281, %$38] ; # A
  %293 = phi i64 [%282, %$38] ; # B
  %294 = phi i64 [%289, %$38] ; # N
  %295 = phi i1 [%284, %$38] ; # C
  %296 = phi i64 [%285, %$38] ; # P
  %297 = phi i64 [%286, %$38] ; # Q
  br label %$36
$40:
  %298 = phi i64 [%281, %$38] ; # A
  %299 = phi i64 [%282, %$38] ; # B
  %300 = phi i64 [%289, %$38] ; # N
  %301 = phi i1 [%284, %$38] ; # C
  %302 = phi i64 [%285, %$38] ; # P
  %303 = phi i64 [%286, %$38] ; # Q
  %304 = phi i64 [0, %$38] ; # ->
; # (set (big Q) (+ N (hex "10")))
; # (big Q)
  %305 = add i64 %303, 4
; # (+ N (hex "10"))
  %306 = add i64 %300, 16
  %307 = inttoptr i64 %305 to i64*
  store i64 %306, i64* %307
; # (: 9 (sign (zapZero R)))
  br label %$-9
$-9:
  %308 = phi i64 [%275, %$37], [%298, %$40] ; # A
  %309 = phi i64 [%276, %$37], [%299, %$40] ; # B
  %310 = phi i64 [%277, %$37], [%300, %$40] ; # N
  %311 = phi i1 [%278, %$37], [%301, %$40] ; # C
  %312 = phi i64 [%279, %$37], [%302, %$40] ; # P
; # (zapZero R)
  %313 = call i64 @zapZero(i64 %50)
; # (sign (zapZero R))
  %314 = or i64 %313, 8
  br label %$32
$32:
  %315 = phi i64 [%217, %$30], [%308, %$-9] ; # A
  %316 = phi i64 [%218, %$30], [%309, %$-9] ; # B
  %317 = phi i64 [%219, %$30], [%310, %$-9] ; # N
  %318 = phi i1 [%220, %$30], [%311, %$-9] ; # C
  %319 = phi i64 [%221, %$30], [%312, %$-9] ; # P
  %320 = phi i64 [%222, %$30], [%314, %$-9] ; # ->
; # (drop *Safe)
  %321 = inttoptr i64 %54 to i64*
  %322 = getelementptr i64, i64* %321, i32 1
  %323 = load i64, i64* %322
  %324 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %323, i64* %324
  br label %$2
$2:
  %325 = phi i64 [%29, %$7], [%36, %$15], [%315, %$32] ; # A
  %326 = phi i64 [%30, %$7], [%37, %$15], [%316, %$32] ; # B
  %327 = phi i64 [%31, %$7], [%38, %$15], [%320, %$32] ; # ->
  ret i64 %327
}

define i64 @mulu(i64, i64) align 8 {
$1:
; # (cond ((== A ZERO) A) ((cnt? A) (setq A (int A)) (if (cnt? B) (le...
; # (== A ZERO)
  %2 = icmp eq i64 %0, 2
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # A
  %4 = phi i64 [%1, %$1] ; # B
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # A
  %6 = phi i64 [%1, %$1] ; # B
; # (cnt? A)
  %7 = and i64 %5, 2
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i64 [%5, %$3] ; # A
  %10 = phi i64 [%6, %$3] ; # B
; # (int A)
  %11 = lshr i64 %9, 4
; # (if (cnt? B) (let N (mul A (int B)) (if (or @@@ (& N (hex "F00000...
; # (cnt? B)
  %12 = and i64 %10, 2
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$7, label %$8
$7:
  %14 = phi i64 [%11, %$6] ; # A
  %15 = phi i64 [%10, %$6] ; # B
; # (let N (mul A (int B)) (if (or @@@ (& N (hex "F000000000000000"))...
; # (int B)
  %16 = lshr i64 %15, 4
; # (mul A (int B))
  %17 = zext i64 %14 to i128
  %18 = zext i64 %16 to i128
  %19 = mul i128 %17, %18
  %20 = lshr i128 %19, 64
  %21 = trunc i128 %20 to i64
  %22 = trunc i128 %19 to i64
; # (if (or @@@ (& N (hex "F000000000000000"))) (consNum N (cnt @@@))...
; # (or @@@ (& N (hex "F000000000000000")))
  %23 = icmp ne i64 %21, 0
  br i1 %23, label %$10, label %$11
$11:
  %24 = phi i64 [%14, %$7] ; # A
  %25 = phi i64 [%15, %$7] ; # B
; # (& N (hex "F000000000000000"))
  %26 = and i64 %22, 17293822569102704640
  %27 = icmp ne i64 %26, 0
  br label %$10
$10:
  %28 = phi i64 [%14, %$7], [%24, %$11] ; # A
  %29 = phi i64 [%15, %$7], [%25, %$11] ; # B
  %30 = phi i1 [1, %$7], [%27, %$11] ; # ->
  br i1 %30, label %$12, label %$13
$12:
  %31 = phi i64 [%28, %$10] ; # A
  %32 = phi i64 [%29, %$10] ; # B
; # (cnt @@@)
  %33 = shl i64 %21, 4
  %34 = or i64 %33, 2
; # (consNum N (cnt @@@))
  %35 = call i64 @consNum(i64 %22, i64 %34)
  br label %$14
$13:
  %36 = phi i64 [%28, %$10] ; # A
  %37 = phi i64 [%29, %$10] ; # B
; # (cnt N)
  %38 = shl i64 %22, 4
  %39 = or i64 %38, 2
  br label %$14
$14:
  %40 = phi i64 [%31, %$12], [%36, %$13] ; # A
  %41 = phi i64 [%32, %$12], [%37, %$13] ; # B
  %42 = phi i64 [%35, %$12], [%39, %$13] ; # ->
  br label %$9
$8:
  %43 = phi i64 [%11, %$6] ; # A
  %44 = phi i64 [%10, %$6] ; # B
; # (: 1 (let (Lo (mul A (val (dig B))) Hi @@@ P (boxNum Lo) R (save ...
  br label %$-1
$-1:
  %45 = phi i64 [%43, %$8], [%169, %$26] ; # A
  %46 = phi i64 [%44, %$8], [%167, %$26] ; # B
; # (let (Lo (mul A (val (dig B))) Hi @@@ P (boxNum Lo) R (save P)) (...
; # (dig B)
  %47 = add i64 %46, -4
; # (val (dig B))
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (mul A (val (dig B)))
  %50 = zext i64 %45 to i128
  %51 = zext i64 %49 to i128
  %52 = mul i128 %50, %51
  %53 = lshr i128 %52, 64
  %54 = trunc i128 %53 to i64
  %55 = trunc i128 %52 to i64
; # (boxNum Lo)
  %56 = call i64 @boxNum(i64 %55)
; # (save P)
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %58 = load i64, i64* %57
  %59 = alloca i64, i64 2, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = inttoptr i64 %60 to i64*
  store i64 %56, i64* %61
  %62 = add i64 %60, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 %58, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %64
; # (while (big? (setq B (val (big B)))) (setq Lo (add (mul A (val (d...
  br label %$15
$15:
  %65 = phi i64 [%45, %$-1], [%75, %$16] ; # A
  %66 = phi i64 [%46, %$-1], [%76, %$16] ; # B
  %67 = phi i64 [%55, %$-1], [%91, %$16] ; # Lo
  %68 = phi i64 [%54, %$-1], [%93, %$16] ; # Hi
  %69 = phi i64 [%56, %$-1], [%95, %$16] ; # P
; # (big B)
  %70 = add i64 %66, 4
; # (val (big B))
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
; # (big? (setq B (val (big B))))
  %73 = and i64 %72, 4
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$16, label %$17
$16:
  %75 = phi i64 [%65, %$15] ; # A
  %76 = phi i64 [%72, %$15] ; # B
  %77 = phi i64 [%67, %$15] ; # Lo
  %78 = phi i64 [%68, %$15] ; # Hi
  %79 = phi i64 [%69, %$15] ; # P
; # (dig B)
  %80 = add i64 %76, -4
; # (val (dig B))
  %81 = inttoptr i64 %80 to i64*
  %82 = load i64, i64* %81
; # (mul A (val (dig B)))
  %83 = zext i64 %75 to i128
  %84 = zext i64 %82 to i128
  %85 = mul i128 %83, %84
  %86 = lshr i128 %85, 64
  %87 = trunc i128 %86 to i64
  %88 = trunc i128 %85 to i64
; # (add (mul A (val (dig B))) Hi)
  %89 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %88, i64 %78)
  %90 = extractvalue {i64, i1} %89, 1
  %91 = extractvalue {i64, i1} %89, 0
; # (+ @@@ @@)
  %92 = zext i1 %90 to i64
  %93 = add i64 %87, %92
; # (set (big P) (boxNum Lo))
; # (big P)
  %94 = add i64 %79, 4
; # (boxNum Lo)
  %95 = call i64 @boxNum(i64 %91)
  %96 = inttoptr i64 %94 to i64*
  store i64 %95, i64* %96
  br label %$15
$17:
  %97 = phi i64 [%65, %$15] ; # A
  %98 = phi i64 [%72, %$15] ; # B
  %99 = phi i64 [%67, %$15] ; # Lo
  %100 = phi i64 [%68, %$15] ; # Hi
  %101 = phi i64 [%69, %$15] ; # P
; # (int B)
  %102 = lshr i64 %98, 4
; # (mul A (int B))
  %103 = zext i64 %97 to i128
  %104 = zext i64 %102 to i128
  %105 = mul i128 %103, %104
  %106 = lshr i128 %105, 64
  %107 = trunc i128 %106 to i64
  %108 = trunc i128 %105 to i64
; # (add (mul A (int B)) Hi)
  %109 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %108, i64 %100)
  %110 = extractvalue {i64, i1} %109, 1
  %111 = extractvalue {i64, i1} %109, 0
; # (+ @@@ @@)
  %112 = zext i1 %110 to i64
  %113 = add i64 %107, %112
; # (set (big P) (if (or Hi (& Lo (hex "F000000000000000"))) (consNum...
; # (big P)
  %114 = add i64 %101, 4
; # (if (or Hi (& Lo (hex "F000000000000000"))) (consNum Lo (cnt Hi))...
; # (or Hi (& Lo (hex "F000000000000000")))
  %115 = icmp ne i64 %113, 0
  br i1 %115, label %$18, label %$19
$19:
  %116 = phi i64 [%97, %$17] ; # A
  %117 = phi i64 [%98, %$17] ; # B
  %118 = phi i64 [%111, %$17] ; # Lo
  %119 = phi i64 [%113, %$17] ; # Hi
  %120 = phi i64 [%101, %$17] ; # P
; # (& Lo (hex "F000000000000000"))
  %121 = and i64 %118, 17293822569102704640
  %122 = icmp ne i64 %121, 0
  br label %$18
$18:
  %123 = phi i64 [%97, %$17], [%116, %$19] ; # A
  %124 = phi i64 [%98, %$17], [%117, %$19] ; # B
  %125 = phi i64 [%111, %$17], [%118, %$19] ; # Lo
  %126 = phi i64 [%113, %$17], [%119, %$19] ; # Hi
  %127 = phi i64 [%101, %$17], [%120, %$19] ; # P
  %128 = phi i1 [1, %$17], [%122, %$19] ; # ->
  br i1 %128, label %$20, label %$21
$20:
  %129 = phi i64 [%123, %$18] ; # A
  %130 = phi i64 [%124, %$18] ; # B
  %131 = phi i64 [%125, %$18] ; # Lo
  %132 = phi i64 [%126, %$18] ; # Hi
  %133 = phi i64 [%127, %$18] ; # P
; # (cnt Hi)
  %134 = shl i64 %132, 4
  %135 = or i64 %134, 2
; # (consNum Lo (cnt Hi))
  %136 = call i64 @consNum(i64 %131, i64 %135)
  br label %$22
$21:
  %137 = phi i64 [%123, %$18] ; # A
  %138 = phi i64 [%124, %$18] ; # B
  %139 = phi i64 [%125, %$18] ; # Lo
  %140 = phi i64 [%126, %$18] ; # Hi
  %141 = phi i64 [%127, %$18] ; # P
; # (cnt Lo)
  %142 = shl i64 %139, 4
  %143 = or i64 %142, 2
  br label %$22
$22:
  %144 = phi i64 [%129, %$20], [%137, %$21] ; # A
  %145 = phi i64 [%130, %$20], [%138, %$21] ; # B
  %146 = phi i64 [%131, %$20], [%139, %$21] ; # Lo
  %147 = phi i64 [%132, %$20], [%140, %$21] ; # Hi
  %148 = phi i64 [%133, %$20], [%141, %$21] ; # P
  %149 = phi i64 [%136, %$20], [%143, %$21] ; # ->
  %150 = inttoptr i64 %114 to i64*
  store i64 %149, i64* %150
; # (drop *Safe)
  %151 = inttoptr i64 %60 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  %154 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %153, i64* %154
  br label %$9
$9:
  %155 = phi i64 [%40, %$14], [%144, %$22] ; # A
  %156 = phi i64 [%41, %$14], [%145, %$22] ; # B
  %157 = phi i64 [%42, %$14], [%56, %$22] ; # ->
  br label %$2
$5:
  %158 = phi i64 [%5, %$3] ; # A
  %159 = phi i64 [%6, %$3] ; # B
; # (== B ZERO)
  %160 = icmp eq i64 %159, 2
  br i1 %160, label %$24, label %$23
$24:
  %161 = phi i64 [%158, %$5] ; # A
  %162 = phi i64 [%159, %$5] ; # B
  br label %$2
$23:
  %163 = phi i64 [%158, %$5] ; # A
  %164 = phi i64 [%159, %$5] ; # B
; # (cnt? B)
  %165 = and i64 %164, 2
  %166 = icmp ne i64 %165, 0
  br i1 %166, label %$26, label %$25
$26:
  %167 = phi i64 [%163, %$23] ; # A
  %168 = phi i64 [%164, %$23] ; # B
; # (int B)
  %169 = lshr i64 %168, 4
; # (xchg 'A 'B)
; # (goto 1)
  br label %$-1
$25:
  %170 = phi i64 [%163, %$23] ; # A
  %171 = phi i64 [%164, %$23] ; # B
; # (let (P (boxNum 0) R (save P)) (loop (let (X A Q P Lo (add (mul (...
; # (boxNum 0)
  %172 = call i64 @boxNum(i64 0)
; # (save P)
  %173 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %174 = load i64, i64* %173
  %175 = alloca i64, i64 2, align 16
  %176 = ptrtoint i64* %175 to i64
  %177 = inttoptr i64 %176 to i64*
  store i64 %172, i64* %177
  %178 = add i64 %176, 8
  %179 = inttoptr i64 %178 to i64*
  store i64 %174, i64* %179
  %180 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %176, i64* %180
; # (loop (let (X A Q P Lo (add (mul (val (dig X)) (val (dig B))) (va...
  br label %$27
$27:
  %181 = phi i64 [%170, %$25], [%368, %$39] ; # A
  %182 = phi i64 [%171, %$25], [%369, %$39] ; # B
  %183 = phi i64 [%172, %$25], [%370, %$39] ; # P
; # (let (X A Q P Lo (add (mul (val (dig X)) (val (dig B))) (val (dig...
; # (dig X)
  %184 = add i64 %181, -4
; # (val (dig X))
  %185 = inttoptr i64 %184 to i64*
  %186 = load i64, i64* %185
; # (dig B)
  %187 = add i64 %182, -4
; # (val (dig B))
  %188 = inttoptr i64 %187 to i64*
  %189 = load i64, i64* %188
; # (mul (val (dig X)) (val (dig B)))
  %190 = zext i64 %186 to i128
  %191 = zext i64 %189 to i128
  %192 = mul i128 %190, %191
  %193 = lshr i128 %192, 64
  %194 = trunc i128 %193 to i64
  %195 = trunc i128 %192 to i64
; # (dig Q)
  %196 = add i64 %183, -4
; # (val (dig Q))
  %197 = inttoptr i64 %196 to i64*
  %198 = load i64, i64* %197
; # (add (mul (val (dig X)) (val (dig B))) (val (dig Q)))
  %199 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %195, i64 %198)
  %200 = extractvalue {i64, i1} %199, 1
  %201 = extractvalue {i64, i1} %199, 0
; # (+ @@@ @@)
  %202 = zext i1 %200 to i64
  %203 = add i64 %194, %202
; # (loop (set (dig Q) Lo) (setq Q (if (cnt? (val (big Q))) (set (big...
  br label %$28
$28:
  %204 = phi i64 [%181, %$27], [%248, %$32] ; # A
  %205 = phi i64 [%182, %$27], [%249, %$32] ; # B
  %206 = phi i64 [%183, %$27], [%250, %$32] ; # P
  %207 = phi i64 [%181, %$27], [%251, %$32] ; # X
  %208 = phi i64 [%183, %$27], [%252, %$32] ; # Q
  %209 = phi i64 [%201, %$27], [%277, %$32] ; # Lo
  %210 = phi i64 [%203, %$27], [%279, %$32] ; # Hi
; # (set (dig Q) Lo)
; # (dig Q)
  %211 = add i64 %208, -4
  %212 = inttoptr i64 %211 to i64*
  store i64 %209, i64* %212
; # (if (cnt? (val (big Q))) (set (big Q) (boxNum 0)) @)
; # (big Q)
  %213 = add i64 %208, 4
; # (val (big Q))
  %214 = inttoptr i64 %213 to i64*
  %215 = load i64, i64* %214
; # (cnt? (val (big Q)))
  %216 = and i64 %215, 2
  %217 = icmp ne i64 %216, 0
  br i1 %217, label %$29, label %$30
$29:
  %218 = phi i64 [%204, %$28] ; # A
  %219 = phi i64 [%205, %$28] ; # B
  %220 = phi i64 [%206, %$28] ; # P
  %221 = phi i64 [%207, %$28] ; # X
  %222 = phi i64 [%208, %$28] ; # Q
  %223 = phi i64 [%209, %$28] ; # Lo
  %224 = phi i64 [%210, %$28] ; # Hi
; # (set (big Q) (boxNum 0))
; # (big Q)
  %225 = add i64 %222, 4
; # (boxNum 0)
  %226 = call i64 @boxNum(i64 0)
  %227 = inttoptr i64 %225 to i64*
  store i64 %226, i64* %227
  br label %$31
$30:
  %228 = phi i64 [%204, %$28] ; # A
  %229 = phi i64 [%205, %$28] ; # B
  %230 = phi i64 [%206, %$28] ; # P
  %231 = phi i64 [%207, %$28] ; # X
  %232 = phi i64 [%208, %$28] ; # Q
  %233 = phi i64 [%209, %$28] ; # Lo
  %234 = phi i64 [%210, %$28] ; # Hi
  br label %$31
$31:
  %235 = phi i64 [%218, %$29], [%228, %$30] ; # A
  %236 = phi i64 [%219, %$29], [%229, %$30] ; # B
  %237 = phi i64 [%220, %$29], [%230, %$30] ; # P
  %238 = phi i64 [%221, %$29], [%231, %$30] ; # X
  %239 = phi i64 [%222, %$29], [%232, %$30] ; # Q
  %240 = phi i64 [%223, %$29], [%233, %$30] ; # Lo
  %241 = phi i64 [%224, %$29], [%234, %$30] ; # Hi
  %242 = phi i64 [%226, %$29], [%215, %$30] ; # ->
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %243 = add i64 %238, 4
; # (val (big X))
  %244 = inttoptr i64 %243 to i64*
  %245 = load i64, i64* %244
; # (cnt? (setq X (val (big X))))
  %246 = and i64 %245, 2
  %247 = icmp ne i64 %246, 0
  br i1 %247, label %$33, label %$32
$32:
  %248 = phi i64 [%235, %$31] ; # A
  %249 = phi i64 [%236, %$31] ; # B
  %250 = phi i64 [%237, %$31] ; # P
  %251 = phi i64 [%245, %$31] ; # X
  %252 = phi i64 [%242, %$31] ; # Q
  %253 = phi i64 [%240, %$31] ; # Lo
  %254 = phi i64 [%241, %$31] ; # Hi
; # (dig X)
  %255 = add i64 %251, -4
; # (val (dig X))
  %256 = inttoptr i64 %255 to i64*
  %257 = load i64, i64* %256
; # (dig B)
  %258 = add i64 %249, -4
; # (val (dig B))
  %259 = inttoptr i64 %258 to i64*
  %260 = load i64, i64* %259
; # (mulAddHiLo (val (dig X)) (val (dig B)) Q)
  %261 = zext i64 %257 to i128
  %262 = zext i64 %260 to i128
  %263 = mul i128 %261, %262
  %264 = lshr i128 %263, 64
  %265 = trunc i128 %264 to i64
  %266 = trunc i128 %263 to i64
  %267 = add i64 %252, -4
  %268 = inttoptr i64 %267 to i64*
  %269 = load i64, i64* %268
  %270 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %266, i64 %269)
  %271 = extractvalue {i64, i1} %270, 1
  %272 = extractvalue {i64, i1} %270, 0
  %273 = zext i1 %271 to i64
  %274 = add i64 %265, %273
  %275 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %272, i64 %254)
  %276 = extractvalue {i64, i1} %275, 1
  %277 = extractvalue {i64, i1} %275, 0
  %278 = zext i1 %276 to i64
  %279 = add i64 %274, %278
  br label %$28
$33:
  %280 = phi i64 [%235, %$31] ; # A
  %281 = phi i64 [%236, %$31] ; # B
  %282 = phi i64 [%237, %$31] ; # P
  %283 = phi i64 [%245, %$31] ; # X
  %284 = phi i64 [%242, %$31] ; # Q
  %285 = phi i64 [%240, %$31] ; # Lo
  %286 = phi i64 [%241, %$31] ; # Hi
  %287 = phi i64 [0, %$31] ; # ->
; # (int X)
  %288 = lshr i64 %283, 4
; # (dig B)
  %289 = add i64 %281, -4
; # (val (dig B))
  %290 = inttoptr i64 %289 to i64*
  %291 = load i64, i64* %290
; # (mulAddHiLo (int X) (val (dig B)) Q)
  %292 = zext i64 %288 to i128
  %293 = zext i64 %291 to i128
  %294 = mul i128 %292, %293
  %295 = lshr i128 %294, 64
  %296 = trunc i128 %295 to i64
  %297 = trunc i128 %294 to i64
  %298 = add i64 %284, -4
  %299 = inttoptr i64 %298 to i64*
  %300 = load i64, i64* %299
  %301 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %297, i64 %300)
  %302 = extractvalue {i64, i1} %301, 1
  %303 = extractvalue {i64, i1} %301, 0
  %304 = zext i1 %302 to i64
  %305 = add i64 %296, %304
  %306 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %303, i64 %286)
  %307 = extractvalue {i64, i1} %306, 1
  %308 = extractvalue {i64, i1} %306, 0
  %309 = zext i1 %307 to i64
  %310 = add i64 %305, %309
; # (set (dig Q) Lo)
; # (dig Q)
  %311 = add i64 %284, -4
  %312 = inttoptr i64 %311 to i64*
  store i64 %308, i64* %312
; # (when Hi (if (cnt? (val (big Q))) (set (big Q) (boxNum Hi)) (set ...
  %313 = icmp ne i64 %310, 0
  br i1 %313, label %$34, label %$35
$34:
  %314 = phi i64 [%280, %$33] ; # A
  %315 = phi i64 [%281, %$33] ; # B
  %316 = phi i64 [%282, %$33] ; # P
  %317 = phi i64 [%283, %$33] ; # X
  %318 = phi i64 [%284, %$33] ; # Q
  %319 = phi i64 [%308, %$33] ; # Lo
  %320 = phi i64 [%310, %$33] ; # Hi
; # (if (cnt? (val (big Q))) (set (big Q) (boxNum Hi)) (set (big @) H...
; # (big Q)
  %321 = add i64 %318, 4
; # (val (big Q))
  %322 = inttoptr i64 %321 to i64*
  %323 = load i64, i64* %322
; # (cnt? (val (big Q)))
  %324 = and i64 %323, 2
  %325 = icmp ne i64 %324, 0
  br i1 %325, label %$36, label %$37
$36:
  %326 = phi i64 [%314, %$34] ; # A
  %327 = phi i64 [%315, %$34] ; # B
  %328 = phi i64 [%316, %$34] ; # P
  %329 = phi i64 [%317, %$34] ; # X
  %330 = phi i64 [%318, %$34] ; # Q
  %331 = phi i64 [%319, %$34] ; # Lo
  %332 = phi i64 [%320, %$34] ; # Hi
; # (set (big Q) (boxNum Hi))
; # (big Q)
  %333 = add i64 %330, 4
; # (boxNum Hi)
  %334 = call i64 @boxNum(i64 %332)
  %335 = inttoptr i64 %333 to i64*
  store i64 %334, i64* %335
  br label %$38
$37:
  %336 = phi i64 [%314, %$34] ; # A
  %337 = phi i64 [%315, %$34] ; # B
  %338 = phi i64 [%316, %$34] ; # P
  %339 = phi i64 [%317, %$34] ; # X
  %340 = phi i64 [%318, %$34] ; # Q
  %341 = phi i64 [%319, %$34] ; # Lo
  %342 = phi i64 [%320, %$34] ; # Hi
; # (set (big @) Hi)
; # (big @)
  %343 = add i64 %323, 4
  %344 = inttoptr i64 %343 to i64*
  store i64 %342, i64* %344
  br label %$38
$38:
  %345 = phi i64 [%326, %$36], [%336, %$37] ; # A
  %346 = phi i64 [%327, %$36], [%337, %$37] ; # B
  %347 = phi i64 [%328, %$36], [%338, %$37] ; # P
  %348 = phi i64 [%329, %$36], [%339, %$37] ; # X
  %349 = phi i64 [%330, %$36], [%340, %$37] ; # Q
  %350 = phi i64 [%331, %$36], [%341, %$37] ; # Lo
  %351 = phi i64 [%332, %$36], [%342, %$37] ; # Hi
  %352 = phi i64 [%334, %$36], [%342, %$37] ; # ->
  br label %$35
$35:
  %353 = phi i64 [%280, %$33], [%345, %$38] ; # A
  %354 = phi i64 [%281, %$33], [%346, %$38] ; # B
  %355 = phi i64 [%282, %$33], [%347, %$38] ; # P
  %356 = phi i64 [%283, %$33], [%348, %$38] ; # X
  %357 = phi i64 [%284, %$33], [%349, %$38] ; # Q
  %358 = phi i64 [%308, %$33], [%350, %$38] ; # Lo
  %359 = phi i64 [%310, %$33], [%351, %$38] ; # Hi
; # (big P)
  %360 = add i64 %355, 4
; # (val (big P))
  %361 = inttoptr i64 %360 to i64*
  %362 = load i64, i64* %361
; # (? (cnt? (setq B (val (big B)))))
; # (big B)
  %363 = add i64 %354, 4
; # (val (big B))
  %364 = inttoptr i64 %363 to i64*
  %365 = load i64, i64* %364
; # (cnt? (setq B (val (big B))))
  %366 = and i64 %365, 2
  %367 = icmp ne i64 %366, 0
  br i1 %367, label %$40, label %$39
$39:
  %368 = phi i64 [%353, %$35] ; # A
  %369 = phi i64 [%365, %$35] ; # B
  %370 = phi i64 [%362, %$35] ; # P
  br label %$27
$40:
  %371 = phi i64 [%353, %$35] ; # A
  %372 = phi i64 [%365, %$35] ; # B
  %373 = phi i64 [%362, %$35] ; # P
  %374 = phi i64 [0, %$35] ; # ->
; # (int B)
  %375 = lshr i64 %372, 4
; # (let (Lo (add (mul (val (dig A)) B) (val (dig P))) Hi (+ @@@ @@))...
; # (dig A)
  %376 = add i64 %371, -4
; # (val (dig A))
  %377 = inttoptr i64 %376 to i64*
  %378 = load i64, i64* %377
; # (mul (val (dig A)) B)
  %379 = zext i64 %378 to i128
  %380 = zext i64 %375 to i128
  %381 = mul i128 %379, %380
  %382 = lshr i128 %381, 64
  %383 = trunc i128 %382 to i64
  %384 = trunc i128 %381 to i64
; # (dig P)
  %385 = add i64 %373, -4
; # (val (dig P))
  %386 = inttoptr i64 %385 to i64*
  %387 = load i64, i64* %386
; # (add (mul (val (dig A)) B) (val (dig P)))
  %388 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %384, i64 %387)
  %389 = extractvalue {i64, i1} %388, 1
  %390 = extractvalue {i64, i1} %388, 0
; # (+ @@@ @@)
  %391 = zext i1 %389 to i64
  %392 = add i64 %383, %391
; # (loop (set (dig P) Lo) (setq P (if (cnt? (val (big P))) (set (big...
  br label %$41
$41:
  %393 = phi i64 [%371, %$40], [%429, %$45] ; # A
  %394 = phi i64 [%375, %$40], [%430, %$45] ; # B
  %395 = phi i64 [%373, %$40], [%431, %$45] ; # P
  %396 = phi i64 [%390, %$40], [%453, %$45] ; # Lo
  %397 = phi i64 [%392, %$40], [%455, %$45] ; # Hi
; # (set (dig P) Lo)
; # (dig P)
  %398 = add i64 %395, -4
  %399 = inttoptr i64 %398 to i64*
  store i64 %396, i64* %399
; # (if (cnt? (val (big P))) (set (big P) (boxNum 0)) @)
; # (big P)
  %400 = add i64 %395, 4
; # (val (big P))
  %401 = inttoptr i64 %400 to i64*
  %402 = load i64, i64* %401
; # (cnt? (val (big P)))
  %403 = and i64 %402, 2
  %404 = icmp ne i64 %403, 0
  br i1 %404, label %$42, label %$43
$42:
  %405 = phi i64 [%393, %$41] ; # A
  %406 = phi i64 [%394, %$41] ; # B
  %407 = phi i64 [%395, %$41] ; # P
  %408 = phi i64 [%396, %$41] ; # Lo
  %409 = phi i64 [%397, %$41] ; # Hi
; # (set (big P) (boxNum 0))
; # (big P)
  %410 = add i64 %407, 4
; # (boxNum 0)
  %411 = call i64 @boxNum(i64 0)
  %412 = inttoptr i64 %410 to i64*
  store i64 %411, i64* %412
  br label %$44
$43:
  %413 = phi i64 [%393, %$41] ; # A
  %414 = phi i64 [%394, %$41] ; # B
  %415 = phi i64 [%395, %$41] ; # P
  %416 = phi i64 [%396, %$41] ; # Lo
  %417 = phi i64 [%397, %$41] ; # Hi
  br label %$44
$44:
  %418 = phi i64 [%405, %$42], [%413, %$43] ; # A
  %419 = phi i64 [%406, %$42], [%414, %$43] ; # B
  %420 = phi i64 [%407, %$42], [%415, %$43] ; # P
  %421 = phi i64 [%408, %$42], [%416, %$43] ; # Lo
  %422 = phi i64 [%409, %$42], [%417, %$43] ; # Hi
  %423 = phi i64 [%411, %$42], [%402, %$43] ; # ->
; # (? (cnt? (setq A (val (big A)))))
; # (big A)
  %424 = add i64 %418, 4
; # (val (big A))
  %425 = inttoptr i64 %424 to i64*
  %426 = load i64, i64* %425
; # (cnt? (setq A (val (big A))))
  %427 = and i64 %426, 2
  %428 = icmp ne i64 %427, 0
  br i1 %428, label %$46, label %$45
$45:
  %429 = phi i64 [%426, %$44] ; # A
  %430 = phi i64 [%419, %$44] ; # B
  %431 = phi i64 [%423, %$44] ; # P
  %432 = phi i64 [%421, %$44] ; # Lo
  %433 = phi i64 [%422, %$44] ; # Hi
; # (dig A)
  %434 = add i64 %429, -4
; # (val (dig A))
  %435 = inttoptr i64 %434 to i64*
  %436 = load i64, i64* %435
; # (mulAddHiLo (val (dig A)) B P)
  %437 = zext i64 %436 to i128
  %438 = zext i64 %430 to i128
  %439 = mul i128 %437, %438
  %440 = lshr i128 %439, 64
  %441 = trunc i128 %440 to i64
  %442 = trunc i128 %439 to i64
  %443 = add i64 %431, -4
  %444 = inttoptr i64 %443 to i64*
  %445 = load i64, i64* %444
  %446 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %442, i64 %445)
  %447 = extractvalue {i64, i1} %446, 1
  %448 = extractvalue {i64, i1} %446, 0
  %449 = zext i1 %447 to i64
  %450 = add i64 %441, %449
  %451 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %448, i64 %433)
  %452 = extractvalue {i64, i1} %451, 1
  %453 = extractvalue {i64, i1} %451, 0
  %454 = zext i1 %452 to i64
  %455 = add i64 %450, %454
  br label %$41
$46:
  %456 = phi i64 [%426, %$44] ; # A
  %457 = phi i64 [%419, %$44] ; # B
  %458 = phi i64 [%423, %$44] ; # P
  %459 = phi i64 [%421, %$44] ; # Lo
  %460 = phi i64 [%422, %$44] ; # Hi
  %461 = phi i64 [0, %$44] ; # ->
; # (int A)
  %462 = lshr i64 %456, 4
; # (mulAddHiLo (int A) B P)
  %463 = zext i64 %462 to i128
  %464 = zext i64 %457 to i128
  %465 = mul i128 %463, %464
  %466 = lshr i128 %465, 64
  %467 = trunc i128 %466 to i64
  %468 = trunc i128 %465 to i64
  %469 = add i64 %458, -4
  %470 = inttoptr i64 %469 to i64*
  %471 = load i64, i64* %470
  %472 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %468, i64 %471)
  %473 = extractvalue {i64, i1} %472, 1
  %474 = extractvalue {i64, i1} %472, 0
  %475 = zext i1 %473 to i64
  %476 = add i64 %467, %475
  %477 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %474, i64 %460)
  %478 = extractvalue {i64, i1} %477, 1
  %479 = extractvalue {i64, i1} %477, 0
  %480 = zext i1 %478 to i64
  %481 = add i64 %476, %480
; # (set (dig P) Lo)
; # (dig P)
  %482 = add i64 %458, -4
  %483 = inttoptr i64 %482 to i64*
  store i64 %479, i64* %483
; # (when Hi (if (cnt? (val (big P))) (set (big P) (boxNum Hi)) (set ...
  %484 = icmp ne i64 %481, 0
  br i1 %484, label %$47, label %$48
$47:
  %485 = phi i64 [%456, %$46] ; # A
  %486 = phi i64 [%457, %$46] ; # B
  %487 = phi i64 [%458, %$46] ; # P
  %488 = phi i64 [%479, %$46] ; # Lo
  %489 = phi i64 [%481, %$46] ; # Hi
; # (if (cnt? (val (big P))) (set (big P) (boxNum Hi)) (set (big @) H...
; # (big P)
  %490 = add i64 %487, 4
; # (val (big P))
  %491 = inttoptr i64 %490 to i64*
  %492 = load i64, i64* %491
; # (cnt? (val (big P)))
  %493 = and i64 %492, 2
  %494 = icmp ne i64 %493, 0
  br i1 %494, label %$49, label %$50
$49:
  %495 = phi i64 [%485, %$47] ; # A
  %496 = phi i64 [%486, %$47] ; # B
  %497 = phi i64 [%487, %$47] ; # P
  %498 = phi i64 [%488, %$47] ; # Lo
  %499 = phi i64 [%489, %$47] ; # Hi
; # (set (big P) (boxNum Hi))
; # (big P)
  %500 = add i64 %497, 4
; # (boxNum Hi)
  %501 = call i64 @boxNum(i64 %499)
  %502 = inttoptr i64 %500 to i64*
  store i64 %501, i64* %502
  br label %$51
$50:
  %503 = phi i64 [%485, %$47] ; # A
  %504 = phi i64 [%486, %$47] ; # B
  %505 = phi i64 [%487, %$47] ; # P
  %506 = phi i64 [%488, %$47] ; # Lo
  %507 = phi i64 [%489, %$47] ; # Hi
; # (set (big @) Hi)
; # (big @)
  %508 = add i64 %492, 4
  %509 = inttoptr i64 %508 to i64*
  store i64 %507, i64* %509
  br label %$51
$51:
  %510 = phi i64 [%495, %$49], [%503, %$50] ; # A
  %511 = phi i64 [%496, %$49], [%504, %$50] ; # B
  %512 = phi i64 [%497, %$49], [%505, %$50] ; # P
  %513 = phi i64 [%498, %$49], [%506, %$50] ; # Lo
  %514 = phi i64 [%499, %$49], [%507, %$50] ; # Hi
  %515 = phi i64 [%501, %$49], [%507, %$50] ; # ->
  br label %$48
$48:
  %516 = phi i64 [%456, %$46], [%510, %$51] ; # A
  %517 = phi i64 [%457, %$46], [%511, %$51] ; # B
  %518 = phi i64 [%458, %$46], [%512, %$51] ; # P
  %519 = phi i64 [%479, %$46], [%513, %$51] ; # Lo
  %520 = phi i64 [%481, %$46], [%514, %$51] ; # Hi
; # (zapZero R)
  %521 = call i64 @zapZero(i64 %172)
; # (drop *Safe)
  %522 = inttoptr i64 %176 to i64*
  %523 = getelementptr i64, i64* %522, i32 1
  %524 = load i64, i64* %523
  %525 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %524, i64* %525
  br label %$2
$2:
  %526 = phi i64 [%3, %$4], [%155, %$9], [%161, %$24], [%516, %$48] ; # A
  %527 = phi i64 [%4, %$4], [%156, %$9], [%162, %$24], [%517, %$48] ; # B
  %528 = phi i64 [%3, %$4], [%157, %$9], [%162, %$24], [%521, %$48] ; # ->
  ret i64 %528
}

define i64 @div1(i64, i64, i1) align 8 {
$1:
; # (let (R (save ZERO) P (boxNum (val (dig A))) U (link (push P NIL)...
; # (save ZERO)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 2, i64* %7
  %8 = add i64 %6, 8
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %10
; # (dig A)
  %11 = add i64 %0, -4
; # (val (dig A))
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
; # (boxNum (val (dig A)))
  %14 = call i64 @boxNum(i64 %13)
; # (push P NIL)
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %14, i64* %17
; # (link (push P NIL))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = inttoptr i64 %16 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  store i64 %19, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %22
; # (push B NIL)
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %1, i64* %25
; # (link (push B NIL))
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %24 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %27, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %30
; # (while (big? (setq A (val (big A)))) (setq P (set (big P) (boxNum...
  br label %$2
$2:
  %31 = phi i64 [%0, %$1], [%44, %$3] ; # A
  %32 = phi i64 [%1, %$1], [%45, %$3] ; # B
  %33 = phi i64 [2, %$1], [%46, %$3] ; # R
  %34 = phi i64 [%14, %$1], [%56, %$3] ; # P
  %35 = phi i64 [0, %$1], [%48, %$3] ; # V2
  %36 = phi i64 [0, %$1], [%58, %$3] ; # M
  %37 = phi i64 [1, %$1], [%50, %$3] ; # N
  %38 = phi i64 [0, %$1], [%51, %$3] ; # D
; # (big A)
  %39 = add i64 %31, 4
; # (val (big A))
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
; # (big? (setq A (val (big A))))
  %42 = and i64 %41, 4
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$3, label %$4
$3:
  %44 = phi i64 [%41, %$2] ; # A
  %45 = phi i64 [%32, %$2] ; # B
  %46 = phi i64 [%33, %$2] ; # R
  %47 = phi i64 [%34, %$2] ; # P
  %48 = phi i64 [%35, %$2] ; # V2
  %49 = phi i64 [%36, %$2] ; # M
  %50 = phi i64 [%37, %$2] ; # N
  %51 = phi i64 [%38, %$2] ; # D
; # (set (big P) (boxNum (val (dig A))))
; # (big P)
  %52 = add i64 %47, 4
; # (dig A)
  %53 = add i64 %44, -4
; # (val (dig A))
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (boxNum (val (dig A)))
  %56 = call i64 @boxNum(i64 %55)
  %57 = inttoptr i64 %52 to i64*
  store i64 %56, i64* %57
; # (inc 'M)
  %58 = add i64 %49, 1
  br label %$2
$4:
  %59 = phi i64 [%41, %$2] ; # A
  %60 = phi i64 [%32, %$2] ; # B
  %61 = phi i64 [%33, %$2] ; # R
  %62 = phi i64 [%34, %$2] ; # P
  %63 = phi i64 [%35, %$2] ; # V2
  %64 = phi i64 [%36, %$2] ; # M
  %65 = phi i64 [%37, %$2] ; # N
  %66 = phi i64 [%38, %$2] ; # D
; # (unless (== A ZERO) (setq P (set (big P) (boxNum (int A)))) (inc ...
; # (== A ZERO)
  %67 = icmp eq i64 %59, 2
  br i1 %67, label %$6, label %$5
$5:
  %68 = phi i64 [%59, %$4] ; # A
  %69 = phi i64 [%60, %$4] ; # B
  %70 = phi i64 [%61, %$4] ; # R
  %71 = phi i64 [%62, %$4] ; # P
  %72 = phi i64 [%63, %$4] ; # V2
  %73 = phi i64 [%64, %$4] ; # M
  %74 = phi i64 [%65, %$4] ; # N
  %75 = phi i64 [%66, %$4] ; # D
; # (set (big P) (boxNum (int A)))
; # (big P)
  %76 = add i64 %71, 4
; # (int A)
  %77 = lshr i64 %68, 4
; # (boxNum (int A))
  %78 = call i64 @boxNum(i64 %77)
  %79 = inttoptr i64 %76 to i64*
  store i64 %78, i64* %79
; # (inc 'M)
  %80 = add i64 %73, 1
  br label %$6
$6:
  %81 = phi i64 [%59, %$4], [%68, %$5] ; # A
  %82 = phi i64 [%60, %$4], [%69, %$5] ; # B
  %83 = phi i64 [%61, %$4], [%70, %$5] ; # R
  %84 = phi i64 [%62, %$4], [%78, %$5] ; # P
  %85 = phi i64 [%63, %$4], [%72, %$5] ; # V2
  %86 = phi i64 [%64, %$4], [%80, %$5] ; # M
  %87 = phi i64 [%65, %$4], [%74, %$5] ; # N
  %88 = phi i64 [%66, %$4], [%75, %$5] ; # D
; # (if (cnt? B) (setq Q (set V (boxNum (int B)))) (setq Q (set V (bo...
; # (cnt? B)
  %89 = and i64 %82, 2
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$7, label %$8
$7:
  %91 = phi i64 [%81, %$6] ; # A
  %92 = phi i64 [%82, %$6] ; # B
  %93 = phi i64 [%83, %$6] ; # R
  %94 = phi i64 [%84, %$6] ; # P
  %95 = phi i64 [%85, %$6] ; # V2
  %96 = phi i64 [%86, %$6] ; # M
  %97 = phi i64 [%87, %$6] ; # N
  %98 = phi i64 [%88, %$6] ; # D
; # (set V (boxNum (int B)))
; # (int B)
  %99 = lshr i64 %92, 4
; # (boxNum (int B))
  %100 = call i64 @boxNum(i64 %99)
  %101 = inttoptr i64 %24 to i64*
  store i64 %100, i64* %101
  br label %$9
$8:
  %102 = phi i64 [%81, %$6] ; # A
  %103 = phi i64 [%82, %$6] ; # B
  %104 = phi i64 [%83, %$6] ; # R
  %105 = phi i64 [%84, %$6] ; # P
  %106 = phi i64 [%85, %$6] ; # V2
  %107 = phi i64 [%86, %$6] ; # M
  %108 = phi i64 [%87, %$6] ; # N
  %109 = phi i64 [%88, %$6] ; # D
; # (set V (boxNum (val (dig B))))
; # (dig B)
  %110 = add i64 %103, -4
; # (val (dig B))
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
; # (boxNum (val (dig B)))
  %113 = call i64 @boxNum(i64 %112)
  %114 = inttoptr i64 %24 to i64*
  store i64 %113, i64* %114
; # (while (big? (setq B (val (big B)))) (setq V2 Q Q (set (big Q) (b...
  br label %$10
$10:
  %115 = phi i64 [%102, %$8], [%129, %$11] ; # A
  %116 = phi i64 [%103, %$8], [%130, %$11] ; # B
  %117 = phi i64 [%104, %$8], [%131, %$11] ; # R
  %118 = phi i64 [%105, %$8], [%132, %$11] ; # P
  %119 = phi i64 [%106, %$8], [%137, %$11] ; # V2
  %120 = phi i64 [%107, %$8], [%144, %$11] ; # M
  %121 = phi i64 [%108, %$8], [%145, %$11] ; # N
  %122 = phi i64 [%109, %$8], [%136, %$11] ; # D
  %123 = phi i64 [%113, %$8], [%142, %$11] ; # Q
; # (big B)
  %124 = add i64 %116, 4
; # (val (big B))
  %125 = inttoptr i64 %124 to i64*
  %126 = load i64, i64* %125
; # (big? (setq B (val (big B))))
  %127 = and i64 %126, 4
  %128 = icmp ne i64 %127, 0
  br i1 %128, label %$11, label %$12
$11:
  %129 = phi i64 [%115, %$10] ; # A
  %130 = phi i64 [%126, %$10] ; # B
  %131 = phi i64 [%117, %$10] ; # R
  %132 = phi i64 [%118, %$10] ; # P
  %133 = phi i64 [%119, %$10] ; # V2
  %134 = phi i64 [%120, %$10] ; # M
  %135 = phi i64 [%121, %$10] ; # N
  %136 = phi i64 [%122, %$10] ; # D
  %137 = phi i64 [%123, %$10] ; # Q
; # (set (big Q) (boxNum (val (dig B))))
; # (big Q)
  %138 = add i64 %137, 4
; # (dig B)
  %139 = add i64 %130, -4
; # (val (dig B))
  %140 = inttoptr i64 %139 to i64*
  %141 = load i64, i64* %140
; # (boxNum (val (dig B)))
  %142 = call i64 @boxNum(i64 %141)
  %143 = inttoptr i64 %138 to i64*
  store i64 %142, i64* %143
; # (dec 'M)
  %144 = sub i64 %134, 1
; # (inc 'N)
  %145 = add i64 %135, 1
  br label %$10
$12:
  %146 = phi i64 [%115, %$10] ; # A
  %147 = phi i64 [%126, %$10] ; # B
  %148 = phi i64 [%117, %$10] ; # R
  %149 = phi i64 [%118, %$10] ; # P
  %150 = phi i64 [%119, %$10] ; # V2
  %151 = phi i64 [%120, %$10] ; # M
  %152 = phi i64 [%121, %$10] ; # N
  %153 = phi i64 [%122, %$10] ; # D
  %154 = phi i64 [%123, %$10] ; # Q
; # (unless (== B ZERO) (setq V2 Q Q (set (big Q) (boxNum (int B)))) ...
; # (== B ZERO)
  %155 = icmp eq i64 %147, 2
  br i1 %155, label %$14, label %$13
$13:
  %156 = phi i64 [%146, %$12] ; # A
  %157 = phi i64 [%147, %$12] ; # B
  %158 = phi i64 [%148, %$12] ; # R
  %159 = phi i64 [%149, %$12] ; # P
  %160 = phi i64 [%150, %$12] ; # V2
  %161 = phi i64 [%151, %$12] ; # M
  %162 = phi i64 [%152, %$12] ; # N
  %163 = phi i64 [%153, %$12] ; # D
  %164 = phi i64 [%154, %$12] ; # Q
; # (set (big Q) (boxNum (int B)))
; # (big Q)
  %165 = add i64 %164, 4
; # (int B)
  %166 = lshr i64 %157, 4
; # (boxNum (int B))
  %167 = call i64 @boxNum(i64 %166)
  %168 = inttoptr i64 %165 to i64*
  store i64 %167, i64* %168
; # (dec 'M)
  %169 = sub i64 %161, 1
; # (inc 'N)
  %170 = add i64 %162, 1
  br label %$14
$14:
  %171 = phi i64 [%146, %$12], [%156, %$13] ; # A
  %172 = phi i64 [%147, %$12], [%157, %$13] ; # B
  %173 = phi i64 [%148, %$12], [%158, %$13] ; # R
  %174 = phi i64 [%149, %$12], [%159, %$13] ; # P
  %175 = phi i64 [%150, %$12], [%164, %$13] ; # V2
  %176 = phi i64 [%151, %$12], [%169, %$13] ; # M
  %177 = phi i64 [%152, %$12], [%170, %$13] ; # N
  %178 = phi i64 [%153, %$12], [%163, %$13] ; # D
  %179 = phi i64 [%154, %$12], [%167, %$13] ; # Q
; # (when (lt0 M) (ret (if Rem (zapZero (val U)) ZERO)))
; # (lt0 M)
  %180 = icmp slt i64 %176, 0
  br i1 %180, label %$15, label %$16
$15:
  %181 = phi i64 [%171, %$14] ; # A
  %182 = phi i64 [%172, %$14] ; # B
  %183 = phi i64 [%173, %$14] ; # R
  %184 = phi i64 [%174, %$14] ; # P
  %185 = phi i64 [%175, %$14] ; # V2
  %186 = phi i64 [%176, %$14] ; # M
  %187 = phi i64 [%177, %$14] ; # N
  %188 = phi i64 [%178, %$14] ; # D
  %189 = phi i64 [%179, %$14] ; # Q
; # (if Rem (zapZero (val U)) ZERO)
  br i1 %2, label %$17, label %$18
$17:
  %190 = phi i64 [%181, %$15] ; # A
  %191 = phi i64 [%182, %$15] ; # B
  %192 = phi i64 [%183, %$15] ; # R
  %193 = phi i64 [%184, %$15] ; # P
  %194 = phi i64 [%185, %$15] ; # V2
  %195 = phi i64 [%186, %$15] ; # M
  %196 = phi i64 [%187, %$15] ; # N
  %197 = phi i64 [%188, %$15] ; # D
  %198 = phi i64 [%189, %$15] ; # Q
; # (val U)
  %199 = inttoptr i64 %16 to i64*
  %200 = load i64, i64* %199
; # (zapZero (val U))
  %201 = call i64 @zapZero(i64 %200)
  br label %$19
$18:
  %202 = phi i64 [%181, %$15] ; # A
  %203 = phi i64 [%182, %$15] ; # B
  %204 = phi i64 [%183, %$15] ; # R
  %205 = phi i64 [%184, %$15] ; # P
  %206 = phi i64 [%185, %$15] ; # V2
  %207 = phi i64 [%186, %$15] ; # M
  %208 = phi i64 [%187, %$15] ; # N
  %209 = phi i64 [%188, %$15] ; # D
  %210 = phi i64 [%189, %$15] ; # Q
  br label %$19
$19:
  %211 = phi i64 [%190, %$17], [%202, %$18] ; # A
  %212 = phi i64 [%191, %$17], [%203, %$18] ; # B
  %213 = phi i64 [%192, %$17], [%204, %$18] ; # R
  %214 = phi i64 [%193, %$17], [%205, %$18] ; # P
  %215 = phi i64 [%194, %$17], [%206, %$18] ; # V2
  %216 = phi i64 [%195, %$17], [%207, %$18] ; # M
  %217 = phi i64 [%196, %$17], [%208, %$18] ; # N
  %218 = phi i64 [%197, %$17], [%209, %$18] ; # D
  %219 = phi i64 [%198, %$17], [%210, %$18] ; # Q
  %220 = phi i64 [%201, %$17], [2, %$18] ; # ->
; # (ret (if Rem (zapZero (val U)) ZERO))
; # (drop *Safe)
  %221 = inttoptr i64 %6 to i64*
  %222 = getelementptr i64, i64* %221, i32 1
  %223 = load i64, i64* %222
  %224 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %223, i64* %224
  ret i64 %220
$16:
  %225 = phi i64 [%171, %$14] ; # A
  %226 = phi i64 [%172, %$14] ; # B
  %227 = phi i64 [%173, %$14] ; # R
  %228 = phi i64 [%174, %$14] ; # P
  %229 = phi i64 [%175, %$14] ; # V2
  %230 = phi i64 [%176, %$14] ; # M
  %231 = phi i64 [%177, %$14] ; # N
  %232 = phi i64 [%178, %$14] ; # D
  %233 = phi i64 [%179, %$14] ; # Q
  br label %$9
$9:
  %234 = phi i64 [%91, %$7], [%225, %$16] ; # A
  %235 = phi i64 [%92, %$7], [%226, %$16] ; # B
  %236 = phi i64 [%93, %$7], [%227, %$16] ; # R
  %237 = phi i64 [%94, %$7], [%228, %$16] ; # P
  %238 = phi i64 [%95, %$7], [%229, %$16] ; # V2
  %239 = phi i64 [%96, %$7], [%230, %$16] ; # M
  %240 = phi i64 [%97, %$7], [%231, %$16] ; # N
  %241 = phi i64 [%98, %$7], [%232, %$16] ; # D
  %242 = phi i64 [%100, %$7], [%233, %$16] ; # Q
; # (set (big P) (boxNum 0))
; # (big P)
  %243 = add i64 %237, 4
; # (boxNum 0)
  %244 = call i64 @boxNum(i64 0)
  %245 = inttoptr i64 %243 to i64*
  store i64 %244, i64* %245
; # (while (ge0 (val (dig Q))) (twiceBig (val U)) (twiceBig (val V)) ...
  br label %$20
$20:
  %246 = phi i64 [%234, %$9], [%259, %$21] ; # A
  %247 = phi i64 [%235, %$9], [%260, %$21] ; # B
  %248 = phi i64 [%236, %$9], [%261, %$21] ; # R
  %249 = phi i64 [%237, %$9], [%262, %$21] ; # P
  %250 = phi i64 [%238, %$9], [%263, %$21] ; # V2
  %251 = phi i64 [%239, %$9], [%264, %$21] ; # M
  %252 = phi i64 [%240, %$9], [%265, %$21] ; # N
  %253 = phi i64 [%241, %$9], [%274, %$21] ; # D
  %254 = phi i64 [%242, %$9], [%267, %$21] ; # Q
; # (dig Q)
  %255 = add i64 %254, -4
; # (val (dig Q))
  %256 = inttoptr i64 %255 to i64*
  %257 = load i64, i64* %256
; # (ge0 (val (dig Q)))
  %258 = icmp sge i64 %257, 0
  br i1 %258, label %$21, label %$22
$21:
  %259 = phi i64 [%246, %$20] ; # A
  %260 = phi i64 [%247, %$20] ; # B
  %261 = phi i64 [%248, %$20] ; # R
  %262 = phi i64 [%249, %$20] ; # P
  %263 = phi i64 [%250, %$20] ; # V2
  %264 = phi i64 [%251, %$20] ; # M
  %265 = phi i64 [%252, %$20] ; # N
  %266 = phi i64 [%253, %$20] ; # D
  %267 = phi i64 [%254, %$20] ; # Q
; # (val U)
  %268 = inttoptr i64 %16 to i64*
  %269 = load i64, i64* %268
; # (twiceBig (val U))
  %270 = call i64 @twiceBig(i64 %269)
; # (val V)
  %271 = inttoptr i64 %24 to i64*
  %272 = load i64, i64* %271
; # (twiceBig (val V))
  %273 = call i64 @twiceBig(i64 %272)
; # (inc 'D)
  %274 = add i64 %266, 1
  br label %$20
$22:
  %275 = phi i64 [%246, %$20] ; # A
  %276 = phi i64 [%247, %$20] ; # B
  %277 = phi i64 [%248, %$20] ; # R
  %278 = phi i64 [%249, %$20] ; # P
  %279 = phi i64 [%250, %$20] ; # V2
  %280 = phi i64 [%251, %$20] ; # M
  %281 = phi i64 [%252, %$20] ; # N
  %282 = phi i64 [%253, %$20] ; # D
  %283 = phi i64 [%254, %$20] ; # Q
; # (dig Q)
  %284 = add i64 %283, -4
; # (val (dig Q))
  %285 = inttoptr i64 %284 to i64*
  %286 = load i64, i64* %285
; # (when V2 (setq V2 (val (dig V2))))
  %287 = icmp ne i64 %279, 0
  br i1 %287, label %$23, label %$24
$23:
  %288 = phi i64 [%275, %$22] ; # A
  %289 = phi i64 [%276, %$22] ; # B
  %290 = phi i64 [%277, %$22] ; # R
  %291 = phi i64 [%278, %$22] ; # P
  %292 = phi i64 [%286, %$22] ; # V1
  %293 = phi i64 [%279, %$22] ; # V2
  %294 = phi i64 [%280, %$22] ; # M
  %295 = phi i64 [%281, %$22] ; # N
  %296 = phi i64 [%282, %$22] ; # D
  %297 = phi i64 [%283, %$22] ; # Q
; # (dig V2)
  %298 = add i64 %293, -4
; # (val (dig V2))
  %299 = inttoptr i64 %298 to i64*
  %300 = load i64, i64* %299
  br label %$24
$24:
  %301 = phi i64 [%275, %$22], [%288, %$23] ; # A
  %302 = phi i64 [%276, %$22], [%289, %$23] ; # B
  %303 = phi i64 [%277, %$22], [%290, %$23] ; # R
  %304 = phi i64 [%278, %$22], [%291, %$23] ; # P
  %305 = phi i64 [%286, %$22], [%292, %$23] ; # V1
  %306 = phi i64 [%279, %$22], [%300, %$23] ; # V2
  %307 = phi i64 [%280, %$22], [%294, %$23] ; # M
  %308 = phi i64 [%281, %$22], [%295, %$23] ; # N
  %309 = phi i64 [%282, %$22], [%296, %$23] ; # D
  %310 = phi i64 [%283, %$22], [%297, %$23] ; # Q
; # (loop (let (X (val U) U1 0 U2 0 U3 T) (let I M (while (ge0 (dec '...
  br label %$25
$25:
  %311 = phi i64 [%301, %$24], [%1016, %$56] ; # A
  %312 = phi i64 [%302, %$24], [%1017, %$56] ; # B
  %313 = phi i64 [%303, %$24], [%1018, %$56] ; # R
  %314 = phi i64 [%304, %$24], [%1019, %$56] ; # P
  %315 = phi i64 [%305, %$24], [%1020, %$56] ; # V1
  %316 = phi i64 [%306, %$24], [%1021, %$56] ; # V2
  %317 = phi i64 [%307, %$24], [%1022, %$56] ; # M
  %318 = phi i64 [%308, %$24], [%1023, %$56] ; # N
  %319 = phi i64 [%309, %$24], [%1024, %$56] ; # D
  %320 = phi i64 [%310, %$24], [%1025, %$56] ; # Q
; # (let (X (val U) U1 0 U2 0 U3 T) (let I M (while (ge0 (dec 'I)) (s...
; # (val U)
  %321 = inttoptr i64 %16 to i64*
  %322 = load i64, i64* %321
; # (let I M (while (ge0 (dec 'I)) (setq X (val (big X)))))
; # (while (ge0 (dec 'I)) (setq X (val (big X))))
  br label %$26
$26:
  %323 = phi i64 [%311, %$25], [%339, %$27] ; # A
  %324 = phi i64 [%312, %$25], [%340, %$27] ; # B
  %325 = phi i64 [%313, %$25], [%341, %$27] ; # R
  %326 = phi i64 [%314, %$25], [%342, %$27] ; # P
  %327 = phi i64 [%315, %$25], [%343, %$27] ; # V1
  %328 = phi i64 [%316, %$25], [%344, %$27] ; # V2
  %329 = phi i64 [%317, %$25], [%345, %$27] ; # M
  %330 = phi i64 [%318, %$25], [%346, %$27] ; # N
  %331 = phi i64 [%319, %$25], [%347, %$27] ; # D
  %332 = phi i64 [%320, %$25], [%348, %$27] ; # Q
  %333 = phi i64 [%322, %$25], [%355, %$27] ; # X
  %334 = phi i64 [0, %$25], [%350, %$27] ; # U1
  %335 = phi i64 [0, %$25], [%351, %$27] ; # U2
  %336 = phi i64 [%317, %$25], [%352, %$27] ; # I
; # (dec 'I)
  %337 = sub i64 %336, 1
; # (ge0 (dec 'I))
  %338 = icmp sge i64 %337, 0
  br i1 %338, label %$27, label %$28
$27:
  %339 = phi i64 [%323, %$26] ; # A
  %340 = phi i64 [%324, %$26] ; # B
  %341 = phi i64 [%325, %$26] ; # R
  %342 = phi i64 [%326, %$26] ; # P
  %343 = phi i64 [%327, %$26] ; # V1
  %344 = phi i64 [%328, %$26] ; # V2
  %345 = phi i64 [%329, %$26] ; # M
  %346 = phi i64 [%330, %$26] ; # N
  %347 = phi i64 [%331, %$26] ; # D
  %348 = phi i64 [%332, %$26] ; # Q
  %349 = phi i64 [%333, %$26] ; # X
  %350 = phi i64 [%334, %$26] ; # U1
  %351 = phi i64 [%335, %$26] ; # U2
  %352 = phi i64 [%337, %$26] ; # I
; # (big X)
  %353 = add i64 %349, 4
; # (val (big X))
  %354 = inttoptr i64 %353 to i64*
  %355 = load i64, i64* %354
  br label %$26
$28:
  %356 = phi i64 [%323, %$26] ; # A
  %357 = phi i64 [%324, %$26] ; # B
  %358 = phi i64 [%325, %$26] ; # R
  %359 = phi i64 [%326, %$26] ; # P
  %360 = phi i64 [%327, %$26] ; # V1
  %361 = phi i64 [%328, %$26] ; # V2
  %362 = phi i64 [%329, %$26] ; # M
  %363 = phi i64 [%330, %$26] ; # N
  %364 = phi i64 [%331, %$26] ; # D
  %365 = phi i64 [%332, %$26] ; # Q
  %366 = phi i64 [%333, %$26] ; # X
  %367 = phi i64 [%334, %$26] ; # U1
  %368 = phi i64 [%335, %$26] ; # U2
  %369 = phi i64 [%337, %$26] ; # I
; # (let (I N Y X) (loop (setq U3 U2 U2 U1 U1 (val (dig Y)) Y (val (b...
; # (loop (setq U3 U2 U2 U1 U1 (val (dig Y)) Y (val (big Y))) (? (lt0...
  br label %$29
$29:
  %370 = phi i64 [%356, %$28], [%393, %$30] ; # A
  %371 = phi i64 [%357, %$28], [%394, %$30] ; # B
  %372 = phi i64 [%358, %$28], [%395, %$30] ; # R
  %373 = phi i64 [%359, %$28], [%396, %$30] ; # P
  %374 = phi i64 [%360, %$28], [%397, %$30] ; # V1
  %375 = phi i64 [%361, %$28], [%398, %$30] ; # V2
  %376 = phi i64 [%362, %$28], [%399, %$30] ; # M
  %377 = phi i64 [%363, %$28], [%400, %$30] ; # N
  %378 = phi i64 [%364, %$28], [%401, %$30] ; # D
  %379 = phi i64 [%365, %$28], [%402, %$30] ; # Q
  %380 = phi i64 [%366, %$28], [%403, %$30] ; # X
  %381 = phi i64 [%367, %$28], [%404, %$30] ; # U1
  %382 = phi i64 [%368, %$28], [%405, %$30] ; # U2
  %383 = phi i64 [%363, %$28], [%407, %$30] ; # I
  %384 = phi i64 [%366, %$28], [%408, %$30] ; # Y
; # (dig Y)
  %385 = add i64 %384, -4
; # (val (dig Y))
  %386 = inttoptr i64 %385 to i64*
  %387 = load i64, i64* %386
; # (big Y)
  %388 = add i64 %384, 4
; # (val (big Y))
  %389 = inttoptr i64 %388 to i64*
  %390 = load i64, i64* %389
; # (? (lt0 (dec 'I)))
; # (dec 'I)
  %391 = sub i64 %383, 1
; # (lt0 (dec 'I))
  %392 = icmp slt i64 %391, 0
  br i1 %392, label %$31, label %$30
$30:
  %393 = phi i64 [%370, %$29] ; # A
  %394 = phi i64 [%371, %$29] ; # B
  %395 = phi i64 [%372, %$29] ; # R
  %396 = phi i64 [%373, %$29] ; # P
  %397 = phi i64 [%374, %$29] ; # V1
  %398 = phi i64 [%375, %$29] ; # V2
  %399 = phi i64 [%376, %$29] ; # M
  %400 = phi i64 [%377, %$29] ; # N
  %401 = phi i64 [%378, %$29] ; # D
  %402 = phi i64 [%379, %$29] ; # Q
  %403 = phi i64 [%380, %$29] ; # X
  %404 = phi i64 [%387, %$29] ; # U1
  %405 = phi i64 [%381, %$29] ; # U2
  %406 = phi i64 [%382, %$29] ; # U3
  %407 = phi i64 [%391, %$29] ; # I
  %408 = phi i64 [%390, %$29] ; # Y
  br label %$29
$31:
  %409 = phi i64 [%370, %$29] ; # A
  %410 = phi i64 [%371, %$29] ; # B
  %411 = phi i64 [%372, %$29] ; # R
  %412 = phi i64 [%373, %$29] ; # P
  %413 = phi i64 [%374, %$29] ; # V1
  %414 = phi i64 [%375, %$29] ; # V2
  %415 = phi i64 [%376, %$29] ; # M
  %416 = phi i64 [%377, %$29] ; # N
  %417 = phi i64 [%378, %$29] ; # D
  %418 = phi i64 [%379, %$29] ; # Q
  %419 = phi i64 [%380, %$29] ; # X
  %420 = phi i64 [%387, %$29] ; # U1
  %421 = phi i64 [%381, %$29] ; # U2
  %422 = phi i64 [%382, %$29] ; # U3
  %423 = phi i64 [%391, %$29] ; # I
  %424 = phi i64 [%390, %$29] ; # Y
  %425 = phi i64 [0, %$29] ; # ->
; # (let (Hi U1 Lo U2) (setq Q (if (== U1 V1) -1 (div Hi Lo V1))) (se...
; # (if (== U1 V1) -1 (div Hi Lo V1))
; # (== U1 V1)
  %426 = icmp eq i64 %420, %413
  br i1 %426, label %$32, label %$33
$32:
  %427 = phi i64 [%409, %$31] ; # A
  %428 = phi i64 [%410, %$31] ; # B
  %429 = phi i64 [%411, %$31] ; # R
  %430 = phi i64 [%412, %$31] ; # P
  %431 = phi i64 [%413, %$31] ; # V1
  %432 = phi i64 [%414, %$31] ; # V2
  %433 = phi i64 [%415, %$31] ; # M
  %434 = phi i64 [%416, %$31] ; # N
  %435 = phi i64 [%417, %$31] ; # D
  %436 = phi i64 [%418, %$31] ; # Q
  %437 = phi i64 [%419, %$31] ; # X
  %438 = phi i64 [%420, %$31] ; # U1
  %439 = phi i64 [%421, %$31] ; # U2
  %440 = phi i64 [%422, %$31] ; # U3
  %441 = phi i64 [%420, %$31] ; # Hi
  %442 = phi i64 [%421, %$31] ; # Lo
  br label %$34
$33:
  %443 = phi i64 [%409, %$31] ; # A
  %444 = phi i64 [%410, %$31] ; # B
  %445 = phi i64 [%411, %$31] ; # R
  %446 = phi i64 [%412, %$31] ; # P
  %447 = phi i64 [%413, %$31] ; # V1
  %448 = phi i64 [%414, %$31] ; # V2
  %449 = phi i64 [%415, %$31] ; # M
  %450 = phi i64 [%416, %$31] ; # N
  %451 = phi i64 [%417, %$31] ; # D
  %452 = phi i64 [%418, %$31] ; # Q
  %453 = phi i64 [%419, %$31] ; # X
  %454 = phi i64 [%420, %$31] ; # U1
  %455 = phi i64 [%421, %$31] ; # U2
  %456 = phi i64 [%422, %$31] ; # U3
  %457 = phi i64 [%420, %$31] ; # Hi
  %458 = phi i64 [%421, %$31] ; # Lo
; # (div Hi Lo V1)
  %459 = zext i64 %457 to i128
  %460 = shl i128 %459, 64
  %461 = zext i64 %458 to i128
  %462 = or i128 %460, %461
  %463 = zext i64 %447 to i128
  %464 = urem i128 %462, %463
  %465 = trunc i128 %464 to i64
  %466 = udiv i128 %462, %463
  %467 = trunc i128 %466 to i64
  br label %$34
$34:
  %468 = phi i64 [%427, %$32], [%443, %$33] ; # A
  %469 = phi i64 [%428, %$32], [%444, %$33] ; # B
  %470 = phi i64 [%429, %$32], [%445, %$33] ; # R
  %471 = phi i64 [%430, %$32], [%446, %$33] ; # P
  %472 = phi i64 [%431, %$32], [%447, %$33] ; # V1
  %473 = phi i64 [%432, %$32], [%448, %$33] ; # V2
  %474 = phi i64 [%433, %$32], [%449, %$33] ; # M
  %475 = phi i64 [%434, %$32], [%450, %$33] ; # N
  %476 = phi i64 [%435, %$32], [%451, %$33] ; # D
  %477 = phi i64 [%436, %$32], [%452, %$33] ; # Q
  %478 = phi i64 [%437, %$32], [%453, %$33] ; # X
  %479 = phi i64 [%438, %$32], [%454, %$33] ; # U1
  %480 = phi i64 [%439, %$32], [%455, %$33] ; # U2
  %481 = phi i64 [%440, %$32], [%456, %$33] ; # U3
  %482 = phi i64 [%441, %$32], [%457, %$33] ; # Hi
  %483 = phi i64 [%442, %$32], [%458, %$33] ; # Lo
  %484 = phi i64 [-1, %$32], [%467, %$33] ; # ->
; # (mul Q V1)
  %485 = zext i64 %484 to i128
  %486 = zext i64 %472 to i128
  %487 = mul i128 %485, %486
  %488 = lshr i128 %487, 64
  %489 = trunc i128 %488 to i64
  %490 = trunc i128 %487 to i64
; # (sub Lo (mul Q V1))
  %491 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %483, i64 %490)
  %492 = extractvalue {i64, i1} %491, 1
  %493 = extractvalue {i64, i1} %491, 0
; # (sub Hi @@@ @@)
  %494 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %482, i64 %489)
  %495 = extractvalue {i64, i1} %494, 1
  %496 = extractvalue {i64, i1} %494, 0
  %497 = zext i1 %492 to i64
  %498 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %496, i64 %497)
  %499 = extractvalue {i64, i1} %498, 1
  %500 = or i1 %495, %499
  %501 = extractvalue {i64, i1} %498, 0
; # (until Hi (let L (mul Q V2) (? (> Lo @@@)) (? (and (== Lo @@@) (>...
  br label %$35
$35:
  %502 = phi i64 [%468, %$34], [%593, %$41] ; # A
  %503 = phi i64 [%469, %$34], [%594, %$41] ; # B
  %504 = phi i64 [%470, %$34], [%595, %$41] ; # R
  %505 = phi i64 [%471, %$34], [%596, %$41] ; # P
  %506 = phi i64 [%472, %$34], [%597, %$41] ; # V1
  %507 = phi i64 [%473, %$34], [%598, %$41] ; # V2
  %508 = phi i64 [%474, %$34], [%599, %$41] ; # M
  %509 = phi i64 [%475, %$34], [%600, %$41] ; # N
  %510 = phi i64 [%476, %$34], [%601, %$41] ; # D
  %511 = phi i64 [%484, %$34], [%609, %$41] ; # Q
  %512 = phi i64 [%478, %$34], [%603, %$41] ; # X
  %513 = phi i64 [%479, %$34], [%604, %$41] ; # U1
  %514 = phi i64 [%480, %$34], [%605, %$41] ; # U2
  %515 = phi i64 [%481, %$34], [%606, %$41] ; # U3
  %516 = phi i64 [%501, %$34], [%614, %$41] ; # Hi
  %517 = phi i64 [%493, %$34], [%612, %$41] ; # Lo
  %518 = icmp ne i64 %516, 0
  br i1 %518, label %$37, label %$36
$36:
  %519 = phi i64 [%502, %$35] ; # A
  %520 = phi i64 [%503, %$35] ; # B
  %521 = phi i64 [%504, %$35] ; # R
  %522 = phi i64 [%505, %$35] ; # P
  %523 = phi i64 [%506, %$35] ; # V1
  %524 = phi i64 [%507, %$35] ; # V2
  %525 = phi i64 [%508, %$35] ; # M
  %526 = phi i64 [%509, %$35] ; # N
  %527 = phi i64 [%510, %$35] ; # D
  %528 = phi i64 [%511, %$35] ; # Q
  %529 = phi i64 [%512, %$35] ; # X
  %530 = phi i64 [%513, %$35] ; # U1
  %531 = phi i64 [%514, %$35] ; # U2
  %532 = phi i64 [%515, %$35] ; # U3
  %533 = phi i64 [%516, %$35] ; # Hi
  %534 = phi i64 [%517, %$35] ; # Lo
; # (let L (mul Q V2) (? (> Lo @@@)) (? (and (== Lo @@@) (>= U3 L))))...
; # (mul Q V2)
  %535 = zext i64 %528 to i128
  %536 = zext i64 %524 to i128
  %537 = mul i128 %535, %536
  %538 = lshr i128 %537, 64
  %539 = trunc i128 %538 to i64
  %540 = trunc i128 %537 to i64
; # (? (> Lo @@@))
; # (> Lo @@@)
  %541 = icmp ugt i64 %534, %539
  br i1 %541, label %$37, label %$38
$38:
  %542 = phi i64 [%519, %$36] ; # A
  %543 = phi i64 [%520, %$36] ; # B
  %544 = phi i64 [%521, %$36] ; # R
  %545 = phi i64 [%522, %$36] ; # P
  %546 = phi i64 [%523, %$36] ; # V1
  %547 = phi i64 [%524, %$36] ; # V2
  %548 = phi i64 [%525, %$36] ; # M
  %549 = phi i64 [%526, %$36] ; # N
  %550 = phi i64 [%527, %$36] ; # D
  %551 = phi i64 [%528, %$36] ; # Q
  %552 = phi i64 [%529, %$36] ; # X
  %553 = phi i64 [%530, %$36] ; # U1
  %554 = phi i64 [%531, %$36] ; # U2
  %555 = phi i64 [%532, %$36] ; # U3
  %556 = phi i64 [%533, %$36] ; # Hi
  %557 = phi i64 [%534, %$36] ; # Lo
; # (? (and (== Lo @@@) (>= U3 L)))
; # (and (== Lo @@@) (>= U3 L))
; # (== Lo @@@)
  %558 = icmp eq i64 %557, %539
  br i1 %558, label %$40, label %$39
$40:
  %559 = phi i64 [%542, %$38] ; # A
  %560 = phi i64 [%543, %$38] ; # B
  %561 = phi i64 [%544, %$38] ; # R
  %562 = phi i64 [%545, %$38] ; # P
  %563 = phi i64 [%546, %$38] ; # V1
  %564 = phi i64 [%547, %$38] ; # V2
  %565 = phi i64 [%548, %$38] ; # M
  %566 = phi i64 [%549, %$38] ; # N
  %567 = phi i64 [%550, %$38] ; # D
  %568 = phi i64 [%551, %$38] ; # Q
  %569 = phi i64 [%552, %$38] ; # X
  %570 = phi i64 [%553, %$38] ; # U1
  %571 = phi i64 [%554, %$38] ; # U2
  %572 = phi i64 [%555, %$38] ; # U3
  %573 = phi i64 [%556, %$38] ; # Hi
  %574 = phi i64 [%557, %$38] ; # Lo
; # (>= U3 L)
  %575 = icmp uge i64 %572, %540
  br label %$39
$39:
  %576 = phi i64 [%542, %$38], [%559, %$40] ; # A
  %577 = phi i64 [%543, %$38], [%560, %$40] ; # B
  %578 = phi i64 [%544, %$38], [%561, %$40] ; # R
  %579 = phi i64 [%545, %$38], [%562, %$40] ; # P
  %580 = phi i64 [%546, %$38], [%563, %$40] ; # V1
  %581 = phi i64 [%547, %$38], [%564, %$40] ; # V2
  %582 = phi i64 [%548, %$38], [%565, %$40] ; # M
  %583 = phi i64 [%549, %$38], [%566, %$40] ; # N
  %584 = phi i64 [%550, %$38], [%567, %$40] ; # D
  %585 = phi i64 [%551, %$38], [%568, %$40] ; # Q
  %586 = phi i64 [%552, %$38], [%569, %$40] ; # X
  %587 = phi i64 [%553, %$38], [%570, %$40] ; # U1
  %588 = phi i64 [%554, %$38], [%571, %$40] ; # U2
  %589 = phi i64 [%555, %$38], [%572, %$40] ; # U3
  %590 = phi i64 [%556, %$38], [%573, %$40] ; # Hi
  %591 = phi i64 [%557, %$38], [%574, %$40] ; # Lo
  %592 = phi i1 [0, %$38], [%575, %$40] ; # ->
  br i1 %592, label %$37, label %$41
$41:
  %593 = phi i64 [%576, %$39] ; # A
  %594 = phi i64 [%577, %$39] ; # B
  %595 = phi i64 [%578, %$39] ; # R
  %596 = phi i64 [%579, %$39] ; # P
  %597 = phi i64 [%580, %$39] ; # V1
  %598 = phi i64 [%581, %$39] ; # V2
  %599 = phi i64 [%582, %$39] ; # M
  %600 = phi i64 [%583, %$39] ; # N
  %601 = phi i64 [%584, %$39] ; # D
  %602 = phi i64 [%585, %$39] ; # Q
  %603 = phi i64 [%586, %$39] ; # X
  %604 = phi i64 [%587, %$39] ; # U1
  %605 = phi i64 [%588, %$39] ; # U2
  %606 = phi i64 [%589, %$39] ; # U3
  %607 = phi i64 [%590, %$39] ; # Hi
  %608 = phi i64 [%591, %$39] ; # Lo
; # (dec 'Q)
  %609 = sub i64 %602, 1
; # (add Lo V1)
  %610 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %608, i64 %597)
  %611 = extractvalue {i64, i1} %610, 1
  %612 = extractvalue {i64, i1} %610, 0
; # (+ Hi @@)
  %613 = zext i1 %611 to i64
  %614 = add i64 %607, %613
  br label %$35
$37:
  %615 = phi i64 [%502, %$35], [%519, %$36], [%576, %$39] ; # A
  %616 = phi i64 [%503, %$35], [%520, %$36], [%577, %$39] ; # B
  %617 = phi i64 [%504, %$35], [%521, %$36], [%578, %$39] ; # R
  %618 = phi i64 [%505, %$35], [%522, %$36], [%579, %$39] ; # P
  %619 = phi i64 [%506, %$35], [%523, %$36], [%580, %$39] ; # V1
  %620 = phi i64 [%507, %$35], [%524, %$36], [%581, %$39] ; # V2
  %621 = phi i64 [%508, %$35], [%525, %$36], [%582, %$39] ; # M
  %622 = phi i64 [%509, %$35], [%526, %$36], [%583, %$39] ; # N
  %623 = phi i64 [%510, %$35], [%527, %$36], [%584, %$39] ; # D
  %624 = phi i64 [%511, %$35], [%528, %$36], [%585, %$39] ; # Q
  %625 = phi i64 [%512, %$35], [%529, %$36], [%586, %$39] ; # X
  %626 = phi i64 [%513, %$35], [%530, %$36], [%587, %$39] ; # U1
  %627 = phi i64 [%514, %$35], [%531, %$36], [%588, %$39] ; # U2
  %628 = phi i64 [%515, %$35], [%532, %$36], [%589, %$39] ; # U3
  %629 = phi i64 [%516, %$35], [%533, %$36], [%590, %$39] ; # Hi
  %630 = phi i64 [%517, %$35], [%534, %$36], [%591, %$39] ; # Lo
; # (let (Z X Y (val V)) (set (dig Z) (sub (val (dig Z)) (mul Q (val ...
; # (val V)
  %631 = inttoptr i64 %24 to i64*
  %632 = load i64, i64* %631
; # (set (dig Z) (sub (val (dig Z)) (mul Q (val (dig Y)))))
; # (dig Z)
  %633 = add i64 %625, -4
; # (dig Z)
  %634 = add i64 %625, -4
; # (val (dig Z))
  %635 = inttoptr i64 %634 to i64*
  %636 = load i64, i64* %635
; # (dig Y)
  %637 = add i64 %632, -4
; # (val (dig Y))
  %638 = inttoptr i64 %637 to i64*
  %639 = load i64, i64* %638
; # (mul Q (val (dig Y)))
  %640 = zext i64 %624 to i128
  %641 = zext i64 %639 to i128
  %642 = mul i128 %640, %641
  %643 = lshr i128 %642, 64
  %644 = trunc i128 %643 to i64
  %645 = trunc i128 %642 to i64
; # (sub (val (dig Z)) (mul Q (val (dig Y))))
  %646 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %636, i64 %645)
  %647 = extractvalue {i64, i1} %646, 1
  %648 = extractvalue {i64, i1} %646, 0
  %649 = inttoptr i64 %633 to i64*
  store i64 %648, i64* %649
; # (+ @@@ @@)
  %650 = zext i1 %647 to i64
  %651 = add i64 %644, %650
; # (while (big? (setq Y (val (big Y)))) (setq Z (val (big Z))) (set ...
  br label %$42
$42:
  %652 = phi i64 [%615, %$37], [%675, %$43] ; # A
  %653 = phi i64 [%616, %$37], [%676, %$43] ; # B
  %654 = phi i64 [%617, %$37], [%677, %$43] ; # R
  %655 = phi i64 [%618, %$37], [%678, %$43] ; # P
  %656 = phi i64 [%619, %$37], [%679, %$43] ; # V1
  %657 = phi i64 [%620, %$37], [%680, %$43] ; # V2
  %658 = phi i64 [%621, %$37], [%681, %$43] ; # M
  %659 = phi i64 [%622, %$37], [%682, %$43] ; # N
  %660 = phi i64 [%623, %$37], [%683, %$43] ; # D
  %661 = phi i64 [%624, %$37], [%684, %$43] ; # Q
  %662 = phi i64 [%625, %$37], [%685, %$43] ; # X
  %663 = phi i64 [%626, %$37], [%686, %$43] ; # U1
  %664 = phi i64 [%627, %$37], [%687, %$43] ; # U2
  %665 = phi i64 [%628, %$37], [%688, %$43] ; # U3
  %666 = phi i64 [%651, %$37], [%732, %$43] ; # Hi
  %667 = phi i64 [%630, %$37], [%690, %$43] ; # Lo
  %668 = phi i64 [%625, %$37], [%695, %$43] ; # Z
  %669 = phi i64 [%632, %$37], [%692, %$43] ; # Y
; # (big Y)
  %670 = add i64 %669, 4
; # (val (big Y))
  %671 = inttoptr i64 %670 to i64*
  %672 = load i64, i64* %671
; # (big? (setq Y (val (big Y))))
  %673 = and i64 %672, 4
  %674 = icmp ne i64 %673, 0
  br i1 %674, label %$43, label %$44
$43:
  %675 = phi i64 [%652, %$42] ; # A
  %676 = phi i64 [%653, %$42] ; # B
  %677 = phi i64 [%654, %$42] ; # R
  %678 = phi i64 [%655, %$42] ; # P
  %679 = phi i64 [%656, %$42] ; # V1
  %680 = phi i64 [%657, %$42] ; # V2
  %681 = phi i64 [%658, %$42] ; # M
  %682 = phi i64 [%659, %$42] ; # N
  %683 = phi i64 [%660, %$42] ; # D
  %684 = phi i64 [%661, %$42] ; # Q
  %685 = phi i64 [%662, %$42] ; # X
  %686 = phi i64 [%663, %$42] ; # U1
  %687 = phi i64 [%664, %$42] ; # U2
  %688 = phi i64 [%665, %$42] ; # U3
  %689 = phi i64 [%666, %$42] ; # Hi
  %690 = phi i64 [%667, %$42] ; # Lo
  %691 = phi i64 [%668, %$42] ; # Z
  %692 = phi i64 [%672, %$42] ; # Y
; # (big Z)
  %693 = add i64 %691, 4
; # (val (big Z))
  %694 = inttoptr i64 %693 to i64*
  %695 = load i64, i64* %694
; # (set (dig Z) (sub (val (dig Z)) Hi))
; # (dig Z)
  %696 = add i64 %695, -4
; # (dig Z)
  %697 = add i64 %695, -4
; # (val (dig Z))
  %698 = inttoptr i64 %697 to i64*
  %699 = load i64, i64* %698
; # (sub (val (dig Z)) Hi)
  %700 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %699, i64 %689)
  %701 = extractvalue {i64, i1} %700, 1
  %702 = extractvalue {i64, i1} %700, 0
  %703 = inttoptr i64 %696 to i64*
  store i64 %702, i64* %703
; # (- Hi Hi @@)
  %704 = sub i64 %689, %689
  %705 = zext i1 %701 to i64
  %706 = sub i64 %704, %705
; # (set (dig Z) (sub (val (dig Z)) (mul Q (val (dig Y)))))
; # (dig Z)
  %707 = add i64 %695, -4
; # (dig Z)
  %708 = add i64 %695, -4
; # (val (dig Z))
  %709 = inttoptr i64 %708 to i64*
  %710 = load i64, i64* %709
; # (dig Y)
  %711 = add i64 %692, -4
; # (val (dig Y))
  %712 = inttoptr i64 %711 to i64*
  %713 = load i64, i64* %712
; # (mul Q (val (dig Y)))
  %714 = zext i64 %684 to i128
  %715 = zext i64 %713 to i128
  %716 = mul i128 %714, %715
  %717 = lshr i128 %716, 64
  %718 = trunc i128 %717 to i64
  %719 = trunc i128 %716 to i64
; # (sub (val (dig Z)) (mul Q (val (dig Y))))
  %720 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %710, i64 %719)
  %721 = extractvalue {i64, i1} %720, 1
  %722 = extractvalue {i64, i1} %720, 0
  %723 = inttoptr i64 %707 to i64*
  store i64 %722, i64* %723
; # (sub Hi @@@ @@)
  %724 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %706, i64 %718)
  %725 = extractvalue {i64, i1} %724, 1
  %726 = extractvalue {i64, i1} %724, 0
  %727 = zext i1 %721 to i64
  %728 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %726, i64 %727)
  %729 = extractvalue {i64, i1} %728, 1
  %730 = or i1 %725, %729
  %731 = extractvalue {i64, i1} %728, 0
; # (- (sub Hi @@@ @@))
  %732 = sub i64 0, %731
  br label %$42
$44:
  %733 = phi i64 [%652, %$42] ; # A
  %734 = phi i64 [%653, %$42] ; # B
  %735 = phi i64 [%654, %$42] ; # R
  %736 = phi i64 [%655, %$42] ; # P
  %737 = phi i64 [%656, %$42] ; # V1
  %738 = phi i64 [%657, %$42] ; # V2
  %739 = phi i64 [%658, %$42] ; # M
  %740 = phi i64 [%659, %$42] ; # N
  %741 = phi i64 [%660, %$42] ; # D
  %742 = phi i64 [%661, %$42] ; # Q
  %743 = phi i64 [%662, %$42] ; # X
  %744 = phi i64 [%663, %$42] ; # U1
  %745 = phi i64 [%664, %$42] ; # U2
  %746 = phi i64 [%665, %$42] ; # U3
  %747 = phi i64 [%666, %$42] ; # Hi
  %748 = phi i64 [%667, %$42] ; # Lo
  %749 = phi i64 [%668, %$42] ; # Z
  %750 = phi i64 [%672, %$42] ; # Y
; # (when Hi (setq Z (val (big Z))) (set (dig Z) (sub (val (dig Z)) H...
  %751 = icmp ne i64 %747, 0
  br i1 %751, label %$45, label %$46
$45:
  %752 = phi i64 [%733, %$44] ; # A
  %753 = phi i64 [%734, %$44] ; # B
  %754 = phi i64 [%735, %$44] ; # R
  %755 = phi i64 [%736, %$44] ; # P
  %756 = phi i64 [%737, %$44] ; # V1
  %757 = phi i64 [%738, %$44] ; # V2
  %758 = phi i64 [%739, %$44] ; # M
  %759 = phi i64 [%740, %$44] ; # N
  %760 = phi i64 [%741, %$44] ; # D
  %761 = phi i64 [%742, %$44] ; # Q
  %762 = phi i64 [%743, %$44] ; # X
  %763 = phi i64 [%744, %$44] ; # U1
  %764 = phi i64 [%745, %$44] ; # U2
  %765 = phi i64 [%746, %$44] ; # U3
  %766 = phi i64 [%747, %$44] ; # Hi
  %767 = phi i64 [%748, %$44] ; # Lo
  %768 = phi i64 [%749, %$44] ; # Z
  %769 = phi i64 [%750, %$44] ; # Y
; # (big Z)
  %770 = add i64 %768, 4
; # (val (big Z))
  %771 = inttoptr i64 %770 to i64*
  %772 = load i64, i64* %771
; # (set (dig Z) (sub (val (dig Z)) Hi))
; # (dig Z)
  %773 = add i64 %772, -4
; # (dig Z)
  %774 = add i64 %772, -4
; # (val (dig Z))
  %775 = inttoptr i64 %774 to i64*
  %776 = load i64, i64* %775
; # (sub (val (dig Z)) Hi)
  %777 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %776, i64 %766)
  %778 = extractvalue {i64, i1} %777, 1
  %779 = extractvalue {i64, i1} %777, 0
  %780 = inttoptr i64 %773 to i64*
  store i64 %779, i64* %780
; # (when @@ (dec 'Q) (when (or Rem M) (setq Y (val V)) (set (dig X) ...
  br i1 %778, label %$47, label %$48
$47:
  %781 = phi i64 [%752, %$45] ; # A
  %782 = phi i64 [%753, %$45] ; # B
  %783 = phi i64 [%754, %$45] ; # R
  %784 = phi i64 [%755, %$45] ; # P
  %785 = phi i64 [%756, %$45] ; # V1
  %786 = phi i64 [%757, %$45] ; # V2
  %787 = phi i64 [%758, %$45] ; # M
  %788 = phi i64 [%759, %$45] ; # N
  %789 = phi i64 [%760, %$45] ; # D
  %790 = phi i64 [%761, %$45] ; # Q
  %791 = phi i64 [%762, %$45] ; # X
  %792 = phi i64 [%763, %$45] ; # U1
  %793 = phi i64 [%764, %$45] ; # U2
  %794 = phi i64 [%765, %$45] ; # U3
  %795 = phi i64 [%766, %$45] ; # Hi
  %796 = phi i64 [%767, %$45] ; # Lo
  %797 = phi i64 [%772, %$45] ; # Z
  %798 = phi i64 [%769, %$45] ; # Y
; # (dec 'Q)
  %799 = sub i64 %790, 1
; # (when (or Rem M) (setq Y (val V)) (set (dig X) (add (val (dig X))...
; # (or Rem M)
  br i1 %2, label %$49, label %$50
$50:
  %800 = phi i64 [%781, %$47] ; # A
  %801 = phi i64 [%782, %$47] ; # B
  %802 = phi i64 [%783, %$47] ; # R
  %803 = phi i64 [%784, %$47] ; # P
  %804 = phi i64 [%785, %$47] ; # V1
  %805 = phi i64 [%786, %$47] ; # V2
  %806 = phi i64 [%787, %$47] ; # M
  %807 = phi i64 [%788, %$47] ; # N
  %808 = phi i64 [%789, %$47] ; # D
  %809 = phi i64 [%799, %$47] ; # Q
  %810 = phi i64 [%791, %$47] ; # X
  %811 = phi i64 [%792, %$47] ; # U1
  %812 = phi i64 [%793, %$47] ; # U2
  %813 = phi i64 [%794, %$47] ; # U3
  %814 = phi i64 [%795, %$47] ; # Hi
  %815 = phi i64 [%796, %$47] ; # Lo
  %816 = phi i64 [%797, %$47] ; # Z
  %817 = phi i64 [%798, %$47] ; # Y
  %818 = icmp ne i64 %806, 0
  br label %$49
$49:
  %819 = phi i64 [%781, %$47], [%800, %$50] ; # A
  %820 = phi i64 [%782, %$47], [%801, %$50] ; # B
  %821 = phi i64 [%783, %$47], [%802, %$50] ; # R
  %822 = phi i64 [%784, %$47], [%803, %$50] ; # P
  %823 = phi i64 [%785, %$47], [%804, %$50] ; # V1
  %824 = phi i64 [%786, %$47], [%805, %$50] ; # V2
  %825 = phi i64 [%787, %$47], [%806, %$50] ; # M
  %826 = phi i64 [%788, %$47], [%807, %$50] ; # N
  %827 = phi i64 [%789, %$47], [%808, %$50] ; # D
  %828 = phi i64 [%799, %$47], [%809, %$50] ; # Q
  %829 = phi i64 [%791, %$47], [%810, %$50] ; # X
  %830 = phi i64 [%792, %$47], [%811, %$50] ; # U1
  %831 = phi i64 [%793, %$47], [%812, %$50] ; # U2
  %832 = phi i64 [%794, %$47], [%813, %$50] ; # U3
  %833 = phi i64 [%795, %$47], [%814, %$50] ; # Hi
  %834 = phi i64 [%796, %$47], [%815, %$50] ; # Lo
  %835 = phi i64 [%797, %$47], [%816, %$50] ; # Z
  %836 = phi i64 [%798, %$47], [%817, %$50] ; # Y
  %837 = phi i1 [1, %$47], [%818, %$50] ; # ->
  br i1 %837, label %$51, label %$52
$51:
  %838 = phi i64 [%819, %$49] ; # A
  %839 = phi i64 [%820, %$49] ; # B
  %840 = phi i64 [%821, %$49] ; # R
  %841 = phi i64 [%822, %$49] ; # P
  %842 = phi i64 [%823, %$49] ; # V1
  %843 = phi i64 [%824, %$49] ; # V2
  %844 = phi i64 [%825, %$49] ; # M
  %845 = phi i64 [%826, %$49] ; # N
  %846 = phi i64 [%827, %$49] ; # D
  %847 = phi i64 [%828, %$49] ; # Q
  %848 = phi i64 [%829, %$49] ; # X
  %849 = phi i64 [%830, %$49] ; # U1
  %850 = phi i64 [%831, %$49] ; # U2
  %851 = phi i64 [%832, %$49] ; # U3
  %852 = phi i64 [%833, %$49] ; # Hi
  %853 = phi i64 [%834, %$49] ; # Lo
  %854 = phi i64 [%835, %$49] ; # Z
  %855 = phi i64 [%836, %$49] ; # Y
; # (val V)
  %856 = inttoptr i64 %24 to i64*
  %857 = load i64, i64* %856
; # (set (dig X) (add (val (dig X)) (val (dig Y))))
; # (dig X)
  %858 = add i64 %848, -4
; # (dig X)
  %859 = add i64 %848, -4
; # (val (dig X))
  %860 = inttoptr i64 %859 to i64*
  %861 = load i64, i64* %860
; # (dig Y)
  %862 = add i64 %857, -4
; # (val (dig Y))
  %863 = inttoptr i64 %862 to i64*
  %864 = load i64, i64* %863
; # (add (val (dig X)) (val (dig Y)))
  %865 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %861, i64 %864)
  %866 = extractvalue {i64, i1} %865, 1
  %867 = extractvalue {i64, i1} %865, 0
  %868 = inttoptr i64 %858 to i64*
  store i64 %867, i64* %868
; # (let C @@ (loop (setq X (val (big X))) (? (cnt? (setq Y (val (big...
; # (loop (setq X (val (big X))) (? (cnt? (setq Y (val (big Y))))) (s...
  br label %$53
$53:
  %869 = phi i64 [%838, %$51], [%896, %$54] ; # A
  %870 = phi i64 [%839, %$51], [%897, %$54] ; # B
  %871 = phi i64 [%840, %$51], [%898, %$54] ; # R
  %872 = phi i64 [%841, %$51], [%899, %$54] ; # P
  %873 = phi i64 [%842, %$51], [%900, %$54] ; # V1
  %874 = phi i64 [%843, %$51], [%901, %$54] ; # V2
  %875 = phi i64 [%844, %$51], [%902, %$54] ; # M
  %876 = phi i64 [%845, %$51], [%903, %$54] ; # N
  %877 = phi i64 [%846, %$51], [%904, %$54] ; # D
  %878 = phi i64 [%847, %$51], [%905, %$54] ; # Q
  %879 = phi i64 [%848, %$51], [%906, %$54] ; # X
  %880 = phi i64 [%849, %$51], [%907, %$54] ; # U1
  %881 = phi i64 [%850, %$51], [%908, %$54] ; # U2
  %882 = phi i64 [%851, %$51], [%909, %$54] ; # U3
  %883 = phi i64 [%852, %$51], [%910, %$54] ; # Hi
  %884 = phi i64 [%853, %$51], [%911, %$54] ; # Lo
  %885 = phi i64 [%854, %$51], [%912, %$54] ; # Z
  %886 = phi i64 [%857, %$51], [%913, %$54] ; # Y
  %887 = phi i1 [%866, %$51], [%928, %$54] ; # C
; # (big X)
  %888 = add i64 %879, 4
; # (val (big X))
  %889 = inttoptr i64 %888 to i64*
  %890 = load i64, i64* %889
; # (? (cnt? (setq Y (val (big Y)))))
; # (big Y)
  %891 = add i64 %886, 4
; # (val (big Y))
  %892 = inttoptr i64 %891 to i64*
  %893 = load i64, i64* %892
; # (cnt? (setq Y (val (big Y))))
  %894 = and i64 %893, 2
  %895 = icmp ne i64 %894, 0
  br i1 %895, label %$55, label %$54
$54:
  %896 = phi i64 [%869, %$53] ; # A
  %897 = phi i64 [%870, %$53] ; # B
  %898 = phi i64 [%871, %$53] ; # R
  %899 = phi i64 [%872, %$53] ; # P
  %900 = phi i64 [%873, %$53] ; # V1
  %901 = phi i64 [%874, %$53] ; # V2
  %902 = phi i64 [%875, %$53] ; # M
  %903 = phi i64 [%876, %$53] ; # N
  %904 = phi i64 [%877, %$53] ; # D
  %905 = phi i64 [%878, %$53] ; # Q
  %906 = phi i64 [%890, %$53] ; # X
  %907 = phi i64 [%880, %$53] ; # U1
  %908 = phi i64 [%881, %$53] ; # U2
  %909 = phi i64 [%882, %$53] ; # U3
  %910 = phi i64 [%883, %$53] ; # Hi
  %911 = phi i64 [%884, %$53] ; # Lo
  %912 = phi i64 [%885, %$53] ; # Z
  %913 = phi i64 [%893, %$53] ; # Y
  %914 = phi i1 [%887, %$53] ; # C
; # (set (dig X) (add (val (dig X)) (val (dig Y)) C))
; # (dig X)
  %915 = add i64 %906, -4
; # (dig X)
  %916 = add i64 %906, -4
; # (val (dig X))
  %917 = inttoptr i64 %916 to i64*
  %918 = load i64, i64* %917
; # (dig Y)
  %919 = add i64 %913, -4
; # (val (dig Y))
  %920 = inttoptr i64 %919 to i64*
  %921 = load i64, i64* %920
; # (add (val (dig X)) (val (dig Y)) C)
  %922 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %918, i64 %921)
  %923 = extractvalue {i64, i1} %922, 1
  %924 = extractvalue {i64, i1} %922, 0
  %925 = zext i1 %914 to i64
  %926 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %924, i64 %925)
  %927 = extractvalue {i64, i1} %926, 1
  %928 = or i1 %923, %927
  %929 = extractvalue {i64, i1} %926, 0
  %930 = inttoptr i64 %915 to i64*
  store i64 %929, i64* %930
  br label %$53
$55:
  %931 = phi i64 [%869, %$53] ; # A
  %932 = phi i64 [%870, %$53] ; # B
  %933 = phi i64 [%871, %$53] ; # R
  %934 = phi i64 [%872, %$53] ; # P
  %935 = phi i64 [%873, %$53] ; # V1
  %936 = phi i64 [%874, %$53] ; # V2
  %937 = phi i64 [%875, %$53] ; # M
  %938 = phi i64 [%876, %$53] ; # N
  %939 = phi i64 [%877, %$53] ; # D
  %940 = phi i64 [%878, %$53] ; # Q
  %941 = phi i64 [%890, %$53] ; # X
  %942 = phi i64 [%880, %$53] ; # U1
  %943 = phi i64 [%881, %$53] ; # U2
  %944 = phi i64 [%882, %$53] ; # U3
  %945 = phi i64 [%883, %$53] ; # Hi
  %946 = phi i64 [%884, %$53] ; # Lo
  %947 = phi i64 [%885, %$53] ; # Z
  %948 = phi i64 [%893, %$53] ; # Y
  %949 = phi i1 [%887, %$53] ; # C
  %950 = phi i64 [0, %$53] ; # ->
; # (set (dig X) (+ (val (dig X)) C))
; # (dig X)
  %951 = add i64 %941, -4
; # (dig X)
  %952 = add i64 %941, -4
; # (val (dig X))
  %953 = inttoptr i64 %952 to i64*
  %954 = load i64, i64* %953
; # (+ (val (dig X)) C)
  %955 = zext i1 %949 to i64
  %956 = add i64 %954, %955
  %957 = inttoptr i64 %951 to i64*
  store i64 %956, i64* %957
  br label %$52
$52:
  %958 = phi i64 [%819, %$49], [%931, %$55] ; # A
  %959 = phi i64 [%820, %$49], [%932, %$55] ; # B
  %960 = phi i64 [%821, %$49], [%933, %$55] ; # R
  %961 = phi i64 [%822, %$49], [%934, %$55] ; # P
  %962 = phi i64 [%823, %$49], [%935, %$55] ; # V1
  %963 = phi i64 [%824, %$49], [%936, %$55] ; # V2
  %964 = phi i64 [%825, %$49], [%937, %$55] ; # M
  %965 = phi i64 [%826, %$49], [%938, %$55] ; # N
  %966 = phi i64 [%827, %$49], [%939, %$55] ; # D
  %967 = phi i64 [%828, %$49], [%940, %$55] ; # Q
  %968 = phi i64 [%829, %$49], [%941, %$55] ; # X
  %969 = phi i64 [%830, %$49], [%942, %$55] ; # U1
  %970 = phi i64 [%831, %$49], [%943, %$55] ; # U2
  %971 = phi i64 [%832, %$49], [%944, %$55] ; # U3
  %972 = phi i64 [%833, %$49], [%945, %$55] ; # Hi
  %973 = phi i64 [%834, %$49], [%946, %$55] ; # Lo
  %974 = phi i64 [%835, %$49], [%947, %$55] ; # Z
  %975 = phi i64 [%836, %$49], [%948, %$55] ; # Y
  br label %$48
$48:
  %976 = phi i64 [%752, %$45], [%958, %$52] ; # A
  %977 = phi i64 [%753, %$45], [%959, %$52] ; # B
  %978 = phi i64 [%754, %$45], [%960, %$52] ; # R
  %979 = phi i64 [%755, %$45], [%961, %$52] ; # P
  %980 = phi i64 [%756, %$45], [%962, %$52] ; # V1
  %981 = phi i64 [%757, %$45], [%963, %$52] ; # V2
  %982 = phi i64 [%758, %$45], [%964, %$52] ; # M
  %983 = phi i64 [%759, %$45], [%965, %$52] ; # N
  %984 = phi i64 [%760, %$45], [%966, %$52] ; # D
  %985 = phi i64 [%761, %$45], [%967, %$52] ; # Q
  %986 = phi i64 [%762, %$45], [%968, %$52] ; # X
  %987 = phi i64 [%763, %$45], [%969, %$52] ; # U1
  %988 = phi i64 [%764, %$45], [%970, %$52] ; # U2
  %989 = phi i64 [%765, %$45], [%971, %$52] ; # U3
  %990 = phi i64 [%766, %$45], [%972, %$52] ; # Hi
  %991 = phi i64 [%767, %$45], [%973, %$52] ; # Lo
  %992 = phi i64 [%772, %$45], [%974, %$52] ; # Z
  %993 = phi i64 [%769, %$45], [%975, %$52] ; # Y
  br label %$46
$46:
  %994 = phi i64 [%733, %$44], [%976, %$48] ; # A
  %995 = phi i64 [%734, %$44], [%977, %$48] ; # B
  %996 = phi i64 [%735, %$44], [%978, %$48] ; # R
  %997 = phi i64 [%736, %$44], [%979, %$48] ; # P
  %998 = phi i64 [%737, %$44], [%980, %$48] ; # V1
  %999 = phi i64 [%738, %$44], [%981, %$48] ; # V2
  %1000 = phi i64 [%739, %$44], [%982, %$48] ; # M
  %1001 = phi i64 [%740, %$44], [%983, %$48] ; # N
  %1002 = phi i64 [%741, %$44], [%984, %$48] ; # D
  %1003 = phi i64 [%742, %$44], [%985, %$48] ; # Q
  %1004 = phi i64 [%743, %$44], [%986, %$48] ; # X
  %1005 = phi i64 [%744, %$44], [%987, %$48] ; # U1
  %1006 = phi i64 [%745, %$44], [%988, %$48] ; # U2
  %1007 = phi i64 [%746, %$44], [%989, %$48] ; # U3
  %1008 = phi i64 [%747, %$44], [%990, %$48] ; # Hi
  %1009 = phi i64 [%748, %$44], [%991, %$48] ; # Lo
  %1010 = phi i64 [%749, %$44], [%992, %$48] ; # Z
  %1011 = phi i64 [%750, %$44], [%993, %$48] ; # Y
; # (consNum Q R)
  %1012 = call i64 @consNum(i64 %1003, i64 %996)
; # (safe (consNum Q R))
  %1013 = inttoptr i64 %6 to i64*
  store i64 %1012, i64* %1013
; # (? (lt0 (dec 'M)))
; # (dec 'M)
  %1014 = sub i64 %1000, 1
; # (lt0 (dec 'M))
  %1015 = icmp slt i64 %1014, 0
  br i1 %1015, label %$57, label %$56
$56:
  %1016 = phi i64 [%994, %$46] ; # A
  %1017 = phi i64 [%995, %$46] ; # B
  %1018 = phi i64 [%1012, %$46] ; # R
  %1019 = phi i64 [%997, %$46] ; # P
  %1020 = phi i64 [%998, %$46] ; # V1
  %1021 = phi i64 [%999, %$46] ; # V2
  %1022 = phi i64 [%1014, %$46] ; # M
  %1023 = phi i64 [%1001, %$46] ; # N
  %1024 = phi i64 [%1002, %$46] ; # D
  %1025 = phi i64 [%1003, %$46] ; # Q
  br label %$25
$57:
  %1026 = phi i64 [%994, %$46] ; # A
  %1027 = phi i64 [%995, %$46] ; # B
  %1028 = phi i64 [%1012, %$46] ; # R
  %1029 = phi i64 [%997, %$46] ; # P
  %1030 = phi i64 [%998, %$46] ; # V1
  %1031 = phi i64 [%999, %$46] ; # V2
  %1032 = phi i64 [%1014, %$46] ; # M
  %1033 = phi i64 [%1001, %$46] ; # N
  %1034 = phi i64 [%1002, %$46] ; # D
  %1035 = phi i64 [%1003, %$46] ; # Q
  %1036 = phi i64 [0, %$46] ; # ->
; # (ifn Rem (zapZero R) (setq A (zapZero (val U))) (while D (setq A ...
  br i1 %2, label %$59, label %$58
$58:
  %1037 = phi i64 [%1026, %$57] ; # A
  %1038 = phi i64 [%1027, %$57] ; # B
  %1039 = phi i64 [%1028, %$57] ; # R
  %1040 = phi i64 [%1029, %$57] ; # P
  %1041 = phi i64 [%1030, %$57] ; # V1
  %1042 = phi i64 [%1031, %$57] ; # V2
  %1043 = phi i64 [%1032, %$57] ; # M
  %1044 = phi i64 [%1033, %$57] ; # N
  %1045 = phi i64 [%1034, %$57] ; # D
  %1046 = phi i64 [%1035, %$57] ; # Q
; # (zapZero R)
  %1047 = call i64 @zapZero(i64 %1039)
  br label %$60
$59:
  %1048 = phi i64 [%1026, %$57] ; # A
  %1049 = phi i64 [%1027, %$57] ; # B
  %1050 = phi i64 [%1028, %$57] ; # R
  %1051 = phi i64 [%1029, %$57] ; # P
  %1052 = phi i64 [%1030, %$57] ; # V1
  %1053 = phi i64 [%1031, %$57] ; # V2
  %1054 = phi i64 [%1032, %$57] ; # M
  %1055 = phi i64 [%1033, %$57] ; # N
  %1056 = phi i64 [%1034, %$57] ; # D
  %1057 = phi i64 [%1035, %$57] ; # Q
; # (val U)
  %1058 = inttoptr i64 %16 to i64*
  %1059 = load i64, i64* %1058
; # (zapZero (val U))
  %1060 = call i64 @zapZero(i64 %1059)
; # (while D (setq A (half A)) (dec 'D))
  br label %$61
$61:
  %1061 = phi i64 [%1060, %$59], [%1082, %$62] ; # A
  %1062 = phi i64 [%1049, %$59], [%1073, %$62] ; # B
  %1063 = phi i64 [%1050, %$59], [%1074, %$62] ; # R
  %1064 = phi i64 [%1051, %$59], [%1075, %$62] ; # P
  %1065 = phi i64 [%1052, %$59], [%1076, %$62] ; # V1
  %1066 = phi i64 [%1053, %$59], [%1077, %$62] ; # V2
  %1067 = phi i64 [%1054, %$59], [%1078, %$62] ; # M
  %1068 = phi i64 [%1055, %$59], [%1079, %$62] ; # N
  %1069 = phi i64 [%1056, %$59], [%1083, %$62] ; # D
  %1070 = phi i64 [%1057, %$59], [%1081, %$62] ; # Q
  %1071 = icmp ne i64 %1069, 0
  br i1 %1071, label %$62, label %$63
$62:
  %1072 = phi i64 [%1061, %$61] ; # A
  %1073 = phi i64 [%1062, %$61] ; # B
  %1074 = phi i64 [%1063, %$61] ; # R
  %1075 = phi i64 [%1064, %$61] ; # P
  %1076 = phi i64 [%1065, %$61] ; # V1
  %1077 = phi i64 [%1066, %$61] ; # V2
  %1078 = phi i64 [%1067, %$61] ; # M
  %1079 = phi i64 [%1068, %$61] ; # N
  %1080 = phi i64 [%1069, %$61] ; # D
  %1081 = phi i64 [%1070, %$61] ; # Q
; # (half A)
  %1082 = call i64 @half(i64 %1072)
; # (dec 'D)
  %1083 = sub i64 %1080, 1
  br label %$61
$63:
  %1084 = phi i64 [%1061, %$61] ; # A
  %1085 = phi i64 [%1062, %$61] ; # B
  %1086 = phi i64 [%1063, %$61] ; # R
  %1087 = phi i64 [%1064, %$61] ; # P
  %1088 = phi i64 [%1065, %$61] ; # V1
  %1089 = phi i64 [%1066, %$61] ; # V2
  %1090 = phi i64 [%1067, %$61] ; # M
  %1091 = phi i64 [%1068, %$61] ; # N
  %1092 = phi i64 [%1069, %$61] ; # D
  %1093 = phi i64 [%1070, %$61] ; # Q
  br label %$60
$60:
  %1094 = phi i64 [%1037, %$58], [%1084, %$63] ; # A
  %1095 = phi i64 [%1038, %$58], [%1085, %$63] ; # B
  %1096 = phi i64 [%1039, %$58], [%1086, %$63] ; # R
  %1097 = phi i64 [%1040, %$58], [%1087, %$63] ; # P
  %1098 = phi i64 [%1041, %$58], [%1088, %$63] ; # V1
  %1099 = phi i64 [%1042, %$58], [%1089, %$63] ; # V2
  %1100 = phi i64 [%1043, %$58], [%1090, %$63] ; # M
  %1101 = phi i64 [%1044, %$58], [%1091, %$63] ; # N
  %1102 = phi i64 [%1045, %$58], [%1092, %$63] ; # D
  %1103 = phi i64 [%1046, %$58], [%1093, %$63] ; # Q
  %1104 = phi i64 [%1047, %$58], [%1084, %$63] ; # ->
; # (drop *Safe)
  %1105 = inttoptr i64 %6 to i64*
  %1106 = getelementptr i64, i64* %1105, i32 1
  %1107 = load i64, i64* %1106
  %1108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %1107, i64* %1108
  ret i64 %1104
}

define i64 @divu(i64, i64) align 8 {
$1:
; # (cond ((big? A) (div1 A B NO)) ((big? B) ZERO) (T (cnt (/ (int A)...
; # (big? A)
  %2 = and i64 %0, 4
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
; # (div1 A B NO)
  %4 = call i64 @div1(i64 %0, i64 %1, i1 0)
  br label %$2
$3:
; # (big? B)
  %5 = and i64 %1, 4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  br label %$2
$5:
; # (int A)
  %7 = lshr i64 %0, 4
; # (int B)
  %8 = lshr i64 %1, 4
; # (/ (int A) (int B))
  %9 = udiv i64 %7, %8
; # (cnt (/ (int A) (int B)))
  %10 = shl i64 %9, 4
  %11 = or i64 %10, 2
  br label %$2
$2:
  %12 = phi i64 [%4, %$4], [2, %$6], [%11, %$5] ; # ->
  ret i64 %12
}

define i64 @remu(i64, i64) align 8 {
$1:
; # (cond ((big? A) (div1 A B YES)) ((big? B) A) (T (cnt (% (int A) (...
; # (big? A)
  %2 = and i64 %0, 4
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
; # (div1 A B YES)
  %4 = call i64 @div1(i64 %0, i64 %1, i1 1)
  br label %$2
$3:
; # (big? B)
  %5 = and i64 %1, 4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  br label %$2
$5:
; # (int A)
  %7 = lshr i64 %0, 4
; # (int B)
  %8 = lshr i64 %1, 4
; # (% (int A) (int B))
  %9 = urem i64 %7, %8
; # (cnt (% (int A) (int B)))
  %10 = shl i64 %9, 4
  %11 = or i64 %10, 2
  br label %$2
$2:
  %12 = phi i64 [%4, %$4], [%0, %$6], [%11, %$5] ; # ->
  ret i64 %12
}

define i64 @incs(i64) align 8 {
$1:
; # (if (sign? A) (neg (subu (pos A) ONE)) (addu A ONE))
; # (sign? A)
  %1 = and i64 %0, 8
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (pos A)
  %3 = and i64 %0, -9
; # (subu (pos A) ONE)
  %4 = call i64 @subu(i64 %3, i64 18)
; # (neg (subu (pos A) ONE))
  %5 = icmp eq i64 %4, 2
  br i1 %5, label %$5, label %$6
$5:
  br label %$7
$6:
  %6 = xor i64 %4, 8
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%6, %$6] ; # ->
  br label %$4
$3:
; # (addu A ONE)
  %8 = call i64 @addu(i64 %0, i64 18)
  br label %$4
$4:
  %9 = phi i64 [%7, %$7], [%8, %$3] ; # ->
  ret i64 %9
}

define i64 @decs(i64) align 8 {
$1:
; # (if (sign? A) (neg (addu (pos A) ONE)) (subu A ONE))
; # (sign? A)
  %1 = and i64 %0, 8
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (pos A)
  %3 = and i64 %0, -9
; # (addu (pos A) ONE)
  %4 = call i64 @addu(i64 %3, i64 18)
; # (neg (addu (pos A) ONE))
  %5 = icmp eq i64 %4, 2
  br i1 %5, label %$5, label %$6
$5:
  br label %$7
$6:
  %6 = xor i64 %4, 8
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%6, %$6] ; # ->
  br label %$4
$3:
; # (subu A ONE)
  %8 = call i64 @subu(i64 %0, i64 18)
  br label %$4
$4:
  %9 = phi i64 [%7, %$7], [%8, %$3] ; # ->
  ret i64 %9
}

define i64 @adds(i64, i64) align 8 {
$1:
; # (ifn (sign? A) (ifn (sign? B) (addu A B) (subu A (pos B))) (neg (...
; # (sign? A)
  %2 = and i64 %0, 8
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (ifn (sign? B) (addu A B) (subu A (pos B)))
; # (sign? B)
  %4 = and i64 %1, 8
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$6, label %$5
$5:
; # (addu A B)
  %6 = call i64 @addu(i64 %0, i64 %1)
  br label %$7
$6:
; # (pos B)
  %7 = and i64 %1, -9
; # (subu A (pos B))
  %8 = call i64 @subu(i64 %0, i64 %7)
  br label %$7
$7:
  %9 = phi i64 [%6, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (ifn (sign? B) (subu (pos A) B) (addu (pos A) (pos B)))
; # (sign? B)
  %10 = and i64 %1, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$9, label %$8
$8:
; # (pos A)
  %12 = and i64 %0, -9
; # (subu (pos A) B)
  %13 = call i64 @subu(i64 %12, i64 %1)
  br label %$10
$9:
; # (pos A)
  %14 = and i64 %0, -9
; # (pos B)
  %15 = and i64 %1, -9
; # (addu (pos A) (pos B))
  %16 = call i64 @addu(i64 %14, i64 %15)
  br label %$10
$10:
  %17 = phi i64 [%13, %$8], [%16, %$9] ; # ->
; # (neg (ifn (sign? B) (subu (pos A) B) (addu (pos A) (pos B))))
  %18 = icmp eq i64 %17, 2
  br i1 %18, label %$11, label %$12
$11:
  br label %$13
$12:
  %19 = xor i64 %17, 8
  br label %$13
$13:
  %20 = phi i64 [%17, %$11], [%19, %$12] ; # ->
  br label %$4
$4:
  %21 = phi i64 [%9, %$7], [%20, %$13] ; # ->
  ret i64 %21
}

define i64 @subs(i64, i64) align 8 {
$1:
; # (ifn (sign? A) (ifn (sign? B) (subu A B) (addu A (pos B))) (neg (...
; # (sign? A)
  %2 = and i64 %0, 8
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (ifn (sign? B) (subu A B) (addu A (pos B)))
; # (sign? B)
  %4 = and i64 %1, 8
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$6, label %$5
$5:
; # (subu A B)
  %6 = call i64 @subu(i64 %0, i64 %1)
  br label %$7
$6:
; # (pos B)
  %7 = and i64 %1, -9
; # (addu A (pos B))
  %8 = call i64 @addu(i64 %0, i64 %7)
  br label %$7
$7:
  %9 = phi i64 [%6, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (ifn (sign? B) (addu (pos A) B) (subu (pos A) (pos B)))
; # (sign? B)
  %10 = and i64 %1, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$9, label %$8
$8:
; # (pos A)
  %12 = and i64 %0, -9
; # (addu (pos A) B)
  %13 = call i64 @addu(i64 %12, i64 %1)
  br label %$10
$9:
; # (pos A)
  %14 = and i64 %0, -9
; # (pos B)
  %15 = and i64 %1, -9
; # (subu (pos A) (pos B))
  %16 = call i64 @subu(i64 %14, i64 %15)
  br label %$10
$10:
  %17 = phi i64 [%13, %$8], [%16, %$9] ; # ->
; # (neg (ifn (sign? B) (addu (pos A) B) (subu (pos A) (pos B))))
  %18 = icmp eq i64 %17, 2
  br i1 %18, label %$11, label %$12
$11:
  br label %$13
$12:
  %19 = xor i64 %17, 8
  br label %$13
$13:
  %20 = phi i64 [%17, %$11], [%19, %$12] ; # ->
  br label %$4
$4:
  %21 = phi i64 [%9, %$7], [%20, %$13] ; # ->
  ret i64 %21
}

define i64 @cmpu(i64, i64) align 8 {
$1:
; # (if (cnt? A) (cond ((or (big? B) (> B A)) -1) ((== B A) 0) (T 1))...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (cond ((or (big? B) (> B A)) -1) ((== B A) 0) (T 1))
; # (or (big? B) (> B A))
; # (big? B)
  %6 = and i64 %5, 4
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$7
$7:
  %8 = phi i64 [%4, %$2] ; # A
  %9 = phi i64 [%5, %$2] ; # B
; # (> B A)
  %10 = icmp ugt i64 %9, %8
  br label %$6
$6:
  %11 = phi i64 [%4, %$2], [%8, %$7] ; # A
  %12 = phi i64 [%5, %$2], [%9, %$7] ; # B
  %13 = phi i1 [1, %$2], [%10, %$7] ; # ->
  br i1 %13, label %$9, label %$8
$9:
  %14 = phi i64 [%11, %$6] ; # A
  %15 = phi i64 [%12, %$6] ; # B
  br label %$5
$8:
  %16 = phi i64 [%11, %$6] ; # A
  %17 = phi i64 [%12, %$6] ; # B
; # (== B A)
  %18 = icmp eq i64 %17, %16
  br i1 %18, label %$11, label %$10
$11:
  %19 = phi i64 [%16, %$8] ; # A
  %20 = phi i64 [%17, %$8] ; # B
  br label %$5
$10:
  %21 = phi i64 [%16, %$8] ; # A
  %22 = phi i64 [%17, %$8] ; # B
  br label %$5
$5:
  %23 = phi i64 [%14, %$9], [%19, %$11], [%21, %$10] ; # A
  %24 = phi i64 [%15, %$9], [%20, %$11], [%22, %$10] ; # B
  %25 = phi i64 [-1, %$9], [0, %$11], [1, %$10] ; # ->
  br label %$4
$3:
  %26 = phi i64 [%0, %$1] ; # A
  %27 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) 1 (let (X 0 Y 0) (prog1 (loop (let (C (val (big A)) ...
; # (cnt? B)
  %28 = and i64 %27, 2
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$13
$12:
  %30 = phi i64 [%26, %$3] ; # A
  %31 = phi i64 [%27, %$3] ; # B
  br label %$14
$13:
  %32 = phi i64 [%26, %$3] ; # A
  %33 = phi i64 [%27, %$3] ; # B
; # (let (X 0 Y 0) (prog1 (loop (let (C (val (big A)) D (val (big B))...
; # (prog1 (loop (let (C (val (big A)) D (val (big B))) (? (== C D) (...
; # (loop (let (C (val (big A)) D (val (big B))) (? (== C D) (loop (s...
  br label %$15
$15:
  %34 = phi i64 [%32, %$13], [%199, %$36] ; # A
  %35 = phi i64 [%33, %$13], [%200, %$36] ; # B
  %36 = phi i64 [0, %$13], [%195, %$36] ; # X
  %37 = phi i64 [0, %$13], [%196, %$36] ; # Y
; # (let (C (val (big A)) D (val (big B))) (? (== C D) (loop (setq C ...
; # (big A)
  %38 = add i64 %34, 4
; # (val (big A))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (big B)
  %41 = add i64 %35, 4
; # (val (big B))
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
; # (? (== C D) (loop (setq C (val (dig A)) D (val (dig B))) (? (> D ...
; # (== C D)
  %44 = icmp eq i64 %40, %43
  br i1 %44, label %$18, label %$16
$18:
  %45 = phi i64 [%34, %$15] ; # A
  %46 = phi i64 [%35, %$15] ; # B
  %47 = phi i64 [%36, %$15] ; # X
  %48 = phi i64 [%37, %$15] ; # Y
  %49 = phi i64 [%40, %$15] ; # C
  %50 = phi i64 [%43, %$15] ; # D
; # (loop (setq C (val (dig A)) D (val (dig B))) (? (> D C) -1) (? (>...
  br label %$19
$19:
  %51 = phi i64 [%45, %$18], [%98, %$25] ; # A
  %52 = phi i64 [%46, %$18], [%99, %$25] ; # B
  %53 = phi i64 [%47, %$18], [%104, %$25] ; # X
  %54 = phi i64 [%48, %$18], [%109, %$25] ; # Y
  %55 = phi i64 [%49, %$18], [%100, %$25] ; # C
  %56 = phi i64 [%50, %$18], [%101, %$25] ; # D
; # (dig A)
  %57 = add i64 %51, -4
; # (val (dig A))
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (dig B)
  %60 = add i64 %52, -4
; # (val (dig B))
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (? (> D C) -1)
; # (> D C)
  %63 = icmp ugt i64 %62, %59
  br i1 %63, label %$22, label %$20
$22:
  %64 = phi i64 [%51, %$19] ; # A
  %65 = phi i64 [%52, %$19] ; # B
  %66 = phi i64 [%53, %$19] ; # X
  %67 = phi i64 [%54, %$19] ; # Y
  %68 = phi i64 [%59, %$19] ; # C
  %69 = phi i64 [%62, %$19] ; # D
  br label %$21
$20:
  %70 = phi i64 [%51, %$19] ; # A
  %71 = phi i64 [%52, %$19] ; # B
  %72 = phi i64 [%53, %$19] ; # X
  %73 = phi i64 [%54, %$19] ; # Y
  %74 = phi i64 [%59, %$19] ; # C
  %75 = phi i64 [%62, %$19] ; # D
; # (? (> C D) 1)
; # (> C D)
  %76 = icmp ugt i64 %74, %75
  br i1 %76, label %$24, label %$23
$24:
  %77 = phi i64 [%70, %$20] ; # A
  %78 = phi i64 [%71, %$20] ; # B
  %79 = phi i64 [%72, %$20] ; # X
  %80 = phi i64 [%73, %$20] ; # Y
  %81 = phi i64 [%74, %$20] ; # C
  %82 = phi i64 [%75, %$20] ; # D
  br label %$21
$23:
  %83 = phi i64 [%70, %$20] ; # A
  %84 = phi i64 [%71, %$20] ; # B
  %85 = phi i64 [%72, %$20] ; # X
  %86 = phi i64 [%73, %$20] ; # Y
  %87 = phi i64 [%74, %$20] ; # C
  %88 = phi i64 [%75, %$20] ; # D
; # (? (=0 X) 0)
; # (=0 X)
  %89 = icmp eq i64 %85, 0
  br i1 %89, label %$26, label %$25
$26:
  %90 = phi i64 [%83, %$23] ; # A
  %91 = phi i64 [%84, %$23] ; # B
  %92 = phi i64 [%85, %$23] ; # X
  %93 = phi i64 [%86, %$23] ; # Y
  %94 = phi i64 [%87, %$23] ; # C
  %95 = phi i64 [%88, %$23] ; # D
  br label %$21
$25:
  %96 = phi i64 [%83, %$23] ; # A
  %97 = phi i64 [%84, %$23] ; # B
  %98 = phi i64 [%85, %$23] ; # X
  %99 = phi i64 [%86, %$23] ; # Y
  %100 = phi i64 [%87, %$23] ; # C
  %101 = phi i64 [%88, %$23] ; # D
; # (let Z (val (big X)) (set (big X) A) (setq A X X Z))
; # (big X)
  %102 = add i64 %98, 4
; # (val (big X))
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
; # (set (big X) A)
; # (big X)
  %105 = add i64 %98, 4
  %106 = inttoptr i64 %105 to i64*
  store i64 %96, i64* %106
; # (let Z (val (big Y)) (set (big Y) B) (setq B Y Y Z))
; # (big Y)
  %107 = add i64 %99, 4
; # (val (big Y))
  %108 = inttoptr i64 %107 to i64*
  %109 = load i64, i64* %108
; # (set (big Y) B)
; # (big Y)
  %110 = add i64 %99, 4
  %111 = inttoptr i64 %110 to i64*
  store i64 %97, i64* %111
  br label %$19
$21:
  %112 = phi i64 [%64, %$22], [%77, %$24], [%90, %$26] ; # A
  %113 = phi i64 [%65, %$22], [%78, %$24], [%91, %$26] ; # B
  %114 = phi i64 [%66, %$22], [%79, %$24], [%92, %$26] ; # X
  %115 = phi i64 [%67, %$22], [%80, %$24], [%93, %$26] ; # Y
  %116 = phi i64 [%68, %$22], [%81, %$24], [%94, %$26] ; # C
  %117 = phi i64 [%69, %$22], [%82, %$24], [%95, %$26] ; # D
  %118 = phi i64 [-1, %$22], [1, %$24], [0, %$26] ; # ->
  br label %$17
$16:
  %119 = phi i64 [%34, %$15] ; # A
  %120 = phi i64 [%35, %$15] ; # B
  %121 = phi i64 [%36, %$15] ; # X
  %122 = phi i64 [%37, %$15] ; # Y
  %123 = phi i64 [%40, %$15] ; # C
  %124 = phi i64 [%43, %$15] ; # D
; # (? (cnt? C) (cond ((or (big? D) (> D C)) -1) ((== D C) 0) (T 1)))...
; # (cnt? C)
  %125 = and i64 %123, 2
  %126 = icmp ne i64 %125, 0
  br i1 %126, label %$28, label %$27
$28:
  %127 = phi i64 [%119, %$16] ; # A
  %128 = phi i64 [%120, %$16] ; # B
  %129 = phi i64 [%121, %$16] ; # X
  %130 = phi i64 [%122, %$16] ; # Y
  %131 = phi i64 [%123, %$16] ; # C
  %132 = phi i64 [%124, %$16] ; # D
; # (cond ((or (big? D) (> D C)) -1) ((== D C) 0) (T 1))
; # (or (big? D) (> D C))
; # (big? D)
  %133 = and i64 %132, 4
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$30, label %$31
$31:
  %135 = phi i64 [%127, %$28] ; # A
  %136 = phi i64 [%128, %$28] ; # B
  %137 = phi i64 [%129, %$28] ; # X
  %138 = phi i64 [%130, %$28] ; # Y
  %139 = phi i64 [%131, %$28] ; # C
  %140 = phi i64 [%132, %$28] ; # D
; # (> D C)
  %141 = icmp ugt i64 %140, %139
  br label %$30
$30:
  %142 = phi i64 [%127, %$28], [%135, %$31] ; # A
  %143 = phi i64 [%128, %$28], [%136, %$31] ; # B
  %144 = phi i64 [%129, %$28], [%137, %$31] ; # X
  %145 = phi i64 [%130, %$28], [%138, %$31] ; # Y
  %146 = phi i64 [%131, %$28], [%139, %$31] ; # C
  %147 = phi i64 [%132, %$28], [%140, %$31] ; # D
  %148 = phi i1 [1, %$28], [%141, %$31] ; # ->
  br i1 %148, label %$33, label %$32
$33:
  %149 = phi i64 [%142, %$30] ; # A
  %150 = phi i64 [%143, %$30] ; # B
  %151 = phi i64 [%144, %$30] ; # X
  %152 = phi i64 [%145, %$30] ; # Y
  %153 = phi i64 [%146, %$30] ; # C
  %154 = phi i64 [%147, %$30] ; # D
  br label %$29
$32:
  %155 = phi i64 [%142, %$30] ; # A
  %156 = phi i64 [%143, %$30] ; # B
  %157 = phi i64 [%144, %$30] ; # X
  %158 = phi i64 [%145, %$30] ; # Y
  %159 = phi i64 [%146, %$30] ; # C
  %160 = phi i64 [%147, %$30] ; # D
; # (== D C)
  %161 = icmp eq i64 %160, %159
  br i1 %161, label %$35, label %$34
$35:
  %162 = phi i64 [%155, %$32] ; # A
  %163 = phi i64 [%156, %$32] ; # B
  %164 = phi i64 [%157, %$32] ; # X
  %165 = phi i64 [%158, %$32] ; # Y
  %166 = phi i64 [%159, %$32] ; # C
  %167 = phi i64 [%160, %$32] ; # D
  br label %$29
$34:
  %168 = phi i64 [%155, %$32] ; # A
  %169 = phi i64 [%156, %$32] ; # B
  %170 = phi i64 [%157, %$32] ; # X
  %171 = phi i64 [%158, %$32] ; # Y
  %172 = phi i64 [%159, %$32] ; # C
  %173 = phi i64 [%160, %$32] ; # D
  br label %$29
$29:
  %174 = phi i64 [%149, %$33], [%162, %$35], [%168, %$34] ; # A
  %175 = phi i64 [%150, %$33], [%163, %$35], [%169, %$34] ; # B
  %176 = phi i64 [%151, %$33], [%164, %$35], [%170, %$34] ; # X
  %177 = phi i64 [%152, %$33], [%165, %$35], [%171, %$34] ; # Y
  %178 = phi i64 [%153, %$33], [%166, %$35], [%172, %$34] ; # C
  %179 = phi i64 [%154, %$33], [%167, %$35], [%173, %$34] ; # D
  %180 = phi i64 [-1, %$33], [0, %$35], [1, %$34] ; # ->
  br label %$17
$27:
  %181 = phi i64 [%119, %$16] ; # A
  %182 = phi i64 [%120, %$16] ; # B
  %183 = phi i64 [%121, %$16] ; # X
  %184 = phi i64 [%122, %$16] ; # Y
  %185 = phi i64 [%123, %$16] ; # C
  %186 = phi i64 [%124, %$16] ; # D
; # (? (cnt? D) 1)
; # (cnt? D)
  %187 = and i64 %186, 2
  %188 = icmp ne i64 %187, 0
  br i1 %188, label %$37, label %$36
$37:
  %189 = phi i64 [%181, %$27] ; # A
  %190 = phi i64 [%182, %$27] ; # B
  %191 = phi i64 [%183, %$27] ; # X
  %192 = phi i64 [%184, %$27] ; # Y
  %193 = phi i64 [%185, %$27] ; # C
  %194 = phi i64 [%186, %$27] ; # D
  br label %$17
$36:
  %195 = phi i64 [%181, %$27] ; # A
  %196 = phi i64 [%182, %$27] ; # B
  %197 = phi i64 [%183, %$27] ; # X
  %198 = phi i64 [%184, %$27] ; # Y
  %199 = phi i64 [%185, %$27] ; # C
  %200 = phi i64 [%186, %$27] ; # D
; # (set (big A) X)
; # (big A)
  %201 = add i64 %195, 4
  %202 = inttoptr i64 %201 to i64*
  store i64 %197, i64* %202
; # (set (big B) Y)
; # (big B)
  %203 = add i64 %196, 4
  %204 = inttoptr i64 %203 to i64*
  store i64 %198, i64* %204
  br label %$15
$17:
  %205 = phi i64 [%112, %$21], [%174, %$29], [%189, %$37] ; # A
  %206 = phi i64 [%113, %$21], [%175, %$29], [%190, %$37] ; # B
  %207 = phi i64 [%114, %$21], [%176, %$29], [%191, %$37] ; # X
  %208 = phi i64 [%115, %$21], [%177, %$29], [%192, %$37] ; # Y
  %209 = phi i64 [%118, %$21], [%180, %$29], [1, %$37] ; # ->
; # (while X (let Z (val (big X)) (set (big X) A) (setq A X X Z)) (le...
  br label %$38
$38:
  %210 = phi i64 [%205, %$17], [%217, %$39] ; # A
  %211 = phi i64 [%206, %$17], [%218, %$39] ; # B
  %212 = phi i64 [%207, %$17], [%221, %$39] ; # X
  %213 = phi i64 [%208, %$17], [%226, %$39] ; # Y
  %214 = icmp ne i64 %212, 0
  br i1 %214, label %$39, label %$40
$39:
  %215 = phi i64 [%210, %$38] ; # A
  %216 = phi i64 [%211, %$38] ; # B
  %217 = phi i64 [%212, %$38] ; # X
  %218 = phi i64 [%213, %$38] ; # Y
; # (let Z (val (big X)) (set (big X) A) (setq A X X Z))
; # (big X)
  %219 = add i64 %217, 4
; # (val (big X))
  %220 = inttoptr i64 %219 to i64*
  %221 = load i64, i64* %220
; # (set (big X) A)
; # (big X)
  %222 = add i64 %217, 4
  %223 = inttoptr i64 %222 to i64*
  store i64 %215, i64* %223
; # (let Z (val (big Y)) (set (big Y) B) (setq B Y Y Z))
; # (big Y)
  %224 = add i64 %218, 4
; # (val (big Y))
  %225 = inttoptr i64 %224 to i64*
  %226 = load i64, i64* %225
; # (set (big Y) B)
; # (big Y)
  %227 = add i64 %218, 4
  %228 = inttoptr i64 %227 to i64*
  store i64 %216, i64* %228
  br label %$38
$40:
  %229 = phi i64 [%210, %$38] ; # A
  %230 = phi i64 [%211, %$38] ; # B
  %231 = phi i64 [%212, %$38] ; # X
  %232 = phi i64 [%213, %$38] ; # Y
  br label %$14
$14:
  %233 = phi i64 [%30, %$12], [%229, %$40] ; # A
  %234 = phi i64 [%31, %$12], [%230, %$40] ; # B
  %235 = phi i64 [1, %$12], [%209, %$40] ; # ->
  br label %$4
$4:
  %236 = phi i64 [%23, %$5], [%233, %$14] ; # A
  %237 = phi i64 [%24, %$5], [%234, %$14] ; # B
  %238 = phi i64 [%25, %$5], [%235, %$14] ; # ->
  ret i64 %238
}

define i64 @cmpNum(i64, i64) align 8 {
$1:
; # (ifn (sign? A) (ifn (sign? B) (cmpu A B) 1) (ifn (sign? B) -1 (cm...
; # (sign? A)
  %2 = and i64 %0, 8
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (ifn (sign? B) (cmpu A B) 1)
; # (sign? B)
  %4 = and i64 %1, 8
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$6, label %$5
$5:
; # (cmpu A B)
  %6 = call i64 @cmpu(i64 %0, i64 %1)
  br label %$7
$6:
  br label %$7
$7:
  %7 = phi i64 [%6, %$5], [1, %$6] ; # ->
  br label %$4
$3:
; # (ifn (sign? B) -1 (cmpu (pos B) (pos A)))
; # (sign? B)
  %8 = and i64 %1, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$9, label %$8
$8:
  br label %$10
$9:
; # (pos B)
  %10 = and i64 %1, -9
; # (pos A)
  %11 = and i64 %0, -9
; # (cmpu (pos B) (pos A))
  %12 = call i64 @cmpu(i64 %10, i64 %11)
  br label %$10
$10:
  %13 = phi i64 [-1, %$8], [%12, %$9] ; # ->
  br label %$4
$4:
  %14 = phi i64 [%7, %$7], [%13, %$10] ; # ->
  ret i64 %14
}

define i64 @symToNum(i64, i64, i8, i8) align 8 {
$1:
; # (let (P (push 0 Name) Num (push ZERO NIL) Sign NO Frac NO B T) (u...
; # (push 0 Name)
  %4 = alloca i64, i64 2, align 16
  store i64 0, i64* %4
  %5 = getelementptr i64, i64* %4, i32 1
  store i64 %0, i64* %5
; # (push ZERO NIL)
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 2, i64* %8
; # (until (> (setq B (symByte P)) (char " ")) (unless B (ret 0)))
  br label %$2
$2:
  %9 = phi i64 [%1, %$1], [%26, %$6] ; # Scl
  %10 = phi i64 [%7, %$1], [%27, %$6] ; # Num
  %11 = phi i1 [0, %$1], [%28, %$6] ; # Sign
  %12 = phi i1 [0, %$1], [%29, %$6] ; # Frac
; # (symByte P)
  %13 = call i8 @symByte(i64* %4)
; # (> (setq B (symByte P)) (char " "))
  %14 = icmp ugt i8 %13, 32
  br i1 %14, label %$4, label %$3
$3:
  %15 = phi i64 [%9, %$2] ; # Scl
  %16 = phi i64 [%10, %$2] ; # Num
  %17 = phi i1 [%11, %$2] ; # Sign
  %18 = phi i1 [%12, %$2] ; # Frac
  %19 = phi i8 [%13, %$2] ; # B
; # (unless B (ret 0))
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %$6, label %$5
$5:
  %21 = phi i64 [%15, %$3] ; # Scl
  %22 = phi i64 [%16, %$3] ; # Num
  %23 = phi i1 [%17, %$3] ; # Sign
  %24 = phi i1 [%18, %$3] ; # Frac
  %25 = phi i8 [%19, %$3] ; # B
; # (ret 0)
  ret i64 0
$6:
  %26 = phi i64 [%15, %$3] ; # Scl
  %27 = phi i64 [%16, %$3] ; # Num
  %28 = phi i1 [%17, %$3] ; # Sign
  %29 = phi i1 [%18, %$3] ; # Frac
  %30 = phi i8 [%19, %$3] ; # B
  br label %$2
$4:
  %31 = phi i64 [%9, %$2] ; # Scl
  %32 = phi i64 [%10, %$2] ; # Num
  %33 = phi i1 [%11, %$2] ; # Sign
  %34 = phi i1 [%12, %$2] ; # Frac
  %35 = phi i8 [%13, %$2] ; # B
; # (cond ((== B (char "+")) (goto 1)) ((== B (char "-")) (setq Sign ...
; # (== B (char "+"))
  %36 = icmp eq i8 %35, 43
  br i1 %36, label %$9, label %$8
$9:
  %37 = phi i64 [%31, %$4] ; # Scl
  %38 = phi i64 [%32, %$4] ; # Num
  %39 = phi i1 [%33, %$4] ; # Sign
  %40 = phi i1 [%34, %$4] ; # Frac
  %41 = phi i8 [%35, %$4] ; # B
; # (goto 1)
  br label %$-1
$8:
  %42 = phi i64 [%31, %$4] ; # Scl
  %43 = phi i64 [%32, %$4] ; # Num
  %44 = phi i1 [%33, %$4] ; # Sign
  %45 = phi i1 [%34, %$4] ; # Frac
  %46 = phi i8 [%35, %$4] ; # B
; # (== B (char "-"))
  %47 = icmp eq i8 %46, 45
  br i1 %47, label %$11, label %$10
$11:
  %48 = phi i64 [%42, %$8] ; # Scl
  %49 = phi i64 [%43, %$8] ; # Num
  %50 = phi i1 [%44, %$8] ; # Sign
  %51 = phi i1 [%45, %$8] ; # Frac
  %52 = phi i8 [%46, %$8] ; # B
; # (: 1 (unless (setq B (symByte P)) (ret 0)))
  br label %$-1
$-1:
  %53 = phi i64 [%37, %$9], [%48, %$11] ; # Scl
  %54 = phi i64 [%38, %$9], [%49, %$11] ; # Num
  %55 = phi i1 [%39, %$9], [1, %$11] ; # Sign
  %56 = phi i1 [%40, %$9], [%51, %$11] ; # Frac
  %57 = phi i8 [%41, %$9], [%52, %$11] ; # B
; # (unless (setq B (symByte P)) (ret 0))
; # (symByte P)
  %58 = call i8 @symByte(i64* %4)
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %$13, label %$12
$12:
  %60 = phi i64 [%53, %$-1] ; # Scl
  %61 = phi i64 [%54, %$-1] ; # Num
  %62 = phi i1 [%55, %$-1] ; # Sign
  %63 = phi i1 [%56, %$-1] ; # Frac
  %64 = phi i8 [%58, %$-1] ; # B
; # (ret 0)
  ret i64 0
$13:
  %65 = phi i64 [%53, %$-1] ; # Scl
  %66 = phi i64 [%54, %$-1] ; # Num
  %67 = phi i1 [%55, %$-1] ; # Sign
  %68 = phi i1 [%56, %$-1] ; # Frac
  %69 = phi i8 [%58, %$-1] ; # B
  br label %$7
$10:
  %70 = phi i64 [%42, %$8] ; # Scl
  %71 = phi i64 [%43, %$8] ; # Num
  %72 = phi i1 [%44, %$8] ; # Sign
  %73 = phi i1 [%45, %$8] ; # Frac
  %74 = phi i8 [%46, %$8] ; # B
  br label %$7
$7:
  %75 = phi i64 [%65, %$13], [%70, %$10] ; # Scl
  %76 = phi i64 [%66, %$13], [%71, %$10] ; # Num
  %77 = phi i1 [%67, %$13], [%72, %$10] ; # Sign
  %78 = phi i1 [%68, %$13], [%73, %$10] ; # Frac
  %79 = phi i8 [%69, %$13], [%74, %$10] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %80 = sub i8 %79, 48
; # (> (dec 'B (char "0")) 9)
  %81 = icmp ugt i8 %80, 9
  br i1 %81, label %$14, label %$15
$14:
  %82 = phi i64 [%75, %$7] ; # Scl
  %83 = phi i64 [%76, %$7] ; # Num
  %84 = phi i1 [%77, %$7] ; # Sign
  %85 = phi i1 [%78, %$7] ; # Frac
  %86 = phi i8 [%80, %$7] ; # B
; # (ret 0)
  ret i64 0
$15:
  %87 = phi i64 [%75, %$7] ; # Scl
  %88 = phi i64 [%76, %$7] ; # Num
  %89 = phi i1 [%77, %$7] ; # Sign
  %90 = phi i1 [%78, %$7] ; # Frac
  %91 = phi i8 [%80, %$7] ; # B
; # (set (link Num T) (cnt (i64 B)))
; # (link Num T)
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %88 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %88, i64* %96
; # (i64 B)
  %97 = zext i8 %91 to i64
; # (cnt (i64 B))
  %98 = shl i64 %97, 4
  %99 = or i64 %98, 2
  %100 = inttoptr i64 %88 to i64*
  store i64 %99, i64* %100
; # (while (setq B (symByte P)) (? (and Frac (=0 Scl)) (when (> (dec ...
  br label %$16
$16:
  %101 = phi i64 [%87, %$15], [%270, %$32] ; # Scl
  %102 = phi i64 [%88, %$15], [%271, %$32] ; # Num
  %103 = phi i1 [%89, %$15], [%272, %$32] ; # Sign
  %104 = phi i1 [%90, %$15], [%273, %$32] ; # Frac
  %105 = phi i8 [%91, %$15], [%274, %$32] ; # B
; # (symByte P)
  %106 = call i8 @symByte(i64* %4)
  %107 = icmp ne i8 %106, 0
  br i1 %107, label %$17, label %$18
$17:
  %108 = phi i64 [%101, %$16] ; # Scl
  %109 = phi i64 [%102, %$16] ; # Num
  %110 = phi i1 [%103, %$16] ; # Sign
  %111 = phi i1 [%104, %$16] ; # Frac
  %112 = phi i8 [%106, %$16] ; # B
; # (? (and Frac (=0 Scl)) (when (> (dec 'B (char "0")) 9) (ret 0)) (...
; # (and Frac (=0 Scl))
  br i1 %111, label %$20, label %$19
$20:
  %113 = phi i64 [%108, %$17] ; # Scl
  %114 = phi i64 [%109, %$17] ; # Num
  %115 = phi i1 [%110, %$17] ; # Sign
  %116 = phi i1 [%111, %$17] ; # Frac
  %117 = phi i8 [%112, %$17] ; # B
; # (=0 Scl)
  %118 = icmp eq i64 %113, 0
  br label %$19
$19:
  %119 = phi i64 [%108, %$17], [%113, %$20] ; # Scl
  %120 = phi i64 [%109, %$17], [%114, %$20] ; # Num
  %121 = phi i1 [%110, %$17], [%115, %$20] ; # Sign
  %122 = phi i1 [%111, %$17], [%116, %$20] ; # Frac
  %123 = phi i8 [%112, %$17], [%117, %$20] ; # B
  %124 = phi i1 [0, %$17], [%118, %$20] ; # ->
  br i1 %124, label %$22, label %$21
$22:
  %125 = phi i64 [%119, %$19] ; # Scl
  %126 = phi i64 [%120, %$19] ; # Num
  %127 = phi i1 [%121, %$19] ; # Sign
  %128 = phi i1 [%122, %$19] ; # Frac
  %129 = phi i8 [%123, %$19] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %130 = sub i8 %129, 48
; # (> (dec 'B (char "0")) 9)
  %131 = icmp ugt i8 %130, 9
  br i1 %131, label %$23, label %$24
$23:
  %132 = phi i64 [%125, %$22] ; # Scl
  %133 = phi i64 [%126, %$22] ; # Num
  %134 = phi i1 [%127, %$22] ; # Sign
  %135 = phi i1 [%128, %$22] ; # Frac
  %136 = phi i8 [%130, %$22] ; # B
; # (ret 0)
; # (drop *Safe)
  %137 = inttoptr i64 %88 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %139, i64* %140
  ret i64 0
$24:
  %141 = phi i64 [%125, %$22] ; # Scl
  %142 = phi i64 [%126, %$22] ; # Num
  %143 = phi i1 [%127, %$22] ; # Sign
  %144 = phi i1 [%128, %$22] ; # Frac
  %145 = phi i8 [%130, %$22] ; # B
; # (when (>= B 5) (set Num (addu (val Num) ONE)))
; # (>= B 5)
  %146 = icmp uge i8 %145, 5
  br i1 %146, label %$25, label %$26
$25:
  %147 = phi i64 [%141, %$24] ; # Scl
  %148 = phi i64 [%142, %$24] ; # Num
  %149 = phi i1 [%143, %$24] ; # Sign
  %150 = phi i1 [%144, %$24] ; # Frac
  %151 = phi i8 [%145, %$24] ; # B
; # (set Num (addu (val Num) ONE))
; # (val Num)
  %152 = inttoptr i64 %148 to i64*
  %153 = load i64, i64* %152
; # (addu (val Num) ONE)
  %154 = call i64 @addu(i64 %153, i64 18)
  %155 = inttoptr i64 %148 to i64*
  store i64 %154, i64* %155
  br label %$26
$26:
  %156 = phi i64 [%141, %$24], [%147, %$25] ; # Scl
  %157 = phi i64 [%142, %$24], [%148, %$25] ; # Num
  %158 = phi i1 [%143, %$24], [%149, %$25] ; # Sign
  %159 = phi i1 [%144, %$24], [%150, %$25] ; # Frac
  %160 = phi i8 [%145, %$24], [%151, %$25] ; # B
; # (while (setq B (symByte P)) (when (> (dec 'B (char "0")) 9) (ret ...
  br label %$27
$27:
  %161 = phi i64 [%156, %$26], [%184, %$31] ; # Scl
  %162 = phi i64 [%157, %$26], [%185, %$31] ; # Num
  %163 = phi i1 [%158, %$26], [%186, %$31] ; # Sign
  %164 = phi i1 [%159, %$26], [%187, %$31] ; # Frac
  %165 = phi i8 [%160, %$26], [%188, %$31] ; # B
; # (symByte P)
  %166 = call i8 @symByte(i64* %4)
  %167 = icmp ne i8 %166, 0
  br i1 %167, label %$28, label %$29
$28:
  %168 = phi i64 [%161, %$27] ; # Scl
  %169 = phi i64 [%162, %$27] ; # Num
  %170 = phi i1 [%163, %$27] ; # Sign
  %171 = phi i1 [%164, %$27] ; # Frac
  %172 = phi i8 [%166, %$27] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %173 = sub i8 %172, 48
; # (> (dec 'B (char "0")) 9)
  %174 = icmp ugt i8 %173, 9
  br i1 %174, label %$30, label %$31
$30:
  %175 = phi i64 [%168, %$28] ; # Scl
  %176 = phi i64 [%169, %$28] ; # Num
  %177 = phi i1 [%170, %$28] ; # Sign
  %178 = phi i1 [%171, %$28] ; # Frac
  %179 = phi i8 [%173, %$28] ; # B
; # (ret 0)
; # (drop *Safe)
  %180 = inttoptr i64 %88 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %182, i64* %183
  ret i64 0
$31:
  %184 = phi i64 [%168, %$28] ; # Scl
  %185 = phi i64 [%169, %$28] ; # Num
  %186 = phi i1 [%170, %$28] ; # Sign
  %187 = phi i1 [%171, %$28] ; # Frac
  %188 = phi i8 [%173, %$28] ; # B
  br label %$27
$29:
  %189 = phi i64 [%161, %$27] ; # Scl
  %190 = phi i64 [%162, %$27] ; # Num
  %191 = phi i1 [%163, %$27] ; # Sign
  %192 = phi i1 [%164, %$27] ; # Frac
  %193 = phi i8 [%166, %$27] ; # B
  br label %$18
$21:
  %194 = phi i64 [%119, %$19] ; # Scl
  %195 = phi i64 [%120, %$19] ; # Num
  %196 = phi i1 [%121, %$19] ; # Sign
  %197 = phi i1 [%122, %$19] ; # Frac
  %198 = phi i8 [%123, %$19] ; # B
; # (cond ((== B Sep) (when Frac (ret 0)) (setq Frac YES)) ((<> B Ign...
; # (== B Sep)
  %199 = icmp eq i8 %198, %2
  br i1 %199, label %$34, label %$33
$34:
  %200 = phi i64 [%194, %$21] ; # Scl
  %201 = phi i64 [%195, %$21] ; # Num
  %202 = phi i1 [%196, %$21] ; # Sign
  %203 = phi i1 [%197, %$21] ; # Frac
  %204 = phi i8 [%198, %$21] ; # B
; # (when Frac (ret 0))
  br i1 %203, label %$35, label %$36
$35:
  %205 = phi i64 [%200, %$34] ; # Scl
  %206 = phi i64 [%201, %$34] ; # Num
  %207 = phi i1 [%202, %$34] ; # Sign
  %208 = phi i1 [%203, %$34] ; # Frac
  %209 = phi i8 [%204, %$34] ; # B
; # (ret 0)
; # (drop *Safe)
  %210 = inttoptr i64 %88 to i64*
  %211 = getelementptr i64, i64* %210, i32 1
  %212 = load i64, i64* %211
  %213 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %212, i64* %213
  ret i64 0
$36:
  %214 = phi i64 [%200, %$34] ; # Scl
  %215 = phi i64 [%201, %$34] ; # Num
  %216 = phi i1 [%202, %$34] ; # Sign
  %217 = phi i1 [%203, %$34] ; # Frac
  %218 = phi i8 [%204, %$34] ; # B
  br label %$32
$33:
  %219 = phi i64 [%194, %$21] ; # Scl
  %220 = phi i64 [%195, %$21] ; # Num
  %221 = phi i1 [%196, %$21] ; # Sign
  %222 = phi i1 [%197, %$21] ; # Frac
  %223 = phi i8 [%198, %$21] ; # B
; # (<> B Ign)
  %224 = icmp ne i8 %223, %3
  br i1 %224, label %$38, label %$37
$38:
  %225 = phi i64 [%219, %$33] ; # Scl
  %226 = phi i64 [%220, %$33] ; # Num
  %227 = phi i1 [%221, %$33] ; # Sign
  %228 = phi i1 [%222, %$33] ; # Frac
  %229 = phi i8 [%223, %$33] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %230 = sub i8 %229, 48
; # (> (dec 'B (char "0")) 9)
  %231 = icmp ugt i8 %230, 9
  br i1 %231, label %$39, label %$40
$39:
  %232 = phi i64 [%225, %$38] ; # Scl
  %233 = phi i64 [%226, %$38] ; # Num
  %234 = phi i1 [%227, %$38] ; # Sign
  %235 = phi i1 [%228, %$38] ; # Frac
  %236 = phi i8 [%230, %$38] ; # B
; # (ret 0)
; # (drop *Safe)
  %237 = inttoptr i64 %88 to i64*
  %238 = getelementptr i64, i64* %237, i32 1
  %239 = load i64, i64* %238
  %240 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %239, i64* %240
  ret i64 0
$40:
  %241 = phi i64 [%225, %$38] ; # Scl
  %242 = phi i64 [%226, %$38] ; # Num
  %243 = phi i1 [%227, %$38] ; # Sign
  %244 = phi i1 [%228, %$38] ; # Frac
  %245 = phi i8 [%230, %$38] ; # B
; # (set Num (addu (tenfold (val Num)) (cnt (i64 B))))
; # (val Num)
  %246 = inttoptr i64 %242 to i64*
  %247 = load i64, i64* %246
; # (tenfold (val Num))
  %248 = call i64 @tenfold(i64 %247)
; # (i64 B)
  %249 = zext i8 %245 to i64
; # (cnt (i64 B))
  %250 = shl i64 %249, 4
  %251 = or i64 %250, 2
; # (addu (tenfold (val Num)) (cnt (i64 B)))
  %252 = call i64 @addu(i64 %248, i64 %251)
  %253 = inttoptr i64 %242 to i64*
  store i64 %252, i64* %253
; # (when Frac (dec 'Scl))
  br i1 %244, label %$41, label %$42
$41:
  %254 = phi i64 [%241, %$40] ; # Scl
  %255 = phi i64 [%242, %$40] ; # Num
  %256 = phi i1 [%243, %$40] ; # Sign
  %257 = phi i1 [%244, %$40] ; # Frac
  %258 = phi i8 [%245, %$40] ; # B
; # (dec 'Scl)
  %259 = sub i64 %254, 1
  br label %$42
$42:
  %260 = phi i64 [%241, %$40], [%259, %$41] ; # Scl
  %261 = phi i64 [%242, %$40], [%255, %$41] ; # Num
  %262 = phi i1 [%243, %$40], [%256, %$41] ; # Sign
  %263 = phi i1 [%244, %$40], [%257, %$41] ; # Frac
  %264 = phi i8 [%245, %$40], [%258, %$41] ; # B
  br label %$32
$37:
  %265 = phi i64 [%219, %$33] ; # Scl
  %266 = phi i64 [%220, %$33] ; # Num
  %267 = phi i1 [%221, %$33] ; # Sign
  %268 = phi i1 [%222, %$33] ; # Frac
  %269 = phi i8 [%223, %$33] ; # B
  br label %$32
$32:
  %270 = phi i64 [%214, %$36], [%260, %$42], [%265, %$37] ; # Scl
  %271 = phi i64 [%215, %$36], [%261, %$42], [%266, %$37] ; # Num
  %272 = phi i1 [%216, %$36], [%262, %$42], [%267, %$37] ; # Sign
  %273 = phi i1 [1, %$36], [%263, %$42], [%268, %$37] ; # Frac
  %274 = phi i8 [%218, %$36], [%264, %$42], [%269, %$37] ; # B
  br label %$16
$18:
  %275 = phi i64 [%101, %$16], [%189, %$29] ; # Scl
  %276 = phi i64 [%102, %$16], [%190, %$29] ; # Num
  %277 = phi i1 [%103, %$16], [%191, %$29] ; # Sign
  %278 = phi i1 [%104, %$16], [%192, %$29] ; # Frac
  %279 = phi i8 [%106, %$16], [%193, %$29] ; # B
; # (when Frac (while (ge0 (dec 'Scl)) (set Num (tenfold (val Num))))...
  br i1 %278, label %$43, label %$44
$43:
  %280 = phi i64 [%275, %$18] ; # Scl
  %281 = phi i64 [%276, %$18] ; # Num
  %282 = phi i1 [%277, %$18] ; # Sign
  %283 = phi i1 [%278, %$18] ; # Frac
  %284 = phi i8 [%279, %$18] ; # B
; # (while (ge0 (dec 'Scl)) (set Num (tenfold (val Num))))
  br label %$45
$45:
  %285 = phi i64 [%280, %$43], [%292, %$46] ; # Scl
  %286 = phi i64 [%281, %$43], [%293, %$46] ; # Num
  %287 = phi i1 [%282, %$43], [%294, %$46] ; # Sign
  %288 = phi i1 [%283, %$43], [%295, %$46] ; # Frac
  %289 = phi i8 [%284, %$43], [%296, %$46] ; # B
; # (dec 'Scl)
  %290 = sub i64 %285, 1
; # (ge0 (dec 'Scl))
  %291 = icmp sge i64 %290, 0
  br i1 %291, label %$46, label %$47
$46:
  %292 = phi i64 [%290, %$45] ; # Scl
  %293 = phi i64 [%286, %$45] ; # Num
  %294 = phi i1 [%287, %$45] ; # Sign
  %295 = phi i1 [%288, %$45] ; # Frac
  %296 = phi i8 [%289, %$45] ; # B
; # (set Num (tenfold (val Num)))
; # (val Num)
  %297 = inttoptr i64 %293 to i64*
  %298 = load i64, i64* %297
; # (tenfold (val Num))
  %299 = call i64 @tenfold(i64 %298)
  %300 = inttoptr i64 %293 to i64*
  store i64 %299, i64* %300
  br label %$45
$47:
  %301 = phi i64 [%290, %$45] ; # Scl
  %302 = phi i64 [%286, %$45] ; # Num
  %303 = phi i1 [%287, %$45] ; # Sign
  %304 = phi i1 [%288, %$45] ; # Frac
  %305 = phi i8 [%289, %$45] ; # B
  br label %$44
$44:
  %306 = phi i64 [%275, %$18], [%301, %$47] ; # Scl
  %307 = phi i64 [%276, %$18], [%302, %$47] ; # Num
  %308 = phi i1 [%277, %$18], [%303, %$47] ; # Sign
  %309 = phi i1 [%278, %$18], [%304, %$47] ; # Frac
  %310 = phi i8 [%279, %$18], [%305, %$47] ; # B
; # (val Num)
  %311 = inttoptr i64 %307 to i64*
  %312 = load i64, i64* %311
; # (if Sign (neg Num) Num)
  br i1 %308, label %$48, label %$49
$48:
  %313 = phi i64 [%306, %$44] ; # Scl
  %314 = phi i64 [%312, %$44] ; # Num
  %315 = phi i1 [%308, %$44] ; # Sign
  %316 = phi i1 [%309, %$44] ; # Frac
  %317 = phi i8 [%310, %$44] ; # B
; # (neg Num)
  %318 = icmp eq i64 %314, 2
  br i1 %318, label %$51, label %$52
$51:
  br label %$53
$52:
  %319 = xor i64 %314, 8
  br label %$53
$53:
  %320 = phi i64 [%314, %$51], [%319, %$52] ; # ->
  br label %$50
$49:
  %321 = phi i64 [%306, %$44] ; # Scl
  %322 = phi i64 [%312, %$44] ; # Num
  %323 = phi i1 [%308, %$44] ; # Sign
  %324 = phi i1 [%309, %$44] ; # Frac
  %325 = phi i8 [%310, %$44] ; # B
  br label %$50
$50:
  %326 = phi i64 [%313, %$53], [%321, %$49] ; # Scl
  %327 = phi i64 [%314, %$53], [%322, %$49] ; # Num
  %328 = phi i1 [%315, %$53], [%323, %$49] ; # Sign
  %329 = phi i1 [%316, %$53], [%324, %$49] ; # Frac
  %330 = phi i8 [%317, %$53], [%325, %$49] ; # B
  %331 = phi i64 [%320, %$53], [%322, %$49] ; # ->
; # (drop *Safe)
  %332 = inttoptr i64 %88 to i64*
  %333 = getelementptr i64, i64* %332, i32 1
  %334 = load i64, i64* %333
  %335 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %334, i64* %335
  ret i64 %331
}

define i64 @fmtWord(i64, i64, i8, i8, i64*) align 8 {
$1:
; # (when (> N 9) (setq Scl (fmtWord (/ N 10) Scl Sep Ign P)) (cond (...
; # (> N 9)
  %5 = icmp ugt i64 %0, 9
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%0, %$1] ; # N
  %7 = phi i64 [%1, %$1] ; # Scl
; # (/ N 10)
  %8 = udiv i64 %6, 10
; # (fmtWord (/ N 10) Scl Sep Ign P)
  %9 = call i64 @fmtWord(i64 %8, i64 %7, i8 %2, i8 %3, i64* %4)
; # (cond ((=0 Scl) (byteSym Sep P)) ((and Ign (gt0 Scl) (=0 (% Scl 3...
; # (=0 Scl)
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$6, label %$5
$6:
  %11 = phi i64 [%6, %$2] ; # N
  %12 = phi i64 [%9, %$2] ; # Scl
; # (byteSym Sep P)
  call void @byteSym(i8 %2, i64* %4)
  br label %$4
$5:
  %13 = phi i64 [%6, %$2] ; # N
  %14 = phi i64 [%9, %$2] ; # Scl
; # (and Ign (gt0 Scl) (=0 (% Scl 3)))
  %15 = icmp ne i8 %3, 0
  br i1 %15, label %$8, label %$7
$8:
  %16 = phi i64 [%13, %$5] ; # N
  %17 = phi i64 [%14, %$5] ; # Scl
; # (gt0 Scl)
  %18 = icmp sgt i64 %17, 0
  br i1 %18, label %$9, label %$7
$9:
  %19 = phi i64 [%16, %$8] ; # N
  %20 = phi i64 [%17, %$8] ; # Scl
; # (% Scl 3)
  %21 = urem i64 %20, 3
; # (=0 (% Scl 3))
  %22 = icmp eq i64 %21, 0
  br label %$7
$7:
  %23 = phi i64 [%13, %$5], [%16, %$8], [%19, %$9] ; # N
  %24 = phi i64 [%14, %$5], [%17, %$8], [%20, %$9] ; # Scl
  %25 = phi i1 [0, %$5], [0, %$8], [%22, %$9] ; # ->
  br i1 %25, label %$11, label %$10
$11:
  %26 = phi i64 [%23, %$7] ; # N
  %27 = phi i64 [%24, %$7] ; # Scl
; # (byteSym Ign P)
  call void @byteSym(i8 %3, i64* %4)
  br label %$4
$10:
  %28 = phi i64 [%23, %$7] ; # N
  %29 = phi i64 [%24, %$7] ; # Scl
  br label %$4
$4:
  %30 = phi i64 [%11, %$6], [%26, %$11], [%28, %$10] ; # N
  %31 = phi i64 [%12, %$6], [%27, %$11], [%29, %$10] ; # Scl
; # (dec 'Scl)
  %32 = sub i64 %31, 1
; # (% N 10)
  %33 = urem i64 %30, 10
  br label %$3
$3:
  %34 = phi i64 [%0, %$1], [%33, %$4] ; # N
  %35 = phi i64 [%1, %$1], [%32, %$4] ; # Scl
; # (i8 N)
  %36 = trunc i64 %34 to i8
; # (+ (i8 N) (char "0"))
  %37 = add i8 %36, 48
; # (byteSym (+ (i8 N) (char "0")) P)
  call void @byteSym(i8 %37, i64* %4)
  ret i64 %35
}

define i64 @fmtNum(i64, i64, i8, i8, i64*) align 8 {
$1:
; # (let (Sign (sign? Num) Len (+ 19 17)) (let N (setq Num (& Num -9)...
; # (sign? Num)
  %5 = and i64 %0, 8
  %6 = icmp ne i64 %5, 0
; # (+ 19 17)
; # (let N (setq Num (& Num -9)) (until (cnt? N) (inc 'Len 20) (setq ...
; # (& Num -9)
  %7 = and i64 %0, -9
; # (until (cnt? N) (inc 'Len 20) (setq N (val (big N))))
  br label %$2
$2:
  %8 = phi i64 [%7, %$1], [%14, %$3] ; # Num
  %9 = phi i64 [%1, %$1], [%15, %$3] ; # Scl
  %10 = phi i64 [36, %$1], [%18, %$3] ; # Len
  %11 = phi i64 [%7, %$1], [%21, %$3] ; # N
; # (cnt? N)
  %12 = and i64 %11, 2
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$4, label %$3
$3:
  %14 = phi i64 [%8, %$2] ; # Num
  %15 = phi i64 [%9, %$2] ; # Scl
  %16 = phi i64 [%10, %$2] ; # Len
  %17 = phi i64 [%11, %$2] ; # N
; # (inc 'Len 20)
  %18 = add i64 %16, 20
; # (big N)
  %19 = add i64 %17, 4
; # (val (big N))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
  br label %$2
$4:
  %22 = phi i64 [%8, %$2] ; # Num
  %23 = phi i64 [%9, %$2] ; # Scl
  %24 = phi i64 [%10, %$2] ; # Len
  %25 = phi i64 [%11, %$2] ; # N
; # (/ Len 18)
  %26 = udiv i64 %24, 18
; # (let (Acc (b64 Len) TopA Acc) (let (Inc (b64 Len) TopI Inc) (set ...
; # (b64 Len)
  %27 = alloca i64, i64 %26
; # (let (Inc (b64 Len) TopI Inc) (set Acc 0 Inc 1) (loop (let (Dig N...
; # (b64 Len)
  %28 = alloca i64, i64 %26
; # (set Acc 0 Inc 1)
  store i64 0, i64* %27
  store i64 1, i64* %28
; # (loop (let (Dig Num Mask 16) (when (big? Num) (setq Dig (val (dig...
  br label %$5
$5:
  %29 = phi i64 [%22, %$4], [%306, %$31] ; # Num
  %30 = phi i64 [%23, %$4], [%300, %$31] ; # Scl
  %31 = phi i64 [%26, %$4], [%301, %$31] ; # Len
  %32 = phi i64* [%27, %$4], [%302, %$31] ; # TopA
  %33 = phi i64* [%28, %$4], [%303, %$31] ; # TopI
; # (let (Dig Num Mask 16) (when (big? Num) (setq Dig (val (dig Num))...
; # (when (big? Num) (setq Dig (val (dig Num)) Mask 1))
; # (big? Num)
  %34 = and i64 %29, 4
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$6, label %$7
$6:
  %36 = phi i64 [%29, %$5] ; # Num
  %37 = phi i64 [%30, %$5] ; # Scl
  %38 = phi i64 [%31, %$5] ; # Len
  %39 = phi i64* [%32, %$5] ; # TopA
  %40 = phi i64* [%33, %$5] ; # TopI
  %41 = phi i64 [%29, %$5] ; # Dig
  %42 = phi i64 [16, %$5] ; # Mask
; # (dig Num)
  %43 = add i64 %36, -4
; # (val (dig Num))
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
  br label %$7
$7:
  %46 = phi i64 [%29, %$5], [%36, %$6] ; # Num
  %47 = phi i64 [%30, %$5], [%37, %$6] ; # Scl
  %48 = phi i64 [%31, %$5], [%38, %$6] ; # Len
  %49 = phi i64* [%32, %$5], [%39, %$6] ; # TopA
  %50 = phi i64* [%33, %$5], [%40, %$6] ; # TopI
  %51 = phi i64 [%29, %$5], [%45, %$6] ; # Dig
  %52 = phi i64 [16, %$5], [1, %$6] ; # Mask
; # (loop (when (& Dig Mask) (let (A Acc I Inc C 0) (loop (let N (+ (...
  br label %$8
$8:
  %53 = phi i64 [%46, %$7], [%282, %$29] ; # Num
  %54 = phi i64 [%47, %$7], [%283, %$29] ; # Scl
  %55 = phi i64 [%48, %$7], [%284, %$29] ; # Len
  %56 = phi i64* [%49, %$7], [%285, %$29] ; # TopA
  %57 = phi i64* [%50, %$7], [%286, %$29] ; # TopI
  %58 = phi i64 [%51, %$7], [%287, %$29] ; # Dig
  %59 = phi i64 [%52, %$7], [%288, %$29] ; # Mask
; # (when (& Dig Mask) (let (A Acc I Inc C 0) (loop (let N (+ (val A)...
; # (& Dig Mask)
  %60 = and i64 %58, %59
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$9, label %$10
$9:
  %62 = phi i64 [%53, %$8] ; # Num
  %63 = phi i64 [%54, %$8] ; # Scl
  %64 = phi i64 [%55, %$8] ; # Len
  %65 = phi i64* [%56, %$8] ; # TopA
  %66 = phi i64* [%57, %$8] ; # TopI
  %67 = phi i64 [%58, %$8] ; # Dig
  %68 = phi i64 [%59, %$8] ; # Mask
; # (let (A Acc I Inc C 0) (loop (let N (+ (val A) (val I) C) (setq C...
; # (loop (let N (+ (val A) (val I) C) (setq C (if (> 100000000000000...
  br label %$11
$11:
  %69 = phi i64 [%62, %$9], [%144, %$18] ; # Num
  %70 = phi i64 [%63, %$9], [%145, %$18] ; # Scl
  %71 = phi i64 [%64, %$9], [%146, %$18] ; # Len
  %72 = phi i64* [%65, %$9], [%147, %$18] ; # TopA
  %73 = phi i64* [%66, %$9], [%148, %$18] ; # TopI
  %74 = phi i64 [%67, %$9], [%149, %$18] ; # Dig
  %75 = phi i64 [%68, %$9], [%150, %$18] ; # Mask
  %76 = phi i64* [%27, %$9], [%151, %$18] ; # A
  %77 = phi i64* [%28, %$9], [%152, %$18] ; # I
  %78 = phi i64 [0, %$9], [%153, %$18] ; # C
; # (let N (+ (val A) (val I) C) (setq C (if (> 1000000000000000000 N...
; # (val A)
  %79 = load i64, i64* %76
; # (val I)
  %80 = load i64, i64* %77
; # (+ (val A) (val I) C)
  %81 = add i64 %79, %80
  %82 = add i64 %81, %78
; # (if (> 1000000000000000000 N) 0 (dec 'N 1000000000000000000) 1)
; # (> 1000000000000000000 N)
  %83 = icmp ugt i64 1000000000000000000, %82
  br i1 %83, label %$12, label %$13
$12:
  %84 = phi i64 [%69, %$11] ; # Num
  %85 = phi i64 [%70, %$11] ; # Scl
  %86 = phi i64 [%71, %$11] ; # Len
  %87 = phi i64* [%72, %$11] ; # TopA
  %88 = phi i64* [%73, %$11] ; # TopI
  %89 = phi i64 [%74, %$11] ; # Dig
  %90 = phi i64 [%75, %$11] ; # Mask
  %91 = phi i64* [%76, %$11] ; # A
  %92 = phi i64* [%77, %$11] ; # I
  %93 = phi i64 [%78, %$11] ; # C
  %94 = phi i64 [%82, %$11] ; # N
  br label %$14
$13:
  %95 = phi i64 [%69, %$11] ; # Num
  %96 = phi i64 [%70, %$11] ; # Scl
  %97 = phi i64 [%71, %$11] ; # Len
  %98 = phi i64* [%72, %$11] ; # TopA
  %99 = phi i64* [%73, %$11] ; # TopI
  %100 = phi i64 [%74, %$11] ; # Dig
  %101 = phi i64 [%75, %$11] ; # Mask
  %102 = phi i64* [%76, %$11] ; # A
  %103 = phi i64* [%77, %$11] ; # I
  %104 = phi i64 [%78, %$11] ; # C
  %105 = phi i64 [%82, %$11] ; # N
; # (dec 'N 1000000000000000000)
  %106 = sub i64 %105, 1000000000000000000
  br label %$14
$14:
  %107 = phi i64 [%84, %$12], [%95, %$13] ; # Num
  %108 = phi i64 [%85, %$12], [%96, %$13] ; # Scl
  %109 = phi i64 [%86, %$12], [%97, %$13] ; # Len
  %110 = phi i64* [%87, %$12], [%98, %$13] ; # TopA
  %111 = phi i64* [%88, %$12], [%99, %$13] ; # TopI
  %112 = phi i64 [%89, %$12], [%100, %$13] ; # Dig
  %113 = phi i64 [%90, %$12], [%101, %$13] ; # Mask
  %114 = phi i64* [%91, %$12], [%102, %$13] ; # A
  %115 = phi i64* [%92, %$12], [%103, %$13] ; # I
  %116 = phi i64 [%93, %$12], [%104, %$13] ; # C
  %117 = phi i64 [%94, %$12], [%106, %$13] ; # N
  %118 = phi i64 [0, %$12], [1, %$13] ; # ->
; # (set A N)
  store i64 %117, i64* %114
; # (? (> (inc 'I) TopI))
; # (inc 'I)
  %119 = getelementptr i64, i64* %115, i32 1
; # (> (inc 'I) TopI)
  %120 = icmp ugt i64* %119, %111
  br i1 %120, label %$16, label %$15
$15:
  %121 = phi i64 [%107, %$14] ; # Num
  %122 = phi i64 [%108, %$14] ; # Scl
  %123 = phi i64 [%109, %$14] ; # Len
  %124 = phi i64* [%110, %$14] ; # TopA
  %125 = phi i64* [%111, %$14] ; # TopI
  %126 = phi i64 [%112, %$14] ; # Dig
  %127 = phi i64 [%113, %$14] ; # Mask
  %128 = phi i64* [%114, %$14] ; # A
  %129 = phi i64* [%119, %$14] ; # I
  %130 = phi i64 [%118, %$14] ; # C
; # (when (> (inc 'A) TopA) (inc 'TopA) (set A 0))
; # (inc 'A)
  %131 = getelementptr i64, i64* %128, i32 1
; # (> (inc 'A) TopA)
  %132 = icmp ugt i64* %131, %124
  br i1 %132, label %$17, label %$18
$17:
  %133 = phi i64 [%121, %$15] ; # Num
  %134 = phi i64 [%122, %$15] ; # Scl
  %135 = phi i64 [%123, %$15] ; # Len
  %136 = phi i64* [%124, %$15] ; # TopA
  %137 = phi i64* [%125, %$15] ; # TopI
  %138 = phi i64 [%126, %$15] ; # Dig
  %139 = phi i64 [%127, %$15] ; # Mask
  %140 = phi i64* [%131, %$15] ; # A
  %141 = phi i64* [%129, %$15] ; # I
  %142 = phi i64 [%130, %$15] ; # C
; # (inc 'TopA)
  %143 = getelementptr i64, i64* %136, i32 1
; # (set A 0)
  store i64 0, i64* %140
  br label %$18
$18:
  %144 = phi i64 [%121, %$15], [%133, %$17] ; # Num
  %145 = phi i64 [%122, %$15], [%134, %$17] ; # Scl
  %146 = phi i64 [%123, %$15], [%135, %$17] ; # Len
  %147 = phi i64* [%124, %$15], [%143, %$17] ; # TopA
  %148 = phi i64* [%125, %$15], [%137, %$17] ; # TopI
  %149 = phi i64 [%126, %$15], [%138, %$17] ; # Dig
  %150 = phi i64 [%127, %$15], [%139, %$17] ; # Mask
  %151 = phi i64* [%131, %$15], [%140, %$17] ; # A
  %152 = phi i64* [%129, %$15], [%141, %$17] ; # I
  %153 = phi i64 [%130, %$15], [%142, %$17] ; # C
  br label %$11
$16:
  %154 = phi i64 [%107, %$14] ; # Num
  %155 = phi i64 [%108, %$14] ; # Scl
  %156 = phi i64 [%109, %$14] ; # Len
  %157 = phi i64* [%110, %$14] ; # TopA
  %158 = phi i64* [%111, %$14] ; # TopI
  %159 = phi i64 [%112, %$14] ; # Dig
  %160 = phi i64 [%113, %$14] ; # Mask
  %161 = phi i64* [%114, %$14] ; # A
  %162 = phi i64* [%119, %$14] ; # I
  %163 = phi i64 [%118, %$14] ; # C
  %164 = phi i64 [0, %$14] ; # ->
; # (when C (set (inc 'TopA) 1))
  %165 = icmp ne i64 %163, 0
  br i1 %165, label %$19, label %$20
$19:
  %166 = phi i64 [%154, %$16] ; # Num
  %167 = phi i64 [%155, %$16] ; # Scl
  %168 = phi i64 [%156, %$16] ; # Len
  %169 = phi i64* [%157, %$16] ; # TopA
  %170 = phi i64* [%158, %$16] ; # TopI
  %171 = phi i64 [%159, %$16] ; # Dig
  %172 = phi i64 [%160, %$16] ; # Mask
  %173 = phi i64* [%161, %$16] ; # A
  %174 = phi i64* [%162, %$16] ; # I
  %175 = phi i64 [%163, %$16] ; # C
; # (set (inc 'TopA) 1)
; # (inc 'TopA)
  %176 = getelementptr i64, i64* %169, i32 1
  store i64 1, i64* %176
  br label %$20
$20:
  %177 = phi i64 [%154, %$16], [%166, %$19] ; # Num
  %178 = phi i64 [%155, %$16], [%167, %$19] ; # Scl
  %179 = phi i64 [%156, %$16], [%168, %$19] ; # Len
  %180 = phi i64* [%157, %$16], [%176, %$19] ; # TopA
  %181 = phi i64* [%158, %$16], [%170, %$19] ; # TopI
  %182 = phi i64 [%159, %$16], [%171, %$19] ; # Dig
  %183 = phi i64 [%160, %$16], [%172, %$19] ; # Mask
  %184 = phi i64* [%161, %$16], [%173, %$19] ; # A
  %185 = phi i64* [%162, %$16], [%174, %$19] ; # I
  %186 = phi i64 [%163, %$16], [%175, %$19] ; # C
  br label %$10
$10:
  %187 = phi i64 [%53, %$8], [%177, %$20] ; # Num
  %188 = phi i64 [%54, %$8], [%178, %$20] ; # Scl
  %189 = phi i64 [%55, %$8], [%179, %$20] ; # Len
  %190 = phi i64* [%56, %$8], [%180, %$20] ; # TopA
  %191 = phi i64* [%57, %$8], [%181, %$20] ; # TopI
  %192 = phi i64 [%58, %$8], [%182, %$20] ; # Dig
  %193 = phi i64 [%59, %$8], [%183, %$20] ; # Mask
; # (let (I Inc C 0) (loop (let N (val I) (setq C (if (> 100000000000...
; # (loop (let N (val I) (setq C (if (> 1000000000000000000 (setq N (...
  br label %$21
$21:
  %194 = phi i64 [%187, %$10], [%241, %$25] ; # Num
  %195 = phi i64 [%188, %$10], [%242, %$25] ; # Scl
  %196 = phi i64 [%189, %$10], [%243, %$25] ; # Len
  %197 = phi i64* [%190, %$10], [%244, %$25] ; # TopA
  %198 = phi i64* [%191, %$10], [%245, %$25] ; # TopI
  %199 = phi i64 [%192, %$10], [%246, %$25] ; # Dig
  %200 = phi i64 [%193, %$10], [%247, %$25] ; # Mask
  %201 = phi i64* [%28, %$10], [%248, %$25] ; # I
  %202 = phi i64 [0, %$10], [%249, %$25] ; # C
; # (let N (val I) (setq C (if (> 1000000000000000000 (setq N (+ N N ...
; # (val I)
  %203 = load i64, i64* %201
; # (if (> 1000000000000000000 (setq N (+ N N C))) 0 (dec 'N 10000000...
; # (+ N N C)
  %204 = add i64 %203, %203
  %205 = add i64 %204, %202
; # (> 1000000000000000000 (setq N (+ N N C)))
  %206 = icmp ugt i64 1000000000000000000, %205
  br i1 %206, label %$22, label %$23
$22:
  %207 = phi i64 [%194, %$21] ; # Num
  %208 = phi i64 [%195, %$21] ; # Scl
  %209 = phi i64 [%196, %$21] ; # Len
  %210 = phi i64* [%197, %$21] ; # TopA
  %211 = phi i64* [%198, %$21] ; # TopI
  %212 = phi i64 [%199, %$21] ; # Dig
  %213 = phi i64 [%200, %$21] ; # Mask
  %214 = phi i64* [%201, %$21] ; # I
  %215 = phi i64 [%202, %$21] ; # C
  %216 = phi i64 [%205, %$21] ; # N
  br label %$24
$23:
  %217 = phi i64 [%194, %$21] ; # Num
  %218 = phi i64 [%195, %$21] ; # Scl
  %219 = phi i64 [%196, %$21] ; # Len
  %220 = phi i64* [%197, %$21] ; # TopA
  %221 = phi i64* [%198, %$21] ; # TopI
  %222 = phi i64 [%199, %$21] ; # Dig
  %223 = phi i64 [%200, %$21] ; # Mask
  %224 = phi i64* [%201, %$21] ; # I
  %225 = phi i64 [%202, %$21] ; # C
  %226 = phi i64 [%205, %$21] ; # N
; # (dec 'N 1000000000000000000)
  %227 = sub i64 %226, 1000000000000000000
  br label %$24
$24:
  %228 = phi i64 [%207, %$22], [%217, %$23] ; # Num
  %229 = phi i64 [%208, %$22], [%218, %$23] ; # Scl
  %230 = phi i64 [%209, %$22], [%219, %$23] ; # Len
  %231 = phi i64* [%210, %$22], [%220, %$23] ; # TopA
  %232 = phi i64* [%211, %$22], [%221, %$23] ; # TopI
  %233 = phi i64 [%212, %$22], [%222, %$23] ; # Dig
  %234 = phi i64 [%213, %$22], [%223, %$23] ; # Mask
  %235 = phi i64* [%214, %$22], [%224, %$23] ; # I
  %236 = phi i64 [%215, %$22], [%225, %$23] ; # C
  %237 = phi i64 [%216, %$22], [%227, %$23] ; # N
  %238 = phi i64 [0, %$22], [1, %$23] ; # ->
; # (set I N)
  store i64 %237, i64* %235
; # (? (> (inc 'I) TopI))
; # (inc 'I)
  %239 = getelementptr i64, i64* %235, i32 1
; # (> (inc 'I) TopI)
  %240 = icmp ugt i64* %239, %232
  br i1 %240, label %$26, label %$25
$25:
  %241 = phi i64 [%228, %$24] ; # Num
  %242 = phi i64 [%229, %$24] ; # Scl
  %243 = phi i64 [%230, %$24] ; # Len
  %244 = phi i64* [%231, %$24] ; # TopA
  %245 = phi i64* [%232, %$24] ; # TopI
  %246 = phi i64 [%233, %$24] ; # Dig
  %247 = phi i64 [%234, %$24] ; # Mask
  %248 = phi i64* [%239, %$24] ; # I
  %249 = phi i64 [%238, %$24] ; # C
  br label %$21
$26:
  %250 = phi i64 [%228, %$24] ; # Num
  %251 = phi i64 [%229, %$24] ; # Scl
  %252 = phi i64 [%230, %$24] ; # Len
  %253 = phi i64* [%231, %$24] ; # TopA
  %254 = phi i64* [%232, %$24] ; # TopI
  %255 = phi i64 [%233, %$24] ; # Dig
  %256 = phi i64 [%234, %$24] ; # Mask
  %257 = phi i64* [%239, %$24] ; # I
  %258 = phi i64 [%238, %$24] ; # C
  %259 = phi i64 [0, %$24] ; # ->
; # (when C (inc 'TopI) (set I 1))
  %260 = icmp ne i64 %258, 0
  br i1 %260, label %$27, label %$28
$27:
  %261 = phi i64 [%250, %$26] ; # Num
  %262 = phi i64 [%251, %$26] ; # Scl
  %263 = phi i64 [%252, %$26] ; # Len
  %264 = phi i64* [%253, %$26] ; # TopA
  %265 = phi i64* [%254, %$26] ; # TopI
  %266 = phi i64 [%255, %$26] ; # Dig
  %267 = phi i64 [%256, %$26] ; # Mask
  %268 = phi i64* [%257, %$26] ; # I
  %269 = phi i64 [%258, %$26] ; # C
; # (inc 'TopI)
  %270 = getelementptr i64, i64* %265, i32 1
; # (set I 1)
  store i64 1, i64* %268
  br label %$28
$28:
  %271 = phi i64 [%250, %$26], [%261, %$27] ; # Num
  %272 = phi i64 [%251, %$26], [%262, %$27] ; # Scl
  %273 = phi i64 [%252, %$26], [%263, %$27] ; # Len
  %274 = phi i64* [%253, %$26], [%264, %$27] ; # TopA
  %275 = phi i64* [%254, %$26], [%270, %$27] ; # TopI
  %276 = phi i64 [%255, %$26], [%266, %$27] ; # Dig
  %277 = phi i64 [%256, %$26], [%267, %$27] ; # Mask
  %278 = phi i64* [%257, %$26], [%268, %$27] ; # I
  %279 = phi i64 [%258, %$26], [%269, %$27] ; # C
; # (? (=0 (setq Mask (shl Mask 1))))
; # (shl Mask 1)
  %280 = shl i64 %277, 1
; # (=0 (setq Mask (shl Mask 1)))
  %281 = icmp eq i64 %280, 0
  br i1 %281, label %$30, label %$29
$29:
  %282 = phi i64 [%271, %$28] ; # Num
  %283 = phi i64 [%272, %$28] ; # Scl
  %284 = phi i64 [%273, %$28] ; # Len
  %285 = phi i64* [%274, %$28] ; # TopA
  %286 = phi i64* [%275, %$28] ; # TopI
  %287 = phi i64 [%276, %$28] ; # Dig
  %288 = phi i64 [%280, %$28] ; # Mask
  br label %$8
$30:
  %289 = phi i64 [%271, %$28] ; # Num
  %290 = phi i64 [%272, %$28] ; # Scl
  %291 = phi i64 [%273, %$28] ; # Len
  %292 = phi i64* [%274, %$28] ; # TopA
  %293 = phi i64* [%275, %$28] ; # TopI
  %294 = phi i64 [%276, %$28] ; # Dig
  %295 = phi i64 [%280, %$28] ; # Mask
  %296 = phi i64 [0, %$28] ; # ->
; # (? (cnt? Num))
; # (cnt? Num)
  %297 = and i64 %289, 2
  %298 = icmp ne i64 %297, 0
  br i1 %298, label %$32, label %$31
$31:
  %299 = phi i64 [%289, %$30] ; # Num
  %300 = phi i64 [%290, %$30] ; # Scl
  %301 = phi i64 [%291, %$30] ; # Len
  %302 = phi i64* [%292, %$30] ; # TopA
  %303 = phi i64* [%293, %$30] ; # TopI
; # (big Num)
  %304 = add i64 %299, 4
; # (val (big Num))
  %305 = inttoptr i64 %304 to i64*
  %306 = load i64, i64* %305
  br label %$5
$32:
  %307 = phi i64 [%289, %$30] ; # Num
  %308 = phi i64 [%290, %$30] ; # Scl
  %309 = phi i64 [%291, %$30] ; # Len
  %310 = phi i64* [%292, %$30] ; # TopA
  %311 = phi i64* [%293, %$30] ; # TopI
  %312 = phi i64 [0, %$30] ; # ->
; # (cond ((ge0 Scl) (when Sign (byteSym (char "-") P)) (let N (* (sh...
; # (ge0 Scl)
  %313 = icmp sge i64 %308, 0
  br i1 %313, label %$35, label %$34
$35:
  %314 = phi i64 [%307, %$32] ; # Num
  %315 = phi i64 [%308, %$32] ; # Scl
  %316 = phi i64 [%309, %$32] ; # Len
  %317 = phi i64* [%310, %$32] ; # TopA
; # (when Sign (byteSym (char "-") P))
  br i1 %6, label %$36, label %$37
$36:
  %318 = phi i64 [%314, %$35] ; # Num
  %319 = phi i64 [%315, %$35] ; # Scl
  %320 = phi i64 [%316, %$35] ; # Len
  %321 = phi i64* [%317, %$35] ; # TopA
; # (byteSym (char "-") P)
  call void @byteSym(i8 45, i64* %4)
  br label %$37
$37:
  %322 = phi i64 [%314, %$35], [%318, %$36] ; # Num
  %323 = phi i64 [%315, %$35], [%319, %$36] ; # Scl
  %324 = phi i64 [%316, %$35], [%320, %$36] ; # Len
  %325 = phi i64* [%317, %$35], [%321, %$36] ; # TopA
; # (let N (* (shr (- TopA Acc) 3) 18) (let D (val TopA) (while (setq...
; # (- TopA Acc)
  %326 = ptrtoint i64* %325 to i64
  %327 = ptrtoint i64* %27 to i64
  %328 = sub i64 %326, %327
; # (shr (- TopA Acc) 3)
  %329 = lshr i64 %328, 3
; # (* (shr (- TopA Acc) 3) 18)
  %330 = mul i64 %329, 18
; # (let D (val TopA) (while (setq D (/ D 10)) (inc 'N)))
; # (val TopA)
  %331 = load i64, i64* %325
; # (while (setq D (/ D 10)) (inc 'N))
  br label %$38
$38:
  %332 = phi i64 [%322, %$37], [%340, %$39] ; # Num
  %333 = phi i64 [%323, %$37], [%341, %$39] ; # Scl
  %334 = phi i64 [%324, %$37], [%342, %$39] ; # Len
  %335 = phi i64* [%325, %$37], [%343, %$39] ; # TopA
  %336 = phi i64 [%330, %$37], [%346, %$39] ; # N
  %337 = phi i64 [%331, %$37], [%345, %$39] ; # D
; # (/ D 10)
  %338 = udiv i64 %337, 10
  %339 = icmp ne i64 %338, 0
  br i1 %339, label %$39, label %$40
$39:
  %340 = phi i64 [%332, %$38] ; # Num
  %341 = phi i64 [%333, %$38] ; # Scl
  %342 = phi i64 [%334, %$38] ; # Len
  %343 = phi i64* [%335, %$38] ; # TopA
  %344 = phi i64 [%336, %$38] ; # N
  %345 = phi i64 [%338, %$38] ; # D
; # (inc 'N)
  %346 = add i64 %344, 1
  br label %$38
$40:
  %347 = phi i64 [%332, %$38] ; # Num
  %348 = phi i64 [%333, %$38] ; # Scl
  %349 = phi i64 [%334, %$38] ; # Len
  %350 = phi i64* [%335, %$38] ; # TopA
  %351 = phi i64 [%336, %$38] ; # N
  %352 = phi i64 [%338, %$38] ; # D
; # (when (lt0 (setq Scl (- N Scl))) (byteSym (char "0") P) (byteSym ...
; # (- N Scl)
  %353 = sub i64 %351, %348
; # (lt0 (setq Scl (- N Scl)))
  %354 = icmp slt i64 %353, 0
  br i1 %354, label %$41, label %$42
$41:
  %355 = phi i64 [%347, %$40] ; # Num
  %356 = phi i64 [%353, %$40] ; # Scl
  %357 = phi i64 [%349, %$40] ; # Len
  %358 = phi i64* [%350, %$40] ; # TopA
  %359 = phi i64 [%351, %$40] ; # N
; # (byteSym (char "0") P)
  call void @byteSym(i8 48, i64* %4)
; # (byteSym Sep P)
  call void @byteSym(i8 %2, i64* %4)
; # (while (> -1 Scl) (inc 'Scl) (byteSym (char "0") P))
  br label %$43
$43:
  %360 = phi i64 [%355, %$41], [%366, %$44] ; # Num
  %361 = phi i64 [%356, %$41], [%371, %$44] ; # Scl
  %362 = phi i64 [%357, %$41], [%368, %$44] ; # Len
  %363 = phi i64* [%358, %$41], [%369, %$44] ; # TopA
  %364 = phi i64 [%359, %$41], [%370, %$44] ; # N
; # (> -1 Scl)
  %365 = icmp ugt i64 -1, %361
  br i1 %365, label %$44, label %$45
$44:
  %366 = phi i64 [%360, %$43] ; # Num
  %367 = phi i64 [%361, %$43] ; # Scl
  %368 = phi i64 [%362, %$43] ; # Len
  %369 = phi i64* [%363, %$43] ; # TopA
  %370 = phi i64 [%364, %$43] ; # N
; # (inc 'Scl)
  %371 = add i64 %367, 1
; # (byteSym (char "0") P)
  call void @byteSym(i8 48, i64* %4)
  br label %$43
$45:
  %372 = phi i64 [%360, %$43] ; # Num
  %373 = phi i64 [%361, %$43] ; # Scl
  %374 = phi i64 [%362, %$43] ; # Len
  %375 = phi i64* [%363, %$43] ; # TopA
  %376 = phi i64 [%364, %$43] ; # N
  br label %$42
$42:
  %377 = phi i64 [%347, %$40], [%372, %$45] ; # Num
  %378 = phi i64 [%353, %$40], [%373, %$45] ; # Scl
  %379 = phi i64 [%349, %$40], [%374, %$45] ; # Len
  %380 = phi i64* [%350, %$40], [%375, %$45] ; # TopA
  %381 = phi i64 [%351, %$40], [%376, %$45] ; # N
; # (val TopA)
  %382 = load i64, i64* %380
; # (fmtWord (val TopA) Scl Sep Ign P)
  %383 = call i64 @fmtWord(i64 %382, i64 %378, i8 %2, i8 %3, i64* %4)
; # (while (>= (dec 'TopA) Acc) (let (N (val TopA) D 1000000000000000...
  br label %$46
$46:
  %384 = phi i64 [%377, %$42], [%468, %$59] ; # Num
  %385 = phi i64 [%383, %$42], [%469, %$59] ; # Scl
  %386 = phi i64 [%379, %$42], [%470, %$59] ; # Len
  %387 = phi i64* [%380, %$42], [%471, %$59] ; # TopA
; # (dec 'TopA)
  %388 = getelementptr i64, i64* %387, i32 -1
; # (>= (dec 'TopA) Acc)
  %389 = icmp uge i64* %388, %27
  br i1 %389, label %$47, label %$48
$47:
  %390 = phi i64 [%384, %$46] ; # Num
  %391 = phi i64 [%385, %$46] ; # Scl
  %392 = phi i64 [%386, %$46] ; # Len
  %393 = phi i64* [%388, %$46] ; # TopA
; # (let (N (val TopA) D 100000000000000000) (loop (cond ((=0 Scl) (b...
; # (val TopA)
  %394 = load i64, i64* %393
; # (loop (cond ((=0 Scl) (byteSym Sep P)) ((and Ign (gt0 Scl) (=0 (%...
  br label %$49
$49:
  %395 = phi i64 [%390, %$47], [%457, %$58] ; # Num
  %396 = phi i64 [%391, %$47], [%458, %$58] ; # Scl
  %397 = phi i64 [%392, %$47], [%459, %$58] ; # Len
  %398 = phi i64* [%393, %$47], [%460, %$58] ; # TopA
  %399 = phi i64 [%394, %$47], [%466, %$58] ; # N
  %400 = phi i64 [100000000000000000, %$47], [%467, %$58] ; # D
; # (cond ((=0 Scl) (byteSym Sep P)) ((and Ign (gt0 Scl) (=0 (% Scl 3...
; # (=0 Scl)
  %401 = icmp eq i64 %396, 0
  br i1 %401, label %$52, label %$51
$52:
  %402 = phi i64 [%395, %$49] ; # Num
  %403 = phi i64 [%396, %$49] ; # Scl
  %404 = phi i64 [%397, %$49] ; # Len
  %405 = phi i64* [%398, %$49] ; # TopA
  %406 = phi i64 [%399, %$49] ; # N
  %407 = phi i64 [%400, %$49] ; # D
; # (byteSym Sep P)
  call void @byteSym(i8 %2, i64* %4)
  br label %$50
$51:
  %408 = phi i64 [%395, %$49] ; # Num
  %409 = phi i64 [%396, %$49] ; # Scl
  %410 = phi i64 [%397, %$49] ; # Len
  %411 = phi i64* [%398, %$49] ; # TopA
  %412 = phi i64 [%399, %$49] ; # N
  %413 = phi i64 [%400, %$49] ; # D
; # (and Ign (gt0 Scl) (=0 (% Scl 3)))
  %414 = icmp ne i8 %3, 0
  br i1 %414, label %$54, label %$53
$54:
  %415 = phi i64 [%408, %$51] ; # Num
  %416 = phi i64 [%409, %$51] ; # Scl
  %417 = phi i64 [%410, %$51] ; # Len
  %418 = phi i64* [%411, %$51] ; # TopA
  %419 = phi i64 [%412, %$51] ; # N
  %420 = phi i64 [%413, %$51] ; # D
; # (gt0 Scl)
  %421 = icmp sgt i64 %416, 0
  br i1 %421, label %$55, label %$53
$55:
  %422 = phi i64 [%415, %$54] ; # Num
  %423 = phi i64 [%416, %$54] ; # Scl
  %424 = phi i64 [%417, %$54] ; # Len
  %425 = phi i64* [%418, %$54] ; # TopA
  %426 = phi i64 [%419, %$54] ; # N
  %427 = phi i64 [%420, %$54] ; # D
; # (% Scl 3)
  %428 = urem i64 %423, 3
; # (=0 (% Scl 3))
  %429 = icmp eq i64 %428, 0
  br label %$53
$53:
  %430 = phi i64 [%408, %$51], [%415, %$54], [%422, %$55] ; # Num
  %431 = phi i64 [%409, %$51], [%416, %$54], [%423, %$55] ; # Scl
  %432 = phi i64 [%410, %$51], [%417, %$54], [%424, %$55] ; # Len
  %433 = phi i64* [%411, %$51], [%418, %$54], [%425, %$55] ; # TopA
  %434 = phi i64 [%412, %$51], [%419, %$54], [%426, %$55] ; # N
  %435 = phi i64 [%413, %$51], [%420, %$54], [%427, %$55] ; # D
  %436 = phi i1 [0, %$51], [0, %$54], [%429, %$55] ; # ->
  br i1 %436, label %$57, label %$56
$57:
  %437 = phi i64 [%430, %$53] ; # Num
  %438 = phi i64 [%431, %$53] ; # Scl
  %439 = phi i64 [%432, %$53] ; # Len
  %440 = phi i64* [%433, %$53] ; # TopA
  %441 = phi i64 [%434, %$53] ; # N
  %442 = phi i64 [%435, %$53] ; # D
; # (byteSym Ign P)
  call void @byteSym(i8 %3, i64* %4)
  br label %$50
$56:
  %443 = phi i64 [%430, %$53] ; # Num
  %444 = phi i64 [%431, %$53] ; # Scl
  %445 = phi i64 [%432, %$53] ; # Len
  %446 = phi i64* [%433, %$53] ; # TopA
  %447 = phi i64 [%434, %$53] ; # N
  %448 = phi i64 [%435, %$53] ; # D
  br label %$50
$50:
  %449 = phi i64 [%402, %$52], [%437, %$57], [%443, %$56] ; # Num
  %450 = phi i64 [%403, %$52], [%438, %$57], [%444, %$56] ; # Scl
  %451 = phi i64 [%404, %$52], [%439, %$57], [%445, %$56] ; # Len
  %452 = phi i64* [%405, %$52], [%440, %$57], [%446, %$56] ; # TopA
  %453 = phi i64 [%406, %$52], [%441, %$57], [%447, %$56] ; # N
  %454 = phi i64 [%407, %$52], [%442, %$57], [%448, %$56] ; # D
; # (dec 'Scl)
  %455 = sub i64 %450, 1
; # (? (== 1 D))
; # (== 1 D)
  %456 = icmp eq i64 1, %454
  br i1 %456, label %$59, label %$58
$58:
  %457 = phi i64 [%449, %$50] ; # Num
  %458 = phi i64 [%455, %$50] ; # Scl
  %459 = phi i64 [%451, %$50] ; # Len
  %460 = phi i64* [%452, %$50] ; # TopA
  %461 = phi i64 [%453, %$50] ; # N
  %462 = phi i64 [%454, %$50] ; # D
; # (/ N D)
  %463 = udiv i64 %461, %462
; # (i8 (/ N D))
  %464 = trunc i64 %463 to i8
; # (+ (i8 (/ N D)) (char "0"))
  %465 = add i8 %464, 48
; # (byteSym (+ (i8 (/ N D)) (char "0")) P)
  call void @byteSym(i8 %465, i64* %4)
; # (% N D)
  %466 = urem i64 %461, %462
; # (/ D 10)
  %467 = udiv i64 %462, 10
  br label %$49
$59:
  %468 = phi i64 [%449, %$50] ; # Num
  %469 = phi i64 [%455, %$50] ; # Scl
  %470 = phi i64 [%451, %$50] ; # Len
  %471 = phi i64* [%452, %$50] ; # TopA
  %472 = phi i64 [%453, %$50] ; # N
  %473 = phi i64 [%454, %$50] ; # D
  %474 = phi i64 [0, %$50] ; # ->
; # (i8 N)
  %475 = trunc i64 %472 to i8
; # (+ (i8 N) (char "0"))
  %476 = add i8 %475, 48
; # (byteSym (+ (i8 N) (char "0")) P)
  call void @byteSym(i8 %476, i64* %4)
  br label %$46
$48:
  %477 = phi i64 [%384, %$46] ; # Num
  %478 = phi i64 [%385, %$46] ; # Scl
  %479 = phi i64 [%386, %$46] ; # Len
  %480 = phi i64* [%388, %$46] ; # TopA
  br label %$33
$34:
  %481 = phi i64 [%307, %$32] ; # Num
  %482 = phi i64 [%308, %$32] ; # Scl
  %483 = phi i64 [%309, %$32] ; # Len
  %484 = phi i64* [%310, %$32] ; # TopA
; # (== Scl -1)
  %485 = icmp eq i64 %482, -1
  br i1 %485, label %$61, label %$60
$61:
  %486 = phi i64 [%481, %$34] ; # Num
  %487 = phi i64 [%482, %$34] ; # Scl
  %488 = phi i64 [%483, %$34] ; # Len
  %489 = phi i64* [%484, %$34] ; # TopA
; # (when Sign (call $Put (char "-")))
  br i1 %6, label %$62, label %$63
$62:
  %490 = phi i64 [%486, %$61] ; # Num
  %491 = phi i64 [%487, %$61] ; # Scl
  %492 = phi i64 [%488, %$61] ; # Len
  %493 = phi i64* [%489, %$61] ; # TopA
; # (call $Put (char "-"))
  %494 = load void(i8)*, void(i8)** @$Put
  call void %494(i8 45)
  br label %$63
$63:
  %495 = phi i64 [%486, %$61], [%490, %$62] ; # Num
  %496 = phi i64 [%487, %$61], [%491, %$62] ; # Scl
  %497 = phi i64 [%488, %$61], [%492, %$62] ; # Len
  %498 = phi i64* [%489, %$61], [%493, %$62] ; # TopA
; # (val TopA)
  %499 = load i64, i64* %498
; # (outWord (val TopA))
  call void @outWord(i64 %499)
; # (while (>= (dec 'TopA) Acc) (let (N (val TopA) D 1000000000000000...
  br label %$64
$64:
  %500 = phi i64 [%495, %$63], [%530, %$69] ; # Num
  %501 = phi i64 [%496, %$63], [%531, %$69] ; # Scl
  %502 = phi i64 [%497, %$63], [%532, %$69] ; # Len
  %503 = phi i64* [%498, %$63], [%533, %$69] ; # TopA
; # (dec 'TopA)
  %504 = getelementptr i64, i64* %503, i32 -1
; # (>= (dec 'TopA) Acc)
  %505 = icmp uge i64* %504, %27
  br i1 %505, label %$65, label %$66
$65:
  %506 = phi i64 [%500, %$64] ; # Num
  %507 = phi i64 [%501, %$64] ; # Scl
  %508 = phi i64 [%502, %$64] ; # Len
  %509 = phi i64* [%504, %$64] ; # TopA
; # (let (N (val TopA) D 100000000000000000) (loop (call $Put (+ (i8 ...
; # (val TopA)
  %510 = load i64, i64* %509
; # (loop (call $Put (+ (i8 (/ N D)) (char "0"))) (setq N (% N D)) (?...
  br label %$67
$67:
  %511 = phi i64 [%506, %$65], [%524, %$68] ; # Num
  %512 = phi i64 [%507, %$65], [%525, %$68] ; # Scl
  %513 = phi i64 [%508, %$65], [%526, %$68] ; # Len
  %514 = phi i64* [%509, %$65], [%527, %$68] ; # TopA
  %515 = phi i64 [%510, %$65], [%528, %$68] ; # N
  %516 = phi i64 [100000000000000000, %$65], [%529, %$68] ; # D
; # (/ N D)
  %517 = udiv i64 %515, %516
; # (i8 (/ N D))
  %518 = trunc i64 %517 to i8
; # (+ (i8 (/ N D)) (char "0"))
  %519 = add i8 %518, 48
; # (call $Put (+ (i8 (/ N D)) (char "0")))
  %520 = load void(i8)*, void(i8)** @$Put
  call void %520(i8 %519)
; # (% N D)
  %521 = urem i64 %515, %516
; # (? (== 1 (setq D (/ D 10))))
; # (/ D 10)
  %522 = udiv i64 %516, 10
; # (== 1 (setq D (/ D 10)))
  %523 = icmp eq i64 1, %522
  br i1 %523, label %$69, label %$68
$68:
  %524 = phi i64 [%511, %$67] ; # Num
  %525 = phi i64 [%512, %$67] ; # Scl
  %526 = phi i64 [%513, %$67] ; # Len
  %527 = phi i64* [%514, %$67] ; # TopA
  %528 = phi i64 [%521, %$67] ; # N
  %529 = phi i64 [%522, %$67] ; # D
  br label %$67
$69:
  %530 = phi i64 [%511, %$67] ; # Num
  %531 = phi i64 [%512, %$67] ; # Scl
  %532 = phi i64 [%513, %$67] ; # Len
  %533 = phi i64* [%514, %$67] ; # TopA
  %534 = phi i64 [%521, %$67] ; # N
  %535 = phi i64 [%522, %$67] ; # D
  %536 = phi i64 [0, %$67] ; # ->
; # (i8 N)
  %537 = trunc i64 %534 to i8
; # (+ (i8 N) (char "0"))
  %538 = add i8 %537, 48
; # (call $Put (+ (i8 N) (char "0")))
  %539 = load void(i8)*, void(i8)** @$Put
  call void %539(i8 %538)
  br label %$64
$66:
  %540 = phi i64 [%500, %$64] ; # Num
  %541 = phi i64 [%501, %$64] ; # Scl
  %542 = phi i64 [%502, %$64] ; # Len
  %543 = phi i64* [%504, %$64] ; # TopA
  br label %$33
$60:
  %544 = phi i64 [%481, %$34] ; # Num
  %545 = phi i64 [%482, %$34] ; # Scl
  %546 = phi i64 [%483, %$34] ; # Len
  %547 = phi i64* [%484, %$34] ; # TopA
; # (let (N (* (shr (- TopA Acc) 3) 18) D (val TopA)) (loop (inc 'N) ...
; # (- TopA Acc)
  %548 = ptrtoint i64* %547 to i64
  %549 = ptrtoint i64* %27 to i64
  %550 = sub i64 %548, %549
; # (shr (- TopA Acc) 3)
  %551 = lshr i64 %550, 3
; # (* (shr (- TopA Acc) 3) 18)
  %552 = mul i64 %551, 18
; # (val TopA)
  %553 = load i64, i64* %547
; # (loop (inc 'N) (? (=0 (setq D (/ D 10)))))
  br label %$70
$70:
  %554 = phi i64 [%544, %$60], [%563, %$71] ; # Num
  %555 = phi i64 [%545, %$60], [%564, %$71] ; # Scl
  %556 = phi i64 [%546, %$60], [%565, %$71] ; # Len
  %557 = phi i64* [%547, %$60], [%566, %$71] ; # TopA
  %558 = phi i64 [%552, %$60], [%567, %$71] ; # N
  %559 = phi i64 [%553, %$60], [%568, %$71] ; # D
; # (inc 'N)
  %560 = add i64 %558, 1
; # (? (=0 (setq D (/ D 10))))
; # (/ D 10)
  %561 = udiv i64 %559, 10
; # (=0 (setq D (/ D 10)))
  %562 = icmp eq i64 %561, 0
  br i1 %562, label %$72, label %$71
$71:
  %563 = phi i64 [%554, %$70] ; # Num
  %564 = phi i64 [%555, %$70] ; # Scl
  %565 = phi i64 [%556, %$70] ; # Len
  %566 = phi i64* [%557, %$70] ; # TopA
  %567 = phi i64 [%560, %$70] ; # N
  %568 = phi i64 [%561, %$70] ; # D
  br label %$70
$72:
  %569 = phi i64 [%554, %$70] ; # Num
  %570 = phi i64 [%555, %$70] ; # Scl
  %571 = phi i64 [%556, %$70] ; # Len
  %572 = phi i64* [%557, %$70] ; # TopA
  %573 = phi i64 [%560, %$70] ; # N
  %574 = phi i64 [%561, %$70] ; # D
  %575 = phi i64 [0, %$70] ; # ->
; # (when Sign (inc 'N))
  br i1 %6, label %$73, label %$74
$73:
  %576 = phi i64 [%569, %$72] ; # Num
  %577 = phi i64 [%570, %$72] ; # Scl
  %578 = phi i64 [%571, %$72] ; # Len
  %579 = phi i64* [%572, %$72] ; # TopA
  %580 = phi i64 [%573, %$72] ; # N
  %581 = phi i64 [%574, %$72] ; # D
; # (inc 'N)
  %582 = add i64 %580, 1
  br label %$74
$74:
  %583 = phi i64 [%569, %$72], [%576, %$73] ; # Num
  %584 = phi i64 [%570, %$72], [%577, %$73] ; # Scl
  %585 = phi i64 [%571, %$72], [%578, %$73] ; # Len
  %586 = phi i64* [%572, %$72], [%579, %$73] ; # TopA
  %587 = phi i64 [%573, %$72], [%582, %$73] ; # N
  %588 = phi i64 [%574, %$72], [%581, %$73] ; # D
; # (cnt N)
  %589 = shl i64 %587, 4
  %590 = or i64 %589, 2
  br label %$33
$33:
  %591 = phi i64 [%477, %$48], [%540, %$66], [%583, %$74] ; # Num
  %592 = phi i64 [%478, %$48], [%541, %$66], [%584, %$74] ; # Scl
  %593 = phi i64 [%479, %$48], [%542, %$66], [%585, %$74] ; # Len
  %594 = phi i64* [%480, %$48], [%543, %$66], [%586, %$74] ; # TopA
  %595 = phi i64 [0, %$48], [0, %$66], [%590, %$74] ; # ->
  ret i64 %595
}

define i64 @_format(i64) align 8 {
$1:
; # (let (X (cdr Exe) A (save (eval (++ X))) Y (eval (++ X)) Scl (if ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (if (nil? Y) 0 (xCnt Exe Y))
; # (nil? Y)
  %36 = icmp eq i64 %35, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %36, label %$12, label %$13
$12:
  %37 = phi i64 [%27, %$7] ; # X
  br label %$14
$13:
  %38 = phi i64 [%27, %$7] ; # X
; # (xCnt Exe Y)
  %39 = call i64 @xCnt(i64 %0, i64 %35)
  br label %$14
$14:
  %40 = phi i64 [%37, %$12], [%38, %$13] ; # X
  %41 = phi i64 [0, %$12], [%39, %$13] ; # ->
; # (i8 (char "."))
; # (i8 0)
; # (when (pair X) (setq Sep (firstByte (needSymb Exe (eval (++ X))))...
; # (pair X)
  %42 = and i64 %40, 15
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %$15, label %$16
$15:
  %44 = phi i64 [%40, %$14] ; # X
  %45 = phi i8 [46, %$14] ; # Sep
  %46 = phi i8 [0, %$14] ; # Ign
; # (++ X)
  %47 = inttoptr i64 %44 to i64*
  %48 = load i64, i64* %47
  %49 = getelementptr i64, i64* %47, i32 1
  %50 = load i64, i64* %49
; # (eval (++ X))
  %51 = and i64 %48, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$19, label %$18
$19:
  br label %$17
$18:
  %53 = and i64 %48, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$21, label %$20
$21:
  %55 = inttoptr i64 %48 to i64*
  %56 = load i64, i64* %55
  br label %$17
$20:
  %57 = call i64 @evList(i64 %48)
  br label %$17
$17:
  %58 = phi i64 [%48, %$19], [%56, %$21], [%57, %$20] ; # ->
; # (needSymb Exe (eval (++ X)))
  %59 = xor i64 %58, 8
  %60 = and i64 %59, 14
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %$23, label %$22
$22:
  call void @symErr(i64 %0, i64 %58)
  unreachable
$23:
; # (firstByte (needSymb Exe (eval (++ X))))
  %62 = call i8 @firstByte(i64 %58)
; # (when (pair X) (setq Ign (firstByte (needSymb Exe (eval (car X)))...
; # (pair X)
  %63 = and i64 %50, 15
  %64 = icmp eq i64 %63, 0
  br i1 %64, label %$24, label %$25
$24:
  %65 = phi i64 [%50, %$23] ; # X
  %66 = phi i8 [%62, %$23] ; # Sep
  %67 = phi i8 [%46, %$23] ; # Ign
; # (car X)
  %68 = inttoptr i64 %65 to i64*
  %69 = load i64, i64* %68
; # (eval (car X))
  %70 = and i64 %69, 6
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$28, label %$27
$28:
  br label %$26
$27:
  %72 = and i64 %69, 8
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$30, label %$29
$30:
  %74 = inttoptr i64 %69 to i64*
  %75 = load i64, i64* %74
  br label %$26
$29:
  %76 = call i64 @evList(i64 %69)
  br label %$26
$26:
  %77 = phi i64 [%69, %$28], [%75, %$30], [%76, %$29] ; # ->
; # (needSymb Exe (eval (car X)))
  %78 = xor i64 %77, 8
  %79 = and i64 %78, 14
  %80 = icmp eq i64 %79, 0
  br i1 %80, label %$32, label %$31
$31:
  call void @symErr(i64 %0, i64 %77)
  unreachable
$32:
; # (firstByte (needSymb Exe (eval (car X))))
  %81 = call i8 @firstByte(i64 %77)
  br label %$25
$25:
  %82 = phi i64 [%50, %$23], [%65, %$32] ; # X
  %83 = phi i8 [%62, %$23], [%66, %$32] ; # Sep
  %84 = phi i8 [%46, %$23], [%81, %$32] ; # Ign
  br label %$16
$16:
  %85 = phi i64 [%40, %$14], [%82, %$25] ; # X
  %86 = phi i8 [46, %$14], [%83, %$25] ; # Sep
  %87 = phi i8 [0, %$14], [%84, %$25] ; # Ign
; # (cond ((num? A) (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (fm...
; # (num? A)
  %88 = and i64 %15, 6
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$35, label %$34
$35:
  %90 = phi i64 [%85, %$16] ; # X
  %91 = phi i8 [%86, %$16] ; # Sep
  %92 = phi i8 [%87, %$16] ; # Ign
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (fmtNum A Scl Sep I...
; # (push 4 NIL ZERO NIL)
  %93 = alloca i64, i64 4, align 16
  store i64 4, i64* %93
  %94 = getelementptr i64, i64* %93, i32 2
  store i64 2, i64* %94
; # (ofs P 2)
  %95 = getelementptr i64, i64* %93, i32 2
; # (link (ofs P 2))
  %96 = ptrtoint i64* %95 to i64
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %98 = load i64, i64* %97
  %99 = inttoptr i64 %96 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  store i64 %98, i64* %100
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %96, i64* %101
; # (fmtNum A Scl Sep Ign P)
  %102 = call i64 @fmtNum(i64 %15, i64 %41, i8 %91, i8 %92, i64* %93)
; # (val 3 P)
  %103 = getelementptr i64, i64* %93, i32 2
  %104 = load i64, i64* %103
; # (consStr (val 3 P))
  %105 = call i64 @consStr(i64 %104)
  br label %$33
$34:
  %106 = phi i64 [%85, %$16] ; # X
  %107 = phi i8 [%86, %$16] ; # Sep
  %108 = phi i8 [%87, %$16] ; # Ign
; # (sym? A)
  %109 = and i64 %15, 8
  %110 = icmp ne i64 %109, 0
  br i1 %110, label %$37, label %$36
$37:
  %111 = phi i64 [%106, %$34] ; # X
  %112 = phi i8 [%107, %$34] ; # Sep
  %113 = phi i8 [%108, %$34] ; # Ign
; # (cond ((sym? (val (tail A))) $Nil) ((=0 (symToNum (name @) Scl Se...
; # (tail A)
  %114 = add i64 %15, -8
; # (val (tail A))
  %115 = inttoptr i64 %114 to i64*
  %116 = load i64, i64* %115
; # (sym? (val (tail A)))
  %117 = and i64 %116, 8
  %118 = icmp ne i64 %117, 0
  br i1 %118, label %$40, label %$39
$40:
  %119 = phi i64 [%111, %$37] ; # X
  %120 = phi i8 [%112, %$37] ; # Sep
  %121 = phi i8 [%113, %$37] ; # Ign
  br label %$38
$39:
  %122 = phi i64 [%111, %$37] ; # X
  %123 = phi i8 [%112, %$37] ; # Sep
  %124 = phi i8 [%113, %$37] ; # Ign
; # (name @)
  br label %$41
$41:
  %125 = phi i64 [%116, %$39], [%131, %$42] ; # Tail
  %126 = and i64 %125, 6
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$43, label %$42
$42:
  %128 = phi i64 [%125, %$41] ; # Tail
  %129 = inttoptr i64 %128 to i64*
  %130 = getelementptr i64, i64* %129, i32 1
  %131 = load i64, i64* %130
  br label %$41
$43:
  %132 = phi i64 [%125, %$41] ; # Tail
; # (symToNum (name @) Scl Sep Ign)
  %133 = call i64 @symToNum(i64 %132, i64 %41, i8 %123, i8 %124)
; # (=0 (symToNum (name @) Scl Sep Ign))
  %134 = icmp eq i64 %133, 0
  br i1 %134, label %$45, label %$44
$45:
  %135 = phi i64 [%122, %$43] ; # X
  %136 = phi i8 [%123, %$43] ; # Sep
  %137 = phi i8 [%124, %$43] ; # Ign
  br label %$38
$44:
  %138 = phi i64 [%122, %$43] ; # X
  %139 = phi i8 [%123, %$43] ; # Sep
  %140 = phi i8 [%124, %$43] ; # Ign
  br label %$38
$38:
  %141 = phi i64 [%119, %$40], [%135, %$45], [%138, %$44] ; # X
  %142 = phi i8 [%120, %$40], [%136, %$45], [%139, %$44] ; # Sep
  %143 = phi i8 [%121, %$40], [%137, %$45], [%140, %$44] ; # Ign
  %144 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$40], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$45], [%133, %$44] ; # ->
  br label %$33
$36:
  %145 = phi i64 [%106, %$34] ; # X
  %146 = phi i8 [%107, %$34] ; # Sep
  %147 = phi i8 [%108, %$34] ; # Ign
; # (if (symToNum (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (pack...
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (pack A P) (val 3 P...
; # (push 4 NIL ZERO NIL)
  %148 = alloca i64, i64 4, align 16
  store i64 4, i64* %148
  %149 = getelementptr i64, i64* %148, i32 2
  store i64 2, i64* %149
; # (ofs P 2)
  %150 = getelementptr i64, i64* %148, i32 2
; # (link (ofs P 2))
  %151 = ptrtoint i64* %150 to i64
  %152 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %153 = load i64, i64* %152
  %154 = inttoptr i64 %151 to i64*
  %155 = getelementptr i64, i64* %154, i32 1
  store i64 %153, i64* %155
  %156 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %151, i64* %156
; # (pack A P)
  call void @pack(i64 %15, i64* %148)
; # (val 3 P)
  %157 = getelementptr i64, i64* %148, i32 2
  %158 = load i64, i64* %157
; # (symToNum (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (pack A P...
  %159 = call i64 @symToNum(i64 %158, i64 %41, i8 %146, i8 %147)
  %160 = icmp ne i64 %159, 0
  br i1 %160, label %$46, label %$47
$46:
  %161 = phi i64 [%145, %$36] ; # X
  %162 = phi i8 [%146, %$36] ; # Sep
  %163 = phi i8 [%147, %$36] ; # Ign
  br label %$48
$47:
  %164 = phi i64 [%145, %$36] ; # X
  %165 = phi i8 [%146, %$36] ; # Sep
  %166 = phi i8 [%147, %$36] ; # Ign
  br label %$48
$48:
  %167 = phi i64 [%161, %$46], [%164, %$47] ; # X
  %168 = phi i8 [%162, %$46], [%165, %$47] ; # Sep
  %169 = phi i8 [%163, %$46], [%166, %$47] ; # Ign
  %170 = phi i64 [%159, %$46], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$47] ; # ->
  br label %$33
$33:
  %171 = phi i64 [%90, %$35], [%141, %$38], [%167, %$48] ; # X
  %172 = phi i8 [%91, %$35], [%142, %$38], [%168, %$48] ; # Sep
  %173 = phi i8 [%92, %$35], [%143, %$38], [%169, %$48] ; # Ign
  %174 = phi i64 [%105, %$35], [%144, %$38], [%170, %$48] ; # ->
; # (drop *Safe)
  %175 = inttoptr i64 %19 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  %177 = load i64, i64* %176
  %178 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %177, i64* %178
  ret i64 %174
}

define i64 @_add(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (needN...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (needNum Exe @) NIL)) (loop (? (at...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let R (link (push (needNum Exe @) NIL)) (loop (? (atom (shift X)...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (push (needNum Exe @) NIL)
  %27 = alloca i64, i64 2, align 16
  %28 = ptrtoint i64* %27 to i64
  %29 = inttoptr i64 %28 to i64*
  store i64 %13, i64* %29
; # (link (push (needNum Exe @) NIL))
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %31 = load i64, i64* %30
  %32 = inttoptr i64 %28 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %31, i64* %33
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %34
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %35 = phi i64 [%16, %$11], [%57, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
; # (atom (shift X))
  %39 = and i64 %38, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$15, label %$13
$15:
  %41 = phi i64 [%38, %$12] ; # X
; # (val R)
  %42 = inttoptr i64 %28 to i64*
  %43 = load i64, i64* %42
  br label %$14
$13:
  %44 = phi i64 [%38, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (eval (car X))
  %47 = and i64 %46, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$18, label %$17
$18:
  br label %$16
$17:
  %49 = and i64 %46, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$20, label %$19
$20:
  %51 = inttoptr i64 %46 to i64*
  %52 = load i64, i64* %51
  br label %$16
$19:
  %53 = call i64 @evList(i64 %46)
  br label %$16
$16:
  %54 = phi i64 [%46, %$18], [%52, %$20], [%53, %$19] ; # ->
; # (nil? (eval (car X)))
  %55 = icmp eq i64 %54, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %55, label %$22, label %$21
$22:
  %56 = phi i64 [%44, %$16] ; # X
  br label %$14
$21:
  %57 = phi i64 [%44, %$16] ; # X
; # (needNum Exe @)
  %58 = and i64 %54, 6
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %54)
  unreachable
$24:
; # (safe (needNum Exe @))
  %60 = inttoptr i64 %20 to i64*
  store i64 %54, i64* %60
; # (set R (adds (val R) @))
; # (val R)
  %61 = inttoptr i64 %28 to i64*
  %62 = load i64, i64* %61
; # (adds (val R) @)
  %63 = call i64 @adds(i64 %62, i64 %54)
  %64 = inttoptr i64 %28 to i64*
  store i64 %63, i64* %64
  br label %$12
$14:
  %65 = phi i64 [%41, %$15], [%56, %$22] ; # X
  %66 = phi i64 [%43, %$15], [%54, %$22] ; # ->
; # drop
  %67 = inttoptr i64 %20 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %69, i64* %70
  br label %$9
$9:
  %71 = phi i64 [%15, %$7], [%65, %$14] ; # X
  %72 = phi i64 [%13, %$7], [%66, %$14] ; # ->
  ret i64 %72
}

define i64 @_sub(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (eval (++ X))) (if (nil? N) N (needNum Exe N)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (if (nil? N) N (needNum Exe N) (if (atom X) (neg N) (save -ZERO (...
; # (nil? N)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
  br label %$9
$8:
  %18 = phi i64 [%7, %$2] ; # X
; # (needNum Exe N)
  %19 = and i64 %15, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$11:
; # (if (atom X) (neg N) (save -ZERO (let R (link (push N NIL)) (loop...
; # (atom X)
  %21 = and i64 %18, 15
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$12, label %$13
$12:
  %23 = phi i64 [%18, %$11] ; # X
; # (neg N)
  %24 = icmp eq i64 %15, 2
  br i1 %24, label %$15, label %$16
$15:
  br label %$17
$16:
  %25 = xor i64 %15, 8
  br label %$17
$17:
  %26 = phi i64 [%15, %$15], [%25, %$16] ; # ->
  br label %$14
$13:
  %27 = phi i64 [%18, %$11] ; # X
; # (save -ZERO (let R (link (push N NIL)) (loop (? (nil? (eval (++ X...
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 10, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %29, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
; # (let R (link (push N NIL)) (loop (? (nil? (eval (++ X))) @) (safe...
; # (push N NIL)
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %15, i64* %38
; # (link (push N NIL))
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %43
; # (loop (? (nil? (eval (++ X))) @) (safe (needNum Exe @)) (set R (s...
  br label %$18
$18:
  %44 = phi i64 [%27, %$13], [%72, %$29] ; # X
; # (? (nil? (eval (++ X))) @)
; # (++ X)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
  %47 = getelementptr i64, i64* %45, i32 1
  %48 = load i64, i64* %47
; # (eval (++ X))
  %49 = and i64 %46, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$21, label %$20
$21:
  br label %$19
$20:
  %51 = and i64 %46, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$23, label %$22
$23:
  %53 = inttoptr i64 %46 to i64*
  %54 = load i64, i64* %53
  br label %$19
$22:
  %55 = call i64 @evList(i64 %46)
  br label %$19
$19:
  %56 = phi i64 [%46, %$21], [%54, %$23], [%55, %$22] ; # ->
; # (nil? (eval (++ X)))
  %57 = icmp eq i64 %56, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %57, label %$26, label %$24
$26:
  %58 = phi i64 [%48, %$19] ; # X
  br label %$25
$24:
  %59 = phi i64 [%48, %$19] ; # X
; # (needNum Exe @)
  %60 = and i64 %56, 6
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$28, label %$27
$27:
  call void @numErr(i64 %0, i64 %56)
  unreachable
$28:
; # (safe (needNum Exe @))
  %62 = inttoptr i64 %31 to i64*
  store i64 %56, i64* %62
; # (set R (subs (val R) @))
; # (val R)
  %63 = inttoptr i64 %37 to i64*
  %64 = load i64, i64* %63
; # (subs (val R) @)
  %65 = call i64 @subs(i64 %64, i64 %56)
  %66 = inttoptr i64 %37 to i64*
  store i64 %65, i64* %66
; # (? (atom X) (val R))
; # (atom X)
  %67 = and i64 %59, 15
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$30, label %$29
$30:
  %69 = phi i64 [%59, %$28] ; # X
; # (val R)
  %70 = inttoptr i64 %37 to i64*
  %71 = load i64, i64* %70
  br label %$25
$29:
  %72 = phi i64 [%59, %$28] ; # X
  br label %$18
$25:
  %73 = phi i64 [%58, %$26], [%69, %$30] ; # X
  %74 = phi i64 [%56, %$26], [%71, %$30] ; # ->
; # drop
  %75 = inttoptr i64 %31 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %78
  br label %$14
$14:
  %79 = phi i64 [%23, %$17], [%73, %$25] ; # X
  %80 = phi i64 [%26, %$17], [%74, %$25] ; # ->
  br label %$9
$9:
  %81 = phi i64 [%17, %$7], [%79, %$14] ; # X
  %82 = phi i64 [%15, %$7], [%80, %$14] ; # ->
  ret i64 %82
}

define i64 @_inc(i64) align 8 {
$1:
; # (let X (cdr Exe) (cond ((nil? (eval (car X))) @) ((num? @) (incs ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((nil? (eval (car X))) @) ((num? @) (incs @)) (T (let Y (sa...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%3, %$3] ; # X
  br label %$2
$8:
  %16 = phi i64 [%3, %$3] ; # X
; # (num? @)
  %17 = and i64 %13, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
  %19 = phi i64 [%16, %$8] ; # X
; # (incs @)
  %20 = call i64 @incs(i64 %13)
  br label %$2
$10:
  %21 = phi i64 [%16, %$8] ; # X
; # (let Y (save (chkVar Exe @)) (when (and (sym? Y) (sym? (val (tail...
; # (chkVar Exe @)
  %22 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %22, label %$13, label %$12
$13:
  %23 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %13
  br label %$12
$12:
  %24 = phi i1 [0, %$10], [%23, %$13] ; # ->
  br i1 %24, label %$14, label %$15
$14:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$15:
; # (save (chkVar Exe @))
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = alloca i64, i64 2, align 16
  %28 = ptrtoint i64* %27 to i64
  %29 = inttoptr i64 %28 to i64*
  store i64 %13, i64* %29
  %30 = add i64 %28, 8
  %31 = inttoptr i64 %30 to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %32
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %33 = and i64 %13, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$17, label %$16
$17:
  %35 = phi i64 [%21, %$15] ; # X
; # (tail Y)
  %36 = add i64 %13, -8
; # (val (tail Y))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (sym? (val (tail Y)))
  %39 = and i64 %38, 8
  %40 = icmp ne i64 %39, 0
  br label %$16
$16:
  %41 = phi i64 [%21, %$15], [%35, %$17] ; # X
  %42 = phi i1 [0, %$15], [%40, %$17] ; # ->
  br i1 %42, label %$18, label %$19
$18:
  %43 = phi i64 [%41, %$16] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$19
$19:
  %44 = phi i64 [%41, %$16], [%43, %$18] ; # X
; # (if (atom (shift X)) (if (nil? (val Y)) @ (set Y (incs (needNum E...
; # (shift X)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (atom (shift X))
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$20, label %$21
$20:
  %50 = phi i64 [%47, %$19] ; # X
; # (if (nil? (val Y)) @ (set Y (incs (needNum Exe @))))
; # (val Y)
  %51 = inttoptr i64 %13 to i64*
  %52 = load i64, i64* %51
; # (nil? (val Y))
  %53 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %53, label %$23, label %$24
$23:
  %54 = phi i64 [%50, %$20] ; # X
  br label %$25
$24:
  %55 = phi i64 [%50, %$20] ; # X
; # (set Y (incs (needNum Exe @)))
; # (needNum Exe @)
  %56 = and i64 %52, 6
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$27, label %$26
$26:
  call void @numErr(i64 %0, i64 %52)
  unreachable
$27:
; # (incs (needNum Exe @))
  %58 = call i64 @incs(i64 %52)
  %59 = inttoptr i64 %13 to i64*
  store i64 %58, i64* %59
  br label %$25
$25:
  %60 = phi i64 [%54, %$23], [%55, %$27] ; # X
  %61 = phi i64 [%52, %$23], [%58, %$27] ; # ->
  br label %$22
$21:
  %62 = phi i64 [%47, %$19] ; # X
; # (let (D (save (eval (car X))) N (val Y)) (cond ((nil? N) N) ((nil...
; # (car X)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$30, label %$29
$30:
  br label %$28
$29:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$32, label %$31
$32:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$28
$31:
  %71 = call i64 @evList(i64 %64)
  br label %$28
$28:
  %72 = phi i64 [%64, %$30], [%70, %$32], [%71, %$31] ; # ->
; # (save (eval (car X)))
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %74 = load i64, i64* %73
  %75 = alloca i64, i64 2, align 16
  %76 = ptrtoint i64* %75 to i64
  %77 = inttoptr i64 %76 to i64*
  store i64 %72, i64* %77
  %78 = add i64 %76, 8
  %79 = inttoptr i64 %78 to i64*
  store i64 %74, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %76, i64* %80
; # (val Y)
  %81 = inttoptr i64 %13 to i64*
  %82 = load i64, i64* %81
; # (cond ((nil? N) N) ((nil? D) D) (T (set Y (adds (needNum Exe N) (...
; # (nil? N)
  %83 = icmp eq i64 %82, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %83, label %$35, label %$34
$35:
  %84 = phi i64 [%62, %$28] ; # X
  br label %$33
$34:
  %85 = phi i64 [%62, %$28] ; # X
; # (nil? D)
  %86 = icmp eq i64 %72, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %86, label %$37, label %$36
$37:
  %87 = phi i64 [%85, %$34] ; # X
  br label %$33
$36:
  %88 = phi i64 [%85, %$34] ; # X
; # (set Y (adds (needNum Exe N) (needNum Exe D)))
; # (needNum Exe N)
  %89 = and i64 %82, 6
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$39, label %$38
$38:
  call void @numErr(i64 %0, i64 %82)
  unreachable
$39:
; # (needNum Exe D)
  %91 = and i64 %72, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$41, label %$40
$40:
  call void @numErr(i64 %0, i64 %72)
  unreachable
$41:
; # (adds (needNum Exe N) (needNum Exe D))
  %93 = call i64 @adds(i64 %82, i64 %72)
  %94 = inttoptr i64 %13 to i64*
  store i64 %93, i64* %94
  br label %$33
$33:
  %95 = phi i64 [%84, %$35], [%87, %$37], [%88, %$41] ; # X
  %96 = phi i64 [%82, %$35], [%72, %$37], [%93, %$41] ; # ->
  br label %$22
$22:
  %97 = phi i64 [%60, %$25], [%95, %$33] ; # X
  %98 = phi i64 [%61, %$25], [%96, %$33] ; # ->
; # (drop *Safe)
  %99 = inttoptr i64 %28 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %101, i64* %102
  br label %$2
$2:
  %103 = phi i64 [%15, %$9], [%19, %$11], [%97, %$22] ; # X
  %104 = phi i64 [%13, %$9], [%20, %$11], [%98, %$22] ; # ->
  ret i64 %104
}

define i64 @_dec(i64) align 8 {
$1:
; # (let X (cdr Exe) (cond ((nil? (eval (car X))) @) ((num? @) (decs ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((nil? (eval (car X))) @) ((num? @) (decs @)) (T (let Y (sa...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%3, %$3] ; # X
  br label %$2
$8:
  %16 = phi i64 [%3, %$3] ; # X
; # (num? @)
  %17 = and i64 %13, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
  %19 = phi i64 [%16, %$8] ; # X
; # (decs @)
  %20 = call i64 @decs(i64 %13)
  br label %$2
$10:
  %21 = phi i64 [%16, %$8] ; # X
; # (let Y (save (chkVar Exe @)) (when (and (sym? Y) (sym? (val (tail...
; # (chkVar Exe @)
  %22 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %22, label %$13, label %$12
$13:
  %23 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %13
  br label %$12
$12:
  %24 = phi i1 [0, %$10], [%23, %$13] ; # ->
  br i1 %24, label %$14, label %$15
$14:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$15:
; # (save (chkVar Exe @))
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = alloca i64, i64 2, align 16
  %28 = ptrtoint i64* %27 to i64
  %29 = inttoptr i64 %28 to i64*
  store i64 %13, i64* %29
  %30 = add i64 %28, 8
  %31 = inttoptr i64 %30 to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %32
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %33 = and i64 %13, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$17, label %$16
$17:
  %35 = phi i64 [%21, %$15] ; # X
; # (tail Y)
  %36 = add i64 %13, -8
; # (val (tail Y))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (sym? (val (tail Y)))
  %39 = and i64 %38, 8
  %40 = icmp ne i64 %39, 0
  br label %$16
$16:
  %41 = phi i64 [%21, %$15], [%35, %$17] ; # X
  %42 = phi i1 [0, %$15], [%40, %$17] ; # ->
  br i1 %42, label %$18, label %$19
$18:
  %43 = phi i64 [%41, %$16] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$19
$19:
  %44 = phi i64 [%41, %$16], [%43, %$18] ; # X
; # (if (atom (shift X)) (if (nil? (val Y)) @ (set Y (decs (needNum E...
; # (shift X)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (atom (shift X))
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$20, label %$21
$20:
  %50 = phi i64 [%47, %$19] ; # X
; # (if (nil? (val Y)) @ (set Y (decs (needNum Exe @))))
; # (val Y)
  %51 = inttoptr i64 %13 to i64*
  %52 = load i64, i64* %51
; # (nil? (val Y))
  %53 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %53, label %$23, label %$24
$23:
  %54 = phi i64 [%50, %$20] ; # X
  br label %$25
$24:
  %55 = phi i64 [%50, %$20] ; # X
; # (set Y (decs (needNum Exe @)))
; # (needNum Exe @)
  %56 = and i64 %52, 6
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$27, label %$26
$26:
  call void @numErr(i64 %0, i64 %52)
  unreachable
$27:
; # (decs (needNum Exe @))
  %58 = call i64 @decs(i64 %52)
  %59 = inttoptr i64 %13 to i64*
  store i64 %58, i64* %59
  br label %$25
$25:
  %60 = phi i64 [%54, %$23], [%55, %$27] ; # X
  %61 = phi i64 [%52, %$23], [%58, %$27] ; # ->
  br label %$22
$21:
  %62 = phi i64 [%47, %$19] ; # X
; # (let (D (save (eval (car X))) N (val Y)) (cond ((nil? N) N) ((nil...
; # (car X)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$30, label %$29
$30:
  br label %$28
$29:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$32, label %$31
$32:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$28
$31:
  %71 = call i64 @evList(i64 %64)
  br label %$28
$28:
  %72 = phi i64 [%64, %$30], [%70, %$32], [%71, %$31] ; # ->
; # (save (eval (car X)))
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %74 = load i64, i64* %73
  %75 = alloca i64, i64 2, align 16
  %76 = ptrtoint i64* %75 to i64
  %77 = inttoptr i64 %76 to i64*
  store i64 %72, i64* %77
  %78 = add i64 %76, 8
  %79 = inttoptr i64 %78 to i64*
  store i64 %74, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %76, i64* %80
; # (val Y)
  %81 = inttoptr i64 %13 to i64*
  %82 = load i64, i64* %81
; # (cond ((nil? N) N) ((nil? D) D) (T (set Y (subs (needNum Exe N) (...
; # (nil? N)
  %83 = icmp eq i64 %82, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %83, label %$35, label %$34
$35:
  %84 = phi i64 [%62, %$28] ; # X
  br label %$33
$34:
  %85 = phi i64 [%62, %$28] ; # X
; # (nil? D)
  %86 = icmp eq i64 %72, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %86, label %$37, label %$36
$37:
  %87 = phi i64 [%85, %$34] ; # X
  br label %$33
$36:
  %88 = phi i64 [%85, %$34] ; # X
; # (set Y (subs (needNum Exe N) (needNum Exe D)))
; # (needNum Exe N)
  %89 = and i64 %82, 6
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$39, label %$38
$38:
  call void @numErr(i64 %0, i64 %82)
  unreachable
$39:
; # (needNum Exe D)
  %91 = and i64 %72, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$41, label %$40
$40:
  call void @numErr(i64 %0, i64 %72)
  unreachable
$41:
; # (subs (needNum Exe N) (needNum Exe D))
  %93 = call i64 @subs(i64 %82, i64 %72)
  %94 = inttoptr i64 %13 to i64*
  store i64 %93, i64* %94
  br label %$33
$33:
  %95 = phi i64 [%84, %$35], [%87, %$37], [%88, %$41] ; # X
  %96 = phi i64 [%82, %$35], [%72, %$37], [%93, %$41] ; # ->
  br label %$22
$22:
  %97 = phi i64 [%60, %$25], [%95, %$33] ; # X
  %98 = phi i64 [%61, %$25], [%96, %$33] ; # ->
; # (drop *Safe)
  %99 = inttoptr i64 %28 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %101, i64* %102
  br label %$2
$2:
  %103 = phi i64 [%15, %$9], [%19, %$11], [%97, %$22] ; # X
  %104 = phi i64 [%13, %$9], [%20, %$11], [%98, %$22] ; # ->
  ret i64 %104
}

define i64 @_mul(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (loop (? (atom (shift X)) (let N (val R) (if Sign (neg N) N))) (l...
  br label %$12
$12:
  %38 = phi i64 [%16, %$11], [%94, %$34] ; # X
  %39 = phi i1 [%28, %$11], [%95, %$34] ; # Sign
; # (? (atom (shift X)) (let N (val R) (if Sign (neg N) N)))
; # (shift X)
  %40 = inttoptr i64 %38 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
; # (atom (shift X))
  %43 = and i64 %42, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$13
$15:
  %45 = phi i64 [%42, %$12] ; # X
  %46 = phi i1 [%39, %$12] ; # Sign
; # (let N (val R) (if Sign (neg N) N))
; # (val R)
  %47 = inttoptr i64 %31 to i64*
  %48 = load i64, i64* %47
; # (if Sign (neg N) N)
  br i1 %46, label %$16, label %$17
$16:
  %49 = phi i64 [%45, %$15] ; # X
  %50 = phi i1 [%46, %$15] ; # Sign
; # (neg N)
  %51 = icmp eq i64 %48, 2
  br i1 %51, label %$19, label %$20
$19:
  br label %$21
$20:
  %52 = xor i64 %48, 8
  br label %$21
$21:
  %53 = phi i64 [%48, %$19], [%52, %$20] ; # ->
  br label %$18
$17:
  %54 = phi i64 [%45, %$15] ; # X
  %55 = phi i1 [%46, %$15] ; # Sign
  br label %$18
$18:
  %56 = phi i64 [%49, %$21], [%54, %$17] ; # X
  %57 = phi i1 [%50, %$21], [%55, %$17] ; # Sign
  %58 = phi i64 [%53, %$21], [%48, %$17] ; # ->
  br label %$14
$13:
  %59 = phi i64 [%42, %$12] ; # X
  %60 = phi i1 [%39, %$12] ; # Sign
; # (let N (eval (car X)) (? (nil? N) N) (? (== N ZERO) N) (when (sig...
; # (car X)
  %61 = inttoptr i64 %59 to i64*
  %62 = load i64, i64* %61
; # (eval (car X))
  %63 = and i64 %62, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$24, label %$23
$24:
  br label %$22
$23:
  %65 = and i64 %62, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$26, label %$25
$26:
  %67 = inttoptr i64 %62 to i64*
  %68 = load i64, i64* %67
  br label %$22
$25:
  %69 = call i64 @evList(i64 %62)
  br label %$22
$22:
  %70 = phi i64 [%62, %$24], [%68, %$26], [%69, %$25] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %71, label %$28, label %$27
$28:
  %72 = phi i64 [%59, %$22] ; # X
  %73 = phi i1 [%60, %$22] ; # Sign
  %74 = phi i64 [%70, %$22] ; # N
  br label %$14
$27:
  %75 = phi i64 [%59, %$22] ; # X
  %76 = phi i1 [%60, %$22] ; # Sign
  %77 = phi i64 [%70, %$22] ; # N
; # (? (== N ZERO) N)
; # (== N ZERO)
  %78 = icmp eq i64 %77, 2
  br i1 %78, label %$30, label %$29
$30:
  %79 = phi i64 [%75, %$27] ; # X
  %80 = phi i1 [%76, %$27] ; # Sign
  %81 = phi i64 [%77, %$27] ; # N
  br label %$14
$29:
  %82 = phi i64 [%75, %$27] ; # X
  %83 = phi i1 [%76, %$27] ; # Sign
  %84 = phi i64 [%77, %$27] ; # N
; # (when (sign? (needNum Exe N)) (setq Sign (not Sign) N (pos N)))
; # (needNum Exe N)
  %85 = and i64 %84, 6
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$32, label %$31
$31:
  call void @numErr(i64 %0, i64 %84)
  unreachable
$32:
; # (sign? (needNum Exe N))
  %87 = and i64 %84, 8
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$33, label %$34
$33:
  %89 = phi i64 [%82, %$32] ; # X
  %90 = phi i1 [%83, %$32] ; # Sign
  %91 = phi i64 [%84, %$32] ; # N
; # (not Sign)
  %92 = icmp eq i1 %90, 0
; # (pos N)
  %93 = and i64 %91, -9
  br label %$34
$34:
  %94 = phi i64 [%82, %$32], [%89, %$33] ; # X
  %95 = phi i1 [%83, %$32], [%92, %$33] ; # Sign
  %96 = phi i64 [%84, %$32], [%93, %$33] ; # N
; # (safe N)
  %97 = inttoptr i64 %20 to i64*
  store i64 %96, i64* %97
; # (set R (mulu (val R) N))
; # (val R)
  %98 = inttoptr i64 %31 to i64*
  %99 = load i64, i64* %98
; # (mulu (val R) N)
  %100 = call i64 @mulu(i64 %99, i64 %96)
  %101 = inttoptr i64 %31 to i64*
  store i64 %100, i64* %101
  br label %$12
$14:
  %102 = phi i64 [%56, %$18], [%72, %$28], [%79, %$30] ; # X
  %103 = phi i1 [%57, %$18], [%73, %$28], [%80, %$30] ; # Sign
  %104 = phi i64 [%58, %$18], [%74, %$28], [%81, %$30] ; # ->
; # drop
  %105 = inttoptr i64 %20 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %108
  br label %$9
$9:
  %109 = phi i64 [%15, %$7], [%102, %$14] ; # X
  %110 = phi i64 [%13, %$7], [%104, %$14] ; # ->
  ret i64 %110
}

define i64 @_mulDiv(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (shift X)
  %38 = inttoptr i64 %16 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (loop (let N (eval (car X)) (? (nil? N) N) (when (sign? (needNum ...
  br label %$12
$12:
  %41 = phi i64 [%40, %$11], [%122, %$35] ; # X
  %42 = phi i1 [%28, %$11], [%123, %$35] ; # Sign
; # (let N (eval (car X)) (? (nil? N) N) (when (sign? (needNum Exe N)...
; # (car X)
  %43 = inttoptr i64 %41 to i64*
  %44 = load i64, i64* %43
; # (eval (car X))
  %45 = and i64 %44, 6
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$15, label %$14
$15:
  br label %$13
$14:
  %47 = and i64 %44, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$17, label %$16
$17:
  %49 = inttoptr i64 %44 to i64*
  %50 = load i64, i64* %49
  br label %$13
$16:
  %51 = call i64 @evList(i64 %44)
  br label %$13
$13:
  %52 = phi i64 [%44, %$15], [%50, %$17], [%51, %$16] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %53 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %53, label %$20, label %$18
$20:
  %54 = phi i64 [%41, %$13] ; # X
  %55 = phi i1 [%42, %$13] ; # Sign
  %56 = phi i64 [%52, %$13] ; # N
  br label %$19
$18:
  %57 = phi i64 [%41, %$13] ; # X
  %58 = phi i1 [%42, %$13] ; # Sign
  %59 = phi i64 [%52, %$13] ; # N
; # (when (sign? (needNum Exe N)) (setq Sign (not Sign) N (pos N)))
; # (needNum Exe N)
  %60 = and i64 %59, 6
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$22, label %$21
$21:
  call void @numErr(i64 %0, i64 %59)
  unreachable
$22:
; # (sign? (needNum Exe N))
  %62 = and i64 %59, 8
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$23, label %$24
$23:
  %64 = phi i64 [%57, %$22] ; # X
  %65 = phi i1 [%58, %$22] ; # Sign
  %66 = phi i64 [%59, %$22] ; # N
; # (not Sign)
  %67 = icmp eq i1 %65, 0
; # (pos N)
  %68 = and i64 %66, -9
  br label %$24
$24:
  %69 = phi i64 [%57, %$22], [%64, %$23] ; # X
  %70 = phi i1 [%58, %$22], [%67, %$23] ; # Sign
  %71 = phi i64 [%59, %$22], [%68, %$23] ; # N
; # (safe N)
  %72 = inttoptr i64 %20 to i64*
  store i64 %71, i64* %72
; # (? (atom (shift X)) (when (== N ZERO) (divErr Exe)) (let Half (sa...
; # (shift X)
  %73 = inttoptr i64 %69 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
; # (atom (shift X))
  %76 = and i64 %75, 15
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$26, label %$25
$26:
  %78 = phi i64 [%75, %$24] ; # X
  %79 = phi i1 [%70, %$24] ; # Sign
  %80 = phi i64 [%71, %$24] ; # N
; # (when (== N ZERO) (divErr Exe))
; # (== N ZERO)
  %81 = icmp eq i64 %80, 2
  br i1 %81, label %$27, label %$28
$27:
  %82 = phi i64 [%78, %$26] ; # X
  %83 = phi i1 [%79, %$26] ; # Sign
  %84 = phi i64 [%80, %$26] ; # N
; # (divErr Exe)
  call void @divErr(i64 %0)
  unreachable
$28:
  %85 = phi i64 [%78, %$26] ; # X
  %86 = phi i1 [%79, %$26] ; # Sign
  %87 = phi i64 [%80, %$26] ; # N
; # (let Half (save (shru N)) (setq N (divu (set R (addu (val R) Half...
; # (shru N)
  %88 = call i64 @shru(i64 %87)
; # (save (shru N))
  %89 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %90 = load i64, i64* %89
  %91 = alloca i64, i64 2, align 16
  %92 = ptrtoint i64* %91 to i64
  %93 = inttoptr i64 %92 to i64*
  store i64 %88, i64* %93
  %94 = add i64 %92, 8
  %95 = inttoptr i64 %94 to i64*
  store i64 %90, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %92, i64* %96
; # (set R (addu (val R) Half))
; # (val R)
  %97 = inttoptr i64 %31 to i64*
  %98 = load i64, i64* %97
; # (addu (val R) Half)
  %99 = call i64 @addu(i64 %98, i64 %88)
  %100 = inttoptr i64 %31 to i64*
  store i64 %99, i64* %100
; # (divu (set R (addu (val R) Half)) N)
  %101 = call i64 @divu(i64 %99, i64 %87)
; # (if Sign (neg N) N)
  br i1 %86, label %$29, label %$30
$29:
  %102 = phi i64 [%85, %$28] ; # X
  %103 = phi i1 [%86, %$28] ; # Sign
  %104 = phi i64 [%101, %$28] ; # N
; # (neg N)
  %105 = icmp eq i64 %104, 2
  br i1 %105, label %$32, label %$33
$32:
  br label %$34
$33:
  %106 = xor i64 %104, 8
  br label %$34
$34:
  %107 = phi i64 [%104, %$32], [%106, %$33] ; # ->
  br label %$31
$30:
  %108 = phi i64 [%85, %$28] ; # X
  %109 = phi i1 [%86, %$28] ; # Sign
  %110 = phi i64 [%101, %$28] ; # N
  br label %$31
$31:
  %111 = phi i64 [%102, %$34], [%108, %$30] ; # X
  %112 = phi i1 [%103, %$34], [%109, %$30] ; # Sign
  %113 = phi i64 [%104, %$34], [%110, %$30] ; # N
  %114 = phi i64 [%107, %$34], [%110, %$30] ; # ->
  br label %$19
$25:
  %115 = phi i64 [%75, %$24] ; # X
  %116 = phi i1 [%70, %$24] ; # Sign
  %117 = phi i64 [%71, %$24] ; # N
; # (? (== N ZERO) N)
; # (== N ZERO)
  %118 = icmp eq i64 %117, 2
  br i1 %118, label %$36, label %$35
$36:
  %119 = phi i64 [%115, %$25] ; # X
  %120 = phi i1 [%116, %$25] ; # Sign
  %121 = phi i64 [%117, %$25] ; # N
  br label %$19
$35:
  %122 = phi i64 [%115, %$25] ; # X
  %123 = phi i1 [%116, %$25] ; # Sign
  %124 = phi i64 [%117, %$25] ; # N
; # (set R (mulu (val R) N))
; # (val R)
  %125 = inttoptr i64 %31 to i64*
  %126 = load i64, i64* %125
; # (mulu (val R) N)
  %127 = call i64 @mulu(i64 %126, i64 %124)
  %128 = inttoptr i64 %31 to i64*
  store i64 %127, i64* %128
  br label %$12
$19:
  %129 = phi i64 [%54, %$20], [%111, %$31], [%119, %$36] ; # X
  %130 = phi i1 [%55, %$20], [%112, %$31], [%120, %$36] ; # Sign
  %131 = phi i64 [%56, %$20], [%114, %$31], [%121, %$36] ; # ->
; # drop
  %132 = inttoptr i64 %20 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
  %135 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %134, i64* %135
  br label %$9
$9:
  %136 = phi i64 [%15, %$7], [%129, %$19] ; # X
  %137 = phi i64 [%13, %$7], [%131, %$19] ; # ->
  ret i64 %137
}

define i64 @_div(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (loop (? (atom (shift X)) (let N (val R) (if Sign (neg N) N))) (l...
  br label %$12
$12:
  %38 = phi i64 [%16, %$11], [%94, %$34] ; # X
  %39 = phi i1 [%28, %$11], [%95, %$34] ; # Sign
; # (? (atom (shift X)) (let N (val R) (if Sign (neg N) N)))
; # (shift X)
  %40 = inttoptr i64 %38 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
; # (atom (shift X))
  %43 = and i64 %42, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$13
$15:
  %45 = phi i64 [%42, %$12] ; # X
  %46 = phi i1 [%39, %$12] ; # Sign
; # (let N (val R) (if Sign (neg N) N))
; # (val R)
  %47 = inttoptr i64 %31 to i64*
  %48 = load i64, i64* %47
; # (if Sign (neg N) N)
  br i1 %46, label %$16, label %$17
$16:
  %49 = phi i64 [%45, %$15] ; # X
  %50 = phi i1 [%46, %$15] ; # Sign
; # (neg N)
  %51 = icmp eq i64 %48, 2
  br i1 %51, label %$19, label %$20
$19:
  br label %$21
$20:
  %52 = xor i64 %48, 8
  br label %$21
$21:
  %53 = phi i64 [%48, %$19], [%52, %$20] ; # ->
  br label %$18
$17:
  %54 = phi i64 [%45, %$15] ; # X
  %55 = phi i1 [%46, %$15] ; # Sign
  br label %$18
$18:
  %56 = phi i64 [%49, %$21], [%54, %$17] ; # X
  %57 = phi i1 [%50, %$21], [%55, %$17] ; # Sign
  %58 = phi i64 [%53, %$21], [%48, %$17] ; # ->
  br label %$14
$13:
  %59 = phi i64 [%42, %$12] ; # X
  %60 = phi i1 [%39, %$12] ; # Sign
; # (let N (eval (car X)) (? (nil? N) N) (when (== N ZERO) (divErr Ex...
; # (car X)
  %61 = inttoptr i64 %59 to i64*
  %62 = load i64, i64* %61
; # (eval (car X))
  %63 = and i64 %62, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$24, label %$23
$24:
  br label %$22
$23:
  %65 = and i64 %62, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$26, label %$25
$26:
  %67 = inttoptr i64 %62 to i64*
  %68 = load i64, i64* %67
  br label %$22
$25:
  %69 = call i64 @evList(i64 %62)
  br label %$22
$22:
  %70 = phi i64 [%62, %$24], [%68, %$26], [%69, %$25] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %71, label %$28, label %$27
$28:
  %72 = phi i64 [%59, %$22] ; # X
  %73 = phi i1 [%60, %$22] ; # Sign
  %74 = phi i64 [%70, %$22] ; # N
  br label %$14
$27:
  %75 = phi i64 [%59, %$22] ; # X
  %76 = phi i1 [%60, %$22] ; # Sign
  %77 = phi i64 [%70, %$22] ; # N
; # (when (== N ZERO) (divErr Exe))
; # (== N ZERO)
  %78 = icmp eq i64 %77, 2
  br i1 %78, label %$29, label %$30
$29:
  %79 = phi i64 [%75, %$27] ; # X
  %80 = phi i1 [%76, %$27] ; # Sign
  %81 = phi i64 [%77, %$27] ; # N
; # (divErr Exe)
  call void @divErr(i64 %0)
  unreachable
$30:
  %82 = phi i64 [%75, %$27] ; # X
  %83 = phi i1 [%76, %$27] ; # Sign
  %84 = phi i64 [%77, %$27] ; # N
; # (when (sign? (needNum Exe N)) (setq Sign (not Sign) N (pos N)))
; # (needNum Exe N)
  %85 = and i64 %84, 6
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$32, label %$31
$31:
  call void @numErr(i64 %0, i64 %84)
  unreachable
$32:
; # (sign? (needNum Exe N))
  %87 = and i64 %84, 8
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$33, label %$34
$33:
  %89 = phi i64 [%82, %$32] ; # X
  %90 = phi i1 [%83, %$32] ; # Sign
  %91 = phi i64 [%84, %$32] ; # N
; # (not Sign)
  %92 = icmp eq i1 %90, 0
; # (pos N)
  %93 = and i64 %91, -9
  br label %$34
$34:
  %94 = phi i64 [%82, %$32], [%89, %$33] ; # X
  %95 = phi i1 [%83, %$32], [%92, %$33] ; # Sign
  %96 = phi i64 [%84, %$32], [%93, %$33] ; # N
; # (safe N)
  %97 = inttoptr i64 %20 to i64*
  store i64 %96, i64* %97
; # (set R (divu (val R) N))
; # (val R)
  %98 = inttoptr i64 %31 to i64*
  %99 = load i64, i64* %98
; # (divu (val R) N)
  %100 = call i64 @divu(i64 %99, i64 %96)
  %101 = inttoptr i64 %31 to i64*
  store i64 %100, i64* %101
  br label %$12
$14:
  %102 = phi i64 [%56, %$18], [%72, %$28] ; # X
  %103 = phi i1 [%57, %$18], [%73, %$28] ; # Sign
  %104 = phi i64 [%58, %$18], [%74, %$28] ; # ->
; # drop
  %105 = inttoptr i64 %20 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %108
  br label %$9
$9:
  %109 = phi i64 [%15, %$7], [%102, %$14] ; # X
  %110 = phi i64 [%13, %$7], [%104, %$14] ; # ->
  ret i64 %110
}

define i64 @_rem(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (loop (? (atom (shift X)) (let N (val R) (if Sign (neg N) N))) (l...
  br label %$12
$12:
  %38 = phi i64 [%16, %$11], [%70, %$32] ; # X
; # (? (atom (shift X)) (let N (val R) (if Sign (neg N) N)))
; # (shift X)
  %39 = inttoptr i64 %38 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  %41 = load i64, i64* %40
; # (atom (shift X))
  %42 = and i64 %41, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$15, label %$13
$15:
  %44 = phi i64 [%41, %$12] ; # X
; # (let N (val R) (if Sign (neg N) N))
; # (val R)
  %45 = inttoptr i64 %31 to i64*
  %46 = load i64, i64* %45
; # (if Sign (neg N) N)
  br i1 %28, label %$16, label %$17
$16:
  %47 = phi i64 [%44, %$15] ; # X
; # (neg N)
  %48 = icmp eq i64 %46, 2
  br i1 %48, label %$19, label %$20
$19:
  br label %$21
$20:
  %49 = xor i64 %46, 8
  br label %$21
$21:
  %50 = phi i64 [%46, %$19], [%49, %$20] ; # ->
  br label %$18
$17:
  %51 = phi i64 [%44, %$15] ; # X
  br label %$18
$18:
  %52 = phi i64 [%47, %$21], [%51, %$17] ; # X
  %53 = phi i64 [%50, %$21], [%46, %$17] ; # ->
  br label %$14
$13:
  %54 = phi i64 [%41, %$12] ; # X
; # (let N (eval (car X)) (? (nil? N) N) (when (== N ZERO) (divErr Ex...
; # (car X)
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (eval (car X))
  %57 = and i64 %56, 6
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$24, label %$23
$24:
  br label %$22
$23:
  %59 = and i64 %56, 8
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$26, label %$25
$26:
  %61 = inttoptr i64 %56 to i64*
  %62 = load i64, i64* %61
  br label %$22
$25:
  %63 = call i64 @evList(i64 %56)
  br label %$22
$22:
  %64 = phi i64 [%56, %$24], [%62, %$26], [%63, %$25] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %65 = icmp eq i64 %64, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %65, label %$28, label %$27
$28:
  %66 = phi i64 [%54, %$22] ; # X
  br label %$14
$27:
  %67 = phi i64 [%54, %$22] ; # X
; # (when (== N ZERO) (divErr Exe))
; # (== N ZERO)
  %68 = icmp eq i64 %64, 2
  br i1 %68, label %$29, label %$30
$29:
  %69 = phi i64 [%67, %$27] ; # X
; # (divErr Exe)
  call void @divErr(i64 %0)
  unreachable
$30:
  %70 = phi i64 [%67, %$27] ; # X
; # (set R (remu (val R) (safe (pos (needNum Exe N)))))
; # (val R)
  %71 = inttoptr i64 %31 to i64*
  %72 = load i64, i64* %71
; # (needNum Exe N)
  %73 = and i64 %64, 6
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$32, label %$31
$31:
  call void @numErr(i64 %0, i64 %64)
  unreachable
$32:
; # (pos (needNum Exe N))
  %75 = and i64 %64, -9
; # (safe (pos (needNum Exe N)))
  %76 = inttoptr i64 %20 to i64*
  store i64 %75, i64* %76
; # (remu (val R) (safe (pos (needNum Exe N))))
  %77 = call i64 @remu(i64 %72, i64 %75)
  %78 = inttoptr i64 %31 to i64*
  store i64 %77, i64* %78
  br label %$12
$14:
  %79 = phi i64 [%52, %$18], [%66, %$28] ; # X
  %80 = phi i64 [%53, %$18], [%64, %$28] ; # ->
; # drop
  %81 = inttoptr i64 %20 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  br label %$9
$9:
  %85 = phi i64 [%15, %$7], [%79, %$14] ; # X
  %86 = phi i64 [%13, %$7], [%80, %$14] ; # ->
  ret i64 %86
}

define i64 @_shr(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) Y (eval (cadr X))) (if (or (=0 ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (cadr X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (cadr X))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (if (or (=0 N) (nil? Y) (== ZERO (needNum Exe Y))) Y (let Sign (s...
; # (or (=0 N) (nil? Y) (== ZERO (needNum Exe Y)))
; # (=0 N)
  %18 = icmp eq i64 %4, 0
  br i1 %18, label %$7, label %$8
$8:
  %19 = phi i64 [%4, %$2] ; # N
  %20 = phi i64 [%17, %$2] ; # Y
; # (nil? Y)
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$7, label %$9
$9:
  %22 = phi i64 [%19, %$8] ; # N
  %23 = phi i64 [%20, %$8] ; # Y
; # (needNum Exe Y)
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %23)
  unreachable
$11:
; # (== ZERO (needNum Exe Y))
  %26 = icmp eq i64 2, %23
  br label %$7
$7:
  %27 = phi i64 [%4, %$2], [%19, %$8], [%22, %$11] ; # N
  %28 = phi i64 [%17, %$2], [%20, %$8], [%23, %$11] ; # Y
  %29 = phi i1 [1, %$2], [1, %$8], [%26, %$11] ; # ->
  br i1 %29, label %$12, label %$13
$12:
  %30 = phi i64 [%27, %$7] ; # N
  %31 = phi i64 [%28, %$7] ; # Y
  br label %$14
$13:
  %32 = phi i64 [%27, %$7] ; # N
  %33 = phi i64 [%28, %$7] ; # Y
; # (let Sign (sign? Y) (setq Y (save (pos Y))) (cond ((gt0 N) (while...
; # (sign? Y)
  %34 = and i64 %33, 8
  %35 = icmp ne i64 %34, 0
; # (pos Y)
  %36 = and i64 %33, -9
; # (save (pos Y))
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %38 = load i64, i64* %37
  %39 = alloca i64, i64 2, align 16
  %40 = ptrtoint i64* %39 to i64
  %41 = inttoptr i64 %40 to i64*
  store i64 %36, i64* %41
  %42 = add i64 %40, 8
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %44
; # (cond ((gt0 N) (while (and (big? Y) (>= N 64)) (setq Y (val (big ...
; # (gt0 N)
  %45 = icmp sgt i64 %32, 0
  br i1 %45, label %$17, label %$16
$17:
  %46 = phi i64 [%32, %$13] ; # N
  %47 = phi i64 [%36, %$13] ; # Y
; # (while (and (big? Y) (>= N 64)) (setq Y (val (big Y))) (unless (d...
  br label %$18
$18:
  %48 = phi i64 [%46, %$17], [%67, %$24] ; # N
  %49 = phi i64 [%47, %$17], [%68, %$24] ; # Y
; # (and (big? Y) (>= N 64))
; # (big? Y)
  %50 = and i64 %49, 4
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = phi i64 [%48, %$18] ; # N
  %53 = phi i64 [%49, %$18] ; # Y
; # (>= N 64)
  %54 = icmp uge i64 %52, 64
  br label %$19
$19:
  %55 = phi i64 [%48, %$18], [%52, %$20] ; # N
  %56 = phi i64 [%49, %$18], [%53, %$20] ; # Y
  %57 = phi i1 [0, %$18], [%54, %$20] ; # ->
  br i1 %57, label %$21, label %$22
$21:
  %58 = phi i64 [%55, %$19] ; # N
  %59 = phi i64 [%56, %$19] ; # Y
; # (big Y)
  %60 = add i64 %59, 4
; # (val (big Y))
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (unless (dec 'N 64) (goto 9))
; # (dec 'N 64)
  %63 = sub i64 %58, 64
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$24, label %$23
$23:
  %65 = phi i64 [%63, %$21] ; # N
  %66 = phi i64 [%62, %$21] ; # Y
; # (goto 9)
  br label %$-9
$24:
  %67 = phi i64 [%63, %$21] ; # N
  %68 = phi i64 [%62, %$21] ; # Y
  br label %$18
$22:
  %69 = phi i64 [%55, %$19] ; # N
  %70 = phi i64 [%56, %$19] ; # Y
; # (shru Y)
  %71 = call i64 @shru(i64 %70)
; # (safe (shru Y))
  %72 = inttoptr i64 %40 to i64*
  store i64 %71, i64* %72
; # (while (dec 'N) (setq Y (half Y)))
  br label %$25
$25:
  %73 = phi i64 [%69, %$22], [%77, %$26] ; # N
  %74 = phi i64 [%71, %$22], [%79, %$26] ; # Y
; # (dec 'N)
  %75 = sub i64 %73, 1
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$26, label %$27
$26:
  %77 = phi i64 [%75, %$25] ; # N
  %78 = phi i64 [%74, %$25] ; # Y
; # (half Y)
  %79 = call i64 @half(i64 %78)
  br label %$25
$27:
  %80 = phi i64 [%75, %$25] ; # N
  %81 = phi i64 [%74, %$25] ; # Y
  br label %$15
$16:
  %82 = phi i64 [%32, %$13] ; # N
  %83 = phi i64 [%36, %$13] ; # Y
; # (while (>= -64 N) (setq Y (safe (consNum 0 Y))) (unless (inc 'N 6...
  br label %$28
$28:
  %84 = phi i64 [%82, %$16], [%95, %$32] ; # N
  %85 = phi i64 [%83, %$16], [%96, %$32] ; # Y
; # (>= -64 N)
  %86 = icmp uge i64 -64, %84
  br i1 %86, label %$29, label %$30
$29:
  %87 = phi i64 [%84, %$28] ; # N
  %88 = phi i64 [%85, %$28] ; # Y
; # (consNum 0 Y)
  %89 = call i64 @consNum(i64 0, i64 %88)
; # (safe (consNum 0 Y))
  %90 = inttoptr i64 %40 to i64*
  store i64 %89, i64* %90
; # (unless (inc 'N 64) (goto 9))
; # (inc 'N 64)
  %91 = add i64 %87, 64
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$32, label %$31
$31:
  %93 = phi i64 [%91, %$29] ; # N
  %94 = phi i64 [%89, %$29] ; # Y
; # (goto 9)
  br label %$-9
$32:
  %95 = phi i64 [%91, %$29] ; # N
  %96 = phi i64 [%89, %$29] ; # Y
  br label %$28
$30:
  %97 = phi i64 [%84, %$28] ; # N
  %98 = phi i64 [%85, %$28] ; # Y
; # (shlu Y)
  %99 = call i64 @shlu(i64 %98)
; # (safe (shlu Y))
  %100 = inttoptr i64 %40 to i64*
  store i64 %99, i64* %100
; # (while (inc 'N) (setq Y (safe (twice Y))))
  br label %$33
$33:
  %101 = phi i64 [%97, %$30], [%105, %$34] ; # N
  %102 = phi i64 [%99, %$30], [%107, %$34] ; # Y
; # (inc 'N)
  %103 = add i64 %101, 1
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$34, label %$35
$34:
  %105 = phi i64 [%103, %$33] ; # N
  %106 = phi i64 [%102, %$33] ; # Y
; # (twice Y)
  %107 = call i64 @twice(i64 %106)
; # (safe (twice Y))
  %108 = inttoptr i64 %40 to i64*
  store i64 %107, i64* %108
  br label %$33
$35:
  %109 = phi i64 [%103, %$33] ; # N
  %110 = phi i64 [%102, %$33] ; # Y
  br label %$15
$15:
  %111 = phi i64 [%80, %$27], [%109, %$35] ; # N
  %112 = phi i64 [%81, %$27], [%110, %$35] ; # Y
; # (: 9 (if Sign (neg Y) Y))
  br label %$-9
$-9:
  %113 = phi i64 [%65, %$23], [%93, %$31], [%111, %$15] ; # N
  %114 = phi i64 [%66, %$23], [%94, %$31], [%112, %$15] ; # Y
; # (if Sign (neg Y) Y)
  br i1 %35, label %$36, label %$37
$36:
  %115 = phi i64 [%113, %$-9] ; # N
  %116 = phi i64 [%114, %$-9] ; # Y
; # (neg Y)
  %117 = icmp eq i64 %116, 2
  br i1 %117, label %$39, label %$40
$39:
  br label %$41
$40:
  %118 = xor i64 %116, 8
  br label %$41
$41:
  %119 = phi i64 [%116, %$39], [%118, %$40] ; # ->
  br label %$38
$37:
  %120 = phi i64 [%113, %$-9] ; # N
  %121 = phi i64 [%114, %$-9] ; # Y
  br label %$38
$38:
  %122 = phi i64 [%115, %$41], [%120, %$37] ; # N
  %123 = phi i64 [%116, %$41], [%121, %$37] ; # Y
  %124 = phi i64 [%119, %$41], [%121, %$37] ; # ->
; # (drop *Safe)
  %125 = inttoptr i64 %40 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
  %128 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %127, i64* %128
  br label %$14
$14:
  %129 = phi i64 [%30, %$12], [%122, %$38] ; # N
  %130 = phi i64 [%31, %$12], [%123, %$38] ; # Y
  %131 = phi i64 [%31, %$12], [%124, %$38] ; # ->
  ret i64 %131
}

define i64 @_rev(i64) align 8 {
$1:
; # (let (X (cdr Exe) C (evCnt Exe X) N (evCnt Exe (cdr X)) R 0) (loo...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (cdr X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (evCnt Exe (cdr X))
  %8 = call i64 @evCnt(i64 %0, i64 %7)
; # (loop (setq R (+ R R (& N 1)) N (shr N 1)) (? (=0 (dec 'C))))
  br label %$2
$2:
  %9 = phi i64 [%4, %$1], [%18, %$3] ; # C
  %10 = phi i64 [%8, %$1], [%19, %$3] ; # N
  %11 = phi i64 [0, %$1], [%20, %$3] ; # R
; # (& N 1)
  %12 = and i64 %10, 1
; # (+ R R (& N 1))
  %13 = add i64 %11, %11
  %14 = add i64 %13, %12
; # (shr N 1)
  %15 = lshr i64 %10, 1
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %16 = sub i64 %9, 1
; # (=0 (dec 'C))
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$4, label %$3
$3:
  %18 = phi i64 [%16, %$2] ; # C
  %19 = phi i64 [%15, %$2] ; # N
  %20 = phi i64 [%14, %$2] ; # R
  br label %$2
$4:
  %21 = phi i64 [%16, %$2] ; # C
  %22 = phi i64 [%15, %$2] ; # N
  %23 = phi i64 [%14, %$2] ; # R
  %24 = phi i64 [0, %$2] ; # ->
; # (cnt R)
  %25 = shl i64 %23, 4
  %26 = or i64 %25, 2
  ret i64 %26
}

define i64 @_lt0(i64) align 8 {
$1:
; # (if (and (num? (eval (cadr Exe))) (sign? @)) @ $Nil)
; # (and (num? (eval (cadr Exe))) (sign? @))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (sign? @)
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br label %$2
$2:
  %18 = phi i1 [0, %$3], [%17, %$8] ; # ->
  br i1 %18, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %19 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %19
}

define i64 @_le0(i64) align 8 {
$1:
; # (if (and (num? (eval (cadr Exe))) (or (== @ ZERO) (sign? @))) @ $...
; # (and (num? (eval (cadr Exe))) (or (== @ ZERO) (sign? @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (or (== @ ZERO) (sign? @))
; # (== @ ZERO)
  %16 = icmp eq i64 %13, 2
  br i1 %16, label %$9, label %$10
$10:
; # (sign? @)
  %17 = and i64 %13, 8
  %18 = icmp ne i64 %17, 0
  br label %$9
$9:
  %19 = phi i1 [1, %$8], [%18, %$10] ; # ->
  br label %$2
$2:
  %20 = phi i1 [0, %$3], [%19, %$9] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  br label %$13
$12:
  br label %$13
$13:
  %21 = phi i64 [%13, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %21
}

define i64 @_ge0(i64) align 8 {
$1:
; # (if (and (num? (eval (cadr Exe))) (not (sign? @))) @ $Nil)
; # (and (num? (eval (cadr Exe))) (not (sign? @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (sign? @)
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
; # (not (sign? @))
  %18 = icmp eq i1 %17, 0
  br label %$2
$2:
  %19 = phi i1 [0, %$3], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_gt0(i64) align 8 {
$1:
; # (if (and (num? (eval (cadr Exe))) (<> @ ZERO) (not (sign? @))) @ ...
; # (and (num? (eval (cadr Exe))) (<> @ ZERO) (not (sign? @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (<> @ ZERO)
  %16 = icmp ne i64 %13, 2
  br i1 %16, label %$9, label %$2
$9:
; # (sign? @)
  %17 = and i64 %13, 8
  %18 = icmp ne i64 %17, 0
; # (not (sign? @))
  %19 = icmp eq i1 %18, 0
  br label %$2
$2:
  %20 = phi i1 [0, %$3], [0, %$8], [%19, %$9] ; # ->
  br i1 %20, label %$10, label %$11
$10:
  br label %$12
$11:
  br label %$12
$12:
  %21 = phi i64 [%13, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  ret i64 %21
}

define i64 @_abs(i64) align 8 {
$1:
; # (if (nil? (eval (cadr Exe))) @ (pos (needNum Exe @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (needNum Exe @)
  %15 = and i64 %13, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %17 = and i64 %13, -9
  br label %$9
$9:
  %18 = phi i64 [%13, %$7], [%17, %$11] ; # ->
  ret i64 %18
}

define i64 @_bitQ(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (save (pos (needNum Exe (eval (++ X)))))) (lo...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (pos (needNum Exe (eval (++ X))))
  %18 = and i64 %15, -9
; # (save (pos (needNum Exe (eval (++ X)))))
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (loop (? (atom X) N) (let Y (eval (++ X)) (? (nil? Y) Y) (setq Y ...
  br label %$9
$9:
  %27 = phi i64 [%7, %$8], [%116, %$31] ; # X
; # (? (atom X) N)
; # (atom X)
  %28 = and i64 %27, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$10
$12:
  %30 = phi i64 [%27, %$9] ; # X
  br label %$11
$10:
  %31 = phi i64 [%27, %$9] ; # X
; # (let Y (eval (++ X)) (? (nil? Y) Y) (setq Y (pos (needNum Exe Y))...
; # (++ X)
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
  %34 = getelementptr i64, i64* %32, i32 1
  %35 = load i64, i64* %34
; # (eval (++ X))
  %36 = and i64 %33, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$15, label %$14
$15:
  br label %$13
$14:
  %38 = and i64 %33, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$17, label %$16
$17:
  %40 = inttoptr i64 %33 to i64*
  %41 = load i64, i64* %40
  br label %$13
$16:
  %42 = call i64 @evList(i64 %33)
  br label %$13
$13:
  %43 = phi i64 [%33, %$15], [%41, %$17], [%42, %$16] ; # ->
; # (? (nil? Y) Y)
; # (nil? Y)
  %44 = icmp eq i64 %43, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %44, label %$19, label %$18
$19:
  %45 = phi i64 [%35, %$13] ; # X
  %46 = phi i64 [%43, %$13] ; # Y
  br label %$11
$18:
  %47 = phi i64 [%35, %$13] ; # X
  %48 = phi i64 [%43, %$13] ; # Y
; # (needNum Exe Y)
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$21, label %$20
$20:
  call void @numErr(i64 %0, i64 %48)
  unreachable
$21:
; # (pos (needNum Exe Y))
  %51 = and i64 %48, -9
; # (let Z N (while (big? Z) (unless (big? Y) (ret $Nil)) (let A (val...
; # (while (big? Z) (unless (big? Y) (ret $Nil)) (let A (val (dig Z))...
  br label %$22
$22:
  %52 = phi i64 [%47, %$21], [%87, %$28] ; # X
  %53 = phi i64 [%51, %$21], [%92, %$28] ; # Y
  %54 = phi i64 [%18, %$21], [%95, %$28] ; # Z
; # (big? Z)
  %55 = and i64 %54, 4
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$23, label %$24
$23:
  %57 = phi i64 [%52, %$22] ; # X
  %58 = phi i64 [%53, %$22] ; # Y
  %59 = phi i64 [%54, %$22] ; # Z
; # (unless (big? Y) (ret $Nil))
; # (big? Y)
  %60 = and i64 %58, 4
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$26, label %$25
$25:
  %62 = phi i64 [%57, %$23] ; # X
  %63 = phi i64 [%58, %$23] ; # Y
  %64 = phi i64 [%59, %$23] ; # Z
; # (ret $Nil)
; # (drop *Safe)
  %65 = inttoptr i64 %22 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %68
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$26:
  %69 = phi i64 [%57, %$23] ; # X
  %70 = phi i64 [%58, %$23] ; # Y
  %71 = phi i64 [%59, %$23] ; # Z
; # (let A (val (dig Z)) (unless (== A (& A (val (dig Y)))) (ret $Nil...
; # (dig Z)
  %72 = add i64 %71, -4
; # (val (dig Z))
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
; # (unless (== A (& A (val (dig Y)))) (ret $Nil))
; # (dig Y)
  %75 = add i64 %70, -4
; # (val (dig Y))
  %76 = inttoptr i64 %75 to i64*
  %77 = load i64, i64* %76
; # (& A (val (dig Y)))
  %78 = and i64 %74, %77
; # (== A (& A (val (dig Y))))
  %79 = icmp eq i64 %74, %78
  br i1 %79, label %$28, label %$27
$27:
  %80 = phi i64 [%69, %$26] ; # X
  %81 = phi i64 [%70, %$26] ; # Y
  %82 = phi i64 [%71, %$26] ; # Z
; # (ret $Nil)
; # (drop *Safe)
  %83 = inttoptr i64 %22 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  %85 = load i64, i64* %84
  %86 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %85, i64* %86
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$28:
  %87 = phi i64 [%69, %$26] ; # X
  %88 = phi i64 [%70, %$26] ; # Y
  %89 = phi i64 [%71, %$26] ; # Z
; # (big Y)
  %90 = add i64 %88, 4
; # (val (big Y))
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (big Z)
  %93 = add i64 %89, 4
; # (val (big Z))
  %94 = inttoptr i64 %93 to i64*
  %95 = load i64, i64* %94
  br label %$22
$24:
  %96 = phi i64 [%52, %$22] ; # X
  %97 = phi i64 [%53, %$22] ; # Y
  %98 = phi i64 [%54, %$22] ; # Z
; # (when (big? Y) (setq Z (int Z) Y (val (dig Y))))
; # (big? Y)
  %99 = and i64 %97, 4
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$29, label %$30
$29:
  %101 = phi i64 [%96, %$24] ; # X
  %102 = phi i64 [%97, %$24] ; # Y
  %103 = phi i64 [%98, %$24] ; # Z
; # (int Z)
  %104 = lshr i64 %103, 4
; # (dig Y)
  %105 = add i64 %102, -4
; # (val (dig Y))
  %106 = inttoptr i64 %105 to i64*
  %107 = load i64, i64* %106
  br label %$30
$30:
  %108 = phi i64 [%96, %$24], [%101, %$29] ; # X
  %109 = phi i64 [%97, %$24], [%107, %$29] ; # Y
  %110 = phi i64 [%98, %$24], [%104, %$29] ; # Z
; # (? (<> Z (& Y Z)) $Nil)
; # (& Y Z)
  %111 = and i64 %109, %110
; # (<> Z (& Y Z))
  %112 = icmp ne i64 %110, %111
  br i1 %112, label %$32, label %$31
$32:
  %113 = phi i64 [%108, %$30] ; # X
  %114 = phi i64 [%109, %$30] ; # Y
  %115 = phi i64 [%110, %$30] ; # Z
  br label %$11
$31:
  %116 = phi i64 [%108, %$30] ; # X
  %117 = phi i64 [%109, %$30] ; # Y
  %118 = phi i64 [%110, %$30] ; # Z
  br label %$9
$11:
  %119 = phi i64 [%30, %$12], [%45, %$19], [%113, %$32] ; # X
  %120 = phi i64 [%18, %$12], [%46, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$32] ; # ->
; # (drop *Safe)
  %121 = inttoptr i64 %22 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  %123 = load i64, i64* %122
  %124 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %123, i64* %124
  ret i64 %120
}

define i64 @_bitAnd(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (pos (...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (pos (needNum Exe @)) NIL)) (loop ...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let R (link (push (pos (needNum Exe @)) NIL)) (loop (? (atom (sh...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %27 = and i64 %13, -9
; # (push (pos (needNum Exe @)) NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
; # (link (push (pos (needNum Exe @)) NIL))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %36 = phi i64 [%16, %$11], [%58, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (atom (shift X))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$15, label %$13
$15:
  %42 = phi i64 [%39, %$12] ; # X
; # (val R)
  %43 = inttoptr i64 %29 to i64*
  %44 = load i64, i64* %43
  br label %$14
$13:
  %45 = phi i64 [%39, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$17
$18:
  br label %$16
$17:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$16
$19:
  %54 = call i64 @evList(i64 %47)
  br label %$16
$16:
  %55 = phi i64 [%47, %$18], [%53, %$20], [%54, %$19] ; # ->
; # (nil? (eval (car X)))
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%45, %$16] ; # X
  br label %$14
$21:
  %58 = phi i64 [%45, %$16] ; # X
; # (needNum Exe @)
  %59 = and i64 %55, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %55)
  unreachable
$24:
; # (safe (needNum Exe @))
  %61 = inttoptr i64 %20 to i64*
  store i64 %55, i64* %61
; # (set R (andu (val R) (pos @)))
; # (val R)
  %62 = inttoptr i64 %29 to i64*
  %63 = load i64, i64* %62
; # (pos @)
  %64 = and i64 %55, -9
; # (andu (val R) (pos @))
  %65 = call i64 @andu(i64 %63, i64 %64)
  %66 = inttoptr i64 %29 to i64*
  store i64 %65, i64* %66
  br label %$12
$14:
  %67 = phi i64 [%42, %$15], [%57, %$22] ; # X
  %68 = phi i64 [%44, %$15], [%55, %$22] ; # ->
; # drop
  %69 = inttoptr i64 %20 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  br label %$9
$9:
  %73 = phi i64 [%15, %$7], [%67, %$14] ; # X
  %74 = phi i64 [%13, %$7], [%68, %$14] ; # ->
  ret i64 %74
}

define i64 @_bitOr(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (pos (...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (pos (needNum Exe @)) NIL)) (loop ...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let R (link (push (pos (needNum Exe @)) NIL)) (loop (? (atom (sh...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %27 = and i64 %13, -9
; # (push (pos (needNum Exe @)) NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
; # (link (push (pos (needNum Exe @)) NIL))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %36 = phi i64 [%16, %$11], [%58, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (atom (shift X))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$15, label %$13
$15:
  %42 = phi i64 [%39, %$12] ; # X
; # (val R)
  %43 = inttoptr i64 %29 to i64*
  %44 = load i64, i64* %43
  br label %$14
$13:
  %45 = phi i64 [%39, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$17
$18:
  br label %$16
$17:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$16
$19:
  %54 = call i64 @evList(i64 %47)
  br label %$16
$16:
  %55 = phi i64 [%47, %$18], [%53, %$20], [%54, %$19] ; # ->
; # (nil? (eval (car X)))
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%45, %$16] ; # X
  br label %$14
$21:
  %58 = phi i64 [%45, %$16] ; # X
; # (needNum Exe @)
  %59 = and i64 %55, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %55)
  unreachable
$24:
; # (safe (needNum Exe @))
  %61 = inttoptr i64 %20 to i64*
  store i64 %55, i64* %61
; # (set R (oru (val R) (pos @)))
; # (val R)
  %62 = inttoptr i64 %29 to i64*
  %63 = load i64, i64* %62
; # (pos @)
  %64 = and i64 %55, -9
; # (oru (val R) (pos @))
  %65 = call i64 @oru(i64 %63, i64 %64)
  %66 = inttoptr i64 %29 to i64*
  store i64 %65, i64* %66
  br label %$12
$14:
  %67 = phi i64 [%42, %$15], [%57, %$22] ; # X
  %68 = phi i64 [%44, %$15], [%55, %$22] ; # ->
; # drop
  %69 = inttoptr i64 %20 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  br label %$9
$9:
  %73 = phi i64 [%15, %$7], [%67, %$14] ; # X
  %74 = phi i64 [%13, %$7], [%68, %$14] ; # ->
  ret i64 %74
}

define i64 @_bitXor(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (pos (...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (pos (needNum Exe @)) NIL)) (loop ...
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 10, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (let R (link (push (pos (needNum Exe @)) NIL)) (loop (? (atom (sh...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %27 = and i64 %13, -9
; # (push (pos (needNum Exe @)) NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
; # (link (push (pos (needNum Exe @)) NIL))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %36 = phi i64 [%16, %$11], [%58, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (atom (shift X))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$15, label %$13
$15:
  %42 = phi i64 [%39, %$12] ; # X
; # (val R)
  %43 = inttoptr i64 %29 to i64*
  %44 = load i64, i64* %43
  br label %$14
$13:
  %45 = phi i64 [%39, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$17
$18:
  br label %$16
$17:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$16
$19:
  %54 = call i64 @evList(i64 %47)
  br label %$16
$16:
  %55 = phi i64 [%47, %$18], [%53, %$20], [%54, %$19] ; # ->
; # (nil? (eval (car X)))
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%45, %$16] ; # X
  br label %$14
$21:
  %58 = phi i64 [%45, %$16] ; # X
; # (needNum Exe @)
  %59 = and i64 %55, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %55)
  unreachable
$24:
; # (safe (needNum Exe @))
  %61 = inttoptr i64 %20 to i64*
  store i64 %55, i64* %61
; # (set R (xoru (val R) (pos @)))
; # (val R)
  %62 = inttoptr i64 %29 to i64*
  %63 = load i64, i64* %62
; # (pos @)
  %64 = and i64 %55, -9
; # (xoru (val R) (pos @))
  %65 = call i64 @xoru(i64 %63, i64 %64)
  %66 = inttoptr i64 %29 to i64*
  store i64 %65, i64* %66
  br label %$12
$14:
  %67 = phi i64 [%42, %$15], [%57, %$22] ; # X
  %68 = phi i64 [%44, %$15], [%55, %$22] ; # ->
; # drop
  %69 = inttoptr i64 %20 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  br label %$9
$9:
  %73 = phi i64 [%15, %$7], [%67, %$14] ; # X
  %74 = phi i64 [%13, %$7], [%68, %$14] ; # ->
  ret i64 %74
}

define i64 @_sqrt(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (when (sign? (needNu...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (when (sign? (needNum Exe @)) (argErr...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (when (sign? (needNum Exe @)) (argErr Exe @))
; # (needNum Exe @)
  %15 = and i64 %13, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %17 = and i64 %13, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$12, label %$13
$12:
; # (argErr Exe @)
  call void @argErr(i64 %0, i64 %13)
  unreachable
$13:
; # (let (Y (save @) Z (save (eval (cadr X)))) (when (num? Z) (setq Y...
; # (save @)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %13, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (cadr X)
  %27 = inttoptr i64 %3 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (cadr X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$16, label %$15
$16:
  br label %$14
$15:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$18, label %$17
$18:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$14
$17:
  %38 = call i64 @evList(i64 %31)
  br label %$14
$14:
  %39 = phi i64 [%31, %$16], [%37, %$18], [%38, %$17] ; # ->
; # (save (eval (cadr X)))
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 %39, i64* %44
  %45 = add i64 %43, 8
  %46 = inttoptr i64 %45 to i64*
  store i64 %41, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %47
; # (when (num? Z) (setq Y (safe (mulu Y Z))))
; # (num? Z)
  %48 = and i64 %39, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$19, label %$20
$19:
  %50 = phi i64 [%13, %$14] ; # Y
; # (mulu Y Z)
  %51 = call i64 @mulu(i64 %50, i64 %39)
; # (safe (mulu Y Z))
  %52 = inttoptr i64 %22 to i64*
  store i64 %51, i64* %52
  br label %$20
$20:
  %53 = phi i64 [%13, %$14], [%51, %$19] ; # Y
; # (prog1 (if (cnt? Y) (let (M (hex "400000000000000") R 0) (setq Y ...
; # (if (cnt? Y) (let (M (hex "400000000000000") R 0) (setq Y (int Y)...
; # (cnt? Y)
  %54 = and i64 %53, 2
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$21, label %$22
$21:
  %56 = phi i64 [%53, %$20] ; # Y
; # (let (M (hex "400000000000000") R 0) (setq Y (int Y)) (loop (let ...
; # (int Y)
  %57 = lshr i64 %56, 4
; # (loop (let N (+ R M) (when (>= Y N) (dec 'Y N) (setq R (+ N M))))...
  br label %$24
$24:
  %58 = phi i64 [%57, %$21], [%74, %$27] ; # Y
  %59 = phi i64 [288230376151711744, %$21], [%75, %$27] ; # M
  %60 = phi i64 [0, %$21], [%76, %$27] ; # R
; # (let N (+ R M) (when (>= Y N) (dec 'Y N) (setq R (+ N M))))
; # (+ R M)
  %61 = add i64 %60, %59
; # (when (>= Y N) (dec 'Y N) (setq R (+ N M)))
; # (>= Y N)
  %62 = icmp uge i64 %58, %61
  br i1 %62, label %$25, label %$26
$25:
  %63 = phi i64 [%58, %$24] ; # Y
  %64 = phi i64 [%59, %$24] ; # M
  %65 = phi i64 [%60, %$24] ; # R
; # (dec 'Y N)
  %66 = sub i64 %63, %61
; # (+ N M)
  %67 = add i64 %61, %64
  br label %$26
$26:
  %68 = phi i64 [%58, %$24], [%66, %$25] ; # Y
  %69 = phi i64 [%59, %$24], [%64, %$25] ; # M
  %70 = phi i64 [%60, %$24], [%67, %$25] ; # R
; # (shr R 1)
  %71 = lshr i64 %70, 1
; # (? (=0 (setq M (shr M 2))))
; # (shr M 2)
  %72 = lshr i64 %69, 2
; # (=0 (setq M (shr M 2)))
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %$28, label %$27
$27:
  %74 = phi i64 [%68, %$26] ; # Y
  %75 = phi i64 [%72, %$26] ; # M
  %76 = phi i64 [%71, %$26] ; # R
  br label %$24
$28:
  %77 = phi i64 [%68, %$26] ; # Y
  %78 = phi i64 [%72, %$26] ; # M
  %79 = phi i64 [%71, %$26] ; # R
  %80 = phi i64 [0, %$26] ; # ->
; # (or (nil? Z) (>= R Y) (inc 'R))
; # (nil? Z)
  %81 = icmp eq i64 %39, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %81, label %$29, label %$30
$30:
  %82 = phi i64 [%77, %$28] ; # Y
  %83 = phi i64 [%78, %$28] ; # M
  %84 = phi i64 [%79, %$28] ; # R
; # (>= R Y)
  %85 = icmp uge i64 %84, %82
  br i1 %85, label %$29, label %$31
$31:
  %86 = phi i64 [%82, %$30] ; # Y
  %87 = phi i64 [%83, %$30] ; # M
  %88 = phi i64 [%84, %$30] ; # R
; # (inc 'R)
  %89 = add i64 %88, 1
  %90 = icmp ne i64 %89, 0
  br label %$29
$29:
  %91 = phi i64 [%77, %$28], [%82, %$30], [%86, %$31] ; # Y
  %92 = phi i64 [%78, %$28], [%83, %$30], [%87, %$31] ; # M
  %93 = phi i64 [%79, %$28], [%84, %$30], [%89, %$31] ; # R
  %94 = phi i1 [1, %$28], [1, %$30], [%90, %$31] ; # ->
; # (cnt R)
  %95 = shl i64 %93, 4
  %96 = or i64 %95, 2
  br label %$23
$22:
  %97 = phi i64 [%53, %$20] ; # Y
; # (let (M (consNum 0 ONE) M* (link (push M NIL)) R (link (push ZERO...
; # (consNum 0 ONE)
  %98 = call i64 @consNum(i64 0, i64 18)
; # (push M NIL)
  %99 = alloca i64, i64 2, align 16
  %100 = ptrtoint i64* %99 to i64
  %101 = inttoptr i64 %100 to i64*
  store i64 %98, i64* %101
; # (link (push M NIL))
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %103 = load i64, i64* %102
  %104 = inttoptr i64 %100 to i64*
  %105 = getelementptr i64, i64* %104, i32 1
  store i64 %103, i64* %105
  %106 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %100, i64* %106
; # (push ZERO NIL)
  %107 = alloca i64, i64 2, align 16
  %108 = ptrtoint i64* %107 to i64
  %109 = inttoptr i64 %108 to i64*
  store i64 2, i64* %109
; # (link (push ZERO NIL))
  %110 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %111 = load i64, i64* %110
  %112 = inttoptr i64 %108 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  store i64 %111, i64* %113
  %114 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %108, i64* %114
; # (dig Y)
  %115 = add i64 %97, -4
; # (val (dig Y))
  %116 = inttoptr i64 %115 to i64*
  %117 = load i64, i64* %116
; # (boxNum (val (dig Y)))
  %118 = call i64 @boxNum(i64 %117)
; # (push C NIL)
  %119 = alloca i64, i64 2, align 16
  %120 = ptrtoint i64* %119 to i64
  %121 = inttoptr i64 %120 to i64*
  store i64 %118, i64* %121
; # (link (push C NIL))
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %123 = load i64, i64* %122
  %124 = inttoptr i64 %120 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  store i64 %123, i64* %125
  %126 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %120, i64* %126
; # (while (big? (setq Y (val (big Y)))) (setq C (set (big C) (boxNum...
  br label %$32
$32:
  %127 = phi i64 [%97, %$22], [%136, %$33] ; # Y
  %128 = phi i64 [%98, %$22], [%146, %$33] ; # M
  %129 = phi i64 [%108, %$22], [%138, %$33] ; # R
  %130 = phi i64 [%118, %$22], [%144, %$33] ; # C
; # (big Y)
  %131 = add i64 %127, 4
; # (val (big Y))
  %132 = inttoptr i64 %131 to i64*
  %133 = load i64, i64* %132
; # (big? (setq Y (val (big Y))))
  %134 = and i64 %133, 4
  %135 = icmp ne i64 %134, 0
  br i1 %135, label %$33, label %$34
$33:
  %136 = phi i64 [%133, %$32] ; # Y
  %137 = phi i64 [%128, %$32] ; # M
  %138 = phi i64 [%129, %$32] ; # R
  %139 = phi i64 [%130, %$32] ; # C
; # (set (big C) (boxNum (val (dig Y))))
; # (big C)
  %140 = add i64 %139, 4
; # (dig Y)
  %141 = add i64 %136, -4
; # (val (dig Y))
  %142 = inttoptr i64 %141 to i64*
  %143 = load i64, i64* %142
; # (boxNum (val (dig Y)))
  %144 = call i64 @boxNum(i64 %143)
  %145 = inttoptr i64 %140 to i64*
  store i64 %144, i64* %145
; # (set M* (consNum 0 M))
; # (consNum 0 M)
  %146 = call i64 @consNum(i64 0, i64 %137)
  %147 = inttoptr i64 %100 to i64*
  store i64 %146, i64* %147
  br label %$32
$34:
  %148 = phi i64 [%133, %$32] ; # Y
  %149 = phi i64 [%128, %$32] ; # M
  %150 = phi i64 [%129, %$32] ; # R
  %151 = phi i64 [%130, %$32] ; # C
; # (set (big C) Y)
; # (big C)
  %152 = add i64 %151, 4
  %153 = inttoptr i64 %152 to i64*
  store i64 %148, i64* %153
; # (val C*)
  %154 = inttoptr i64 %120 to i64*
  %155 = load i64, i64* %154
; # (safe (val C*))
  %156 = inttoptr i64 %22 to i64*
  store i64 %155, i64* %156
; # (while (le0 (cmpu M Y)) (twiceBig M) (twiceBig M))
  br label %$35
$35:
  %157 = phi i64 [%155, %$34], [%163, %$36] ; # Y
  %158 = phi i64 [%149, %$34], [%164, %$36] ; # M
  %159 = phi i64 [%150, %$34], [%165, %$36] ; # R
  %160 = phi i64 [%151, %$34], [%166, %$36] ; # C
; # (cmpu M Y)
  %161 = call i64 @cmpu(i64 %158, i64 %157)
; # (le0 (cmpu M Y))
  %162 = icmp sle i64 %161, 0
  br i1 %162, label %$36, label %$37
$36:
  %163 = phi i64 [%157, %$35] ; # Y
  %164 = phi i64 [%158, %$35] ; # M
  %165 = phi i64 [%159, %$35] ; # R
  %166 = phi i64 [%160, %$35] ; # C
; # (twiceBig M)
  %167 = call i64 @twiceBig(i64 %164)
; # (twiceBig M)
  %168 = call i64 @twiceBig(i64 %164)
  br label %$35
$37:
  %169 = phi i64 [%157, %$35] ; # Y
  %170 = phi i64 [%158, %$35] ; # M
  %171 = phi i64 [%159, %$35] ; # R
  %172 = phi i64 [%160, %$35] ; # C
; # (loop (let N (set C* (addu (val R) M)) (when (ge0 (cmpu Y N)) (se...
  br label %$38
$38:
  %173 = phi i64 [%169, %$37], [%203, %$41] ; # Y
  %174 = phi i64 [%170, %$37], [%204, %$41] ; # M
  %175 = phi i64 [%171, %$37], [%205, %$41] ; # R
  %176 = phi i64 [%172, %$37], [%206, %$41] ; # C
; # (let N (set C* (addu (val R) M)) (when (ge0 (cmpu Y N)) (setq Y (...
; # (set C* (addu (val R) M))
; # (val R)
  %177 = inttoptr i64 %175 to i64*
  %178 = load i64, i64* %177
; # (addu (val R) M)
  %179 = call i64 @addu(i64 %178, i64 %174)
  %180 = inttoptr i64 %120 to i64*
  store i64 %179, i64* %180
; # (when (ge0 (cmpu Y N)) (setq Y (safe (subu Y N))) (set R (addu N ...
; # (cmpu Y N)
  %181 = call i64 @cmpu(i64 %173, i64 %179)
; # (ge0 (cmpu Y N))
  %182 = icmp sge i64 %181, 0
  br i1 %182, label %$39, label %$40
$39:
  %183 = phi i64 [%173, %$38] ; # Y
  %184 = phi i64 [%174, %$38] ; # M
  %185 = phi i64 [%175, %$38] ; # R
  %186 = phi i64 [%176, %$38] ; # C
; # (subu Y N)
  %187 = call i64 @subu(i64 %183, i64 %179)
; # (safe (subu Y N))
  %188 = inttoptr i64 %22 to i64*
  store i64 %187, i64* %188
; # (set R (addu N M))
; # (addu N M)
  %189 = call i64 @addu(i64 %179, i64 %184)
  %190 = inttoptr i64 %185 to i64*
  store i64 %189, i64* %190
  br label %$40
$40:
  %191 = phi i64 [%173, %$38], [%187, %$39] ; # Y
  %192 = phi i64 [%174, %$38], [%184, %$39] ; # M
  %193 = phi i64 [%175, %$38], [%185, %$39] ; # R
  %194 = phi i64 [%176, %$38], [%186, %$39] ; # C
; # (set R (half (val R)))
; # (val R)
  %195 = inttoptr i64 %193 to i64*
  %196 = load i64, i64* %195
; # (half (val R))
  %197 = call i64 @half(i64 %196)
  %198 = inttoptr i64 %193 to i64*
  store i64 %197, i64* %198
; # (? (== ZERO (setq M (set M* (half (half M))))))
; # (set M* (half (half M)))
; # (half M)
  %199 = call i64 @half(i64 %192)
; # (half (half M))
  %200 = call i64 @half(i64 %199)
  %201 = inttoptr i64 %100 to i64*
  store i64 %200, i64* %201
; # (== ZERO (setq M (set M* (half (half M)))))
  %202 = icmp eq i64 2, %200
  br i1 %202, label %$42, label %$41
$41:
  %203 = phi i64 [%191, %$40] ; # Y
  %204 = phi i64 [%200, %$40] ; # M
  %205 = phi i64 [%193, %$40] ; # R
  %206 = phi i64 [%194, %$40] ; # C
  br label %$38
$42:
  %207 = phi i64 [%191, %$40] ; # Y
  %208 = phi i64 [%200, %$40] ; # M
  %209 = phi i64 [%193, %$40] ; # R
  %210 = phi i64 [%194, %$40] ; # C
  %211 = phi i64 [0, %$40] ; # ->
; # (val R)
  %212 = inttoptr i64 %209 to i64*
  %213 = load i64, i64* %212
; # (if (or (nil? Z) (ge0 (cmpu R Y))) R (addu R ONE))
; # (or (nil? Z) (ge0 (cmpu R Y)))
; # (nil? Z)
  %214 = icmp eq i64 %39, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %214, label %$43, label %$44
$44:
  %215 = phi i64 [%207, %$42] ; # Y
  %216 = phi i64 [%208, %$42] ; # M
  %217 = phi i64 [%213, %$42] ; # R
  %218 = phi i64 [%210, %$42] ; # C
; # (cmpu R Y)
  %219 = call i64 @cmpu(i64 %217, i64 %215)
; # (ge0 (cmpu R Y))
  %220 = icmp sge i64 %219, 0
  br label %$43
$43:
  %221 = phi i64 [%207, %$42], [%215, %$44] ; # Y
  %222 = phi i64 [%208, %$42], [%216, %$44] ; # M
  %223 = phi i64 [%213, %$42], [%217, %$44] ; # R
  %224 = phi i64 [%210, %$42], [%218, %$44] ; # C
  %225 = phi i1 [1, %$42], [%220, %$44] ; # ->
  br i1 %225, label %$45, label %$46
$45:
  %226 = phi i64 [%221, %$43] ; # Y
  %227 = phi i64 [%222, %$43] ; # M
  %228 = phi i64 [%223, %$43] ; # R
  %229 = phi i64 [%224, %$43] ; # C
  br label %$47
$46:
  %230 = phi i64 [%221, %$43] ; # Y
  %231 = phi i64 [%222, %$43] ; # M
  %232 = phi i64 [%223, %$43] ; # R
  %233 = phi i64 [%224, %$43] ; # C
; # (addu R ONE)
  %234 = call i64 @addu(i64 %232, i64 18)
  br label %$47
$47:
  %235 = phi i64 [%226, %$45], [%230, %$46] ; # Y
  %236 = phi i64 [%227, %$45], [%231, %$46] ; # M
  %237 = phi i64 [%228, %$45], [%232, %$46] ; # R
  %238 = phi i64 [%229, %$45], [%233, %$46] ; # C
  %239 = phi i64 [%228, %$45], [%234, %$46] ; # ->
  br label %$23
$23:
  %240 = phi i64 [%91, %$29], [%235, %$47] ; # Y
  %241 = phi i64 [%96, %$29], [%239, %$47] ; # ->
; # (drop *Safe)
  %242 = inttoptr i64 %22 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
  %245 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %244, i64* %245
  br label %$9
$9:
  %246 = phi i64 [%13, %$7], [%241, %$23] ; # ->
  ret i64 %246
}

define i64 @initSeed(i64) align 8 {
$1:
; # (let C 0 (while (pair X) (inc 'C (initSeed (++ X)))) (unless (nil...
; # (while (pair X) (inc 'C (initSeed (++ X))))
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%10, %$3] ; # X
  %2 = phi i64 [0, %$1], [%12, %$3] ; # C
; # (pair X)
  %3 = and i64 %1, 15
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$3, label %$4
$3:
  %5 = phi i64 [%1, %$2] ; # X
  %6 = phi i64 [%2, %$2] ; # C
; # (++ X)
  %7 = inttoptr i64 %5 to i64*
  %8 = load i64, i64* %7
  %9 = getelementptr i64, i64* %7, i32 1
  %10 = load i64, i64* %9
; # (initSeed (++ X))
  %11 = call i64 @initSeed(i64 %8)
; # (inc 'C (initSeed (++ X)))
  %12 = add i64 %6, %11
  br label %$2
$4:
  %13 = phi i64 [%1, %$2] ; # X
  %14 = phi i64 [%2, %$2] ; # C
; # (unless (nil? X) (unless (num? X) (setq X (name (& (val (tail X))...
; # (nil? X)
  %15 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$6, label %$5
$5:
  %16 = phi i64 [%13, %$4] ; # X
  %17 = phi i64 [%14, %$4] ; # C
; # (unless (num? X) (setq X (name (& (val (tail X)) -9))))
; # (num? X)
  %18 = and i64 %16, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$7:
  %20 = phi i64 [%16, %$5] ; # X
  %21 = phi i64 [%17, %$5] ; # C
; # (tail X)
  %22 = add i64 %20, -8
; # (val (tail X))
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (& (val (tail X)) -9)
  %25 = and i64 %24, -9
; # (name (& (val (tail X)) -9))
  br label %$9
$9:
  %26 = phi i64 [%25, %$7], [%32, %$10] ; # Tail
  %27 = and i64 %26, 6
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$11, label %$10
$10:
  %29 = phi i64 [%26, %$9] ; # Tail
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  br label %$9
$11:
  %33 = phi i64 [%26, %$9] ; # Tail
  br label %$8
$8:
  %34 = phi i64 [%16, %$5], [%33, %$11] ; # X
  %35 = phi i64 [%17, %$5], [%21, %$11] ; # C
; # (if (cnt? X) (inc 'C (shr X 3)) (when (sign? X) (inc 'C) (setq X ...
; # (cnt? X)
  %36 = and i64 %34, 2
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = phi i64 [%34, %$8] ; # X
  %39 = phi i64 [%35, %$8] ; # C
; # (shr X 3)
  %40 = lshr i64 %38, 3
; # (inc 'C (shr X 3))
  %41 = add i64 %39, %40
  br label %$14
$13:
  %42 = phi i64 [%34, %$8] ; # X
  %43 = phi i64 [%35, %$8] ; # C
; # (when (sign? X) (inc 'C) (setq X (pos X)))
; # (sign? X)
  %44 = and i64 %42, 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$15, label %$16
$15:
  %46 = phi i64 [%42, %$13] ; # X
  %47 = phi i64 [%43, %$13] ; # C
; # (inc 'C)
  %48 = add i64 %47, 1
; # (pos X)
  %49 = and i64 %46, -9
  br label %$16
$16:
  %50 = phi i64 [%42, %$13], [%49, %$15] ; # X
  %51 = phi i64 [%43, %$13], [%48, %$15] ; # C
; # (loop (inc 'C (val (dig X))) (? (cnt? (setq X (val (big X))))))
  br label %$17
$17:
  %52 = phi i64 [%50, %$16], [%63, %$18] ; # X
  %53 = phi i64 [%51, %$16], [%64, %$18] ; # C
; # (dig X)
  %54 = add i64 %52, -4
; # (val (dig X))
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (inc 'C (val (dig X)))
  %57 = add i64 %53, %56
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %58 = add i64 %52, 4
; # (val (big X))
  %59 = inttoptr i64 %58 to i64*
  %60 = load i64, i64* %59
; # (cnt? (setq X (val (big X))))
  %61 = and i64 %60, 2
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$18
$18:
  %63 = phi i64 [%60, %$17] ; # X
  %64 = phi i64 [%57, %$17] ; # C
  br label %$17
$19:
  %65 = phi i64 [%60, %$17] ; # X
  %66 = phi i64 [%57, %$17] ; # C
  %67 = phi i64 [0, %$17] ; # ->
; # (int X)
  %68 = lshr i64 %65, 4
; # (inc 'C (int X))
  %69 = add i64 %66, %68
  br label %$14
$14:
  %70 = phi i64 [%38, %$12], [%65, %$19] ; # X
  %71 = phi i64 [%41, %$12], [%69, %$19] ; # C
  %72 = phi i64 [%41, %$12], [%69, %$19] ; # ->
  br label %$6
$6:
  %73 = phi i64 [%13, %$4], [%70, %$14] ; # X
  %74 = phi i64 [%14, %$4], [%71, %$14] ; # C
  ret i64 %74
}

define i64 @_seed(i64) align 8 {
$1:
; # (let N (mul 6364136223846793005 (initSeed (eval (cadr Exe)))) (se...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (initSeed (eval (cadr Exe)))
  %14 = call i64 @initSeed(i64 %13)
; # (mul 6364136223846793005 (initSeed (eval (cadr Exe))))
  %15 = zext i64 %14 to i128
  %16 = mul i128 6364136223846793005, %15
  %17 = lshr i128 %16, 64
  %18 = trunc i128 %17 to i64
  %19 = trunc i128 %16 to i64
; # (set $SeedL N $SeedH @@@)
  store i64 %19, i64* @$SeedL
  store i64 %18, i64* @$SeedH
; # (- 32 3)
; # (shr N (- 32 3))
  %20 = lshr i64 %19, 29
; # (& (shr N (- 32 3)) -8)
  %21 = and i64 %20, -8
; # (| (& (shr N (- 32 3)) -8) 2)
  %22 = or i64 %21, 2
  ret i64 %22
}

define i64 @_hash(i64) align 8 {
$1:
; # (let (N (initSeed (eval (cadr Exe))) C 64 R 0) (loop (when (& (x|...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (initSeed (eval (cadr Exe)))
  %14 = call i64 @initSeed(i64 %13)
; # (loop (when (& (x| N R) 1) (setq R (x| R (hex "14002")))) (setq N...
  br label %$7
$7:
  %15 = phi i64 [%14, %$2], [%32, %$10] ; # N
  %16 = phi i64 [64, %$2], [%33, %$10] ; # C
  %17 = phi i64 [0, %$2], [%34, %$10] ; # R
; # (when (& (x| N R) 1) (setq R (x| R (hex "14002"))))
; # (x| N R)
  %18 = xor i64 %15, %17
; # (& (x| N R) 1)
  %19 = and i64 %18, 1
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$8, label %$9
$8:
  %21 = phi i64 [%15, %$7] ; # N
  %22 = phi i64 [%16, %$7] ; # C
  %23 = phi i64 [%17, %$7] ; # R
; # (x| R (hex "14002"))
  %24 = xor i64 %23, 81922
  br label %$9
$9:
  %25 = phi i64 [%15, %$7], [%21, %$8] ; # N
  %26 = phi i64 [%16, %$7], [%22, %$8] ; # C
  %27 = phi i64 [%17, %$7], [%24, %$8] ; # R
; # (shr N 1)
  %28 = lshr i64 %25, 1
; # (shr R 1)
  %29 = lshr i64 %27, 1
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %30 = sub i64 %26, 1
; # (=0 (dec 'C))
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$11, label %$10
$10:
  %32 = phi i64 [%28, %$9] ; # N
  %33 = phi i64 [%30, %$9] ; # C
  %34 = phi i64 [%29, %$9] ; # R
  br label %$7
$11:
  %35 = phi i64 [%28, %$9] ; # N
  %36 = phi i64 [%30, %$9] ; # C
  %37 = phi i64 [%29, %$9] ; # R
  %38 = phi i64 [0, %$9] ; # ->
; # (inc R)
  %39 = add i64 %37, 1
; # (cnt (inc R))
  %40 = shl i64 %39, 4
  %41 = or i64 %40, 2
  ret i64 %41
}

define i64 @_rand(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X)) N (add (mul 6364136223846793005...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (val $SeedL)
  %16 = load i64, i64* @$SeedL
; # (mul 6364136223846793005 (val $SeedL))
  %17 = zext i64 %16 to i128
  %18 = mul i128 6364136223846793005, %17
  %19 = lshr i128 %18, 64
  %20 = trunc i128 %19 to i64
  %21 = trunc i128 %18 to i64
; # (add (mul 6364136223846793005 (val $SeedL)) 1)
  %22 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %21, i64 1)
  %23 = extractvalue {i64, i1} %22, 1
  %24 = extractvalue {i64, i1} %22, 0
; # (set $SeedL N $SeedH (+ @@@ @@))
  store i64 %24, i64* @$SeedL
; # (+ @@@ @@)
  %25 = zext i1 %23 to i64
  %26 = add i64 %20, %25
  store i64 %26, i64* @$SeedH
; # (cond ((nil? Y) (| (& (shr N (- 32 3)) -8) 2)) ((t? Y) (add N N) ...
; # (nil? Y)
  %27 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %27, label %$9, label %$8
$9:
  %28 = phi i64 [%15, %$2] ; # Y
  %29 = phi i64 [%24, %$2] ; # N
; # (- 32 3)
; # (shr N (- 32 3))
  %30 = lshr i64 %29, 29
; # (& (shr N (- 32 3)) -8)
  %31 = and i64 %30, -8
; # (| (& (shr N (- 32 3)) -8) 2)
  %32 = or i64 %31, 2
  br label %$7
$8:
  %33 = phi i64 [%15, %$2] ; # Y
  %34 = phi i64 [%24, %$2] ; # N
; # (t? Y)
  %35 = icmp eq i64 %33, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %35, label %$11, label %$10
$11:
  %36 = phi i64 [%33, %$8] ; # Y
  %37 = phi i64 [%34, %$8] ; # N
; # (add N N)
  %38 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %37, i64 %37)
  %39 = extractvalue {i64, i1} %38, 1
  %40 = extractvalue {i64, i1} %38, 0
; # (if @@ Y $Nil)
  br i1 %39, label %$12, label %$13
$12:
  %41 = phi i64 [%36, %$11] ; # Y
  %42 = phi i64 [%37, %$11] ; # N
  br label %$14
$13:
  %43 = phi i64 [%36, %$11] ; # Y
  %44 = phi i64 [%37, %$11] ; # N
  br label %$14
$14:
  %45 = phi i64 [%41, %$12], [%43, %$13] ; # Y
  %46 = phi i64 [%42, %$12], [%44, %$13] ; # N
  %47 = phi i64 [%41, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13] ; # ->
  br label %$7
$10:
  %48 = phi i64 [%33, %$8] ; # Y
  %49 = phi i64 [%34, %$8] ; # N
; # (when (sign? (needCnt Exe Y)) (argErr Exe Y))
; # (needCnt Exe Y)
  %50 = and i64 %48, 2
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$16, label %$15
$15:
  call void @cntErr(i64 %0, i64 %48)
  unreachable
$16:
; # (sign? (needCnt Exe Y))
  %52 = and i64 %48, 8
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$17, label %$18
$17:
  %54 = phi i64 [%48, %$16] ; # Y
  %55 = phi i64 [%49, %$16] ; # N
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %54)
  unreachable
$18:
  %56 = phi i64 [%48, %$16] ; # Y
  %57 = phi i64 [%49, %$16] ; # N
; # (let A (int Y) (when (sign? (needCnt Exe (setq Y (eval (car X))))...
; # (int Y)
  %58 = lshr i64 %56, 4
; # (when (sign? (needCnt Exe (setq Y (eval (car X))))) (argErr Exe Y...
; # (car X)
  %59 = inttoptr i64 %7 to i64*
  %60 = load i64, i64* %59
; # (eval (car X))
  %61 = and i64 %60, 6
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$21, label %$20
$21:
  br label %$19
$20:
  %63 = and i64 %60, 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$23, label %$22
$23:
  %65 = inttoptr i64 %60 to i64*
  %66 = load i64, i64* %65
  br label %$19
$22:
  %67 = call i64 @evList(i64 %60)
  br label %$19
$19:
  %68 = phi i64 [%60, %$21], [%66, %$23], [%67, %$22] ; # ->
; # (needCnt Exe (setq Y (eval (car X))))
  %69 = and i64 %68, 2
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$25, label %$24
$24:
  call void @cntErr(i64 %0, i64 %68)
  unreachable
$25:
; # (sign? (needCnt Exe (setq Y (eval (car X)))))
  %71 = and i64 %68, 8
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$26, label %$27
$26:
  %73 = phi i64 [%68, %$25] ; # Y
  %74 = phi i64 [%57, %$25] ; # N
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %73)
  unreachable
$27:
  %75 = phi i64 [%68, %$25] ; # Y
  %76 = phi i64 [%57, %$25] ; # N
; # (let B (inc (int Y)) (when (>= A B) (argErr Exe Y)) (setq N (+ (%...
; # (int Y)
  %77 = lshr i64 %75, 4
; # (inc (int Y))
  %78 = add i64 %77, 1
; # (when (>= A B) (argErr Exe Y))
; # (>= A B)
  %79 = icmp uge i64 %58, %78
  br i1 %79, label %$28, label %$29
$28:
  %80 = phi i64 [%75, %$27] ; # Y
  %81 = phi i64 [%76, %$27] ; # N
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %80)
  unreachable
$29:
  %82 = phi i64 [%75, %$27] ; # Y
  %83 = phi i64 [%76, %$27] ; # N
; # (val $SeedH)
  %84 = load i64, i64* @$SeedH
; # (val $SeedL)
  %85 = load i64, i64* @$SeedL
; # (shr (val $SeedH) (val $SeedL) 32)
  %86 = call i64 @llvm.fshr.i64(i64 %84, i64 %85, i64 32)
; # (- B A)
  %87 = sub i64 %78, %58
; # (% (shr (val $SeedH) (val $SeedL) 32) (- B A))
  %88 = urem i64 %86, %87
; # (+ (% (shr (val $SeedH) (val $SeedL) 32) (- B A)) A)
  %89 = add i64 %88, %58
; # (if (lt0 N) (sign (cnt (- N))) (cnt N))
; # (lt0 N)
  %90 = icmp slt i64 %89, 0
  br i1 %90, label %$30, label %$31
$30:
  %91 = phi i64 [%82, %$29] ; # Y
  %92 = phi i64 [%89, %$29] ; # N
; # (- N)
  %93 = sub i64 0, %92
; # (cnt (- N))
  %94 = shl i64 %93, 4
  %95 = or i64 %94, 2
; # (sign (cnt (- N)))
  %96 = or i64 %95, 8
  br label %$32
$31:
  %97 = phi i64 [%82, %$29] ; # Y
  %98 = phi i64 [%89, %$29] ; # N
; # (cnt N)
  %99 = shl i64 %98, 4
  %100 = or i64 %99, 2
  br label %$32
$32:
  %101 = phi i64 [%91, %$30], [%97, %$31] ; # Y
  %102 = phi i64 [%92, %$30], [%98, %$31] ; # N
  %103 = phi i64 [%96, %$30], [%100, %$31] ; # ->
  br label %$7
$7:
  %104 = phi i64 [%28, %$9], [%45, %$14], [%101, %$32] ; # Y
  %105 = phi i64 [%29, %$9], [%46, %$14], [%102, %$32] ; # N
  %106 = phi i64 [%32, %$9], [%47, %$14], [%103, %$32] ; # ->
  ret i64 %106
}

define i64 @bufSize(i64) align 8 {
$1:
; # (let N 1 (while (big? Nm) (inc 'N 8) (setq Nm (val (big Nm)))) (s...
; # (while (big? Nm) (inc 'N 8) (setq Nm (val (big Nm))))
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%10, %$3] ; # Nm
  %2 = phi i64 [1, %$1], [%7, %$3] ; # N
; # (big? Nm)
  %3 = and i64 %1, 4
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$3, label %$4
$3:
  %5 = phi i64 [%1, %$2] ; # Nm
  %6 = phi i64 [%2, %$2] ; # N
; # (inc 'N 8)
  %7 = add i64 %6, 8
; # (big Nm)
  %8 = add i64 %5, 4
; # (val (big Nm))
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  br label %$2
$4:
  %11 = phi i64 [%1, %$2] ; # Nm
  %12 = phi i64 [%2, %$2] ; # N
; # (int Nm)
  %13 = lshr i64 %11, 4
; # (while Nm (inc 'N) (setq Nm (shr Nm 8)))
  br label %$5
$5:
  %14 = phi i64 [%13, %$4], [%20, %$6] ; # Nm
  %15 = phi i64 [%12, %$4], [%19, %$6] ; # N
  %16 = icmp ne i64 %14, 0
  br i1 %16, label %$6, label %$7
$6:
  %17 = phi i64 [%14, %$5] ; # Nm
  %18 = phi i64 [%15, %$5] ; # N
; # (inc 'N)
  %19 = add i64 %18, 1
; # (shr Nm 8)
  %20 = lshr i64 %17, 8
  br label %$5
$7:
  %21 = phi i64 [%14, %$5] ; # Nm
  %22 = phi i64 [%15, %$5] ; # N
  ret i64 %22
}

define i64 @pathSize(i64) align 8 {
$1:
; # (let (Len (bufSize Nm) N (if (cnt? Nm) (int @) (val (dig @))) B (...
; # (bufSize Nm)
  %1 = call i64 @bufSize(i64 %0)
; # (if (cnt? Nm) (int @) (val (dig @)))
; # (cnt? Nm)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (int @)
  %4 = lshr i64 %0, 4
  br label %$4
$3:
; # (dig @)
  %5 = add i64 %0, -4
; # (val (dig @))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
  br label %$4
$4:
  %8 = phi i64 [%4, %$2], [%7, %$3] ; # ->
; # (i8 N)
  %9 = trunc i64 %8 to i8
; # (cond ((or (== B (char "@")) (and (== B (char "+")) (== (i8 (shr ...
; # (or (== B (char "@")) (and (== B (char "+")) (== (i8 (shr N 8)) (...
; # (== B (char "@"))
  %10 = icmp eq i8 %9, 64
  br i1 %10, label %$6, label %$7
$7:
; # (and (== B (char "+")) (== (i8 (shr N 8)) (char "@")))
; # (== B (char "+"))
  %11 = icmp eq i8 %9, 43
  br i1 %11, label %$9, label %$8
$9:
; # (shr N 8)
  %12 = lshr i64 %8, 8
; # (i8 (shr N 8))
  %13 = trunc i64 %12 to i8
; # (== (i8 (shr N 8)) (char "@"))
  %14 = icmp eq i8 %13, 64
  br label %$8
$8:
  %15 = phi i1 [0, %$7], [%14, %$9] ; # ->
  br label %$6
$6:
  %16 = phi i1 [1, %$4], [%15, %$8] ; # ->
  br i1 %16, label %$11, label %$10
$11:
; # (val $PilLen)
  %17 = load i64, i64* @$PilLen
; # (dec Len)
  %18 = sub i64 %1, 1
; # (+ (val $PilLen) (dec Len))
  %19 = add i64 %17, %18
  br label %$5
$10:
; # (or (== B (char "~")) (and (== B (char "+")) (== (i8 (shr N 8)) (...
; # (== B (char "~"))
  %20 = icmp eq i8 %9, 126
  br i1 %20, label %$12, label %$13
$13:
; # (and (== B (char "+")) (== (i8 (shr N 8)) (char "~")))
; # (== B (char "+"))
  %21 = icmp eq i8 %9, 43
  br i1 %21, label %$15, label %$14
$15:
; # (shr N 8)
  %22 = lshr i64 %8, 8
; # (i8 (shr N 8))
  %23 = trunc i64 %22 to i8
; # (== (i8 (shr N 8)) (char "~"))
  %24 = icmp eq i8 %23, 126
  br label %$14
$14:
  %25 = phi i1 [0, %$13], [%24, %$15] ; # ->
  br label %$12
$12:
  %26 = phi i1 [1, %$10], [%25, %$14] ; # ->
  br i1 %26, label %$17, label %$16
$17:
; # (val $UsrLen)
  %27 = load i64, i64* @$UsrLen
; # (dec Len)
  %28 = sub i64 %1, 1
; # (+ (val $UsrLen) (dec Len))
  %29 = add i64 %27, %28
  br label %$5
$16:
  br label %$5
$5:
  %30 = phi i64 [%19, %$11], [%29, %$17], [%1, %$16] ; # ->
  ret i64 %30
}

define i8* @bufString(i64, i8*) align 8 {
$1:
; # (let Q (push 0 Nm) (prog1 P (while (set P (symByte Q)) (inc 'P)))...
; # (push 0 Nm)
  %2 = alloca i64, i64 2, align 16
  store i64 0, i64* %2
  %3 = getelementptr i64, i64* %2, i32 1
  store i64 %0, i64* %3
; # (prog1 P (while (set P (symByte Q)) (inc 'P)))
; # (while (set P (symByte Q)) (inc 'P))
  br label %$2
$2:
  %4 = phi i8* [%1, %$1], [%8, %$3] ; # P
; # (set P (symByte Q))
; # (symByte Q)
  %5 = call i8 @symByte(i64* %2)
  store i8 %5, i8* %4
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %$3, label %$4
$3:
  %7 = phi i8* [%4, %$2] ; # P
; # (inc 'P)
  %8 = getelementptr i8, i8* %7, i32 1
  br label %$2
$4:
  %9 = phi i8* [%4, %$2] ; # P
  ret i8* %1
}

define i8* @pathString(i64, i8*) align 8 {
$1:
; # (let (Q (push 0 Nm) B (symByte Q)) (prog1 P (when (== B (char "+"...
; # (push 0 Nm)
  %2 = alloca i64, i64 2, align 16
  store i64 0, i64* %2
  %3 = getelementptr i64, i64* %2, i32 1
  store i64 %0, i64* %3
; # (symByte Q)
  %4 = call i8 @symByte(i64* %2)
; # (prog1 P (when (== B (char "+")) (set P B) (inc 'P) (setq B (symB...
; # (when (== B (char "+")) (set P B) (inc 'P) (setq B (symByte Q)))
; # (== B (char "+"))
  %5 = icmp eq i8 %4, 43
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i8* [%1, %$1] ; # P
  %7 = phi i8 [%4, %$1] ; # B
; # (set P B)
  store i8 %7, i8* %6
; # (inc 'P)
  %8 = getelementptr i8, i8* %6, i32 1
; # (symByte Q)
  %9 = call i8 @symByte(i64* %2)
  br label %$3
$3:
  %10 = phi i8* [%1, %$1], [%8, %$2] ; # P
  %11 = phi i8 [%4, %$1], [%9, %$2] ; # B
; # (case B ((char "@") (when (val $PilLen) (memcpy P (val $PilHome) ...
  switch i8 %11, label %$4 [
    i8 64, label %$6
    i8 126, label %$7
  ]
$6:
  %12 = phi i8* [%10, %$3] ; # P
  %13 = phi i8 [%11, %$3] ; # B
; # (when (val $PilLen) (memcpy P (val $PilHome) @) (inc 'P @))
; # (val $PilLen)
  %14 = load i64, i64* @$PilLen
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$9
$8:
  %16 = phi i8* [%12, %$6] ; # P
  %17 = phi i8 [%13, %$6] ; # B
; # (val $PilHome)
  %18 = load i8*, i8** @$PilHome
; # (memcpy P (val $PilHome) @)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %18, i64 %14, i1 0)
; # (inc 'P @)
  %19 = getelementptr i8, i8* %16, i64 %14
  br label %$9
$9:
  %20 = phi i8* [%12, %$6], [%19, %$8] ; # P
  %21 = phi i8 [%13, %$6], [%17, %$8] ; # B
  br label %$5
$7:
  %22 = phi i8* [%10, %$3] ; # P
  %23 = phi i8 [%11, %$3] ; # B
; # (when (val $UsrLen) (memcpy P (val $UsrHome) @) (inc 'P @))
; # (val $UsrLen)
  %24 = load i64, i64* @$UsrLen
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$10, label %$11
$10:
  %26 = phi i8* [%22, %$7] ; # P
  %27 = phi i8 [%23, %$7] ; # B
; # (val $UsrHome)
  %28 = load i8*, i8** @$UsrHome
; # (memcpy P (val $UsrHome) @)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %26, i8* %28, i64 %24, i1 0)
; # (inc 'P @)
  %29 = getelementptr i8, i8* %26, i64 %24
  br label %$11
$11:
  %30 = phi i8* [%22, %$7], [%29, %$10] ; # P
  %31 = phi i8 [%23, %$7], [%27, %$10] ; # B
  br label %$5
$4:
  %32 = phi i8* [%10, %$3] ; # P
  %33 = phi i8 [%11, %$3] ; # B
; # (set P B)
  store i8 %33, i8* %32
; # (inc 'P)
  %34 = getelementptr i8, i8* %32, i32 1
  br label %$5
$5:
  %35 = phi i8* [%20, %$9], [%30, %$11], [%34, %$4] ; # P
  %36 = phi i8 [%21, %$9], [%31, %$11], [%33, %$4] ; # B
; # (while (set P (symByte Q)) (inc 'P))
  br label %$12
$12:
  %37 = phi i8* [%35, %$5], [%43, %$13] ; # P
  %38 = phi i8 [%36, %$5], [%42, %$13] ; # B
; # (set P (symByte Q))
; # (symByte Q)
  %39 = call i8 @symByte(i64* %2)
  store i8 %39, i8* %37
  %40 = icmp ne i8 %39, 0
  br i1 %40, label %$13, label %$14
$13:
  %41 = phi i8* [%37, %$12] ; # P
  %42 = phi i8 [%38, %$12] ; # B
; # (inc 'P)
  %43 = getelementptr i8, i8* %41, i32 1
  br label %$12
$14:
  %44 = phi i8* [%37, %$12] ; # P
  %45 = phi i8 [%38, %$12] ; # B
  ret i8* %1
}

define i64 @mkChar(i32) align 8 {
$1:
; # (cond ((>= 127 C) (i64 C)) ((== TOP C) (hex "FF")) ((> (hex "800"...
; # (>= 127 C)
  %1 = icmp sge i32 127, %0
  br i1 %1, label %$4, label %$3
$4:
; # (i64 C)
  %2 = sext i32 %0 to i64
  br label %$2
$3:
; # (== TOP C)
  %3 = icmp eq i32 1114112, %0
  br i1 %3, label %$6, label %$5
$6:
  br label %$2
$5:
; # (> (hex "800") C)
  %4 = icmp sgt i32 2048, %0
  br i1 %4, label %$8, label %$7
$8:
; # (shr C 6)
  %5 = lshr i32 %0, 6
; # (& (shr C 6) (hex "1F"))
  %6 = and i32 %5, 31
; # (| (hex "C0") (& (shr C 6) (hex "1F")))
  %7 = or i32 192, %6
; # (& C (hex "3F"))
  %8 = and i32 %0, 63
; # (| (hex "80") (& C (hex "3F")))
  %9 = or i32 128, %8
; # (shl (| (hex "80") (& C (hex "3F"))) 8)
  %10 = shl i32 %9, 8
; # (| (| (hex "C0") (& (shr C 6) (hex "1F"))) (shl (| (hex "80") (& ...
  %11 = or i32 %7, %10
; # (i64 (| (| (hex "C0") (& (shr C 6) (hex "1F"))) (shl (| (hex "80"...
  %12 = sext i32 %11 to i64
  br label %$2
$7:
; # (> (hex "10000") C)
  %13 = icmp sgt i32 65536, %0
  br i1 %13, label %$10, label %$9
$10:
; # (shr C 12)
  %14 = lshr i32 %0, 12
; # (& (shr C 12) (hex "0F"))
  %15 = and i32 %14, 15
; # (| (hex "E0") (& (shr C 12) (hex "0F")))
  %16 = or i32 224, %15
; # (shr C 6)
  %17 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %18 = and i32 %17, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %19 = or i32 128, %18
; # (shl (| (hex "80") (& (shr C 6) (hex "3F"))) 8)
  %20 = shl i32 %19, 8
; # (| (| (hex "E0") (& (shr C 12) (hex "0F"))) (shl (| (hex "80") (&...
  %21 = or i32 %16, %20
; # (& C (hex "3F"))
  %22 = and i32 %0, 63
; # (| (hex "80") (& C (hex "3F")))
  %23 = or i32 128, %22
; # (shl (| (hex "80") (& C (hex "3F"))) 16)
  %24 = shl i32 %23, 16
; # (| (| (| (hex "E0") (& (shr C 12) (hex "0F"))) (shl (| (hex "80")...
  %25 = or i32 %21, %24
; # (i64 (| (| (| (hex "E0") (& (shr C 12) (hex "0F"))) (shl (| (hex ...
  %26 = sext i32 %25 to i64
  br label %$2
$9:
; # (shr C 18)
  %27 = lshr i32 %0, 18
; # (& (shr C 18) (hex "07"))
  %28 = and i32 %27, 7
; # (| (hex "F0") (& (shr C 18) (hex "07")))
  %29 = or i32 240, %28
; # (shr C 12)
  %30 = lshr i32 %0, 12
; # (& (shr C 12) (hex "3F"))
  %31 = and i32 %30, 63
; # (| (hex "80") (& (shr C 12) (hex "3F")))
  %32 = or i32 128, %31
; # (shl (| (hex "80") (& (shr C 12) (hex "3F"))) 8)
  %33 = shl i32 %32, 8
; # (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (hex "80") (&...
  %34 = or i32 %29, %33
; # (shr C 6)
  %35 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %36 = and i32 %35, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %37 = or i32 128, %36
; # (shl (| (hex "80") (& (shr C 6) (hex "3F"))) 16)
  %38 = shl i32 %37, 16
; # (| (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (hex "80")...
  %39 = or i32 %34, %38
; # (i64 (| (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (hex ...
  %40 = sext i32 %39 to i64
; # (i64 C)
  %41 = sext i32 %0 to i64
; # (& (i64 C) (hex "3F"))
  %42 = and i64 %41, 63
; # (| (hex "80") (& (i64 C) (hex "3F")))
  %43 = or i64 128, %42
; # (shl (| (hex "80") (& (i64 C) (hex "3F"))) 24)
  %44 = shl i64 %43, 24
; # (| (i64 (| (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (h...
  %45 = or i64 %40, %44
  br label %$2
$2:
  %46 = phi i64 [%2, %$4], [255, %$6], [%12, %$8], [%26, %$10], [%45, %$9] ; # ->
; # (cnt (cond ((>= 127 C) (i64 C)) ((== TOP C) (hex "FF")) ((> (hex ...
  %47 = shl i64 %46, 4
  %48 = or i64 %47, 2
; # (consStr (cnt (cond ((>= 127 C) (i64 C)) ((== TOP C) (hex "FF")) ...
  %49 = call i64 @consStr(i64 %48)
  ret i64 %49
}

define i64 @mkStr(i8*) align 8 {
$1:
; # (if Str (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (while (v...
  %1 = icmp ne i8* %0, null
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i8* [%0, %$1] ; # Str
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (while (val Str) ...
; # (push 4 NIL ZERO NIL)
  %3 = alloca i64, i64 4, align 16
  store i64 4, i64* %3
  %4 = getelementptr i64, i64* %3, i32 2
  store i64 2, i64* %4
; # (ofs P 2)
  %5 = getelementptr i64, i64* %3, i32 2
; # (link (ofs P 2) T)
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %6 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %11
; # (while (val Str) (byteSym @ P) (inc 'Str))
  br label %$5
$5:
  %12 = phi i8* [%2, %$2], [%16, %$6] ; # Str
; # (val Str)
  %13 = load i8, i8* %12
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %$6, label %$7
$6:
  %15 = phi i8* [%12, %$5] ; # Str
; # (byteSym @ P)
  call void @byteSym(i8 %13, i64* %3)
; # (inc 'Str)
  %16 = getelementptr i8, i8* %15, i32 1
  br label %$5
$7:
  %17 = phi i8* [%12, %$5] ; # Str
; # (val 3 P)
  %18 = getelementptr i64, i64* %3, i32 2
  %19 = load i64, i64* %18
; # (consStr (val 3 P))
  %20 = call i64 @consStr(i64 %19)
; # (drop *Safe)
  %21 = inttoptr i64 %6 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %24
  br label %$4
$3:
  %25 = phi i8* [%0, %$1] ; # Str
  br label %$4
$4:
  %26 = phi i8* [%17, %$7], [%25, %$3] ; # Str
  %27 = phi i64 [%20, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %27
}

define i64 @mkStrE(i8*, i8*) align 8 {
$1:
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (loop (? (== Str ...
; # (push 4 NIL ZERO NIL)
  %2 = alloca i64, i64 4, align 16
  store i64 4, i64* %2
  %3 = getelementptr i64, i64* %2, i32 2
  store i64 2, i64* %3
; # (ofs P 2)
  %4 = getelementptr i64, i64* %2, i32 2
; # (link (ofs P 2) T)
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %5 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %10
; # (loop (? (== Str End)) (? (=0 (val Str))) (byteSym @ P) (inc 'Str...
  br label %$2
$2:
  %11 = phi i8* [%0, %$1], [%17, %$5] ; # Str
; # (? (== Str End))
; # (== Str End)
  %12 = icmp eq i8* %11, %1
  br i1 %12, label %$4, label %$3
$3:
  %13 = phi i8* [%11, %$2] ; # Str
; # (? (=0 (val Str)))
; # (val Str)
  %14 = load i8, i8* %13
; # (=0 (val Str))
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %$4, label %$5
$5:
  %16 = phi i8* [%13, %$3] ; # Str
; # (byteSym @ P)
  call void @byteSym(i8 %14, i64* %2)
; # (inc 'Str)
  %17 = getelementptr i8, i8* %16, i32 1
  br label %$2
$4:
  %18 = phi i8* [%11, %$2], [%13, %$3] ; # Str
  %19 = phi i64 [0, %$2], [0, %$3] ; # ->
; # (val 3 P)
  %20 = getelementptr i64, i64* %2, i32 2
  %21 = load i64, i64* %20
; # (consStr (val 3 P))
  %22 = call i64 @consStr(i64 %21)
; # (drop *Safe)
  %23 = inttoptr i64 %5 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %26
  ret i64 %22
}

define i8 @firstByte(i64) align 8 {
$1:
; # (cond ((nil? Sym) 0) ((sym? (val (tail Sym))) 0) ((cnt? (name @))...
; # (nil? Sym)
  %1 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (tail Sym)
  %2 = add i64 %0, -8
; # (val (tail Sym))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (sym? (val (tail Sym)))
  %5 = and i64 %4, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  br label %$2
$5:
; # (name @)
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%13, %$8] ; # Tail
  %8 = and i64 %7, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$9, label %$8
$8:
  %10 = phi i64 [%7, %$7] ; # Tail
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  br label %$7
$9:
  %14 = phi i64 [%7, %$7] ; # Tail
; # (cnt? (name @))
  %15 = and i64 %14, 2
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$10
$11:
; # (int @)
  %17 = lshr i64 %14, 4
  br label %$2
$10:
; # (dig @)
  %18 = add i64 %14, -4
; # (val (dig @))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  br label %$2
$2:
  %21 = phi i64 [0, %$4], [0, %$6], [%17, %$11], [%20, %$10] ; # ->
; # (i8 (cond ((nil? Sym) 0) ((sym? (val (tail Sym))) 0) ((cnt? (name...
  %22 = trunc i64 %21 to i8
  ret i8 %22
}

define i32 @firstChar(i64) align 8 {
$1:
; # (cond ((nil? Sym) 0) ((sym? (val (tail Sym))) 0) (T (symChar (pus...
; # (nil? Sym)
  %1 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (tail Sym)
  %2 = add i64 %0, -8
; # (val (tail Sym))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (sym? (val (tail Sym)))
  %5 = and i64 %4, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  br label %$2
$5:
; # (name @)
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%13, %$8] ; # Tail
  %8 = and i64 %7, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$9, label %$8
$8:
  %10 = phi i64 [%7, %$7] ; # Tail
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  br label %$7
$9:
  %14 = phi i64 [%7, %$7] ; # Tail
; # (push 0 (name @))
  %15 = alloca i64, i64 2, align 16
  store i64 0, i64* %15
  %16 = getelementptr i64, i64* %15, i32 1
  store i64 %14, i64* %16
; # (symChar (push 0 (name @)))
  %17 = call i32 @symChar(i64* %15)
  br label %$2
$2:
  %18 = phi i32 [0, %$4], [0, %$6], [%17, %$9] ; # ->
  ret i32 %18
}

define i1 @isBlank(i64) align 8 {
$1:
; # (or (nil? X) (and (symb? X) (not (sym? (val (tail X)))) (let P (p...
; # (nil? X)
  %1 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %1, label %$2, label %$3
$3:
; # (and (symb? X) (not (sym? (val (tail X)))) (let P (push 0 (name @...
; # (symb? X)
  %2 = xor i64 %0, 8
  %3 = and i64 %2, 14
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$5, label %$4
$5:
; # (tail X)
  %5 = add i64 %0, -8
; # (val (tail X))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (sym? (val (tail X)))
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
; # (not (sym? (val (tail X))))
  %10 = icmp eq i1 %9, 0
  br i1 %10, label %$6, label %$4
$6:
; # (let P (push 0 (name @)) (loop (? (=0 (symByte P)) YES) (? (> @ 3...
; # (name @)
  br label %$7
$7:
  %11 = phi i64 [%7, %$6], [%17, %$8] ; # Tail
  %12 = and i64 %11, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$9, label %$8
$8:
  %14 = phi i64 [%11, %$7] ; # Tail
  %15 = inttoptr i64 %14 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  br label %$7
$9:
  %18 = phi i64 [%11, %$7] ; # Tail
; # (push 0 (name @))
  %19 = alloca i64, i64 2, align 16
  store i64 0, i64* %19
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
; # (loop (? (=0 (symByte P)) YES) (? (> @ 32) NO))
  br label %$10
$10:
; # (? (=0 (symByte P)) YES)
; # (symByte P)
  %21 = call i8 @symByte(i64* %19)
; # (=0 (symByte P))
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %$13, label %$11
$13:
  br label %$12
$11:
; # (? (> @ 32) NO)
; # (> @ 32)
  %23 = icmp ugt i8 %21, 32
  br i1 %23, label %$15, label %$14
$15:
  br label %$12
$14:
  br label %$10
$12:
  %24 = phi i1 [1, %$13], [0, %$15] ; # ->
  br label %$4
$4:
  %25 = phi i1 [0, %$3], [0, %$5], [%24, %$12] ; # ->
  br label %$2
$2:
  %26 = phi i1 [1, %$1], [%25, %$4] ; # ->
  ret i1 %26
}

define i64 @extNm(i32, i64) align 8 {
$1:
; # (& Obj (hex "FFFFF"))
  %2 = and i64 %1, 1048575
; # (& File (hex "FF"))
  %3 = and i32 %0, 255
; # (i64 (& File (hex "FF")))
  %4 = sext i32 %3 to i64
; # (shl (i64 (& File (hex "FF"))) 20)
  %5 = shl i64 %4, 20
; # (shr Obj 20)
  %6 = lshr i64 %1, 20
; # (& (setq Obj (shr Obj 20)) (hex "FFF"))
  %7 = and i64 %6, 4095
; # (shl (& (setq Obj (shr Obj 20)) (hex "FFF")) 28)
  %8 = shl i64 %7, 28
; # (shr File 8)
  %9 = lshr i32 %0, 8
; # (i64 (shr File 8))
  %10 = sext i32 %9 to i64
; # (shl (i64 (shr File 8)) 40)
  %11 = shl i64 %10, 40
; # (shr Obj 12)
  %12 = lshr i64 %6, 12
; # (shl (shr Obj 12) 48)
  %13 = shl i64 %12, 48
; # (| (shl (i64 (shr File 8)) 40) (shl (shr Obj 12) 48))
  %14 = or i64 %11, %13
; # (| (shl (& (setq Obj (shr Obj 20)) (hex "FFF")) 28) (| (shl (i64 ...
  %15 = or i64 %8, %14
; # (| (shl (i64 (& File (hex "FF"))) 20) (| (shl (& (setq Obj (shr O...
  %16 = or i64 %5, %15
; # (| (& Obj (hex "FFFFF")) (| (shl (i64 (& File (hex "FF"))) 20) (|...
  %17 = or i64 %2, %16
; # (cnt (| (& Obj (hex "FFFFF")) (| (shl (i64 (& File (hex "FF"))) 2...
  %18 = shl i64 %17, 4
  %19 = or i64 %18, 2
  ret i64 %19
}

define i32 @objFile(i64) align 8 {
$1:
; # (shr Name 24)
  %1 = lshr i64 %0, 24
; # (i32 (setq Name (shr Name 24)))
  %2 = trunc i64 %1 to i32
; # (& (i32 (setq Name (shr Name 24))) (hex "FF"))
  %3 = and i32 %2, 255
; # (shr Name 12)
  %4 = lshr i64 %1, 12
; # (i32 (shr Name 12))
  %5 = trunc i64 %4 to i32
; # (& (i32 (shr Name 12)) (hex "FF00"))
  %6 = and i32 %5, 65280
; # (| (& (i32 (setq Name (shr Name 24))) (hex "FF")) (& (i32 (shr Na...
  %7 = or i32 %3, %6
  ret i32 %7
}

define i64 @objId(i64) align 8 {
$1:
; # (shr Name 4)
  %1 = lshr i64 %0, 4
; # (& (setq Name (shr Name 4)) (hex "FFFFF"))
  %2 = and i64 %1, 1048575
; # (shr Name 8)
  %3 = lshr i64 %1, 8
; # (& (setq Name (shr Name 8)) (hex "FFF00000"))
  %4 = and i64 %3, 4293918720
; # (| (& (setq Name (shr Name 4)) (hex "FFFFF")) (& (setq Name (shr ...
  %5 = or i64 %2, %4
; # (shr Name 8)
  %6 = lshr i64 %3, 8
; # (& (shr Name 8) (hex "3FF00000000"))
  %7 = and i64 %6, 4393751543808
; # (| (| (& (setq Name (shr Name 4)) (hex "FFFFF")) (& (setq Name (s...
  %8 = or i64 %5, %7
  ret i64 %8
}

define void @packAO(i32, i64*) align 8 {
$1:
; # (when (> File 15) (packAO (shr File 4) P))
; # (> File 15)
  %2 = icmp sgt i32 %0, 15
  br i1 %2, label %$2, label %$3
$2:
; # (shr File 4)
  %3 = lshr i32 %0, 4
; # (packAO (shr File 4) P)
  call void @packAO(i32 %3, i64* %1)
  br label %$3
$3:
; # (i8 File)
  %4 = trunc i32 %0 to i8
; # (& (i8 File) 15)
  %5 = and i8 %4, 15
; # (+ (& (i8 File) 15) (char "@"))
  %6 = add i8 %5, 64
; # (byteSym (+ (& (i8 File) 15) (char "@")) P)
  call void @byteSym(i8 %6, i64* %1)
  ret void
}

define void @packOct(i64, i64*) align 8 {
$1:
; # (when (> Obj 7) (packOct (shr Obj 3) P))
; # (> Obj 7)
  %2 = icmp ugt i64 %0, 7
  br i1 %2, label %$2, label %$3
$2:
; # (shr Obj 3)
  %3 = lshr i64 %0, 3
; # (packOct (shr Obj 3) P)
  call void @packOct(i64 %3, i64* %1)
  br label %$3
$3:
; # (i8 Obj)
  %4 = trunc i64 %0 to i8
; # (& (i8 Obj) 7)
  %5 = and i8 %4, 7
; # (+ (& (i8 Obj) 7) (char "0"))
  %6 = add i8 %5, 48
; # (byteSym (+ (& (i8 Obj) 7) (char "0")) P)
  call void @byteSym(i8 %6, i64* %1)
  ret void
}

define void @packExtNm(i64, i64*) align 8 {
$1:
; # (when (objFile Name) (packAO @ P))
; # (objFile Name)
  %2 = call i32 @objFile(i64 %0)
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (packAO @ P)
  call void @packAO(i32 %2, i64* %1)
  br label %$3
$3:
; # (objId Name)
  %4 = call i64 @objId(i64 %0)
; # (packOct (objId Name) P)
  call void @packOct(i64 %4, i64* %1)
  ret void
}

define void @pack(i64, i64*) align 8 {
$1:
; # (when (pair X) (stkChk 0) (loop (pack (++ X) P) (? (atom X))))
; # (pair X)
  %2 = and i64 %0, 15
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # X
; # (stkChk 0)
  %5 = load i8*, i8** @$StkLimit
  %6 = call i8* @llvm.stacksave()
  %7 = icmp ugt i8* %5, %6
  br i1 %7, label %$4, label %$5
$4:
  call void @stkErr(i64 0)
  unreachable
$5:
; # (loop (pack (++ X) P) (? (atom X)))
  br label %$6
$6:
  %8 = phi i64 [%4, %$5], [%15, %$7] ; # X
; # (++ X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
; # (pack (++ X) P)
  call void @pack(i64 %10, i64* %1)
; # (? (atom X))
; # (atom X)
  %13 = and i64 %12, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$7:
  %15 = phi i64 [%12, %$6] ; # X
  br label %$6
$8:
  %16 = phi i64 [%12, %$6] ; # X
  %17 = phi i64 [0, %$6] ; # ->
  br label %$3
$3:
  %18 = phi i64 [%0, %$1], [%16, %$8] ; # X
; # (cond ((nil? X)) ((num? X) (fmtNum X 0 0 0 P)) ((sym? (val (tail ...
; # (nil? X)
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %19, label %$9, label %$10
$10:
  %20 = phi i64 [%18, %$3] ; # X
; # (num? X)
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$12, label %$11
$12:
  %23 = phi i64 [%20, %$10] ; # X
; # (fmtNum X 0 0 0 P)
  %24 = call i64 @fmtNum(i64 %23, i64 0, i8 0, i8 0, i64* %1)
  br label %$9
$11:
  %25 = phi i64 [%20, %$10] ; # X
; # (tail X)
  %26 = add i64 %25, -8
; # (val (tail X))
  %27 = inttoptr i64 %26 to i64*
  %28 = load i64, i64* %27
; # (sym? (val (tail X)))
  %29 = and i64 %28, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%25, %$11] ; # X
; # (byteSym (char "{") P)
  call void @byteSym(i8 123, i64* %1)
; # (& @ -9)
  %32 = and i64 %28, -9
; # (name (& @ -9))
  br label %$15
$15:
  %33 = phi i64 [%32, %$14], [%39, %$16] ; # Tail
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$17, label %$16
$16:
  %36 = phi i64 [%33, %$15] ; # Tail
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  br label %$15
$17:
  %40 = phi i64 [%33, %$15] ; # Tail
; # (packExtNm (name (& @ -9)) P)
  call void @packExtNm(i64 %40, i64* %1)
; # (byteSym (char "}") P)
  call void @byteSym(i8 125, i64* %1)
  br label %$9
$13:
  %41 = phi i64 [%25, %$11] ; # X
; # (let Q (push 0 (name @)) (while (symByte Q) (byteSym @ P)))
; # (name @)
  br label %$18
$18:
  %42 = phi i64 [%28, %$13], [%48, %$19] ; # Tail
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$20, label %$19
$19:
  %45 = phi i64 [%42, %$18] ; # Tail
  %46 = inttoptr i64 %45 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
  br label %$18
$20:
  %49 = phi i64 [%42, %$18] ; # Tail
; # (push 0 (name @))
  %50 = alloca i64, i64 2, align 16
  store i64 0, i64* %50
  %51 = getelementptr i64, i64* %50, i32 1
  store i64 %49, i64* %51
; # (while (symByte Q) (byteSym @ P))
  br label %$21
$21:
  %52 = phi i64 [%41, %$20], [%55, %$22] ; # X
; # (symByte Q)
  %53 = call i8 @symByte(i64* %50)
  %54 = icmp ne i8 %53, 0
  br i1 %54, label %$22, label %$23
$22:
  %55 = phi i64 [%52, %$21] ; # X
; # (byteSym @ P)
  call void @byteSym(i8 %53, i64* %1)
  br label %$21
$23:
  %56 = phi i64 [%52, %$21] ; # X
  br label %$9
$9:
  %57 = phi i64 [%18, %$3], [%23, %$12], [%31, %$17], [%56, %$23] ; # X
  ret void
}

define i64 @chopExtNm(i64) align 8 {
$1:
; # (let (R (link (push $Nil NIL)) N (objId Name)) (loop (let A (+ (&...
; # (push $Nil NIL)
  %1 = alloca i64, i64 2, align 16
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 %2 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %3
; # (link (push $Nil NIL))
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = inttoptr i64 %2 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  store i64 %5, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %2, i64* %8
; # (objId Name)
  %9 = call i64 @objId(i64 %0)
; # (loop (let A (+ (& N 7) (char "0")) (when (setq N (shr N 3)) (set...
  br label %$2
$2:
  %10 = phi i64 [%9, %$1], [%42, %$7] ; # N
; # (let A (+ (& N 7) (char "0")) (when (setq N (shr N 3)) (setq A (|...
; # (& N 7)
  %11 = and i64 %10, 7
; # (+ (& N 7) (char "0"))
  %12 = add i64 %11, 48
; # (when (setq N (shr N 3)) (setq A (| (shl A 8) (+ (& N 7) (char "0...
; # (shr N 3)
  %13 = lshr i64 %10, 3
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$3, label %$4
$3:
  %15 = phi i64 [%13, %$2] ; # N
  %16 = phi i64 [%12, %$2] ; # A
; # (shl A 8)
  %17 = shl i64 %16, 8
; # (& N 7)
  %18 = and i64 %15, 7
; # (+ (& N 7) (char "0"))
  %19 = add i64 %18, 48
; # (| (shl A 8) (+ (& N 7) (char "0")))
  %20 = or i64 %17, %19
; # (when (setq N (shr N 3)) (setq A (| (shl A 8) (+ (& N 7) (char "0...
; # (shr N 3)
  %21 = lshr i64 %15, 3
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$5, label %$6
$5:
  %23 = phi i64 [%21, %$3] ; # N
  %24 = phi i64 [%20, %$3] ; # A
; # (shl A 8)
  %25 = shl i64 %24, 8
; # (& N 7)
  %26 = and i64 %23, 7
; # (+ (& N 7) (char "0"))
  %27 = add i64 %26, 48
; # (| (shl A 8) (+ (& N 7) (char "0")))
  %28 = or i64 %25, %27
  br label %$6
$6:
  %29 = phi i64 [%21, %$3], [%23, %$5] ; # N
  %30 = phi i64 [%20, %$3], [%28, %$5] ; # A
  br label %$4
$4:
  %31 = phi i64 [%13, %$2], [%29, %$6] ; # N
  %32 = phi i64 [%12, %$2], [%30, %$6] ; # A
; # (set R (cons (consSym (cnt A) 0) (val R)))
; # (cnt A)
  %33 = shl i64 %32, 4
  %34 = or i64 %33, 2
; # (consSym (cnt A) 0)
  %35 = call i64 @consSym(i64 %34, i64 0)
; # (val R)
  %36 = inttoptr i64 %2 to i64*
  %37 = load i64, i64* %36
; # (cons (consSym (cnt A) 0) (val R))
  %38 = call i64 @cons(i64 %35, i64 %37)
  %39 = inttoptr i64 %2 to i64*
  store i64 %38, i64* %39
; # (? (=0 (setq N (shr N 3))))
; # (shr N 3)
  %40 = lshr i64 %31, 3
; # (=0 (setq N (shr N 3)))
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %$8, label %$7
$7:
  %42 = phi i64 [%40, %$4] ; # N
  br label %$2
$8:
  %43 = phi i64 [%40, %$4] ; # N
  %44 = phi i64 [0, %$4] ; # ->
; # (when (setq N (objFile Name)) (let F (i32 0) (loop (setq F (| F (...
; # (objFile Name)
  %45 = call i32 @objFile(i64 %0)
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %$9, label %$10
$9:
  %47 = phi i32 [%45, %$8] ; # N
; # (let F (i32 0) (loop (setq F (| F (+ (& N 15) (char "@")))) (? (=...
; # (i32 0)
; # (loop (setq F (| F (+ (& N 15) (char "@")))) (? (=0 (setq N (shr ...
  br label %$11
$11:
  %48 = phi i32 [%47, %$9], [%55, %$12] ; # N
  %49 = phi i32 [0, %$9], [%57, %$12] ; # F
; # (& N 15)
  %50 = and i32 %48, 15
; # (+ (& N 15) (char "@"))
  %51 = add i32 %50, 64
; # (| F (+ (& N 15) (char "@")))
  %52 = or i32 %49, %51
; # (? (=0 (setq N (shr N 4))))
; # (shr N 4)
  %53 = lshr i32 %48, 4
; # (=0 (setq N (shr N 4)))
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %$13, label %$12
$12:
  %55 = phi i32 [%53, %$11] ; # N
  %56 = phi i32 [%52, %$11] ; # F
; # (shl F 8)
  %57 = shl i32 %56, 8
  br label %$11
$13:
  %58 = phi i32 [%53, %$11] ; # N
  %59 = phi i32 [%52, %$11] ; # F
  %60 = phi i64 [0, %$11] ; # ->
; # (set R (cons (consStr (cnt (i64 F))) (val R)))
; # (i64 F)
  %61 = sext i32 %59 to i64
; # (cnt (i64 F))
  %62 = shl i64 %61, 4
  %63 = or i64 %62, 2
; # (consStr (cnt (i64 F)))
  %64 = call i64 @consStr(i64 %63)
; # (val R)
  %65 = inttoptr i64 %2 to i64*
  %66 = load i64, i64* %65
; # (cons (consStr (cnt (i64 F))) (val R))
  %67 = call i64 @cons(i64 %64, i64 %66)
  %68 = inttoptr i64 %2 to i64*
  store i64 %67, i64* %68
  br label %$10
$10:
  %69 = phi i32 [%45, %$8], [%58, %$13] ; # N
; # (pop R)
  %70 = inttoptr i64 %2 to i64*
  %71 = load i64, i64* %70
  %72 = inttoptr i64 %2 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %74, i64* %75
  ret i64 %71
}

define i64 @cmpLong(i64, i64) align 8 {
$1:
; # (loop (? (sub (val (dig X)) (val (dig Y))) (if @@ -1 1)) (setq X ...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%60, %$18] ; # X
  %3 = phi i64 [%1, %$1], [%61, %$18] ; # Y
; # (? (sub (val (dig X)) (val (dig Y))) (if @@ -1 1))
; # (dig X)
  %4 = add i64 %2, -4
; # (val (dig X))
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (dig Y)
  %7 = add i64 %3, -4
; # (val (dig Y))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (sub (val (dig X)) (val (dig Y)))
  %10 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %6, i64 %9)
  %11 = extractvalue {i64, i1} %10, 1
  %12 = extractvalue {i64, i1} %10, 0
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$5, label %$3
$5:
  %14 = phi i64 [%2, %$2] ; # X
  %15 = phi i64 [%3, %$2] ; # Y
; # (if @@ -1 1)
  br i1 %11, label %$6, label %$7
$6:
  %16 = phi i64 [%14, %$5] ; # X
  %17 = phi i64 [%15, %$5] ; # Y
  br label %$8
$7:
  %18 = phi i64 [%14, %$5] ; # X
  %19 = phi i64 [%15, %$5] ; # Y
  br label %$8
$8:
  %20 = phi i64 [%16, %$6], [%18, %$7] ; # X
  %21 = phi i64 [%17, %$6], [%19, %$7] ; # Y
  %22 = phi i64 [-1, %$6], [1, %$7] ; # ->
  br label %$4
$3:
  %23 = phi i64 [%2, %$2] ; # X
  %24 = phi i64 [%3, %$2] ; # Y
; # (big X)
  %25 = add i64 %23, 4
; # (val (big X))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (big Y)
  %28 = add i64 %24, 4
; # (val (big Y))
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (? (cnt? X) (cond ((big? Y) -1) ((== Y X) 0) ((> Y X) -1) (T 1)))...
; # (cnt? X)
  %31 = and i64 %27, 2
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$10, label %$9
$10:
  %33 = phi i64 [%27, %$3] ; # X
  %34 = phi i64 [%30, %$3] ; # Y
; # (cond ((big? Y) -1) ((== Y X) 0) ((> Y X) -1) (T 1))
; # (big? Y)
  %35 = and i64 %34, 4
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  %37 = phi i64 [%33, %$10] ; # X
  %38 = phi i64 [%34, %$10] ; # Y
  br label %$11
$12:
  %39 = phi i64 [%33, %$10] ; # X
  %40 = phi i64 [%34, %$10] ; # Y
; # (== Y X)
  %41 = icmp eq i64 %40, %39
  br i1 %41, label %$15, label %$14
$15:
  %42 = phi i64 [%39, %$12] ; # X
  %43 = phi i64 [%40, %$12] ; # Y
  br label %$11
$14:
  %44 = phi i64 [%39, %$12] ; # X
  %45 = phi i64 [%40, %$12] ; # Y
; # (> Y X)
  %46 = icmp ugt i64 %45, %44
  br i1 %46, label %$17, label %$16
$17:
  %47 = phi i64 [%44, %$14] ; # X
  %48 = phi i64 [%45, %$14] ; # Y
  br label %$11
$16:
  %49 = phi i64 [%44, %$14] ; # X
  %50 = phi i64 [%45, %$14] ; # Y
  br label %$11
$11:
  %51 = phi i64 [%37, %$13], [%42, %$15], [%47, %$17], [%49, %$16] ; # X
  %52 = phi i64 [%38, %$13], [%43, %$15], [%48, %$17], [%50, %$16] ; # Y
  %53 = phi i64 [-1, %$13], [0, %$15], [-1, %$17], [1, %$16] ; # ->
  br label %$4
$9:
  %54 = phi i64 [%27, %$3] ; # X
  %55 = phi i64 [%30, %$3] ; # Y
; # (? (cnt? Y) 1)
; # (cnt? Y)
  %56 = and i64 %55, 2
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$19, label %$18
$19:
  %58 = phi i64 [%54, %$9] ; # X
  %59 = phi i64 [%55, %$9] ; # Y
  br label %$4
$18:
  %60 = phi i64 [%54, %$9] ; # X
  %61 = phi i64 [%55, %$9] ; # Y
  br label %$2
$4:
  %62 = phi i64 [%20, %$8], [%51, %$11], [%58, %$19] ; # X
  %63 = phi i64 [%21, %$8], [%52, %$11], [%59, %$19] ; # Y
  %64 = phi i64 [%22, %$8], [%53, %$11], [1, %$19] ; # ->
  ret i64 %64
}

define i64 @isIntern(i64, i64) align 8 {
$1:
; # (if (cnt? Name) (let X (car Tree) (loop (? (atom X) 0) (let (S (c...
; # (cnt? Name)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (let X (car Tree) (loop (? (atom X) 0) (let (S (car X) Nm (name (...
; # (car Tree)
  %4 = inttoptr i64 %1 to i64*
  %5 = load i64, i64* %4
; # (loop (? (atom X) 0) (let (S (car X) Nm (name (val (tail S)))) (?...
  br label %$5
$5:
  %6 = phi i64 [%5, %$2], [%42, %$16] ; # X
; # (? (atom X) 0)
; # (atom X)
  %7 = and i64 %6, 15
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$8, label %$6
$8:
  %9 = phi i64 [%6, %$5] ; # X
  br label %$7
$6:
  %10 = phi i64 [%6, %$5] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) S) (set...
; # (car X)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (tail S)
  %13 = add i64 %12, -8
; # (val (tail S))
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
; # (name (val (tail S)))
  br label %$9
$9:
  %16 = phi i64 [%15, %$6], [%22, %$10] ; # Tail
  %17 = and i64 %16, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$10:
  %19 = phi i64 [%16, %$9] ; # Tail
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
  br label %$9
$11:
  %23 = phi i64 [%16, %$9] ; # Tail
; # (? (== Name Nm) S)
; # (== Name Nm)
  %24 = icmp eq i64 %0, %23
  br i1 %24, label %$13, label %$12
$13:
  %25 = phi i64 [%10, %$11] ; # X
  br label %$7
$12:
  %26 = phi i64 [%10, %$11] ; # X
; # (if (> Name Nm) (cddr X) (cadr X))
; # (> Name Nm)
  %27 = icmp ugt i64 %0, %23
  br i1 %27, label %$14, label %$15
$14:
  %28 = phi i64 [%26, %$12] ; # X
; # (cddr X)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
  br label %$16
$15:
  %35 = phi i64 [%26, %$12] ; # X
; # (cadr X)
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  br label %$16
$16:
  %41 = phi i64 [%28, %$14], [%35, %$15] ; # X
  %42 = phi i64 [%34, %$14], [%40, %$15] ; # ->
  br label %$5
$7:
  %43 = phi i64 [%9, %$8], [%25, %$13] ; # X
  %44 = phi i64 [0, %$8], [%12, %$13] ; # ->
  br label %$4
$3:
; # (let X (cdr Tree) (loop (? (atom X) 0) (let (S (car X) Nm (name (...
; # (cdr Tree)
  %45 = inttoptr i64 %1 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (loop (? (atom X) 0) (let (S (car X) Nm (name (val (tail S)))) (?...
  br label %$17
$17:
  %48 = phi i64 [%47, %$3], [%85, %$28] ; # X
; # (? (atom X) 0)
; # (atom X)
  %49 = and i64 %48, 15
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$20, label %$18
$20:
  %51 = phi i64 [%48, %$17] ; # X
  br label %$19
$18:
  %52 = phi i64 [%48, %$17] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (=0 (cmpLong Nm Name...
; # (car X)
  %53 = inttoptr i64 %52 to i64*
  %54 = load i64, i64* %53
; # (tail S)
  %55 = add i64 %54, -8
; # (val (tail S))
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
; # (name (val (tail S)))
  br label %$21
$21:
  %58 = phi i64 [%57, %$18], [%64, %$22] ; # Tail
  %59 = and i64 %58, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$23, label %$22
$22:
  %61 = phi i64 [%58, %$21] ; # Tail
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  br label %$21
$23:
  %65 = phi i64 [%58, %$21] ; # Tail
; # (? (=0 (cmpLong Nm Name)) S)
; # (cmpLong Nm Name)
  %66 = call i64 @cmpLong(i64 %65, i64 %0)
; # (=0 (cmpLong Nm Name))
  %67 = icmp eq i64 %66, 0
  br i1 %67, label %$25, label %$24
$25:
  %68 = phi i64 [%52, %$23] ; # X
  br label %$19
$24:
  %69 = phi i64 [%52, %$23] ; # X
; # (if (lt0 @) (cddr X) (cadr X))
; # (lt0 @)
  %70 = icmp slt i64 %66, 0
  br i1 %70, label %$26, label %$27
$26:
  %71 = phi i64 [%69, %$24] ; # X
; # (cddr X)
  %72 = inttoptr i64 %71 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
  %75 = inttoptr i64 %74 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
  br label %$28
$27:
  %78 = phi i64 [%69, %$24] ; # X
; # (cadr X)
  %79 = inttoptr i64 %78 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %81 to i64*
  %83 = load i64, i64* %82
  br label %$28
$28:
  %84 = phi i64 [%71, %$26], [%78, %$27] ; # X
  %85 = phi i64 [%77, %$26], [%83, %$27] ; # ->
  br label %$17
$19:
  %86 = phi i64 [%51, %$20], [%68, %$25] ; # X
  %87 = phi i64 [0, %$20], [%54, %$25] ; # ->
  br label %$4
$4:
  %88 = phi i64 [%44, %$7], [%87, %$19] ; # ->
  ret i64 %88
}

define i64 @isLstIntern(i64, i64) align 8 {
$1:
; # (loop (? (atom Lst) 0) (? (isIntern Name (cdar (car Lst))) @) (sh...
  br label %$2
$2:
  %2 = phi i64 [%1, %$1], [%20, %$6] ; # Lst
; # (? (atom Lst) 0)
; # (atom Lst)
  %3 = and i64 %2, 15
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$5, label %$3
$5:
  %5 = phi i64 [%2, %$2] ; # Lst
  br label %$4
$3:
  %6 = phi i64 [%2, %$2] ; # Lst
; # (? (isIntern Name (cdar (car Lst))) @)
; # (car Lst)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (cdar (car Lst))
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
; # (isIntern Name (cdar (car Lst)))
  %14 = call i64 @isIntern(i64 %0, i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  %16 = phi i64 [%6, %$3] ; # Lst
  br label %$4
$6:
  %17 = phi i64 [%6, %$3] ; # Lst
; # (shift Lst)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  br label %$2
$4:
  %21 = phi i64 [%5, %$5], [%16, %$7] ; # Lst
  %22 = phi i64 [0, %$5], [%14, %$7] ; # ->
  ret i64 %22
}

define i1 @findSym(i64, i64, i64) align 8 {
$1:
; # (loop (? (atom Lst) NO) (? (== Sym (isIntern Name (cdar (car Lst)...
  br label %$2
$2:
  %3 = phi i64 [%2, %$1], [%21, %$6] ; # Lst
; # (? (atom Lst) NO)
; # (atom Lst)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$5, label %$3
$5:
  %6 = phi i64 [%3, %$2] ; # Lst
  br label %$4
$3:
  %7 = phi i64 [%3, %$2] ; # Lst
; # (? (== Sym (isIntern Name (cdar (car Lst)))) YES)
; # (car Lst)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (cdar (car Lst))
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
  %12 = inttoptr i64 %11 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  %14 = load i64, i64* %13
; # (isIntern Name (cdar (car Lst)))
  %15 = call i64 @isIntern(i64 %1, i64 %14)
; # (== Sym (isIntern Name (cdar (car Lst))))
  %16 = icmp eq i64 %0, %15
  br i1 %16, label %$7, label %$6
$7:
  %17 = phi i64 [%7, %$3] ; # Lst
  br label %$4
$6:
  %18 = phi i64 [%7, %$3] ; # Lst
; # (shift Lst)
  %19 = inttoptr i64 %18 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
  br label %$2
$4:
  %22 = phi i64 [%6, %$5], [%17, %$7] ; # Lst
  %23 = phi i1 [0, %$5], [1, %$7] ; # ->
  ret i1 %23
}

define i64 @intern(i64, i64, i64, i64, i64, i1) align 8 {
$1:
; # (if (cnt? Name) (let X (car Tree) (if (pair X) (loop (let (S (car...
; # (cnt? Name)
  %6 = and i64 %2, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$2, label %$3
$2:
; # (let X (car Tree) (if (pair X) (loop (let (S (car X) Nm (name (va...
; # (car Tree)
  %8 = inttoptr i64 %3 to i64*
  %9 = load i64, i64* %8
; # (if (pair X) (loop (let (S (car X) Nm (name (val (tail S)))) (? (...
; # (pair X)
  %10 = and i64 %9, 15
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$5, label %$6
$5:
  %12 = phi i64 [%9, %$2] ; # X
; # (loop (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) (...
  br label %$8
$8:
  %13 = phi i64 [%12, %$5], [%126, %$18] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) (if Rpl...
; # (car X)
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
; # (tail S)
  %16 = add i64 %15, -8
; # (val (tail S))
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
; # (name (val (tail S)))
  br label %$9
$9:
  %19 = phi i64 [%18, %$8], [%25, %$10] ; # Tail
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$10
$10:
  %22 = phi i64 [%19, %$9] ; # Tail
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
  br label %$9
$11:
  %26 = phi i64 [%19, %$9] ; # Tail
; # (? (== Name Nm) (if Rpl (set X Sym) S))
; # (== Name Nm)
  %27 = icmp eq i64 %2, %26
  br i1 %27, label %$14, label %$12
$14:
  %28 = phi i64 [%13, %$11] ; # X
; # (if Rpl (set X Sym) S)
  br i1 %5, label %$15, label %$16
$15:
  %29 = phi i64 [%28, %$14] ; # X
; # (set X Sym)
  %30 = inttoptr i64 %29 to i64*
  store i64 %0, i64* %30
  br label %$17
$16:
  %31 = phi i64 [%28, %$14] ; # X
  br label %$17
$17:
  %32 = phi i64 [%29, %$15], [%31, %$16] ; # X
  %33 = phi i64 [%0, %$15], [%15, %$16] ; # ->
  br label %$13
$12:
  %34 = phi i64 [%13, %$11] ; # X
; # (let Y (cdr X) (cond ((> Name Nm) (? (atom Y) (internRight Sym Va...
; # (cdr X)
  %35 = inttoptr i64 %34 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
; # (cond ((> Name Nm) (? (atom Y) (internRight Sym Val Name X More))...
; # (> Name Nm)
  %38 = icmp ugt i64 %2, %26
  br i1 %38, label %$20, label %$19
$20:
  %39 = phi i64 [%34, %$12] ; # X
  %40 = phi i64 [%37, %$12] ; # Y
; # (? (atom Y) (internRight Sym Val Name X More))
; # (atom Y)
  %41 = and i64 %40, 15
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$22, label %$21
$22:
  %43 = phi i64 [%39, %$20] ; # X
  %44 = phi i64 [%40, %$20] ; # Y
; # (internRight Sym Val Name X More)
  %45 = call i64 @isLstIntern(i64 %2, i64 %4)
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$23, label %$24
$23:
  %47 = phi i64 [%0, %$22] ; # Sym
  br label %$25
$24:
  %48 = phi i64 [%0, %$22] ; # Sym
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$27, label %$26
$26:
  %50 = phi i64 [%48, %$24] ; # Sym
  %51 = call i64 @consSym(i64 %2, i64 %1)
  br label %$27
$27:
  %52 = phi i64 [%48, %$24], [%51, %$26] ; # Sym
  %53 = call i64 @cons(i64 %52, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %54 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %53)
  %55 = inttoptr i64 %43 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  store i64 %54, i64* %56
  br label %$25
$25:
  %57 = phi i64 [%47, %$23], [%52, %$27] ; # Sym
  %58 = phi i64 [%45, %$23], [%52, %$27] ; # ->
  br label %$13
$21:
  %59 = phi i64 [%39, %$20] ; # X
  %60 = phi i64 [%40, %$20] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (intern2 Sym Val Name X More)...
; # (cdr (setq X Y))
  %61 = inttoptr i64 %60 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
; # (atom (setq Y (cdr (setq X Y))))
  %64 = and i64 %63, 15
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$29, label %$28
$29:
  %66 = phi i64 [%60, %$21] ; # X
  %67 = phi i64 [%63, %$21] ; # Y
; # (intern2 Sym Val Name X More)
  %68 = call i64 @isLstIntern(i64 %2, i64 %4)
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$30, label %$31
$30:
  %70 = phi i64 [%0, %$29] ; # Sym
  br label %$32
$31:
  %71 = phi i64 [%0, %$29] ; # Sym
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$34, label %$33
$33:
  %73 = phi i64 [%71, %$31] ; # Sym
  %74 = call i64 @consSym(i64 %2, i64 %1)
  br label %$34
$34:
  %75 = phi i64 [%71, %$31], [%74, %$33] ; # Sym
  %76 = call i64 @cons(i64 %75, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %77 = inttoptr i64 %66 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  br label %$32
$32:
  %79 = phi i64 [%70, %$30], [%75, %$34] ; # Sym
  %80 = phi i64 [%68, %$30], [%75, %$34] ; # ->
  br label %$13
$28:
  %81 = phi i64 [%60, %$21] ; # X
  %82 = phi i64 [%63, %$21] ; # Y
  br label %$18
$19:
  %83 = phi i64 [%34, %$12] ; # X
  %84 = phi i64 [%37, %$12] ; # Y
; # (? (atom Y) (internLeft Sym Val Name X More))
; # (atom Y)
  %85 = and i64 %84, 15
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$36, label %$35
$36:
  %87 = phi i64 [%83, %$19] ; # X
  %88 = phi i64 [%84, %$19] ; # Y
; # (internLeft Sym Val Name X More)
  %89 = call i64 @isLstIntern(i64 %2, i64 %4)
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$37, label %$38
$37:
  %91 = phi i64 [%0, %$36] ; # Sym
  br label %$39
$38:
  %92 = phi i64 [%0, %$36] ; # Sym
  %93 = icmp ne i64 %92, 0
  br i1 %93, label %$41, label %$40
$40:
  %94 = phi i64 [%92, %$38] ; # Sym
  %95 = call i64 @consSym(i64 %2, i64 %1)
  br label %$41
$41:
  %96 = phi i64 [%92, %$38], [%95, %$40] ; # Sym
  %97 = call i64 @cons(i64 %96, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %98 = call i64 @cons(i64 %97, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %99 = inttoptr i64 %87 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  store i64 %98, i64* %100
  br label %$39
$39:
  %101 = phi i64 [%91, %$37], [%96, %$41] ; # Sym
  %102 = phi i64 [%89, %$37], [%96, %$41] ; # ->
  br label %$13
$35:
  %103 = phi i64 [%83, %$19] ; # X
  %104 = phi i64 [%84, %$19] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (intern1 Sym Val Name X More)...
; # (car (setq X Y))
  %105 = inttoptr i64 %104 to i64*
  %106 = load i64, i64* %105
; # (atom (setq Y (car (setq X Y))))
  %107 = and i64 %106, 15
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$43, label %$42
$43:
  %109 = phi i64 [%104, %$35] ; # X
  %110 = phi i64 [%106, %$35] ; # Y
; # (intern1 Sym Val Name X More)
  %111 = call i64 @isLstIntern(i64 %2, i64 %4)
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$44, label %$45
$44:
  %113 = phi i64 [%0, %$43] ; # Sym
  br label %$46
$45:
  %114 = phi i64 [%0, %$43] ; # Sym
  %115 = icmp ne i64 %114, 0
  br i1 %115, label %$48, label %$47
$47:
  %116 = phi i64 [%114, %$45] ; # Sym
  %117 = call i64 @consSym(i64 %2, i64 %1)
  br label %$48
$48:
  %118 = phi i64 [%114, %$45], [%117, %$47] ; # Sym
  %119 = call i64 @cons(i64 %118, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %120 = inttoptr i64 %109 to i64*
  store i64 %119, i64* %120
  br label %$46
$46:
  %121 = phi i64 [%113, %$44], [%118, %$48] ; # Sym
  %122 = phi i64 [%111, %$44], [%118, %$48] ; # ->
  br label %$13
$42:
  %123 = phi i64 [%104, %$35] ; # X
  %124 = phi i64 [%106, %$35] ; # Y
  br label %$18
$18:
  %125 = phi i64 [%81, %$28], [%123, %$42] ; # X
  %126 = phi i64 [%82, %$28], [%124, %$42] ; # Y
  br label %$8
$13:
  %127 = phi i64 [%32, %$17], [%43, %$25], [%66, %$32], [%87, %$39], [%109, %$46] ; # X
  %128 = phi i64 [%33, %$17], [%58, %$25], [%80, %$32], [%102, %$39], [%122, %$46] ; # ->
  br label %$7
$6:
  %129 = phi i64 [%9, %$2] ; # X
; # (intern1 Sym Val Name Tree More)
  %130 = call i64 @isLstIntern(i64 %2, i64 %4)
  %131 = icmp ne i64 %130, 0
  br i1 %131, label %$49, label %$50
$49:
  %132 = phi i64 [%0, %$6] ; # Sym
  br label %$51
$50:
  %133 = phi i64 [%0, %$6] ; # Sym
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$53, label %$52
$52:
  %135 = phi i64 [%133, %$50] ; # Sym
  %136 = call i64 @consSym(i64 %2, i64 %1)
  br label %$53
$53:
  %137 = phi i64 [%133, %$50], [%136, %$52] ; # Sym
  %138 = call i64 @cons(i64 %137, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %139 = inttoptr i64 %3 to i64*
  store i64 %138, i64* %139
  br label %$51
$51:
  %140 = phi i64 [%132, %$49], [%137, %$53] ; # Sym
  %141 = phi i64 [%130, %$49], [%137, %$53] ; # ->
  br label %$7
$7:
  %142 = phi i64 [%127, %$13], [%129, %$51] ; # X
  %143 = phi i64 [%128, %$13], [%141, %$51] ; # ->
  br label %$4
$3:
; # (let X (cdr Tree) (if (pair X) (loop (let (S (car X) Nm (name (va...
; # (cdr Tree)
  %144 = inttoptr i64 %3 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (if (pair X) (loop (let (S (car X) Nm (name (val (tail S)))) (? (...
; # (pair X)
  %147 = and i64 %146, 15
  %148 = icmp eq i64 %147, 0
  br i1 %148, label %$54, label %$55
$54:
  %149 = phi i64 [%146, %$3] ; # X
; # (loop (let (S (car X) Nm (name (val (tail S)))) (? (=0 (cmpLong N...
  br label %$57
$57:
  %150 = phi i64 [%149, %$54], [%264, %$67] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (=0 (cmpLong Nm Name...
; # (car X)
  %151 = inttoptr i64 %150 to i64*
  %152 = load i64, i64* %151
; # (tail S)
  %153 = add i64 %152, -8
; # (val (tail S))
  %154 = inttoptr i64 %153 to i64*
  %155 = load i64, i64* %154
; # (name (val (tail S)))
  br label %$58
$58:
  %156 = phi i64 [%155, %$57], [%162, %$59] ; # Tail
  %157 = and i64 %156, 6
  %158 = icmp ne i64 %157, 0
  br i1 %158, label %$60, label %$59
$59:
  %159 = phi i64 [%156, %$58] ; # Tail
  %160 = inttoptr i64 %159 to i64*
  %161 = getelementptr i64, i64* %160, i32 1
  %162 = load i64, i64* %161
  br label %$58
$60:
  %163 = phi i64 [%156, %$58] ; # Tail
; # (? (=0 (cmpLong Nm Name)) (if Rpl (set X Sym) S))
; # (cmpLong Nm Name)
  %164 = call i64 @cmpLong(i64 %163, i64 %2)
; # (=0 (cmpLong Nm Name))
  %165 = icmp eq i64 %164, 0
  br i1 %165, label %$63, label %$61
$63:
  %166 = phi i64 [%150, %$60] ; # X
; # (if Rpl (set X Sym) S)
  br i1 %5, label %$64, label %$65
$64:
  %167 = phi i64 [%166, %$63] ; # X
; # (set X Sym)
  %168 = inttoptr i64 %167 to i64*
  store i64 %0, i64* %168
  br label %$66
$65:
  %169 = phi i64 [%166, %$63] ; # X
  br label %$66
$66:
  %170 = phi i64 [%167, %$64], [%169, %$65] ; # X
  %171 = phi i64 [%0, %$64], [%152, %$65] ; # ->
  br label %$62
$61:
  %172 = phi i64 [%150, %$60] ; # X
; # (let Y (cdr X) (cond ((lt0 @) (? (atom Y) (internRight Sym Val Na...
; # (cdr X)
  %173 = inttoptr i64 %172 to i64*
  %174 = getelementptr i64, i64* %173, i32 1
  %175 = load i64, i64* %174
; # (cond ((lt0 @) (? (atom Y) (internRight Sym Val Name X More)) (? ...
; # (lt0 @)
  %176 = icmp slt i64 %164, 0
  br i1 %176, label %$69, label %$68
$69:
  %177 = phi i64 [%172, %$61] ; # X
  %178 = phi i64 [%175, %$61] ; # Y
; # (? (atom Y) (internRight Sym Val Name X More))
; # (atom Y)
  %179 = and i64 %178, 15
  %180 = icmp ne i64 %179, 0
  br i1 %180, label %$71, label %$70
$71:
  %181 = phi i64 [%177, %$69] ; # X
  %182 = phi i64 [%178, %$69] ; # Y
; # (internRight Sym Val Name X More)
  %183 = call i64 @isLstIntern(i64 %2, i64 %4)
  %184 = icmp ne i64 %183, 0
  br i1 %184, label %$72, label %$73
$72:
  %185 = phi i64 [%0, %$71] ; # Sym
  br label %$74
$73:
  %186 = phi i64 [%0, %$71] ; # Sym
  %187 = icmp ne i64 %186, 0
  br i1 %187, label %$76, label %$75
$75:
  %188 = phi i64 [%186, %$73] ; # Sym
  %189 = call i64 @consSym(i64 %2, i64 %1)
  br label %$76
$76:
  %190 = phi i64 [%186, %$73], [%189, %$75] ; # Sym
  %191 = call i64 @cons(i64 %190, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %192 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %191)
  %193 = inttoptr i64 %181 to i64*
  %194 = getelementptr i64, i64* %193, i32 1
  store i64 %192, i64* %194
  br label %$74
$74:
  %195 = phi i64 [%185, %$72], [%190, %$76] ; # Sym
  %196 = phi i64 [%183, %$72], [%190, %$76] ; # ->
  br label %$62
$70:
  %197 = phi i64 [%177, %$69] ; # X
  %198 = phi i64 [%178, %$69] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (intern2 Sym Val Name X More)...
; # (cdr (setq X Y))
  %199 = inttoptr i64 %198 to i64*
  %200 = getelementptr i64, i64* %199, i32 1
  %201 = load i64, i64* %200
; # (atom (setq Y (cdr (setq X Y))))
  %202 = and i64 %201, 15
  %203 = icmp ne i64 %202, 0
  br i1 %203, label %$78, label %$77
$78:
  %204 = phi i64 [%198, %$70] ; # X
  %205 = phi i64 [%201, %$70] ; # Y
; # (intern2 Sym Val Name X More)
  %206 = call i64 @isLstIntern(i64 %2, i64 %4)
  %207 = icmp ne i64 %206, 0
  br i1 %207, label %$79, label %$80
$79:
  %208 = phi i64 [%0, %$78] ; # Sym
  br label %$81
$80:
  %209 = phi i64 [%0, %$78] ; # Sym
  %210 = icmp ne i64 %209, 0
  br i1 %210, label %$83, label %$82
$82:
  %211 = phi i64 [%209, %$80] ; # Sym
  %212 = call i64 @consSym(i64 %2, i64 %1)
  br label %$83
$83:
  %213 = phi i64 [%209, %$80], [%212, %$82] ; # Sym
  %214 = call i64 @cons(i64 %213, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %215 = inttoptr i64 %204 to i64*
  %216 = getelementptr i64, i64* %215, i32 1
  store i64 %214, i64* %216
  br label %$81
$81:
  %217 = phi i64 [%208, %$79], [%213, %$83] ; # Sym
  %218 = phi i64 [%206, %$79], [%213, %$83] ; # ->
  br label %$62
$77:
  %219 = phi i64 [%198, %$70] ; # X
  %220 = phi i64 [%201, %$70] ; # Y
  br label %$67
$68:
  %221 = phi i64 [%172, %$61] ; # X
  %222 = phi i64 [%175, %$61] ; # Y
; # (? (atom Y) (internLeft Sym Val Name X More))
; # (atom Y)
  %223 = and i64 %222, 15
  %224 = icmp ne i64 %223, 0
  br i1 %224, label %$85, label %$84
$85:
  %225 = phi i64 [%221, %$68] ; # X
  %226 = phi i64 [%222, %$68] ; # Y
; # (internLeft Sym Val Name X More)
  %227 = call i64 @isLstIntern(i64 %2, i64 %4)
  %228 = icmp ne i64 %227, 0
  br i1 %228, label %$86, label %$87
$86:
  %229 = phi i64 [%0, %$85] ; # Sym
  br label %$88
$87:
  %230 = phi i64 [%0, %$85] ; # Sym
  %231 = icmp ne i64 %230, 0
  br i1 %231, label %$90, label %$89
$89:
  %232 = phi i64 [%230, %$87] ; # Sym
  %233 = call i64 @consSym(i64 %2, i64 %1)
  br label %$90
$90:
  %234 = phi i64 [%230, %$87], [%233, %$89] ; # Sym
  %235 = call i64 @cons(i64 %234, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %236 = call i64 @cons(i64 %235, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %237 = inttoptr i64 %225 to i64*
  %238 = getelementptr i64, i64* %237, i32 1
  store i64 %236, i64* %238
  br label %$88
$88:
  %239 = phi i64 [%229, %$86], [%234, %$90] ; # Sym
  %240 = phi i64 [%227, %$86], [%234, %$90] ; # ->
  br label %$62
$84:
  %241 = phi i64 [%221, %$68] ; # X
  %242 = phi i64 [%222, %$68] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (intern1 Sym Val Name X More)...
; # (car (setq X Y))
  %243 = inttoptr i64 %242 to i64*
  %244 = load i64, i64* %243
; # (atom (setq Y (car (setq X Y))))
  %245 = and i64 %244, 15
  %246 = icmp ne i64 %245, 0
  br i1 %246, label %$92, label %$91
$92:
  %247 = phi i64 [%242, %$84] ; # X
  %248 = phi i64 [%244, %$84] ; # Y
; # (intern1 Sym Val Name X More)
  %249 = call i64 @isLstIntern(i64 %2, i64 %4)
  %250 = icmp ne i64 %249, 0
  br i1 %250, label %$93, label %$94
$93:
  %251 = phi i64 [%0, %$92] ; # Sym
  br label %$95
$94:
  %252 = phi i64 [%0, %$92] ; # Sym
  %253 = icmp ne i64 %252, 0
  br i1 %253, label %$97, label %$96
$96:
  %254 = phi i64 [%252, %$94] ; # Sym
  %255 = call i64 @consSym(i64 %2, i64 %1)
  br label %$97
$97:
  %256 = phi i64 [%252, %$94], [%255, %$96] ; # Sym
  %257 = call i64 @cons(i64 %256, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %258 = inttoptr i64 %247 to i64*
  store i64 %257, i64* %258
  br label %$95
$95:
  %259 = phi i64 [%251, %$93], [%256, %$97] ; # Sym
  %260 = phi i64 [%249, %$93], [%256, %$97] ; # ->
  br label %$62
$91:
  %261 = phi i64 [%242, %$84] ; # X
  %262 = phi i64 [%244, %$84] ; # Y
  br label %$67
$67:
  %263 = phi i64 [%219, %$77], [%261, %$91] ; # X
  %264 = phi i64 [%220, %$77], [%262, %$91] ; # Y
  br label %$57
$62:
  %265 = phi i64 [%170, %$66], [%181, %$74], [%204, %$81], [%225, %$88], [%247, %$95] ; # X
  %266 = phi i64 [%171, %$66], [%196, %$74], [%218, %$81], [%240, %$88], [%260, %$95] ; # ->
  br label %$56
$55:
  %267 = phi i64 [%146, %$3] ; # X
; # (intern2 Sym Val Name Tree More)
  %268 = call i64 @isLstIntern(i64 %2, i64 %4)
  %269 = icmp ne i64 %268, 0
  br i1 %269, label %$98, label %$99
$98:
  %270 = phi i64 [%0, %$55] ; # Sym
  br label %$100
$99:
  %271 = phi i64 [%0, %$55] ; # Sym
  %272 = icmp ne i64 %271, 0
  br i1 %272, label %$102, label %$101
$101:
  %273 = phi i64 [%271, %$99] ; # Sym
  %274 = call i64 @consSym(i64 %2, i64 %1)
  br label %$102
$102:
  %275 = phi i64 [%271, %$99], [%274, %$101] ; # Sym
  %276 = call i64 @cons(i64 %275, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %277 = inttoptr i64 %3 to i64*
  %278 = getelementptr i64, i64* %277, i32 1
  store i64 %276, i64* %278
  br label %$100
$100:
  %279 = phi i64 [%270, %$98], [%275, %$102] ; # Sym
  %280 = phi i64 [%268, %$98], [%275, %$102] ; # ->
  br label %$56
$56:
  %281 = phi i64 [%265, %$62], [%267, %$100] ; # X
  %282 = phi i64 [%266, %$62], [%280, %$100] ; # ->
  br label %$4
$4:
  %283 = phi i64 [%143, %$7], [%282, %$56] ; # ->
  ret i64 %283
}

define i64 @requestSym(i64) align 8 {
$1:
; # (if (isIntern Name $PrivT) @ (let L (val $Intern) (intern 0 $Nil ...
; # (isIntern Name $PrivT)
  %1 = call i64 @isIntern(i64 %0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64))
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let L (val $Intern) (intern 0 $Nil Name (cdar (car L)) (cdr L) N...
; # (val $Intern)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
; # (car L)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (cdar (car L))
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %8 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (cdr L)
  %12 = inttoptr i64 %4 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  %14 = load i64, i64* %13
; # (intern 0 $Nil Name (cdar (car L)) (cdr L) NO)
  %15 = call i64 @intern(i64 0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %0, i64 %11, i64 %14, i1 0)
  br label %$4
$4:
  %16 = phi i64 [%1, %$2], [%15, %$3] ; # ->
  ret i64 %16
}

define i64 @extern(i64) align 8 {
$1:
; # (need3)
  call void @need3()
; # (let (X (val $Extern) C 0 Sym T) (loop (inc 'C) (setq Sym (car X)...
; # (val $Extern)
  %1 = load i64, i64* @$Extern
; # (loop (inc 'C) (setq Sym (car X)) (let Nm (& (name (& (val (tail ...
  br label %$2
$2:
  %2 = phi i64 [%1, %$1], [%101, %$8] ; # X
  %3 = phi i64 [0, %$1], [%99, %$8] ; # C
; # (inc 'C)
  %4 = add i64 %3, 1
; # (car X)
  %5 = inttoptr i64 %2 to i64*
  %6 = load i64, i64* %5
; # (let Nm (& (name (& (val (tail Sym)) -9)) (hex "3FFFFFFFFFFFFFF7"...
; # (tail Sym)
  %7 = add i64 %6, -8
; # (val (tail Sym))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (& (val (tail Sym)) -9)
  %10 = and i64 %9, -9
; # (name (& (val (tail Sym)) -9))
  br label %$3
$3:
  %11 = phi i64 [%10, %$2], [%17, %$4] ; # Tail
  %12 = and i64 %11, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$5, label %$4
$4:
  %14 = phi i64 [%11, %$3] ; # Tail
  %15 = inttoptr i64 %14 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  br label %$3
$5:
  %18 = phi i64 [%11, %$3] ; # Tail
; # (& (name (& (val (tail Sym)) -9)) (hex "3FFFFFFFFFFFFFF7"))
  %19 = and i64 %18, 4611686018427387895
; # (? (== Nm Name))
; # (== Nm Name)
  %20 = icmp eq i64 %19, %0
  br i1 %20, label %$7, label %$6
$6:
  %21 = phi i64 [%2, %$5] ; # X
  %22 = phi i64 [%4, %$5] ; # C
  %23 = phi i64 [%6, %$5] ; # Sym
; # (let Y (cdr X) (cond ((> Name Nm) (? (atom Y) (set 2 X (cons $Nil...
; # (cdr X)
  %24 = inttoptr i64 %21 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (cond ((> Name Nm) (? (atom Y) (set 2 X (cons $Nil (cons (setq Sy...
; # (> Name Nm)
  %27 = icmp ugt i64 %0, %19
  br i1 %27, label %$10, label %$9
$10:
  %28 = phi i64 [%21, %$6] ; # X
  %29 = phi i64 [%22, %$6] ; # C
  %30 = phi i64 [%23, %$6] ; # Sym
  %31 = phi i64 [%26, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons $Nil (cons (setq Sym (consExt Name)) $...
; # (atom Y)
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = phi i64 [%28, %$10] ; # X
  %35 = phi i64 [%29, %$10] ; # C
  %36 = phi i64 [%30, %$10] ; # Sym
  %37 = phi i64 [%31, %$10] ; # Y
; # (set 2 X (cons $Nil (cons (setq Sym (consExt Name)) $Nil)))
; # (consExt Name)
  %38 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %39 = call i64 @cons(i64 %38, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Nil (cons (setq Sym (consExt Name)) $Nil))
  %40 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %39)
  %41 = inttoptr i64 %34 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  br label %$7
$11:
  %43 = phi i64 [%28, %$10] ; # X
  %44 = phi i64 [%29, %$10] ; # C
  %45 = phi i64 [%30, %$10] ; # Sym
  %46 = phi i64 [%31, %$10] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (set 2 X (cons (setq Sym (con...
; # (cdr (setq X Y))
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
; # (atom (setq Y (cdr (setq X Y))))
  %50 = and i64 %49, 15
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$14, label %$13
$14:
  %52 = phi i64 [%46, %$11] ; # X
  %53 = phi i64 [%44, %$11] ; # C
  %54 = phi i64 [%45, %$11] ; # Sym
  %55 = phi i64 [%49, %$11] ; # Y
; # (set 2 X (cons (setq Sym (consExt Name)) $Nil))
; # (consExt Name)
  %56 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %57 = call i64 @cons(i64 %56, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %58 = inttoptr i64 %52 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %57, i64* %59
  br label %$7
$13:
  %60 = phi i64 [%46, %$11] ; # X
  %61 = phi i64 [%44, %$11] ; # C
  %62 = phi i64 [%45, %$11] ; # Sym
  %63 = phi i64 [%49, %$11] ; # Y
  br label %$8
$9:
  %64 = phi i64 [%21, %$6] ; # X
  %65 = phi i64 [%22, %$6] ; # C
  %66 = phi i64 [%23, %$6] ; # Sym
  %67 = phi i64 [%26, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons (cons (setq Sym (consExt Name)) $Nil) ...
; # (atom Y)
  %68 = and i64 %67, 15
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$16, label %$15
$16:
  %70 = phi i64 [%64, %$9] ; # X
  %71 = phi i64 [%65, %$9] ; # C
  %72 = phi i64 [%66, %$9] ; # Sym
  %73 = phi i64 [%67, %$9] ; # Y
; # (set 2 X (cons (cons (setq Sym (consExt Name)) $Nil) $Nil))
; # (consExt Name)
  %74 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %75 = call i64 @cons(i64 %74, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cons (setq Sym (consExt Name)) $Nil) $Nil)
  %76 = call i64 @cons(i64 %75, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %77 = inttoptr i64 %70 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  br label %$7
$15:
  %79 = phi i64 [%64, %$9] ; # X
  %80 = phi i64 [%65, %$9] ; # C
  %81 = phi i64 [%66, %$9] ; # Sym
  %82 = phi i64 [%67, %$9] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (set X (cons (setq Sym (consE...
; # (car (setq X Y))
  %83 = inttoptr i64 %82 to i64*
  %84 = load i64, i64* %83
; # (atom (setq Y (car (setq X Y))))
  %85 = and i64 %84, 15
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$18, label %$17
$18:
  %87 = phi i64 [%82, %$15] ; # X
  %88 = phi i64 [%80, %$15] ; # C
  %89 = phi i64 [%81, %$15] ; # Sym
  %90 = phi i64 [%84, %$15] ; # Y
; # (set X (cons (setq Sym (consExt Name)) $Nil))
; # (consExt Name)
  %91 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %92 = call i64 @cons(i64 %91, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %93 = inttoptr i64 %87 to i64*
  store i64 %92, i64* %93
  br label %$7
$17:
  %94 = phi i64 [%82, %$15] ; # X
  %95 = phi i64 [%80, %$15] ; # C
  %96 = phi i64 [%81, %$15] ; # Sym
  %97 = phi i64 [%84, %$15] ; # Y
  br label %$8
$8:
  %98 = phi i64 [%60, %$13], [%94, %$17] ; # X
  %99 = phi i64 [%61, %$13], [%95, %$17] ; # C
  %100 = phi i64 [%62, %$13], [%96, %$17] ; # Sym
  %101 = phi i64 [%63, %$13], [%97, %$17] ; # Y
  br label %$2
$7:
  %102 = phi i64 [%2, %$5], [%34, %$12], [%52, %$14], [%70, %$16], [%87, %$18] ; # X
  %103 = phi i64 [%4, %$5], [%35, %$12], [%53, %$14], [%71, %$16], [%88, %$18] ; # C
  %104 = phi i64 [%6, %$5], [%38, %$12], [%56, %$14], [%74, %$16], [%91, %$18] ; # Sym
  %105 = phi i64 [0, %$5], [%40, %$12], [%57, %$14], [%76, %$16], [%92, %$18] ; # ->
; # (shr C 1)
  %106 = lshr i64 %103, 1
; # (when (> (shl 1 C) (val $ExtCnt)) (setq X (val $Extern)) (let N (...
; # (shl 1 C)
  %107 = shl i64 1, %106
; # (val $ExtCnt)
  %108 = load i64, i64* @$ExtCnt
; # (> (shl 1 C) (val $ExtCnt))
  %109 = icmp ugt i64 %107, %108
  br i1 %109, label %$19, label %$20
$19:
  %110 = phi i64 [%102, %$7] ; # X
  %111 = phi i64 [%106, %$7] ; # C
  %112 = phi i64 [%104, %$7] ; # Sym
; # (val $Extern)
  %113 = load i64, i64* @$Extern
; # (let N (val $ExtSkip) (if (> (inc 'N) C) (set $ExtSkip 0) (set $E...
; # (val $ExtSkip)
  %114 = load i64, i64* @$ExtSkip
; # (if (> (inc 'N) C) (set $ExtSkip 0) (set $ExtSkip N) (loop (setq ...
; # (inc 'N)
  %115 = add i64 %114, 1
; # (> (inc 'N) C)
  %116 = icmp ugt i64 %115, %111
  br i1 %116, label %$21, label %$22
$21:
  %117 = phi i64 [%113, %$19] ; # X
  %118 = phi i64 [%111, %$19] ; # C
  %119 = phi i64 [%112, %$19] ; # Sym
  %120 = phi i64 [%115, %$19] ; # N
; # (set $ExtSkip 0)
  store i64 0, i64* @$ExtSkip
  br label %$23
$22:
  %121 = phi i64 [%113, %$19] ; # X
  %122 = phi i64 [%111, %$19] ; # C
  %123 = phi i64 [%112, %$19] ; # Sym
  %124 = phi i64 [%115, %$19] ; # N
; # (set $ExtSkip N)
  store i64 %124, i64* @$ExtSkip
; # (loop (setq X (if (> Name (& (name (& (val (tail (++ X))) -9)) (h...
  br label %$24
$24:
  %125 = phi i64 [%121, %$22], [%167, %$31] ; # X
  %126 = phi i64 [%122, %$22], [%168, %$31] ; # C
  %127 = phi i64 [%123, %$22], [%169, %$31] ; # Sym
  %128 = phi i64 [%124, %$22], [%170, %$31] ; # N
; # (if (> Name (& (name (& (val (tail (++ X))) -9)) (hex "3FFFFFFFFF...
; # (++ X)
  %129 = inttoptr i64 %125 to i64*
  %130 = load i64, i64* %129
  %131 = getelementptr i64, i64* %129, i32 1
  %132 = load i64, i64* %131
; # (tail (++ X))
  %133 = add i64 %130, -8
; # (val (tail (++ X)))
  %134 = inttoptr i64 %133 to i64*
  %135 = load i64, i64* %134
; # (& (val (tail (++ X))) -9)
  %136 = and i64 %135, -9
; # (name (& (val (tail (++ X))) -9))
  br label %$25
$25:
  %137 = phi i64 [%136, %$24], [%143, %$26] ; # Tail
  %138 = and i64 %137, 6
  %139 = icmp ne i64 %138, 0
  br i1 %139, label %$27, label %$26
$26:
  %140 = phi i64 [%137, %$25] ; # Tail
  %141 = inttoptr i64 %140 to i64*
  %142 = getelementptr i64, i64* %141, i32 1
  %143 = load i64, i64* %142
  br label %$25
$27:
  %144 = phi i64 [%137, %$25] ; # Tail
; # (& (name (& (val (tail (++ X))) -9)) (hex "3FFFFFFFFFFFFFF7"))
  %145 = and i64 %144, 4611686018427387895
; # (> Name (& (name (& (val (tail (++ X))) -9)) (hex "3FFFFFFFFFFFFF...
  %146 = icmp ugt i64 %0, %145
  br i1 %146, label %$28, label %$29
$28:
  %147 = phi i64 [%132, %$27] ; # X
  %148 = phi i64 [%126, %$27] ; # C
  %149 = phi i64 [%127, %$27] ; # Sym
  %150 = phi i64 [%128, %$27] ; # N
; # (cdr X)
  %151 = inttoptr i64 %147 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  br label %$30
$29:
  %154 = phi i64 [%132, %$27] ; # X
  %155 = phi i64 [%126, %$27] ; # C
  %156 = phi i64 [%127, %$27] ; # Sym
  %157 = phi i64 [%128, %$27] ; # N
; # (car X)
  %158 = inttoptr i64 %154 to i64*
  %159 = load i64, i64* %158
  br label %$30
$30:
  %160 = phi i64 [%147, %$28], [%154, %$29] ; # X
  %161 = phi i64 [%148, %$28], [%155, %$29] ; # C
  %162 = phi i64 [%149, %$28], [%156, %$29] ; # Sym
  %163 = phi i64 [%150, %$28], [%157, %$29] ; # N
  %164 = phi i64 [%153, %$28], [%159, %$29] ; # ->
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %165 = sub i64 %161, 1
; # (=0 (dec 'C))
  %166 = icmp eq i64 %165, 0
  br i1 %166, label %$32, label %$31
$31:
  %167 = phi i64 [%164, %$30] ; # X
  %168 = phi i64 [%165, %$30] ; # C
  %169 = phi i64 [%162, %$30] ; # Sym
  %170 = phi i64 [%163, %$30] ; # N
  br label %$24
$32:
  %171 = phi i64 [%164, %$30] ; # X
  %172 = phi i64 [%165, %$30] ; # C
  %173 = phi i64 [%162, %$30] ; # Sym
  %174 = phi i64 [%163, %$30] ; # N
  %175 = phi i64 [0, %$30] ; # ->
  br label %$23
$23:
  %176 = phi i64 [%117, %$21], [%171, %$32] ; # X
  %177 = phi i64 [%118, %$21], [%172, %$32] ; # C
  %178 = phi i64 [%119, %$21], [%173, %$32] ; # Sym
  %179 = phi i64 [%120, %$21], [%174, %$32] ; # N
  %180 = phi i64 [0, %$21], [%175, %$32] ; # ->
; # (loop (let (Nm (& (name (& (val (tail (car X))) -9)) (hex "3FFFFF...
  br label %$33
$33:
  %181 = phi i64 [%176, %$23], [%282, %$41] ; # X
  %182 = phi i64 [%177, %$23], [%283, %$41] ; # C
  %183 = phi i64 [%178, %$23], [%284, %$41] ; # Sym
; # (let (Nm (& (name (& (val (tail (car X))) -9)) (hex "3FFFFFFFFFFF...
; # (car X)
  %184 = inttoptr i64 %181 to i64*
  %185 = load i64, i64* %184
; # (tail (car X))
  %186 = add i64 %185, -8
; # (val (tail (car X)))
  %187 = inttoptr i64 %186 to i64*
  %188 = load i64, i64* %187
; # (& (val (tail (car X))) -9)
  %189 = and i64 %188, -9
; # (name (& (val (tail (car X))) -9))
  br label %$34
$34:
  %190 = phi i64 [%189, %$33], [%196, %$35] ; # Tail
  %191 = and i64 %190, 6
  %192 = icmp ne i64 %191, 0
  br i1 %192, label %$36, label %$35
$35:
  %193 = phi i64 [%190, %$34] ; # Tail
  %194 = inttoptr i64 %193 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
  br label %$34
$36:
  %197 = phi i64 [%190, %$34] ; # Tail
; # (& (name (& (val (tail (car X))) -9)) (hex "3FFFFFFFFFFFFFF7"))
  %198 = and i64 %197, 4611686018427387895
; # (cdr X)
  %199 = inttoptr i64 %181 to i64*
  %200 = getelementptr i64, i64* %199, i32 1
  %201 = load i64, i64* %200
; # (? (== Nm Name))
; # (== Nm Name)
  %202 = icmp eq i64 %198, %0
  br i1 %202, label %$38, label %$37
$37:
  %203 = phi i64 [%181, %$36] ; # X
  %204 = phi i64 [%182, %$36] ; # C
  %205 = phi i64 [%183, %$36] ; # Sym
; # (if (> Name Nm) (let Z (cdr Y) (? (atom (cdr Z))) (xchg Z X) (set...
; # (> Name Nm)
  %206 = icmp ugt i64 %0, %198
  br i1 %206, label %$39, label %$40
$39:
  %207 = phi i64 [%203, %$37] ; # X
  %208 = phi i64 [%204, %$37] ; # C
  %209 = phi i64 [%205, %$37] ; # Sym
; # (let Z (cdr Y) (? (atom (cdr Z))) (xchg Z X) (setq Z (cdr Z) X (c...
; # (cdr Y)
  %210 = inttoptr i64 %201 to i64*
  %211 = getelementptr i64, i64* %210, i32 1
  %212 = load i64, i64* %211
; # (? (atom (cdr Z)))
; # (cdr Z)
  %213 = inttoptr i64 %212 to i64*
  %214 = getelementptr i64, i64* %213, i32 1
  %215 = load i64, i64* %214
; # (atom (cdr Z))
  %216 = and i64 %215, 15
  %217 = icmp ne i64 %216, 0
  br i1 %217, label %$38, label %$42
$42:
  %218 = phi i64 [%207, %$39] ; # X
  %219 = phi i64 [%208, %$39] ; # C
  %220 = phi i64 [%209, %$39] ; # Sym
  %221 = phi i64 [%212, %$39] ; # Z
; # (xchg Z X)
  %222 = inttoptr i64 %221 to i64*
  %223 = load i64, i64* %222
  %224 = inttoptr i64 %218 to i64*
  %225 = load i64, i64* %224
  store i64 %225, i64* %222
  store i64 %223, i64* %224
; # (cdr Z)
  %226 = inttoptr i64 %221 to i64*
  %227 = getelementptr i64, i64* %226, i32 1
  %228 = load i64, i64* %227
; # (cdr Z)
  %229 = inttoptr i64 %228 to i64*
  %230 = getelementptr i64, i64* %229, i32 1
  %231 = load i64, i64* %230
; # (set 2 Z (val Z) Z (val Y) Y (cdr Y) 2 Y X)
; # (val Z)
  %232 = inttoptr i64 %228 to i64*
  %233 = load i64, i64* %232
  %234 = inttoptr i64 %228 to i64*
  %235 = getelementptr i64, i64* %234, i32 1
  store i64 %233, i64* %235
; # (val Y)
  %236 = inttoptr i64 %201 to i64*
  %237 = load i64, i64* %236
  %238 = inttoptr i64 %228 to i64*
  store i64 %237, i64* %238
; # (cdr Y)
  %239 = inttoptr i64 %201 to i64*
  %240 = getelementptr i64, i64* %239, i32 1
  %241 = load i64, i64* %240
  %242 = inttoptr i64 %201 to i64*
  store i64 %241, i64* %242
  %243 = inttoptr i64 %201 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  store i64 %231, i64* %244
  br label %$41
$40:
  %245 = phi i64 [%203, %$37] ; # X
  %246 = phi i64 [%204, %$37] ; # C
  %247 = phi i64 [%205, %$37] ; # Sym
; # (let Z (car Y) (? (atom (cdr Z))) (xchg Z X) (setq Z (cdr Z) X (v...
; # (car Y)
  %248 = inttoptr i64 %201 to i64*
  %249 = load i64, i64* %248
; # (? (atom (cdr Z)))
; # (cdr Z)
  %250 = inttoptr i64 %249 to i64*
  %251 = getelementptr i64, i64* %250, i32 1
  %252 = load i64, i64* %251
; # (atom (cdr Z))
  %253 = and i64 %252, 15
  %254 = icmp ne i64 %253, 0
  br i1 %254, label %$38, label %$43
$43:
  %255 = phi i64 [%245, %$40] ; # X
  %256 = phi i64 [%246, %$40] ; # C
  %257 = phi i64 [%247, %$40] ; # Sym
  %258 = phi i64 [%249, %$40] ; # Z
; # (xchg Z X)
  %259 = inttoptr i64 %258 to i64*
  %260 = load i64, i64* %259
  %261 = inttoptr i64 %255 to i64*
  %262 = load i64, i64* %261
  store i64 %262, i64* %259
  store i64 %260, i64* %261
; # (cdr Z)
  %263 = inttoptr i64 %258 to i64*
  %264 = getelementptr i64, i64* %263, i32 1
  %265 = load i64, i64* %264
; # (val Z)
  %266 = inttoptr i64 %265 to i64*
  %267 = load i64, i64* %266
; # (set Z (cdr Z) 2 Z (cdr Y) 2 Y (val Y) Y X)
; # (cdr Z)
  %268 = inttoptr i64 %265 to i64*
  %269 = getelementptr i64, i64* %268, i32 1
  %270 = load i64, i64* %269
  %271 = inttoptr i64 %265 to i64*
  store i64 %270, i64* %271
; # (cdr Y)
  %272 = inttoptr i64 %201 to i64*
  %273 = getelementptr i64, i64* %272, i32 1
  %274 = load i64, i64* %273
  %275 = inttoptr i64 %265 to i64*
  %276 = getelementptr i64, i64* %275, i32 1
  store i64 %274, i64* %276
; # (val Y)
  %277 = inttoptr i64 %201 to i64*
  %278 = load i64, i64* %277
  %279 = inttoptr i64 %201 to i64*
  %280 = getelementptr i64, i64* %279, i32 1
  store i64 %278, i64* %280
  %281 = inttoptr i64 %201 to i64*
  store i64 %267, i64* %281
  br label %$41
$41:
  %282 = phi i64 [%231, %$42], [%267, %$43] ; # X
  %283 = phi i64 [%219, %$42], [%256, %$43] ; # C
  %284 = phi i64 [%220, %$42], [%257, %$43] ; # Sym
  %285 = phi i64 [%231, %$42], [%267, %$43] ; # ->
  br label %$33
$38:
  %286 = phi i64 [%181, %$36], [%207, %$39], [%245, %$40] ; # X
  %287 = phi i64 [%182, %$36], [%208, %$39], [%246, %$40] ; # C
  %288 = phi i64 [%183, %$36], [%209, %$39], [%247, %$40] ; # Sym
  %289 = phi i64 [0, %$36], [0, %$39], [0, %$40] ; # ->
  br label %$20
$20:
  %290 = phi i64 [%102, %$7], [%286, %$38] ; # X
  %291 = phi i64 [%106, %$7], [%287, %$38] ; # C
  %292 = phi i64 [%104, %$7], [%288, %$38] ; # Sym
  ret i64 %292
}

define void @delNode(i64, i64) align 8 {
$1:
; # (let Y (cdr X) (cond ((atom (car Y)) (set P (cdr Y))) ((atom (cdr...
; # (cdr X)
  %2 = inttoptr i64 %0 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (cond ((atom (car Y)) (set P (cdr Y))) ((atom (cdr Y)) (set P (ca...
; # (car Y)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (atom (car Y))
  %7 = and i64 %6, 15
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$4, label %$3
$4:
  %9 = phi i64 [%1, %$1] ; # P
  %10 = phi i64 [%4, %$1] ; # Y
; # (set P (cdr Y))
; # (cdr Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  %14 = inttoptr i64 %9 to i64*
  store i64 %13, i64* %14
  br label %$2
$3:
  %15 = phi i64 [%1, %$1] ; # P
  %16 = phi i64 [%4, %$1] ; # Y
; # (cdr Y)
  %17 = inttoptr i64 %16 to i64*
  %18 = getelementptr i64, i64* %17, i32 1
  %19 = load i64, i64* %18
; # (atom (cdr Y))
  %20 = and i64 %19, 15
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$6, label %$5
$6:
  %22 = phi i64 [%15, %$3] ; # P
  %23 = phi i64 [%16, %$3] ; # Y
; # (set P (car Y))
; # (car Y)
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  store i64 %25, i64* %26
  br label %$2
$5:
  %27 = phi i64 [%15, %$3] ; # P
  %28 = phi i64 [%16, %$3] ; # Y
; # (shift Y)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (cdr (shift Y))
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (car (setq P (cdr (shift Y))))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (atom (car (setq P (cdr (shift Y)))))
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$8, label %$7
$8:
  %39 = phi i64 [%34, %$5] ; # P
  %40 = phi i64 [%31, %$5] ; # Y
; # (set X (car Y) 2 (cdr X) (cdr P))
; # (car Y)
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = inttoptr i64 %0 to i64*
  store i64 %42, i64* %43
; # (cdr X)
  %44 = inttoptr i64 %0 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (cdr P)
  %47 = inttoptr i64 %39 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 %46 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  store i64 %49, i64* %51
  br label %$2
$7:
  %52 = phi i64 [%34, %$5] ; # P
  %53 = phi i64 [%31, %$5] ; # Y
; # (car P)
  %54 = inttoptr i64 %52 to i64*
  %55 = load i64, i64* %54
; # (loop (let Z (cdr P) (? (atom (car Z)) (set X (car P) (cdr Y) (cd...
  br label %$9
$9:
  %56 = phi i64 [%55, %$7], [%80, %$10] ; # P
  %57 = phi i64 [%53, %$7], [%77, %$10] ; # Y
; # (let Z (cdr P) (? (atom (car Z)) (set X (car P) (cdr Y) (cdr Z)))...
; # (cdr P)
  %58 = inttoptr i64 %56 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
; # (? (atom (car Z)) (set X (car P) (cdr Y) (cdr Z)))
; # (car Z)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (atom (car Z))
  %63 = and i64 %62, 15
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$12, label %$10
$12:
  %65 = phi i64 [%56, %$9] ; # P
  %66 = phi i64 [%57, %$9] ; # Y
; # (set X (car P) (cdr Y) (cdr Z))
; # (car P)
  %67 = inttoptr i64 %65 to i64*
  %68 = load i64, i64* %67
  %69 = inttoptr i64 %0 to i64*
  store i64 %68, i64* %69
; # (cdr Y)
  %70 = inttoptr i64 %66 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
; # (cdr Z)
  %73 = inttoptr i64 %60 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
  %76 = inttoptr i64 %72 to i64*
  store i64 %75, i64* %76
  br label %$11
$10:
  %77 = phi i64 [%56, %$9] ; # P
  %78 = phi i64 [%57, %$9] ; # Y
; # (car Z)
  %79 = inttoptr i64 %60 to i64*
  %80 = load i64, i64* %79
  br label %$9
$11:
  %81 = phi i64 [%65, %$12] ; # P
  %82 = phi i64 [%66, %$12] ; # Y
  %83 = phi i64 [%75, %$12] ; # ->
  br label %$2
$2:
  %84 = phi i64 [%9, %$4], [%22, %$6], [%39, %$8], [%81, %$11] ; # P
  %85 = phi i64 [%10, %$4], [%23, %$6], [%40, %$8], [%82, %$11] ; # Y
  %86 = phi i64 [%13, %$4], [%25, %$6], [%49, %$8], [%83, %$11] ; # ->
  ret void
}

define void @unintern(i64, i64, i64) align 8 {
$1:
; # (if (cnt? Name) (loop (let X (car P) (? (atom X)) (let (S (car X)...
; # (cnt? Name)
  %3 = and i64 %1, 2
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%2, %$1] ; # P
; # (loop (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (...
  br label %$5
$5:
  %6 = phi i64 [%5, %$2], [%51, %$18] ; # P
; # (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (tail S...
; # (car P)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (? (atom X))
; # (atom X)
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$6:
  %11 = phi i64 [%6, %$5] ; # P
  %12 = phi i64 [%8, %$5] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) (when (...
; # (car X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (tail S)
  %15 = add i64 %14, -8
; # (val (tail S))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (name (val (tail S)))
  br label %$8
$8:
  %18 = phi i64 [%17, %$6], [%24, %$9] ; # Tail
  %19 = and i64 %18, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$9
$9:
  %21 = phi i64 [%18, %$8] ; # Tail
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  br label %$8
$10:
  %25 = phi i64 [%18, %$8] ; # Tail
; # (? (== Name Nm) (when (== S Sym) (delNode X P)))
; # (== Name Nm)
  %26 = icmp eq i64 %1, %25
  br i1 %26, label %$12, label %$11
$12:
  %27 = phi i64 [%11, %$10] ; # P
  %28 = phi i64 [%12, %$10] ; # X
; # (when (== S Sym) (delNode X P))
; # (== S Sym)
  %29 = icmp eq i64 %14, %0
  br i1 %29, label %$13, label %$14
$13:
  %30 = phi i64 [%27, %$12] ; # P
  %31 = phi i64 [%28, %$12] ; # X
; # (delNode X P)
  call void @delNode(i64 %31, i64 %30)
  br label %$14
$14:
  %32 = phi i64 [%27, %$12], [%30, %$13] ; # P
  %33 = phi i64 [%28, %$12], [%31, %$13] ; # X
  br label %$7
$11:
  %34 = phi i64 [%11, %$10] ; # P
  %35 = phi i64 [%12, %$10] ; # X
; # (? (atom (shift X)))
; # (shift X)
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
; # (atom (shift X))
  %39 = and i64 %38, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$7, label %$15
$15:
  %41 = phi i64 [%34, %$11] ; # P
  %42 = phi i64 [%38, %$11] ; # X
; # (if (> Name Nm) (ofs X 1) X)
; # (> Name Nm)
  %43 = icmp ugt i64 %1, %25
  br i1 %43, label %$16, label %$17
$16:
  %44 = phi i64 [%41, %$15] ; # P
  %45 = phi i64 [%42, %$15] ; # X
; # (ofs X 1)
  %46 = add i64 %45, 8
  br label %$18
$17:
  %47 = phi i64 [%41, %$15] ; # P
  %48 = phi i64 [%42, %$15] ; # X
  br label %$18
$18:
  %49 = phi i64 [%44, %$16], [%47, %$17] ; # P
  %50 = phi i64 [%45, %$16], [%48, %$17] ; # X
  %51 = phi i64 [%46, %$16], [%48, %$17] ; # ->
  br label %$5
$7:
  %52 = phi i64 [%6, %$5], [%32, %$14], [%34, %$11] ; # P
  br label %$4
$3:
  %53 = phi i64 [%2, %$1] ; # P
; # (ofs P 1)
  %54 = add i64 %53, 8
; # (loop (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (...
  br label %$19
$19:
  %55 = phi i64 [%54, %$3], [%101, %$32] ; # P
; # (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (tail S...
; # (car P)
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
; # (? (atom X))
; # (atom X)
  %58 = and i64 %57, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$21, label %$20
$20:
  %60 = phi i64 [%55, %$19] ; # P
  %61 = phi i64 [%57, %$19] ; # X
; # (let (S (car X) Nm (name (val (tail S))) I (cmpLong Nm Name)) (? ...
; # (car X)
  %62 = inttoptr i64 %61 to i64*
  %63 = load i64, i64* %62
; # (tail S)
  %64 = add i64 %63, -8
; # (val (tail S))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (name (val (tail S)))
  br label %$22
$22:
  %67 = phi i64 [%66, %$20], [%73, %$23] ; # Tail
  %68 = and i64 %67, 6
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$24, label %$23
$23:
  %70 = phi i64 [%67, %$22] ; # Tail
  %71 = inttoptr i64 %70 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
  br label %$22
$24:
  %74 = phi i64 [%67, %$22] ; # Tail
; # (cmpLong Nm Name)
  %75 = call i64 @cmpLong(i64 %74, i64 %1)
; # (? (=0 I) (when (== S Sym) (delNode X P)))
; # (=0 I)
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %$26, label %$25
$26:
  %77 = phi i64 [%60, %$24] ; # P
  %78 = phi i64 [%61, %$24] ; # X
; # (when (== S Sym) (delNode X P))
; # (== S Sym)
  %79 = icmp eq i64 %63, %0
  br i1 %79, label %$27, label %$28
$27:
  %80 = phi i64 [%77, %$26] ; # P
  %81 = phi i64 [%78, %$26] ; # X
; # (delNode X P)
  call void @delNode(i64 %81, i64 %80)
  br label %$28
$28:
  %82 = phi i64 [%77, %$26], [%80, %$27] ; # P
  %83 = phi i64 [%78, %$26], [%81, %$27] ; # X
  br label %$21
$25:
  %84 = phi i64 [%60, %$24] ; # P
  %85 = phi i64 [%61, %$24] ; # X
; # (? (atom (shift X)))
; # (shift X)
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
; # (atom (shift X))
  %89 = and i64 %88, 15
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$21, label %$29
$29:
  %91 = phi i64 [%84, %$25] ; # P
  %92 = phi i64 [%88, %$25] ; # X
; # (if (lt0 I) (ofs X 1) X)
; # (lt0 I)
  %93 = icmp slt i64 %75, 0
  br i1 %93, label %$30, label %$31
$30:
  %94 = phi i64 [%91, %$29] ; # P
  %95 = phi i64 [%92, %$29] ; # X
; # (ofs X 1)
  %96 = add i64 %95, 8
  br label %$32
$31:
  %97 = phi i64 [%91, %$29] ; # P
  %98 = phi i64 [%92, %$29] ; # X
  br label %$32
$32:
  %99 = phi i64 [%94, %$30], [%97, %$31] ; # P
  %100 = phi i64 [%95, %$30], [%98, %$31] ; # X
  %101 = phi i64 [%96, %$30], [%98, %$31] ; # ->
  br label %$19
$21:
  %102 = phi i64 [%55, %$19], [%82, %$28], [%84, %$25] ; # P
  br label %$4
$4:
  %103 = phi i64 [%52, %$7], [%102, %$21] ; # P
  ret void
}

define i64 @_name(i64) align 8 {
$1:
; # (let Tail (val (tail (needSymb Exe (eval (cadr Exe))))) (if (sym?...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (tail (needSymb Exe (eval (cadr Exe))))
  %17 = add i64 %13, -8
; # (val (tail (needSymb Exe (eval (cadr Exe)))))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (if (sym? Tail) (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (...
; # (sym? Tail)
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$10
$9:
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (packExtNm (name ...
; # (push 4 NIL ZERO NIL)
  %22 = alloca i64, i64 4, align 16
  store i64 4, i64* %22
  %23 = getelementptr i64, i64* %22, i32 2
  store i64 2, i64* %23
; # (ofs P 2)
  %24 = getelementptr i64, i64* %22, i32 2
; # (link (ofs P 2) T)
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %25 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %27, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %30
; # (& Tail -9)
  %31 = and i64 %19, -9
; # (name (& Tail -9))
  br label %$12
$12:
  %32 = phi i64 [%31, %$9], [%38, %$13] ; # Tail
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$14, label %$13
$13:
  %35 = phi i64 [%32, %$12] ; # Tail
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  br label %$12
$14:
  %39 = phi i64 [%32, %$12] ; # Tail
; # (packExtNm (name (& Tail -9)) P)
  call void @packExtNm(i64 %39, i64* %22)
; # (val 3 P)
  %40 = getelementptr i64, i64* %22, i32 2
  %41 = load i64, i64* %40
; # (consStr (val 3 P))
  %42 = call i64 @consStr(i64 %41)
; # (drop *Safe)
  %43 = inttoptr i64 %25 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %46
  br label %$11
$10:
; # (name Tail)
  br label %$15
$15:
  %47 = phi i64 [%19, %$10], [%53, %$16] ; # Tail
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$17, label %$16
$16:
  %50 = phi i64 [%47, %$15] ; # Tail
  %51 = inttoptr i64 %50 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  br label %$15
$17:
  %54 = phi i64 [%47, %$15] ; # Tail
; # (consStr (name Tail))
  %55 = call i64 @consStr(i64 %54)
  br label %$11
$11:
  %56 = phi i64 [%42, %$14], [%55, %$17] ; # ->
  ret i64 %56
}

define i64 @_nsp(i64) align 8 {
$1:
; # (let Sym (needSymb Exe (eval (cadr Exe))) (if (sym? (val (tail Sy...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (if (sym? (val (tail Sym))) $Nil (let (Nm (name @) Lst (val $Inte...
; # (tail Sym)
  %17 = add i64 %13, -8
; # (val (tail Sym))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail Sym)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (Nm (name @) Lst (val $Intern)) (loop (? (atom Lst) $Nil) (l...
; # (name @)
  br label %$12
$12:
  %22 = phi i64 [%19, %$10], [%28, %$13] ; # Tail
  %23 = and i64 %22, 6
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$14, label %$13
$13:
  %25 = phi i64 [%22, %$12] ; # Tail
  %26 = inttoptr i64 %25 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  br label %$12
$14:
  %29 = phi i64 [%22, %$12] ; # Tail
; # (val $Intern)
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %31 = load i64, i64* %30
; # (loop (? (atom Lst) $Nil) (let Nsp (car Lst) (? (== Sym (isIntern...
  br label %$15
$15:
  %32 = phi i64 [%31, %$14], [%50, %$19] ; # Lst
; # (? (atom Lst) $Nil)
; # (atom Lst)
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$18, label %$16
$18:
  %35 = phi i64 [%32, %$15] ; # Lst
  br label %$17
$16:
  %36 = phi i64 [%32, %$15] ; # Lst
; # (let Nsp (car Lst) (? (== Sym (isIntern Nm (cdar Nsp))) Nsp))
; # (car Lst)
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (? (== Sym (isIntern Nm (cdar Nsp))) Nsp)
; # (cdar Nsp)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %40 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (isIntern Nm (cdar Nsp))
  %44 = call i64 @isIntern(i64 %29, i64 %43)
; # (== Sym (isIntern Nm (cdar Nsp)))
  %45 = icmp eq i64 %13, %44
  br i1 %45, label %$20, label %$19
$20:
  %46 = phi i64 [%36, %$16] ; # Lst
  br label %$17
$19:
  %47 = phi i64 [%36, %$16] ; # Lst
; # (shift Lst)
  %48 = inttoptr i64 %47 to i64*
  %49 = getelementptr i64, i64* %48, i32 1
  %50 = load i64, i64* %49
  br label %$15
$17:
  %51 = phi i64 [%35, %$18], [%46, %$20] ; # Lst
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$18], [%38, %$20] ; # ->
  br label %$11
$11:
  %53 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%52, %$17] ; # ->
  ret i64 %53
}

define i64 @_spQ(i64) align 8 {
$1:
; # (if (isBlank (eval (cadr Exe))) $T $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (isBlank (eval (cadr Exe)))
  %14 = call i1 @isBlank(i64 %13)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_patQ(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (== (firstChar X) (ch...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (== (firstChar X) (char "@"))) X $Nil)
; # (and (symb? X) (== (firstChar X) (char "@")))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (firstChar X)
  %17 = call i32 @firstChar(i64 %13)
; # (== (firstChar X) (char "@"))
  %18 = icmp eq i32 %17, 64
  br label %$7
$7:
  %19 = phi i1 [0, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_funQ(i64) align 8 {
$1:
; # (if (funq (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (funq (eval (cadr Exe)))
  %14 = call i64 @funq(i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_getd(i64) align 8 {
$1:
; # (let (X (eval (cadr Exe)) V T) (cond ((not (symb? X)) $Nil) ((fun...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((not (symb? X)) $Nil) ((funq (setq V (val X))) V) ((and (n...
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  br label %$7
$8:
; # (val X)
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
; # (funq (setq V (val X)))
  %20 = call i64 @funq(i64 %19)
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$10
$11:
  %22 = phi i64 [%19, %$8] ; # V
  br label %$7
$10:
  %23 = phi i64 [%19, %$8] ; # V
; # (and (nil? V) (sharedLib X))
; # (nil? V)
  %24 = icmp eq i64 %23, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %24, label %$13, label %$12
$13:
  %25 = phi i64 [%23, %$10] ; # V
; # (sharedLib X)
  %26 = call i1 @sharedLib(i64 %13)
  br label %$12
$12:
  %27 = phi i64 [%23, %$10], [%25, %$13] ; # V
  %28 = phi i1 [0, %$10], [%26, %$13] ; # ->
  br i1 %28, label %$15, label %$14
$15:
  %29 = phi i64 [%27, %$12] ; # V
; # (val X)
  %30 = inttoptr i64 %13 to i64*
  %31 = load i64, i64* %30
  br label %$7
$14:
  %32 = phi i64 [%27, %$12] ; # V
  br label %$7
$7:
  %33 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%22, %$11], [%31, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$14] ; # ->
  ret i64 %33
}

define i64 @consTree(i64, i64) align 8 {
$1:
; # (if (atom P) Lst (let (Q (link (push NIL NIL)) Tos (link (push -Z...
; # (atom P)
  %2 = and i64 %0, 15
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # P
  %5 = phi i64 [%1, %$1] ; # Lst
  br label %$4
$3:
  %6 = phi i64 [%0, %$1] ; # P
  %7 = phi i64 [%1, %$1] ; # Lst
; # (let (Q (link (push NIL NIL)) Tos (link (push -ZERO NIL))) (loop ...
; # (push NIL NIL)
  %8 = alloca i64, i64 2, align 16
  %9 = ptrtoint i64* %8 to i64
; # (link (push NIL NIL))
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %11 = load i64, i64* %10
  %12 = inttoptr i64 %9 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  store i64 %11, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %9, i64* %14
; # (push -ZERO NIL)
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 10, i64* %17
; # (link (push -ZERO NIL))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = inttoptr i64 %16 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  store i64 %19, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %22
; # (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @)...
  br label %$5
$5:
  %23 = phi i64 [%6, %$3], [%113, %$11] ; # P
  %24 = phi i64 [%7, %$3], [%114, %$11] ; # Lst
; # (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set ...
  br label %$6
$6:
  %25 = phi i64 [%23, %$5], [%32, %$7] ; # P
  %26 = phi i64 [%24, %$5], [%36, %$7] ; # Lst
; # (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set 2 X (v...
; # (cdr P)
  %27 = inttoptr i64 %25 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
; # (? (atom (cdr X)))
; # (cdr X)
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (atom (cdr X))
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$8, label %$7
$7:
  %35 = phi i64 [%25, %$6] ; # P
  %36 = phi i64 [%26, %$6] ; # Lst
; # (let Y P (setq P @) (set 2 X (val Tos)) (set Tos Y))
; # (set 2 X (val Tos))
; # (val Tos)
  %37 = inttoptr i64 %16 to i64*
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %29 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  store i64 %38, i64* %40
; # (set Tos Y)
  %41 = inttoptr i64 %16 to i64*
  store i64 %35, i64* %41
  br label %$6
$8:
  %42 = phi i64 [%25, %$6] ; # P
  %43 = phi i64 [%26, %$6] ; # Lst
  %44 = phi i64 [0, %$6] ; # ->
; # (set Q P)
  %45 = inttoptr i64 %9 to i64*
  store i64 %42, i64* %45
; # (loop (setq Lst (cons (car P) Lst)) (let X (cdr P) (? (pair (car ...
  br label %$9
$9:
  %46 = phi i64 [%42, %$8], [%110, %$17] ; # P
  %47 = phi i64 [%43, %$8], [%111, %$17] ; # Lst
; # (car P)
  %48 = inttoptr i64 %46 to i64*
  %49 = load i64, i64* %48
; # (cons (car P) Lst)
  %50 = call i64 @cons(i64 %49, i64 %47)
; # (let X (cdr P) (? (pair (car X)) (let Y P (setq P @) (set X (val ...
; # (cdr P)
  %51 = inttoptr i64 %46 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
; # (? (pair (car X)) (let Y P (setq P @) (set X (val Tos)) (set Tos ...
; # (car X)
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (pair (car X))
  %56 = and i64 %55, 15
  %57 = icmp eq i64 %56, 0
  br i1 %57, label %$12, label %$10
$12:
  %58 = phi i64 [%46, %$9] ; # P
  %59 = phi i64 [%50, %$9] ; # Lst
; # (let Y P (setq P @) (set X (val Tos)) (set Tos (| Y 8)) (set Q P)...
; # (set X (val Tos))
; # (val Tos)
  %60 = inttoptr i64 %16 to i64*
  %61 = load i64, i64* %60
  %62 = inttoptr i64 %53 to i64*
  store i64 %61, i64* %62
; # (set Tos (| Y 8))
; # (| Y 8)
  %63 = or i64 %58, 8
  %64 = inttoptr i64 %16 to i64*
  store i64 %63, i64* %64
; # (set Q P)
  %65 = inttoptr i64 %9 to i64*
  store i64 %55, i64* %65
  br label %$11
$10:
  %66 = phi i64 [%46, %$9] ; # P
  %67 = phi i64 [%50, %$9] ; # Lst
; # (loop (let X (val Tos) (when (== -ZERO X) (drop Q) (ret Lst)) (? ...
  br label %$13
$13:
  %68 = phi i64 [%66, %$10], [%101, %$16] ; # P
  %69 = phi i64 [%67, %$10], [%99, %$16] ; # Lst
; # (let X (val Tos) (when (== -ZERO X) (drop Q) (ret Lst)) (? (=0 (&...
; # (val Tos)
  %70 = inttoptr i64 %16 to i64*
  %71 = load i64, i64* %70
; # (when (== -ZERO X) (drop Q) (ret Lst))
; # (== -ZERO X)
  %72 = icmp eq i64 10, %71
  br i1 %72, label %$14, label %$15
$14:
  %73 = phi i64 [%68, %$13] ; # P
  %74 = phi i64 [%69, %$13] ; # Lst
  %75 = phi i64 [%71, %$13] ; # X
; # (drop Q)
  %76 = inttoptr i64 %9 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %78, i64* %79
; # (ret Lst)
  ret i64 %74
$15:
  %80 = phi i64 [%68, %$13] ; # P
  %81 = phi i64 [%69, %$13] ; # Lst
  %82 = phi i64 [%71, %$13] ; # X
; # (? (=0 (& X 8)) (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (set...
; # (& X 8)
  %83 = and i64 %82, 8
; # (=0 (& X 8))
  %84 = icmp eq i64 %83, 0
  br i1 %84, label %$18, label %$16
$18:
  %85 = phi i64 [%80, %$15] ; # P
  %86 = phi i64 [%81, %$15] ; # Lst
  %87 = phi i64 [%82, %$15] ; # X
; # (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (setq P X) (set Q P)...
; # (cdr X)
  %88 = inttoptr i64 %87 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
; # (set Tos (cdr Y))
; # (cdr Y)
  %91 = inttoptr i64 %90 to i64*
  %92 = getelementptr i64, i64* %91, i32 1
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %16 to i64*
  store i64 %93, i64* %94
; # (set 2 Y P)
  %95 = inttoptr i64 %90 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %85, i64* %96
; # (set Q P)
  %97 = inttoptr i64 %9 to i64*
  store i64 %87, i64* %97
  br label %$17
$16:
  %98 = phi i64 [%80, %$15] ; # P
  %99 = phi i64 [%81, %$15] ; # Lst
  %100 = phi i64 [%82, %$15] ; # X
; # (& X -9)
  %101 = and i64 %100, -9
; # (let Y (cdr X) (set Tos (car Y)) (set Y P) (setq P X) (set Q P))
; # (cdr X)
  %102 = inttoptr i64 %101 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
; # (set Tos (car Y))
; # (car Y)
  %105 = inttoptr i64 %104 to i64*
  %106 = load i64, i64* %105
  %107 = inttoptr i64 %16 to i64*
  store i64 %106, i64* %107
; # (set Y P)
  %108 = inttoptr i64 %104 to i64*
  store i64 %98, i64* %108
; # (set Q P)
  %109 = inttoptr i64 %9 to i64*
  store i64 %101, i64* %109
  br label %$13
$17:
  %110 = phi i64 [%87, %$18] ; # P
  %111 = phi i64 [%86, %$18] ; # Lst
  %112 = phi i64 [%87, %$18] ; # ->
  br label %$9
$11:
  %113 = phi i64 [%55, %$12] ; # P
  %114 = phi i64 [%59, %$12] ; # Lst
  %115 = phi i64 [%55, %$12] ; # ->
  br label %$5
$4:
  %116 = phi i64 [%4, %$2] ; # P
  %117 = phi i64 [%5, %$2] ; # Lst
  %118 = phi i64 [%5, %$2] ; # ->
  ret i64 %118
}

define i64 @_all(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (cond ((nil? X) (let Y (val $Intern) (lo...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((nil? X) (let Y (val $Intern) (loop (let Z (cdar (++ Y)) (...
; # (nil? X)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%13, %$2] ; # X
; # (let Y (val $Intern) (loop (let Z (cdar (++ Y)) (setq X (consTree...
; # (val $Intern)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
; # (loop (let Z (cdar (++ Y)) (setq X (consTree (car Z) (consTree (c...
  br label %$10
$10:
  %18 = phi i64 [%15, %$9], [%40, %$11] ; # X
  %19 = phi i64 [%17, %$9], [%41, %$11] ; # Y
; # (let Z (cdar (++ Y)) (setq X (consTree (car Z) (consTree (cdr Z) ...
; # (++ Y)
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
  %22 = getelementptr i64, i64* %20, i32 1
  %23 = load i64, i64* %22
; # (cdar (++ Y))
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %25 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (car Z)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (cdr Z)
  %31 = inttoptr i64 %28 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
; # (consTree (cdr Z) X)
  %34 = call i64 @consTree(i64 %33, i64 %18)
; # (consTree (car Z) (consTree (cdr Z) X))
  %35 = call i64 @consTree(i64 %30, i64 %34)
; # (? (atom Y) X)
; # (atom Y)
  %36 = and i64 %23, 15
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$13, label %$11
$13:
  %38 = phi i64 [%35, %$10] ; # X
  %39 = phi i64 [%23, %$10] ; # Y
  br label %$12
$11:
  %40 = phi i64 [%35, %$10] ; # X
  %41 = phi i64 [%23, %$10] ; # Y
  br label %$10
$12:
  %42 = phi i64 [%38, %$13] ; # X
  %43 = phi i64 [%39, %$13] ; # Y
  %44 = phi i64 [%38, %$13] ; # ->
  br label %$7
$8:
  %45 = phi i64 [%13, %$2] ; # X
; # (t? X)
  %46 = icmp eq i64 %45, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %46, label %$15, label %$14
$15:
  %47 = phi i64 [%45, %$8] ; # X
; # (val $Transient)
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %49 = load i64, i64* %48
; # (val 2 $Transient)
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
; # (consTree (val 2 $Transient) $Nil)
  %53 = call i64 @consTree(i64 %52, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (consTree (val $Transient) (consTree (val 2 $Transient) $Nil))
  %54 = call i64 @consTree(i64 %49, i64 %53)
  br label %$7
$14:
  %55 = phi i64 [%45, %$8] ; # X
; # (num? X)
  %56 = and i64 %55, 6
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$17, label %$16
$17:
  %58 = phi i64 [%55, %$14] ; # X
; # (val $Extern)
  %59 = load i64, i64* @$Extern
; # (consTree (val $Extern) $Nil)
  %60 = call i64 @consTree(i64 %59, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$7
$16:
  %61 = phi i64 [%55, %$14] ; # X
; # (sym? X)
  %62 = and i64 %61, 8
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$19, label %$18
$19:
  %64 = phi i64 [%61, %$16] ; # X
; # (let Y (cdar X) (if (pair Y) (consTree (car Y) (consTree (cdr Y) ...
; # (cdar X)
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = inttoptr i64 %66 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
; # (if (pair Y) (consTree (car Y) (consTree (cdr Y) $Nil)) $Nil)
; # (pair Y)
  %70 = and i64 %69, 15
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %$20, label %$21
$20:
  %72 = phi i64 [%64, %$19] ; # X
; # (car Y)
  %73 = inttoptr i64 %69 to i64*
  %74 = load i64, i64* %73
; # (cdr Y)
  %75 = inttoptr i64 %69 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
; # (consTree (cdr Y) $Nil)
  %78 = call i64 @consTree(i64 %77, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (consTree (car Y) (consTree (cdr Y) $Nil))
  %79 = call i64 @consTree(i64 %74, i64 %78)
  br label %$22
$21:
  %80 = phi i64 [%64, %$19] ; # X
  br label %$22
$22:
  %81 = phi i64 [%72, %$20], [%80, %$21] ; # X
  %82 = phi i64 [%79, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
  br label %$7
$18:
  %83 = phi i64 [%61, %$16] ; # X
; # (car X)
  %84 = inttoptr i64 %83 to i64*
  %85 = load i64, i64* %84
; # (nil? (car X))
  %86 = icmp eq i64 %85, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %86, label %$24, label %$23
$24:
  %87 = phi i64 [%83, %$18] ; # X
; # (let Y (val (car (val $Intern))) (if (nil? (cdr X)) (val Y) (val ...
; # (val $Intern)
  %88 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %89 = load i64, i64* %88
; # (car (val $Intern))
  %90 = inttoptr i64 %89 to i64*
  %91 = load i64, i64* %90
; # (val (car (val $Intern)))
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
; # (if (nil? (cdr X)) (val Y) (val 2 Y))
; # (cdr X)
  %94 = inttoptr i64 %87 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
; # (nil? (cdr X))
  %97 = icmp eq i64 %96, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %97, label %$25, label %$26
$25:
  %98 = phi i64 [%87, %$24] ; # X
; # (val Y)
  %99 = inttoptr i64 %93 to i64*
  %100 = load i64, i64* %99
  br label %$27
$26:
  %101 = phi i64 [%87, %$24] ; # X
; # (val 2 Y)
  %102 = inttoptr i64 %93 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  br label %$27
$27:
  %105 = phi i64 [%98, %$25], [%101, %$26] ; # X
  %106 = phi i64 [%100, %$25], [%104, %$26] ; # ->
  br label %$7
$23:
  %107 = phi i64 [%83, %$18] ; # X
; # (car X)
  %108 = inttoptr i64 %107 to i64*
  %109 = load i64, i64* %108
; # (t? (car X))
  %110 = icmp eq i64 %109, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %110, label %$29, label %$28
$29:
  %111 = phi i64 [%107, %$23] ; # X
; # (if (nil? (cdr X)) (val $Transient) (val 2 $Transient))
; # (cdr X)
  %112 = inttoptr i64 %111 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  %114 = load i64, i64* %113
; # (nil? (cdr X))
  %115 = icmp eq i64 %114, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %115, label %$30, label %$31
$30:
  %116 = phi i64 [%111, %$29] ; # X
; # (val $Transient)
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %118 = load i64, i64* %117
  br label %$32
$31:
  %119 = phi i64 [%111, %$29] ; # X
; # (val 2 $Transient)
  %120 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  %122 = load i64, i64* %121
  br label %$32
$32:
  %123 = phi i64 [%116, %$30], [%119, %$31] ; # X
  %124 = phi i64 [%118, %$30], [%122, %$31] ; # ->
  br label %$7
$28:
  %125 = phi i64 [%107, %$23] ; # X
; # (val $Extern)
  %126 = load i64, i64* @$Extern
  br label %$7
$7:
  %127 = phi i64 [%42, %$12], [%47, %$15], [%58, %$17], [%81, %$22], [%105, %$27], [%123, %$32], [%125, %$28] ; # X
  %128 = phi i64 [%44, %$12], [%54, %$15], [%60, %$17], [%82, %$22], [%106, %$27], [%124, %$32], [%126, %$28] ; # ->
  ret i64 %128
}

define i64 @_symbols(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (atom X) (val $Intern) (let Y (eval (++ X)) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom X) (val $Intern) (let Y (eval (++ X)) (if (pair Y) (let...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
; # (val $Intern)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  br label %$4
$3:
  %9 = phi i64 [%3, %$1] ; # X
; # (let Y (eval (++ X)) (if (pair Y) (let L Y (loop (needNsp Exe (ne...
; # (++ X)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (eval (++ X))
  %14 = and i64 %11, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  br label %$5
$6:
  %16 = and i64 %11, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = inttoptr i64 %11 to i64*
  %19 = load i64, i64* %18
  br label %$5
$8:
  %20 = call i64 @evList(i64 %11)
  br label %$5
$5:
  %21 = phi i64 [%11, %$7], [%19, %$9], [%20, %$8] ; # ->
; # (if (pair Y) (let L Y (loop (needNsp Exe (needSymb Exe (++ L))) (...
; # (pair Y)
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$10, label %$11
$10:
  %24 = phi i64 [%13, %$5] ; # X
  %25 = phi i64 [%21, %$5] ; # Y
; # (let L Y (loop (needNsp Exe (needSymb Exe (++ L))) (? (atom L))) ...
; # (loop (needNsp Exe (needSymb Exe (++ L))) (? (atom L)))
  br label %$13
$13:
  %26 = phi i64 [%24, %$10], [%46, %$20] ; # X
  %27 = phi i64 [%25, %$10], [%47, %$20] ; # Y
  %28 = phi i64 [%25, %$10], [%48, %$20] ; # L
; # (++ L)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  %31 = getelementptr i64, i64* %29, i32 1
  %32 = load i64, i64* %31
; # (needSymb Exe (++ L))
  %33 = xor i64 %30, 8
  %34 = and i64 %33, 14
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$15, label %$14
$14:
  call void @symErr(i64 %0, i64 %30)
  unreachable
$15:
; # (needNsp Exe (needSymb Exe (++ L)))
  %36 = inttoptr i64 %30 to i64*
  %37 = load i64, i64* %36
  %38 = and i64 %37, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$17, label %$16
$17:
  %40 = inttoptr i64 %37 to i64*
  %41 = load i64, i64* %40
  %42 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64), %41
  br label %$16
$16:
  %43 = phi i1 [0, %$15], [%42, %$17] ; # ->
  br i1 %43, label %$19, label %$18
$18:
  call void @symNspErr(i64 %0, i64 %30)
  unreachable
$19:
; # (? (atom L))
; # (atom L)
  %44 = and i64 %32, 15
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$21, label %$20
$20:
  %46 = phi i64 [%26, %$19] ; # X
  %47 = phi i64 [%27, %$19] ; # Y
  %48 = phi i64 [%32, %$19] ; # L
  br label %$13
$21:
  %49 = phi i64 [%26, %$19] ; # X
  %50 = phi i64 [%27, %$19] ; # Y
  %51 = phi i64 [%32, %$19] ; # L
  %52 = phi i64 [0, %$19] ; # ->
; # (if (atom X) (prog1 (val $Intern) (set $Intern Y)) (let Z (save (...
; # (atom X)
  %53 = and i64 %49, 15
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$22, label %$23
$22:
  %55 = phi i64 [%49, %$21] ; # X
  %56 = phi i64 [%50, %$21] ; # Y
  %57 = phi i64 [%51, %$21] ; # L
; # (prog1 (val $Intern) (set $Intern Y))
; # (val $Intern)
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %59 = load i64, i64* %58
; # (set $Intern Y)
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %56, i64* %60
  br label %$24
$23:
  %61 = phi i64 [%49, %$21] ; # X
  %62 = phi i64 [%50, %$21] ; # Y
  %63 = phi i64 [%51, %$21] ; # L
; # (let Z (save (val $Intern)) (set $Intern Y) (prog1 (run X) (set $...
; # (val $Intern)
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %65 = load i64, i64* %64
; # (save (val $Intern))
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %67 = load i64, i64* %66
  %68 = alloca i64, i64 2, align 16
  %69 = ptrtoint i64* %68 to i64
  %70 = inttoptr i64 %69 to i64*
  store i64 %65, i64* %70
  %71 = add i64 %69, 8
  %72 = inttoptr i64 %71 to i64*
  store i64 %67, i64* %72
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %69, i64* %73
; # (set $Intern Y)
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %62, i64* %74
; # (prog1 (run X) (set $Intern Z))
; # (run X)
  br label %$25
$25:
  %75 = phi i64 [%61, %$23], [%97, %$34] ; # Prg
  %76 = inttoptr i64 %75 to i64*
  %77 = load i64, i64* %76
  %78 = getelementptr i64, i64* %76, i32 1
  %79 = load i64, i64* %78
  %80 = and i64 %79, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$28, label %$26
$28:
  %82 = phi i64 [%79, %$25] ; # Prg
  %83 = and i64 %77, 6
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$31, label %$30
$31:
  br label %$29
$30:
  %85 = and i64 %77, 8
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$33, label %$32
$33:
  %87 = inttoptr i64 %77 to i64*
  %88 = load i64, i64* %87
  br label %$29
$32:
  %89 = call i64 @evList(i64 %77)
  br label %$29
$29:
  %90 = phi i64 [%77, %$31], [%88, %$33], [%89, %$32] ; # ->
  br label %$27
$26:
  %91 = phi i64 [%79, %$25] ; # Prg
  %92 = and i64 %77, 15
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %$35, label %$34
$35:
  %94 = phi i64 [%91, %$26] ; # Prg
  %95 = call i64 @evList(i64 %77)
  %96 = icmp ne i64 %95, 0
  br label %$34
$34:
  %97 = phi i64 [%91, %$26], [%94, %$35] ; # Prg
  %98 = phi i1 [0, %$26], [%96, %$35] ; # ->
  br label %$25
$27:
  %99 = phi i64 [%82, %$29] ; # Prg
  %100 = phi i64 [%90, %$29] ; # ->
; # (set $Intern Z)
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %101
; # (drop *Safe)
  %102 = inttoptr i64 %69 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %104, i64* %105
  br label %$24
$24:
  %106 = phi i64 [%55, %$22], [%61, %$27] ; # X
  %107 = phi i64 [%56, %$22], [%62, %$27] ; # Y
  %108 = phi i64 [%57, %$22], [%63, %$27] ; # L
  %109 = phi i64 [%59, %$22], [%100, %$27] ; # ->
  br label %$12
$11:
  %110 = phi i64 [%13, %$5] ; # X
  %111 = phi i64 [%21, %$5] ; # Y
; # (if (or (nil? (val (needSymb Exe Y))) (== @ Y)) (set (chkVar Exe ...
; # (or (nil? (val (needSymb Exe Y))) (== @ Y))
; # (needSymb Exe Y)
  %112 = xor i64 %111, 8
  %113 = and i64 %112, 14
  %114 = icmp eq i64 %113, 0
  br i1 %114, label %$38, label %$37
$37:
  call void @symErr(i64 %0, i64 %111)
  unreachable
$38:
; # (val (needSymb Exe Y))
  %115 = inttoptr i64 %111 to i64*
  %116 = load i64, i64* %115
; # (nil? (val (needSymb Exe Y)))
  %117 = icmp eq i64 %116, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %117, label %$36, label %$39
$39:
  %118 = phi i64 [%110, %$38] ; # X
  %119 = phi i64 [%111, %$38] ; # Y
; # (== @ Y)
  %120 = icmp eq i64 %116, %119
  br label %$36
$36:
  %121 = phi i64 [%110, %$38], [%118, %$39] ; # X
  %122 = phi i64 [%111, %$38], [%119, %$39] ; # Y
  %123 = phi i1 [1, %$38], [%120, %$39] ; # ->
  br i1 %123, label %$40, label %$41
$40:
  %124 = phi i64 [%121, %$36] ; # X
  %125 = phi i64 [%122, %$36] ; # Y
; # (set (chkVar Exe Y) (cons $Tilde (cons $Nil $Nil)))
; # (chkVar Exe Y)
  %126 = icmp uge i64 %125, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %126, label %$44, label %$43
$44:
  %127 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %125
  br label %$43
$43:
  %128 = phi i1 [0, %$40], [%127, %$44] ; # ->
  br i1 %128, label %$45, label %$46
$45:
  call void @protErr(i64 %0, i64 %125)
  unreachable
$46:
; # (cons $Nil $Nil)
  %129 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Tilde (cons $Nil $Nil))
  %130 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64), i64 %129)
  %131 = inttoptr i64 %125 to i64*
  store i64 %130, i64* %131
  br label %$42
$41:
  %132 = phi i64 [%121, %$36] ; # X
  %133 = phi i64 [%122, %$36] ; # Y
; # (needNsp Exe Y)
  %134 = inttoptr i64 %133 to i64*
  %135 = load i64, i64* %134
  %136 = and i64 %135, 15
  %137 = icmp eq i64 %136, 0
  br i1 %137, label %$48, label %$47
$48:
  %138 = inttoptr i64 %135 to i64*
  %139 = load i64, i64* %138
  %140 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64), %139
  br label %$47
$47:
  %141 = phi i1 [0, %$41], [%140, %$48] ; # ->
  br i1 %141, label %$50, label %$49
$49:
  call void @symNspErr(i64 %0, i64 %133)
  unreachable
$50:
  br label %$42
$42:
  %142 = phi i64 [%124, %$46], [%132, %$50] ; # X
  %143 = phi i64 [%125, %$46], [%133, %$50] ; # Y
  %144 = phi i64 [%130, %$46], [%133, %$50] ; # ->
; # (let R (setq Y (save (cons Y $Nil))) (while (pair X) (setq Y (set...
; # (cons Y $Nil)
  %145 = call i64 @cons(i64 %143, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons Y $Nil))
  %146 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %147 = load i64, i64* %146
  %148 = alloca i64, i64 2, align 16
  %149 = ptrtoint i64* %148 to i64
  %150 = inttoptr i64 %149 to i64*
  store i64 %145, i64* %150
  %151 = add i64 %149, 8
  %152 = inttoptr i64 %151 to i64*
  store i64 %147, i64* %152
  %153 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %149, i64* %153
; # (while (pair X) (setq Y (set 2 Y (cons (needNsp Exe (needSymb Exe...
  br label %$51
$51:
  %154 = phi i64 [%142, %$42], [%163, %$64] ; # X
  %155 = phi i64 [%145, %$42], [%183, %$64] ; # Y
; # (pair X)
  %156 = and i64 %154, 15
  %157 = icmp eq i64 %156, 0
  br i1 %157, label %$52, label %$53
$52:
  %158 = phi i64 [%154, %$51] ; # X
  %159 = phi i64 [%155, %$51] ; # Y
; # (set 2 Y (cons (needNsp Exe (needSymb Exe (eval (++ X)))) $Nil))
; # (++ X)
  %160 = inttoptr i64 %158 to i64*
  %161 = load i64, i64* %160
  %162 = getelementptr i64, i64* %160, i32 1
  %163 = load i64, i64* %162
; # (eval (++ X))
  %164 = and i64 %161, 6
  %165 = icmp ne i64 %164, 0
  br i1 %165, label %$56, label %$55
$56:
  br label %$54
$55:
  %166 = and i64 %161, 8
  %167 = icmp ne i64 %166, 0
  br i1 %167, label %$58, label %$57
$58:
  %168 = inttoptr i64 %161 to i64*
  %169 = load i64, i64* %168
  br label %$54
$57:
  %170 = call i64 @evList(i64 %161)
  br label %$54
$54:
  %171 = phi i64 [%161, %$56], [%169, %$58], [%170, %$57] ; # ->
; # (needSymb Exe (eval (++ X)))
  %172 = xor i64 %171, 8
  %173 = and i64 %172, 14
  %174 = icmp eq i64 %173, 0
  br i1 %174, label %$60, label %$59
$59:
  call void @symErr(i64 %0, i64 %171)
  unreachable
$60:
; # (needNsp Exe (needSymb Exe (eval (++ X))))
  %175 = inttoptr i64 %171 to i64*
  %176 = load i64, i64* %175
  %177 = and i64 %176, 15
  %178 = icmp eq i64 %177, 0
  br i1 %178, label %$62, label %$61
$62:
  %179 = inttoptr i64 %176 to i64*
  %180 = load i64, i64* %179
  %181 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64), %180
  br label %$61
$61:
  %182 = phi i1 [0, %$60], [%181, %$62] ; # ->
  br i1 %182, label %$64, label %$63
$63:
  call void @symNspErr(i64 %0, i64 %171)
  unreachable
$64:
; # (cons (needNsp Exe (needSymb Exe (eval (++ X)))) $Nil)
  %183 = call i64 @cons(i64 %171, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %184 = inttoptr i64 %159 to i64*
  %185 = getelementptr i64, i64* %184, i32 1
  store i64 %183, i64* %185
  br label %$51
$53:
  %186 = phi i64 [%154, %$51] ; # X
  %187 = phi i64 [%155, %$51] ; # Y
; # (prog1 (val $Intern) (set $Intern R))
; # (val $Intern)
  %188 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %189 = load i64, i64* %188
; # (set $Intern R)
  %190 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %145, i64* %190
; # (drop *Safe)
  %191 = inttoptr i64 %149 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
  %194 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %193, i64* %194
  br label %$12
$12:
  %195 = phi i64 [%106, %$24], [%186, %$53] ; # X
  %196 = phi i64 [%107, %$24], [%187, %$53] ; # Y
  %197 = phi i64 [%109, %$24], [%189, %$53] ; # ->
  br label %$4
$4:
  %198 = phi i64 [%6, %$2], [%195, %$12] ; # X
  %199 = phi i64 [%8, %$2], [%197, %$12] ; # ->
  ret i64 %199
}

define i64 @_intern(i64) align 8 {
$1:
; # (let (X (cdr Exe) Sym (save (needSymb Exe (eval (++ X))))) (cond ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needSymb Exe (eval (++ X)))
  %16 = xor i64 %15, 8
  %17 = and i64 %16, 14
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %15)
  unreachable
$8:
; # (save (needSymb Exe (eval (++ X))))
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (cond ((sym? (val (tail Sym))) $Nil) ((== (name @) ZERO) $Nil) (T...
; # (tail Sym)
  %27 = add i64 %15, -8
; # (val (tail Sym))
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (sym? (val (tail Sym)))
  %30 = and i64 %29, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  br label %$9
$10:
; # (name @)
  br label %$12
$12:
  %32 = phi i64 [%29, %$10], [%38, %$13] ; # Tail
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$14, label %$13
$13:
  %35 = phi i64 [%32, %$12] ; # Tail
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  br label %$12
$14:
  %39 = phi i64 [%32, %$12] ; # Tail
; # (== (name @) ZERO)
  %40 = icmp eq i64 %39, 2
  br i1 %40, label %$16, label %$15
$16:
  br label %$9
$15:
; # (let Nm @ (if (nil? (eval (car X))) (let L (val $Intern) (intern ...
; # (if (nil? (eval (car X))) (let L (val $Intern) (intern Sym 0 Nm (...
; # (car X)
  %41 = inttoptr i64 %7 to i64*
  %42 = load i64, i64* %41
; # (eval (car X))
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$19, label %$18
$19:
  br label %$17
$18:
  %45 = and i64 %42, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$21, label %$20
$21:
  %47 = inttoptr i64 %42 to i64*
  %48 = load i64, i64* %47
  br label %$17
$20:
  %49 = call i64 @evList(i64 %42)
  br label %$17
$17:
  %50 = phi i64 [%42, %$19], [%48, %$21], [%49, %$20] ; # ->
; # (nil? (eval (car X)))
  %51 = icmp eq i64 %50, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %51, label %$22, label %$23
$22:
; # (let L (val $Intern) (intern Sym 0 Nm (cdar (car L)) (cdr L) NO))...
; # (val $Intern)
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %53 = load i64, i64* %52
; # (car L)
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (cdar (car L))
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
  %58 = inttoptr i64 %57 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
; # (cdr L)
  %61 = inttoptr i64 %53 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
; # (intern Sym 0 Nm (cdar (car L)) (cdr L) NO)
  %64 = call i64 @intern(i64 %15, i64 0, i64 %39, i64 %60, i64 %63, i1 0)
  br label %$24
$23:
; # (if (t? @) (cdar (car (val $Intern))) (cdar @))
; # (t? @)
  %65 = icmp eq i64 %50, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %65, label %$25, label %$26
$25:
; # (val $Intern)
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %67 = load i64, i64* %66
; # (car (val $Intern))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (cdar (car (val $Intern)))
  %70 = inttoptr i64 %69 to i64*
  %71 = load i64, i64* %70
  %72 = inttoptr i64 %71 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
  br label %$27
$26:
; # (cdar @)
  %75 = inttoptr i64 %50 to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %76 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  %79 = load i64, i64* %78
  br label %$27
$27:
  %80 = phi i64 [%74, %$25], [%79, %$26] ; # ->
; # (intern Sym 0 Nm (if (t? @) (cdar (car (val $Intern))) (cdar @)) ...
  %81 = call i64 @intern(i64 %15, i64 0, i64 %39, i64 %80, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i1 0)
  br label %$24
$24:
  %82 = phi i64 [%64, %$22], [%81, %$27] ; # ->
  br label %$9
$9:
  %83 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%82, %$24] ; # ->
; # (drop *Safe)
  %84 = inttoptr i64 %22 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
  %87 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %86, i64* %87
  ret i64 %83
}

define i64 @_hide(i64) align 8 {
$1:
; # (set $Transient (set 2 $Transient $Nil))
; # (set 2 $Transient $Nil)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %2
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %3
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_boxQ(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (not (sym? (val (tail...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (not (sym? (val (tail X)))) (== ZERO (name @))...
; # (and (symb? X) (not (sym? (val (tail X)))) (== ZERO (name @)))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (tail X)
  %17 = add i64 %13, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
; # (not (sym? (val (tail X))))
  %22 = icmp eq i1 %21, 0
  br i1 %22, label %$9, label %$7
$9:
; # (name @)
  br label %$10
$10:
  %23 = phi i64 [%19, %$9], [%29, %$11] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$12, label %$11
$11:
  %26 = phi i64 [%23, %$10] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$10
$12:
  %30 = phi i64 [%23, %$10] ; # Tail
; # (== ZERO (name @))
  %31 = icmp eq i64 2, %30
  br label %$7
$7:
  %32 = phi i1 [0, %$2], [0, %$8], [%31, %$12] ; # ->
  br i1 %32, label %$13, label %$14
$13:
  br label %$15
$14:
  br label %$15
$15:
  %33 = phi i64 [%13, %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$14] ; # ->
  ret i64 %33
}

define i64 @_strQ(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (cond ((not (symb? X)) $Nil) ((or (sym? ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((not (symb? X)) $Nil) ((or (sym? (val (tail X))) (findSym ...
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  br label %$7
$8:
; # (or (sym? (val (tail X))) (findSym X (name @) (val $Intern)))
; # (tail X)
  %18 = add i64 %13, -8
; # (val (tail X))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (sym? (val (tail X)))
  %21 = and i64 %20, 8
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$10, label %$11
$11:
; # (name @)
  br label %$12
$12:
  %23 = phi i64 [%20, %$11], [%29, %$13] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$14, label %$13
$13:
  %26 = phi i64 [%23, %$12] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$12
$14:
  %30 = phi i64 [%23, %$12] ; # Tail
; # (val $Intern)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
; # (findSym X (name @) (val $Intern))
  %33 = call i1 @findSym(i64 %13, i64 %30, i64 %32)
  br label %$10
$10:
  %34 = phi i1 [1, %$8], [%33, %$14] ; # ->
  br i1 %34, label %$16, label %$15
$16:
  br label %$7
$15:
  br label %$7
$7:
  %35 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%13, %$15] ; # ->
  ret i64 %35
}

define i64 @_zap(i64) align 8 {
$1:
; # (let Sym (needSymb Exe (eval (cadr Exe))) (if (sym? (val (tail Sy...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (if (sym? (val (tail Sym))) (dbZap Sym) (unintern Sym (name @) (c...
; # (tail Sym)
  %17 = add i64 %13, -8
; # (val (tail Sym))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail Sym)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$10
$9:
; # (dbZap Sym)
  call void @dbZap(i64 %13)
  br label %$11
$10:
; # (name @)
  br label %$12
$12:
  %22 = phi i64 [%19, %$10], [%28, %$13] ; # Tail
  %23 = and i64 %22, 6
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$14, label %$13
$13:
  %25 = phi i64 [%22, %$12] ; # Tail
  %26 = inttoptr i64 %25 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  br label %$12
$14:
  %29 = phi i64 [%22, %$12] ; # Tail
; # (val $Intern)
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %31 = load i64, i64* %30
; # (car (val $Intern))
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (cdar (car (val $Intern)))
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
; # (unintern Sym (name @) (cdar (car (val $Intern))))
  call void @unintern(i64 %13, i64 %29, i64 %38)
  br label %$11
$11:
  ret i64 %13
}

define i64 @_chop(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (or (pair X) (nil? X)) X (let Tail (...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (pair X) (nil? X)) X (let Tail (val (tail (xSym X))) (if ...
; # (or (pair X) (nil? X))
; # (pair X)
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
; # (nil? X)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let Tail (val (tail (xSym X))) (if (sym? Tail) (chopExtNm (name ...
; # (xSym X)
  %18 = call i64 @xSym(i64 %13)
; # (tail (xSym X))
  %19 = add i64 %18, -8
; # (val (tail (xSym X)))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (if (sym? Tail) (chopExtNm (name (& Tail -9))) (let (P (push 0 (n...
; # (sym? Tail)
  %22 = and i64 %21, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$13
$12:
; # (& Tail -9)
  %24 = and i64 %21, -9
; # (name (& Tail -9))
  br label %$15
$15:
  %25 = phi i64 [%24, %$12], [%31, %$16] ; # Tail
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$17, label %$16
$16:
  %28 = phi i64 [%25, %$15] ; # Tail
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  br label %$15
$17:
  %32 = phi i64 [%25, %$15] ; # Tail
; # (chopExtNm (name (& Tail -9)))
  %33 = call i64 @chopExtNm(i64 %32)
  br label %$14
$13:
; # (let (P (push 0 (name Tail)) C (symChar P)) (if C (save Tail (let...
; # (name Tail)
  br label %$18
$18:
  %34 = phi i64 [%21, %$13], [%40, %$19] ; # Tail
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$20, label %$19
$19:
  %37 = phi i64 [%34, %$18] ; # Tail
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  br label %$18
$20:
  %41 = phi i64 [%34, %$18] ; # Tail
; # (push 0 (name Tail))
  %42 = alloca i64, i64 2, align 16
  store i64 0, i64* %42
  %43 = getelementptr i64, i64* %42, i32 1
  store i64 %41, i64* %43
; # (symChar P)
  %44 = call i32 @symChar(i64* %42)
; # (if C (save Tail (let (Y (cons (mkChar C) $Nil) R (save Y)) (whil...
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %$21, label %$22
$21:
  %46 = phi i32 [%44, %$20] ; # C
; # (save Tail (let (Y (cons (mkChar C) $Nil) R (save Y)) (while (set...
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %48 = load i64, i64* %47
  %49 = alloca i64, i64 2, align 16
  %50 = ptrtoint i64* %49 to i64
  %51 = inttoptr i64 %50 to i64*
  store i64 %21, i64* %51
  %52 = add i64 %50, 8
  %53 = inttoptr i64 %52 to i64*
  store i64 %48, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %50, i64* %54
; # (let (Y (cons (mkChar C) $Nil) R (save Y)) (while (setq C (symCha...
; # (mkChar C)
  %55 = call i64 @mkChar(i32 %46)
; # (cons (mkChar C) $Nil)
  %56 = call i64 @cons(i64 %55, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %58 = load i64, i64* %57
  %59 = alloca i64, i64 2, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = inttoptr i64 %60 to i64*
  store i64 %56, i64* %61
  %62 = add i64 %60, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 %58, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %64
; # (while (setq C (symChar P)) (setq Y (set 2 Y (cons (mkChar C) $Ni...
  br label %$24
$24:
  %65 = phi i32 [%46, %$21], [%69, %$25] ; # C
  %66 = phi i64 [%56, %$21], [%72, %$25] ; # Y
; # (symChar P)
  %67 = call i32 @symChar(i64* %42)
  %68 = icmp ne i32 %67, 0
  br i1 %68, label %$25, label %$26
$25:
  %69 = phi i32 [%67, %$24] ; # C
  %70 = phi i64 [%66, %$24] ; # Y
; # (set 2 Y (cons (mkChar C) $Nil))
; # (mkChar C)
  %71 = call i64 @mkChar(i32 %69)
; # (cons (mkChar C) $Nil)
  %72 = call i64 @cons(i64 %71, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  br label %$24
$26:
  %75 = phi i32 [%67, %$24] ; # C
  %76 = phi i64 [%66, %$24] ; # Y
; # drop
  %77 = inttoptr i64 %50 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  %79 = load i64, i64* %78
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %79, i64* %80
  br label %$23
$22:
  %81 = phi i32 [%44, %$20] ; # C
  br label %$23
$23:
  %82 = phi i32 [%75, %$26], [%81, %$22] ; # C
  %83 = phi i64 [%56, %$26], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
  br label %$14
$14:
  %84 = phi i64 [%33, %$17], [%83, %$23] ; # ->
  br label %$11
$11:
  %85 = phi i64 [%13, %$9], [%84, %$14] ; # ->
  ret i64 %85
}

define i64 @_pack(i64) align 8 {
$1:
; # (save -ZERO (let (X (cdr Exe) P (push 4 NIL ZERO NIL)) (link (ofs...
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %2 = load i64, i64* %1
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 10, i64* %5
  %6 = add i64 %4, 8
  %7 = inttoptr i64 %6 to i64*
  store i64 %2, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %8
; # (let (X (cdr Exe) P (push 4 NIL ZERO NIL)) (link (ofs P 2)) (whil...
; # (cdr Exe)
  %9 = inttoptr i64 %0 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (push 4 NIL ZERO NIL)
  %12 = alloca i64, i64 4, align 16
  store i64 4, i64* %12
  %13 = getelementptr i64, i64* %12, i32 2
  store i64 2, i64* %13
; # (ofs P 2)
  %14 = getelementptr i64, i64* %12, i32 2
; # (link (ofs P 2))
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %15 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  store i64 %17, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %20
; # (while (pair X) (pack (safe (eval (++ X))) P))
  br label %$2
$2:
  %21 = phi i64 [%11, %$1], [%28, %$5] ; # X
; # (pair X)
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$3, label %$4
$3:
  %24 = phi i64 [%21, %$2] ; # X
; # (++ X)
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
  %27 = getelementptr i64, i64* %25, i32 1
  %28 = load i64, i64* %27
; # (eval (++ X))
  %29 = and i64 %26, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$7, label %$6
$7:
  br label %$5
$6:
  %31 = and i64 %26, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  %33 = inttoptr i64 %26 to i64*
  %34 = load i64, i64* %33
  br label %$5
$8:
  %35 = call i64 @evList(i64 %26)
  br label %$5
$5:
  %36 = phi i64 [%26, %$7], [%34, %$9], [%35, %$8] ; # ->
; # (safe (eval (++ X)))
  %37 = inttoptr i64 %4 to i64*
  store i64 %36, i64* %37
; # (pack (safe (eval (++ X))) P)
  call void @pack(i64 %36, i64* %12)
  br label %$2
$4:
  %38 = phi i64 [%21, %$2] ; # X
; # (val 3 P)
  %39 = getelementptr i64, i64* %12, i32 2
  %40 = load i64, i64* %39
; # (consStr (val 3 P))
  %41 = call i64 @consStr(i64 %40)
; # drop
  %42 = inttoptr i64 %4 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %45
  ret i64 %41
}

define i64 @_glue(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X)))) (if (atom (eval (++ X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (if (atom (eval (++ X))) @ (let (Z (save @) P (push 4 NIL ZERO NI...
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (atom (eval (++ X)))
  %36 = and i64 %35, 15
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = phi i64 [%27, %$7] ; # X
  br label %$14
$13:
  %39 = phi i64 [%27, %$7] ; # X
; # (let (Z (save @) P (push 4 NIL ZERO NIL)) (link (ofs P 2)) (loop ...
; # (save @)
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 %35, i64* %44
  %45 = add i64 %43, 8
  %46 = inttoptr i64 %45 to i64*
  store i64 %41, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %47
; # (push 4 NIL ZERO NIL)
  %48 = alloca i64, i64 4, align 16
  store i64 4, i64* %48
  %49 = getelementptr i64, i64* %48, i32 2
  store i64 2, i64* %49
; # (ofs P 2)
  %50 = getelementptr i64, i64* %48, i32 2
; # (link (ofs P 2))
  %51 = ptrtoint i64* %50 to i64
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %51 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %53, i64* %55
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %56
; # (loop (pack (++ Z) P) (? (atom Z)) (pack Y P))
  br label %$15
$15:
  %57 = phi i64 [%39, %$13], [%65, %$16] ; # X
  %58 = phi i64 [%35, %$13], [%66, %$16] ; # Z
; # (++ Z)
  %59 = inttoptr i64 %58 to i64*
  %60 = load i64, i64* %59
  %61 = getelementptr i64, i64* %59, i32 1
  %62 = load i64, i64* %61
; # (pack (++ Z) P)
  call void @pack(i64 %60, i64* %48)
; # (? (atom Z))
; # (atom Z)
  %63 = and i64 %62, 15
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$17, label %$16
$16:
  %65 = phi i64 [%57, %$15] ; # X
  %66 = phi i64 [%62, %$15] ; # Z
; # (pack Y P)
  call void @pack(i64 %15, i64* %48)
  br label %$15
$17:
  %67 = phi i64 [%57, %$15] ; # X
  %68 = phi i64 [%62, %$15] ; # Z
  %69 = phi i64 [0, %$15] ; # ->
; # (val 3 P)
  %70 = getelementptr i64, i64* %48, i32 2
  %71 = load i64, i64* %70
; # (consStr (val 3 P))
  %72 = call i64 @consStr(i64 %71)
  br label %$14
$14:
  %73 = phi i64 [%38, %$12], [%67, %$17] ; # X
  %74 = phi i64 [%35, %$12], [%72, %$17] ; # ->
; # (drop *Safe)
  %75 = inttoptr i64 %19 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %78
  ret i64 %74
}

define i64 @_text(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (evSym X)) (if (nil? Y) Y (let (P (push 0 (xN...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (if (nil? Y) Y (let (P (push 0 (xName Exe Y) NIL) Q (link (ofs P ...
; # (nil? Y)
  %5 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
  br label %$4
$3:
  %7 = phi i64 [%3, %$1] ; # X
; # (let (P (push 0 (xName Exe Y) NIL) Q (link (ofs P 1) T) R (push 4...
; # (xName Exe Y)
  %8 = call i64 @xName(i64 %0, i64 %4)
; # (push 0 (xName Exe Y) NIL)
  %9 = alloca i64, i64 3, align 16
  store i64 0, i64* %9
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
; # (ofs P 1)
  %11 = getelementptr i64, i64* %9, i32 1
; # (link (ofs P 1) T)
  %12 = ptrtoint i64* %11 to i64
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %14 = load i64, i64* %13
  %15 = inttoptr i64 %12 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  store i64 %14, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %12, i64* %17
; # (push 4 NIL ZERO NIL)
  %18 = alloca i64, i64 4, align 16
  store i64 4, i64* %18
  %19 = getelementptr i64, i64* %18, i32 2
  store i64 2, i64* %19
; # (ofs R 2)
  %20 = getelementptr i64, i64* %18, i32 2
; # (link (ofs R 2))
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %21 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %26
; # (while (pair (shift X)) (setq A (link (push (eval (car X)) NIL)))...
  br label %$5
$5:
  %27 = phi i64 [%7, %$3], [%35, %$8] ; # X
  %28 = phi i64 [%21, %$3], [%49, %$8] ; # A
  %29 = phi i64 [0, %$3], [%56, %$8] ; # N
; # (shift X)
  %30 = inttoptr i64 %27 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (pair (shift X))
  %33 = and i64 %32, 15
  %34 = icmp eq i64 %33, 0
  br i1 %34, label %$6, label %$7
$6:
  %35 = phi i64 [%32, %$5] ; # X
  %36 = phi i64 [%28, %$5] ; # A
  %37 = phi i64 [%29, %$5] ; # N
; # (car X)
  %38 = inttoptr i64 %35 to i64*
  %39 = load i64, i64* %38
; # (eval (car X))
  %40 = and i64 %39, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$10, label %$9
$10:
  br label %$8
$9:
  %42 = and i64 %39, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$12, label %$11
$12:
  %44 = inttoptr i64 %39 to i64*
  %45 = load i64, i64* %44
  br label %$8
$11:
  %46 = call i64 @evList(i64 %39)
  br label %$8
$8:
  %47 = phi i64 [%39, %$10], [%45, %$12], [%46, %$11] ; # ->
; # (push (eval (car X)) NIL)
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %47, i64* %50
; # (link (push (eval (car X)) NIL))
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %52 = load i64, i64* %51
  %53 = inttoptr i64 %49 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  store i64 %52, i64* %54
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %55
; # (inc 'N)
  %56 = add i64 %37, 1
  br label %$5
$7:
  %57 = phi i64 [%32, %$5] ; # X
  %58 = phi i64 [%28, %$5] ; # A
  %59 = phi i64 [%29, %$5] ; # N
; # (while (setq C (symByte P)) (cond ((<> C (char "@")) (byteSym C R...
  br label %$13
$13:
  %60 = phi i64 [%57, %$7], [%141, %$16] ; # X
  %61 = phi i64 [%58, %$7], [%142, %$16] ; # A
  %62 = phi i64 [%59, %$7], [%143, %$16] ; # N
; # (symByte P)
  %63 = call i8 @symByte(i64* %9)
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %$14, label %$15
$14:
  %65 = phi i64 [%60, %$13] ; # X
  %66 = phi i64 [%61, %$13] ; # A
  %67 = phi i64 [%62, %$13] ; # N
  %68 = phi i8 [%63, %$13] ; # C
; # (cond ((<> C (char "@")) (byteSym C R)) ((== (setq C (symByte P))...
; # (<> C (char "@"))
  %69 = icmp ne i8 %68, 64
  br i1 %69, label %$18, label %$17
$18:
  %70 = phi i64 [%65, %$14] ; # X
  %71 = phi i64 [%66, %$14] ; # A
  %72 = phi i64 [%67, %$14] ; # N
  %73 = phi i8 [%68, %$14] ; # C
; # (byteSym C R)
  call void @byteSym(i8 %73, i64* %18)
  br label %$16
$17:
  %74 = phi i64 [%65, %$14] ; # X
  %75 = phi i64 [%66, %$14] ; # A
  %76 = phi i64 [%67, %$14] ; # N
  %77 = phi i8 [%68, %$14] ; # C
; # (symByte P)
  %78 = call i8 @symByte(i64* %9)
; # (== (setq C (symByte P)) (char "@"))
  %79 = icmp eq i8 %78, 64
  br i1 %79, label %$20, label %$19
$20:
  %80 = phi i64 [%74, %$17] ; # X
  %81 = phi i64 [%75, %$17] ; # A
  %82 = phi i64 [%76, %$17] ; # N
  %83 = phi i8 [%78, %$17] ; # C
; # (byteSym C R)
  call void @byteSym(i8 %83, i64* %18)
  br label %$16
$19:
  %84 = phi i64 [%74, %$17] ; # X
  %85 = phi i64 [%75, %$17] ; # A
  %86 = phi i64 [%76, %$17] ; # N
  %87 = phi i8 [%78, %$17] ; # C
; # (dec 'C (char "0"))
  %88 = sub i8 %87, 48
; # (gt0 (dec 'C (char "0")))
  %89 = icmp sgt i8 %88, 0
  br i1 %89, label %$22, label %$21
$22:
  %90 = phi i64 [%84, %$19] ; # X
  %91 = phi i64 [%85, %$19] ; # A
  %92 = phi i64 [%86, %$19] ; # N
  %93 = phi i8 [%88, %$19] ; # C
; # (when (> C 9) (dec 'C 7))
; # (> C 9)
  %94 = icmp ugt i8 %93, 9
  br i1 %94, label %$23, label %$24
$23:
  %95 = phi i64 [%90, %$22] ; # X
  %96 = phi i64 [%91, %$22] ; # A
  %97 = phi i64 [%92, %$22] ; # N
  %98 = phi i8 [%93, %$22] ; # C
; # (dec 'C 7)
  %99 = sub i8 %98, 7
  br label %$24
$24:
  %100 = phi i64 [%90, %$22], [%95, %$23] ; # X
  %101 = phi i64 [%91, %$22], [%96, %$23] ; # A
  %102 = phi i64 [%92, %$22], [%97, %$23] ; # N
  %103 = phi i8 [%93, %$22], [%99, %$23] ; # C
; # (when (ge0 (setq C (- N (i64 C)))) (let I A (while (ge0 (dec 'C))...
; # (i64 C)
  %104 = zext i8 %103 to i64
; # (- N (i64 C))
  %105 = sub i64 %102, %104
; # (ge0 (setq C (- N (i64 C))))
  %106 = icmp sge i64 %105, 0
  br i1 %106, label %$25, label %$26
$25:
  %107 = phi i64 [%100, %$24] ; # X
  %108 = phi i64 [%101, %$24] ; # A
  %109 = phi i64 [%102, %$24] ; # N
  %110 = phi i64 [%105, %$24] ; # C
; # (let I A (while (ge0 (dec 'C)) (shift I)) (pack (val I) R))
; # (while (ge0 (dec 'C)) (shift I))
  br label %$27
$27:
  %111 = phi i64 [%107, %$25], [%118, %$28] ; # X
  %112 = phi i64 [%108, %$25], [%119, %$28] ; # A
  %113 = phi i64 [%109, %$25], [%120, %$28] ; # N
  %114 = phi i64 [%110, %$25], [%121, %$28] ; # C
  %115 = phi i64 [%108, %$25], [%125, %$28] ; # I
; # (dec 'C)
  %116 = sub i64 %114, 1
; # (ge0 (dec 'C))
  %117 = icmp sge i64 %116, 0
  br i1 %117, label %$28, label %$29
$28:
  %118 = phi i64 [%111, %$27] ; # X
  %119 = phi i64 [%112, %$27] ; # A
  %120 = phi i64 [%113, %$27] ; # N
  %121 = phi i64 [%116, %$27] ; # C
  %122 = phi i64 [%115, %$27] ; # I
; # (shift I)
  %123 = inttoptr i64 %122 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  br label %$27
$29:
  %126 = phi i64 [%111, %$27] ; # X
  %127 = phi i64 [%112, %$27] ; # A
  %128 = phi i64 [%113, %$27] ; # N
  %129 = phi i64 [%116, %$27] ; # C
  %130 = phi i64 [%115, %$27] ; # I
; # (val I)
  %131 = inttoptr i64 %130 to i64*
  %132 = load i64, i64* %131
; # (pack (val I) R)
  call void @pack(i64 %132, i64* %18)
  br label %$26
$26:
  %133 = phi i64 [%100, %$24], [%126, %$29] ; # X
  %134 = phi i64 [%101, %$24], [%127, %$29] ; # A
  %135 = phi i64 [%102, %$24], [%128, %$29] ; # N
  %136 = phi i64 [%105, %$24], [%129, %$29] ; # C
  br label %$16
$21:
  %137 = phi i64 [%84, %$19] ; # X
  %138 = phi i64 [%85, %$19] ; # A
  %139 = phi i64 [%86, %$19] ; # N
  %140 = phi i8 [%88, %$19] ; # C
  br label %$16
$16:
  %141 = phi i64 [%70, %$18], [%80, %$20], [%133, %$26], [%137, %$21] ; # X
  %142 = phi i64 [%71, %$18], [%81, %$20], [%134, %$26], [%138, %$21] ; # A
  %143 = phi i64 [%72, %$18], [%82, %$20], [%135, %$26], [%139, %$21] ; # N
  br label %$13
$15:
  %144 = phi i64 [%60, %$13] ; # X
  %145 = phi i64 [%61, %$13] ; # A
  %146 = phi i64 [%62, %$13] ; # N
  %147 = phi i8 [%63, %$13] ; # C
; # (val 3 R)
  %148 = getelementptr i64, i64* %18, i32 2
  %149 = load i64, i64* %148
; # (consStr (val 3 R))
  %150 = call i64 @consStr(i64 %149)
; # (drop *Safe)
  %151 = inttoptr i64 %12 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  %154 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %153, i64* %154
  br label %$4
$4:
  %155 = phi i64 [%6, %$2], [%144, %$15] ; # X
  %156 = phi i64 [%4, %$2], [%150, %$15] ; # ->
  ret i64 %156
}

define i1 @preStr(i64, i8, i64*) align 8 {
$1:
; # (let (Q (push 0 (i64 Nm)) C (symByte Q)) (loop (? (<> B C) NO) (?...
; # (i64 Nm)
; # (push 0 (i64 Nm))
  %3 = alloca i64, i64 2, align 16
  store i64 0, i64* %3
  %4 = getelementptr i64, i64* %3, i32 1
  store i64 %0, i64* %4
; # (symByte Q)
  %5 = call i8 @symByte(i64* %3)
; # (loop (? (<> B C) NO) (? (=0 (setq C (symByte Q))) YES) (? (=0 (s...
  br label %$2
$2:
  %6 = phi i8 [%1, %$1], [%23, %$8] ; # B
  %7 = phi i8 [%5, %$1], [%24, %$8] ; # C
; # (? (<> B C) NO)
; # (<> B C)
  %8 = icmp ne i8 %6, %7
  br i1 %8, label %$5, label %$3
$5:
  %9 = phi i8 [%6, %$2] ; # B
  %10 = phi i8 [%7, %$2] ; # C
  br label %$4
$3:
  %11 = phi i8 [%6, %$2] ; # B
  %12 = phi i8 [%7, %$2] ; # C
; # (? (=0 (setq C (symByte Q))) YES)
; # (symByte Q)
  %13 = call i8 @symByte(i64* %3)
; # (=0 (setq C (symByte Q)))
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  %15 = phi i8 [%11, %$3] ; # B
  %16 = phi i8 [%13, %$3] ; # C
  br label %$4
$6:
  %17 = phi i8 [%11, %$3] ; # B
  %18 = phi i8 [%13, %$3] ; # C
; # (? (=0 (setq B (symByte P))) NO)
; # (symByte P)
  %19 = call i8 @symByte(i64* %2)
; # (=0 (setq B (symByte P)))
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %$9, label %$8
$9:
  %21 = phi i8 [%19, %$6] ; # B
  %22 = phi i8 [%18, %$6] ; # C
  br label %$4
$8:
  %23 = phi i8 [%19, %$6] ; # B
  %24 = phi i8 [%18, %$6] ; # C
  br label %$2
$4:
  %25 = phi i8 [%9, %$5], [%15, %$7], [%21, %$9] ; # B
  %26 = phi i8 [%10, %$5], [%16, %$7], [%22, %$9] ; # C
  %27 = phi i1 [0, %$5], [1, %$7], [0, %$9] ; # ->
  ret i1 %27
}

define i1 @subStr(i64, i64) align 8 {
$1:
; # (or (nil? X) (== ZERO (setq X (xName 0 X))) (let (P (push 0 (xNam...
; # (nil? X)
  %2 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %2, label %$2, label %$3
$3:
  %3 = phi i64 [%0, %$1] ; # X
; # (xName 0 X)
  %4 = call i64 @xName(i64 0, i64 %3)
; # (== ZERO (setq X (xName 0 X)))
  %5 = icmp eq i64 2, %4
  br i1 %5, label %$2, label %$4
$4:
  %6 = phi i64 [%4, %$3] ; # X
; # (let (P (push 0 (xName 0 Y)) B T) (loop (? (=0 (setq B (symByte P...
; # (xName 0 Y)
  %7 = call i64 @xName(i64 0, i64 %1)
; # (push 0 (xName 0 Y))
  %8 = alloca i64, i64 2, align 16
  store i64 0, i64* %8
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
; # (loop (? (=0 (setq B (symByte P))) NO) (let (Cnt (val P) Nm (val ...
  br label %$5
$5:
  %10 = phi i64 [%6, %$4], [%23, %$9] ; # X
; # (? (=0 (setq B (symByte P))) NO)
; # (symByte P)
  %11 = call i8 @symByte(i64* %8)
; # (=0 (setq B (symByte P)))
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %$8, label %$6
$8:
  %13 = phi i64 [%10, %$5] ; # X
  %14 = phi i8 [%11, %$5] ; # B
  br label %$7
$6:
  %15 = phi i64 [%10, %$5] ; # X
  %16 = phi i8 [%11, %$5] ; # B
; # (let (Cnt (val P) Nm (val 2 P)) (? (preStr X B P) YES) (set P Cnt...
; # (val P)
  %17 = load i64, i64* %8
; # (val 2 P)
  %18 = getelementptr i64, i64* %8, i32 1
  %19 = load i64, i64* %18
; # (? (preStr X B P) YES)
; # (preStr X B P)
  %20 = call i1 @preStr(i64 %15, i8 %16, i64* %8)
  br i1 %20, label %$10, label %$9
$10:
  %21 = phi i64 [%15, %$6] ; # X
  %22 = phi i8 [%16, %$6] ; # B
  br label %$7
$9:
  %23 = phi i64 [%15, %$6] ; # X
  %24 = phi i8 [%16, %$6] ; # B
; # (set P Cnt 2 P Nm)
  store i64 %17, i64* %8
  %25 = getelementptr i64, i64* %8, i32 1
  store i64 %19, i64* %25
  br label %$5
$7:
  %26 = phi i64 [%13, %$8], [%21, %$10] ; # X
  %27 = phi i8 [%14, %$8], [%22, %$10] ; # B
  %28 = phi i1 [0, %$8], [1, %$10] ; # ->
  br label %$2
$2:
  %29 = phi i64 [%0, %$1], [%4, %$3], [%26, %$7] ; # X
  %30 = phi i1 [1, %$1], [1, %$3], [%28, %$7] ; # ->
  ret i1 %30
}

define i64 @_preQ(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (evSym X)) Z (evSym (shift X))) (cond (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (save (evSym X))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (shift X)
  %13 = inttoptr i64 %3 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (evSym (shift X))
  %16 = call i64 @evSym(i64 %15)
; # (cond ((nil? Y) Z) ((== ZERO (setq Y (xName Exe Y))) Z) (T (let P...
; # (nil? Y)
  %17 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %17, label %$4, label %$3
$4:
  %18 = phi i64 [%4, %$1] ; # Y
  br label %$2
$3:
  %19 = phi i64 [%4, %$1] ; # Y
; # (xName Exe Y)
  %20 = call i64 @xName(i64 %0, i64 %19)
; # (== ZERO (setq Y (xName Exe Y)))
  %21 = icmp eq i64 2, %20
  br i1 %21, label %$6, label %$5
$6:
  %22 = phi i64 [%20, %$3] ; # Y
  br label %$2
$5:
  %23 = phi i64 [%20, %$3] ; # Y
; # (let P (push 0 (xName Exe Z)) (cond ((=0 (symByte P)) $Nil) ((pre...
; # (xName Exe Z)
  %24 = call i64 @xName(i64 %0, i64 %16)
; # (push 0 (xName Exe Z))
  %25 = alloca i64, i64 2, align 16
  store i64 0, i64* %25
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
; # (cond ((=0 (symByte P)) $Nil) ((preStr Y @ P) Z) (T $Nil))
; # (symByte P)
  %27 = call i8 @symByte(i64* %25)
; # (=0 (symByte P))
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %$9, label %$8
$9:
  %29 = phi i64 [%23, %$5] ; # Y
  br label %$7
$8:
  %30 = phi i64 [%23, %$5] ; # Y
; # (preStr Y @ P)
  %31 = call i1 @preStr(i64 %30, i8 %27, i64* %25)
  br i1 %31, label %$11, label %$10
$11:
  %32 = phi i64 [%30, %$8] ; # Y
  br label %$7
$10:
  %33 = phi i64 [%30, %$8] ; # Y
  br label %$7
$7:
  %34 = phi i64 [%29, %$9], [%32, %$11], [%33, %$10] ; # Y
  %35 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%16, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  br label %$2
$2:
  %36 = phi i64 [%18, %$4], [%22, %$6], [%34, %$7] ; # Y
  %37 = phi i64 [%16, %$4], [%16, %$6], [%35, %$7] ; # ->
; # (drop *Safe)
  %38 = inttoptr i64 %8 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  ret i64 %37
}

define i64 @_subQ(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (evSym X)) Z (evSym (shift X))) (if (su...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (save (evSym X))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (shift X)
  %13 = inttoptr i64 %3 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (evSym (shift X))
  %16 = call i64 @evSym(i64 %15)
; # (if (subStr Y Z) Z $Nil)
; # (subStr Y Z)
  %17 = call i1 @subStr(i64 %4, i64 %16)
  br i1 %17, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %18 = phi i64 [%16, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
; # (drop *Safe)
  %19 = inttoptr i64 %8 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %22
  ret i64 %18
}

define i64 @_val(i64) align 8 {
$1:
; # (let V (needVar Exe (eval (cadr Exe))) (when (and (sym? V) (sym? ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needVar Exe (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
; # (when (and (sym? V) (sym? (val (tail V)))) (dbFetch Exe V))
; # (and (sym? V) (sym? (val (tail V))))
; # (sym? V)
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$10, label %$9
$10:
; # (tail V)
  %18 = add i64 %13, -8
; # (val (tail V))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (sym? (val (tail V)))
  %21 = and i64 %20, 8
  %22 = icmp ne i64 %21, 0
  br label %$9
$9:
  %23 = phi i1 [0, %$8], [%22, %$10] ; # ->
  br i1 %23, label %$11, label %$12
$11:
; # (dbFetch Exe V)
  call void @dbFetch(i64 %0, i64 %13)
  br label %$12
$12:
; # (val V)
  %24 = inttoptr i64 %13 to i64*
  %25 = load i64, i64* %24
  ret i64 %25
}

define i64 @_set(i64) align 8 {
$1:
; # (save -ZERO (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (...
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %2 = load i64, i64* %1
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 10, i64* %5
  %6 = add i64 %4, 8
  %7 = inttoptr i64 %6 to i64*
  store i64 %2, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %8
; # (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (eval (++ X))...
; # (cdr Exe)
  %9 = inttoptr i64 %0 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (loop (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sy...
  br label %$2
$2:
  %12 = phi i64 [%11, %$1], [%59, %$23] ; # X
; # (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sym? Y) ...
; # (++ X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
  %15 = getelementptr i64, i64* %13, i32 1
  %16 = load i64, i64* %15
; # (eval (++ X))
  %17 = and i64 %14, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %14, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %14 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %14)
  br label %$3
$3:
  %24 = phi i64 [%14, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$8, label %$9
$8:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$9:
  %27 = icmp uge i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %27, label %$11, label %$10
$11:
  %28 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %24
  br label %$10
$10:
  %29 = phi i1 [0, %$9], [%28, %$11] ; # ->
  br i1 %29, label %$12, label %$13
$12:
  call void @protErr(i64 %0, i64 %24)
  unreachable
$13:
; # (safe (needChkVar Exe (eval (++ X))))
  %30 = inttoptr i64 %4 to i64*
  store i64 %24, i64* %30
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %31 = and i64 %24, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = phi i64 [%16, %$13] ; # X
; # (tail Y)
  %34 = add i64 %24, -8
; # (val (tail Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (sym? (val (tail Y)))
  %37 = and i64 %36, 8
  %38 = icmp ne i64 %37, 0
  br label %$14
$14:
  %39 = phi i64 [%16, %$13], [%33, %$15] ; # X
  %40 = phi i1 [0, %$13], [%38, %$15] ; # ->
  br i1 %40, label %$16, label %$17
$16:
  %41 = phi i64 [%39, %$14] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %24)
  br label %$17
$17:
  %42 = phi i64 [%39, %$14], [%41, %$16] ; # X
; # (let Z (eval (++ X)) (set Y Z) (? (atom X) Z))
; # (++ X)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (eval (++ X))
  %47 = and i64 %44, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$20, label %$19
$20:
  br label %$18
$19:
  %49 = and i64 %44, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  %51 = inttoptr i64 %44 to i64*
  %52 = load i64, i64* %51
  br label %$18
$21:
  %53 = call i64 @evList(i64 %44)
  br label %$18
$18:
  %54 = phi i64 [%44, %$20], [%52, %$22], [%53, %$21] ; # ->
; # (set Y Z)
  %55 = inttoptr i64 %24 to i64*
  store i64 %54, i64* %55
; # (? (atom X) Z)
; # (atom X)
  %56 = and i64 %46, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$25, label %$23
$25:
  %58 = phi i64 [%46, %$18] ; # X
  br label %$24
$23:
  %59 = phi i64 [%46, %$18] ; # X
  br label %$2
$24:
  %60 = phi i64 [%58, %$25] ; # X
  %61 = phi i64 [%54, %$25] ; # ->
; # drop
  %62 = inttoptr i64 %4 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  %65 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %64, i64* %65
  ret i64 %61
}

define i64 @_setq(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (set (needChkVar Exe (++ X)) (eval ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (set (needChkVar Exe (++ X)) (eval (++ X))) (? (atom...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%30, %$14] ; # X
; # (let Y (set (needChkVar Exe (++ X)) (eval (++ X))) (? (atom X) Y)...
; # (set (needChkVar Exe (++ X)) (eval (++ X)))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
; # (++ X)
  %14 = inttoptr i64 %8 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
; # (eval (++ X))
  %18 = and i64 %15, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
  br label %$9
$10:
  %20 = and i64 %15, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  %22 = inttoptr i64 %15 to i64*
  %23 = load i64, i64* %22
  br label %$9
$12:
  %24 = call i64 @evList(i64 %15)
  br label %$9
$9:
  %25 = phi i64 [%15, %$11], [%23, %$13], [%24, %$12] ; # ->
  %26 = inttoptr i64 %6 to i64*
  store i64 %25, i64* %26
; # (? (atom X) Y)
; # (atom X)
  %27 = and i64 %17, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$16, label %$14
$16:
  %29 = phi i64 [%17, %$9] ; # X
  br label %$15
$14:
  %30 = phi i64 [%17, %$9] ; # X
  br label %$2
$15:
  %31 = phi i64 [%29, %$16] ; # X
  %32 = phi i64 [%25, %$16] ; # ->
  ret i64 %32
}

define i64 @_swap(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
; # (tail Y)
  %31 = add i64 %15, -8
; # (val (tail Y))
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (sym? (val (tail Y)))
  %34 = and i64 %33, 8
  %35 = icmp ne i64 %34, 0
  br label %$13
$13:
  %36 = phi i1 [0, %$12], [%35, %$14] ; # ->
  br i1 %36, label %$15, label %$16
$15:
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
; # (let (Z (eval (car X)) V (val Y)) (set Y Z) V)
; # (car X)
  %37 = inttoptr i64 %7 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$19, label %$18
$19:
  br label %$17
$18:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$21, label %$20
$21:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$17
$20:
  %45 = call i64 @evList(i64 %38)
  br label %$17
$17:
  %46 = phi i64 [%38, %$19], [%44, %$21], [%45, %$20] ; # ->
; # (val Y)
  %47 = inttoptr i64 %15 to i64*
  %48 = load i64, i64* %47
; # (set Y Z)
  %49 = inttoptr i64 %15 to i64*
  store i64 %46, i64* %49
; # (drop *Safe)
  %50 = inttoptr i64 %24 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %48
}

define i64 @_xchg(i64) align 8 {
$1:
; # (save -ZERO (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (...
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %2 = load i64, i64* %1
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 10, i64* %5
  %6 = add i64 %4, 8
  %7 = inttoptr i64 %6 to i64*
  store i64 %2, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %8
; # (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (eval (++ X))...
; # (cdr Exe)
  %9 = inttoptr i64 %0 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (loop (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sy...
  br label %$2
$2:
  %12 = phi i64 [%11, %$1], [%84, %$33] ; # X
; # (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sym? Y) ...
; # (++ X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
  %15 = getelementptr i64, i64* %13, i32 1
  %16 = load i64, i64* %15
; # (eval (++ X))
  %17 = and i64 %14, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %14, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %14 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %14)
  br label %$3
$3:
  %24 = phi i64 [%14, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$8, label %$9
$8:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$9:
  %27 = icmp uge i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %27, label %$11, label %$10
$11:
  %28 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %24
  br label %$10
$10:
  %29 = phi i1 [0, %$9], [%28, %$11] ; # ->
  br i1 %29, label %$12, label %$13
$12:
  call void @protErr(i64 %0, i64 %24)
  unreachable
$13:
; # (safe (needChkVar Exe (eval (++ X))))
  %30 = inttoptr i64 %4 to i64*
  store i64 %24, i64* %30
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %31 = and i64 %24, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = phi i64 [%16, %$13] ; # X
; # (tail Y)
  %34 = add i64 %24, -8
; # (val (tail Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (sym? (val (tail Y)))
  %37 = and i64 %36, 8
  %38 = icmp ne i64 %37, 0
  br label %$14
$14:
  %39 = phi i64 [%16, %$13], [%33, %$15] ; # X
  %40 = phi i1 [0, %$13], [%38, %$15] ; # ->
  br i1 %40, label %$16, label %$17
$16:
  %41 = phi i64 [%39, %$14] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %24)
  br label %$17
$17:
  %42 = phi i64 [%39, %$14], [%41, %$16] ; # X
; # (let Z (needChkVar Exe (eval (++ X))) (when (and (sym? Z) (sym? (...
; # (++ X)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (eval (++ X))
  %47 = and i64 %44, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$20, label %$19
$20:
  br label %$18
$19:
  %49 = and i64 %44, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  %51 = inttoptr i64 %44 to i64*
  %52 = load i64, i64* %51
  br label %$18
$21:
  %53 = call i64 @evList(i64 %44)
  br label %$18
$18:
  %54 = phi i64 [%44, %$20], [%52, %$22], [%53, %$21] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %55 = and i64 %54, 6
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$23, label %$24
$23:
  call void @varErr(i64 %0, i64 %54)
  unreachable
$24:
  %57 = icmp uge i64 %54, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %57, label %$26, label %$25
$26:
  %58 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %54
  br label %$25
$25:
  %59 = phi i1 [0, %$24], [%58, %$26] ; # ->
  br i1 %59, label %$27, label %$28
$27:
  call void @protErr(i64 %0, i64 %54)
  unreachable
$28:
; # (when (and (sym? Z) (sym? (val (tail Z)))) (dbTouch Exe Z))
; # (and (sym? Z) (sym? (val (tail Z))))
; # (sym? Z)
  %60 = and i64 %54, 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$30, label %$29
$30:
  %62 = phi i64 [%46, %$28] ; # X
  %63 = phi i64 [%54, %$28] ; # Z
; # (tail Z)
  %64 = add i64 %63, -8
; # (val (tail Z))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (sym? (val (tail Z)))
  %67 = and i64 %66, 8
  %68 = icmp ne i64 %67, 0
  br label %$29
$29:
  %69 = phi i64 [%46, %$28], [%62, %$30] ; # X
  %70 = phi i64 [%54, %$28], [%63, %$30] ; # Z
  %71 = phi i1 [0, %$28], [%68, %$30] ; # ->
  br i1 %71, label %$31, label %$32
$31:
  %72 = phi i64 [%69, %$29] ; # X
  %73 = phi i64 [%70, %$29] ; # Z
; # (dbTouch Exe Z)
  call void @dbTouch(i64 %0, i64 %73)
  br label %$32
$32:
  %74 = phi i64 [%69, %$29], [%72, %$31] ; # X
  %75 = phi i64 [%70, %$29], [%73, %$31] ; # Z
; # (xchg Y Z)
  %76 = inttoptr i64 %24 to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %75 to i64*
  %79 = load i64, i64* %78
  store i64 %79, i64* %76
  store i64 %77, i64* %78
; # (? (atom X) Z)
; # (atom X)
  %80 = and i64 %74, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$35, label %$33
$35:
  %82 = phi i64 [%74, %$32] ; # X
  %83 = phi i64 [%77, %$32] ; # Z
  br label %$34
$33:
  %84 = phi i64 [%74, %$32] ; # X
  %85 = phi i64 [%77, %$32] ; # Z
  br label %$2
$34:
  %86 = phi i64 [%82, %$35] ; # X
  %87 = phi i64 [%83, %$35] ; # ->
; # drop
  %88 = inttoptr i64 %4 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %90, i64* %91
  ret i64 %87
}

define i64 @_on(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) $T) (? (atom ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) $T) (? (atom X) $T))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) $T)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), i64* %14
; # (? (atom X) $T)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$11] ; # ->
  ret i64 %20
}

define i64 @_off(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) $Nil) (? (ato...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) $Nil) (? (atom X) $Nil))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) $Nil)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %14
; # (? (atom X) $Nil)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  ret i64 %20
}

define i64 @_onOff(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let (Y (needChkVar Exe (++ X)) Z (if (nil...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let (Y (needChkVar Exe (++ X)) Z (if (nil? (val Y)) $T $Ni...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%25, %$12] ; # X
; # (let (Y (needChkVar Exe (++ X)) Z (if (nil? (val Y)) $T $Nil)) (s...
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
; # (if (nil? (val Y)) $T $Nil)
; # (val Y)
  %14 = inttoptr i64 %6 to i64*
  %15 = load i64, i64* %14
; # (nil? (val Y))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$10
$9:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$11
$10:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$11
$11:
  %19 = phi i64 [%17, %$9], [%18, %$10] ; # X
  %20 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
; # (set Y Z)
  %21 = inttoptr i64 %6 to i64*
  store i64 %20, i64* %21
; # (? (atom X) Z)
; # (atom X)
  %22 = and i64 %19, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$12
$14:
  %24 = phi i64 [%19, %$11] ; # X
  br label %$13
$12:
  %25 = phi i64 [%19, %$11] ; # X
  br label %$2
$13:
  %26 = phi i64 [%24, %$14] ; # X
  %27 = phi i64 [%20, %$14] ; # ->
  ret i64 %27
}

define i64 @_zero(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) ZERO) (? (ato...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) ZERO) (? (atom X) ZERO))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) ZERO)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 2, i64* %14
; # (? (atom X) ZERO)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [2, %$11] ; # ->
  ret i64 %20
}

define i64 @_one(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) ONE) (? (atom...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) ONE) (? (atom X) ONE))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) ONE)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 18, i64* %14
; # (? (atom X) ONE)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [18, %$11] ; # ->
  ret i64 %20
}

define i64 @_default(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (needChkVar Exe (++ X)) (when (nil?...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (needChkVar Exe (++ X)) (when (nil? (val Y)) (set Y ...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%38, %$16] ; # X
; # (let Y (needChkVar Exe (++ X)) (when (nil? (val Y)) (set Y (eval ...
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
; # (when (nil? (val Y)) (set Y (eval (car X))))
; # (val Y)
  %14 = inttoptr i64 %6 to i64*
  %15 = load i64, i64* %14
; # (nil? (val Y))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$10
$9:
  %17 = phi i64 [%8, %$8] ; # X
; # (set Y (eval (car X)))
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (eval (car X))
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  br label %$11
$12:
  %22 = and i64 %19, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$15, label %$14
$15:
  %24 = inttoptr i64 %19 to i64*
  %25 = load i64, i64* %24
  br label %$11
$14:
  %26 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %27 = phi i64 [%19, %$13], [%25, %$15], [%26, %$14] ; # ->
  %28 = inttoptr i64 %6 to i64*
  store i64 %27, i64* %28
  br label %$10
$10:
  %29 = phi i64 [%8, %$8], [%17, %$11] ; # X
; # (? (atom (shift X)) (val Y))
; # (shift X)
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (atom (shift X))
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$18, label %$16
$18:
  %35 = phi i64 [%32, %$10] ; # X
; # (val Y)
  %36 = inttoptr i64 %6 to i64*
  %37 = load i64, i64* %36
  br label %$17
$16:
  %38 = phi i64 [%32, %$10] ; # X
  br label %$2
$17:
  %39 = phi i64 [%35, %$18] ; # X
  %40 = phi i64 [%37, %$18] ; # ->
  ret i64 %40
}

define i64 @_push(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (loop (let Z (eval (++ X)) (set Y (cons Z (val Y))) (? (atom X) Z...
  br label %$17
$17:
  %41 = phi i64 [%40, %$16], [%61, %$23] ; # X
; # (let Z (eval (++ X)) (set Y (cons Z (val Y))) (? (atom X) Z))
; # (++ X)
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
; # (eval (++ X))
  %46 = and i64 %43, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$20, label %$19
$20:
  br label %$18
$19:
  %48 = and i64 %43, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$22, label %$21
$22:
  %50 = inttoptr i64 %43 to i64*
  %51 = load i64, i64* %50
  br label %$18
$21:
  %52 = call i64 @evList(i64 %43)
  br label %$18
$18:
  %53 = phi i64 [%43, %$20], [%51, %$22], [%52, %$21] ; # ->
; # (set Y (cons Z (val Y)))
; # (val Y)
  %54 = inttoptr i64 %15 to i64*
  %55 = load i64, i64* %54
; # (cons Z (val Y))
  %56 = call i64 @cons(i64 %53, i64 %55)
  %57 = inttoptr i64 %15 to i64*
  store i64 %56, i64* %57
; # (? (atom X) Z)
; # (atom X)
  %58 = and i64 %45, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$25, label %$23
$25:
  %60 = phi i64 [%45, %$18] ; # X
  br label %$24
$23:
  %61 = phi i64 [%45, %$18] ; # X
  br label %$17
$24:
  %62 = phi i64 [%60, %$25] ; # X
  %63 = phi i64 [%53, %$25] ; # ->
; # (drop *Safe)
  %64 = inttoptr i64 %24 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  %66 = load i64, i64* %65
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %66, i64* %67
  ret i64 %63
}

define i64 @_push1(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (loop (let (Z (eval (++ X)) V (val Y)) (unless (member Z V) (set ...
  br label %$17
$17:
  %41 = phi i64 [%40, %$16], [%78, %$31] ; # X
; # (let (Z (eval (++ X)) V (val Y)) (unless (member Z V) (set Y (con...
; # (++ X)
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
; # (eval (++ X))
  %46 = and i64 %43, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$20, label %$19
$20:
  br label %$18
$19:
  %48 = and i64 %43, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$22, label %$21
$22:
  %50 = inttoptr i64 %43 to i64*
  %51 = load i64, i64* %50
  br label %$18
$21:
  %52 = call i64 @evList(i64 %43)
  br label %$18
$18:
  %53 = phi i64 [%43, %$20], [%51, %$22], [%52, %$21] ; # ->
; # (val Y)
  %54 = inttoptr i64 %15 to i64*
  %55 = load i64, i64* %54
; # (unless (member Z V) (set Y (cons Z V)))
; # (member Z V)
  br label %$23
$23:
  %56 = phi i64 [%55, %$18], [%68, %$27] ; # L
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$26, label %$24
$26:
  %59 = phi i64 [%56, %$23] ; # L
  br label %$25
$24:
  %60 = phi i64 [%56, %$23] ; # L
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  %63 = call i1 @equal(i64 %53, i64 %62)
  br i1 %63, label %$28, label %$27
$28:
  %64 = phi i64 [%60, %$24] ; # L
  br label %$25
$27:
  %65 = phi i64 [%60, %$24] ; # L
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
  br label %$23
$25:
  %69 = phi i64 [%59, %$26], [%64, %$28] ; # L
  %70 = phi i1 [0, %$26], [1, %$28] ; # ->
  br i1 %70, label %$30, label %$29
$29:
  %71 = phi i64 [%45, %$25] ; # X
; # (set Y (cons Z V))
; # (cons Z V)
  %72 = call i64 @cons(i64 %53, i64 %55)
  %73 = inttoptr i64 %15 to i64*
  store i64 %72, i64* %73
  br label %$30
$30:
  %74 = phi i64 [%45, %$25], [%71, %$29] ; # X
; # (? (atom X) Z)
; # (atom X)
  %75 = and i64 %74, 15
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$33, label %$31
$33:
  %77 = phi i64 [%74, %$30] ; # X
  br label %$32
$31:
  %78 = phi i64 [%74, %$30] ; # X
  br label %$17
$32:
  %79 = phi i64 [%77, %$33] ; # X
  %80 = phi i64 [%53, %$33] ; # ->
; # (drop *Safe)
  %81 = inttoptr i64 %24 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_push1q(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (loop (let (Z (eval (++ X)) V (val Y)) (unless (memq Z V) (set Y ...
  br label %$17
$17:
  %41 = phi i64 [%40, %$16], [%78, %$31] ; # X
; # (let (Z (eval (++ X)) V (val Y)) (unless (memq Z V) (set Y (cons ...
; # (++ X)
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
; # (eval (++ X))
  %46 = and i64 %43, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$20, label %$19
$20:
  br label %$18
$19:
  %48 = and i64 %43, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$22, label %$21
$22:
  %50 = inttoptr i64 %43 to i64*
  %51 = load i64, i64* %50
  br label %$18
$21:
  %52 = call i64 @evList(i64 %43)
  br label %$18
$18:
  %53 = phi i64 [%43, %$20], [%51, %$22], [%52, %$21] ; # ->
; # (val Y)
  %54 = inttoptr i64 %15 to i64*
  %55 = load i64, i64* %54
; # (unless (memq Z V) (set Y (cons Z V)))
; # (memq Z V)
  br label %$23
$23:
  %56 = phi i64 [%55, %$18], [%68, %$27] ; # L
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$26, label %$24
$26:
  %59 = phi i64 [%56, %$23] ; # L
  br label %$25
$24:
  %60 = phi i64 [%56, %$23] ; # L
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  %63 = icmp eq i64 %53, %62
  br i1 %63, label %$28, label %$27
$28:
  %64 = phi i64 [%60, %$24] ; # L
  br label %$25
$27:
  %65 = phi i64 [%60, %$24] ; # L
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
  br label %$23
$25:
  %69 = phi i64 [%59, %$26], [%64, %$28] ; # L
  %70 = phi i1 [0, %$26], [1, %$28] ; # ->
  br i1 %70, label %$30, label %$29
$29:
  %71 = phi i64 [%45, %$25] ; # X
; # (set Y (cons Z V))
; # (cons Z V)
  %72 = call i64 @cons(i64 %53, i64 %55)
  %73 = inttoptr i64 %15 to i64*
  store i64 %72, i64* %73
  br label %$30
$30:
  %74 = phi i64 [%45, %$25], [%71, %$29] ; # X
; # (? (atom X) Z)
; # (atom X)
  %75 = and i64 %74, 15
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$33, label %$31
$33:
  %77 = phi i64 [%74, %$30] ; # X
  br label %$32
$31:
  %78 = phi i64 [%74, %$30] ; # X
  br label %$17
$32:
  %79 = phi i64 [%77, %$33] ; # X
  %80 = phi i64 [%53, %$33] ; # ->
; # (drop *Safe)
  %81 = inttoptr i64 %24 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_pop(i64) align 8 {
$1:
; # (let X (needChkVar Exe (eval (cadr Exe))) (when (and (sym? X) (sy...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needChkVar Exe (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$10, label %$9
$10:
  %17 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %13
  br label %$9
$9:
  %18 = phi i1 [0, %$8], [%17, %$10] ; # ->
  br i1 %18, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$12:
; # (when (and (sym? X) (sym? (val (tail X)))) (dbTouch Exe X))
; # (and (sym? X) (sym? (val (tail X))))
; # (sym? X)
  %19 = and i64 %13, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$14, label %$13
$14:
; # (tail X)
  %21 = add i64 %13, -8
; # (val (tail X))
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
; # (sym? (val (tail X)))
  %24 = and i64 %23, 8
  %25 = icmp ne i64 %24, 0
  br label %$13
$13:
  %26 = phi i1 [0, %$12], [%25, %$14] ; # ->
  br i1 %26, label %$15, label %$16
$15:
; # (dbTouch Exe X)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$16
$16:
; # (if (atom (val X)) @ (set X (cdr @)) (car @))
; # (val X)
  %27 = inttoptr i64 %13 to i64*
  %28 = load i64, i64* %27
; # (atom (val X))
  %29 = and i64 %28, 15
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$17, label %$18
$17:
  br label %$19
$18:
; # (set X (cdr @))
; # (cdr @)
  %31 = inttoptr i64 %28 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %13 to i64*
  store i64 %33, i64* %34
; # (car @)
  %35 = inttoptr i64 %28 to i64*
  %36 = load i64, i64* %35
  br label %$19
$19:
  %37 = phi i64 [%28, %$17], [%36, %$18] ; # ->
  ret i64 %37
}

define i64 @_popq(i64) align 8 {
$1:
; # (let X (needChkVar Exe (cadr Exe)) (if (atom (val X)) @ (set X (c...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (needChkVar Exe (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$2, label %$3
$2:
  call void @varErr(i64 %0, i64 %5)
  unreachable
$3:
  %8 = icmp uge i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %8, label %$5, label %$4
$5:
  %9 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %5
  br label %$4
$4:
  %10 = phi i1 [0, %$3], [%9, %$5] ; # ->
  br i1 %10, label %$6, label %$7
$6:
  call void @protErr(i64 %0, i64 %5)
  unreachable
$7:
; # (if (atom (val X)) @ (set X (cdr @)) (car @))
; # (val X)
  %11 = inttoptr i64 %5 to i64*
  %12 = load i64, i64* %11
; # (atom (val X))
  %13 = and i64 %12, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$9
$8:
  br label %$10
$9:
; # (set X (cdr @))
; # (cdr @)
  %15 = inttoptr i64 %12 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %5 to i64*
  store i64 %17, i64* %18
; # (car @)
  %19 = inttoptr i64 %12 to i64*
  %20 = load i64, i64* %19
  br label %$10
$10:
  %21 = phi i64 [%12, %$8], [%20, %$9] ; # ->
  ret i64 %21
}

define i64 @_shift(i64) align 8 {
$1:
; # (let X (needChkVar Exe (eval (cadr Exe))) (when (and (sym? X) (sy...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needChkVar Exe (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$10, label %$9
$10:
  %17 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %13
  br label %$9
$9:
  %18 = phi i1 [0, %$8], [%17, %$10] ; # ->
  br i1 %18, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$12:
; # (when (and (sym? X) (sym? (val (tail X)))) (dbTouch Exe X))
; # (and (sym? X) (sym? (val (tail X))))
; # (sym? X)
  %19 = and i64 %13, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$14, label %$13
$14:
; # (tail X)
  %21 = add i64 %13, -8
; # (val (tail X))
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
; # (sym? (val (tail X)))
  %24 = and i64 %23, 8
  %25 = icmp ne i64 %24, 0
  br label %$13
$13:
  %26 = phi i1 [0, %$12], [%25, %$14] ; # ->
  br i1 %26, label %$15, label %$16
$15:
; # (dbTouch Exe X)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$16
$16:
; # (set X (cdr (needLst Exe (val X))))
; # (val X)
  %27 = inttoptr i64 %13 to i64*
  %28 = load i64, i64* %27
; # (needLst Exe (val X))
  %29 = and i64 %28, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$17, label %$18
$18:
  %31 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$17
$17:
  %32 = phi i1 [1, %$16], [%31, %$18] ; # ->
  br i1 %32, label %$20, label %$19
$19:
  call void @lstErr(i64 %0, i64 %28)
  unreachable
$20:
; # (cdr (needLst Exe (val X)))
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %13 to i64*
  store i64 %35, i64* %36
  ret i64 %35
}

define i64 @_cut(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X)) (if (le0 N) $Nil (let Y (needC...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (if (le0 N) $Nil (let Y (needChkVar Exe (eval (cadr X))) (when (a...
; # (le0 N)
  %5 = icmp sle i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%4, %$1] ; # N
  br label %$4
$3:
  %7 = phi i64 [%4, %$1] ; # N
; # (let Y (needChkVar Exe (eval (cadr X))) (when (and (sym? Y) (sym?...
; # (cadr X)
  %8 = inttoptr i64 %3 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (cadr X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  br label %$5
$6:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$5
$8:
  %19 = call i64 @evList(i64 %12)
  br label %$5
$5:
  %20 = phi i64 [%12, %$7], [%18, %$9], [%19, %$8] ; # ->
; # (needChkVar Exe (eval (cadr X)))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$10, label %$11
$10:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$11:
  %23 = icmp uge i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %23, label %$13, label %$12
$13:
  %24 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %20
  br label %$12
$12:
  %25 = phi i1 [0, %$11], [%24, %$13] ; # ->
  br i1 %25, label %$14, label %$15
$14:
  call void @protErr(i64 %0, i64 %20)
  unreachable
$15:
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %26 = and i64 %20, 8
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$17, label %$16
$17:
  %28 = phi i64 [%7, %$15] ; # N
; # (tail Y)
  %29 = add i64 %20, -8
; # (val (tail Y))
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (sym? (val (tail Y)))
  %32 = and i64 %31, 8
  %33 = icmp ne i64 %32, 0
  br label %$16
$16:
  %34 = phi i64 [%7, %$15], [%28, %$17] ; # N
  %35 = phi i1 [0, %$15], [%33, %$17] ; # ->
  br i1 %35, label %$18, label %$19
$18:
  %36 = phi i64 [%34, %$16] ; # N
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %20)
  br label %$19
$19:
  %37 = phi i64 [%34, %$16], [%36, %$18] ; # N
; # (if (atom (val Y)) @ (let (V (save @) Z (cons (++ V) $Nil) R (sav...
; # (val Y)
  %38 = inttoptr i64 %20 to i64*
  %39 = load i64, i64* %38
; # (atom (val Y))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$20, label %$21
$20:
  %42 = phi i64 [%37, %$19] ; # N
  br label %$22
$21:
  %43 = phi i64 [%37, %$19] ; # N
; # (let (V (save @) Z (cons (++ V) $Nil) R (save Z)) (while (and (pa...
; # (save @)
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %45 = load i64, i64* %44
  %46 = alloca i64, i64 2, align 16
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 %39, i64* %48
  %49 = add i64 %47, 8
  %50 = inttoptr i64 %49 to i64*
  store i64 %45, i64* %50
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %51
; # (++ V)
  %52 = inttoptr i64 %39 to i64*
  %53 = load i64, i64* %52
  %54 = getelementptr i64, i64* %52, i32 1
  %55 = load i64, i64* %54
; # (cons (++ V) $Nil)
  %56 = call i64 @cons(i64 %53, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Z)
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %58 = load i64, i64* %57
  %59 = alloca i64, i64 2, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = inttoptr i64 %60 to i64*
  store i64 %56, i64* %61
  %62 = add i64 %60, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 %58, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %64
; # (while (and (pair V) (dec 'N)) (setq Z (set 2 Z (cons (++ V) $Nil...
  br label %$23
$23:
  %65 = phi i64 [%43, %$21], [%79, %$26] ; # N
  %66 = phi i64 [%55, %$21], [%85, %$26] ; # V
  %67 = phi i64 [%56, %$21], [%86, %$26] ; # Z
; # (and (pair V) (dec 'N))
; # (pair V)
  %68 = and i64 %66, 15
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %$25, label %$24
$25:
  %70 = phi i64 [%65, %$23] ; # N
  %71 = phi i64 [%66, %$23] ; # V
  %72 = phi i64 [%67, %$23] ; # Z
; # (dec 'N)
  %73 = sub i64 %70, 1
  %74 = icmp ne i64 %73, 0
  br label %$24
$24:
  %75 = phi i64 [%65, %$23], [%73, %$25] ; # N
  %76 = phi i64 [%66, %$23], [%71, %$25] ; # V
  %77 = phi i64 [%67, %$23], [%72, %$25] ; # Z
  %78 = phi i1 [0, %$23], [%74, %$25] ; # ->
  br i1 %78, label %$26, label %$27
$26:
  %79 = phi i64 [%75, %$24] ; # N
  %80 = phi i64 [%76, %$24] ; # V
  %81 = phi i64 [%77, %$24] ; # Z
; # (set 2 Z (cons (++ V) $Nil))
; # (++ V)
  %82 = inttoptr i64 %80 to i64*
  %83 = load i64, i64* %82
  %84 = getelementptr i64, i64* %82, i32 1
  %85 = load i64, i64* %84
; # (cons (++ V) $Nil)
  %86 = call i64 @cons(i64 %83, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %87 = inttoptr i64 %81 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  store i64 %86, i64* %88
  br label %$23
$27:
  %89 = phi i64 [%75, %$24] ; # N
  %90 = phi i64 [%76, %$24] ; # V
  %91 = phi i64 [%77, %$24] ; # Z
; # (set Y V)
  %92 = inttoptr i64 %20 to i64*
  store i64 %90, i64* %92
; # (drop *Safe)
  %93 = inttoptr i64 %47 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  %95 = load i64, i64* %94
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %95, i64* %96
  br label %$22
$22:
  %97 = phi i64 [%42, %$20], [%89, %$27] ; # N
  %98 = phi i64 [%39, %$20], [%56, %$27] ; # ->
  br label %$4
$4:
  %99 = phi i64 [%6, %$2], [%97, %$22] ; # N
  %100 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%98, %$22] ; # ->
  ret i64 %100
}

define i64 @_del(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Var (save (needChkVar Ex...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %36 = and i64 %35, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  call void @varErr(i64 %0, i64 %35)
  unreachable
$13:
  %38 = icmp uge i64 %35, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %38, label %$15, label %$14
$15:
  %39 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %35
  br label %$14
$14:
  %40 = phi i1 [0, %$13], [%39, %$15] ; # ->
  br i1 %40, label %$16, label %$17
$16:
  call void @protErr(i64 %0, i64 %35)
  unreachable
$17:
; # (save (needChkVar Exe (eval (++ X))))
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %42 = load i64, i64* %41
  %43 = alloca i64, i64 2, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %35, i64* %45
  %46 = add i64 %44, 8
  %47 = inttoptr i64 %46 to i64*
  store i64 %42, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %48
; # (car X)
  %49 = inttoptr i64 %27 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$20, label %$19
$20:
  br label %$18
$19:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$22, label %$21
$22:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$18
$21:
  %57 = call i64 @evList(i64 %50)
  br label %$18
$18:
  %58 = phi i64 [%50, %$20], [%56, %$22], [%57, %$21] ; # ->
; # (nil? (eval (car X)))
  %59 = icmp eq i64 %58, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (when (and (sym? Var) (sym? (val (tail Var)))) (dbTouch Exe Var))...
; # (and (sym? Var) (sym? (val (tail Var))))
; # (sym? Var)
  %60 = and i64 %35, 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$24, label %$23
$24:
; # (tail Var)
  %62 = add i64 %35, -8
; # (val (tail Var))
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (sym? (val (tail Var)))
  %65 = and i64 %64, 8
  %66 = icmp ne i64 %65, 0
  br label %$23
$23:
  %67 = phi i1 [0, %$18], [%66, %$24] ; # ->
  br i1 %67, label %$25, label %$26
$25:
; # (dbTouch Exe Var)
  call void @dbTouch(i64 %0, i64 %35)
  br label %$26
$26:
; # (let V (val Var) (loop (? (atom V) V) (let Z (++ V) (? (not (equa...
; # (val Var)
  %68 = inttoptr i64 %35 to i64*
  %69 = load i64, i64* %68
; # (loop (? (atom V) V) (let Z (++ V) (? (not (equal Y Z)) (let (P (...
  br label %$27
$27:
  %70 = phi i64 [%69, %$26], [%135, %$40] ; # V
; # (? (atom V) V)
; # (atom V)
  %71 = and i64 %70, 15
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$30, label %$28
$30:
  %73 = phi i64 [%70, %$27] ; # V
  br label %$29
$28:
  %74 = phi i64 [%70, %$27] ; # V
; # (let Z (++ V) (? (not (equal Y Z)) (let (P (cons Z $Nil) R P) (sa...
; # (++ V)
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
  %77 = getelementptr i64, i64* %75, i32 1
  %78 = load i64, i64* %77
; # (? (not (equal Y Z)) (let (P (cons Z $Nil) R P) (save R (loop (? ...
; # (equal Y Z)
  %79 = call i1 @equal(i64 %15, i64 %76)
; # (not (equal Y Z))
  %80 = icmp eq i1 %79, 0
  br i1 %80, label %$32, label %$31
$32:
  %81 = phi i64 [%78, %$28] ; # V
  %82 = phi i64 [%76, %$28] ; # Z
; # (let (P (cons Z $Nil) R P) (save R (loop (? (atom V)) (if (equal ...
; # (cons Z $Nil)
  %83 = call i64 @cons(i64 %82, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save R (loop (? (atom V)) (if (equal Y (setq Z (++ V))) (? Flg) ...
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %85 = load i64, i64* %84
  %86 = alloca i64, i64 2, align 16
  %87 = ptrtoint i64* %86 to i64
  %88 = inttoptr i64 %87 to i64*
  store i64 %83, i64* %88
  %89 = add i64 %87, 8
  %90 = inttoptr i64 %89 to i64*
  store i64 %85, i64* %90
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %87, i64* %91
; # (loop (? (atom V)) (if (equal Y (setq Z (++ V))) (? Flg) (setq P ...
  br label %$33
$33:
  %92 = phi i64 [%81, %$32], [%117, %$38] ; # V
  %93 = phi i64 [%82, %$32], [%118, %$38] ; # Z
  %94 = phi i64 [%83, %$32], [%119, %$38] ; # P
; # (? (atom V))
; # (atom V)
  %95 = and i64 %92, 15
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$35, label %$34
$34:
  %97 = phi i64 [%92, %$33] ; # V
  %98 = phi i64 [%93, %$33] ; # Z
  %99 = phi i64 [%94, %$33] ; # P
; # (if (equal Y (setq Z (++ V))) (? Flg) (setq P (set 2 P (cons Z $N...
; # (++ V)
  %100 = inttoptr i64 %97 to i64*
  %101 = load i64, i64* %100
  %102 = getelementptr i64, i64* %100, i32 1
  %103 = load i64, i64* %102
; # (equal Y (setq Z (++ V)))
  %104 = call i1 @equal(i64 %15, i64 %101)
  br i1 %104, label %$36, label %$37
$36:
  %105 = phi i64 [%103, %$34] ; # V
  %106 = phi i64 [%101, %$34] ; # Z
  %107 = phi i64 [%99, %$34] ; # P
; # (? Flg)
  br i1 %59, label %$35, label %$39
$39:
  %108 = phi i64 [%105, %$36] ; # V
  %109 = phi i64 [%106, %$36] ; # Z
  %110 = phi i64 [%107, %$36] ; # P
  br label %$38
$37:
  %111 = phi i64 [%103, %$34] ; # V
  %112 = phi i64 [%101, %$34] ; # Z
  %113 = phi i64 [%99, %$34] ; # P
; # (set 2 P (cons Z $Nil))
; # (cons Z $Nil)
  %114 = call i64 @cons(i64 %112, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %115 = inttoptr i64 %113 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  store i64 %114, i64* %116
  br label %$38
$38:
  %117 = phi i64 [%108, %$39], [%111, %$37] ; # V
  %118 = phi i64 [%109, %$39], [%112, %$37] ; # Z
  %119 = phi i64 [%110, %$39], [%114, %$37] ; # P
  br label %$33
$35:
  %120 = phi i64 [%92, %$33], [%105, %$36] ; # V
  %121 = phi i64 [%93, %$33], [%106, %$36] ; # Z
  %122 = phi i64 [%94, %$33], [%107, %$36] ; # P
  %123 = phi i64 [0, %$33], [0, %$36] ; # ->
; # drop
  %124 = inttoptr i64 %87 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
  %127 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %126, i64* %127
; # (set 2 P V Var R)
  %128 = inttoptr i64 %122 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  store i64 %120, i64* %129
  %130 = inttoptr i64 %35 to i64*
  store i64 %83, i64* %130
  br label %$29
$31:
  %131 = phi i64 [%78, %$28] ; # V
  %132 = phi i64 [%76, %$28] ; # Z
; # (set Var V)
  %133 = inttoptr i64 %35 to i64*
  store i64 %131, i64* %133
; # (? Flg V)
  br i1 %59, label %$41, label %$40
$41:
  %134 = phi i64 [%131, %$31] ; # V
  br label %$29
$40:
  %135 = phi i64 [%131, %$31] ; # V
  br label %$27
$29:
  %136 = phi i64 [%73, %$30], [%120, %$35], [%134, %$41] ; # V
  %137 = phi i64 [%73, %$30], [%83, %$35], [%134, %$41] ; # ->
; # (drop *Safe)
  %138 = inttoptr i64 %19 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  %140 = load i64, i64* %139
  %141 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %140, i64* %141
  ret i64 %137
}

define i64 @_queue(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
; # (tail Y)
  %31 = add i64 %15, -8
; # (val (tail Y))
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (sym? (val (tail Y)))
  %34 = and i64 %33, 8
  %35 = icmp ne i64 %34, 0
  br label %$13
$13:
  %36 = phi i1 [0, %$12], [%35, %$14] ; # ->
  br i1 %36, label %$15, label %$16
$15:
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
; # (let (Z (eval (car X)) L (cons Z $Nil) V (val Y)) (if (atom V) (s...
; # (car X)
  %37 = inttoptr i64 %7 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$19, label %$18
$19:
  br label %$17
$18:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$21, label %$20
$21:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$17
$20:
  %45 = call i64 @evList(i64 %38)
  br label %$17
$17:
  %46 = phi i64 [%38, %$19], [%44, %$21], [%45, %$20] ; # ->
; # (cons Z $Nil)
  %47 = call i64 @cons(i64 %46, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (val Y)
  %48 = inttoptr i64 %15 to i64*
  %49 = load i64, i64* %48
; # (if (atom V) (set Y L) (while (pair (cdr V)) (shift V)) (set 2 V ...
; # (atom V)
  %50 = and i64 %49, 15
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$22, label %$23
$22:
  %52 = phi i64 [%49, %$17] ; # V
; # (set Y L)
  %53 = inttoptr i64 %15 to i64*
  store i64 %47, i64* %53
  br label %$24
$23:
  %54 = phi i64 [%49, %$17] ; # V
; # (while (pair (cdr V)) (shift V))
  br label %$25
$25:
  %55 = phi i64 [%54, %$23], [%64, %$26] ; # V
; # (cdr V)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (pair (cdr V))
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$26, label %$27
$26:
  %61 = phi i64 [%55, %$25] ; # V
; # (shift V)
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  br label %$25
$27:
  %65 = phi i64 [%55, %$25] ; # V
; # (set 2 V L)
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %47, i64* %67
  br label %$24
$24:
  %68 = phi i64 [%52, %$22], [%65, %$27] ; # V
  %69 = phi i64 [%47, %$22], [%47, %$27] ; # ->
; # (drop *Safe)
  %70 = inttoptr i64 %24 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %72, i64* %73
  ret i64 %46
}

define i64 @_fifo(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (let V (val Y) (cond ((pair X) (let E (eval (car X)) (if (pair V)...
; # (val Y)
  %41 = inttoptr i64 %15 to i64*
  %42 = load i64, i64* %41
; # (cond ((pair X) (let E (eval (car X)) (if (pair V) (setq V (set 2...
; # (pair X)
  %43 = and i64 %40, 15
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$19, label %$18
$19:
  %45 = phi i64 [%40, %$16] ; # X
  %46 = phi i64 [%42, %$16] ; # V
; # (let E (eval (car X)) (if (pair V) (setq V (set 2 V (cons E (cdr ...
; # (car X)
  %47 = inttoptr i64 %45 to i64*
  %48 = load i64, i64* %47
; # (eval (car X))
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  br label %$20
$21:
  %51 = and i64 %48, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$24, label %$23
$24:
  %53 = inttoptr i64 %48 to i64*
  %54 = load i64, i64* %53
  br label %$20
$23:
  %55 = call i64 @evList(i64 %48)
  br label %$20
$20:
  %56 = phi i64 [%48, %$22], [%54, %$24], [%55, %$23] ; # ->
; # (if (pair V) (setq V (set 2 V (cons E (cdr V)))) (setq V (cons E ...
; # (pair V)
  %57 = and i64 %46, 15
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %$25, label %$26
$25:
  %59 = phi i64 [%45, %$20] ; # X
  %60 = phi i64 [%46, %$20] ; # V
  %61 = phi i64 [%56, %$20] ; # E
; # (set 2 V (cons E (cdr V)))
; # (cdr V)
  %62 = inttoptr i64 %60 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (cons E (cdr V))
  %65 = call i64 @cons(i64 %61, i64 %64)
  %66 = inttoptr i64 %60 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %65, i64* %67
  br label %$27
$26:
  %68 = phi i64 [%45, %$20] ; # X
  %69 = phi i64 [%46, %$20] ; # V
  %70 = phi i64 [%56, %$20] ; # E
; # (cons E -ZERO)
  %71 = call i64 @cons(i64 %70, i64 10)
; # (set 2 V V)
  %72 = inttoptr i64 %71 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  store i64 %71, i64* %73
  br label %$27
$27:
  %74 = phi i64 [%59, %$25], [%68, %$26] ; # X
  %75 = phi i64 [%65, %$25], [%71, %$26] ; # V
  %76 = phi i64 [%61, %$25], [%70, %$26] ; # E
  %77 = phi i64 [%65, %$25], [%71, %$26] ; # ->
; # (while (pair (shift X)) (setq V (set 2 V (cons (setq E (eval (car...
  br label %$28
$28:
  %78 = phi i64 [%74, %$27], [%86, %$31] ; # X
  %79 = phi i64 [%75, %$27], [%102, %$31] ; # V
  %80 = phi i64 [%76, %$27], [%98, %$31] ; # E
; # (shift X)
  %81 = inttoptr i64 %78 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (pair (shift X))
  %84 = and i64 %83, 15
  %85 = icmp eq i64 %84, 0
  br i1 %85, label %$29, label %$30
$29:
  %86 = phi i64 [%83, %$28] ; # X
  %87 = phi i64 [%79, %$28] ; # V
  %88 = phi i64 [%80, %$28] ; # E
; # (set 2 V (cons (setq E (eval (car X))) (cdr V)))
; # (car X)
  %89 = inttoptr i64 %86 to i64*
  %90 = load i64, i64* %89
; # (eval (car X))
  %91 = and i64 %90, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$33, label %$32
$33:
  br label %$31
$32:
  %93 = and i64 %90, 8
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$35, label %$34
$35:
  %95 = inttoptr i64 %90 to i64*
  %96 = load i64, i64* %95
  br label %$31
$34:
  %97 = call i64 @evList(i64 %90)
  br label %$31
$31:
  %98 = phi i64 [%90, %$33], [%96, %$35], [%97, %$34] ; # ->
; # (cdr V)
  %99 = inttoptr i64 %87 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
; # (cons (setq E (eval (car X))) (cdr V))
  %102 = call i64 @cons(i64 %98, i64 %101)
  %103 = inttoptr i64 %87 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  store i64 %102, i64* %104
  br label %$28
$30:
  %105 = phi i64 [%83, %$28] ; # X
  %106 = phi i64 [%79, %$28] ; # V
  %107 = phi i64 [%80, %$28] ; # E
; # (set Y V)
  %108 = inttoptr i64 %15 to i64*
  store i64 %106, i64* %108
  br label %$17
$18:
  %109 = phi i64 [%40, %$16] ; # X
  %110 = phi i64 [%42, %$16] ; # V
; # (atom V)
  %111 = and i64 %110, 15
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$37, label %$36
$37:
  %113 = phi i64 [%109, %$18] ; # X
  %114 = phi i64 [%110, %$18] ; # V
  br label %$17
$36:
  %115 = phi i64 [%109, %$18] ; # X
  %116 = phi i64 [%110, %$18] ; # V
; # (cdr V)
  %117 = inttoptr i64 %116 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  %119 = load i64, i64* %118
; # (== (cdr V) V)
  %120 = icmp eq i64 %119, %116
  br i1 %120, label %$39, label %$38
$39:
  %121 = phi i64 [%115, %$36] ; # X
  %122 = phi i64 [%116, %$36] ; # V
; # (set Y $Nil)
  %123 = inttoptr i64 %15 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %123
; # (car V)
  %124 = inttoptr i64 %122 to i64*
  %125 = load i64, i64* %124
  br label %$17
$38:
  %126 = phi i64 [%115, %$36] ; # X
  %127 = phi i64 [%116, %$36] ; # V
; # (set 2 V (cdr @))
; # (cdr @)
  %128 = inttoptr i64 %119 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 %127 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  store i64 %130, i64* %132
; # (car @)
  %133 = inttoptr i64 %119 to i64*
  %134 = load i64, i64* %133
  br label %$17
$17:
  %135 = phi i64 [%105, %$30], [%113, %$37], [%121, %$39], [%126, %$38] ; # X
  %136 = phi i64 [%106, %$30], [%114, %$37], [%122, %$39], [%127, %$38] ; # V
  %137 = phi i64 [%107, %$30], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$37], [%125, %$39], [%134, %$38] ; # ->
; # (drop *Safe)
  %138 = inttoptr i64 %24 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  %140 = load i64, i64* %139
  %141 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %140, i64* %141
  ret i64 %137
}

define i64 @_rid(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (car X)
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
; # (eval (car X))
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$19, label %$18
$19:
  br label %$17
$18:
  %45 = and i64 %42, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$21, label %$20
$21:
  %47 = inttoptr i64 %42 to i64*
  %48 = load i64, i64* %47
  br label %$17
$20:
  %49 = call i64 @evList(i64 %42)
  br label %$17
$17:
  %50 = phi i64 [%42, %$19], [%48, %$21], [%49, %$20] ; # ->
; # (let V (val Y) (cond ((pair V) (let (Z V L (cdr Z)) (loop (? (ato...
; # (val Y)
  %51 = inttoptr i64 %15 to i64*
  %52 = load i64, i64* %51
; # (cond ((pair V) (let (Z V L (cdr Z)) (loop (? (atom L) (when (equ...
; # (pair V)
  %53 = and i64 %52, 15
  %54 = icmp eq i64 %53, 0
  br i1 %54, label %$24, label %$23
$24:
  %55 = phi i64 [%50, %$17] ; # X
; # (let (Z V L (cdr Z)) (loop (? (atom L) (when (equal L X) (set 2 Z...
; # (cdr Z)
  %56 = inttoptr i64 %52 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (loop (? (atom L) (when (equal L X) (set 2 Z $Nil)) (if (equal (c...
  br label %$25
$25:
  %59 = phi i64 [%55, %$24], [%150, %$43] ; # X
  %60 = phi i64 [%52, %$24], [%151, %$43] ; # Z
  %61 = phi i64 [%58, %$24], [%152, %$43] ; # L
; # (? (atom L) (when (equal L X) (set 2 Z $Nil)) (if (equal (car V) ...
; # (atom L)
  %62 = and i64 %61, 15
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$28, label %$26
$28:
  %64 = phi i64 [%59, %$25] ; # X
  %65 = phi i64 [%60, %$25] ; # Z
  %66 = phi i64 [%61, %$25] ; # L
; # (when (equal L X) (set 2 Z $Nil))
; # (equal L X)
  %67 = call i1 @equal(i64 %66, i64 %64)
  br i1 %67, label %$29, label %$30
$29:
  %68 = phi i64 [%64, %$28] ; # X
  %69 = phi i64 [%65, %$28] ; # Z
  %70 = phi i64 [%66, %$28] ; # L
; # (set 2 Z $Nil)
  %71 = inttoptr i64 %69 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %72
  br label %$30
$30:
  %73 = phi i64 [%64, %$28], [%68, %$29] ; # X
  %74 = phi i64 [%65, %$28], [%69, %$29] ; # Z
  %75 = phi i64 [%66, %$28], [%70, %$29] ; # L
; # (if (equal (car V) X) (set Y (cdr V)) V)
; # (car V)
  %76 = inttoptr i64 %52 to i64*
  %77 = load i64, i64* %76
; # (equal (car V) X)
  %78 = call i1 @equal(i64 %77, i64 %73)
  br i1 %78, label %$31, label %$32
$31:
  %79 = phi i64 [%73, %$30] ; # X
  %80 = phi i64 [%74, %$30] ; # Z
  %81 = phi i64 [%75, %$30] ; # L
; # (set Y (cdr V))
; # (cdr V)
  %82 = inttoptr i64 %52 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
  %85 = inttoptr i64 %15 to i64*
  store i64 %84, i64* %85
  br label %$33
$32:
  %86 = phi i64 [%73, %$30] ; # X
  %87 = phi i64 [%74, %$30] ; # Z
  %88 = phi i64 [%75, %$30] ; # L
  br label %$33
$33:
  %89 = phi i64 [%79, %$31], [%86, %$32] ; # X
  %90 = phi i64 [%80, %$31], [%87, %$32] ; # Z
  %91 = phi i64 [%81, %$31], [%88, %$32] ; # L
  %92 = phi i64 [%84, %$31], [%52, %$32] ; # ->
  br label %$27
$26:
  %93 = phi i64 [%59, %$25] ; # X
  %94 = phi i64 [%60, %$25] ; # Z
  %95 = phi i64 [%61, %$25] ; # L
; # (? (== L V) (nond ((equal (car L) X) V) ((== L Z) (set 2 Z (cdr L...
; # (== L V)
  %96 = icmp eq i64 %95, %52
  br i1 %96, label %$35, label %$34
$35:
  %97 = phi i64 [%93, %$26] ; # X
  %98 = phi i64 [%94, %$26] ; # Z
  %99 = phi i64 [%95, %$26] ; # L
; # (nond ((equal (car L) X) V) ((== L Z) (set 2 Z (cdr L)) (set Y Z)...
; # (car L)
  %100 = inttoptr i64 %99 to i64*
  %101 = load i64, i64* %100
; # (equal (car L) X)
  %102 = call i1 @equal(i64 %101, i64 %97)
  br i1 %102, label %$37, label %$38
$38:
  %103 = phi i64 [%97, %$35] ; # X
  %104 = phi i64 [%98, %$35] ; # Z
  %105 = phi i64 [%99, %$35] ; # L
  br label %$36
$37:
  %106 = phi i64 [%97, %$35] ; # X
  %107 = phi i64 [%98, %$35] ; # Z
  %108 = phi i64 [%99, %$35] ; # L
; # (== L Z)
  %109 = icmp eq i64 %108, %107
  br i1 %109, label %$39, label %$40
$40:
  %110 = phi i64 [%106, %$37] ; # X
  %111 = phi i64 [%107, %$37] ; # Z
  %112 = phi i64 [%108, %$37] ; # L
; # (set 2 Z (cdr L))
; # (cdr L)
  %113 = inttoptr i64 %112 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  %115 = load i64, i64* %114
  %116 = inttoptr i64 %111 to i64*
  %117 = getelementptr i64, i64* %116, i32 1
  store i64 %115, i64* %117
; # (set Y Z)
  %118 = inttoptr i64 %15 to i64*
  store i64 %111, i64* %118
  br label %$36
$39:
  %119 = phi i64 [%106, %$37] ; # X
  %120 = phi i64 [%107, %$37] ; # Z
  %121 = phi i64 [%108, %$37] ; # L
; # (set Y $Nil)
  %122 = inttoptr i64 %15 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %122
  br label %$36
$36:
  %123 = phi i64 [%103, %$38], [%110, %$40], [%119, %$39] ; # X
  %124 = phi i64 [%104, %$38], [%111, %$40], [%120, %$39] ; # Z
  %125 = phi i64 [%105, %$38], [%112, %$40], [%121, %$39] ; # L
  %126 = phi i64 [%52, %$38], [%111, %$40], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$39] ; # ->
  br label %$27
$34:
  %127 = phi i64 [%93, %$26] ; # X
  %128 = phi i64 [%94, %$26] ; # Z
  %129 = phi i64 [%95, %$26] ; # L
; # (if (equal (car L) X) (set 2 Z (shift L)) (setq L (cdr (shift Z))...
; # (car L)
  %130 = inttoptr i64 %129 to i64*
  %131 = load i64, i64* %130
; # (equal (car L) X)
  %132 = call i1 @equal(i64 %131, i64 %127)
  br i1 %132, label %$41, label %$42
$41:
  %133 = phi i64 [%127, %$34] ; # X
  %134 = phi i64 [%128, %$34] ; # Z
  %135 = phi i64 [%129, %$34] ; # L
; # (set 2 Z (shift L))
; # (shift L)
  %136 = inttoptr i64 %135 to i64*
  %137 = getelementptr i64, i64* %136, i32 1
  %138 = load i64, i64* %137
  %139 = inttoptr i64 %134 to i64*
  %140 = getelementptr i64, i64* %139, i32 1
  store i64 %138, i64* %140
  br label %$43
$42:
  %141 = phi i64 [%127, %$34] ; # X
  %142 = phi i64 [%128, %$34] ; # Z
  %143 = phi i64 [%129, %$34] ; # L
; # (shift Z)
  %144 = inttoptr i64 %142 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (cdr (shift Z))
  %147 = inttoptr i64 %146 to i64*
  %148 = getelementptr i64, i64* %147, i32 1
  %149 = load i64, i64* %148
  br label %$43
$43:
  %150 = phi i64 [%133, %$41], [%141, %$42] ; # X
  %151 = phi i64 [%134, %$41], [%146, %$42] ; # Z
  %152 = phi i64 [%138, %$41], [%149, %$42] ; # L
  %153 = phi i64 [%138, %$41], [%149, %$42] ; # ->
  br label %$25
$27:
  %154 = phi i64 [%89, %$33], [%123, %$36] ; # X
  %155 = phi i64 [%90, %$33], [%124, %$36] ; # Z
  %156 = phi i64 [%91, %$33], [%125, %$36] ; # L
  %157 = phi i64 [%92, %$33], [%126, %$36] ; # ->
  br label %$22
$23:
  %158 = phi i64 [%50, %$17] ; # X
; # (equal V X)
  %159 = call i1 @equal(i64 %52, i64 %158)
  br i1 %159, label %$45, label %$44
$45:
  %160 = phi i64 [%158, %$23] ; # X
; # (set Y $Nil)
  %161 = inttoptr i64 %15 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %161
  br label %$22
$44:
  %162 = phi i64 [%158, %$23] ; # X
  br label %$22
$22:
  %163 = phi i64 [%154, %$27], [%160, %$45], [%162, %$44] ; # X
  %164 = phi i64 [%157, %$27], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$45], [%52, %$44] ; # ->
; # (drop *Safe)
  %165 = inttoptr i64 %24 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
  %168 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %167, i64* %168
  ret i64 %164
}

define i64 @_enum(i64) align 8 {
$1:
; # (let (X (cdr Exe) Var (save (needChkVar Exe (eval (++ X)))) Cnt T...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %15, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %28
; # (if (pair X) (loop (? (le0 (setq Cnt (evCnt Exe X))) $Nil) (let P...
; # (pair X)
  %29 = and i64 %7, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$13, label %$14
$13:
  %31 = phi i64 [%7, %$12] ; # X
  %32 = phi i64 [%15, %$12] ; # Var
; # (loop (? (le0 (setq Cnt (evCnt Exe X))) $Nil) (let P (val Var) (l...
  br label %$16
$16:
  %33 = phi i64 [%31, %$13], [%179, %$40] ; # X
  %34 = phi i64 [%32, %$13], [%180, %$40] ; # Var
; # (? (le0 (setq Cnt (evCnt Exe X))) $Nil)
; # (evCnt Exe X)
  %35 = call i64 @evCnt(i64 %0, i64 %33)
; # (le0 (setq Cnt (evCnt Exe X)))
  %36 = icmp sle i64 %35, 0
  br i1 %36, label %$19, label %$17
$19:
  %37 = phi i64 [%33, %$16] ; # X
  %38 = phi i64 [%34, %$16] ; # Var
  %39 = phi i64 [%35, %$16] ; # Cnt
  br label %$18
$17:
  %40 = phi i64 [%33, %$16] ; # X
  %41 = phi i64 [%34, %$16] ; # Var
  %42 = phi i64 [%35, %$16] ; # Cnt
; # (let P (val Var) (loop (let N (shr Cnt 1) (? (=0 N) (setq Var (if...
; # (val Var)
  %43 = inttoptr i64 %41 to i64*
  %44 = load i64, i64* %43
; # (loop (let N (shr Cnt 1) (? (=0 N) (setq Var (if (pair P) @ (set ...
  br label %$20
$20:
  %45 = phi i64 [%40, %$17], [%161, %$29] ; # X
  %46 = phi i64 [%41, %$17], [%162, %$29] ; # Var
  %47 = phi i64 [%42, %$17], [%49, %$29] ; # Cnt
  %48 = phi i64 [%44, %$17], [%164, %$29] ; # P
; # (let N (shr Cnt 1) (? (=0 N) (setq Var (if (pair P) @ (set Var (c...
; # (shr Cnt 1)
  %49 = lshr i64 %47, 1
; # (? (=0 N) (setq Var (if (pair P) @ (set Var (cons $Nil $Nil)))))
; # (=0 N)
  %50 = icmp eq i64 %49, 0
  br i1 %50, label %$23, label %$21
$23:
  %51 = phi i64 [%45, %$20] ; # X
  %52 = phi i64 [%46, %$20] ; # Var
  %53 = phi i64 [%47, %$20] ; # Cnt
  %54 = phi i64 [%48, %$20] ; # P
; # (if (pair P) @ (set Var (cons $Nil $Nil)))
; # (pair P)
  %55 = and i64 %54, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$24, label %$25
$24:
  %57 = phi i64 [%51, %$23] ; # X
  %58 = phi i64 [%52, %$23] ; # Var
  %59 = phi i64 [%53, %$23] ; # Cnt
  %60 = phi i64 [%54, %$23] ; # P
  br label %$26
$25:
  %61 = phi i64 [%51, %$23] ; # X
  %62 = phi i64 [%52, %$23] ; # Var
  %63 = phi i64 [%53, %$23] ; # Cnt
  %64 = phi i64 [%54, %$23] ; # P
; # (set Var (cons $Nil $Nil))
; # (cons $Nil $Nil)
  %65 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %66 = inttoptr i64 %62 to i64*
  store i64 %65, i64* %66
  br label %$26
$26:
  %67 = phi i64 [%57, %$24], [%61, %$25] ; # X
  %68 = phi i64 [%58, %$24], [%62, %$25] ; # Var
  %69 = phi i64 [%59, %$24], [%63, %$25] ; # Cnt
  %70 = phi i64 [%60, %$24], [%64, %$25] ; # P
  %71 = phi i64 [%54, %$24], [%65, %$25] ; # ->
  br label %$22
$21:
  %72 = phi i64 [%45, %$20] ; # X
  %73 = phi i64 [%46, %$20] ; # Var
  %74 = phi i64 [%47, %$20] ; # Cnt
  %75 = phi i64 [%48, %$20] ; # P
; # (if (& Cnt 1) (cond ((atom P) (let Y (cons $Nil (setq P $Nil)) (s...
; # (& Cnt 1)
  %76 = and i64 %74, 1
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$27, label %$28
$27:
  %78 = phi i64 [%72, %$21] ; # X
  %79 = phi i64 [%73, %$21] ; # Var
  %80 = phi i64 [%74, %$21] ; # Cnt
  %81 = phi i64 [%75, %$21] ; # P
; # (cond ((atom P) (let Y (cons $Nil (setq P $Nil)) (set Var (cons $...
; # (atom P)
  %82 = and i64 %81, 15
  %83 = icmp ne i64 %82, 0
  br i1 %83, label %$32, label %$31
$32:
  %84 = phi i64 [%78, %$27] ; # X
  %85 = phi i64 [%79, %$27] ; # Var
  %86 = phi i64 [%80, %$27] ; # Cnt
  %87 = phi i64 [%81, %$27] ; # P
; # (let Y (cons $Nil (setq P $Nil)) (set Var (cons $Nil Y)) (setq Va...
; # (cons $Nil (setq P $Nil))
  %88 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (set Var (cons $Nil Y))
; # (cons $Nil Y)
  %89 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %88)
  %90 = inttoptr i64 %85 to i64*
  store i64 %89, i64* %90
; # (ofs Y 1)
  %91 = add i64 %88, 8
  br label %$30
$31:
  %92 = phi i64 [%78, %$27] ; # X
  %93 = phi i64 [%79, %$27] ; # Var
  %94 = phi i64 [%80, %$27] ; # Cnt
  %95 = phi i64 [%81, %$27] ; # P
; # (cdr P)
  %96 = inttoptr i64 %95 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  %98 = load i64, i64* %97
; # (atom (cdr P))
  %99 = and i64 %98, 15
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$34, label %$33
$34:
  %101 = phi i64 [%92, %$31] ; # X
  %102 = phi i64 [%93, %$31] ; # Var
  %103 = phi i64 [%94, %$31] ; # Cnt
  %104 = phi i64 [%95, %$31] ; # P
; # (set 2 P (cons $Nil (setq P $Nil)))
; # (cons $Nil (setq P $Nil))
  %105 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %106 = inttoptr i64 %104 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  store i64 %105, i64* %107
; # (ofs (set 2 P (cons $Nil (setq P $Nil))) 1)
  %108 = add i64 %105, 8
  br label %$30
$33:
  %109 = phi i64 [%92, %$31] ; # X
  %110 = phi i64 [%93, %$31] ; # Var
  %111 = phi i64 [%94, %$31] ; # Cnt
  %112 = phi i64 [%95, %$31] ; # P
; # (ofs @ 1)
  %113 = add i64 %98, 8
; # (val (setq Var (ofs @ 1)))
  %114 = inttoptr i64 %113 to i64*
  %115 = load i64, i64* %114
  br label %$30
$30:
  %116 = phi i64 [%84, %$32], [%101, %$34], [%109, %$33] ; # X
  %117 = phi i64 [%91, %$32], [%108, %$34], [%113, %$33] ; # Var
  %118 = phi i64 [%86, %$32], [%103, %$34], [%111, %$33] ; # Cnt
  %119 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$32], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$34], [%115, %$33] ; # P
  %120 = phi i64 [%91, %$32], [%108, %$34], [%115, %$33] ; # ->
  br label %$29
$28:
  %121 = phi i64 [%72, %$21] ; # X
  %122 = phi i64 [%73, %$21] ; # Var
  %123 = phi i64 [%74, %$21] ; # Cnt
  %124 = phi i64 [%75, %$21] ; # P
; # (cond ((atom P) (let Y (cons (setq P $Nil) $Nil) (set Var (cons $...
; # (atom P)
  %125 = and i64 %124, 15
  %126 = icmp ne i64 %125, 0
  br i1 %126, label %$37, label %$36
$37:
  %127 = phi i64 [%121, %$28] ; # X
  %128 = phi i64 [%122, %$28] ; # Var
  %129 = phi i64 [%123, %$28] ; # Cnt
  %130 = phi i64 [%124, %$28] ; # P
; # (let Y (cons (setq P $Nil) $Nil) (set Var (cons $Nil Y)) (setq Va...
; # (cons (setq P $Nil) $Nil)
  %131 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (set Var (cons $Nil Y))
; # (cons $Nil Y)
  %132 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %131)
  %133 = inttoptr i64 %128 to i64*
  store i64 %132, i64* %133
  br label %$35
$36:
  %134 = phi i64 [%121, %$28] ; # X
  %135 = phi i64 [%122, %$28] ; # Var
  %136 = phi i64 [%123, %$28] ; # Cnt
  %137 = phi i64 [%124, %$28] ; # P
; # (cdr P)
  %138 = inttoptr i64 %137 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  %140 = load i64, i64* %139
; # (atom (cdr P))
  %141 = and i64 %140, 15
  %142 = icmp ne i64 %141, 0
  br i1 %142, label %$39, label %$38
$39:
  %143 = phi i64 [%134, %$36] ; # X
  %144 = phi i64 [%135, %$36] ; # Var
  %145 = phi i64 [%136, %$36] ; # Cnt
  %146 = phi i64 [%137, %$36] ; # P
; # (set 2 P (cons (setq P $Nil) $Nil))
; # (cons (setq P $Nil) $Nil)
  %147 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %148 = inttoptr i64 %146 to i64*
  %149 = getelementptr i64, i64* %148, i32 1
  store i64 %147, i64* %149
  br label %$35
$38:
  %150 = phi i64 [%134, %$36] ; # X
  %151 = phi i64 [%135, %$36] ; # Var
  %152 = phi i64 [%136, %$36] ; # Cnt
  %153 = phi i64 [%137, %$36] ; # P
; # (val (setq Var @))
  %154 = inttoptr i64 %140 to i64*
  %155 = load i64, i64* %154
  br label %$35
$35:
  %156 = phi i64 [%127, %$37], [%143, %$39], [%150, %$38] ; # X
  %157 = phi i64 [%131, %$37], [%147, %$39], [%140, %$38] ; # Var
  %158 = phi i64 [%129, %$37], [%145, %$39], [%152, %$38] ; # Cnt
  %159 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$37], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$39], [%155, %$38] ; # P
  %160 = phi i64 [%131, %$37], [%147, %$39], [%155, %$38] ; # ->
  br label %$29
$29:
  %161 = phi i64 [%116, %$30], [%156, %$35] ; # X
  %162 = phi i64 [%117, %$30], [%157, %$35] ; # Var
  %163 = phi i64 [%118, %$30], [%158, %$35] ; # Cnt
  %164 = phi i64 [%119, %$30], [%159, %$35] ; # P
  %165 = phi i64 [%120, %$30], [%160, %$35] ; # ->
  br label %$20
$22:
  %166 = phi i64 [%67, %$26] ; # X
  %167 = phi i64 [%71, %$26] ; # Var
  %168 = phi i64 [%69, %$26] ; # Cnt
  %169 = phi i64 [%70, %$26] ; # P
  %170 = phi i64 [%71, %$26] ; # ->
; # (? (atom (shift X)) Var)
; # (shift X)
  %171 = inttoptr i64 %166 to i64*
  %172 = getelementptr i64, i64* %171, i32 1
  %173 = load i64, i64* %172
; # (atom (shift X))
  %174 = and i64 %173, 15
  %175 = icmp ne i64 %174, 0
  br i1 %175, label %$41, label %$40
$41:
  %176 = phi i64 [%173, %$22] ; # X
  %177 = phi i64 [%167, %$22] ; # Var
  %178 = phi i64 [%168, %$22] ; # Cnt
  br label %$18
$40:
  %179 = phi i64 [%173, %$22] ; # X
  %180 = phi i64 [%167, %$22] ; # Var
  %181 = phi i64 [%168, %$22] ; # Cnt
  br label %$16
$18:
  %182 = phi i64 [%37, %$19], [%176, %$41] ; # X
  %183 = phi i64 [%38, %$19], [%177, %$41] ; # Var
  %184 = phi i64 [%39, %$19], [%178, %$41] ; # Cnt
  %185 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$19], [%177, %$41] ; # ->
  br label %$15
$14:
  %186 = phi i64 [%7, %$12] ; # X
  %187 = phi i64 [%15, %$12] ; # Var
; # (let (Q (link (push NIL NIL)) Tos (link (push -ZERO NIL)) R (link...
; # (push NIL NIL)
  %188 = alloca i64, i64 2, align 16
  %189 = ptrtoint i64* %188 to i64
; # (link (push NIL NIL))
  %190 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %191 = load i64, i64* %190
  %192 = inttoptr i64 %189 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  store i64 %191, i64* %193
  %194 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %189, i64* %194
; # (push -ZERO NIL)
  %195 = alloca i64, i64 2, align 16
  %196 = ptrtoint i64* %195 to i64
  %197 = inttoptr i64 %196 to i64*
  store i64 10, i64* %197
; # (link (push -ZERO NIL))
  %198 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %199 = load i64, i64* %198
  %200 = inttoptr i64 %196 to i64*
  %201 = getelementptr i64, i64* %200, i32 1
  store i64 %199, i64* %201
  %202 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %196, i64* %202
; # (push $Nil NIL)
  %203 = alloca i64, i64 2, align 16
  %204 = ptrtoint i64* %203 to i64
  %205 = inttoptr i64 %204 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %205
; # (link (push $Nil NIL))
  %206 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %207 = load i64, i64* %206
  %208 = inttoptr i64 %204 to i64*
  %209 = getelementptr i64, i64* %208, i32 1
  store i64 %207, i64* %209
  %210 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %204, i64* %210
; # (val Var)
  %211 = inttoptr i64 %187 to i64*
  %212 = load i64, i64* %211
; # (loop (loop (let Y (cdr P) (? (atom (cdr Y))) (let Z P (setq P @)...
  br label %$42
$42:
  %213 = phi i64 [%186, %$14], [%371, %$50] ; # X
  %214 = phi i64 [%187, %$14], [%372, %$50] ; # Var
  %215 = phi i64 [0, %$14], [%373, %$50] ; # Cnt
  %216 = phi i64 [%212, %$14], [%374, %$50] ; # P
  %217 = phi i64 [1, %$14], [%375, %$50] ; # M
; # (loop (let Y (cdr P) (? (atom (cdr Y))) (let Z P (setq P @) (set ...
  br label %$43
$43:
  %218 = phi i64 [%213, %$42], [%231, %$44] ; # X
  %219 = phi i64 [%214, %$42], [%232, %$44] ; # Var
  %220 = phi i64 [%215, %$42], [%241, %$44] ; # Cnt
  %221 = phi i64 [%216, %$42], [%228, %$44] ; # P
  %222 = phi i64 [%217, %$42], [%242, %$44] ; # M
; # (let Y (cdr P) (? (atom (cdr Y))) (let Z P (setq P @) (set 2 Y (v...
; # (cdr P)
  %223 = inttoptr i64 %221 to i64*
  %224 = getelementptr i64, i64* %223, i32 1
  %225 = load i64, i64* %224
; # (? (atom (cdr Y)))
; # (cdr Y)
  %226 = inttoptr i64 %225 to i64*
  %227 = getelementptr i64, i64* %226, i32 1
  %228 = load i64, i64* %227
; # (atom (cdr Y))
  %229 = and i64 %228, 15
  %230 = icmp ne i64 %229, 0
  br i1 %230, label %$45, label %$44
$44:
  %231 = phi i64 [%218, %$43] ; # X
  %232 = phi i64 [%219, %$43] ; # Var
  %233 = phi i64 [%220, %$43] ; # Cnt
  %234 = phi i64 [%221, %$43] ; # P
  %235 = phi i64 [%222, %$43] ; # M
; # (let Z P (setq P @) (set 2 Y (val Tos)) (set Tos Z))
; # (set 2 Y (val Tos))
; # (val Tos)
  %236 = inttoptr i64 %196 to i64*
  %237 = load i64, i64* %236
  %238 = inttoptr i64 %225 to i64*
  %239 = getelementptr i64, i64* %238, i32 1
  store i64 %237, i64* %239
; # (set Tos Z)
  %240 = inttoptr i64 %196 to i64*
  store i64 %234, i64* %240
; # (| Cnt M)
  %241 = or i64 %233, %235
; # (shl M 1)
  %242 = shl i64 %235, 1
  br label %$43
$45:
  %243 = phi i64 [%218, %$43] ; # X
  %244 = phi i64 [%219, %$43] ; # Var
  %245 = phi i64 [%220, %$43] ; # Cnt
  %246 = phi i64 [%221, %$43] ; # P
  %247 = phi i64 [%222, %$43] ; # M
  %248 = phi i64 [0, %$43] ; # ->
; # (set Q P)
  %249 = inttoptr i64 %189 to i64*
  store i64 %246, i64* %249
; # (loop (unless (nil? (car P)) (set R (cons (cons (cnt (| Cnt M)) @...
  br label %$46
$46:
  %250 = phi i64 [%243, %$45], [%365, %$56] ; # X
  %251 = phi i64 [%244, %$45], [%366, %$56] ; # Var
  %252 = phi i64 [%245, %$45], [%367, %$56] ; # Cnt
  %253 = phi i64 [%246, %$45], [%368, %$56] ; # P
  %254 = phi i64 [%247, %$45], [%369, %$56] ; # M
; # (unless (nil? (car P)) (set R (cons (cons (cnt (| Cnt M)) @) (val...
; # (car P)
  %255 = inttoptr i64 %253 to i64*
  %256 = load i64, i64* %255
; # (nil? (car P))
  %257 = icmp eq i64 %256, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %257, label %$48, label %$47
$47:
  %258 = phi i64 [%250, %$46] ; # X
  %259 = phi i64 [%251, %$46] ; # Var
  %260 = phi i64 [%252, %$46] ; # Cnt
  %261 = phi i64 [%253, %$46] ; # P
  %262 = phi i64 [%254, %$46] ; # M
; # (set R (cons (cons (cnt (| Cnt M)) @) (val R)))
; # (| Cnt M)
  %263 = or i64 %260, %262
; # (cnt (| Cnt M))
  %264 = shl i64 %263, 4
  %265 = or i64 %264, 2
; # (cons (cnt (| Cnt M)) @)
  %266 = call i64 @cons(i64 %265, i64 %256)
; # (val R)
  %267 = inttoptr i64 %204 to i64*
  %268 = load i64, i64* %267
; # (cons (cons (cnt (| Cnt M)) @) (val R))
  %269 = call i64 @cons(i64 %266, i64 %268)
  %270 = inttoptr i64 %204 to i64*
  store i64 %269, i64* %270
  br label %$48
$48:
  %271 = phi i64 [%250, %$46], [%258, %$47] ; # X
  %272 = phi i64 [%251, %$46], [%259, %$47] ; # Var
  %273 = phi i64 [%252, %$46], [%260, %$47] ; # Cnt
  %274 = phi i64 [%253, %$46], [%261, %$47] ; # P
  %275 = phi i64 [%254, %$46], [%262, %$47] ; # M
; # (let Y (cdr P) (? (pair (car Y)) (let Z P (setq P @) (set Y (val ...
; # (cdr P)
  %276 = inttoptr i64 %274 to i64*
  %277 = getelementptr i64, i64* %276, i32 1
  %278 = load i64, i64* %277
; # (? (pair (car Y)) (let Z P (setq P @) (set Y (val Tos)) (set Tos ...
; # (car Y)
  %279 = inttoptr i64 %278 to i64*
  %280 = load i64, i64* %279
; # (pair (car Y))
  %281 = and i64 %280, 15
  %282 = icmp eq i64 %281, 0
  br i1 %282, label %$51, label %$49
$51:
  %283 = phi i64 [%271, %$48] ; # X
  %284 = phi i64 [%272, %$48] ; # Var
  %285 = phi i64 [%273, %$48] ; # Cnt
  %286 = phi i64 [%274, %$48] ; # P
  %287 = phi i64 [%275, %$48] ; # M
; # (let Z P (setq P @) (set Y (val Tos)) (set Tos (| Z 8)) (set Q P)...
; # (set Y (val Tos))
; # (val Tos)
  %288 = inttoptr i64 %196 to i64*
  %289 = load i64, i64* %288
  %290 = inttoptr i64 %278 to i64*
  store i64 %289, i64* %290
; # (set Tos (| Z 8))
; # (| Z 8)
  %291 = or i64 %286, 8
  %292 = inttoptr i64 %196 to i64*
  store i64 %291, i64* %292
; # (set Q P)
  %293 = inttoptr i64 %189 to i64*
  store i64 %280, i64* %293
; # (shl M 1)
  %294 = shl i64 %287, 1
  br label %$50
$49:
  %295 = phi i64 [%271, %$48] ; # X
  %296 = phi i64 [%272, %$48] ; # Var
  %297 = phi i64 [%273, %$48] ; # Cnt
  %298 = phi i64 [%274, %$48] ; # P
  %299 = phi i64 [%275, %$48] ; # M
; # (loop (let Y (val Tos) (when (== -ZERO Y) (ret (val R))) (? (=0 (...
  br label %$52
$52:
  %300 = phi i64 [%295, %$49], [%347, %$55] ; # X
  %301 = phi i64 [%296, %$49], [%348, %$55] ; # Var
  %302 = phi i64 [%297, %$49], [%356, %$55] ; # Cnt
  %303 = phi i64 [%298, %$49], [%353, %$55] ; # P
  %304 = phi i64 [%299, %$49], [%354, %$55] ; # M
; # (let Y (val Tos) (when (== -ZERO Y) (ret (val R))) (? (=0 (& Y 8)...
; # (val Tos)
  %305 = inttoptr i64 %196 to i64*
  %306 = load i64, i64* %305
; # (when (== -ZERO Y) (ret (val R)))
; # (== -ZERO Y)
  %307 = icmp eq i64 10, %306
  br i1 %307, label %$53, label %$54
$53:
  %308 = phi i64 [%300, %$52] ; # X
  %309 = phi i64 [%301, %$52] ; # Var
  %310 = phi i64 [%302, %$52] ; # Cnt
  %311 = phi i64 [%303, %$52] ; # P
  %312 = phi i64 [%304, %$52] ; # M
  %313 = phi i64 [%306, %$52] ; # Y
; # (val R)
  %314 = inttoptr i64 %204 to i64*
  %315 = load i64, i64* %314
; # (ret (val R))
; # (drop *Safe)
  %316 = inttoptr i64 %24 to i64*
  %317 = getelementptr i64, i64* %316, i32 1
  %318 = load i64, i64* %317
  %319 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %318, i64* %319
  ret i64 %315
$54:
  %320 = phi i64 [%300, %$52] ; # X
  %321 = phi i64 [%301, %$52] ; # Var
  %322 = phi i64 [%302, %$52] ; # Cnt
  %323 = phi i64 [%303, %$52] ; # P
  %324 = phi i64 [%304, %$52] ; # M
  %325 = phi i64 [%306, %$52] ; # Y
; # (? (=0 (& Y 8)) (setq M (shr M 1) Cnt (& Cnt (x| M -1))) (let Z (...
; # (& Y 8)
  %326 = and i64 %325, 8
; # (=0 (& Y 8))
  %327 = icmp eq i64 %326, 0
  br i1 %327, label %$57, label %$55
$57:
  %328 = phi i64 [%320, %$54] ; # X
  %329 = phi i64 [%321, %$54] ; # Var
  %330 = phi i64 [%322, %$54] ; # Cnt
  %331 = phi i64 [%323, %$54] ; # P
  %332 = phi i64 [%324, %$54] ; # M
  %333 = phi i64 [%325, %$54] ; # Y
; # (shr M 1)
  %334 = lshr i64 %332, 1
; # (x| M -1)
  %335 = xor i64 %334, -1
; # (& Cnt (x| M -1))
  %336 = and i64 %330, %335
; # (let Z (cdr Y) (set Tos (cdr Z)) (set 2 Z P) (setq P Y) (set Q P)...
; # (cdr Y)
  %337 = inttoptr i64 %333 to i64*
  %338 = getelementptr i64, i64* %337, i32 1
  %339 = load i64, i64* %338
; # (set Tos (cdr Z))
; # (cdr Z)
  %340 = inttoptr i64 %339 to i64*
  %341 = getelementptr i64, i64* %340, i32 1
  %342 = load i64, i64* %341
  %343 = inttoptr i64 %196 to i64*
  store i64 %342, i64* %343
; # (set 2 Z P)
  %344 = inttoptr i64 %339 to i64*
  %345 = getelementptr i64, i64* %344, i32 1
  store i64 %331, i64* %345
; # (set Q P)
  %346 = inttoptr i64 %189 to i64*
  store i64 %333, i64* %346
  br label %$56
$55:
  %347 = phi i64 [%320, %$54] ; # X
  %348 = phi i64 [%321, %$54] ; # Var
  %349 = phi i64 [%322, %$54] ; # Cnt
  %350 = phi i64 [%323, %$54] ; # P
  %351 = phi i64 [%324, %$54] ; # M
  %352 = phi i64 [%325, %$54] ; # Y
; # (& Y -9)
  %353 = and i64 %352, -9
; # (shr M 1)
  %354 = lshr i64 %351, 1
; # (x| M -1)
  %355 = xor i64 %354, -1
; # (& Cnt (x| M -1))
  %356 = and i64 %349, %355
; # (let Z (cdr Y) (set Tos (car Z)) (set Z P) (setq P Y) (set Q P))
; # (cdr Y)
  %357 = inttoptr i64 %353 to i64*
  %358 = getelementptr i64, i64* %357, i32 1
  %359 = load i64, i64* %358
; # (set Tos (car Z))
; # (car Z)
  %360 = inttoptr i64 %359 to i64*
  %361 = load i64, i64* %360
  %362 = inttoptr i64 %196 to i64*
  store i64 %361, i64* %362
; # (set Z P)
  %363 = inttoptr i64 %359 to i64*
  store i64 %350, i64* %363
; # (set Q P)
  %364 = inttoptr i64 %189 to i64*
  store i64 %353, i64* %364
  br label %$52
$56:
  %365 = phi i64 [%328, %$57] ; # X
  %366 = phi i64 [%329, %$57] ; # Var
  %367 = phi i64 [%336, %$57] ; # Cnt
  %368 = phi i64 [%333, %$57] ; # P
  %369 = phi i64 [%334, %$57] ; # M
  %370 = phi i64 [%333, %$57] ; # ->
  br label %$46
$50:
  %371 = phi i64 [%283, %$51] ; # X
  %372 = phi i64 [%284, %$51] ; # Var
  %373 = phi i64 [%285, %$51] ; # Cnt
  %374 = phi i64 [%280, %$51] ; # P
  %375 = phi i64 [%294, %$51] ; # M
  %376 = phi i64 [%294, %$51] ; # ->
  br label %$42
$15:
  %377 = phi i64 [%182, %$18] ; # X
  %378 = phi i64 [%183, %$18] ; # Var
  %379 = phi i64 [%184, %$18] ; # Cnt
  %380 = phi i64 [%185, %$18] ; # ->
; # (drop *Safe)
  %381 = inttoptr i64 %24 to i64*
  %382 = getelementptr i64, i64* %381, i32 1
  %383 = load i64, i64* %382
  %384 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %383, i64* %384
  ret i64 %380
}

define i64 @_enumQ(i64) align 8 {
$1:
; # (let (X (cdr Exe) P (save (eval (++ X))) Cnt T) (loop (? (le0 (se...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (loop (? (le0 (setq Cnt (evCnt Exe X))) $Nil) (loop (let N (shr C...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%89, %$19] ; # X
  %25 = phi i64 [%15, %$2], [%93, %$19] ; # P
; # (? (le0 (setq Cnt (evCnt Exe X))) $Nil)
; # (evCnt Exe X)
  %26 = call i64 @evCnt(i64 %0, i64 %24)
; # (le0 (setq Cnt (evCnt Exe X)))
  %27 = icmp sle i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%24, %$7] ; # X
  %29 = phi i64 [%25, %$7] ; # P
  %30 = phi i64 [%26, %$7] ; # Cnt
  br label %$9
$8:
  %31 = phi i64 [%24, %$7] ; # X
  %32 = phi i64 [%25, %$7] ; # P
  %33 = phi i64 [%26, %$7] ; # Cnt
; # (loop (let N (shr Cnt 1) (? (=0 N)) (setq P (if (& Cnt 1) (cddr P...
  br label %$11
$11:
  %34 = phi i64 [%31, %$8], [%74, %$17] ; # X
  %35 = phi i64 [%32, %$8], [%75, %$17] ; # P
  %36 = phi i64 [%33, %$8], [%37, %$17] ; # Cnt
; # (let N (shr Cnt 1) (? (=0 N)) (setq P (if (& Cnt 1) (cddr P) (cad...
; # (shr Cnt 1)
  %37 = lshr i64 %36, 1
; # (? (=0 N))
; # (=0 N)
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$13, label %$12
$12:
  %39 = phi i64 [%34, %$11] ; # X
  %40 = phi i64 [%35, %$11] ; # P
  %41 = phi i64 [%36, %$11] ; # Cnt
; # (if (& Cnt 1) (cddr P) (cadr P))
; # (& Cnt 1)
  %42 = and i64 %41, 1
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$14, label %$15
$14:
  %44 = phi i64 [%39, %$12] ; # X
  %45 = phi i64 [%40, %$12] ; # P
  %46 = phi i64 [%41, %$12] ; # Cnt
; # (cddr P)
  %47 = inttoptr i64 %45 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 %49 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  br label %$16
$15:
  %53 = phi i64 [%39, %$12] ; # X
  %54 = phi i64 [%40, %$12] ; # P
  %55 = phi i64 [%41, %$12] ; # Cnt
; # (cadr P)
  %56 = inttoptr i64 %54 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 %58 to i64*
  %60 = load i64, i64* %59
  br label %$16
$16:
  %61 = phi i64 [%44, %$14], [%53, %$15] ; # X
  %62 = phi i64 [%45, %$14], [%54, %$15] ; # P
  %63 = phi i64 [%46, %$14], [%55, %$15] ; # Cnt
  %64 = phi i64 [%52, %$14], [%60, %$15] ; # ->
; # (? (atom P) (ret $Nil))
; # (atom P)
  %65 = and i64 %64, 15
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$18, label %$17
$18:
  %67 = phi i64 [%61, %$16] ; # X
  %68 = phi i64 [%64, %$16] ; # P
  %69 = phi i64 [%63, %$16] ; # Cnt
; # (ret $Nil)
; # (drop *Safe)
  %70 = inttoptr i64 %19 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %72, i64* %73
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$17:
  %74 = phi i64 [%61, %$16] ; # X
  %75 = phi i64 [%64, %$16] ; # P
  %76 = phi i64 [%63, %$16] ; # Cnt
  br label %$11
$13:
  %77 = phi i64 [%34, %$11] ; # X
  %78 = phi i64 [%35, %$11] ; # P
  %79 = phi i64 [%36, %$11] ; # Cnt
  %80 = phi i64 [0, %$11] ; # ->
; # (? (atom (shift X)) P)
; # (shift X)
  %81 = inttoptr i64 %77 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (atom (shift X))
  %84 = and i64 %83, 15
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$20, label %$19
$20:
  %86 = phi i64 [%83, %$13] ; # X
  %87 = phi i64 [%78, %$13] ; # P
  %88 = phi i64 [%79, %$13] ; # Cnt
  br label %$9
$19:
  %89 = phi i64 [%83, %$13] ; # X
  %90 = phi i64 [%78, %$13] ; # P
  %91 = phi i64 [%79, %$13] ; # Cnt
; # (car P)
  %92 = inttoptr i64 %90 to i64*
  %93 = load i64, i64* %92
  br label %$7
$9:
  %94 = phi i64 [%28, %$10], [%86, %$20] ; # X
  %95 = phi i64 [%29, %$10], [%87, %$20] ; # P
  %96 = phi i64 [%30, %$10], [%88, %$20] ; # Cnt
  %97 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [%87, %$20] ; # ->
; # (drop *Safe)
  %98 = inttoptr i64 %19 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %100, i64* %101
  ret i64 %97
}

define i64 @idxPut(i64, i64) align 8 {
$1:
; # (let X (val Var) (if (pair X) (loop (? (=0 (compare (car X) Key))...
; # (val Var)
  %2 = inttoptr i64 %0 to i64*
  %3 = load i64, i64* %2
; # (if (pair X) (loop (? (=0 (compare (car X) Key)) X) (let Y (cdr X...
; # (pair X)
  %4 = and i64 %3, 15
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
; # (loop (? (=0 (compare (car X) Key)) X) (let Y (cdr X) (cond ((lt0...
  br label %$5
$5:
  %7 = phi i64 [%6, %$2], [%65, %$9] ; # X
; # (? (=0 (compare (car X) Key)) X)
; # (car X)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (compare (car X) Key)
  %10 = call i64 @compare(i64 %9, i64 %1)
; # (=0 (compare (car X) Key))
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$8, label %$6
$8:
  %12 = phi i64 [%7, %$5] ; # X
  br label %$7
$6:
  %13 = phi i64 [%7, %$5] ; # X
; # (let Y (cdr X) (cond ((lt0 @) (? (atom Y) (set 2 X (cons $Nil (co...
; # (cdr X)
  %14 = inttoptr i64 %13 to i64*
  %15 = getelementptr i64, i64* %14, i32 1
  %16 = load i64, i64* %15
; # (cond ((lt0 @) (? (atom Y) (set 2 X (cons $Nil (cons Key $Nil))) ...
; # (lt0 @)
  %17 = icmp slt i64 %10, 0
  br i1 %17, label %$11, label %$10
$11:
  %18 = phi i64 [%13, %$6] ; # X
  %19 = phi i64 [%16, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons $Nil (cons Key $Nil))) $Nil)
; # (atom Y)
  %20 = and i64 %19, 15
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  %22 = phi i64 [%18, %$11] ; # X
  %23 = phi i64 [%19, %$11] ; # Y
; # (set 2 X (cons $Nil (cons Key $Nil)))
; # (cons Key $Nil)
  %24 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Nil (cons Key $Nil))
  %25 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %24)
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  br label %$7
$12:
  %28 = phi i64 [%18, %$11] ; # X
  %29 = phi i64 [%19, %$11] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (set 2 X (cons Key $Nil)) $Ni...
; # (cdr (setq X Y))
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (atom (setq Y (cdr (setq X Y))))
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$15, label %$14
$15:
  %35 = phi i64 [%29, %$12] ; # X
  %36 = phi i64 [%32, %$12] ; # Y
; # (set 2 X (cons Key $Nil))
; # (cons Key $Nil)
  %37 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %38 = inttoptr i64 %35 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  store i64 %37, i64* %39
  br label %$7
$14:
  %40 = phi i64 [%29, %$12] ; # X
  %41 = phi i64 [%32, %$12] ; # Y
  br label %$9
$10:
  %42 = phi i64 [%13, %$6] ; # X
  %43 = phi i64 [%16, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons (cons Key $Nil) $Nil)) $Nil)
; # (atom Y)
  %44 = and i64 %43, 15
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$17, label %$16
$17:
  %46 = phi i64 [%42, %$10] ; # X
  %47 = phi i64 [%43, %$10] ; # Y
; # (set 2 X (cons (cons Key $Nil) $Nil))
; # (cons Key $Nil)
  %48 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cons Key $Nil) $Nil)
  %49 = call i64 @cons(i64 %48, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %50 = inttoptr i64 %46 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  store i64 %49, i64* %51
  br label %$7
$16:
  %52 = phi i64 [%42, %$10] ; # X
  %53 = phi i64 [%43, %$10] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (set X (cons Key $Nil)) $Nil)...
; # (car (setq X Y))
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (atom (setq Y (car (setq X Y))))
  %56 = and i64 %55, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$19, label %$18
$19:
  %58 = phi i64 [%53, %$16] ; # X
  %59 = phi i64 [%55, %$16] ; # Y
; # (set X (cons Key $Nil))
; # (cons Key $Nil)
  %60 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %61 = inttoptr i64 %58 to i64*
  store i64 %60, i64* %61
  br label %$7
$18:
  %62 = phi i64 [%53, %$16] ; # X
  %63 = phi i64 [%55, %$16] ; # Y
  br label %$9
$9:
  %64 = phi i64 [%40, %$14], [%62, %$18] ; # X
  %65 = phi i64 [%41, %$14], [%63, %$18] ; # Y
  br label %$5
$7:
  %66 = phi i64 [%12, %$8], [%22, %$13], [%35, %$15], [%46, %$17], [%58, %$19] ; # X
  %67 = phi i64 [%12, %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$19] ; # ->
  br label %$4
$3:
  %68 = phi i64 [%3, %$1] ; # X
; # (set Var (cons Key $Nil))
; # (cons Key $Nil)
  %69 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %70 = inttoptr i64 %0 to i64*
  store i64 %69, i64* %70
  br label %$4
$4:
  %71 = phi i64 [%66, %$7], [%68, %$3] ; # X
  %72 = phi i64 [%67, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %72
}

define i64 @idxGet(i64, i64) align 8 {
$1:
; # (let X (val Var) (loop (? (atom X) $Nil) (? (=0 (compare (car X) ...
; # (val Var)
  %2 = inttoptr i64 %0 to i64*
  %3 = load i64, i64* %2
; # (loop (? (atom X) $Nil) (? (=0 (compare (car X) Key)) X) (let Y (...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%27, %$10] ; # X
; # (? (atom X) $Nil)
; # (atom X)
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%4, %$2] ; # X
  br label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
; # (? (=0 (compare (car X) Key)) X)
; # (car X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (compare (car X) Key)
  %11 = call i64 @compare(i64 %10, i64 %1)
; # (=0 (compare (car X) Key))
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = phi i64 [%8, %$3] ; # X
  br label %$4
$6:
  %14 = phi i64 [%8, %$3] ; # X
; # (let Y (cdr X) (setq X (if (lt0 @) (cdr Y) (car Y))))
; # (cdr X)
  %15 = inttoptr i64 %14 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
; # (if (lt0 @) (cdr Y) (car Y))
; # (lt0 @)
  %18 = icmp slt i64 %11, 0
  br i1 %18, label %$8, label %$9
$8:
  %19 = phi i64 [%14, %$6] ; # X
; # (cdr Y)
  %20 = inttoptr i64 %17 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
  br label %$10
$9:
  %23 = phi i64 [%14, %$6] ; # X
; # (car Y)
  %24 = inttoptr i64 %17 to i64*
  %25 = load i64, i64* %24
  br label %$10
$10:
  %26 = phi i64 [%19, %$8], [%23, %$9] ; # X
  %27 = phi i64 [%22, %$8], [%25, %$9] ; # ->
  br label %$2
$4:
  %28 = phi i64 [%7, %$5], [%13, %$7] ; # X
  %29 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%13, %$7] ; # ->
  ret i64 %29
}

define i64 @idxDel(i64, i64) align 8 {
$1:
; # (loop (let X (val Var) (? (atom X) $Nil) (let Y (cdr X) (let I (c...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%126, %$21] ; # Var
; # (let X (val Var) (? (atom X) $Nil) (let Y (cdr X) (let I (compare...
; # (val Var)
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (? (atom X) $Nil)
; # (atom X)
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%2, %$2] ; # Var
  br label %$4
$3:
  %8 = phi i64 [%2, %$2] ; # Var
; # (let Y (cdr X) (let I (compare (car X) Key) (? (=0 I) (cond ((ato...
; # (cdr X)
  %9 = inttoptr i64 %4 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (let I (compare (car X) Key) (? (=0 I) (cond ((atom (car Y)) (set...
; # (car X)
  %12 = inttoptr i64 %4 to i64*
  %13 = load i64, i64* %12
; # (compare (car X) Key)
  %14 = call i64 @compare(i64 %13, i64 %1)
; # (? (=0 I) (cond ((atom (car Y)) (set Var (cdr Y))) ((atom (cdr Y)...
; # (=0 I)
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  %16 = phi i64 [%8, %$3] ; # Var
  %17 = phi i64 [%11, %$3] ; # Y
; # (cond ((atom (car Y)) (set Var (cdr Y))) ((atom (cdr Y)) (set Var...
; # (car Y)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (atom (car Y))
  %20 = and i64 %19, 15
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$9
$10:
  %22 = phi i64 [%16, %$7] ; # Var
  %23 = phi i64 [%17, %$7] ; # Y
; # (set Var (cdr Y))
; # (cdr Y)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %22 to i64*
  store i64 %26, i64* %27
  br label %$8
$9:
  %28 = phi i64 [%16, %$7] ; # Var
  %29 = phi i64 [%17, %$7] ; # Y
; # (cdr Y)
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (atom (cdr Y))
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  %35 = phi i64 [%28, %$9] ; # Var
  %36 = phi i64 [%29, %$9] ; # Y
; # (set Var (car Y))
; # (car Y)
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %35 to i64*
  store i64 %38, i64* %39
  br label %$8
$11:
  %40 = phi i64 [%28, %$9] ; # Var
  %41 = phi i64 [%29, %$9] ; # Y
; # (let Z (cdr (setq Y (cdr Y))) (if (atom (car Z)) (set X (car Y) 2...
; # (cdr Y)
  %42 = inttoptr i64 %41 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
; # (cdr (setq Y (cdr Y)))
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (if (atom (car Z)) (set X (car Y) 2 (cdr X) (cdr Z)) (let L (cdr ...
; # (car Z)
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (atom (car Z))
  %50 = and i64 %49, 15
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$13, label %$14
$13:
  %52 = phi i64 [%40, %$11] ; # Var
  %53 = phi i64 [%44, %$11] ; # Y
  %54 = phi i64 [%47, %$11] ; # Z
; # (set X (car Y) 2 (cdr X) (cdr Z))
; # (car Y)
  %55 = inttoptr i64 %53 to i64*
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %4 to i64*
  store i64 %56, i64* %57
; # (cdr X)
  %58 = inttoptr i64 %4 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
; # (cdr Z)
  %61 = inttoptr i64 %54 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
  %64 = inttoptr i64 %60 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  store i64 %63, i64* %65
  br label %$15
$14:
  %66 = phi i64 [%40, %$11] ; # Var
  %67 = phi i64 [%44, %$11] ; # Y
  %68 = phi i64 [%47, %$11] ; # Z
; # (let L (cdr (setq Z (car Z))) (loop (? (atom (car L))) (setq Y Z ...
; # (car Z)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (cdr (setq Z (car Z)))
  %71 = inttoptr i64 %70 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
; # (loop (? (atom (car L))) (setq Y Z Z (car L) L (cdr Z)))
  br label %$16
$16:
  %74 = phi i64 [%66, %$14], [%82, %$17] ; # Var
  %75 = phi i64 [%67, %$14], [%84, %$17] ; # Y
  %76 = phi i64 [%70, %$14], [%87, %$17] ; # Z
  %77 = phi i64 [%73, %$14], [%90, %$17] ; # L
; # (? (atom (car L)))
; # (car L)
  %78 = inttoptr i64 %77 to i64*
  %79 = load i64, i64* %78
; # (atom (car L))
  %80 = and i64 %79, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$18, label %$17
$17:
  %82 = phi i64 [%74, %$16] ; # Var
  %83 = phi i64 [%75, %$16] ; # Y
  %84 = phi i64 [%76, %$16] ; # Z
  %85 = phi i64 [%77, %$16] ; # L
; # (car L)
  %86 = inttoptr i64 %85 to i64*
  %87 = load i64, i64* %86
; # (cdr Z)
  %88 = inttoptr i64 %87 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  br label %$16
$18:
  %91 = phi i64 [%74, %$16] ; # Var
  %92 = phi i64 [%75, %$16] ; # Y
  %93 = phi i64 [%76, %$16] ; # Z
  %94 = phi i64 [%77, %$16] ; # L
  %95 = phi i64 [0, %$16] ; # ->
; # (set X (car Z) (cdr Y) (cdr L))
; # (car Z)
  %96 = inttoptr i64 %93 to i64*
  %97 = load i64, i64* %96
  %98 = inttoptr i64 %4 to i64*
  store i64 %97, i64* %98
; # (cdr Y)
  %99 = inttoptr i64 %92 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
; # (cdr L)
  %102 = inttoptr i64 %94 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  %105 = inttoptr i64 %101 to i64*
  store i64 %104, i64* %105
  br label %$15
$15:
  %106 = phi i64 [%52, %$13], [%91, %$18] ; # Var
  %107 = phi i64 [%53, %$13], [%92, %$18] ; # Y
  %108 = phi i64 [%54, %$13], [%93, %$18] ; # Z
  %109 = phi i64 [%63, %$13], [%104, %$18] ; # ->
  br label %$8
$8:
  %110 = phi i64 [%22, %$10], [%35, %$12], [%106, %$15] ; # Var
  %111 = phi i64 [%23, %$10], [%36, %$12], [%107, %$15] ; # Y
  %112 = phi i64 [%26, %$10], [%38, %$12], [%109, %$15] ; # ->
  br label %$4
$6:
  %113 = phi i64 [%8, %$3] ; # Var
  %114 = phi i64 [%11, %$3] ; # Y
; # (? (atom Y) $Nil)
; # (atom Y)
  %115 = and i64 %114, 15
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$20, label %$19
$20:
  %117 = phi i64 [%113, %$6] ; # Var
  %118 = phi i64 [%114, %$6] ; # Y
  br label %$4
$19:
  %119 = phi i64 [%113, %$6] ; # Var
  %120 = phi i64 [%114, %$6] ; # Y
; # (and (lt0 I) (setq Var (ofs Var 1)))
; # (lt0 I)
  %121 = icmp slt i64 %14, 0
  br i1 %121, label %$22, label %$21
$22:
  %122 = phi i64 [%120, %$19] ; # Var
  %123 = phi i64 [%120, %$19] ; # Y
; # (ofs Var 1)
  %124 = add i64 %122, 8
  %125 = icmp ne i64 %124, 0
  br label %$21
$21:
  %126 = phi i64 [%120, %$19], [%124, %$22] ; # Var
  %127 = phi i64 [%120, %$19], [%123, %$22] ; # Y
  %128 = phi i1 [0, %$19], [%125, %$22] ; # ->
  br label %$2
$4:
  %129 = phi i64 [%7, %$5], [%110, %$8], [%117, %$20] ; # Var
  %130 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%4, %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$20] ; # ->
  ret i64 %130
}

define i64 @_idx(i64) align 8 {
$1:
; # (let (X (cdr Exe) Var (needChkVar Exe (eval (++ X)))) (if (atom X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (if (atom X) (consTree (val Var) $Nil) (save Var (let Key (save (...
; # (atom X)
  %21 = and i64 %7, 15
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$13, label %$14
$13:
  %23 = phi i64 [%7, %$12] ; # X
; # (val Var)
  %24 = inttoptr i64 %15 to i64*
  %25 = load i64, i64* %24
; # (consTree (val Var) $Nil)
  %26 = call i64 @consTree(i64 %25, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$15
$14:
  %27 = phi i64 [%7, %$12] ; # X
; # (save Var (let Key (save (eval (++ X))) (cond ((atom X) (idxGet V...
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %15, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %29, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
; # (let Key (save (eval (++ X))) (cond ((atom X) (idxGet Var Key)) (...
; # (++ X)
  %36 = inttoptr i64 %27 to i64*
  %37 = load i64, i64* %36
  %38 = getelementptr i64, i64* %36, i32 1
  %39 = load i64, i64* %38
; # (eval (++ X))
  %40 = and i64 %37, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$18, label %$17
$18:
  br label %$16
$17:
  %42 = and i64 %37, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$20, label %$19
$20:
  %44 = inttoptr i64 %37 to i64*
  %45 = load i64, i64* %44
  br label %$16
$19:
  %46 = call i64 @evList(i64 %37)
  br label %$16
$16:
  %47 = phi i64 [%37, %$18], [%45, %$20], [%46, %$19] ; # ->
; # (save (eval (++ X)))
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %49 = load i64, i64* %48
  %50 = alloca i64, i64 2, align 16
  %51 = ptrtoint i64* %50 to i64
  %52 = inttoptr i64 %51 to i64*
  store i64 %47, i64* %52
  %53 = add i64 %51, 8
  %54 = inttoptr i64 %53 to i64*
  store i64 %49, i64* %54
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %55
; # (cond ((atom X) (idxGet Var Key)) ((nil? (eval (car X))) (idxDel ...
; # (atom X)
  %56 = and i64 %39, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$23, label %$22
$23:
  %58 = phi i64 [%39, %$16] ; # X
; # (idxGet Var Key)
  %59 = call i64 @idxGet(i64 %15, i64 %47)
  br label %$21
$22:
  %60 = phi i64 [%39, %$16] ; # X
; # (car X)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (eval (car X))
  %63 = and i64 %62, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$26, label %$25
$26:
  br label %$24
$25:
  %65 = and i64 %62, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$28, label %$27
$28:
  %67 = inttoptr i64 %62 to i64*
  %68 = load i64, i64* %67
  br label %$24
$27:
  %69 = call i64 @evList(i64 %62)
  br label %$24
$24:
  %70 = phi i64 [%62, %$26], [%68, %$28], [%69, %$27] ; # ->
; # (nil? (eval (car X)))
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %71, label %$30, label %$29
$30:
  %72 = phi i64 [%60, %$24] ; # X
; # (idxDel Var Key)
  %73 = call i64 @idxDel(i64 %15, i64 %47)
  br label %$21
$29:
  %74 = phi i64 [%60, %$24] ; # X
; # (idxPut Var Key)
  %75 = call i64 @idxPut(i64 %15, i64 %47)
  br label %$21
$21:
  %76 = phi i64 [%58, %$23], [%72, %$30], [%74, %$29] ; # X
  %77 = phi i64 [%59, %$23], [%73, %$30], [%75, %$29] ; # ->
; # drop
  %78 = inttoptr i64 %31 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  %80 = load i64, i64* %79
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %81
  br label %$15
$15:
  %82 = phi i64 [%23, %$13], [%76, %$21] ; # X
  %83 = phi i64 [%26, %$13], [%77, %$21] ; # ->
  ret i64 %83
}

define i64 @_lup(i64) align 8 {
$1:
; # (let (X (cdr Exe) P (save (eval (++ X)))) (if (atom P) P (let Key...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (if (atom P) P (let Key (eval (++ X)) (if (atom X) (loop (let Y (...
; # (atom P)
  %24 = and i64 %15, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$7, label %$8
$7:
  %26 = phi i64 [%7, %$2] ; # X
  %27 = phi i64 [%15, %$2] ; # P
  br label %$9
$8:
  %28 = phi i64 [%7, %$2] ; # X
  %29 = phi i64 [%15, %$2] ; # P
; # (let Key (eval (++ X)) (if (atom X) (loop (let Y (car P) (cond ((...
; # (++ X)
  %30 = inttoptr i64 %28 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
; # (eval (++ X))
  %34 = and i64 %31, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %31, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %31 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %31)
  br label %$10
$10:
  %41 = phi i64 [%31, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (if (atom X) (loop (let Y (car P) (cond ((t? Y) (setq P (cadr P))...
; # (atom X)
  %42 = and i64 %33, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$15, label %$16
$15:
  %44 = phi i64 [%33, %$10] ; # X
  %45 = phi i64 [%29, %$10] ; # P
; # (loop (let Y (car P) (cond ((t? Y) (setq P (cadr P))) ((atom Y) (...
  br label %$18
$18:
  %46 = phi i64 [%44, %$15], [%105, %$30] ; # X
  %47 = phi i64 [%45, %$15], [%106, %$30] ; # P
; # (let Y (car P) (cond ((t? Y) (setq P (cadr P))) ((atom Y) (setq P...
; # (car P)
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (cond ((t? Y) (setq P (cadr P))) ((atom Y) (setq P (cddr P))) (T ...
; # (t? Y)
  %50 = icmp eq i64 %49, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %50, label %$21, label %$20
$21:
  %51 = phi i64 [%46, %$18] ; # X
  %52 = phi i64 [%47, %$18] ; # P
; # (cadr P)
  %53 = inttoptr i64 %52 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
  br label %$19
$20:
  %58 = phi i64 [%46, %$18] ; # X
  %59 = phi i64 [%47, %$18] ; # P
; # (atom Y)
  %60 = and i64 %49, 15
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$23, label %$22
$23:
  %62 = phi i64 [%58, %$20] ; # X
  %63 = phi i64 [%59, %$20] ; # P
; # (cddr P)
  %64 = inttoptr i64 %63 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  %66 = load i64, i64* %65
  %67 = inttoptr i64 %66 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  br label %$19
$22:
  %70 = phi i64 [%58, %$20] ; # X
  %71 = phi i64 [%59, %$20] ; # P
; # (? (=0 (compare (car Y) Key)) (car P))
; # (car Y)
  %72 = inttoptr i64 %49 to i64*
  %73 = load i64, i64* %72
; # (compare (car Y) Key)
  %74 = call i64 @compare(i64 %73, i64 %41)
; # (=0 (compare (car Y) Key))
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$26, label %$24
$26:
  %76 = phi i64 [%70, %$22] ; # X
  %77 = phi i64 [%71, %$22] ; # P
; # (car P)
  %78 = inttoptr i64 %77 to i64*
  %79 = load i64, i64* %78
  br label %$25
$24:
  %80 = phi i64 [%70, %$22] ; # X
  %81 = phi i64 [%71, %$22] ; # P
; # (cdr P)
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (if (lt0 @) (cdr P) (car P))
; # (lt0 @)
  %85 = icmp slt i64 %74, 0
  br i1 %85, label %$27, label %$28
$27:
  %86 = phi i64 [%80, %$24] ; # X
  %87 = phi i64 [%84, %$24] ; # P
; # (cdr P)
  %88 = inttoptr i64 %87 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  br label %$29
$28:
  %91 = phi i64 [%80, %$24] ; # X
  %92 = phi i64 [%84, %$24] ; # P
; # (car P)
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
  br label %$29
$29:
  %95 = phi i64 [%86, %$27], [%91, %$28] ; # X
  %96 = phi i64 [%87, %$27], [%92, %$28] ; # P
  %97 = phi i64 [%90, %$27], [%94, %$28] ; # ->
  br label %$19
$19:
  %98 = phi i64 [%51, %$21], [%62, %$23], [%95, %$29] ; # X
  %99 = phi i64 [%57, %$21], [%69, %$23], [%97, %$29] ; # P
  %100 = phi i64 [%57, %$21], [%69, %$23], [%97, %$29] ; # ->
; # (? (atom P) $Nil)
; # (atom P)
  %101 = and i64 %99, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$31, label %$30
$31:
  %103 = phi i64 [%98, %$19] ; # X
  %104 = phi i64 [%99, %$19] ; # P
  br label %$25
$30:
  %105 = phi i64 [%98, %$19] ; # X
  %106 = phi i64 [%99, %$19] ; # P
  br label %$18
$25:
  %107 = phi i64 [%76, %$26], [%103, %$31] ; # X
  %108 = phi i64 [%77, %$26], [%104, %$31] ; # P
  %109 = phi i64 [%79, %$26], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$31] ; # ->
  br label %$17
$16:
  %110 = phi i64 [%33, %$10] ; # X
  %111 = phi i64 [%29, %$10] ; # P
; # (save Key)
  %112 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %113 = load i64, i64* %112
  %114 = alloca i64, i64 2, align 16
  %115 = ptrtoint i64* %114 to i64
  %116 = inttoptr i64 %115 to i64*
  store i64 %41, i64* %116
  %117 = add i64 %115, 8
  %118 = inttoptr i64 %117 to i64*
  store i64 %113, i64* %118
  %119 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %115, i64* %119
; # (let (Key2 (save (eval (car X))) Q (link (push NIL NIL)) Tos (lin...
; # (car X)
  %120 = inttoptr i64 %110 to i64*
  %121 = load i64, i64* %120
; # (eval (car X))
  %122 = and i64 %121, 6
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$34, label %$33
$34:
  br label %$32
$33:
  %124 = and i64 %121, 8
  %125 = icmp ne i64 %124, 0
  br i1 %125, label %$36, label %$35
$36:
  %126 = inttoptr i64 %121 to i64*
  %127 = load i64, i64* %126
  br label %$32
$35:
  %128 = call i64 @evList(i64 %121)
  br label %$32
$32:
  %129 = phi i64 [%121, %$34], [%127, %$36], [%128, %$35] ; # ->
; # (save (eval (car X)))
  %130 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %131 = load i64, i64* %130
  %132 = alloca i64, i64 2, align 16
  %133 = ptrtoint i64* %132 to i64
  %134 = inttoptr i64 %133 to i64*
  store i64 %129, i64* %134
  %135 = add i64 %133, 8
  %136 = inttoptr i64 %135 to i64*
  store i64 %131, i64* %136
  %137 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %133, i64* %137
; # (push NIL NIL)
  %138 = alloca i64, i64 2, align 16
  %139 = ptrtoint i64* %138 to i64
; # (link (push NIL NIL))
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %141 = load i64, i64* %140
  %142 = inttoptr i64 %139 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  store i64 %141, i64* %143
  %144 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %139, i64* %144
; # (push -ZERO NIL)
  %145 = alloca i64, i64 2, align 16
  %146 = ptrtoint i64* %145 to i64
  %147 = inttoptr i64 %146 to i64*
  store i64 10, i64* %147
; # (link (push -ZERO NIL))
  %148 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %149 = load i64, i64* %148
  %150 = inttoptr i64 %146 to i64*
  %151 = getelementptr i64, i64* %150, i32 1
  store i64 %149, i64* %151
  %152 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %146, i64* %152
; # (loop (loop (let Y (cdr (setq X (cdr P))) (? (atom Y)) (let Z (ca...
  br label %$37
$37:
  %153 = phi i64 [%110, %$32], [%303, %$53] ; # X
  %154 = phi i64 [%111, %$32], [%304, %$53] ; # P
  %155 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$32], [%305, %$53] ; # R
; # (loop (let Y (cdr (setq X (cdr P))) (? (atom Y)) (let Z (car P) (...
  br label %$38
$38:
  %156 = phi i64 [%153, %$37], [%189, %$44] ; # X
  %157 = phi i64 [%154, %$37], [%164, %$44] ; # P
  %158 = phi i64 [%155, %$37], [%191, %$44] ; # R
; # (let Y (cdr (setq X (cdr P))) (? (atom Y)) (let Z (car P) (? (t? ...
; # (cdr P)
  %159 = inttoptr i64 %157 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  %161 = load i64, i64* %160
; # (cdr (setq X (cdr P)))
  %162 = inttoptr i64 %161 to i64*
  %163 = getelementptr i64, i64* %162, i32 1
  %164 = load i64, i64* %163
; # (? (atom Y))
; # (atom Y)
  %165 = and i64 %164, 15
  %166 = icmp ne i64 %165, 0
  br i1 %166, label %$40, label %$39
$39:
  %167 = phi i64 [%161, %$38] ; # X
  %168 = phi i64 [%157, %$38] ; # P
  %169 = phi i64 [%158, %$38] ; # R
; # (let Z (car P) (? (t? Z)) (? (and (pair Z) (gt0 (compare (car Z) ...
; # (car P)
  %170 = inttoptr i64 %168 to i64*
  %171 = load i64, i64* %170
; # (? (t? Z))
; # (t? Z)
  %172 = icmp eq i64 %171, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %172, label %$40, label %$41
$41:
  %173 = phi i64 [%167, %$39] ; # X
  %174 = phi i64 [%168, %$39] ; # P
  %175 = phi i64 [%169, %$39] ; # R
; # (? (and (pair Z) (gt0 (compare (car Z) Key2))))
; # (and (pair Z) (gt0 (compare (car Z) Key2)))
; # (pair Z)
  %176 = and i64 %171, 15
  %177 = icmp eq i64 %176, 0
  br i1 %177, label %$43, label %$42
$43:
  %178 = phi i64 [%173, %$41] ; # X
  %179 = phi i64 [%174, %$41] ; # P
  %180 = phi i64 [%175, %$41] ; # R
; # (car Z)
  %181 = inttoptr i64 %171 to i64*
  %182 = load i64, i64* %181
; # (compare (car Z) Key2)
  %183 = call i64 @compare(i64 %182, i64 %129)
; # (gt0 (compare (car Z) Key2))
  %184 = icmp sgt i64 %183, 0
  br label %$42
$42:
  %185 = phi i64 [%173, %$41], [%178, %$43] ; # X
  %186 = phi i64 [%174, %$41], [%179, %$43] ; # P
  %187 = phi i64 [%175, %$41], [%180, %$43] ; # R
  %188 = phi i1 [0, %$41], [%184, %$43] ; # ->
  br i1 %188, label %$40, label %$44
$44:
  %189 = phi i64 [%185, %$42] ; # X
  %190 = phi i64 [%186, %$42] ; # P
  %191 = phi i64 [%187, %$42] ; # R
; # (let Z P (setq P Y) (set 2 X (val Tos)) (set Tos Z))
; # (set 2 X (val Tos))
; # (val Tos)
  %192 = inttoptr i64 %146 to i64*
  %193 = load i64, i64* %192
  %194 = inttoptr i64 %189 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  store i64 %193, i64* %195
; # (set Tos Z)
  %196 = inttoptr i64 %146 to i64*
  store i64 %190, i64* %196
  br label %$38
$40:
  %197 = phi i64 [%161, %$38], [%167, %$39], [%185, %$42] ; # X
  %198 = phi i64 [%157, %$38], [%168, %$39], [%186, %$42] ; # P
  %199 = phi i64 [%158, %$38], [%169, %$39], [%187, %$42] ; # R
  %200 = phi i64 [0, %$38], [0, %$39], [0, %$42] ; # ->
; # (set Q P)
  %201 = inttoptr i64 %139 to i64*
  store i64 %198, i64* %201
; # (loop (when (and (pair (setq X (car P))) (ge0 (compare (car X) Ke...
  br label %$45
$45:
  %202 = phi i64 [%197, %$40], [%299, %$59] ; # X
  %203 = phi i64 [%198, %$40], [%300, %$59] ; # P
  %204 = phi i64 [%199, %$40], [%301, %$59] ; # R
; # (when (and (pair (setq X (car P))) (ge0 (compare (car X) Key))) (...
; # (and (pair (setq X (car P))) (ge0 (compare (car X) Key)))
; # (car P)
  %205 = inttoptr i64 %203 to i64*
  %206 = load i64, i64* %205
; # (pair (setq X (car P)))
  %207 = and i64 %206, 15
  %208 = icmp eq i64 %207, 0
  br i1 %208, label %$47, label %$46
$47:
  %209 = phi i64 [%206, %$45] ; # X
  %210 = phi i64 [%203, %$45] ; # P
  %211 = phi i64 [%204, %$45] ; # R
; # (car X)
  %212 = inttoptr i64 %209 to i64*
  %213 = load i64, i64* %212
; # (compare (car X) Key)
  %214 = call i64 @compare(i64 %213, i64 %41)
; # (ge0 (compare (car X) Key))
  %215 = icmp sge i64 %214, 0
  br label %$46
$46:
  %216 = phi i64 [%206, %$45], [%209, %$47] ; # X
  %217 = phi i64 [%203, %$45], [%210, %$47] ; # P
  %218 = phi i64 [%204, %$45], [%211, %$47] ; # R
  %219 = phi i1 [0, %$45], [%215, %$47] ; # ->
  br i1 %219, label %$48, label %$49
$48:
  %220 = phi i64 [%216, %$46] ; # X
  %221 = phi i64 [%217, %$46] ; # P
  %222 = phi i64 [%218, %$46] ; # R
; # (when (le0 (compare (car X) Key2)) (setq R (cons X R)))
; # (car X)
  %223 = inttoptr i64 %220 to i64*
  %224 = load i64, i64* %223
; # (compare (car X) Key2)
  %225 = call i64 @compare(i64 %224, i64 %129)
; # (le0 (compare (car X) Key2))
  %226 = icmp sle i64 %225, 0
  br i1 %226, label %$50, label %$51
$50:
  %227 = phi i64 [%220, %$48] ; # X
  %228 = phi i64 [%221, %$48] ; # P
  %229 = phi i64 [%222, %$48] ; # R
; # (cons X R)
  %230 = call i64 @cons(i64 %227, i64 %229)
  br label %$51
$51:
  %231 = phi i64 [%220, %$48], [%227, %$50] ; # X
  %232 = phi i64 [%221, %$48], [%228, %$50] ; # P
  %233 = phi i64 [%222, %$48], [%230, %$50] ; # R
; # (? (pair (car (setq X (cdr P)))) (let Z P (setq P @) (set X (val ...
; # (cdr P)
  %234 = inttoptr i64 %232 to i64*
  %235 = getelementptr i64, i64* %234, i32 1
  %236 = load i64, i64* %235
; # (car (setq X (cdr P)))
  %237 = inttoptr i64 %236 to i64*
  %238 = load i64, i64* %237
; # (pair (car (setq X (cdr P))))
  %239 = and i64 %238, 15
  %240 = icmp eq i64 %239, 0
  br i1 %240, label %$54, label %$52
$54:
  %241 = phi i64 [%236, %$51] ; # X
  %242 = phi i64 [%232, %$51] ; # P
  %243 = phi i64 [%233, %$51] ; # R
; # (let Z P (setq P @) (set X (val Tos)) (set Tos (| Z 8)) (set Q P)...
; # (set X (val Tos))
; # (val Tos)
  %244 = inttoptr i64 %146 to i64*
  %245 = load i64, i64* %244
  %246 = inttoptr i64 %241 to i64*
  store i64 %245, i64* %246
; # (set Tos (| Z 8))
; # (| Z 8)
  %247 = or i64 %242, 8
  %248 = inttoptr i64 %146 to i64*
  store i64 %247, i64* %248
; # (set Q P)
  %249 = inttoptr i64 %139 to i64*
  store i64 %238, i64* %249
  br label %$53
$52:
  %250 = phi i64 [%236, %$51] ; # X
  %251 = phi i64 [%232, %$51] ; # P
  %252 = phi i64 [%233, %$51] ; # R
  br label %$49
$49:
  %253 = phi i64 [%216, %$46], [%250, %$52] ; # X
  %254 = phi i64 [%217, %$46], [%251, %$52] ; # P
  %255 = phi i64 [%218, %$46], [%252, %$52] ; # R
; # (loop (when (== -ZERO (setq X (val Tos))) (ret R)) (? (=0 (& X 8)...
  br label %$55
$55:
  %256 = phi i64 [%253, %$49], [%290, %$58] ; # X
  %257 = phi i64 [%254, %$49], [%290, %$58] ; # P
  %258 = phi i64 [%255, %$49], [%289, %$58] ; # R
; # (when (== -ZERO (setq X (val Tos))) (ret R))
; # (val Tos)
  %259 = inttoptr i64 %146 to i64*
  %260 = load i64, i64* %259
; # (== -ZERO (setq X (val Tos)))
  %261 = icmp eq i64 10, %260
  br i1 %261, label %$56, label %$57
$56:
  %262 = phi i64 [%260, %$55] ; # X
  %263 = phi i64 [%257, %$55] ; # P
  %264 = phi i64 [%258, %$55] ; # R
; # (ret R)
; # (drop *Safe)
  %265 = inttoptr i64 %19 to i64*
  %266 = getelementptr i64, i64* %265, i32 1
  %267 = load i64, i64* %266
  %268 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %267, i64* %268
  ret i64 %264
$57:
  %269 = phi i64 [%260, %$55] ; # X
  %270 = phi i64 [%257, %$55] ; # P
  %271 = phi i64 [%258, %$55] ; # R
; # (? (=0 (& X 8)) (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (set...
; # (& X 8)
  %272 = and i64 %269, 8
; # (=0 (& X 8))
  %273 = icmp eq i64 %272, 0
  br i1 %273, label %$60, label %$58
$60:
  %274 = phi i64 [%269, %$57] ; # X
  %275 = phi i64 [%270, %$57] ; # P
  %276 = phi i64 [%271, %$57] ; # R
; # (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (setq P X) (set Q P)...
; # (cdr X)
  %277 = inttoptr i64 %274 to i64*
  %278 = getelementptr i64, i64* %277, i32 1
  %279 = load i64, i64* %278
; # (set Tos (cdr Y))
; # (cdr Y)
  %280 = inttoptr i64 %279 to i64*
  %281 = getelementptr i64, i64* %280, i32 1
  %282 = load i64, i64* %281
  %283 = inttoptr i64 %146 to i64*
  store i64 %282, i64* %283
; # (set 2 Y P)
  %284 = inttoptr i64 %279 to i64*
  %285 = getelementptr i64, i64* %284, i32 1
  store i64 %275, i64* %285
; # (set Q P)
  %286 = inttoptr i64 %139 to i64*
  store i64 %274, i64* %286
  br label %$59
$58:
  %287 = phi i64 [%269, %$57] ; # X
  %288 = phi i64 [%270, %$57] ; # P
  %289 = phi i64 [%271, %$57] ; # R
; # (& X -9)
  %290 = and i64 %287, -9
; # (let Y (cdr X) (set Tos (car Y)) (set Y P) (setq P X) (set Q P))
; # (cdr X)
  %291 = inttoptr i64 %290 to i64*
  %292 = getelementptr i64, i64* %291, i32 1
  %293 = load i64, i64* %292
; # (set Tos (car Y))
; # (car Y)
  %294 = inttoptr i64 %293 to i64*
  %295 = load i64, i64* %294
  %296 = inttoptr i64 %146 to i64*
  store i64 %295, i64* %296
; # (set Y P)
  %297 = inttoptr i64 %293 to i64*
  store i64 %288, i64* %297
; # (set Q P)
  %298 = inttoptr i64 %139 to i64*
  store i64 %290, i64* %298
  br label %$55
$59:
  %299 = phi i64 [%274, %$60] ; # X
  %300 = phi i64 [%274, %$60] ; # P
  %301 = phi i64 [%276, %$60] ; # R
  %302 = phi i64 [%274, %$60] ; # ->
  br label %$45
$53:
  %303 = phi i64 [%241, %$54] ; # X
  %304 = phi i64 [%238, %$54] ; # P
  %305 = phi i64 [%243, %$54] ; # R
  %306 = phi i64 [%238, %$54] ; # ->
  br label %$37
$17:
  %307 = phi i64 [%107, %$25] ; # X
  %308 = phi i64 [%108, %$25] ; # P
  %309 = phi i64 [%109, %$25] ; # ->
  br label %$9
$9:
  %310 = phi i64 [%26, %$7], [%307, %$17] ; # X
  %311 = phi i64 [%27, %$7], [%308, %$17] ; # P
  %312 = phi i64 [%27, %$7], [%309, %$17] ; # ->
; # (drop *Safe)
  %313 = inttoptr i64 %19 to i64*
  %314 = getelementptr i64, i64* %313, i32 1
  %315 = load i64, i64* %314
  %316 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %315, i64* %316
  ret i64 %312
}

define void @put(i64, i64, i64) align 8 {
$1:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (let (L (any (& Ta...
; # (tail Sym)
  %3 = add i64 %0, -8
; # (val (tail Sym))
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (unless (num? Tail) (let (L (any (& Tail -9)) X (car L)) (if (ato...
; # (num? Tail)
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$3, label %$2
$2:
  %8 = phi i64 [%2, %$1] ; # Val
; # (let (L (any (& Tail -9)) X (car L)) (if (atom X) (when (== Key X...
; # (& Tail -9)
  %9 = and i64 %5, -9
; # (any (& Tail -9))
; # (car L)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
; # (if (atom X) (when (== Key X) (cond ((nil? Val) (shift L) (set (t...
; # (atom X)
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$4, label %$5
$4:
  %14 = phi i64 [%8, %$2] ; # Val
  %15 = phi i64 [%9, %$2] ; # L
  %16 = phi i64 [%11, %$2] ; # X
; # (when (== Key X) (cond ((nil? Val) (shift L) (set (tail Sym) (if ...
; # (== Key X)
  %17 = icmp eq i64 %1, %16
  br i1 %17, label %$7, label %$8
$7:
  %18 = phi i64 [%14, %$4] ; # Val
  %19 = phi i64 [%15, %$4] ; # L
  %20 = phi i64 [%16, %$4] ; # X
; # (cond ((nil? Val) (shift L) (set (tail Sym) (if (sym? Tail) (sym ...
; # (nil? Val)
  %21 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$11, label %$10
$11:
  %22 = phi i64 [%18, %$7] ; # Val
  %23 = phi i64 [%19, %$7] ; # L
  %24 = phi i64 [%20, %$7] ; # X
; # (shift L)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (set (tail Sym) (if (sym? Tail) (sym L) L))
; # (tail Sym)
  %28 = add i64 %0, -8
; # (if (sym? Tail) (sym L) L)
; # (sym? Tail)
  %29 = and i64 %5, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$12, label %$13
$12:
  %31 = phi i64 [%22, %$11] ; # Val
  %32 = phi i64 [%27, %$11] ; # L
  %33 = phi i64 [%24, %$11] ; # X
; # (sym L)
  %34 = or i64 %32, 8
  br label %$14
$13:
  %35 = phi i64 [%22, %$11] ; # Val
  %36 = phi i64 [%27, %$11] ; # L
  %37 = phi i64 [%24, %$11] ; # X
  br label %$14
$14:
  %38 = phi i64 [%31, %$12], [%35, %$13] ; # Val
  %39 = phi i64 [%32, %$12], [%36, %$13] ; # L
  %40 = phi i64 [%33, %$12], [%37, %$13] ; # X
  %41 = phi i64 [%34, %$12], [%36, %$13] ; # ->
  %42 = inttoptr i64 %28 to i64*
  store i64 %41, i64* %42
  br label %$9
$10:
  %43 = phi i64 [%18, %$7] ; # Val
  %44 = phi i64 [%19, %$7] ; # L
  %45 = phi i64 [%20, %$7] ; # X
; # (<> Val $T)
  %46 = icmp ne i64 %43, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %46, label %$16, label %$15
$16:
  %47 = phi i64 [%43, %$10] ; # Val
  %48 = phi i64 [%44, %$10] ; # L
  %49 = phi i64 [%45, %$10] ; # X
; # (set L (cons Val Key))
; # (cons Val Key)
  %50 = call i64 @cons(i64 %47, i64 %1)
  %51 = inttoptr i64 %48 to i64*
  store i64 %50, i64* %51
  br label %$9
$15:
  %52 = phi i64 [%43, %$10] ; # Val
  %53 = phi i64 [%44, %$10] ; # L
  %54 = phi i64 [%45, %$10] ; # X
  br label %$9
$9:
  %55 = phi i64 [%38, %$14], [%47, %$16], [%52, %$15] ; # Val
  %56 = phi i64 [%39, %$14], [%48, %$16], [%53, %$15] ; # L
  %57 = phi i64 [%40, %$14], [%49, %$16], [%54, %$15] ; # X
  %58 = phi i64 [%41, %$14], [%50, %$16], [0, %$15] ; # ->
; # (ret)
  ret void
$8:
  %59 = phi i64 [%14, %$4] ; # Val
  %60 = phi i64 [%15, %$4] ; # L
  %61 = phi i64 [%16, %$4] ; # X
  br label %$6
$5:
  %62 = phi i64 [%8, %$2] ; # Val
  %63 = phi i64 [%9, %$2] ; # L
  %64 = phi i64 [%11, %$2] ; # X
; # (when (== Key (cdr X)) (cond ((nil? Val) (shift L) (set (tail Sym...
; # (cdr X)
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (== Key (cdr X))
  %68 = icmp eq i64 %1, %67
  br i1 %68, label %$17, label %$18
$17:
  %69 = phi i64 [%62, %$5] ; # Val
  %70 = phi i64 [%63, %$5] ; # L
  %71 = phi i64 [%64, %$5] ; # X
; # (cond ((nil? Val) (shift L) (set (tail Sym) (if (sym? Tail) (sym ...
; # (nil? Val)
  %72 = icmp eq i64 %69, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %72, label %$21, label %$20
$21:
  %73 = phi i64 [%69, %$17] ; # Val
  %74 = phi i64 [%70, %$17] ; # L
  %75 = phi i64 [%71, %$17] ; # X
; # (shift L)
  %76 = inttoptr i64 %74 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (set (tail Sym) (if (sym? Tail) (sym L) L))
; # (tail Sym)
  %79 = add i64 %0, -8
; # (if (sym? Tail) (sym L) L)
; # (sym? Tail)
  %80 = and i64 %5, 8
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$22, label %$23
$22:
  %82 = phi i64 [%73, %$21] ; # Val
  %83 = phi i64 [%78, %$21] ; # L
  %84 = phi i64 [%75, %$21] ; # X
; # (sym L)
  %85 = or i64 %83, 8
  br label %$24
$23:
  %86 = phi i64 [%73, %$21] ; # Val
  %87 = phi i64 [%78, %$21] ; # L
  %88 = phi i64 [%75, %$21] ; # X
  br label %$24
$24:
  %89 = phi i64 [%82, %$22], [%86, %$23] ; # Val
  %90 = phi i64 [%83, %$22], [%87, %$23] ; # L
  %91 = phi i64 [%84, %$22], [%88, %$23] ; # X
  %92 = phi i64 [%85, %$22], [%87, %$23] ; # ->
  %93 = inttoptr i64 %79 to i64*
  store i64 %92, i64* %93
  br label %$19
$20:
  %94 = phi i64 [%69, %$17] ; # Val
  %95 = phi i64 [%70, %$17] ; # L
  %96 = phi i64 [%71, %$17] ; # X
; # (t? Val)
  %97 = icmp eq i64 %94, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %97, label %$26, label %$25
$26:
  %98 = phi i64 [%94, %$20] ; # Val
  %99 = phi i64 [%95, %$20] ; # L
  %100 = phi i64 [%96, %$20] ; # X
; # (set L Key)
  %101 = inttoptr i64 %99 to i64*
  store i64 %1, i64* %101
  br label %$19
$25:
  %102 = phi i64 [%94, %$20] ; # Val
  %103 = phi i64 [%95, %$20] ; # L
  %104 = phi i64 [%96, %$20] ; # X
; # (set X Val)
  %105 = inttoptr i64 %104 to i64*
  store i64 %102, i64* %105
  br label %$19
$19:
  %106 = phi i64 [%89, %$24], [%98, %$26], [%102, %$25] ; # Val
  %107 = phi i64 [%90, %$24], [%99, %$26], [%103, %$25] ; # L
  %108 = phi i64 [%91, %$24], [%100, %$26], [%104, %$25] ; # X
  %109 = phi i64 [%92, %$24], [%1, %$26], [%102, %$25] ; # ->
; # (ret)
  ret void
$18:
  %110 = phi i64 [%62, %$5] ; # Val
  %111 = phi i64 [%63, %$5] ; # L
  %112 = phi i64 [%64, %$5] ; # X
  br label %$6
$6:
  %113 = phi i64 [%59, %$8], [%110, %$18] ; # Val
  %114 = phi i64 [%60, %$8], [%111, %$18] ; # L
  %115 = phi i64 [%61, %$8], [%112, %$18] ; # X
; # (while (pair (setq X (cdr L))) (let Y (car X) (if (atom Y) (when ...
  br label %$27
$27:
  %116 = phi i64 [%113, %$6], [%258, %$32] ; # Val
  %117 = phi i64 [%114, %$6], [%260, %$32] ; # L
  %118 = phi i64 [%115, %$6], [%260, %$32] ; # X
; # (cdr L)
  %119 = inttoptr i64 %117 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
; # (pair (setq X (cdr L)))
  %122 = and i64 %121, 15
  %123 = icmp eq i64 %122, 0
  br i1 %123, label %$28, label %$29
$28:
  %124 = phi i64 [%116, %$27] ; # Val
  %125 = phi i64 [%117, %$27] ; # L
  %126 = phi i64 [%121, %$27] ; # X
; # (let Y (car X) (if (atom Y) (when (== Key Y) (if (nil? Val) (set ...
; # (car X)
  %127 = inttoptr i64 %126 to i64*
  %128 = load i64, i64* %127
; # (if (atom Y) (when (== Key Y) (if (nil? Val) (set 2 L (cdr X)) (u...
; # (atom Y)
  %129 = and i64 %128, 15
  %130 = icmp ne i64 %129, 0
  br i1 %130, label %$30, label %$31
$30:
  %131 = phi i64 [%124, %$28] ; # Val
  %132 = phi i64 [%125, %$28] ; # L
  %133 = phi i64 [%126, %$28] ; # X
; # (when (== Key Y) (if (nil? Val) (set 2 L (cdr X)) (unless (t? Val...
; # (== Key Y)
  %134 = icmp eq i64 %1, %128
  br i1 %134, label %$33, label %$34
$33:
  %135 = phi i64 [%131, %$30] ; # Val
  %136 = phi i64 [%132, %$30] ; # L
  %137 = phi i64 [%133, %$30] ; # X
; # (if (nil? Val) (set 2 L (cdr X)) (unless (t? Val) (set X (cons Va...
; # (nil? Val)
  %138 = icmp eq i64 %135, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %138, label %$35, label %$36
$35:
  %139 = phi i64 [%135, %$33] ; # Val
  %140 = phi i64 [%136, %$33] ; # L
  %141 = phi i64 [%137, %$33] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %142 = inttoptr i64 %141 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  %144 = load i64, i64* %143
  %145 = inttoptr i64 %140 to i64*
  %146 = getelementptr i64, i64* %145, i32 1
  store i64 %144, i64* %146
  br label %$37
$36:
  %147 = phi i64 [%135, %$33] ; # Val
  %148 = phi i64 [%136, %$33] ; # L
  %149 = phi i64 [%137, %$33] ; # X
; # (unless (t? Val) (set X (cons Val Key)))
; # (t? Val)
  %150 = icmp eq i64 %147, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %150, label %$39, label %$38
$38:
  %151 = phi i64 [%147, %$36] ; # Val
  %152 = phi i64 [%148, %$36] ; # L
  %153 = phi i64 [%149, %$36] ; # X
; # (set X (cons Val Key))
; # (cons Val Key)
  %154 = call i64 @cons(i64 %151, i64 %1)
  %155 = inttoptr i64 %153 to i64*
  store i64 %154, i64* %155
  br label %$39
$39:
  %156 = phi i64 [%147, %$36], [%151, %$38] ; # Val
  %157 = phi i64 [%148, %$36], [%152, %$38] ; # L
  %158 = phi i64 [%149, %$36], [%153, %$38] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %159 = inttoptr i64 %158 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  %161 = load i64, i64* %160
  %162 = inttoptr i64 %157 to i64*
  %163 = getelementptr i64, i64* %162, i32 1
  store i64 %161, i64* %163
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %164 = and i64 %5, 8
  %165 = icmp ne i64 %164, 0
  br i1 %165, label %$41, label %$40
$40:
  %166 = phi i64 [%156, %$39] ; # Val
  %167 = phi i64 [%157, %$39] ; # L
  %168 = phi i64 [%158, %$39] ; # X
; # (set 2 X Tail)
  %169 = inttoptr i64 %168 to i64*
  %170 = getelementptr i64, i64* %169, i32 1
  store i64 %5, i64* %170
  br label %$42
$41:
  %171 = phi i64 [%156, %$39] ; # Val
  %172 = phi i64 [%157, %$39] ; # L
  %173 = phi i64 [%158, %$39] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %174 = and i64 %5, -9
  %175 = inttoptr i64 %173 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  store i64 %174, i64* %176
; # (sym X)
  %177 = or i64 %173, 8
  br label %$42
$42:
  %178 = phi i64 [%166, %$40], [%171, %$41] ; # Val
  %179 = phi i64 [%167, %$40], [%172, %$41] ; # L
  %180 = phi i64 [%168, %$40], [%177, %$41] ; # X
  %181 = phi i64 [%5, %$40], [%177, %$41] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %182 = add i64 %0, -8
  %183 = inttoptr i64 %182 to i64*
  store i64 %180, i64* %183
  br label %$37
$37:
  %184 = phi i64 [%139, %$35], [%178, %$42] ; # Val
  %185 = phi i64 [%140, %$35], [%179, %$42] ; # L
  %186 = phi i64 [%141, %$35], [%180, %$42] ; # X
  %187 = phi i64 [%144, %$35], [%180, %$42] ; # ->
; # (ret)
  ret void
$34:
  %188 = phi i64 [%131, %$30] ; # Val
  %189 = phi i64 [%132, %$30] ; # L
  %190 = phi i64 [%133, %$30] ; # X
  br label %$32
$31:
  %191 = phi i64 [%124, %$28] ; # Val
  %192 = phi i64 [%125, %$28] ; # L
  %193 = phi i64 [%126, %$28] ; # X
; # (when (== Key (cdr Y)) (if (nil? Val) (set 2 L (cdr X)) (if (t? V...
; # (cdr Y)
  %194 = inttoptr i64 %128 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
; # (== Key (cdr Y))
  %197 = icmp eq i64 %1, %196
  br i1 %197, label %$43, label %$44
$43:
  %198 = phi i64 [%191, %$31] ; # Val
  %199 = phi i64 [%192, %$31] ; # L
  %200 = phi i64 [%193, %$31] ; # X
; # (if (nil? Val) (set 2 L (cdr X)) (if (t? Val) (set X Key) (set Y ...
; # (nil? Val)
  %201 = icmp eq i64 %198, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %201, label %$45, label %$46
$45:
  %202 = phi i64 [%198, %$43] ; # Val
  %203 = phi i64 [%199, %$43] ; # L
  %204 = phi i64 [%200, %$43] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %205 = inttoptr i64 %204 to i64*
  %206 = getelementptr i64, i64* %205, i32 1
  %207 = load i64, i64* %206
  %208 = inttoptr i64 %203 to i64*
  %209 = getelementptr i64, i64* %208, i32 1
  store i64 %207, i64* %209
  br label %$47
$46:
  %210 = phi i64 [%198, %$43] ; # Val
  %211 = phi i64 [%199, %$43] ; # L
  %212 = phi i64 [%200, %$43] ; # X
; # (if (t? Val) (set X Key) (set Y Val))
; # (t? Val)
  %213 = icmp eq i64 %210, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %213, label %$48, label %$49
$48:
  %214 = phi i64 [%210, %$46] ; # Val
  %215 = phi i64 [%211, %$46] ; # L
  %216 = phi i64 [%212, %$46] ; # X
; # (set X Key)
  %217 = inttoptr i64 %216 to i64*
  store i64 %1, i64* %217
  br label %$50
$49:
  %218 = phi i64 [%210, %$46] ; # Val
  %219 = phi i64 [%211, %$46] ; # L
  %220 = phi i64 [%212, %$46] ; # X
; # (set Y Val)
  %221 = inttoptr i64 %128 to i64*
  store i64 %218, i64* %221
  br label %$50
$50:
  %222 = phi i64 [%214, %$48], [%218, %$49] ; # Val
  %223 = phi i64 [%215, %$48], [%219, %$49] ; # L
  %224 = phi i64 [%216, %$48], [%220, %$49] ; # X
  %225 = phi i64 [%1, %$48], [%218, %$49] ; # ->
; # (set 2 L (cdr X))
; # (cdr X)
  %226 = inttoptr i64 %224 to i64*
  %227 = getelementptr i64, i64* %226, i32 1
  %228 = load i64, i64* %227
  %229 = inttoptr i64 %223 to i64*
  %230 = getelementptr i64, i64* %229, i32 1
  store i64 %228, i64* %230
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %231 = and i64 %5, 8
  %232 = icmp ne i64 %231, 0
  br i1 %232, label %$52, label %$51
$51:
  %233 = phi i64 [%222, %$50] ; # Val
  %234 = phi i64 [%223, %$50] ; # L
  %235 = phi i64 [%224, %$50] ; # X
; # (set 2 X Tail)
  %236 = inttoptr i64 %235 to i64*
  %237 = getelementptr i64, i64* %236, i32 1
  store i64 %5, i64* %237
  br label %$53
$52:
  %238 = phi i64 [%222, %$50] ; # Val
  %239 = phi i64 [%223, %$50] ; # L
  %240 = phi i64 [%224, %$50] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %241 = and i64 %5, -9
  %242 = inttoptr i64 %240 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  store i64 %241, i64* %243
; # (sym X)
  %244 = or i64 %240, 8
  br label %$53
$53:
  %245 = phi i64 [%233, %$51], [%238, %$52] ; # Val
  %246 = phi i64 [%234, %$51], [%239, %$52] ; # L
  %247 = phi i64 [%235, %$51], [%244, %$52] ; # X
  %248 = phi i64 [%5, %$51], [%244, %$52] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %249 = add i64 %0, -8
  %250 = inttoptr i64 %249 to i64*
  store i64 %247, i64* %250
  br label %$47
$47:
  %251 = phi i64 [%202, %$45], [%245, %$53] ; # Val
  %252 = phi i64 [%203, %$45], [%246, %$53] ; # L
  %253 = phi i64 [%204, %$45], [%247, %$53] ; # X
  %254 = phi i64 [%207, %$45], [%247, %$53] ; # ->
; # (ret)
  ret void
$44:
  %255 = phi i64 [%191, %$31] ; # Val
  %256 = phi i64 [%192, %$31] ; # L
  %257 = phi i64 [%193, %$31] ; # X
  br label %$32
$32:
  %258 = phi i64 [%188, %$34], [%255, %$44] ; # Val
  %259 = phi i64 [%189, %$34], [%256, %$44] ; # L
  %260 = phi i64 [%190, %$34], [%257, %$44] ; # X
  br label %$27
$29:
  %261 = phi i64 [%116, %$27] ; # Val
  %262 = phi i64 [%117, %$27] ; # L
  %263 = phi i64 [%121, %$27] ; # X
  br label %$3
$3:
  %264 = phi i64 [%2, %$1], [%261, %$29] ; # Val
; # (unless (nil? Val) (setq Val (if (t? Val) Key (cons Val Key))) (s...
; # (nil? Val)
  %265 = icmp eq i64 %264, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %265, label %$55, label %$54
$54:
  %266 = phi i64 [%264, %$3] ; # Val
; # (if (t? Val) Key (cons Val Key))
; # (t? Val)
  %267 = icmp eq i64 %266, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %267, label %$56, label %$57
$56:
  %268 = phi i64 [%266, %$54] ; # Val
  br label %$58
$57:
  %269 = phi i64 [%266, %$54] ; # Val
; # (cons Val Key)
  %270 = call i64 @cons(i64 %269, i64 %1)
  br label %$58
$58:
  %271 = phi i64 [%268, %$56], [%269, %$57] ; # Val
  %272 = phi i64 [%1, %$56], [%270, %$57] ; # ->
; # (set (tail Sym) (if (sym? Tail) (sym (cons Val (& Tail -9))) (con...
; # (tail Sym)
  %273 = add i64 %0, -8
; # (if (sym? Tail) (sym (cons Val (& Tail -9))) (cons Val Tail))
; # (sym? Tail)
  %274 = and i64 %5, 8
  %275 = icmp ne i64 %274, 0
  br i1 %275, label %$59, label %$60
$59:
  %276 = phi i64 [%272, %$58] ; # Val
; # (& Tail -9)
  %277 = and i64 %5, -9
; # (cons Val (& Tail -9))
  %278 = call i64 @cons(i64 %276, i64 %277)
; # (sym (cons Val (& Tail -9)))
  %279 = or i64 %278, 8
  br label %$61
$60:
  %280 = phi i64 [%272, %$58] ; # Val
; # (cons Val Tail)
  %281 = call i64 @cons(i64 %280, i64 %5)
  br label %$61
$61:
  %282 = phi i64 [%276, %$59], [%280, %$60] ; # Val
  %283 = phi i64 [%279, %$59], [%281, %$60] ; # ->
  %284 = inttoptr i64 %273 to i64*
  store i64 %283, i64* %284
  br label %$55
$55:
  %285 = phi i64 [%264, %$3], [%282, %$61] ; # Val
  ret void
}

define void @putn(i64, i64, i64, i64) align 8 {
$1:
; # (nond ((num? Key) (loop (let X (car Lst) (? (and (pair X) (== Key...
; # (num? Key)
  %4 = and i64 %2, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$3, label %$4
$4:
  %6 = phi i64 [%1, %$1] ; # Lst
; # (loop (let X (car Lst) (? (and (pair X) (== Key (car X))) (set 2 ...
  br label %$5
$5:
  %7 = phi i64 [%6, %$4], [%28, %$12] ; # Lst
; # (let X (car Lst) (? (and (pair X) (== Key (car X))) (set 2 X Val)...
; # (car Lst)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (? (and (pair X) (== Key (car X))) (set 2 X Val))
; # (and (pair X) (== Key (car X)))
; # (pair X)
  %10 = and i64 %9, 15
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$7, label %$6
$7:
  %12 = phi i64 [%7, %$5] ; # Lst
; # (car X)
  %13 = inttoptr i64 %9 to i64*
  %14 = load i64, i64* %13
; # (== Key (car X))
  %15 = icmp eq i64 %2, %14
  br label %$6
$6:
  %16 = phi i64 [%7, %$5], [%12, %$7] ; # Lst
  %17 = phi i1 [0, %$5], [%15, %$7] ; # ->
  br i1 %17, label %$10, label %$8
$10:
  %18 = phi i64 [%16, %$6] ; # Lst
; # (set 2 X Val)
  %19 = inttoptr i64 %9 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %3, i64* %20
  br label %$9
$8:
  %21 = phi i64 [%16, %$6] ; # Lst
; # (when (atom (shift Lst)) (itemErr Exe Key))
; # (shift Lst)
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (atom (shift Lst))
  %25 = and i64 %24, 15
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$12
$11:
  %27 = phi i64 [%24, %$8] ; # Lst
; # (itemErr Exe Key)
  call void @itemErr(i64 %0, i64 %2)
  unreachable
$12:
  %28 = phi i64 [%24, %$8] ; # Lst
  br label %$5
$9:
  %29 = phi i64 [%18, %$10] ; # Lst
  %30 = phi i64 [%3, %$10] ; # ->
  br label %$2
$3:
  %31 = phi i64 [%1, %$1] ; # Lst
; # (== ZERO Key)
  %32 = icmp eq i64 2, %2
  br i1 %32, label %$13, label %$14
$14:
  %33 = phi i64 [%31, %$3] ; # Lst
; # (let Cnt (int Key) (while (dec 'Cnt) (when (atom (shift Lst)) (it...
; # (int Key)
  %34 = lshr i64 %2, 4
; # (while (dec 'Cnt) (when (atom (shift Lst)) (itemErr Exe Key)))
  br label %$15
$15:
  %35 = phi i64 [%33, %$14], [%48, %$19] ; # Lst
  %36 = phi i64 [%34, %$14], [%49, %$19] ; # Cnt
; # (dec 'Cnt)
  %37 = sub i64 %36, 1
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%35, %$15] ; # Lst
  %40 = phi i64 [%37, %$15] ; # Cnt
; # (when (atom (shift Lst)) (itemErr Exe Key))
; # (shift Lst)
  %41 = inttoptr i64 %39 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (atom (shift Lst))
  %44 = and i64 %43, 15
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$18, label %$19
$18:
  %46 = phi i64 [%43, %$16] ; # Lst
  %47 = phi i64 [%40, %$16] ; # Cnt
; # (itemErr Exe Key)
  call void @itemErr(i64 %0, i64 %2)
  unreachable
$19:
  %48 = phi i64 [%43, %$16] ; # Lst
  %49 = phi i64 [%40, %$16] ; # Cnt
  br label %$15
$17:
  %50 = phi i64 [%35, %$15] ; # Lst
  %51 = phi i64 [%37, %$15] ; # Cnt
; # (if (sign? Key) (set 2 Lst Val) (set Lst Val))
; # (sign? Key)
  %52 = and i64 %2, 8
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$20, label %$21
$20:
  %54 = phi i64 [%50, %$17] ; # Lst
; # (set 2 Lst Val)
  %55 = inttoptr i64 %54 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  store i64 %3, i64* %56
  br label %$22
$21:
  %57 = phi i64 [%50, %$17] ; # Lst
; # (set Lst Val)
  %58 = inttoptr i64 %57 to i64*
  store i64 %3, i64* %58
  br label %$22
$22:
  %59 = phi i64 [%54, %$20], [%57, %$21] ; # Lst
  %60 = phi i64 [%3, %$20], [%3, %$21] ; # ->
  br label %$2
$13:
  %61 = phi i64 [%31, %$3] ; # Lst
; # (argErr Exe Key)
  call void @argErr(i64 %0, i64 %2)
  unreachable
$2:
  %62 = phi i64 [%29, %$9], [%59, %$22] ; # Lst
  %63 = phi i64 [%30, %$9], [%60, %$22] ; # ->
  ret void
}

define i64 @get(i64, i64) align 8 {
$1:
; # (if (== Key ZERO) (val Sym) (let Tail (val (tail Sym)) (unless (n...
; # (== Key ZERO)
  %2 = icmp eq i64 %1, 2
  br i1 %2, label %$2, label %$3
$2:
; # (val Sym)
  %3 = inttoptr i64 %0 to i64*
  %4 = load i64, i64* %3
  br label %$4
$3:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (let (L (any (& Ta...
; # (tail Sym)
  %5 = add i64 %0, -8
; # (val (tail Sym))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (unless (num? Tail) (let (L (any (& Tail -9)) X (car L)) (if (ato...
; # (num? Tail)
  %8 = and i64 %7, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$5:
; # (let (L (any (& Tail -9)) X (car L)) (if (atom X) (when (== Key X...
; # (& Tail -9)
  %10 = and i64 %7, -9
; # (any (& Tail -9))
; # (car L)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (if (atom X) (when (== Key X) (ret $T)) (when (== Key (cdr X)) (r...
; # (atom X)
  %13 = and i64 %12, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%10, %$5] ; # L
  %16 = phi i64 [%12, %$5] ; # X
; # (when (== Key X) (ret $T))
; # (== Key X)
  %17 = icmp eq i64 %1, %16
  br i1 %17, label %$10, label %$11
$10:
  %18 = phi i64 [%15, %$7] ; # L
  %19 = phi i64 [%16, %$7] ; # X
; # (ret $T)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
$11:
  %20 = phi i64 [%15, %$7] ; # L
  %21 = phi i64 [%16, %$7] ; # X
  br label %$9
$8:
  %22 = phi i64 [%10, %$5] ; # L
  %23 = phi i64 [%12, %$5] ; # X
; # (when (== Key (cdr X)) (ret (car X)))
; # (cdr X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (== Key (cdr X))
  %27 = icmp eq i64 %1, %26
  br i1 %27, label %$12, label %$13
$12:
  %28 = phi i64 [%22, %$8] ; # L
  %29 = phi i64 [%23, %$8] ; # X
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (ret (car X))
  ret i64 %31
$13:
  %32 = phi i64 [%22, %$8] ; # L
  %33 = phi i64 [%23, %$8] ; # X
  br label %$9
$9:
  %34 = phi i64 [%20, %$11], [%32, %$13] ; # L
  %35 = phi i64 [%21, %$11], [%33, %$13] ; # X
; # (while (pair (setq X (cdr L))) (let Y (car X) (if (atom Y) (when ...
  br label %$14
$14:
  %36 = phi i64 [%34, %$9], [%113, %$19] ; # L
  %37 = phi i64 [%35, %$9], [%113, %$19] ; # X
; # (cdr L)
  %38 = inttoptr i64 %36 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (pair (setq X (cdr L)))
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%36, %$14] ; # L
  %44 = phi i64 [%40, %$14] ; # X
; # (let Y (car X) (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (i...
; # (car X)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) ...
; # (atom Y)
  %47 = and i64 %46, 15
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$17, label %$18
$17:
  %49 = phi i64 [%43, %$15] ; # L
  %50 = phi i64 [%44, %$15] ; # X
; # (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 X Tail...
; # (== Key Y)
  %51 = icmp eq i64 %1, %46
  br i1 %51, label %$20, label %$21
$20:
  %52 = phi i64 [%49, %$17] ; # L
  %53 = phi i64 [%50, %$17] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %54 = inttoptr i64 %53 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %52 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %59 = and i64 %7, 8
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$23, label %$22
$22:
  %61 = phi i64 [%52, %$20] ; # L
  %62 = phi i64 [%53, %$20] ; # X
; # (set 2 X Tail)
  %63 = inttoptr i64 %62 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  store i64 %7, i64* %64
  br label %$24
$23:
  %65 = phi i64 [%52, %$20] ; # L
  %66 = phi i64 [%53, %$20] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %67 = and i64 %7, -9
  %68 = inttoptr i64 %66 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %67, i64* %69
; # (sym X)
  %70 = or i64 %66, 8
  br label %$24
$24:
  %71 = phi i64 [%61, %$22], [%65, %$23] ; # L
  %72 = phi i64 [%62, %$22], [%70, %$23] ; # X
  %73 = phi i64 [%7, %$22], [%70, %$23] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %74 = add i64 %0, -8
  %75 = inttoptr i64 %74 to i64*
  store i64 %72, i64* %75
; # (ret $T)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
$21:
  %76 = phi i64 [%49, %$17] ; # L
  %77 = phi i64 [%50, %$17] ; # X
  br label %$19
$18:
  %78 = phi i64 [%43, %$15] ; # L
  %79 = phi i64 [%44, %$15] ; # X
; # (when (== Key (cdr Y)) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 ...
; # (cdr Y)
  %80 = inttoptr i64 %46 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
; # (== Key (cdr Y))
  %83 = icmp eq i64 %1, %82
  br i1 %83, label %$25, label %$26
$25:
  %84 = phi i64 [%78, %$18] ; # L
  %85 = phi i64 [%79, %$18] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
  %89 = inttoptr i64 %84 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %88, i64* %90
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %91 = and i64 %7, 8
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$28, label %$27
$27:
  %93 = phi i64 [%84, %$25] ; # L
  %94 = phi i64 [%85, %$25] ; # X
; # (set 2 X Tail)
  %95 = inttoptr i64 %94 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %7, i64* %96
  br label %$29
$28:
  %97 = phi i64 [%84, %$25] ; # L
  %98 = phi i64 [%85, %$25] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %99 = and i64 %7, -9
  %100 = inttoptr i64 %98 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  store i64 %99, i64* %101
; # (sym X)
  %102 = or i64 %98, 8
  br label %$29
$29:
  %103 = phi i64 [%93, %$27], [%97, %$28] ; # L
  %104 = phi i64 [%94, %$27], [%102, %$28] ; # X
  %105 = phi i64 [%7, %$27], [%102, %$28] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %106 = add i64 %0, -8
  %107 = inttoptr i64 %106 to i64*
  store i64 %104, i64* %107
; # (car Y)
  %108 = inttoptr i64 %46 to i64*
  %109 = load i64, i64* %108
; # (ret (car Y))
  ret i64 %109
$26:
  %110 = phi i64 [%78, %$18] ; # L
  %111 = phi i64 [%79, %$18] ; # X
  br label %$19
$19:
  %112 = phi i64 [%76, %$21], [%110, %$26] ; # L
  %113 = phi i64 [%77, %$21], [%111, %$26] ; # X
  br label %$14
$16:
  %114 = phi i64 [%36, %$14] ; # L
  %115 = phi i64 [%40, %$14] ; # X
  br label %$6
$6:
  br label %$4
$4:
  %116 = phi i64 [%4, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$6] ; # ->
  ret i64 %116
}

define i64 @getn(i64, i64, i64) align 8 {
$1:
; # (when (num? X) (argErr Exe X))
; # (num? X)
  %3 = and i64 %1, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%1, %$1] ; # X
; # (argErr Exe X)
  call void @argErr(i64 %0, i64 %5)
  unreachable
$3:
  %6 = phi i64 [%1, %$1] ; # X
; # (if (pair X) (nond ((num? Key) (loop (let Y (car X) (? (and (pair...
; # (pair X)
  %7 = and i64 %6, 15
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %$4, label %$5
$4:
  %9 = phi i64 [%6, %$3] ; # X
; # (nond ((num? Key) (loop (let Y (car X) (? (and (pair Y) (== Key (...
; # (num? Key)
  %10 = and i64 %2, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$8, label %$9
$9:
  %12 = phi i64 [%9, %$4] ; # X
; # (loop (let Y (car X) (? (and (pair Y) (== Key (car Y))) (cdr Y)))...
  br label %$10
$10:
  %13 = phi i64 [%12, %$9], [%35, %$16] ; # X
; # (let Y (car X) (? (and (pair Y) (== Key (car Y))) (cdr Y)))
; # (car X)
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
; # (? (and (pair Y) (== Key (car Y))) (cdr Y))
; # (and (pair Y) (== Key (car Y)))
; # (pair Y)
  %16 = and i64 %15, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$12, label %$11
$12:
  %18 = phi i64 [%13, %$10] ; # X
; # (car Y)
  %19 = inttoptr i64 %15 to i64*
  %20 = load i64, i64* %19
; # (== Key (car Y))
  %21 = icmp eq i64 %2, %20
  br label %$11
$11:
  %22 = phi i64 [%13, %$10], [%18, %$12] ; # X
  %23 = phi i1 [0, %$10], [%21, %$12] ; # ->
  br i1 %23, label %$15, label %$13
$15:
  %24 = phi i64 [%22, %$11] ; # X
; # (cdr Y)
  %25 = inttoptr i64 %15 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
  br label %$14
$13:
  %28 = phi i64 [%22, %$11] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (atom (shift X))
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$16
$17:
  %34 = phi i64 [%31, %$13] ; # X
  br label %$14
$16:
  %35 = phi i64 [%31, %$13] ; # X
  br label %$10
$14:
  %36 = phi i64 [%24, %$15], [%34, %$17] ; # X
  %37 = phi i64 [%27, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
  br label %$7
$8:
  %38 = phi i64 [%9, %$4] ; # X
; # (== ZERO Key)
  %39 = icmp eq i64 2, %2
  br i1 %39, label %$18, label %$19
$19:
  %40 = phi i64 [%38, %$8] ; # X
; # (nth Key X)
  %41 = lshr i64 %2, 4
  br label %$20
$20:
  %42 = phi i64 [%40, %$19], [%50, %$21] ; # X
  %43 = phi i64 [%41, %$19], [%47, %$21] ; # C
  %44 = sub i64 %43, 1
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$21, label %$22
$21:
  %46 = phi i64 [%42, %$20] ; # X
  %47 = phi i64 [%44, %$20] ; # C
  %48 = inttoptr i64 %46 to i64*
  %49 = getelementptr i64, i64* %48, i32 1
  %50 = load i64, i64* %49
  br label %$20
$22:
  %51 = phi i64 [%42, %$20] ; # X
  %52 = phi i64 [%44, %$20] ; # C
  %53 = and i64 %2, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$23, label %$24
$23:
  %55 = phi i64 [%51, %$22] ; # X
  %56 = phi i64 [%52, %$22] ; # C
  %57 = inttoptr i64 %55 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  br label %$25
$24:
  %60 = phi i64 [%51, %$22] ; # X
  %61 = phi i64 [%52, %$22] ; # C
  %62 = inttoptr i64 %60 to i64*
  %63 = load i64, i64* %62
  br label %$25
$25:
  %64 = phi i64 [%55, %$23], [%60, %$24] ; # X
  %65 = phi i64 [%56, %$23], [%61, %$24] ; # C
  %66 = phi i64 [%59, %$23], [%63, %$24] ; # ->
  br label %$7
$18:
  %67 = phi i64 [%38, %$8] ; # X
  br label %$7
$7:
  %68 = phi i64 [%36, %$14], [%40, %$25], [%67, %$18] ; # X
  %69 = phi i64 [%37, %$14], [%66, %$25], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$18] ; # ->
  br label %$6
$5:
  %70 = phi i64 [%6, %$3] ; # X
; # (when (sym? (val (tail X))) (dbFetch Exe X))
; # (tail X)
  %71 = add i64 %70, -8
; # (val (tail X))
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
; # (sym? (val (tail X)))
  %74 = and i64 %73, 8
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$26, label %$27
$26:
  %76 = phi i64 [%70, %$5] ; # X
; # (dbFetch Exe X)
  call void @dbFetch(i64 %0, i64 %76)
  br label %$27
$27:
  %77 = phi i64 [%70, %$5], [%76, %$26] ; # X
; # (get X Key)
  %78 = tail call i64 @get(i64 %77, i64 %2)
  br label %$6
$6:
  %79 = phi i64 [%68, %$7], [%77, %$27] ; # X
  %80 = phi i64 [%69, %$7], [%78, %$27] ; # ->
  ret i64 %80
}

define i64 @prop(i64, i64) align 8 {
$1:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (let (L (any (& Ta...
; # (tail Sym)
  %2 = add i64 %0, -8
; # (val (tail Sym))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (unless (num? Tail) (let (L (any (& Tail -9)) X (car L)) (if (ato...
; # (num? Tail)
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
; # (let (L (any (& Tail -9)) X (car L)) (if (atom X) (when (== Key X...
; # (& Tail -9)
  %7 = and i64 %4, -9
; # (any (& Tail -9))
; # (car L)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (if (atom X) (when (== Key X) (ret Key)) (when (== Key (cdr X)) (...
; # (atom X)
  %10 = and i64 %9, 15
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$5
$4:
  %12 = phi i64 [%7, %$2] ; # L
  %13 = phi i64 [%9, %$2] ; # X
; # (when (== Key X) (ret Key))
; # (== Key X)
  %14 = icmp eq i64 %1, %13
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%12, %$4] ; # L
  %16 = phi i64 [%13, %$4] ; # X
; # (ret Key)
  ret i64 %1
$8:
  %17 = phi i64 [%12, %$4] ; # L
  %18 = phi i64 [%13, %$4] ; # X
  br label %$6
$5:
  %19 = phi i64 [%7, %$2] ; # L
  %20 = phi i64 [%9, %$2] ; # X
; # (when (== Key (cdr X)) (ret X))
; # (cdr X)
  %21 = inttoptr i64 %20 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (== Key (cdr X))
  %24 = icmp eq i64 %1, %23
  br i1 %24, label %$9, label %$10
$9:
  %25 = phi i64 [%19, %$5] ; # L
  %26 = phi i64 [%20, %$5] ; # X
; # (ret X)
  ret i64 %26
$10:
  %27 = phi i64 [%19, %$5] ; # L
  %28 = phi i64 [%20, %$5] ; # X
  br label %$6
$6:
  %29 = phi i64 [%17, %$8], [%27, %$10] ; # L
  %30 = phi i64 [%18, %$8], [%28, %$10] ; # X
; # (while (pair (setq X (cdr L))) (let Y (car X) (if (atom Y) (when ...
  br label %$11
$11:
  %31 = phi i64 [%29, %$6], [%106, %$16] ; # L
  %32 = phi i64 [%30, %$6], [%106, %$16] ; # X
; # (cdr L)
  %33 = inttoptr i64 %31 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
; # (pair (setq X (cdr L)))
  %36 = and i64 %35, 15
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = phi i64 [%31, %$11] ; # L
  %39 = phi i64 [%35, %$11] ; # X
; # (let Y (car X) (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (i...
; # (car X)
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
; # (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) ...
; # (atom Y)
  %42 = and i64 %41, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$14, label %$15
$14:
  %44 = phi i64 [%38, %$12] ; # L
  %45 = phi i64 [%39, %$12] ; # X
; # (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 X Tail...
; # (== Key Y)
  %46 = icmp eq i64 %1, %41
  br i1 %46, label %$17, label %$18
$17:
  %47 = phi i64 [%44, %$14] ; # L
  %48 = phi i64 [%45, %$14] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %47 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  store i64 %51, i64* %53
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %54 = and i64 %4, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$20, label %$19
$19:
  %56 = phi i64 [%47, %$17] ; # L
  %57 = phi i64 [%48, %$17] ; # X
; # (set 2 X Tail)
  %58 = inttoptr i64 %57 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %4, i64* %59
  br label %$21
$20:
  %60 = phi i64 [%47, %$17] ; # L
  %61 = phi i64 [%48, %$17] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %62 = and i64 %4, -9
  %63 = inttoptr i64 %61 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  store i64 %62, i64* %64
; # (sym X)
  %65 = or i64 %61, 8
  br label %$21
$21:
  %66 = phi i64 [%56, %$19], [%60, %$20] ; # L
  %67 = phi i64 [%57, %$19], [%65, %$20] ; # X
  %68 = phi i64 [%4, %$19], [%65, %$20] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %69 = add i64 %0, -8
  %70 = inttoptr i64 %69 to i64*
  store i64 %67, i64* %70
; # (ret Key)
  ret i64 %1
$18:
  %71 = phi i64 [%44, %$14] ; # L
  %72 = phi i64 [%45, %$14] ; # X
  br label %$16
$15:
  %73 = phi i64 [%38, %$12] ; # L
  %74 = phi i64 [%39, %$12] ; # X
; # (when (== Key (cdr Y)) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 ...
; # (cdr Y)
  %75 = inttoptr i64 %41 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
; # (== Key (cdr Y))
  %78 = icmp eq i64 %1, %77
  br i1 %78, label %$22, label %$23
$22:
  %79 = phi i64 [%73, %$15] ; # L
  %80 = phi i64 [%74, %$15] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 %79 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  store i64 %83, i64* %85
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %86 = and i64 %4, 8
  %87 = icmp ne i64 %86, 0
  br i1 %87, label %$25, label %$24
$24:
  %88 = phi i64 [%79, %$22] ; # L
  %89 = phi i64 [%80, %$22] ; # X
; # (set 2 X Tail)
  %90 = inttoptr i64 %89 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %4, i64* %91
  br label %$26
$25:
  %92 = phi i64 [%79, %$22] ; # L
  %93 = phi i64 [%80, %$22] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %94 = and i64 %4, -9
  %95 = inttoptr i64 %93 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %94, i64* %96
; # (sym X)
  %97 = or i64 %93, 8
  br label %$26
$26:
  %98 = phi i64 [%88, %$24], [%92, %$25] ; # L
  %99 = phi i64 [%89, %$24], [%97, %$25] ; # X
  %100 = phi i64 [%4, %$24], [%97, %$25] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %101 = add i64 %0, -8
  %102 = inttoptr i64 %101 to i64*
  store i64 %99, i64* %102
; # (ret Y)
  ret i64 %41
$23:
  %103 = phi i64 [%73, %$15] ; # L
  %104 = phi i64 [%74, %$15] ; # X
  br label %$16
$16:
  %105 = phi i64 [%71, %$18], [%103, %$23] ; # L
  %106 = phi i64 [%72, %$18], [%104, %$23] ; # X
  br label %$11
$13:
  %107 = phi i64 [%31, %$11] ; # L
  %108 = phi i64 [%35, %$11] ; # X
  br label %$3
$3:
; # (let R (cons $Nil Key) (set (tail Sym) (if (sym? Tail) (sym (cons...
; # (cons $Nil Key)
  %109 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %1)
; # (set (tail Sym) (if (sym? Tail) (sym (cons R (& Tail -9))) (cons ...
; # (tail Sym)
  %110 = add i64 %0, -8
; # (if (sym? Tail) (sym (cons R (& Tail -9))) (cons R Tail))
; # (sym? Tail)
  %111 = and i64 %4, 8
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$27, label %$28
$27:
; # (& Tail -9)
  %113 = and i64 %4, -9
; # (cons R (& Tail -9))
  %114 = call i64 @cons(i64 %109, i64 %113)
; # (sym (cons R (& Tail -9)))
  %115 = or i64 %114, 8
  br label %$29
$28:
; # (cons R Tail)
  %116 = call i64 @cons(i64 %109, i64 %4)
  br label %$29
$29:
  %117 = phi i64 [%115, %$27], [%116, %$28] ; # ->
  %118 = inttoptr i64 %110 to i64*
  store i64 %117, i64* %118
  ret i64 %109
}

define i64 @_put(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Key T) (loop (setq Key (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (loop (setq Key (eval (++ X))) (? (atom (cdr X))) (setq Y (safe (...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%43, %$13] ; # X
  %25 = phi i64 [%15, %$2], [%46, %$13] ; # Y
; # (++ X)
  %26 = inttoptr i64 %24 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
; # (eval (++ X))
  %30 = and i64 %27, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$10, label %$9
$10:
  br label %$8
$9:
  %32 = and i64 %27, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = inttoptr i64 %27 to i64*
  %35 = load i64, i64* %34
  br label %$8
$11:
  %36 = call i64 @evList(i64 %27)
  br label %$8
$8:
  %37 = phi i64 [%27, %$10], [%35, %$12], [%36, %$11] ; # ->
; # (? (atom (cdr X)))
; # (cdr X)
  %38 = inttoptr i64 %29 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (atom (cdr X))
  %41 = and i64 %40, 15
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$14, label %$13
$13:
  %43 = phi i64 [%29, %$8] ; # X
  %44 = phi i64 [%25, %$8] ; # Y
  %45 = phi i64 [%37, %$8] ; # Key
; # (getn Exe Y Key)
  %46 = call i64 @getn(i64 %0, i64 %44, i64 %45)
; # (safe (getn Exe Y Key))
  %47 = inttoptr i64 %19 to i64*
  store i64 %46, i64* %47
  br label %$7
$14:
  %48 = phi i64 [%29, %$8] ; # X
  %49 = phi i64 [%25, %$8] ; # Y
  %50 = phi i64 [%37, %$8] ; # Key
  %51 = phi i64 [0, %$8] ; # ->
; # (when (num? Y) (argErr Exe Y))
; # (num? Y)
  %52 = and i64 %49, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$15, label %$16
$15:
  %54 = phi i64 [%48, %$14] ; # X
  %55 = phi i64 [%49, %$14] ; # Y
  %56 = phi i64 [%50, %$14] ; # Key
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %55)
  unreachable
$16:
  %57 = phi i64 [%48, %$14] ; # X
  %58 = phi i64 [%49, %$14] ; # Y
  %59 = phi i64 [%50, %$14] ; # Key
; # (push Key NIL)
  %60 = alloca i64, i64 2, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = inttoptr i64 %61 to i64*
  store i64 %59, i64* %62
; # (link (push Key NIL))
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %64 = load i64, i64* %63
  %65 = inttoptr i64 %61 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  store i64 %64, i64* %66
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %61, i64* %67
; # (let Val (eval (car X)) (if (pair Y) (putn Exe Y Key Val) (when (...
; # (car X)
  %68 = inttoptr i64 %57 to i64*
  %69 = load i64, i64* %68
; # (eval (car X))
  %70 = and i64 %69, 6
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$19, label %$18
$19:
  br label %$17
$18:
  %72 = and i64 %69, 8
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$21, label %$20
$21:
  %74 = inttoptr i64 %69 to i64*
  %75 = load i64, i64* %74
  br label %$17
$20:
  %76 = call i64 @evList(i64 %69)
  br label %$17
$17:
  %77 = phi i64 [%69, %$19], [%75, %$21], [%76, %$20] ; # ->
; # (if (pair Y) (putn Exe Y Key Val) (when (sym? (val (tail Y))) (if...
; # (pair Y)
  %78 = and i64 %58, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$22, label %$23
$22:
  %80 = phi i64 [%57, %$17] ; # X
  %81 = phi i64 [%58, %$17] ; # Y
  %82 = phi i64 [%59, %$17] ; # Key
; # (putn Exe Y Key Val)
  call void @putn(i64 %0, i64 %81, i64 %82, i64 %77)
  br label %$24
$23:
  %83 = phi i64 [%57, %$17] ; # X
  %84 = phi i64 [%58, %$17] ; # Y
  %85 = phi i64 [%59, %$17] ; # Key
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %86 = add i64 %84, -8
; # (val (tail Y))
  %87 = inttoptr i64 %86 to i64*
  %88 = load i64, i64* %87
; # (sym? (val (tail Y)))
  %89 = and i64 %88, 8
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$25, label %$26
$25:
  %91 = phi i64 [%83, %$23] ; # X
  %92 = phi i64 [%84, %$23] ; # Y
  %93 = phi i64 [%85, %$23] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %94 = icmp eq i64 %93, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %94, label %$27, label %$28
$27:
  %95 = phi i64 [%91, %$25] ; # X
  %96 = phi i64 [%92, %$25] ; # Y
  %97 = phi i64 [%93, %$25] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %96)
  br label %$29
$28:
  %98 = phi i64 [%91, %$25] ; # X
  %99 = phi i64 [%92, %$25] ; # Y
  %100 = phi i64 [%93, %$25] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %99)
  br label %$29
$29:
  %101 = phi i64 [%95, %$27], [%98, %$28] ; # X
  %102 = phi i64 [%96, %$27], [%99, %$28] ; # Y
  %103 = phi i64 [%97, %$27], [%100, %$28] ; # Key
  br label %$26
$26:
  %104 = phi i64 [%83, %$23], [%101, %$29] ; # X
  %105 = phi i64 [%84, %$23], [%102, %$29] ; # Y
  %106 = phi i64 [%85, %$23], [%103, %$29] ; # Key
; # (if (== ZERO Key) (set (chkVar Exe Y) Val) (put Y Key Val))
; # (== ZERO Key)
  %107 = icmp eq i64 2, %106
  br i1 %107, label %$30, label %$31
$30:
  %108 = phi i64 [%104, %$26] ; # X
  %109 = phi i64 [%105, %$26] ; # Y
  %110 = phi i64 [%106, %$26] ; # Key
; # (set (chkVar Exe Y) Val)
; # (chkVar Exe Y)
  %111 = icmp uge i64 %109, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %111, label %$34, label %$33
$34:
  %112 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %109
  br label %$33
$33:
  %113 = phi i1 [0, %$30], [%112, %$34] ; # ->
  br i1 %113, label %$35, label %$36
$35:
  call void @protErr(i64 %0, i64 %109)
  unreachable
$36:
  %114 = inttoptr i64 %109 to i64*
  store i64 %77, i64* %114
  br label %$32
$31:
  %115 = phi i64 [%104, %$26] ; # X
  %116 = phi i64 [%105, %$26] ; # Y
  %117 = phi i64 [%106, %$26] ; # Key
; # (put Y Key Val)
  call void @put(i64 %116, i64 %117, i64 %77)
  br label %$32
$32:
  %118 = phi i64 [%108, %$36], [%115, %$31] ; # X
  %119 = phi i64 [%109, %$36], [%116, %$31] ; # Y
  %120 = phi i64 [%110, %$36], [%117, %$31] ; # Key
  br label %$24
$24:
  %121 = phi i64 [%80, %$22], [%118, %$32] ; # X
  %122 = phi i64 [%81, %$22], [%119, %$32] ; # Y
  %123 = phi i64 [%82, %$22], [%120, %$32] ; # Key
; # (drop *Safe)
  %124 = inttoptr i64 %19 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
  %127 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %126, i64* %127
  ret i64 %77
}

define i64 @_get(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (when (pair X) (save Y (loop (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (when (pair X) (save Y (loop (setq Y (getn Exe Y (eval (++ X)))) ...
; # (pair X)
  %16 = and i64 %7, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  %18 = phi i64 [%7, %$2] ; # X
  %19 = phi i64 [%15, %$2] ; # Y
; # (save Y (loop (setq Y (getn Exe Y (eval (++ X)))) (? (atom X)) (s...
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = alloca i64, i64 2, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = add i64 %23, 8
  %26 = inttoptr i64 %25 to i64*
  store i64 %21, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %27
; # (loop (setq Y (getn Exe Y (eval (++ X)))) (? (atom X)) (safe Y))
  br label %$9
$9:
  %28 = phi i64 [%18, %$7], [%45, %$15] ; # X
  %29 = phi i64 [%19, %$7], [%46, %$15] ; # Y
; # (++ X)
  %30 = inttoptr i64 %28 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
; # (eval (++ X))
  %34 = and i64 %31, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %31, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %31 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %31)
  br label %$10
$10:
  %41 = phi i64 [%31, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (getn Exe Y (eval (++ X)))
  %42 = call i64 @getn(i64 %0, i64 %29, i64 %41)
; # (? (atom X))
; # (atom X)
  %43 = and i64 %33, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$16, label %$15
$15:
  %45 = phi i64 [%33, %$10] ; # X
  %46 = phi i64 [%42, %$10] ; # Y
; # (safe Y)
  %47 = inttoptr i64 %23 to i64*
  store i64 %46, i64* %47
  br label %$9
$16:
  %48 = phi i64 [%33, %$10] ; # X
  %49 = phi i64 [%42, %$10] ; # Y
  %50 = phi i64 [0, %$10] ; # ->
; # drop
  %51 = inttoptr i64 %23 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %54
  br label %$8
$8:
  %55 = phi i64 [%7, %$2], [%48, %$16] ; # X
  %56 = phi i64 [%15, %$2], [%49, %$16] ; # Y
  ret i64 %56
}

define i64 @_prop(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Key T) (loop (setq Key (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (loop (setq Key (eval (++ X))) (? (atom X)) (setq Y (safe (getn E...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%40, %$13] ; # X
  %25 = phi i64 [%15, %$2], [%43, %$13] ; # Y
; # (++ X)
  %26 = inttoptr i64 %24 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
; # (eval (++ X))
  %30 = and i64 %27, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$10, label %$9
$10:
  br label %$8
$9:
  %32 = and i64 %27, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = inttoptr i64 %27 to i64*
  %35 = load i64, i64* %34
  br label %$8
$11:
  %36 = call i64 @evList(i64 %27)
  br label %$8
$8:
  %37 = phi i64 [%27, %$10], [%35, %$12], [%36, %$11] ; # ->
; # (? (atom X))
; # (atom X)
  %38 = and i64 %29, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$14, label %$13
$13:
  %40 = phi i64 [%29, %$8] ; # X
  %41 = phi i64 [%25, %$8] ; # Y
  %42 = phi i64 [%37, %$8] ; # Key
; # (getn Exe Y Key)
  %43 = call i64 @getn(i64 %0, i64 %41, i64 %42)
; # (safe (getn Exe Y Key))
  %44 = inttoptr i64 %19 to i64*
  store i64 %43, i64* %44
  br label %$7
$14:
  %45 = phi i64 [%29, %$8] ; # X
  %46 = phi i64 [%25, %$8] ; # Y
  %47 = phi i64 [%37, %$8] ; # Key
  %48 = phi i64 [0, %$8] ; # ->
; # (needSymb Exe Y)
  %49 = xor i64 %46, 8
  %50 = and i64 %49, 14
  %51 = icmp eq i64 %50, 0
  br i1 %51, label %$16, label %$15
$15:
  call void @symErr(i64 %0, i64 %46)
  unreachable
$16:
; # (push Key NIL)
  %52 = alloca i64, i64 2, align 16
  %53 = ptrtoint i64* %52 to i64
  %54 = inttoptr i64 %53 to i64*
  store i64 %47, i64* %54
; # (link (push Key NIL))
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %53 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %59
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %60 = add i64 %46, -8
; # (val (tail Y))
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (sym? (val (tail Y)))
  %63 = and i64 %62, 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$17, label %$18
$17:
  %65 = phi i64 [%45, %$16] ; # X
  %66 = phi i64 [%46, %$16] ; # Y
  %67 = phi i64 [%47, %$16] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %68 = icmp eq i64 %67, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %68, label %$19, label %$20
$19:
  %69 = phi i64 [%65, %$17] ; # X
  %70 = phi i64 [%66, %$17] ; # Y
  %71 = phi i64 [%67, %$17] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %70)
  br label %$21
$20:
  %72 = phi i64 [%65, %$17] ; # X
  %73 = phi i64 [%66, %$17] ; # Y
  %74 = phi i64 [%67, %$17] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %73)
  br label %$21
$21:
  %75 = phi i64 [%69, %$19], [%72, %$20] ; # X
  %76 = phi i64 [%70, %$19], [%73, %$20] ; # Y
  %77 = phi i64 [%71, %$19], [%74, %$20] ; # Key
  br label %$18
$18:
  %78 = phi i64 [%45, %$16], [%75, %$21] ; # X
  %79 = phi i64 [%46, %$16], [%76, %$21] ; # Y
  %80 = phi i64 [%47, %$16], [%77, %$21] ; # Key
; # (prop Y Key)
  %81 = call i64 @prop(i64 %79, i64 %80)
; # (drop *Safe)
  %82 = inttoptr i64 %19 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %84, i64* %85
  ret i64 %81
}

define i64 @_semicol(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (when (pair X) (save Y (loop (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (when (pair X) (save Y (loop (setq Y (getn Exe Y (++ X))) (? (ato...
; # (pair X)
  %16 = and i64 %7, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  %18 = phi i64 [%7, %$2] ; # X
  %19 = phi i64 [%15, %$2] ; # Y
; # (save Y (loop (setq Y (getn Exe Y (++ X))) (? (atom X)) (safe Y))...
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = alloca i64, i64 2, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = add i64 %23, 8
  %26 = inttoptr i64 %25 to i64*
  store i64 %21, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %27
; # (loop (setq Y (getn Exe Y (++ X))) (? (atom X)) (safe Y))
  br label %$9
$9:
  %28 = phi i64 [%18, %$7], [%37, %$10] ; # X
  %29 = phi i64 [%19, %$7], [%38, %$10] ; # Y
; # (++ X)
  %30 = inttoptr i64 %28 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
; # (getn Exe Y (++ X))
  %34 = call i64 @getn(i64 %0, i64 %29, i64 %31)
; # (? (atom X))
; # (atom X)
  %35 = and i64 %33, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$11, label %$10
$10:
  %37 = phi i64 [%33, %$9] ; # X
  %38 = phi i64 [%34, %$9] ; # Y
; # (safe Y)
  %39 = inttoptr i64 %23 to i64*
  store i64 %38, i64* %39
  br label %$9
$11:
  %40 = phi i64 [%33, %$9] ; # X
  %41 = phi i64 [%34, %$9] ; # Y
  %42 = phi i64 [0, %$9] ; # ->
; # drop
  %43 = inttoptr i64 %23 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %46
  br label %$8
$8:
  %47 = phi i64 [%7, %$2], [%40, %$11] ; # X
  %48 = phi i64 [%15, %$2], [%41, %$11] ; # Y
  ret i64 %48
}

define i64 @_setCol(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (val $This) Key T) (loop (setq Key (++ X)) (?...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $This)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %5 = load i64, i64* %4
; # (loop (setq Key (++ X)) (? (atom (cdr X))) (setq Y (getn Exe Y Ke...
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%17, %$3] ; # X
  %7 = phi i64 [%5, %$1], [%20, %$3] ; # Y
; # (++ X)
  %8 = inttoptr i64 %6 to i64*
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %8, i32 1
  %11 = load i64, i64* %10
; # (? (atom (cdr X)))
; # (cdr X)
  %12 = inttoptr i64 %11 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  %14 = load i64, i64* %13
; # (atom (cdr X))
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$4, label %$3
$3:
  %17 = phi i64 [%11, %$2] ; # X
  %18 = phi i64 [%7, %$2] ; # Y
  %19 = phi i64 [%9, %$2] ; # Key
; # (getn Exe Y Key)
  %20 = call i64 @getn(i64 %0, i64 %18, i64 %19)
  br label %$2
$4:
  %21 = phi i64 [%11, %$2] ; # X
  %22 = phi i64 [%7, %$2] ; # Y
  %23 = phi i64 [%9, %$2] ; # Key
  %24 = phi i64 [0, %$2] ; # ->
; # (when (num? Y) (argErr Exe Y))
; # (num? Y)
  %25 = and i64 %22, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$5, label %$6
$5:
  %27 = phi i64 [%21, %$4] ; # X
  %28 = phi i64 [%22, %$4] ; # Y
  %29 = phi i64 [%23, %$4] ; # Key
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %28)
  unreachable
$6:
  %30 = phi i64 [%21, %$4] ; # X
  %31 = phi i64 [%22, %$4] ; # Y
  %32 = phi i64 [%23, %$4] ; # Key
; # (let Val (eval (car X)) (if (pair Y) (putn Exe Y Key Val) (when (...
; # (car X)
  %33 = inttoptr i64 %30 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$9, label %$8
$9:
  br label %$7
$8:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$11, label %$10
$11:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$7
$10:
  %41 = call i64 @evList(i64 %34)
  br label %$7
$7:
  %42 = phi i64 [%34, %$9], [%40, %$11], [%41, %$10] ; # ->
; # (if (pair Y) (putn Exe Y Key Val) (when (sym? (val (tail Y))) (if...
; # (pair Y)
  %43 = and i64 %31, 15
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$12, label %$13
$12:
  %45 = phi i64 [%30, %$7] ; # X
  %46 = phi i64 [%31, %$7] ; # Y
  %47 = phi i64 [%32, %$7] ; # Key
; # (putn Exe Y Key Val)
  call void @putn(i64 %0, i64 %46, i64 %47, i64 %42)
  br label %$14
$13:
  %48 = phi i64 [%30, %$7] ; # X
  %49 = phi i64 [%31, %$7] ; # Y
  %50 = phi i64 [%32, %$7] ; # Key
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %51 = add i64 %49, -8
; # (val (tail Y))
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
; # (sym? (val (tail Y)))
  %54 = and i64 %53, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$15, label %$16
$15:
  %56 = phi i64 [%48, %$13] ; # X
  %57 = phi i64 [%49, %$13] ; # Y
  %58 = phi i64 [%50, %$13] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %59 = icmp eq i64 %58, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %59, label %$17, label %$18
$17:
  %60 = phi i64 [%56, %$15] ; # X
  %61 = phi i64 [%57, %$15] ; # Y
  %62 = phi i64 [%58, %$15] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %61)
  br label %$19
$18:
  %63 = phi i64 [%56, %$15] ; # X
  %64 = phi i64 [%57, %$15] ; # Y
  %65 = phi i64 [%58, %$15] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %64)
  br label %$19
$19:
  %66 = phi i64 [%60, %$17], [%63, %$18] ; # X
  %67 = phi i64 [%61, %$17], [%64, %$18] ; # Y
  %68 = phi i64 [%62, %$17], [%65, %$18] ; # Key
  br label %$16
$16:
  %69 = phi i64 [%48, %$13], [%66, %$19] ; # X
  %70 = phi i64 [%49, %$13], [%67, %$19] ; # Y
  %71 = phi i64 [%50, %$13], [%68, %$19] ; # Key
; # (if (== ZERO Key) (set (chkVar Exe Y) Val) (put Y Key Val))
; # (== ZERO Key)
  %72 = icmp eq i64 2, %71
  br i1 %72, label %$20, label %$21
$20:
  %73 = phi i64 [%69, %$16] ; # X
  %74 = phi i64 [%70, %$16] ; # Y
  %75 = phi i64 [%71, %$16] ; # Key
; # (set (chkVar Exe Y) Val)
; # (chkVar Exe Y)
  %76 = icmp uge i64 %74, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %76, label %$24, label %$23
$24:
  %77 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %74
  br label %$23
$23:
  %78 = phi i1 [0, %$20], [%77, %$24] ; # ->
  br i1 %78, label %$25, label %$26
$25:
  call void @protErr(i64 %0, i64 %74)
  unreachable
$26:
  %79 = inttoptr i64 %74 to i64*
  store i64 %42, i64* %79
  br label %$22
$21:
  %80 = phi i64 [%69, %$16] ; # X
  %81 = phi i64 [%70, %$16] ; # Y
  %82 = phi i64 [%71, %$16] ; # Key
; # (put Y Key Val)
  call void @put(i64 %81, i64 %82, i64 %42)
  br label %$22
$22:
  %83 = phi i64 [%73, %$26], [%80, %$21] ; # X
  %84 = phi i64 [%74, %$26], [%81, %$21] ; # Y
  %85 = phi i64 [%75, %$26], [%82, %$21] ; # Key
  br label %$14
$14:
  %86 = phi i64 [%45, %$12], [%83, %$22] ; # X
  %87 = phi i64 [%46, %$12], [%84, %$22] ; # Y
  %88 = phi i64 [%47, %$12], [%85, %$22] ; # Key
  ret i64 %42
}

define i64 @_col(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (val $This)) (loop (setq Y (getn Exe Y (++ X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $This)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %5 = load i64, i64* %4
; # (loop (setq Y (getn Exe Y (++ X))) (? (atom X) Y))
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%17, %$3] ; # X
  %7 = phi i64 [%5, %$1], [%18, %$3] ; # Y
; # (++ X)
  %8 = inttoptr i64 %6 to i64*
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %8, i32 1
  %11 = load i64, i64* %10
; # (getn Exe Y (++ X))
  %12 = call i64 @getn(i64 %0, i64 %7, i64 %9)
; # (? (atom X) Y)
; # (atom X)
  %13 = and i64 %11, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$5, label %$3
$5:
  %15 = phi i64 [%11, %$2] ; # X
  %16 = phi i64 [%12, %$2] ; # Y
  br label %$4
$3:
  %17 = phi i64 [%11, %$2] ; # X
  %18 = phi i64 [%12, %$2] ; # Y
  br label %$2
$4:
  %19 = phi i64 [%15, %$5] ; # X
  %20 = phi i64 [%16, %$5] ; # Y
  %21 = phi i64 [%16, %$5] ; # ->
  ret i64 %21
}

define i64 @_propCol(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (val $This) Key T) (loop (setq Key (++ X)) (?...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $This)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %5 = load i64, i64* %4
; # (loop (setq Key (++ X)) (? (atom X)) (setq Y (getn Exe Y Key)))
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%14, %$3] ; # X
  %7 = phi i64 [%5, %$1], [%17, %$3] ; # Y
; # (++ X)
  %8 = inttoptr i64 %6 to i64*
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %8, i32 1
  %11 = load i64, i64* %10
; # (? (atom X))
; # (atom X)
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$4, label %$3
$3:
  %14 = phi i64 [%11, %$2] ; # X
  %15 = phi i64 [%7, %$2] ; # Y
  %16 = phi i64 [%9, %$2] ; # Key
; # (getn Exe Y Key)
  %17 = call i64 @getn(i64 %0, i64 %15, i64 %16)
  br label %$2
$4:
  %18 = phi i64 [%11, %$2] ; # X
  %19 = phi i64 [%7, %$2] ; # Y
  %20 = phi i64 [%9, %$2] ; # Key
  %21 = phi i64 [0, %$2] ; # ->
; # (needSymb Exe Y)
  %22 = xor i64 %19, 8
  %23 = and i64 %22, 14
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$6, label %$5
$5:
  call void @symErr(i64 %0, i64 %19)
  unreachable
$6:
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %25 = add i64 %19, -8
; # (val (tail Y))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (sym? (val (tail Y)))
  %28 = and i64 %27, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$7, label %$8
$7:
  %30 = phi i64 [%18, %$6] ; # X
  %31 = phi i64 [%19, %$6] ; # Y
  %32 = phi i64 [%20, %$6] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %33 = icmp eq i64 %32, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %33, label %$9, label %$10
$9:
  %34 = phi i64 [%30, %$7] ; # X
  %35 = phi i64 [%31, %$7] ; # Y
  %36 = phi i64 [%32, %$7] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %35)
  br label %$11
$10:
  %37 = phi i64 [%30, %$7] ; # X
  %38 = phi i64 [%31, %$7] ; # Y
  %39 = phi i64 [%32, %$7] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %38)
  br label %$11
$11:
  %40 = phi i64 [%34, %$9], [%37, %$10] ; # X
  %41 = phi i64 [%35, %$9], [%38, %$10] ; # Y
  %42 = phi i64 [%36, %$9], [%39, %$10] ; # Key
  br label %$8
$8:
  %43 = phi i64 [%18, %$6], [%40, %$11] ; # X
  %44 = phi i64 [%19, %$6], [%41, %$11] ; # Y
  %45 = phi i64 [%20, %$6], [%42, %$11] ; # Key
; # (prop Y Key)
  %46 = call i64 @prop(i64 %44, i64 %45)
  ret i64 %46
}

define i64 @_putl(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z T) (loop (setq Z (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (loop (setq Z (eval (++ X))) (? (atom X)) (setq Y (safe (getn Exe...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%40, %$13] ; # X
  %25 = phi i64 [%15, %$2], [%43, %$13] ; # Y
; # (++ X)
  %26 = inttoptr i64 %24 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
; # (eval (++ X))
  %30 = and i64 %27, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$10, label %$9
$10:
  br label %$8
$9:
  %32 = and i64 %27, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = inttoptr i64 %27 to i64*
  %35 = load i64, i64* %34
  br label %$8
$11:
  %36 = call i64 @evList(i64 %27)
  br label %$8
$8:
  %37 = phi i64 [%27, %$10], [%35, %$12], [%36, %$11] ; # ->
; # (? (atom X))
; # (atom X)
  %38 = and i64 %29, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$14, label %$13
$13:
  %40 = phi i64 [%29, %$8] ; # X
  %41 = phi i64 [%25, %$8] ; # Y
  %42 = phi i64 [%37, %$8] ; # Z
; # (getn Exe Y Z)
  %43 = call i64 @getn(i64 %0, i64 %41, i64 %42)
; # (safe (getn Exe Y Z))
  %44 = inttoptr i64 %19 to i64*
  store i64 %43, i64* %44
  br label %$7
$14:
  %45 = phi i64 [%29, %$8] ; # X
  %46 = phi i64 [%25, %$8] ; # Y
  %47 = phi i64 [%37, %$8] ; # Z
  %48 = phi i64 [0, %$8] ; # ->
; # (let (R (save Z) Tail (val (tail (needSymb Exe Y)))) (when (sym? ...
; # (save Z)
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
  %51 = alloca i64, i64 2, align 16
  %52 = ptrtoint i64* %51 to i64
  %53 = inttoptr i64 %52 to i64*
  store i64 %47, i64* %53
  %54 = add i64 %52, 8
  %55 = inttoptr i64 %54 to i64*
  store i64 %50, i64* %55
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %56
; # (needSymb Exe Y)
  %57 = xor i64 %46, 8
  %58 = and i64 %57, 14
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$16, label %$15
$15:
  call void @symErr(i64 %0, i64 %46)
  unreachable
$16:
; # (tail (needSymb Exe Y))
  %60 = add i64 %46, -8
; # (val (tail (needSymb Exe Y)))
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (when (sym? (setq X Tail)) (dbTouch Exe Y) (setq X (& (val (tail ...
; # (sym? (setq X Tail))
  %63 = and i64 %62, 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$17, label %$18
$17:
  %65 = phi i64 [%62, %$16] ; # X
  %66 = phi i64 [%46, %$16] ; # Y
  %67 = phi i64 [%47, %$16] ; # Z
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %66)
; # (tail Y)
  %68 = add i64 %66, -8
; # (val (tail Y))
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (& (val (tail Y)) -9)
  %71 = and i64 %70, -9
  br label %$18
$18:
  %72 = phi i64 [%62, %$16], [%71, %$17] ; # X
  %73 = phi i64 [%46, %$16], [%66, %$17] ; # Y
  %74 = phi i64 [%47, %$16], [%67, %$17] ; # Z
; # (until (num? X) (shift X))
  br label %$19
$19:
  %75 = phi i64 [%72, %$18], [%85, %$20] ; # X
  %76 = phi i64 [%73, %$18], [%81, %$20] ; # Y
  %77 = phi i64 [%74, %$18], [%82, %$20] ; # Z
; # (num? X)
  %78 = and i64 %75, 6
  %79 = icmp ne i64 %78, 0
  br i1 %79, label %$21, label %$20
$20:
  %80 = phi i64 [%75, %$19] ; # X
  %81 = phi i64 [%76, %$19] ; # Y
  %82 = phi i64 [%77, %$19] ; # Z
; # (shift X)
  %83 = inttoptr i64 %80 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  %85 = load i64, i64* %84
  br label %$19
$21:
  %86 = phi i64 [%75, %$19] ; # X
  %87 = phi i64 [%76, %$19] ; # Y
  %88 = phi i64 [%77, %$19] ; # Z
; # (while (pair Z) (let P (++ Z) (if (atom P) (setq X (cons P X)) (u...
  br label %$22
$22:
  %89 = phi i64 [%86, %$21], [%138, %$27] ; # X
  %90 = phi i64 [%87, %$21], [%139, %$27] ; # Y
  %91 = phi i64 [%88, %$21], [%140, %$27] ; # Z
; # (pair Z)
  %92 = and i64 %91, 15
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %$23, label %$24
$23:
  %94 = phi i64 [%89, %$22] ; # X
  %95 = phi i64 [%90, %$22] ; # Y
  %96 = phi i64 [%91, %$22] ; # Z
; # (let P (++ Z) (if (atom P) (setq X (cons P X)) (unless (nil? (car...
; # (++ Z)
  %97 = inttoptr i64 %96 to i64*
  %98 = load i64, i64* %97
  %99 = getelementptr i64, i64* %97, i32 1
  %100 = load i64, i64* %99
; # (if (atom P) (setq X (cons P X)) (unless (nil? (car P)) (when (t?...
; # (atom P)
  %101 = and i64 %98, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$25, label %$26
$25:
  %103 = phi i64 [%94, %$23] ; # X
  %104 = phi i64 [%95, %$23] ; # Y
  %105 = phi i64 [%100, %$23] ; # Z
  %106 = phi i64 [%98, %$23] ; # P
; # (cons P X)
  %107 = call i64 @cons(i64 %106, i64 %103)
  br label %$27
$26:
  %108 = phi i64 [%94, %$23] ; # X
  %109 = phi i64 [%95, %$23] ; # Y
  %110 = phi i64 [%100, %$23] ; # Z
  %111 = phi i64 [%98, %$23] ; # P
; # (unless (nil? (car P)) (when (t? (car P)) (setq P (cdr P))) (setq...
; # (car P)
  %112 = inttoptr i64 %111 to i64*
  %113 = load i64, i64* %112
; # (nil? (car P))
  %114 = icmp eq i64 %113, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %114, label %$29, label %$28
$28:
  %115 = phi i64 [%108, %$26] ; # X
  %116 = phi i64 [%109, %$26] ; # Y
  %117 = phi i64 [%110, %$26] ; # Z
  %118 = phi i64 [%111, %$26] ; # P
; # (when (t? (car P)) (setq P (cdr P)))
; # (car P)
  %119 = inttoptr i64 %118 to i64*
  %120 = load i64, i64* %119
; # (t? (car P))
  %121 = icmp eq i64 %120, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %121, label %$30, label %$31
$30:
  %122 = phi i64 [%115, %$28] ; # X
  %123 = phi i64 [%116, %$28] ; # Y
  %124 = phi i64 [%117, %$28] ; # Z
  %125 = phi i64 [%118, %$28] ; # P
; # (cdr P)
  %126 = inttoptr i64 %125 to i64*
  %127 = getelementptr i64, i64* %126, i32 1
  %128 = load i64, i64* %127
  br label %$31
$31:
  %129 = phi i64 [%115, %$28], [%122, %$30] ; # X
  %130 = phi i64 [%116, %$28], [%123, %$30] ; # Y
  %131 = phi i64 [%117, %$28], [%124, %$30] ; # Z
  %132 = phi i64 [%118, %$28], [%128, %$30] ; # P
; # (cons P X)
  %133 = call i64 @cons(i64 %132, i64 %129)
  br label %$29
$29:
  %134 = phi i64 [%108, %$26], [%133, %$31] ; # X
  %135 = phi i64 [%109, %$26], [%130, %$31] ; # Y
  %136 = phi i64 [%110, %$26], [%131, %$31] ; # Z
  %137 = phi i64 [%111, %$26], [%132, %$31] ; # P
  br label %$27
$27:
  %138 = phi i64 [%107, %$25], [%134, %$29] ; # X
  %139 = phi i64 [%104, %$25], [%135, %$29] ; # Y
  %140 = phi i64 [%105, %$25], [%136, %$29] ; # Z
  %141 = phi i64 [%106, %$25], [%137, %$29] ; # P
  br label %$22
$24:
  %142 = phi i64 [%89, %$22] ; # X
  %143 = phi i64 [%90, %$22] ; # Y
  %144 = phi i64 [%91, %$22] ; # Z
; # (set (tail Y) (if (sym? Tail) (sym X) X))
; # (tail Y)
  %145 = add i64 %143, -8
; # (if (sym? Tail) (sym X) X)
; # (sym? Tail)
  %146 = and i64 %62, 8
  %147 = icmp ne i64 %146, 0
  br i1 %147, label %$32, label %$33
$32:
  %148 = phi i64 [%142, %$24] ; # X
  %149 = phi i64 [%143, %$24] ; # Y
  %150 = phi i64 [%144, %$24] ; # Z
; # (sym X)
  %151 = or i64 %148, 8
  br label %$34
$33:
  %152 = phi i64 [%142, %$24] ; # X
  %153 = phi i64 [%143, %$24] ; # Y
  %154 = phi i64 [%144, %$24] ; # Z
  br label %$34
$34:
  %155 = phi i64 [%148, %$32], [%152, %$33] ; # X
  %156 = phi i64 [%149, %$32], [%153, %$33] ; # Y
  %157 = phi i64 [%150, %$32], [%154, %$33] ; # Z
  %158 = phi i64 [%151, %$32], [%152, %$33] ; # ->
  %159 = inttoptr i64 %145 to i64*
  store i64 %158, i64* %159
; # (drop *Safe)
  %160 = inttoptr i64 %19 to i64*
  %161 = getelementptr i64, i64* %160, i32 1
  %162 = load i64, i64* %161
  %163 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %162, i64* %163
  ret i64 %47
}

define i64 @_getl(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (while (pair (shift X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (while (pair (shift X)) (setq Y (safe (getn Exe Y (eval (car X)))...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%29, %$10] ; # X
  %23 = phi i64 [%13, %$2], [%41, %$10] ; # Y
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (pair (shift X))
  %27 = and i64 %26, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$9
$8:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
; # (car X)
  %31 = inttoptr i64 %29 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  br label %$10
$11:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$14, label %$13
$14:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$10
$13:
  %39 = call i64 @evList(i64 %32)
  br label %$10
$10:
  %40 = phi i64 [%32, %$12], [%38, %$14], [%39, %$13] ; # ->
; # (getn Exe Y (eval (car X)))
  %41 = call i64 @getn(i64 %0, i64 %30, i64 %40)
; # (safe (getn Exe Y (eval (car X))))
  %42 = inttoptr i64 %17 to i64*
  store i64 %41, i64* %42
  br label %$7
$9:
  %43 = phi i64 [%26, %$7] ; # X
  %44 = phi i64 [%23, %$7] ; # Y
; # (when (sym? (setq X (val (tail (needSymb Exe Y))))) (dbFetch Exe ...
; # (needSymb Exe Y)
  %45 = xor i64 %44, 8
  %46 = and i64 %45, 14
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %$16, label %$15
$15:
  call void @symErr(i64 %0, i64 %44)
  unreachable
$16:
; # (tail (needSymb Exe Y))
  %48 = add i64 %44, -8
; # (val (tail (needSymb Exe Y)))
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (sym? (setq X (val (tail (needSymb Exe Y)))))
  %51 = and i64 %50, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$17, label %$18
$17:
  %53 = phi i64 [%50, %$16] ; # X
  %54 = phi i64 [%44, %$16] ; # Y
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %54)
; # (tail Y)
  %55 = add i64 %54, -8
; # (val (tail Y))
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
; # (& (val (tail Y)) -9)
  %58 = and i64 %57, -9
  br label %$18
$18:
  %59 = phi i64 [%50, %$16], [%58, %$17] ; # X
  %60 = phi i64 [%44, %$16], [%54, %$17] ; # Y
; # (if (num? X) $Nil (let R (setq Y (cons (car X) $Nil)) (link (push...
; # (num? X)
  %61 = and i64 %59, 6
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$20
$19:
  %63 = phi i64 [%59, %$18] ; # X
  %64 = phi i64 [%60, %$18] ; # Y
  br label %$21
$20:
  %65 = phi i64 [%59, %$18] ; # X
  %66 = phi i64 [%60, %$18] ; # Y
; # (let R (setq Y (cons (car X) $Nil)) (link (push R NIL)) (while (p...
; # (car X)
  %67 = inttoptr i64 %65 to i64*
  %68 = load i64, i64* %67
; # (cons (car X) $Nil)
  %69 = call i64 @cons(i64 %68, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (push R NIL)
  %70 = alloca i64, i64 2, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = inttoptr i64 %71 to i64*
  store i64 %69, i64* %72
; # (link (push R NIL))
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %74 = load i64, i64* %73
  %75 = inttoptr i64 %71 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %74, i64* %76
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %77
; # (while (pair (shift X)) (setq Y (set 2 Y (cons (car X) $Nil))))
  br label %$22
$22:
  %78 = phi i64 [%65, %$20], [%85, %$23] ; # X
  %79 = phi i64 [%69, %$20], [%89, %$23] ; # Y
; # (shift X)
  %80 = inttoptr i64 %78 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
; # (pair (shift X))
  %83 = and i64 %82, 15
  %84 = icmp eq i64 %83, 0
  br i1 %84, label %$23, label %$24
$23:
  %85 = phi i64 [%82, %$22] ; # X
  %86 = phi i64 [%79, %$22] ; # Y
; # (set 2 Y (cons (car X) $Nil))
; # (car X)
  %87 = inttoptr i64 %85 to i64*
  %88 = load i64, i64* %87
; # (cons (car X) $Nil)
  %89 = call i64 @cons(i64 %88, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %90 = inttoptr i64 %86 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %89, i64* %91
  br label %$22
$24:
  %92 = phi i64 [%82, %$22] ; # X
  %93 = phi i64 [%79, %$22] ; # Y
  br label %$21
$21:
  %94 = phi i64 [%63, %$19], [%92, %$24] ; # X
  %95 = phi i64 [%64, %$19], [%93, %$24] ; # Y
  %96 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$19], [%69, %$24] ; # ->
; # (drop *Safe)
  %97 = inttoptr i64 %17 to i64*
  %98 = getelementptr i64, i64* %97, i32 1
  %99 = load i64, i64* %98
  %100 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %99, i64* %100
  ret i64 %96
}

define void @wipe(i64, i64) align 8 {
$1:
; # (let (Tail (val (tail (needSymb Exe X))) Nm (name (& Tail -9))) (...
; # (needSymb Exe X)
  %2 = xor i64 %1, 8
  %3 = and i64 %2, 14
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$3, label %$2
$2:
  call void @symErr(i64 %0, i64 %1)
  unreachable
$3:
; # (tail (needSymb Exe X))
  %5 = add i64 %1, -8
; # (val (tail (needSymb Exe X)))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (& Tail -9)
  %8 = and i64 %7, -9
; # (name (& Tail -9))
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%15, %$5] ; # Tail
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$5:
  %12 = phi i64 [%9, %$4] ; # Tail
  %13 = inttoptr i64 %12 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
  br label %$4
$6:
  %16 = phi i64 [%9, %$4] ; # Tail
; # (ifn (sym? Tail) (set X $Nil (tail X) Nm) (setq Nm (add Nm Nm)) (...
; # (sym? Tail)
  %17 = and i64 %7, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$8, label %$7
$7:
  %19 = phi i64 [%16, %$6] ; # Nm
; # (set X $Nil (tail X) Nm)
  %20 = inttoptr i64 %1 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %20
; # (tail X)
  %21 = add i64 %1, -8
  %22 = inttoptr i64 %21 to i64*
  store i64 %19, i64* %22
  br label %$9
$8:
  %23 = phi i64 [%16, %$6] ; # Nm
; # (add Nm Nm)
  %24 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %23, i64 %23)
  %25 = extractvalue {i64, i1} %24, 1
  %26 = extractvalue {i64, i1} %24, 0
; # (unless @@ (setq Nm (add Nm Nm)) (when @@ (set X $Nil (tail X) (s...
  br i1 %25, label %$11, label %$10
$10:
  %27 = phi i64 [%26, %$8] ; # Nm
; # (add Nm Nm)
  %28 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %27, i64 %27)
  %29 = extractvalue {i64, i1} %28, 1
  %30 = extractvalue {i64, i1} %28, 0
; # (when @@ (set X $Nil (tail X) (sym (shr Nm 2))))
  br i1 %29, label %$12, label %$13
$12:
  %31 = phi i64 [%30, %$10] ; # Nm
; # (set X $Nil (tail X) (sym (shr Nm 2)))
  %32 = inttoptr i64 %1 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %32
; # (tail X)
  %33 = add i64 %1, -8
; # (shr Nm 2)
  %34 = lshr i64 %31, 2
; # (sym (shr Nm 2))
  %35 = or i64 %34, 8
  %36 = inttoptr i64 %33 to i64*
  store i64 %35, i64* %36
  br label %$13
$13:
  %37 = phi i64 [%30, %$10], [%31, %$12] ; # Nm
  br label %$11
$11:
  %38 = phi i64 [%26, %$8], [%37, %$13] ; # Nm
  br label %$9
$9:
  %39 = phi i64 [%19, %$7], [%38, %$11] ; # Nm
  ret void
}

define i64 @_wipe(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (unless (nil? X) (if (atom X) (wipe Exe ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (unless (nil? X) (if (atom X) (wipe Exe X) (let Y X (loop (wipe E...
; # (nil? X)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$8, label %$7
$7:
; # (if (atom X) (wipe Exe X) (let Y X (loop (wipe Exe (++ Y)) (? (at...
; # (atom X)
  %15 = and i64 %13, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$10
$9:
; # (wipe Exe X)
  call void @wipe(i64 %0, i64 %13)
  br label %$11
$10:
; # (let Y X (loop (wipe Exe (++ Y)) (? (atom Y))))
; # (loop (wipe Exe (++ Y)) (? (atom Y)))
  br label %$12
$12:
  %17 = phi i64 [%13, %$10], [%24, %$13] ; # Y
; # (++ Y)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
; # (wipe Exe (++ Y))
  call void @wipe(i64 %0, i64 %19)
; # (? (atom Y))
; # (atom Y)
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$13
$13:
  %24 = phi i64 [%21, %$12] ; # Y
  br label %$12
$14:
  %25 = phi i64 [%21, %$12] ; # Y
  %26 = phi i64 [0, %$12] ; # ->
  br label %$11
$11:
  br label %$8
$8:
  ret i64 %13
}

define i64 @meta(i64, i64) align 8 {
$1:
; # (loop (? (atom X) $Nil) (let Y (car X) (when (symb? Y) (? (not (n...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%31, %$7] ; # X
; # (? (atom X) $Nil)
; # (atom X)
  %3 = and i64 %2, 15
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$5, label %$3
$5:
  %5 = phi i64 [%2, %$2] ; # X
  br label %$4
$3:
  %6 = phi i64 [%2, %$2] ; # X
; # (let Y (car X) (when (symb? Y) (? (not (nil? (get Y Key))) @) (st...
; # (car X)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (when (symb? Y) (? (not (nil? (get Y Key))) @) (stkChk 0) (? (not...
; # (symb? Y)
  %9 = xor i64 %8, 8
  %10 = and i64 %9, 14
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$6, label %$7
$6:
  %12 = phi i64 [%6, %$3] ; # X
; # (? (not (nil? (get Y Key))) @)
; # (get Y Key)
  %13 = call i64 @get(i64 %8, i64 %1)
; # (nil? (get Y Key))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (get Y Key)))
  %15 = icmp eq i1 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%12, %$6] ; # X
  br label %$4
$8:
  %17 = phi i64 [%12, %$6] ; # X
; # (stkChk 0)
  %18 = load i8*, i8** @$StkLimit
  %19 = call i8* @llvm.stacksave()
  %20 = icmp ugt i8* %18, %19
  br i1 %20, label %$10, label %$11
$10:
  call void @stkErr(i64 0)
  unreachable
$11:
; # (? (not (nil? (meta (car Y) Key))) @)
; # (car Y)
  %21 = inttoptr i64 %8 to i64*
  %22 = load i64, i64* %21
; # (meta (car Y) Key)
  %23 = call i64 @meta(i64 %22, i64 %1)
; # (nil? (meta (car Y) Key))
  %24 = icmp eq i64 %23, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (meta (car Y) Key)))
  %25 = icmp eq i1 %24, 0
  br i1 %25, label %$13, label %$12
$13:
  %26 = phi i64 [%17, %$11] ; # X
  br label %$4
$12:
  %27 = phi i64 [%17, %$11] ; # X
  br label %$7
$7:
  %28 = phi i64 [%6, %$3], [%27, %$12] ; # X
; # (shift X)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  br label %$2
$4:
  %32 = phi i64 [%5, %$5], [%16, %$9], [%26, %$13] ; # X
  %33 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%13, %$9], [%23, %$13] ; # ->
  ret i64 %33
}

define i64 @_meta(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X)))) (when (num? Y) (argErr ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (when (num? Y) (argErr Exe Y))
; # (num? Y)
  %24 = and i64 %15, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$7, label %$8
$7:
  %26 = phi i64 [%7, %$2] ; # X
  %27 = phi i64 [%15, %$2] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %27)
  unreachable
$8:
  %28 = phi i64 [%7, %$2] ; # X
  %29 = phi i64 [%15, %$2] ; # Y
; # (when (sym? Y) (when (sym? (val (tail Y))) (dbFetch Exe Y)) (setq...
; # (sym? Y)
  %30 = and i64 %29, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$9, label %$10
$9:
  %32 = phi i64 [%28, %$8] ; # X
  %33 = phi i64 [%29, %$8] ; # Y
; # (when (sym? (val (tail Y))) (dbFetch Exe Y))
; # (tail Y)
  %34 = add i64 %33, -8
; # (val (tail Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (sym? (val (tail Y)))
  %37 = and i64 %36, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$11, label %$12
$11:
  %39 = phi i64 [%32, %$9] ; # X
  %40 = phi i64 [%33, %$9] ; # Y
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %40)
  br label %$12
$12:
  %41 = phi i64 [%32, %$9], [%39, %$11] ; # X
  %42 = phi i64 [%33, %$9], [%40, %$11] ; # Y
; # (val Y)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  br label %$10
$10:
  %45 = phi i64 [%28, %$8], [%41, %$12] ; # X
  %46 = phi i64 [%29, %$8], [%44, %$12] ; # Y
; # (car X)
  %47 = inttoptr i64 %45 to i64*
  %48 = load i64, i64* %47
; # (eval (car X))
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$15, label %$14
$15:
  br label %$13
$14:
  %51 = and i64 %48, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$17, label %$16
$17:
  %53 = inttoptr i64 %48 to i64*
  %54 = load i64, i64* %53
  br label %$13
$16:
  %55 = call i64 @evList(i64 %48)
  br label %$13
$13:
  %56 = phi i64 [%48, %$15], [%54, %$17], [%55, %$16] ; # ->
; # (meta Y (eval (car X)))
  %57 = call i64 @meta(i64 %46, i64 %56)
; # (while (pair (shift X)) (safe Y) (setq Y (getn Exe Y (eval (car X...
  br label %$18
$18:
  %58 = phi i64 [%45, %$13], [%65, %$21] ; # X
  %59 = phi i64 [%57, %$13], [%78, %$21] ; # Y
; # (shift X)
  %60 = inttoptr i64 %58 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
; # (pair (shift X))
  %63 = and i64 %62, 15
  %64 = icmp eq i64 %63, 0
  br i1 %64, label %$19, label %$20
$19:
  %65 = phi i64 [%62, %$18] ; # X
  %66 = phi i64 [%59, %$18] ; # Y
; # (safe Y)
  %67 = inttoptr i64 %19 to i64*
  store i64 %66, i64* %67
; # (car X)
  %68 = inttoptr i64 %65 to i64*
  %69 = load i64, i64* %68
; # (eval (car X))
  %70 = and i64 %69, 6
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$23, label %$22
$23:
  br label %$21
$22:
  %72 = and i64 %69, 8
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$25, label %$24
$25:
  %74 = inttoptr i64 %69 to i64*
  %75 = load i64, i64* %74
  br label %$21
$24:
  %76 = call i64 @evList(i64 %69)
  br label %$21
$21:
  %77 = phi i64 [%69, %$23], [%75, %$25], [%76, %$24] ; # ->
; # (getn Exe Y (eval (car X)))
  %78 = call i64 @getn(i64 %0, i64 %66, i64 %77)
  br label %$18
$20:
  %79 = phi i64 [%62, %$18] ; # X
  %80 = phi i64 [%59, %$18] ; # Y
; # (drop *Safe)
  %81 = inttoptr i64 %19 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_lowQ(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (isLowc (firstChar X)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (isLowc (firstChar X))) X $Nil)
; # (and (symb? X) (isLowc (firstChar X)))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (firstChar X)
  %17 = call i32 @firstChar(i64 %13)
; # (isLowc (firstChar X))
  %18 = call i1 @isLowc(i32 %17)
  br label %$7
$7:
  %19 = phi i1 [0, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_uppQ(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (isUppc (firstChar X)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (isUppc (firstChar X))) X $Nil)
; # (and (symb? X) (isUppc (firstChar X)))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (firstChar X)
  %17 = call i32 @firstChar(i64 %13)
; # (isUppc (firstChar X))
  %18 = call i1 @isUppc(i32 %17)
  br label %$7
$7:
  %19 = phi i1 [0, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_lowc(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (or (not (symb? X)) (nil? X)) X (let...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (not (symb? X)) (nil? X)) X (let (P (push 0 (xName Exe X)...
; # (or (not (symb? X)) (nil? X))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$7, label %$8
$8:
; # (nil? X)
  %18 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %19 = phi i1 [1, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (P (push 0 (xName Exe X) NIL) Q (link (ofs P 1) T) R (push 4...
; # (xName Exe X)
  %20 = call i64 @xName(i64 %0, i64 %13)
; # (push 0 (xName Exe X) NIL)
  %21 = alloca i64, i64 3, align 16
  store i64 0, i64* %21
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
; # (ofs P 1)
  %23 = getelementptr i64, i64* %21, i32 1
; # (link (ofs P 1) T)
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
; # (push 4 NIL ZERO NIL)
  %30 = alloca i64, i64 4, align 16
  store i64 4, i64* %30
  %31 = getelementptr i64, i64* %30, i32 2
  store i64 2, i64* %31
; # (ofs R 2)
  %32 = getelementptr i64, i64* %30, i32 2
; # (link (ofs R 2))
  %33 = ptrtoint i64* %32 to i64
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %33 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %33, i64* %38
; # (while (setq C (symChar P)) (charSym (toLowerCase C) R))
  br label %$12
$12:
; # (symChar P)
  %39 = call i32 @symChar(i64* %21)
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %$13, label %$14
$13:
  %41 = phi i32 [%39, %$12] ; # C
; # (toLowerCase C)
  %42 = call i32 @toLowerCase(i32 %41)
; # (charSym (toLowerCase C) R)
  call void @charSym(i32 %42, i64* %30)
  br label %$12
$14:
  %43 = phi i32 [%39, %$12] ; # C
; # (val 3 R)
  %44 = getelementptr i64, i64* %30, i32 2
  %45 = load i64, i64* %44
; # (consStr (val 3 R))
  %46 = call i64 @consStr(i64 %45)
; # (drop *Safe)
  %47 = inttoptr i64 %24 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %50
  br label %$11
$11:
  %51 = phi i64 [%13, %$9], [%46, %$14] ; # ->
  ret i64 %51
}

define i64 @_uppc(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (or (not (symb? X)) (nil? X)) X (let...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (not (symb? X)) (nil? X)) X (let (P (push 0 (xName Exe X)...
; # (or (not (symb? X)) (nil? X))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$7, label %$8
$8:
; # (nil? X)
  %18 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %19 = phi i1 [1, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (P (push 0 (xName Exe X) NIL) Q (link (ofs P 1) T) R (push 4...
; # (xName Exe X)
  %20 = call i64 @xName(i64 %0, i64 %13)
; # (push 0 (xName Exe X) NIL)
  %21 = alloca i64, i64 3, align 16
  store i64 0, i64* %21
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
; # (ofs P 1)
  %23 = getelementptr i64, i64* %21, i32 1
; # (link (ofs P 1) T)
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
; # (push 4 NIL ZERO NIL)
  %30 = alloca i64, i64 4, align 16
  store i64 4, i64* %30
  %31 = getelementptr i64, i64* %30, i32 2
  store i64 2, i64* %31
; # (ofs R 2)
  %32 = getelementptr i64, i64* %30, i32 2
; # (link (ofs R 2))
  %33 = ptrtoint i64* %32 to i64
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %33 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %33, i64* %38
; # (while (setq C (symChar P)) (ifn (== C (char "")) (charSym (toUp...
  br label %$12
$12:
; # (symChar P)
  %39 = call i32 @symChar(i64* %21)
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %$13, label %$14
$13:
  %41 = phi i32 [%39, %$12] ; # C
; # (ifn (== C (char "")) (charSym (toUpperCase C) R) (charSym (char...
; # (== C (char ""))
  %42 = icmp eq i32 %41, 223
  br i1 %42, label %$16, label %$15
$15:
  %43 = phi i32 [%41, %$13] ; # C
; # (toUpperCase C)
  %44 = call i32 @toUpperCase(i32 %43)
; # (charSym (toUpperCase C) R)
  call void @charSym(i32 %44, i64* %30)
  br label %$17
$16:
  %45 = phi i32 [%41, %$13] ; # C
; # (charSym (char "S") R)
  call void @charSym(i32 83, i64* %30)
; # (charSym (char "S") R)
  call void @charSym(i32 83, i64* %30)
  br label %$17
$17:
  %46 = phi i32 [%43, %$15], [%45, %$16] ; # C
  br label %$12
$14:
  %47 = phi i32 [%39, %$12] ; # C
; # (val 3 R)
  %48 = getelementptr i64, i64* %30, i32 2
  %49 = load i64, i64* %48
; # (consStr (val 3 R))
  %50 = call i64 @consStr(i64 %49)
; # (drop *Safe)
  %51 = inttoptr i64 %24 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %54
  br label %$11
$11:
  %55 = phi i64 [%13, %$9], [%50, %$14] ; # ->
  ret i64 %55
}

define i64 @_fold(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (if (or (not (symb? Y)) (nil? ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (if (or (not (symb? Y)) (nil? Y)) Y (let (N (if (atom X) 0 (evCnt...
; # (or (not (symb? Y)) (nil? Y))
; # (symb? Y)
  %16 = xor i64 %15, 8
  %17 = and i64 %16, 14
  %18 = icmp eq i64 %17, 0
; # (not (symb? Y))
  %19 = icmp eq i1 %18, 0
  br i1 %19, label %$7, label %$8
$8:
; # (nil? Y)
  %20 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %21 = phi i1 [1, %$2], [%20, %$8] ; # ->
  br i1 %21, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (N (if (atom X) 0 (evCnt Exe X)) P (push 0 (xName Exe Y) NIL...
; # (if (atom X) 0 (evCnt Exe X))
; # (atom X)
  %22 = and i64 %7, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$13
$12:
  br label %$14
$13:
; # (evCnt Exe X)
  %24 = call i64 @evCnt(i64 %0, i64 %7)
  br label %$14
$14:
  %25 = phi i64 [0, %$12], [%24, %$13] ; # ->
; # (xName Exe Y)
  %26 = call i64 @xName(i64 %0, i64 %15)
; # (push 0 (xName Exe Y) NIL)
  %27 = alloca i64, i64 3, align 16
  store i64 0, i64* %27
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
; # (ofs P 1)
  %29 = getelementptr i64, i64* %27, i32 1
; # (link (ofs P 1) T)
  %30 = ptrtoint i64* %29 to i64
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %30 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %35
; # (push 4 NIL ZERO NIL)
  %36 = alloca i64, i64 4, align 16
  store i64 4, i64* %36
  %37 = getelementptr i64, i64* %36, i32 2
  store i64 2, i64* %37
; # (ofs R 2)
  %38 = getelementptr i64, i64* %36, i32 2
; # (link (ofs R 2))
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = inttoptr i64 %39 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  store i64 %41, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %44
; # (while (setq C (symChar P)) (when (isLetterOrDigit C) (charSym (t...
  br label %$15
$15:
  %45 = phi i64 [%25, %$14], [%58, %$19] ; # N
; # (symChar P)
  %46 = call i32 @symChar(i64* %27)
  %47 = icmp ne i32 %46, 0
  br i1 %47, label %$16, label %$17
$16:
  %48 = phi i64 [%45, %$15] ; # N
  %49 = phi i32 [%46, %$15] ; # C
; # (when (isLetterOrDigit C) (charSym (toLowerCase C) R) (? (=0 (dec...
; # (isLetterOrDigit C)
  %50 = call i1 @isLetterOrDigit(i32 %49)
  br i1 %50, label %$18, label %$19
$18:
  %51 = phi i64 [%48, %$16] ; # N
  %52 = phi i32 [%49, %$16] ; # C
; # (toLowerCase C)
  %53 = call i32 @toLowerCase(i32 %52)
; # (charSym (toLowerCase C) R)
  call void @charSym(i32 %53, i64* %36)
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %54 = sub i64 %51, 1
; # (=0 (dec 'N))
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %$17, label %$20
$20:
  %56 = phi i64 [%54, %$18] ; # N
  %57 = phi i32 [%52, %$18] ; # C
  br label %$19
$19:
  %58 = phi i64 [%48, %$16], [%56, %$20] ; # N
  %59 = phi i32 [%49, %$16], [%57, %$20] ; # C
  br label %$15
$17:
  %60 = phi i64 [%45, %$15], [%54, %$18] ; # N
  %61 = phi i32 [%46, %$15], [%52, %$18] ; # C
; # (val 3 R)
  %62 = getelementptr i64, i64* %36, i32 2
  %63 = load i64, i64* %62
; # (consStr (val 3 R))
  %64 = call i64 @consStr(i64 %63)
; # (drop *Safe)
  %65 = inttoptr i64 %30 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %68
  br label %$11
$11:
  %69 = phi i64 [%15, %$9], [%64, %$17] ; # ->
  ret i64 %69
}

define i1 @equal(i64, i64) align 8 {
$1:
; # (cond ((== X Y) YES) ((cnt? X) NO) ((big? X) (if (cnt? Y) NO (whe...
; # (== X Y)
  %2 = icmp eq i64 %0, %1
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
  %4 = phi i64 [%1, %$1] ; # Y
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
  %6 = phi i64 [%1, %$1] ; # Y
; # (cnt? X)
  %7 = and i64 %5, 2
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i64 [%5, %$3] ; # X
  %10 = phi i64 [%6, %$3] ; # Y
  br label %$2
$5:
  %11 = phi i64 [%5, %$3] ; # X
  %12 = phi i64 [%6, %$3] ; # Y
; # (big? X)
  %13 = and i64 %11, 4
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  %15 = phi i64 [%11, %$5] ; # X
  %16 = phi i64 [%12, %$5] ; # Y
; # (if (cnt? Y) NO (when (sign? X) (unless (sign? Y) (ret NO)) (setq...
; # (cnt? Y)
  %17 = and i64 %16, 2
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$9, label %$10
$9:
  %19 = phi i64 [%15, %$8] ; # X
  %20 = phi i64 [%16, %$8] ; # Y
  br label %$11
$10:
  %21 = phi i64 [%15, %$8] ; # X
  %22 = phi i64 [%16, %$8] ; # Y
; # (when (sign? X) (unless (sign? Y) (ret NO)) (setq X (pos X) Y (po...
; # (sign? X)
  %23 = and i64 %21, 8
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$13
$12:
  %25 = phi i64 [%21, %$10] ; # X
  %26 = phi i64 [%22, %$10] ; # Y
; # (unless (sign? Y) (ret NO))
; # (sign? Y)
  %27 = and i64 %26, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$14:
  %29 = phi i64 [%25, %$12] ; # X
  %30 = phi i64 [%26, %$12] ; # Y
; # (ret NO)
  ret i1 0
$15:
  %31 = phi i64 [%25, %$12] ; # X
  %32 = phi i64 [%26, %$12] ; # Y
; # (pos X)
  %33 = and i64 %31, -9
; # (pos Y)
  %34 = and i64 %32, -9
  br label %$13
$13:
  %35 = phi i64 [%21, %$10], [%33, %$15] ; # X
  %36 = phi i64 [%22, %$10], [%34, %$15] ; # Y
; # (equalBig X Y)
  br label %$16
$16:
  %37 = phi i64 [%35, %$13], [%71, %$24] ; # X
  %38 = phi i64 [%36, %$13], [%72, %$24] ; # Y
  %39 = add i64 %37, -4
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
  %42 = add i64 %38, -4
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  %45 = icmp ne i64 %41, %44
  br i1 %45, label %$19, label %$17
$19:
  %46 = phi i64 [%37, %$16] ; # X
  %47 = phi i64 [%38, %$16] ; # Y
  br label %$18
$17:
  %48 = phi i64 [%37, %$16] ; # X
  %49 = phi i64 [%38, %$16] ; # Y
  %50 = add i64 %48, 4
  %51 = inttoptr i64 %50 to i64*
  %52 = load i64, i64* %51
  %53 = add i64 %49, 4
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
  %56 = icmp eq i64 %52, %55
  br i1 %56, label %$21, label %$20
$21:
  %57 = phi i64 [%52, %$17] ; # X
  %58 = phi i64 [%55, %$17] ; # Y
  br label %$18
$20:
  %59 = phi i64 [%52, %$17] ; # X
  %60 = phi i64 [%55, %$17] ; # Y
  %61 = and i64 %59, 2
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$23, label %$22
$23:
  %63 = phi i64 [%59, %$20] ; # X
  %64 = phi i64 [%60, %$20] ; # Y
  br label %$18
$22:
  %65 = phi i64 [%59, %$20] ; # X
  %66 = phi i64 [%60, %$20] ; # Y
  %67 = and i64 %66, 2
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$25, label %$24
$25:
  %69 = phi i64 [%65, %$22] ; # X
  %70 = phi i64 [%66, %$22] ; # Y
  br label %$18
$24:
  %71 = phi i64 [%65, %$22] ; # X
  %72 = phi i64 [%66, %$22] ; # Y
  br label %$16
$18:
  %73 = phi i64 [%46, %$19], [%57, %$21], [%63, %$23], [%69, %$25] ; # X
  %74 = phi i64 [%47, %$19], [%58, %$21], [%64, %$23], [%70, %$25] ; # Y
  %75 = phi i1 [0, %$19], [1, %$21], [0, %$23], [0, %$25] ; # ->
  br label %$11
$11:
  %76 = phi i64 [%19, %$9], [%35, %$18] ; # X
  %77 = phi i64 [%20, %$9], [%36, %$18] ; # Y
  %78 = phi i1 [0, %$9], [%75, %$18] ; # ->
  br label %$2
$7:
  %79 = phi i64 [%11, %$5] ; # X
  %80 = phi i64 [%12, %$5] ; # Y
; # (sym? X)
  %81 = and i64 %79, 8
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$27, label %$26
$27:
  %83 = phi i64 [%79, %$7] ; # X
  %84 = phi i64 [%80, %$7] ; # Y
; # (cond ((num? Y) NO) ((pair Y) NO) ((sym? (val (tail X))) NO) ((==...
; # (num? Y)
  %85 = and i64 %84, 6
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$30, label %$29
$30:
  %87 = phi i64 [%83, %$27] ; # X
  %88 = phi i64 [%84, %$27] ; # Y
  br label %$28
$29:
  %89 = phi i64 [%83, %$27] ; # X
  %90 = phi i64 [%84, %$27] ; # Y
; # (pair Y)
  %91 = and i64 %90, 15
  %92 = icmp eq i64 %91, 0
  br i1 %92, label %$32, label %$31
$32:
  %93 = phi i64 [%89, %$29] ; # X
  %94 = phi i64 [%90, %$29] ; # Y
  br label %$28
$31:
  %95 = phi i64 [%89, %$29] ; # X
  %96 = phi i64 [%90, %$29] ; # Y
; # (tail X)
  %97 = add i64 %95, -8
; # (val (tail X))
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
; # (sym? (val (tail X)))
  %100 = and i64 %99, 8
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$34, label %$33
$34:
  %102 = phi i64 [%95, %$31] ; # X
  %103 = phi i64 [%96, %$31] ; # Y
  br label %$28
$33:
  %104 = phi i64 [%95, %$31] ; # X
  %105 = phi i64 [%96, %$31] ; # Y
; # (name @)
  br label %$35
$35:
  %106 = phi i64 [%99, %$33], [%112, %$36] ; # Tail
  %107 = and i64 %106, 6
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$37, label %$36
$36:
  %109 = phi i64 [%106, %$35] ; # Tail
  %110 = inttoptr i64 %109 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  %112 = load i64, i64* %111
  br label %$35
$37:
  %113 = phi i64 [%106, %$35] ; # Tail
; # (== ZERO (setq X (name @)))
  %114 = icmp eq i64 2, %113
  br i1 %114, label %$39, label %$38
$39:
  %115 = phi i64 [%113, %$37] ; # X
  %116 = phi i64 [%105, %$37] ; # Y
  br label %$28
$38:
  %117 = phi i64 [%113, %$37] ; # X
  %118 = phi i64 [%105, %$37] ; # Y
; # (tail Y)
  %119 = add i64 %118, -8
; # (val (tail Y))
  %120 = inttoptr i64 %119 to i64*
  %121 = load i64, i64* %120
; # (sym? (val (tail Y)))
  %122 = and i64 %121, 8
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$41, label %$40
$41:
  %124 = phi i64 [%117, %$38] ; # X
  %125 = phi i64 [%118, %$38] ; # Y
  br label %$28
$40:
  %126 = phi i64 [%117, %$38] ; # X
  %127 = phi i64 [%118, %$38] ; # Y
; # (name @)
  br label %$42
$42:
  %128 = phi i64 [%121, %$40], [%134, %$43] ; # Tail
  %129 = and i64 %128, 6
  %130 = icmp ne i64 %129, 0
  br i1 %130, label %$44, label %$43
$43:
  %131 = phi i64 [%128, %$42] ; # Tail
  %132 = inttoptr i64 %131 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
  br label %$42
$44:
  %135 = phi i64 [%128, %$42] ; # Tail
; # (== ZERO (setq Y (name @)))
  %136 = icmp eq i64 2, %135
  br i1 %136, label %$46, label %$45
$46:
  %137 = phi i64 [%126, %$44] ; # X
  %138 = phi i64 [%135, %$44] ; # Y
  br label %$28
$45:
  %139 = phi i64 [%126, %$44] ; # X
  %140 = phi i64 [%135, %$44] ; # Y
; # (== X Y)
  %141 = icmp eq i64 %139, %140
  br i1 %141, label %$48, label %$47
$48:
  %142 = phi i64 [%139, %$45] ; # X
  %143 = phi i64 [%140, %$45] ; # Y
  br label %$28
$47:
  %144 = phi i64 [%139, %$45] ; # X
  %145 = phi i64 [%140, %$45] ; # Y
; # (cnt? X)
  %146 = and i64 %144, 2
  %147 = icmp ne i64 %146, 0
  br i1 %147, label %$50, label %$49
$50:
  %148 = phi i64 [%144, %$47] ; # X
  %149 = phi i64 [%145, %$47] ; # Y
  br label %$28
$49:
  %150 = phi i64 [%144, %$47] ; # X
  %151 = phi i64 [%145, %$47] ; # Y
; # (cnt? Y)
  %152 = and i64 %151, 2
  %153 = icmp ne i64 %152, 0
  br i1 %153, label %$52, label %$51
$52:
  %154 = phi i64 [%150, %$49] ; # X
  %155 = phi i64 [%151, %$49] ; # Y
  br label %$28
$51:
  %156 = phi i64 [%150, %$49] ; # X
  %157 = phi i64 [%151, %$49] ; # Y
; # (equalBig X Y)
  br label %$53
$53:
  %158 = phi i64 [%156, %$51], [%192, %$61] ; # X
  %159 = phi i64 [%157, %$51], [%193, %$61] ; # Y
  %160 = add i64 %158, -4
  %161 = inttoptr i64 %160 to i64*
  %162 = load i64, i64* %161
  %163 = add i64 %159, -4
  %164 = inttoptr i64 %163 to i64*
  %165 = load i64, i64* %164
  %166 = icmp ne i64 %162, %165
  br i1 %166, label %$56, label %$54
$56:
  %167 = phi i64 [%158, %$53] ; # X
  %168 = phi i64 [%159, %$53] ; # Y
  br label %$55
$54:
  %169 = phi i64 [%158, %$53] ; # X
  %170 = phi i64 [%159, %$53] ; # Y
  %171 = add i64 %169, 4
  %172 = inttoptr i64 %171 to i64*
  %173 = load i64, i64* %172
  %174 = add i64 %170, 4
  %175 = inttoptr i64 %174 to i64*
  %176 = load i64, i64* %175
  %177 = icmp eq i64 %173, %176
  br i1 %177, label %$58, label %$57
$58:
  %178 = phi i64 [%173, %$54] ; # X
  %179 = phi i64 [%176, %$54] ; # Y
  br label %$55
$57:
  %180 = phi i64 [%173, %$54] ; # X
  %181 = phi i64 [%176, %$54] ; # Y
  %182 = and i64 %180, 2
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$60, label %$59
$60:
  %184 = phi i64 [%180, %$57] ; # X
  %185 = phi i64 [%181, %$57] ; # Y
  br label %$55
$59:
  %186 = phi i64 [%180, %$57] ; # X
  %187 = phi i64 [%181, %$57] ; # Y
  %188 = and i64 %187, 2
  %189 = icmp ne i64 %188, 0
  br i1 %189, label %$62, label %$61
$62:
  %190 = phi i64 [%186, %$59] ; # X
  %191 = phi i64 [%187, %$59] ; # Y
  br label %$55
$61:
  %192 = phi i64 [%186, %$59] ; # X
  %193 = phi i64 [%187, %$59] ; # Y
  br label %$53
$55:
  %194 = phi i64 [%167, %$56], [%178, %$58], [%184, %$60], [%190, %$62] ; # X
  %195 = phi i64 [%168, %$56], [%179, %$58], [%185, %$60], [%191, %$62] ; # Y
  %196 = phi i1 [0, %$56], [1, %$58], [0, %$60], [0, %$62] ; # ->
  br label %$28
$28:
  %197 = phi i64 [%87, %$30], [%93, %$32], [%102, %$34], [%115, %$39], [%124, %$41], [%137, %$46], [%142, %$48], [%148, %$50], [%154, %$52], [%156, %$55] ; # X
  %198 = phi i64 [%88, %$30], [%94, %$32], [%103, %$34], [%116, %$39], [%125, %$41], [%138, %$46], [%143, %$48], [%149, %$50], [%155, %$52], [%157, %$55] ; # Y
  %199 = phi i1 [0, %$30], [0, %$32], [0, %$34], [0, %$39], [0, %$41], [0, %$46], [1, %$48], [0, %$50], [0, %$52], [%196, %$55] ; # ->
  br label %$2
$26:
  %200 = phi i64 [%79, %$7] ; # X
  %201 = phi i64 [%80, %$7] ; # Y
; # (atom Y)
  %202 = and i64 %201, 15
  %203 = icmp ne i64 %202, 0
  br i1 %203, label %$64, label %$63
$64:
  %204 = phi i64 [%200, %$26] ; # X
  %205 = phi i64 [%201, %$26] ; # Y
  br label %$2
$63:
  %206 = phi i64 [%200, %$26] ; # X
  %207 = phi i64 [%201, %$26] ; # Y
; # (stkChk 0)
  %208 = load i8*, i8** @$StkLimit
  %209 = call i8* @llvm.stacksave()
  %210 = icmp ugt i8* %208, %209
  br i1 %210, label %$65, label %$66
$65:
  call void @stkErr(i64 0)
  unreachable
$66:
; # (let (A X B Y) (prog1 (loop (? (not (equal (car X) (& (car Y) -2)...
; # (prog1 (loop (? (not (equal (car X) (& (car Y) -2))) NO) (? (atom...
; # (loop (? (not (equal (car X) (& (car Y) -2))) NO) (? (atom (cdr X...
  br label %$67
$67:
  %211 = phi i64 [%206, %$66], [%373, %$75] ; # X
  %212 = phi i64 [%207, %$66], [%374, %$75] ; # Y
  %213 = phi i64 [%206, %$66], [%375, %$75] ; # A
  %214 = phi i64 [%207, %$66], [%376, %$75] ; # B
; # (? (not (equal (car X) (& (car Y) -2))) NO)
; # (car X)
  %215 = inttoptr i64 %211 to i64*
  %216 = load i64, i64* %215
; # (car Y)
  %217 = inttoptr i64 %212 to i64*
  %218 = load i64, i64* %217
; # (& (car Y) -2)
  %219 = and i64 %218, -2
; # (equal (car X) (& (car Y) -2))
  %220 = call i1 @equal(i64 %216, i64 %219)
; # (not (equal (car X) (& (car Y) -2)))
  %221 = icmp eq i1 %220, 0
  br i1 %221, label %$70, label %$68
$70:
  %222 = phi i64 [%211, %$67] ; # X
  %223 = phi i64 [%212, %$67] ; # Y
  %224 = phi i64 [%213, %$67] ; # A
  %225 = phi i64 [%214, %$67] ; # B
  br label %$69
$68:
  %226 = phi i64 [%211, %$67] ; # X
  %227 = phi i64 [%212, %$67] ; # Y
  %228 = phi i64 [%213, %$67] ; # A
  %229 = phi i64 [%214, %$67] ; # B
; # (? (atom (cdr X)) (equal (cdr X) (cdr Y)))
; # (cdr X)
  %230 = inttoptr i64 %226 to i64*
  %231 = getelementptr i64, i64* %230, i32 1
  %232 = load i64, i64* %231
; # (atom (cdr X))
  %233 = and i64 %232, 15
  %234 = icmp ne i64 %233, 0
  br i1 %234, label %$72, label %$71
$72:
  %235 = phi i64 [%226, %$68] ; # X
  %236 = phi i64 [%227, %$68] ; # Y
  %237 = phi i64 [%228, %$68] ; # A
  %238 = phi i64 [%229, %$68] ; # B
; # (cdr X)
  %239 = inttoptr i64 %235 to i64*
  %240 = getelementptr i64, i64* %239, i32 1
  %241 = load i64, i64* %240
; # (cdr Y)
  %242 = inttoptr i64 %236 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
; # (equal (cdr X) (cdr Y))
  %245 = call i1 @equal(i64 %241, i64 %244)
  br label %$69
$71:
  %246 = phi i64 [%226, %$68] ; # X
  %247 = phi i64 [%227, %$68] ; # Y
  %248 = phi i64 [%228, %$68] ; # A
  %249 = phi i64 [%229, %$68] ; # B
; # (? (atom (cdr Y)) NO)
; # (cdr Y)
  %250 = inttoptr i64 %247 to i64*
  %251 = getelementptr i64, i64* %250, i32 1
  %252 = load i64, i64* %251
; # (atom (cdr Y))
  %253 = and i64 %252, 15
  %254 = icmp ne i64 %253, 0
  br i1 %254, label %$74, label %$73
$74:
  %255 = phi i64 [%246, %$71] ; # X
  %256 = phi i64 [%247, %$71] ; # Y
  %257 = phi i64 [%248, %$71] ; # A
  %258 = phi i64 [%249, %$71] ; # B
  br label %$69
$73:
  %259 = phi i64 [%246, %$71] ; # X
  %260 = phi i64 [%247, %$71] ; # Y
  %261 = phi i64 [%248, %$71] ; # A
  %262 = phi i64 [%249, %$71] ; # B
; # (set X (| (val X) 1))
; # (val X)
  %263 = inttoptr i64 %259 to i64*
  %264 = load i64, i64* %263
; # (| (val X) 1)
  %265 = or i64 %264, 1
  %266 = inttoptr i64 %259 to i64*
  store i64 %265, i64* %266
; # (shift X)
  %267 = inttoptr i64 %259 to i64*
  %268 = getelementptr i64, i64* %267, i32 1
  %269 = load i64, i64* %268
; # (shift Y)
  %270 = inttoptr i64 %260 to i64*
  %271 = getelementptr i64, i64* %270, i32 1
  %272 = load i64, i64* %271
; # (? (& (val X) 1) (prog1 (loop (? (== A X) (if (== B Y) (loop (shi...
; # (val X)
  %273 = inttoptr i64 %269 to i64*
  %274 = load i64, i64* %273
; # (& (val X) 1)
  %275 = and i64 %274, 1
  %276 = icmp ne i64 %275, 0
  br i1 %276, label %$76, label %$75
$76:
  %277 = phi i64 [%269, %$73] ; # X
  %278 = phi i64 [%272, %$73] ; # Y
  %279 = phi i64 [%261, %$73] ; # A
  %280 = phi i64 [%262, %$73] ; # B
; # (prog1 (loop (? (== A X) (if (== B Y) (loop (shift A) (? (== (shi...
; # (loop (? (== A X) (if (== B Y) (loop (shift A) (? (== (shift B) Y...
  br label %$77
$77:
  %281 = phi i64 [%277, %$76], [%347, %$90] ; # X
  %282 = phi i64 [%278, %$76], [%348, %$90] ; # Y
  %283 = phi i64 [%279, %$76], [%357, %$90] ; # A
  %284 = phi i64 [%280, %$76], [%360, %$90] ; # B
; # (? (== A X) (if (== B Y) (loop (shift A) (? (== (shift B) Y) (== ...
; # (== A X)
  %285 = icmp eq i64 %283, %281
  br i1 %285, label %$80, label %$78
$80:
  %286 = phi i64 [%281, %$77] ; # X
  %287 = phi i64 [%282, %$77] ; # Y
  %288 = phi i64 [%283, %$77] ; # A
  %289 = phi i64 [%284, %$77] ; # B
; # (if (== B Y) (loop (shift A) (? (== (shift B) Y) (== A X)) (? (==...
; # (== B Y)
  %290 = icmp eq i64 %289, %287
  br i1 %290, label %$81, label %$82
$81:
  %291 = phi i64 [%286, %$80] ; # X
  %292 = phi i64 [%287, %$80] ; # Y
  %293 = phi i64 [%288, %$80] ; # A
  %294 = phi i64 [%289, %$80] ; # B
; # (loop (shift A) (? (== (shift B) Y) (== A X)) (? (== A X) YES))
  br label %$84
$84:
  %295 = phi i64 [%291, %$81], [%320, %$88] ; # X
  %296 = phi i64 [%292, %$81], [%321, %$88] ; # Y
  %297 = phi i64 [%293, %$81], [%322, %$88] ; # A
  %298 = phi i64 [%294, %$81], [%323, %$88] ; # B
; # (shift A)
  %299 = inttoptr i64 %297 to i64*
  %300 = getelementptr i64, i64* %299, i32 1
  %301 = load i64, i64* %300
; # (? (== (shift B) Y) (== A X))
; # (shift B)
  %302 = inttoptr i64 %298 to i64*
  %303 = getelementptr i64, i64* %302, i32 1
  %304 = load i64, i64* %303
; # (== (shift B) Y)
  %305 = icmp eq i64 %304, %296
  br i1 %305, label %$87, label %$85
$87:
  %306 = phi i64 [%295, %$84] ; # X
  %307 = phi i64 [%296, %$84] ; # Y
  %308 = phi i64 [%301, %$84] ; # A
  %309 = phi i64 [%304, %$84] ; # B
; # (== A X)
  %310 = icmp eq i64 %308, %306
  br label %$86
$85:
  %311 = phi i64 [%295, %$84] ; # X
  %312 = phi i64 [%296, %$84] ; # Y
  %313 = phi i64 [%301, %$84] ; # A
  %314 = phi i64 [%304, %$84] ; # B
; # (? (== A X) YES)
; # (== A X)
  %315 = icmp eq i64 %313, %311
  br i1 %315, label %$89, label %$88
$89:
  %316 = phi i64 [%311, %$85] ; # X
  %317 = phi i64 [%312, %$85] ; # Y
  %318 = phi i64 [%313, %$85] ; # A
  %319 = phi i64 [%314, %$85] ; # B
  br label %$86
$88:
  %320 = phi i64 [%311, %$85] ; # X
  %321 = phi i64 [%312, %$85] ; # Y
  %322 = phi i64 [%313, %$85] ; # A
  %323 = phi i64 [%314, %$85] ; # B
  br label %$84
$86:
  %324 = phi i64 [%306, %$87], [%316, %$89] ; # X
  %325 = phi i64 [%307, %$87], [%317, %$89] ; # Y
  %326 = phi i64 [%308, %$87], [%318, %$89] ; # A
  %327 = phi i64 [%309, %$87], [%319, %$89] ; # B
  %328 = phi i1 [%310, %$87], [1, %$89] ; # ->
  br label %$83
$82:
  %329 = phi i64 [%286, %$80] ; # X
  %330 = phi i64 [%287, %$80] ; # Y
  %331 = phi i64 [%288, %$80] ; # A
  %332 = phi i64 [%289, %$80] ; # B
  br label %$83
$83:
  %333 = phi i64 [%324, %$86], [%329, %$82] ; # X
  %334 = phi i64 [%325, %$86], [%330, %$82] ; # Y
  %335 = phi i64 [%326, %$86], [%331, %$82] ; # A
  %336 = phi i64 [%327, %$86], [%332, %$82] ; # B
  %337 = phi i1 [%328, %$86], [0, %$82] ; # ->
  br label %$79
$78:
  %338 = phi i64 [%281, %$77] ; # X
  %339 = phi i64 [%282, %$77] ; # Y
  %340 = phi i64 [%283, %$77] ; # A
  %341 = phi i64 [%284, %$77] ; # B
; # (? (== B Y) NO)
; # (== B Y)
  %342 = icmp eq i64 %341, %339
  br i1 %342, label %$91, label %$90
$91:
  %343 = phi i64 [%338, %$78] ; # X
  %344 = phi i64 [%339, %$78] ; # Y
  %345 = phi i64 [%340, %$78] ; # A
  %346 = phi i64 [%341, %$78] ; # B
  br label %$79
$90:
  %347 = phi i64 [%338, %$78] ; # X
  %348 = phi i64 [%339, %$78] ; # Y
  %349 = phi i64 [%340, %$78] ; # A
  %350 = phi i64 [%341, %$78] ; # B
; # (set A (& (val A) -2))
; # (val A)
  %351 = inttoptr i64 %349 to i64*
  %352 = load i64, i64* %351
; # (& (val A) -2)
  %353 = and i64 %352, -2
  %354 = inttoptr i64 %349 to i64*
  store i64 %353, i64* %354
; # (shift A)
  %355 = inttoptr i64 %349 to i64*
  %356 = getelementptr i64, i64* %355, i32 1
  %357 = load i64, i64* %356
; # (shift B)
  %358 = inttoptr i64 %350 to i64*
  %359 = getelementptr i64, i64* %358, i32 1
  %360 = load i64, i64* %359
  br label %$77
$79:
  %361 = phi i64 [%333, %$83], [%343, %$91] ; # X
  %362 = phi i64 [%334, %$83], [%344, %$91] ; # Y
  %363 = phi i64 [%335, %$83], [%345, %$91] ; # A
  %364 = phi i64 [%336, %$83], [%346, %$91] ; # B
  %365 = phi i1 [%337, %$83], [0, %$91] ; # ->
; # (set A (& (val A) -2))
; # (val A)
  %366 = inttoptr i64 %363 to i64*
  %367 = load i64, i64* %366
; # (& (val A) -2)
  %368 = and i64 %367, -2
  %369 = inttoptr i64 %363 to i64*
  store i64 %368, i64* %369
; # (shift A)
  %370 = inttoptr i64 %363 to i64*
  %371 = getelementptr i64, i64* %370, i32 1
  %372 = load i64, i64* %371
  br label %$69
$75:
  %373 = phi i64 [%269, %$73] ; # X
  %374 = phi i64 [%272, %$73] ; # Y
  %375 = phi i64 [%261, %$73] ; # A
  %376 = phi i64 [%262, %$73] ; # B
  br label %$67
$69:
  %377 = phi i64 [%222, %$70], [%235, %$72], [%255, %$74], [%361, %$79] ; # X
  %378 = phi i64 [%223, %$70], [%236, %$72], [%256, %$74], [%362, %$79] ; # Y
  %379 = phi i64 [%224, %$70], [%237, %$72], [%257, %$74], [%372, %$79] ; # A
  %380 = phi i64 [%225, %$70], [%238, %$72], [%258, %$74], [%364, %$79] ; # B
  %381 = phi i1 [0, %$70], [%245, %$72], [0, %$74], [%365, %$79] ; # ->
; # (until (== A X) (set A (& (val A) -2)) (shift A))
  br label %$92
$92:
  %382 = phi i64 [%377, %$69], [%387, %$93] ; # X
  %383 = phi i64 [%378, %$69], [%388, %$93] ; # Y
  %384 = phi i64 [%379, %$69], [%397, %$93] ; # A
  %385 = phi i64 [%380, %$69], [%390, %$93] ; # B
; # (== A X)
  %386 = icmp eq i64 %384, %382
  br i1 %386, label %$94, label %$93
$93:
  %387 = phi i64 [%382, %$92] ; # X
  %388 = phi i64 [%383, %$92] ; # Y
  %389 = phi i64 [%384, %$92] ; # A
  %390 = phi i64 [%385, %$92] ; # B
; # (set A (& (val A) -2))
; # (val A)
  %391 = inttoptr i64 %389 to i64*
  %392 = load i64, i64* %391
; # (& (val A) -2)
  %393 = and i64 %392, -2
  %394 = inttoptr i64 %389 to i64*
  store i64 %393, i64* %394
; # (shift A)
  %395 = inttoptr i64 %389 to i64*
  %396 = getelementptr i64, i64* %395, i32 1
  %397 = load i64, i64* %396
  br label %$92
$94:
  %398 = phi i64 [%382, %$92] ; # X
  %399 = phi i64 [%383, %$92] ; # Y
  %400 = phi i64 [%384, %$92] ; # A
  %401 = phi i64 [%385, %$92] ; # B
  br label %$2
$2:
  %402 = phi i64 [%3, %$4], [%9, %$6], [%76, %$11], [%197, %$28], [%204, %$64], [%398, %$94] ; # X
  %403 = phi i64 [%4, %$4], [%10, %$6], [%77, %$11], [%198, %$28], [%205, %$64], [%399, %$94] ; # Y
  %404 = phi i1 [1, %$4], [0, %$6], [%78, %$11], [%199, %$28], [0, %$64], [%381, %$94] ; # ->
  ret i1 %404
}

define i64 @compare(i64, i64) align 8 {
$1:
; # (cond ((== X Y) 0) ((nil? X) -1) ((t? X) 1) ((num? X) (cond ((num...
; # (== X Y)
  %2 = icmp eq i64 %0, %1
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
  %4 = phi i64 [%1, %$1] ; # Y
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
  %6 = phi i64 [%1, %$1] ; # Y
; # (nil? X)
  %7 = icmp eq i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$3] ; # X
  %9 = phi i64 [%6, %$3] ; # Y
  br label %$2
$5:
  %10 = phi i64 [%5, %$3] ; # X
  %11 = phi i64 [%6, %$3] ; # Y
; # (t? X)
  %12 = icmp eq i64 %10, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %12, label %$8, label %$7
$8:
  %13 = phi i64 [%10, %$5] ; # X
  %14 = phi i64 [%11, %$5] ; # Y
  br label %$2
$7:
  %15 = phi i64 [%10, %$5] ; # X
  %16 = phi i64 [%11, %$5] ; # Y
; # (num? X)
  %17 = and i64 %15, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$9
$10:
  %19 = phi i64 [%15, %$7] ; # X
  %20 = phi i64 [%16, %$7] ; # Y
; # (cond ((num? Y) (cmpNum X Y)) ((nil? Y) 1) (T -1))
; # (num? Y)
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$13, label %$12
$13:
  %23 = phi i64 [%19, %$10] ; # X
  %24 = phi i64 [%20, %$10] ; # Y
; # (cmpNum X Y)
  %25 = call i64 @cmpNum(i64 %23, i64 %24)
  br label %$11
$12:
  %26 = phi i64 [%19, %$10] ; # X
  %27 = phi i64 [%20, %$10] ; # Y
; # (nil? Y)
  %28 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %28, label %$15, label %$14
$15:
  %29 = phi i64 [%26, %$12] ; # X
  %30 = phi i64 [%27, %$12] ; # Y
  br label %$11
$14:
  %31 = phi i64 [%26, %$12] ; # X
  %32 = phi i64 [%27, %$12] ; # Y
  br label %$11
$11:
  %33 = phi i64 [%23, %$13], [%29, %$15], [%31, %$14] ; # X
  %34 = phi i64 [%24, %$13], [%30, %$15], [%32, %$14] ; # Y
  %35 = phi i64 [%25, %$13], [1, %$15], [-1, %$14] ; # ->
  br label %$2
$9:
  %36 = phi i64 [%15, %$7] ; # X
  %37 = phi i64 [%16, %$7] ; # Y
; # (sym? X)
  %38 = and i64 %36, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$17, label %$16
$17:
  %40 = phi i64 [%36, %$9] ; # X
  %41 = phi i64 [%37, %$9] ; # Y
; # (cond ((or (num? Y) (nil? Y)) 1) ((or (pair Y) (t? Y)) -1) (T (le...
; # (or (num? Y) (nil? Y))
; # (num? Y)
  %42 = and i64 %41, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$19, label %$20
$20:
  %44 = phi i64 [%40, %$17] ; # X
  %45 = phi i64 [%41, %$17] ; # Y
; # (nil? Y)
  %46 = icmp eq i64 %45, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$19
$19:
  %47 = phi i64 [%40, %$17], [%44, %$20] ; # X
  %48 = phi i64 [%41, %$17], [%45, %$20] ; # Y
  %49 = phi i1 [1, %$17], [%46, %$20] ; # ->
  br i1 %49, label %$22, label %$21
$22:
  %50 = phi i64 [%47, %$19] ; # X
  %51 = phi i64 [%48, %$19] ; # Y
  br label %$18
$21:
  %52 = phi i64 [%47, %$19] ; # X
  %53 = phi i64 [%48, %$19] ; # Y
; # (or (pair Y) (t? Y))
; # (pair Y)
  %54 = and i64 %53, 15
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %$23, label %$24
$24:
  %56 = phi i64 [%52, %$21] ; # X
  %57 = phi i64 [%53, %$21] ; # Y
; # (t? Y)
  %58 = icmp eq i64 %57, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br label %$23
$23:
  %59 = phi i64 [%52, %$21], [%56, %$24] ; # X
  %60 = phi i64 [%53, %$21], [%57, %$24] ; # Y
  %61 = phi i1 [1, %$21], [%58, %$24] ; # ->
  br i1 %61, label %$26, label %$25
$26:
  %62 = phi i64 [%59, %$23] ; # X
  %63 = phi i64 [%60, %$23] ; # Y
  br label %$18
$25:
  %64 = phi i64 [%59, %$23] ; # X
  %65 = phi i64 [%60, %$23] ; # Y
; # (let (NmX (name (& (val (tail X)) -9)) NmY (name (& (val (tail Y)...
; # (tail X)
  %66 = add i64 %64, -8
; # (val (tail X))
  %67 = inttoptr i64 %66 to i64*
  %68 = load i64, i64* %67
; # (& (val (tail X)) -9)
  %69 = and i64 %68, -9
; # (name (& (val (tail X)) -9))
  br label %$27
$27:
  %70 = phi i64 [%69, %$25], [%76, %$28] ; # Tail
  %71 = and i64 %70, 6
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$29, label %$28
$28:
  %73 = phi i64 [%70, %$27] ; # Tail
  %74 = inttoptr i64 %73 to i64*
  %75 = getelementptr i64, i64* %74, i32 1
  %76 = load i64, i64* %75
  br label %$27
$29:
  %77 = phi i64 [%70, %$27] ; # Tail
; # (tail Y)
  %78 = add i64 %65, -8
; # (val (tail Y))
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
; # (& (val (tail Y)) -9)
  %81 = and i64 %80, -9
; # (name (& (val (tail Y)) -9))
  br label %$30
$30:
  %82 = phi i64 [%81, %$29], [%88, %$31] ; # Tail
  %83 = and i64 %82, 6
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$32, label %$31
$31:
  %85 = phi i64 [%82, %$30] ; # Tail
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
  br label %$30
$32:
  %89 = phi i64 [%82, %$30] ; # Tail
; # (cond ((== ZERO NmX) (nond ((== ZERO NmY) -1) ((== X Y) 0) ((> X ...
; # (== ZERO NmX)
  %90 = icmp eq i64 2, %77
  br i1 %90, label %$35, label %$34
$35:
  %91 = phi i64 [%64, %$32] ; # X
  %92 = phi i64 [%65, %$32] ; # Y
  %93 = phi i64 [%77, %$32] ; # NmX
  %94 = phi i64 [%89, %$32] ; # NmY
; # (nond ((== ZERO NmY) -1) ((== X Y) 0) ((> X Y) 1) (NIL -1))
; # (== ZERO NmY)
  %95 = icmp eq i64 2, %94
  br i1 %95, label %$37, label %$38
$38:
  %96 = phi i64 [%91, %$35] ; # X
  %97 = phi i64 [%92, %$35] ; # Y
  %98 = phi i64 [%93, %$35] ; # NmX
  %99 = phi i64 [%94, %$35] ; # NmY
  br label %$36
$37:
  %100 = phi i64 [%91, %$35] ; # X
  %101 = phi i64 [%92, %$35] ; # Y
  %102 = phi i64 [%93, %$35] ; # NmX
  %103 = phi i64 [%94, %$35] ; # NmY
; # (== X Y)
  %104 = icmp eq i64 %100, %101
  br i1 %104, label %$39, label %$40
$40:
  %105 = phi i64 [%100, %$37] ; # X
  %106 = phi i64 [%101, %$37] ; # Y
  %107 = phi i64 [%102, %$37] ; # NmX
  %108 = phi i64 [%103, %$37] ; # NmY
  br label %$36
$39:
  %109 = phi i64 [%100, %$37] ; # X
  %110 = phi i64 [%101, %$37] ; # Y
  %111 = phi i64 [%102, %$37] ; # NmX
  %112 = phi i64 [%103, %$37] ; # NmY
; # (> X Y)
  %113 = icmp ugt i64 %109, %110
  br i1 %113, label %$41, label %$42
$42:
  %114 = phi i64 [%109, %$39] ; # X
  %115 = phi i64 [%110, %$39] ; # Y
  %116 = phi i64 [%111, %$39] ; # NmX
  %117 = phi i64 [%112, %$39] ; # NmY
  br label %$36
$41:
  %118 = phi i64 [%109, %$39] ; # X
  %119 = phi i64 [%110, %$39] ; # Y
  %120 = phi i64 [%111, %$39] ; # NmX
  %121 = phi i64 [%112, %$39] ; # NmY
  br label %$36
$36:
  %122 = phi i64 [%96, %$38], [%105, %$40], [%114, %$42], [%118, %$41] ; # X
  %123 = phi i64 [%97, %$38], [%106, %$40], [%115, %$42], [%119, %$41] ; # Y
  %124 = phi i64 [%98, %$38], [%107, %$40], [%116, %$42], [%120, %$41] ; # NmX
  %125 = phi i64 [%99, %$38], [%108, %$40], [%117, %$42], [%121, %$41] ; # NmY
  %126 = phi i64 [-1, %$38], [0, %$40], [1, %$42], [-1, %$41] ; # ->
  br label %$33
$34:
  %127 = phi i64 [%64, %$32] ; # X
  %128 = phi i64 [%65, %$32] ; # Y
  %129 = phi i64 [%77, %$32] ; # NmX
  %130 = phi i64 [%89, %$32] ; # NmY
; # (== ZERO NmY)
  %131 = icmp eq i64 2, %130
  br i1 %131, label %$44, label %$43
$44:
  %132 = phi i64 [%127, %$34] ; # X
  %133 = phi i64 [%128, %$34] ; # Y
  %134 = phi i64 [%129, %$34] ; # NmX
  %135 = phi i64 [%130, %$34] ; # NmY
  br label %$33
$43:
  %136 = phi i64 [%127, %$34] ; # X
  %137 = phi i64 [%128, %$34] ; # Y
  %138 = phi i64 [%129, %$34] ; # NmX
  %139 = phi i64 [%130, %$34] ; # NmY
; # (loop (let (A (if (cnt? NmX) (prog1 (shr (shl (name NmX) 2) 6) (s...
  br label %$45
$45:
  %140 = phi i64 [%136, %$43], [%339, %$65] ; # X
  %141 = phi i64 [%137, %$43], [%340, %$65] ; # Y
  %142 = phi i64 [%138, %$43], [%341, %$65] ; # NmX
  %143 = phi i64 [%139, %$43], [%342, %$65] ; # NmY
; # (let (A (if (cnt? NmX) (prog1 (shr (shl (name NmX) 2) 6) (setq Nm...
; # (if (cnt? NmX) (prog1 (shr (shl (name NmX) 2) 6) (setq NmX 0)) (p...
; # (cnt? NmX)
  %144 = and i64 %142, 2
  %145 = icmp ne i64 %144, 0
  br i1 %145, label %$46, label %$47
$46:
  %146 = phi i64 [%140, %$45] ; # X
  %147 = phi i64 [%141, %$45] ; # Y
  %148 = phi i64 [%142, %$45] ; # NmX
  %149 = phi i64 [%143, %$45] ; # NmY
; # (prog1 (shr (shl (name NmX) 2) 6) (setq NmX 0))
; # (name NmX)
  br label %$49
$49:
  %150 = phi i64 [%148, %$46], [%156, %$50] ; # Tail
  %151 = and i64 %150, 6
  %152 = icmp ne i64 %151, 0
  br i1 %152, label %$51, label %$50
$50:
  %153 = phi i64 [%150, %$49] ; # Tail
  %154 = inttoptr i64 %153 to i64*
  %155 = getelementptr i64, i64* %154, i32 1
  %156 = load i64, i64* %155
  br label %$49
$51:
  %157 = phi i64 [%150, %$49] ; # Tail
; # (shl (name NmX) 2)
  %158 = shl i64 %157, 2
; # (shr (shl (name NmX) 2) 6)
  %159 = lshr i64 %158, 6
  br label %$48
$47:
  %160 = phi i64 [%140, %$45] ; # X
  %161 = phi i64 [%141, %$45] ; # Y
  %162 = phi i64 [%142, %$45] ; # NmX
  %163 = phi i64 [%143, %$45] ; # NmY
; # (prog1 (val (dig NmX)) (setq NmX (val (big NmX))))
; # (dig NmX)
  %164 = add i64 %162, -4
; # (val (dig NmX))
  %165 = inttoptr i64 %164 to i64*
  %166 = load i64, i64* %165
; # (big NmX)
  %167 = add i64 %162, 4
; # (val (big NmX))
  %168 = inttoptr i64 %167 to i64*
  %169 = load i64, i64* %168
  br label %$48
$48:
  %170 = phi i64 [%146, %$51], [%160, %$47] ; # X
  %171 = phi i64 [%147, %$51], [%161, %$47] ; # Y
  %172 = phi i64 [0, %$51], [%169, %$47] ; # NmX
  %173 = phi i64 [%149, %$51], [%163, %$47] ; # NmY
  %174 = phi i64 [%159, %$51], [%166, %$47] ; # ->
; # (if (cnt? NmY) (prog1 (shr (shl (name NmY) 2) 6) (setq NmY 0)) (p...
; # (cnt? NmY)
  %175 = and i64 %173, 2
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$52, label %$53
$52:
  %177 = phi i64 [%170, %$48] ; # X
  %178 = phi i64 [%171, %$48] ; # Y
  %179 = phi i64 [%172, %$48] ; # NmX
  %180 = phi i64 [%173, %$48] ; # NmY
  %181 = phi i64 [%174, %$48] ; # A
; # (prog1 (shr (shl (name NmY) 2) 6) (setq NmY 0))
; # (name NmY)
  br label %$55
$55:
  %182 = phi i64 [%180, %$52], [%188, %$56] ; # Tail
  %183 = and i64 %182, 6
  %184 = icmp ne i64 %183, 0
  br i1 %184, label %$57, label %$56
$56:
  %185 = phi i64 [%182, %$55] ; # Tail
  %186 = inttoptr i64 %185 to i64*
  %187 = getelementptr i64, i64* %186, i32 1
  %188 = load i64, i64* %187
  br label %$55
$57:
  %189 = phi i64 [%182, %$55] ; # Tail
; # (shl (name NmY) 2)
  %190 = shl i64 %189, 2
; # (shr (shl (name NmY) 2) 6)
  %191 = lshr i64 %190, 6
  br label %$54
$53:
  %192 = phi i64 [%170, %$48] ; # X
  %193 = phi i64 [%171, %$48] ; # Y
  %194 = phi i64 [%172, %$48] ; # NmX
  %195 = phi i64 [%173, %$48] ; # NmY
  %196 = phi i64 [%174, %$48] ; # A
; # (prog1 (val (dig NmY)) (setq NmY (val (big NmY))))
; # (dig NmY)
  %197 = add i64 %195, -4
; # (val (dig NmY))
  %198 = inttoptr i64 %197 to i64*
  %199 = load i64, i64* %198
; # (big NmY)
  %200 = add i64 %195, 4
; # (val (big NmY))
  %201 = inttoptr i64 %200 to i64*
  %202 = load i64, i64* %201
  br label %$54
$54:
  %203 = phi i64 [%177, %$57], [%192, %$53] ; # X
  %204 = phi i64 [%178, %$57], [%193, %$53] ; # Y
  %205 = phi i64 [%179, %$57], [%194, %$53] ; # NmX
  %206 = phi i64 [0, %$57], [%202, %$53] ; # NmY
  %207 = phi i64 [%181, %$57], [%196, %$53] ; # A
  %208 = phi i64 [%191, %$57], [%199, %$53] ; # ->
; # (loop (when (- (& A 255) (& B 255)) (ret (if (gt0 @) 1 -1))) (? (...
  br label %$58
$58:
  %209 = phi i64 [%203, %$54], [%333, %$77] ; # X
  %210 = phi i64 [%204, %$54], [%334, %$77] ; # Y
  %211 = phi i64 [%205, %$54], [%335, %$77] ; # NmX
  %212 = phi i64 [%206, %$54], [%336, %$77] ; # NmY
  %213 = phi i64 [%207, %$54], [%337, %$77] ; # A
  %214 = phi i64 [%208, %$54], [%338, %$77] ; # B
; # (when (- (& A 255) (& B 255)) (ret (if (gt0 @) 1 -1)))
; # (& A 255)
  %215 = and i64 %213, 255
; # (& B 255)
  %216 = and i64 %214, 255
; # (- (& A 255) (& B 255))
  %217 = sub i64 %215, %216
  %218 = icmp ne i64 %217, 0
  br i1 %218, label %$59, label %$60
$59:
  %219 = phi i64 [%209, %$58] ; # X
  %220 = phi i64 [%210, %$58] ; # Y
  %221 = phi i64 [%211, %$58] ; # NmX
  %222 = phi i64 [%212, %$58] ; # NmY
  %223 = phi i64 [%213, %$58] ; # A
  %224 = phi i64 [%214, %$58] ; # B
; # (if (gt0 @) 1 -1)
; # (gt0 @)
  %225 = icmp sgt i64 %217, 0
  br i1 %225, label %$61, label %$62
$61:
  %226 = phi i64 [%219, %$59] ; # X
  %227 = phi i64 [%220, %$59] ; # Y
  %228 = phi i64 [%221, %$59] ; # NmX
  %229 = phi i64 [%222, %$59] ; # NmY
  %230 = phi i64 [%223, %$59] ; # A
  %231 = phi i64 [%224, %$59] ; # B
  br label %$63
$62:
  %232 = phi i64 [%219, %$59] ; # X
  %233 = phi i64 [%220, %$59] ; # Y
  %234 = phi i64 [%221, %$59] ; # NmX
  %235 = phi i64 [%222, %$59] ; # NmY
  %236 = phi i64 [%223, %$59] ; # A
  %237 = phi i64 [%224, %$59] ; # B
  br label %$63
$63:
  %238 = phi i64 [%226, %$61], [%232, %$62] ; # X
  %239 = phi i64 [%227, %$61], [%233, %$62] ; # Y
  %240 = phi i64 [%228, %$61], [%234, %$62] ; # NmX
  %241 = phi i64 [%229, %$61], [%235, %$62] ; # NmY
  %242 = phi i64 [%230, %$61], [%236, %$62] ; # A
  %243 = phi i64 [%231, %$61], [%237, %$62] ; # B
  %244 = phi i64 [1, %$61], [-1, %$62] ; # ->
; # (ret (if (gt0 @) 1 -1))
  ret i64 %244
$60:
  %245 = phi i64 [%209, %$58] ; # X
  %246 = phi i64 [%210, %$58] ; # Y
  %247 = phi i64 [%211, %$58] ; # NmX
  %248 = phi i64 [%212, %$58] ; # NmY
  %249 = phi i64 [%213, %$58] ; # A
  %250 = phi i64 [%214, %$58] ; # B
; # (? (=0 (setq A (shr A 8))) (when (setq B (shr B 8)) (ret -1)) (un...
; # (shr A 8)
  %251 = lshr i64 %249, 8
; # (=0 (setq A (shr A 8)))
  %252 = icmp eq i64 %251, 0
  br i1 %252, label %$66, label %$64
$66:
  %253 = phi i64 [%245, %$60] ; # X
  %254 = phi i64 [%246, %$60] ; # Y
  %255 = phi i64 [%247, %$60] ; # NmX
  %256 = phi i64 [%248, %$60] ; # NmY
  %257 = phi i64 [%251, %$60] ; # A
  %258 = phi i64 [%250, %$60] ; # B
; # (when (setq B (shr B 8)) (ret -1))
; # (shr B 8)
  %259 = lshr i64 %258, 8
  %260 = icmp ne i64 %259, 0
  br i1 %260, label %$67, label %$68
$67:
  %261 = phi i64 [%253, %$66] ; # X
  %262 = phi i64 [%254, %$66] ; # Y
  %263 = phi i64 [%255, %$66] ; # NmX
  %264 = phi i64 [%256, %$66] ; # NmY
  %265 = phi i64 [%257, %$66] ; # A
  %266 = phi i64 [%259, %$66] ; # B
; # (ret -1)
  ret i64 -1
$68:
  %267 = phi i64 [%253, %$66] ; # X
  %268 = phi i64 [%254, %$66] ; # Y
  %269 = phi i64 [%255, %$66] ; # NmX
  %270 = phi i64 [%256, %$66] ; # NmY
  %271 = phi i64 [%257, %$66] ; # A
  %272 = phi i64 [%259, %$66] ; # B
; # (unless NmX (ret (if NmY -1 0)))
  %273 = icmp ne i64 %269, 0
  br i1 %273, label %$70, label %$69
$69:
  %274 = phi i64 [%267, %$68] ; # X
  %275 = phi i64 [%268, %$68] ; # Y
  %276 = phi i64 [%269, %$68] ; # NmX
  %277 = phi i64 [%270, %$68] ; # NmY
  %278 = phi i64 [%271, %$68] ; # A
  %279 = phi i64 [%272, %$68] ; # B
; # (if NmY -1 0)
  %280 = icmp ne i64 %277, 0
  br i1 %280, label %$71, label %$72
$71:
  %281 = phi i64 [%274, %$69] ; # X
  %282 = phi i64 [%275, %$69] ; # Y
  %283 = phi i64 [%276, %$69] ; # NmX
  %284 = phi i64 [%277, %$69] ; # NmY
  %285 = phi i64 [%278, %$69] ; # A
  %286 = phi i64 [%279, %$69] ; # B
  br label %$73
$72:
  %287 = phi i64 [%274, %$69] ; # X
  %288 = phi i64 [%275, %$69] ; # Y
  %289 = phi i64 [%276, %$69] ; # NmX
  %290 = phi i64 [%277, %$69] ; # NmY
  %291 = phi i64 [%278, %$69] ; # A
  %292 = phi i64 [%279, %$69] ; # B
  br label %$73
$73:
  %293 = phi i64 [%281, %$71], [%287, %$72] ; # X
  %294 = phi i64 [%282, %$71], [%288, %$72] ; # Y
  %295 = phi i64 [%283, %$71], [%289, %$72] ; # NmX
  %296 = phi i64 [%284, %$71], [%290, %$72] ; # NmY
  %297 = phi i64 [%285, %$71], [%291, %$72] ; # A
  %298 = phi i64 [%286, %$71], [%292, %$72] ; # B
  %299 = phi i64 [-1, %$71], [0, %$72] ; # ->
; # (ret (if NmY -1 0))
  ret i64 %299
$70:
  %300 = phi i64 [%267, %$68] ; # X
  %301 = phi i64 [%268, %$68] ; # Y
  %302 = phi i64 [%269, %$68] ; # NmX
  %303 = phi i64 [%270, %$68] ; # NmY
  %304 = phi i64 [%271, %$68] ; # A
  %305 = phi i64 [%272, %$68] ; # B
; # (unless NmY (ret 1))
  %306 = icmp ne i64 %303, 0
  br i1 %306, label %$75, label %$74
$74:
  %307 = phi i64 [%300, %$70] ; # X
  %308 = phi i64 [%301, %$70] ; # Y
  %309 = phi i64 [%302, %$70] ; # NmX
  %310 = phi i64 [%303, %$70] ; # NmY
  %311 = phi i64 [%304, %$70] ; # A
  %312 = phi i64 [%305, %$70] ; # B
; # (ret 1)
  ret i64 1
$75:
  %313 = phi i64 [%300, %$70] ; # X
  %314 = phi i64 [%301, %$70] ; # Y
  %315 = phi i64 [%302, %$70] ; # NmX
  %316 = phi i64 [%303, %$70] ; # NmY
  %317 = phi i64 [%304, %$70] ; # A
  %318 = phi i64 [%305, %$70] ; # B
  br label %$65
$64:
  %319 = phi i64 [%245, %$60] ; # X
  %320 = phi i64 [%246, %$60] ; # Y
  %321 = phi i64 [%247, %$60] ; # NmX
  %322 = phi i64 [%248, %$60] ; # NmY
  %323 = phi i64 [%251, %$60] ; # A
  %324 = phi i64 [%250, %$60] ; # B
; # (unless (setq B (shr B 8)) (ret 1))
; # (shr B 8)
  %325 = lshr i64 %324, 8
  %326 = icmp ne i64 %325, 0
  br i1 %326, label %$77, label %$76
$76:
  %327 = phi i64 [%319, %$64] ; # X
  %328 = phi i64 [%320, %$64] ; # Y
  %329 = phi i64 [%321, %$64] ; # NmX
  %330 = phi i64 [%322, %$64] ; # NmY
  %331 = phi i64 [%323, %$64] ; # A
  %332 = phi i64 [%325, %$64] ; # B
; # (ret 1)
  ret i64 1
$77:
  %333 = phi i64 [%319, %$64] ; # X
  %334 = phi i64 [%320, %$64] ; # Y
  %335 = phi i64 [%321, %$64] ; # NmX
  %336 = phi i64 [%322, %$64] ; # NmY
  %337 = phi i64 [%323, %$64] ; # A
  %338 = phi i64 [%325, %$64] ; # B
  br label %$58
$65:
  %339 = phi i64 [%313, %$75] ; # X
  %340 = phi i64 [%314, %$75] ; # Y
  %341 = phi i64 [%315, %$75] ; # NmX
  %342 = phi i64 [%316, %$75] ; # NmY
  %343 = phi i64 [%317, %$75] ; # A
  %344 = phi i64 [%318, %$75] ; # B
  br label %$45
$33:
  %345 = phi i64 [%122, %$36], [%132, %$44] ; # X
  %346 = phi i64 [%123, %$36], [%133, %$44] ; # Y
  %347 = phi i64 [%124, %$36], [%134, %$44] ; # NmX
  %348 = phi i64 [%125, %$36], [%135, %$44] ; # NmY
  %349 = phi i64 [%126, %$36], [1, %$44] ; # ->
  br label %$18
$18:
  %350 = phi i64 [%50, %$22], [%62, %$26], [%345, %$33] ; # X
  %351 = phi i64 [%51, %$22], [%63, %$26], [%346, %$33] ; # Y
  %352 = phi i64 [1, %$22], [-1, %$26], [%349, %$33] ; # ->
  br label %$2
$16:
  %353 = phi i64 [%36, %$9] ; # X
  %354 = phi i64 [%37, %$9] ; # Y
; # (atom Y)
  %355 = and i64 %354, 15
  %356 = icmp ne i64 %355, 0
  br i1 %356, label %$79, label %$78
$79:
  %357 = phi i64 [%353, %$16] ; # X
  %358 = phi i64 [%354, %$16] ; # Y
; # (if (t? Y) -1 1)
; # (t? Y)
  %359 = icmp eq i64 %358, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %359, label %$80, label %$81
$80:
  %360 = phi i64 [%357, %$79] ; # X
  %361 = phi i64 [%358, %$79] ; # Y
  br label %$82
$81:
  %362 = phi i64 [%357, %$79] ; # X
  %363 = phi i64 [%358, %$79] ; # Y
  br label %$82
$82:
  %364 = phi i64 [%360, %$80], [%362, %$81] ; # X
  %365 = phi i64 [%361, %$80], [%363, %$81] ; # Y
  %366 = phi i64 [-1, %$80], [1, %$81] ; # ->
  br label %$2
$78:
  %367 = phi i64 [%353, %$16] ; # X
  %368 = phi i64 [%354, %$16] ; # Y
; # (stkChk 0)
  %369 = load i8*, i8** @$StkLimit
  %370 = call i8* @llvm.stacksave()
  %371 = icmp ugt i8* %369, %370
  br i1 %371, label %$83, label %$84
$83:
  call void @stkErr(i64 0)
  unreachable
$84:
; # (let (A X B Y) (loop (? (compare (car X) (car Y)) @) (? (atom (sh...
; # (loop (? (compare (car X) (car Y)) @) (? (atom (shift X)) (compar...
  br label %$85
$85:
  %372 = phi i64 [%367, %$84], [%423, %$101] ; # X
  %373 = phi i64 [%368, %$84], [%424, %$101] ; # Y
; # (? (compare (car X) (car Y)) @)
; # (car X)
  %374 = inttoptr i64 %372 to i64*
  %375 = load i64, i64* %374
; # (car Y)
  %376 = inttoptr i64 %373 to i64*
  %377 = load i64, i64* %376
; # (compare (car X) (car Y))
  %378 = call i64 @compare(i64 %375, i64 %377)
  %379 = icmp ne i64 %378, 0
  br i1 %379, label %$88, label %$86
$88:
  %380 = phi i64 [%372, %$85] ; # X
  %381 = phi i64 [%373, %$85] ; # Y
  br label %$87
$86:
  %382 = phi i64 [%372, %$85] ; # X
  %383 = phi i64 [%373, %$85] ; # Y
; # (? (atom (shift X)) (compare X (cdr Y)))
; # (shift X)
  %384 = inttoptr i64 %382 to i64*
  %385 = getelementptr i64, i64* %384, i32 1
  %386 = load i64, i64* %385
; # (atom (shift X))
  %387 = and i64 %386, 15
  %388 = icmp ne i64 %387, 0
  br i1 %388, label %$90, label %$89
$90:
  %389 = phi i64 [%386, %$86] ; # X
  %390 = phi i64 [%383, %$86] ; # Y
; # (cdr Y)
  %391 = inttoptr i64 %390 to i64*
  %392 = getelementptr i64, i64* %391, i32 1
  %393 = load i64, i64* %392
; # (compare X (cdr Y))
  %394 = call i64 @compare(i64 %389, i64 %393)
  br label %$87
$89:
  %395 = phi i64 [%386, %$86] ; # X
  %396 = phi i64 [%383, %$86] ; # Y
; # (? (atom (shift Y)) (if (t? Y) -1 1))
; # (shift Y)
  %397 = inttoptr i64 %396 to i64*
  %398 = getelementptr i64, i64* %397, i32 1
  %399 = load i64, i64* %398
; # (atom (shift Y))
  %400 = and i64 %399, 15
  %401 = icmp ne i64 %400, 0
  br i1 %401, label %$92, label %$91
$92:
  %402 = phi i64 [%395, %$89] ; # X
  %403 = phi i64 [%399, %$89] ; # Y
; # (if (t? Y) -1 1)
; # (t? Y)
  %404 = icmp eq i64 %403, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %404, label %$93, label %$94
$93:
  %405 = phi i64 [%402, %$92] ; # X
  %406 = phi i64 [%403, %$92] ; # Y
  br label %$95
$94:
  %407 = phi i64 [%402, %$92] ; # X
  %408 = phi i64 [%403, %$92] ; # Y
  br label %$95
$95:
  %409 = phi i64 [%405, %$93], [%407, %$94] ; # X
  %410 = phi i64 [%406, %$93], [%408, %$94] ; # Y
  %411 = phi i64 [-1, %$93], [1, %$94] ; # ->
  br label %$87
$91:
  %412 = phi i64 [%395, %$89] ; # X
  %413 = phi i64 [%399, %$89] ; # Y
; # (? (and (== X A) (== Y B)) 0)
; # (and (== X A) (== Y B))
; # (== X A)
  %414 = icmp eq i64 %412, %367
  br i1 %414, label %$97, label %$96
$97:
  %415 = phi i64 [%412, %$91] ; # X
  %416 = phi i64 [%413, %$91] ; # Y
; # (== Y B)
  %417 = icmp eq i64 %416, %368
  br label %$96
$96:
  %418 = phi i64 [%412, %$91], [%415, %$97] ; # X
  %419 = phi i64 [%413, %$91], [%416, %$97] ; # Y
  %420 = phi i1 [0, %$91], [%417, %$97] ; # ->
  br i1 %420, label %$99, label %$98
$99:
  %421 = phi i64 [%418, %$96] ; # X
  %422 = phi i64 [%419, %$96] ; # Y
  br label %$87
$98:
  %423 = phi i64 [%418, %$96] ; # X
  %424 = phi i64 [%419, %$96] ; # Y
; # (sigChk 0)
  %425 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %426 = icmp ne i32 %425, 0
  br i1 %426, label %$100, label %$101
$100:
  call void @sighandler(i64 0)
  br label %$101
$101:
  br label %$85
$87:
  %427 = phi i64 [%380, %$88], [%389, %$90], [%409, %$95], [%421, %$99] ; # X
  %428 = phi i64 [%381, %$88], [%390, %$90], [%410, %$95], [%422, %$99] ; # Y
  %429 = phi i64 [%378, %$88], [%394, %$90], [%411, %$95], [0, %$99] ; # ->
  br label %$2
$2:
  %430 = phi i64 [%3, %$4], [%8, %$6], [%13, %$8], [%33, %$11], [%350, %$18], [%364, %$82], [%427, %$87] ; # X
  %431 = phi i64 [%4, %$4], [%9, %$6], [%14, %$8], [%34, %$11], [%351, %$18], [%365, %$82], [%428, %$87] ; # Y
  %432 = phi i64 [0, %$4], [-1, %$6], [1, %$8], [%35, %$11], [%352, %$18], [%366, %$82], [%429, %$87] ; # ->
  ret i64 %432
}

define void @undefined(i64, i64) align 8 {
$1:
; # (err Exe Fun ($ "Undefined") null)
  call void @err(i64 %1, i64 %0, i8* bitcast ([10 x i8]* @$27 to i8*), i8* null)
  unreachable
}

define i64 @evExpr(i64, i64) align 8 {
$1:
; # (stkChk Exe)
  %2 = load i8*, i8** @$StkLimit
  %3 = call i8* @llvm.stacksave()
  %4 = icmp ugt i8* %2, %3
  br i1 %4, label %$2, label %$3
$2:
  call void @stkErr(i64 %0)
  unreachable
$3:
; # (let (X (cdr Lst) Y (car Exe) P (set $Bind (push (val $At) $At (v...
; # (cdr Lst)
  %5 = inttoptr i64 %1 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car Exe)
  %8 = inttoptr i64 %0 to i64*
  %9 = load i64, i64* %8
; # (set $Bind (push (val $At) $At (val $Bind) Lst))
; # (val $At)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %11 = load i64, i64* %10
; # (val $Bind)
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %13 = load i64, i64* %12
; # (push (val $At) $At (val $Bind) Lst)
  %14 = alloca i64, i64 4, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %11, i64* %16
  %17 = add i64 %15, 8
  %18 = inttoptr i64 %17 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), i64* %18
  %19 = add i64 %15, 16
  %20 = inttoptr i64 %19 to i64*
  store i64 %13, i64* %20
  %21 = add i64 %15, 24
  %22 = inttoptr i64 %21 to i64*
  store i64 %1, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %15, i64* %23
; # (while (pair Y) (let (V (eval (++ X)) Z (++ Y)) (if (atom Z) (set...
  br label %$4
$4:
  %24 = phi i64 [%7, %$3], [%154, %$14] ; # X
  %25 = phi i64 [%9, %$3], [%155, %$14] ; # Y
  %26 = phi i64 [%15, %$3], [%156, %$14] ; # P
; # (pair Y)
  %27 = and i64 %25, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$5, label %$6
$5:
  %29 = phi i64 [%24, %$4] ; # X
  %30 = phi i64 [%25, %$4] ; # Y
  %31 = phi i64 [%26, %$4] ; # P
; # (let (V (eval (++ X)) Z (++ Y)) (if (atom Z) (set $Bind (setq P (...
; # (++ X)
  %32 = inttoptr i64 %29 to i64*
  %33 = load i64, i64* %32
  %34 = getelementptr i64, i64* %32, i32 1
  %35 = load i64, i64* %34
; # (eval (++ X))
  %36 = and i64 %33, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$9, label %$8
$9:
  br label %$7
$8:
  %38 = and i64 %33, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$11, label %$10
$11:
  %40 = inttoptr i64 %33 to i64*
  %41 = load i64, i64* %40
  br label %$7
$10:
  %42 = call i64 @evList(i64 %33)
  br label %$7
$7:
  %43 = phi i64 [%33, %$9], [%41, %$11], [%42, %$10] ; # ->
; # (++ Y)
  %44 = inttoptr i64 %30 to i64*
  %45 = load i64, i64* %44
  %46 = getelementptr i64, i64* %44, i32 1
  %47 = load i64, i64* %46
; # (if (atom Z) (set $Bind (setq P (push V (needChkVar Exe Z) P))) (...
; # (atom Z)
  %48 = and i64 %45, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$12, label %$13
$12:
  %50 = phi i64 [%35, %$7] ; # X
  %51 = phi i64 [%47, %$7] ; # Y
  %52 = phi i64 [%31, %$7] ; # P
  %53 = phi i64 [%43, %$7] ; # V
  %54 = phi i64 [%45, %$7] ; # Z
; # (set $Bind (setq P (push V (needChkVar Exe Z) P)))
; # (needChkVar Exe Z)
  %55 = and i64 %54, 6
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %54)
  unreachable
$16:
  %57 = icmp uge i64 %54, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %57, label %$18, label %$17
$18:
  %58 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %54
  br label %$17
$17:
  %59 = phi i1 [0, %$16], [%58, %$18] ; # ->
  br i1 %59, label %$19, label %$20
$19:
  call void @protErr(i64 %0, i64 %54)
  unreachable
$20:
; # (push V (needChkVar Exe Z) P)
  %60 = alloca i64, i64 3, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = inttoptr i64 %61 to i64*
  store i64 %53, i64* %62
  %63 = add i64 %61, 8
  %64 = inttoptr i64 %63 to i64*
  store i64 %54, i64* %64
  %65 = add i64 %61, 16
  %66 = inttoptr i64 %65 to i64*
  store i64 %52, i64* %66
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %61, i64* %67
  br label %$14
$13:
  %68 = phi i64 [%35, %$7] ; # X
  %69 = phi i64 [%47, %$7] ; # Y
  %70 = phi i64 [%31, %$7] ; # P
  %71 = phi i64 [%43, %$7] ; # V
  %72 = phi i64 [%45, %$7] ; # Z
; # (loop (set $Bind (setq P (push (if (pair V) (++ V) $Nil) (needChk...
  br label %$21
$21:
  %73 = phi i64 [%68, %$13], [%119, %$31] ; # X
  %74 = phi i64 [%69, %$13], [%120, %$31] ; # Y
  %75 = phi i64 [%70, %$13], [%121, %$31] ; # P
  %76 = phi i64 [%71, %$13], [%122, %$31] ; # V
  %77 = phi i64 [%72, %$13], [%123, %$31] ; # Z
; # (set $Bind (setq P (push (if (pair V) (++ V) $Nil) (needChkVar Ex...
; # (if (pair V) (++ V) $Nil)
; # (pair V)
  %78 = and i64 %76, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$22, label %$23
$22:
  %80 = phi i64 [%73, %$21] ; # X
  %81 = phi i64 [%74, %$21] ; # Y
  %82 = phi i64 [%75, %$21] ; # P
  %83 = phi i64 [%76, %$21] ; # V
  %84 = phi i64 [%77, %$21] ; # Z
; # (++ V)
  %85 = inttoptr i64 %83 to i64*
  %86 = load i64, i64* %85
  %87 = getelementptr i64, i64* %85, i32 1
  %88 = load i64, i64* %87
  br label %$24
$23:
  %89 = phi i64 [%73, %$21] ; # X
  %90 = phi i64 [%74, %$21] ; # Y
  %91 = phi i64 [%75, %$21] ; # P
  %92 = phi i64 [%76, %$21] ; # V
  %93 = phi i64 [%77, %$21] ; # Z
  br label %$24
$24:
  %94 = phi i64 [%80, %$22], [%89, %$23] ; # X
  %95 = phi i64 [%81, %$22], [%90, %$23] ; # Y
  %96 = phi i64 [%82, %$22], [%91, %$23] ; # P
  %97 = phi i64 [%88, %$22], [%92, %$23] ; # V
  %98 = phi i64 [%84, %$22], [%93, %$23] ; # Z
  %99 = phi i64 [%86, %$22], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$23] ; # ->
; # (++ Z)
  %100 = inttoptr i64 %98 to i64*
  %101 = load i64, i64* %100
  %102 = getelementptr i64, i64* %100, i32 1
  %103 = load i64, i64* %102
; # (needChkVar Exe (++ Z))
  %104 = and i64 %101, 6
  %105 = icmp ne i64 %104, 0
  br i1 %105, label %$25, label %$26
$25:
  call void @varErr(i64 %0, i64 %101)
  unreachable
$26:
  %106 = icmp uge i64 %101, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %106, label %$28, label %$27
$28:
  %107 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %101
  br label %$27
$27:
  %108 = phi i1 [0, %$26], [%107, %$28] ; # ->
  br i1 %108, label %$29, label %$30
$29:
  call void @protErr(i64 %0, i64 %101)
  unreachable
$30:
; # (push (if (pair V) (++ V) $Nil) (needChkVar Exe (++ Z)) P)
  %109 = alloca i64, i64 3, align 16
  %110 = ptrtoint i64* %109 to i64
  %111 = inttoptr i64 %110 to i64*
  store i64 %99, i64* %111
  %112 = add i64 %110, 8
  %113 = inttoptr i64 %112 to i64*
  store i64 %101, i64* %113
  %114 = add i64 %110, 16
  %115 = inttoptr i64 %114 to i64*
  store i64 %96, i64* %115
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %110, i64* %116
; # (? (atom Z))
; # (atom Z)
  %117 = and i64 %103, 15
  %118 = icmp ne i64 %117, 0
  br i1 %118, label %$32, label %$31
$31:
  %119 = phi i64 [%94, %$30] ; # X
  %120 = phi i64 [%95, %$30] ; # Y
  %121 = phi i64 [%110, %$30] ; # P
  %122 = phi i64 [%97, %$30] ; # V
  %123 = phi i64 [%103, %$30] ; # Z
  br label %$21
$32:
  %124 = phi i64 [%94, %$30] ; # X
  %125 = phi i64 [%95, %$30] ; # Y
  %126 = phi i64 [%110, %$30] ; # P
  %127 = phi i64 [%97, %$30] ; # V
  %128 = phi i64 [%103, %$30] ; # Z
  %129 = phi i64 [0, %$30] ; # ->
; # (unless (nil? Z) (set $Bind (setq P (push V (needChkVar Exe Z) P)...
; # (nil? Z)
  %130 = icmp eq i64 %128, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %130, label %$34, label %$33
$33:
  %131 = phi i64 [%124, %$32] ; # X
  %132 = phi i64 [%125, %$32] ; # Y
  %133 = phi i64 [%126, %$32] ; # P
  %134 = phi i64 [%127, %$32] ; # V
  %135 = phi i64 [%128, %$32] ; # Z
; # (set $Bind (setq P (push V (needChkVar Exe Z) P)))
; # (needChkVar Exe Z)
  %136 = and i64 %135, 6
  %137 = icmp ne i64 %136, 0
  br i1 %137, label %$35, label %$36
$35:
  call void @varErr(i64 %0, i64 %135)
  unreachable
$36:
  %138 = icmp uge i64 %135, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %138, label %$38, label %$37
$38:
  %139 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %135
  br label %$37
$37:
  %140 = phi i1 [0, %$36], [%139, %$38] ; # ->
  br i1 %140, label %$39, label %$40
$39:
  call void @protErr(i64 %0, i64 %135)
  unreachable
$40:
; # (push V (needChkVar Exe Z) P)
  %141 = alloca i64, i64 3, align 16
  %142 = ptrtoint i64* %141 to i64
  %143 = inttoptr i64 %142 to i64*
  store i64 %134, i64* %143
  %144 = add i64 %142, 8
  %145 = inttoptr i64 %144 to i64*
  store i64 %135, i64* %145
  %146 = add i64 %142, 16
  %147 = inttoptr i64 %146 to i64*
  store i64 %133, i64* %147
  %148 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %142, i64* %148
  br label %$34
$34:
  %149 = phi i64 [%124, %$32], [%131, %$40] ; # X
  %150 = phi i64 [%125, %$32], [%132, %$40] ; # Y
  %151 = phi i64 [%126, %$32], [%142, %$40] ; # P
  %152 = phi i64 [%127, %$32], [%134, %$40] ; # V
  %153 = phi i64 [%128, %$32], [%135, %$40] ; # Z
  br label %$14
$14:
  %154 = phi i64 [%50, %$20], [%149, %$34] ; # X
  %155 = phi i64 [%51, %$20], [%150, %$34] ; # Y
  %156 = phi i64 [%61, %$20], [%151, %$34] ; # P
  %157 = phi i64 [%53, %$20], [%152, %$34] ; # V
  %158 = phi i64 [%54, %$20], [%153, %$34] ; # Z
  br label %$4
$6:
  %159 = phi i64 [%24, %$4] ; # X
  %160 = phi i64 [%25, %$4] ; # Y
  %161 = phi i64 [%26, %$4] ; # P
; # (prog1 (if (== Y $At) (if (pair X) (let (L (push NIL (eval (car X...
; # (if (== Y $At) (if (pair X) (let (L (push NIL (eval (car X)) NIL)...
; # (== Y $At)
  %162 = icmp eq i64 %160, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64)
  br i1 %162, label %$41, label %$42
$41:
  %163 = phi i64 [%159, %$6] ; # X
  %164 = phi i64 [%160, %$6] ; # Y
  %165 = phi i64 [%161, %$6] ; # P
; # (if (pair X) (let (L (push NIL (eval (car X)) NIL) Q L) (link (of...
; # (pair X)
  %166 = and i64 %163, 15
  %167 = icmp eq i64 %166, 0
  br i1 %167, label %$44, label %$45
$44:
  %168 = phi i64 [%163, %$41] ; # X
  %169 = phi i64 [%164, %$41] ; # Y
  %170 = phi i64 [%165, %$41] ; # P
; # (let (L (push NIL (eval (car X)) NIL) Q L) (link (ofs L 1)) (whil...
; # (car X)
  %171 = inttoptr i64 %168 to i64*
  %172 = load i64, i64* %171
; # (eval (car X))
  %173 = and i64 %172, 6
  %174 = icmp ne i64 %173, 0
  br i1 %174, label %$49, label %$48
$49:
  br label %$47
$48:
  %175 = and i64 %172, 8
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$51, label %$50
$51:
  %177 = inttoptr i64 %172 to i64*
  %178 = load i64, i64* %177
  br label %$47
$50:
  %179 = call i64 @evList(i64 %172)
  br label %$47
$47:
  %180 = phi i64 [%172, %$49], [%178, %$51], [%179, %$50] ; # ->
; # (push NIL (eval (car X)) NIL)
  %181 = alloca i64, i64 3, align 16
  %182 = ptrtoint i64* %181 to i64
  %183 = add i64 %182, 8
  %184 = inttoptr i64 %183 to i64*
  store i64 %180, i64* %184
; # (ofs L 1)
  %185 = add i64 %182, 8
; # (link (ofs L 1))
  %186 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %187 = load i64, i64* %186
  %188 = inttoptr i64 %185 to i64*
  %189 = getelementptr i64, i64* %188, i32 1
  store i64 %187, i64* %189
  %190 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %185, i64* %190
; # (while (pair (shift X)) (setq L (set L (push NIL (eval (car X)) N...
  br label %$52
$52:
  %191 = phi i64 [%168, %$47], [%200, %$55] ; # X
  %192 = phi i64 [%169, %$47], [%201, %$55] ; # Y
  %193 = phi i64 [%170, %$47], [%202, %$55] ; # P
  %194 = phi i64 [%182, %$47], [%215, %$55] ; # L
; # (shift X)
  %195 = inttoptr i64 %191 to i64*
  %196 = getelementptr i64, i64* %195, i32 1
  %197 = load i64, i64* %196
; # (pair (shift X))
  %198 = and i64 %197, 15
  %199 = icmp eq i64 %198, 0
  br i1 %199, label %$53, label %$54
$53:
  %200 = phi i64 [%197, %$52] ; # X
  %201 = phi i64 [%192, %$52] ; # Y
  %202 = phi i64 [%193, %$52] ; # P
  %203 = phi i64 [%194, %$52] ; # L
; # (set L (push NIL (eval (car X)) NIL))
; # (car X)
  %204 = inttoptr i64 %200 to i64*
  %205 = load i64, i64* %204
; # (eval (car X))
  %206 = and i64 %205, 6
  %207 = icmp ne i64 %206, 0
  br i1 %207, label %$57, label %$56
$57:
  br label %$55
$56:
  %208 = and i64 %205, 8
  %209 = icmp ne i64 %208, 0
  br i1 %209, label %$59, label %$58
$59:
  %210 = inttoptr i64 %205 to i64*
  %211 = load i64, i64* %210
  br label %$55
$58:
  %212 = call i64 @evList(i64 %205)
  br label %$55
$55:
  %213 = phi i64 [%205, %$57], [%211, %$59], [%212, %$58] ; # ->
; # (push NIL (eval (car X)) NIL)
  %214 = alloca i64, i64 3, align 16
  %215 = ptrtoint i64* %214 to i64
  %216 = add i64 %215, 8
  %217 = inttoptr i64 %216 to i64*
  store i64 %213, i64* %217
  %218 = inttoptr i64 %203 to i64*
  store i64 %215, i64* %218
; # (ofs L 1)
  %219 = add i64 %215, 8
; # (link (ofs L 1))
  %220 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %221 = load i64, i64* %220
  %222 = inttoptr i64 %219 to i64*
  %223 = getelementptr i64, i64* %222, i32 1
  store i64 %221, i64* %223
  %224 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %219, i64* %224
  br label %$52
$54:
  %225 = phi i64 [%197, %$52] ; # X
  %226 = phi i64 [%192, %$52] ; # Y
  %227 = phi i64 [%193, %$52] ; # P
  %228 = phi i64 [%194, %$52] ; # L
; # (let Next (val $Next) (set L $Nil $Next Q) (loop (let Sym (val 2 ...
; # (val $Next)
  %229 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %230 = load i64, i64* %229
; # (set L $Nil $Next Q)
  %231 = inttoptr i64 %228 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %231
  %232 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 %182, i64* %232
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$60
$60:
  %233 = phi i64 [%225, %$54], [%245, %$61] ; # X
  %234 = phi i64 [%226, %$54], [%246, %$61] ; # Y
  %235 = phi i64 [%227, %$54], [%251, %$61] ; # P
  %236 = phi i64 [%228, %$54], [%248, %$61] ; # L
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %237 = inttoptr i64 %235 to i64*
  %238 = getelementptr i64, i64* %237, i32 1
  %239 = load i64, i64* %238
; # (xchg Sym P)
  %240 = inttoptr i64 %239 to i64*
  %241 = load i64, i64* %240
  %242 = inttoptr i64 %235 to i64*
  %243 = load i64, i64* %242
  store i64 %243, i64* %240
  store i64 %241, i64* %242
; # (? (== $At Sym))
; # (== $At Sym)
  %244 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %239
  br i1 %244, label %$62, label %$61
$61:
  %245 = phi i64 [%233, %$60] ; # X
  %246 = phi i64 [%234, %$60] ; # Y
  %247 = phi i64 [%235, %$60] ; # P
  %248 = phi i64 [%236, %$60] ; # L
; # (val 3 P)
  %249 = inttoptr i64 %247 to i64*
  %250 = getelementptr i64, i64* %249, i32 2
  %251 = load i64, i64* %250
  br label %$60
$62:
  %252 = phi i64 [%233, %$60] ; # X
  %253 = phi i64 [%234, %$60] ; # Y
  %254 = phi i64 [%235, %$60] ; # P
  %255 = phi i64 [%236, %$60] ; # L
  %256 = phi i64 [0, %$60] ; # ->
; # (prog1 (run (cdr Exe)) (set $Next Next) (drop (ofs Q 1)))
; # (cdr Exe)
  %257 = inttoptr i64 %0 to i64*
  %258 = getelementptr i64, i64* %257, i32 1
  %259 = load i64, i64* %258
; # (run (cdr Exe))
  br label %$63
$63:
  %260 = phi i64 [%259, %$62], [%282, %$72] ; # Prg
  %261 = inttoptr i64 %260 to i64*
  %262 = load i64, i64* %261
  %263 = getelementptr i64, i64* %261, i32 1
  %264 = load i64, i64* %263
  %265 = and i64 %264, 15
  %266 = icmp ne i64 %265, 0
  br i1 %266, label %$66, label %$64
$66:
  %267 = phi i64 [%264, %$63] ; # Prg
  %268 = and i64 %262, 6
  %269 = icmp ne i64 %268, 0
  br i1 %269, label %$69, label %$68
$69:
  br label %$67
$68:
  %270 = and i64 %262, 8
  %271 = icmp ne i64 %270, 0
  br i1 %271, label %$71, label %$70
$71:
  %272 = inttoptr i64 %262 to i64*
  %273 = load i64, i64* %272
  br label %$67
$70:
  %274 = call i64 @evList(i64 %262)
  br label %$67
$67:
  %275 = phi i64 [%262, %$69], [%273, %$71], [%274, %$70] ; # ->
  br label %$65
$64:
  %276 = phi i64 [%264, %$63] ; # Prg
  %277 = and i64 %262, 15
  %278 = icmp eq i64 %277, 0
  br i1 %278, label %$73, label %$72
$73:
  %279 = phi i64 [%276, %$64] ; # Prg
  %280 = call i64 @evList(i64 %262)
  %281 = icmp ne i64 %280, 0
  br label %$72
$72:
  %282 = phi i64 [%276, %$64], [%279, %$73] ; # Prg
  %283 = phi i1 [0, %$64], [%281, %$73] ; # ->
  br label %$63
$65:
  %284 = phi i64 [%267, %$67] ; # Prg
  %285 = phi i64 [%275, %$67] ; # ->
; # (set $Next Next)
  %286 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 %230, i64* %286
; # (ofs Q 1)
  %287 = add i64 %182, 8
; # (drop (ofs Q 1))
  %288 = inttoptr i64 %287 to i64*
  %289 = getelementptr i64, i64* %288, i32 1
  %290 = load i64, i64* %289
  %291 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %290, i64* %291
  br label %$46
$45:
  %292 = phi i64 [%163, %$41] ; # X
  %293 = phi i64 [%164, %$41] ; # Y
  %294 = phi i64 [%165, %$41] ; # P
; # (let Next (val $Next) (set $Next $Nil) (loop (let Sym (val 2 P) (...
; # (val $Next)
  %295 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %296 = load i64, i64* %295
; # (set $Next $Nil)
  %297 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %297
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$74
$74:
  %298 = phi i64 [%292, %$45], [%309, %$75] ; # X
  %299 = phi i64 [%293, %$45], [%310, %$75] ; # Y
  %300 = phi i64 [%294, %$45], [%314, %$75] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %301 = inttoptr i64 %300 to i64*
  %302 = getelementptr i64, i64* %301, i32 1
  %303 = load i64, i64* %302
; # (xchg Sym P)
  %304 = inttoptr i64 %303 to i64*
  %305 = load i64, i64* %304
  %306 = inttoptr i64 %300 to i64*
  %307 = load i64, i64* %306
  store i64 %307, i64* %304
  store i64 %305, i64* %306
; # (? (== $At Sym))
; # (== $At Sym)
  %308 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %303
  br i1 %308, label %$76, label %$75
$75:
  %309 = phi i64 [%298, %$74] ; # X
  %310 = phi i64 [%299, %$74] ; # Y
  %311 = phi i64 [%300, %$74] ; # P
; # (val 3 P)
  %312 = inttoptr i64 %311 to i64*
  %313 = getelementptr i64, i64* %312, i32 2
  %314 = load i64, i64* %313
  br label %$74
$76:
  %315 = phi i64 [%298, %$74] ; # X
  %316 = phi i64 [%299, %$74] ; # Y
  %317 = phi i64 [%300, %$74] ; # P
  %318 = phi i64 [0, %$74] ; # ->
; # (prog1 (run (cdr Exe)) (set $Next Next))
; # (cdr Exe)
  %319 = inttoptr i64 %0 to i64*
  %320 = getelementptr i64, i64* %319, i32 1
  %321 = load i64, i64* %320
; # (run (cdr Exe))
  br label %$77
$77:
  %322 = phi i64 [%321, %$76], [%344, %$86] ; # Prg
  %323 = inttoptr i64 %322 to i64*
  %324 = load i64, i64* %323
  %325 = getelementptr i64, i64* %323, i32 1
  %326 = load i64, i64* %325
  %327 = and i64 %326, 15
  %328 = icmp ne i64 %327, 0
  br i1 %328, label %$80, label %$78
$80:
  %329 = phi i64 [%326, %$77] ; # Prg
  %330 = and i64 %324, 6
  %331 = icmp ne i64 %330, 0
  br i1 %331, label %$83, label %$82
$83:
  br label %$81
$82:
  %332 = and i64 %324, 8
  %333 = icmp ne i64 %332, 0
  br i1 %333, label %$85, label %$84
$85:
  %334 = inttoptr i64 %324 to i64*
  %335 = load i64, i64* %334
  br label %$81
$84:
  %336 = call i64 @evList(i64 %324)
  br label %$81
$81:
  %337 = phi i64 [%324, %$83], [%335, %$85], [%336, %$84] ; # ->
  br label %$79
$78:
  %338 = phi i64 [%326, %$77] ; # Prg
  %339 = and i64 %324, 15
  %340 = icmp eq i64 %339, 0
  br i1 %340, label %$87, label %$86
$87:
  %341 = phi i64 [%338, %$78] ; # Prg
  %342 = call i64 @evList(i64 %324)
  %343 = icmp ne i64 %342, 0
  br label %$86
$86:
  %344 = phi i64 [%338, %$78], [%341, %$87] ; # Prg
  %345 = phi i1 [0, %$78], [%343, %$87] ; # ->
  br label %$77
$79:
  %346 = phi i64 [%329, %$81] ; # Prg
  %347 = phi i64 [%337, %$81] ; # ->
; # (set $Next Next)
  %348 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 %296, i64* %348
  br label %$46
$46:
  %349 = phi i64 [%252, %$65], [%315, %$79] ; # X
  %350 = phi i64 [%253, %$65], [%316, %$79] ; # Y
  %351 = phi i64 [%254, %$65], [%317, %$79] ; # P
  %352 = phi i64 [%285, %$65], [%347, %$79] ; # ->
  br label %$43
$42:
  %353 = phi i64 [%159, %$6] ; # X
  %354 = phi i64 [%160, %$6] ; # Y
  %355 = phi i64 [%161, %$6] ; # P
; # (unless (nil? Y) (needChkVar Exe Y) (set $Bind (push (val Y) Y P)...
; # (nil? Y)
  %356 = icmp eq i64 %354, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %356, label %$89, label %$88
$88:
  %357 = phi i64 [%353, %$42] ; # X
  %358 = phi i64 [%354, %$42] ; # Y
  %359 = phi i64 [%355, %$42] ; # P
; # (needChkVar Exe Y)
  %360 = and i64 %358, 6
  %361 = icmp ne i64 %360, 0
  br i1 %361, label %$90, label %$91
$90:
  call void @varErr(i64 %0, i64 %358)
  unreachable
$91:
  %362 = icmp uge i64 %358, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %362, label %$93, label %$92
$93:
  %363 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %358
  br label %$92
$92:
  %364 = phi i1 [0, %$91], [%363, %$93] ; # ->
  br i1 %364, label %$94, label %$95
$94:
  call void @protErr(i64 %0, i64 %358)
  unreachable
$95:
; # (set $Bind (push (val Y) Y P) Y X)
; # (val Y)
  %365 = inttoptr i64 %358 to i64*
  %366 = load i64, i64* %365
; # (push (val Y) Y P)
  %367 = alloca i64, i64 3, align 16
  %368 = ptrtoint i64* %367 to i64
  %369 = inttoptr i64 %368 to i64*
  store i64 %366, i64* %369
  %370 = add i64 %368, 8
  %371 = inttoptr i64 %370 to i64*
  store i64 %358, i64* %371
  %372 = add i64 %368, 16
  %373 = inttoptr i64 %372 to i64*
  store i64 %359, i64* %373
  %374 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %368, i64* %374
  %375 = inttoptr i64 %358 to i64*
  store i64 %357, i64* %375
  br label %$89
$89:
  %376 = phi i64 [%353, %$42], [%357, %$95] ; # X
  %377 = phi i64 [%354, %$42], [%358, %$95] ; # Y
  %378 = phi i64 [%355, %$42], [%359, %$95] ; # P
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$96
$96:
  %379 = phi i64 [%376, %$89], [%390, %$97] ; # X
  %380 = phi i64 [%377, %$89], [%391, %$97] ; # Y
  %381 = phi i64 [%378, %$89], [%395, %$97] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %382 = inttoptr i64 %381 to i64*
  %383 = getelementptr i64, i64* %382, i32 1
  %384 = load i64, i64* %383
; # (xchg Sym P)
  %385 = inttoptr i64 %384 to i64*
  %386 = load i64, i64* %385
  %387 = inttoptr i64 %381 to i64*
  %388 = load i64, i64* %387
  store i64 %388, i64* %385
  store i64 %386, i64* %387
; # (? (== $At Sym))
; # (== $At Sym)
  %389 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %384
  br i1 %389, label %$98, label %$97
$97:
  %390 = phi i64 [%379, %$96] ; # X
  %391 = phi i64 [%380, %$96] ; # Y
  %392 = phi i64 [%381, %$96] ; # P
; # (val 3 P)
  %393 = inttoptr i64 %392 to i64*
  %394 = getelementptr i64, i64* %393, i32 2
  %395 = load i64, i64* %394
  br label %$96
$98:
  %396 = phi i64 [%379, %$96] ; # X
  %397 = phi i64 [%380, %$96] ; # Y
  %398 = phi i64 [%381, %$96] ; # P
  %399 = phi i64 [0, %$96] ; # ->
; # (cdr Exe)
  %400 = inttoptr i64 %0 to i64*
  %401 = getelementptr i64, i64* %400, i32 1
  %402 = load i64, i64* %401
; # (run (cdr Exe))
  br label %$99
$99:
  %403 = phi i64 [%402, %$98], [%425, %$108] ; # Prg
  %404 = inttoptr i64 %403 to i64*
  %405 = load i64, i64* %404
  %406 = getelementptr i64, i64* %404, i32 1
  %407 = load i64, i64* %406
  %408 = and i64 %407, 15
  %409 = icmp ne i64 %408, 0
  br i1 %409, label %$102, label %$100
$102:
  %410 = phi i64 [%407, %$99] ; # Prg
  %411 = and i64 %405, 6
  %412 = icmp ne i64 %411, 0
  br i1 %412, label %$105, label %$104
$105:
  br label %$103
$104:
  %413 = and i64 %405, 8
  %414 = icmp ne i64 %413, 0
  br i1 %414, label %$107, label %$106
$107:
  %415 = inttoptr i64 %405 to i64*
  %416 = load i64, i64* %415
  br label %$103
$106:
  %417 = call i64 @evList(i64 %405)
  br label %$103
$103:
  %418 = phi i64 [%405, %$105], [%416, %$107], [%417, %$106] ; # ->
  br label %$101
$100:
  %419 = phi i64 [%407, %$99] ; # Prg
  %420 = and i64 %405, 15
  %421 = icmp eq i64 %420, 0
  br i1 %421, label %$109, label %$108
$109:
  %422 = phi i64 [%419, %$100] ; # Prg
  %423 = call i64 @evList(i64 %405)
  %424 = icmp ne i64 %423, 0
  br label %$108
$108:
  %425 = phi i64 [%419, %$100], [%422, %$109] ; # Prg
  %426 = phi i1 [0, %$100], [%424, %$109] ; # ->
  br label %$99
$101:
  %427 = phi i64 [%410, %$103] ; # Prg
  %428 = phi i64 [%418, %$103] ; # ->
  br label %$43
$43:
  %429 = phi i64 [%349, %$46], [%396, %$101] ; # X
  %430 = phi i64 [%350, %$46], [%397, %$101] ; # Y
  %431 = phi i64 [%351, %$46], [%398, %$101] ; # P
  %432 = phi i64 [%352, %$46], [%428, %$101] ; # ->
; # (val $Bind)
  %433 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %434 = load i64, i64* %433
; # (loop (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq...
  br label %$110
$110:
  %435 = phi i64 [%429, %$43], [%445, %$111] ; # X
  %436 = phi i64 [%430, %$43], [%446, %$111] ; # Y
  %437 = phi i64 [%434, %$43], [%450, %$111] ; # P
; # (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq P (va...
; # (val 2 P)
  %438 = inttoptr i64 %437 to i64*
  %439 = getelementptr i64, i64* %438, i32 1
  %440 = load i64, i64* %439
; # (set Sym (val P))
; # (val P)
  %441 = inttoptr i64 %437 to i64*
  %442 = load i64, i64* %441
  %443 = inttoptr i64 %440 to i64*
  store i64 %442, i64* %443
; # (? (== $At Sym))
; # (== $At Sym)
  %444 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %440
  br i1 %444, label %$112, label %$111
$111:
  %445 = phi i64 [%435, %$110] ; # X
  %446 = phi i64 [%436, %$110] ; # Y
  %447 = phi i64 [%437, %$110] ; # P
; # (val 3 P)
  %448 = inttoptr i64 %447 to i64*
  %449 = getelementptr i64, i64* %448, i32 2
  %450 = load i64, i64* %449
  br label %$110
$112:
  %451 = phi i64 [%435, %$110] ; # X
  %452 = phi i64 [%436, %$110] ; # Y
  %453 = phi i64 [%437, %$110] ; # P
  %454 = phi i64 [0, %$110] ; # ->
; # (set $Bind (val 3 P))
; # (val 3 P)
  %455 = inttoptr i64 %453 to i64*
  %456 = getelementptr i64, i64* %455, i32 2
  %457 = load i64, i64* %456
  %458 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %457, i64* %458
  ret i64 %432
}

define i64 @evList(i64) align 8 {
$1:
; # (let Fun (car Exe) (cond ((num? Fun) Exe) ((sym? Fun) (loop (sigC...
; # (car Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (cond ((num? Fun) Exe) ((sym? Fun) (loop (sigChk Exe) (let V (val...
; # (num? Fun)
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$4, label %$3
$4:
  %5 = phi i64 [%2, %$1] ; # Fun
  br label %$2
$3:
  %6 = phi i64 [%2, %$1] ; # Fun
; # (sym? Fun)
  %7 = and i64 %6, 8
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i64 [%6, %$3] ; # Fun
; # (loop (sigChk Exe) (let V (val Fun) (? (num? V) (subr V Exe Fun))...
  br label %$7
$7:
  %10 = phi i64 [%9, %$6], [%14, %$15] ; # Fun
; # (sigChk Exe)
  %11 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %$8, label %$9
$8:
  call void @sighandler(i64 %0)
  br label %$9
$9:
; # (let V (val Fun) (? (num? V) (subr V Exe Fun)) (? (pair V) (evExp...
; # (val Fun)
  %13 = inttoptr i64 %10 to i64*
  %14 = load i64, i64* %13
; # (? (num? V) (subr V Exe Fun))
; # (num? V)
  %15 = and i64 %14, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$12, label %$10
$12:
  %17 = phi i64 [%10, %$9] ; # Fun
; # (subr V Exe Fun)
  %18 = and i64 %14, -3
  %19 = inttoptr i64 %18 to i64(i64,i64)*
  %20 = call i64 %19(i64 %0,i64 %17)
  br label %$11
$10:
  %21 = phi i64 [%10, %$9] ; # Fun
; # (? (pair V) (evExpr V Exe))
; # (pair V)
  %22 = and i64 %14, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = phi i64 [%21, %$10] ; # Fun
; # (evExpr V Exe)
  %25 = call i64 @evExpr(i64 %14, i64 %0)
  br label %$11
$13:
  %26 = phi i64 [%21, %$10] ; # Fun
; # (? (== V (val V)) (if (sharedLib Fun) (subr (val Fun) Exe Fun) (u...
; # (val V)
  %27 = inttoptr i64 %14 to i64*
  %28 = load i64, i64* %27
; # (== V (val V))
  %29 = icmp eq i64 %14, %28
  br i1 %29, label %$16, label %$15
$16:
  %30 = phi i64 [%26, %$13] ; # Fun
; # (if (sharedLib Fun) (subr (val Fun) Exe Fun) (undefined Fun Exe))...
; # (sharedLib Fun)
  %31 = call i1 @sharedLib(i64 %30)
  br i1 %31, label %$17, label %$18
$17:
  %32 = phi i64 [%30, %$16] ; # Fun
; # (val Fun)
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (subr (val Fun) Exe Fun)
  %35 = and i64 %34, -3
  %36 = inttoptr i64 %35 to i64(i64,i64)*
  %37 = call i64 %36(i64 %0,i64 %32)
  br label %$19
$18:
  %38 = phi i64 [%30, %$16] ; # Fun
; # (undefined Fun Exe)
  call void @undefined(i64 %38, i64 %0)
  unreachable
$19:
  %39 = phi i64 [%32, %$17] ; # Fun
  %40 = phi i64 [%37, %$17] ; # ->
  br label %$11
$15:
  %41 = phi i64 [%26, %$13] ; # Fun
  br label %$7
$11:
  %42 = phi i64 [%17, %$12], [%24, %$14], [%39, %$19] ; # Fun
  %43 = phi i64 [%20, %$12], [%25, %$14], [%40, %$19] ; # ->
  br label %$2
$5:
  %44 = phi i64 [%6, %$3] ; # Fun
; # (stkChk Exe)
  %45 = load i8*, i8** @$StkLimit
  %46 = call i8* @llvm.stacksave()
  %47 = icmp ugt i8* %45, %46
  br i1 %47, label %$20, label %$21
$20:
  call void @stkErr(i64 %0)
  unreachable
$21:
; # (let F (save (evList Fun)) (loop (sigChk Exe) (? (num? F) (subr F...
; # (evList Fun)
  %48 = call i64 @evList(i64 %44)
; # (save (evList Fun))
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
  %51 = alloca i64, i64 2, align 16
  %52 = ptrtoint i64* %51 to i64
  %53 = inttoptr i64 %52 to i64*
  store i64 %48, i64* %53
  %54 = add i64 %52, 8
  %55 = inttoptr i64 %54 to i64*
  store i64 %50, i64* %55
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %56
; # (loop (sigChk Exe) (? (num? F) (subr F Exe Fun)) (? (pair F) (evE...
  br label %$22
$22:
  %57 = phi i64 [%44, %$21], [%98, %$30] ; # Fun
  %58 = phi i64 [%48, %$21], [%78, %$30] ; # F
; # (sigChk Exe)
  %59 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %60 = icmp ne i32 %59, 0
  br i1 %60, label %$23, label %$24
$23:
  call void @sighandler(i64 %0)
  br label %$24
$24:
; # (? (num? F) (subr F Exe Fun))
; # (num? F)
  %61 = and i64 %58, 6
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$27, label %$25
$27:
  %63 = phi i64 [%57, %$24] ; # Fun
  %64 = phi i64 [%58, %$24] ; # F
; # (subr F Exe Fun)
  %65 = and i64 %64, -3
  %66 = inttoptr i64 %65 to i64(i64,i64)*
  %67 = call i64 %66(i64 %0,i64 %63)
  br label %$26
$25:
  %68 = phi i64 [%57, %$24] ; # Fun
  %69 = phi i64 [%58, %$24] ; # F
; # (? (pair F) (evExpr F Exe))
; # (pair F)
  %70 = and i64 %69, 15
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %$29, label %$28
$29:
  %72 = phi i64 [%68, %$25] ; # Fun
  %73 = phi i64 [%69, %$25] ; # F
; # (evExpr F Exe)
  %74 = call i64 @evExpr(i64 %73, i64 %0)
  br label %$26
$28:
  %75 = phi i64 [%68, %$25] ; # Fun
  %76 = phi i64 [%69, %$25] ; # F
; # (let V (val F) (? (== V (val V)) (if (sharedLib F) (subr (val F) ...
; # (val F)
  %77 = inttoptr i64 %76 to i64*
  %78 = load i64, i64* %77
; # (? (== V (val V)) (if (sharedLib F) (subr (val F) Exe F) (undefin...
; # (val V)
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
; # (== V (val V))
  %81 = icmp eq i64 %78, %80
  br i1 %81, label %$31, label %$30
$31:
  %82 = phi i64 [%75, %$28] ; # Fun
  %83 = phi i64 [%76, %$28] ; # F
; # (if (sharedLib F) (subr (val F) Exe F) (undefined F Exe))
; # (sharedLib F)
  %84 = call i1 @sharedLib(i64 %83)
  br i1 %84, label %$32, label %$33
$32:
  %85 = phi i64 [%82, %$31] ; # Fun
  %86 = phi i64 [%83, %$31] ; # F
; # (val F)
  %87 = inttoptr i64 %86 to i64*
  %88 = load i64, i64* %87
; # (subr (val F) Exe F)
  %89 = and i64 %88, -3
  %90 = inttoptr i64 %89 to i64(i64,i64)*
  %91 = call i64 %90(i64 %0,i64 %86)
  br label %$34
$33:
  %92 = phi i64 [%82, %$31] ; # Fun
  %93 = phi i64 [%83, %$31] ; # F
; # (undefined F Exe)
  call void @undefined(i64 %93, i64 %0)
  unreachable
$34:
  %94 = phi i64 [%85, %$32] ; # Fun
  %95 = phi i64 [%86, %$32] ; # F
  %96 = phi i64 [%91, %$32] ; # ->
  br label %$26
$30:
  %97 = phi i64 [%75, %$28] ; # Fun
  %98 = phi i64 [%76, %$28] ; # F
  br label %$22
$26:
  %99 = phi i64 [%63, %$27], [%72, %$29], [%94, %$34] ; # Fun
  %100 = phi i64 [%64, %$27], [%73, %$29], [%95, %$34] ; # F
  %101 = phi i64 [%67, %$27], [%74, %$29], [%96, %$34] ; # ->
; # (drop *Safe)
  %102 = inttoptr i64 %52 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %104, i64* %105
  br label %$2
$2:
  %106 = phi i64 [%5, %$4], [%42, %$11], [%99, %$26] ; # Fun
  %107 = phi i64 [%0, %$4], [%43, %$11], [%101, %$26] ; # ->
  ret i64 %107
}

define void @openErr(i64, i64) align 8 {
$1:
; # (strErrno)
  %2 = call i8* @strErrno()
; # (err Exe X ($ "Open error: %s") (strErrno))
  call void @err(i64 %0, i64 %1, i8* bitcast ([15 x i8]* @$28 to i8*), i8* %2)
  unreachable
}

define void @closeErr() align 8 {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "Close error: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([16 x i8]* @$29 to i8*), i8* %0)
  unreachable
}

define void @pipeErr(i64) align 8 {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err Exe 0 ($ "Pipe error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([15 x i8]* @$30 to i8*), i8* %1)
  unreachable
}

define void @sizeErr(i64) align 8 {
$1:
; # (err Exe 0 ($ "Size overflow") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([14 x i8]* @$31 to i8*), i8* null)
  unreachable
}

define void @eofErr() align 8 {
$1:
; # (err 0 0 ($ "EOF Overrun") null)
  call void @err(i64 0, i64 0, i8* bitcast ([12 x i8]* @$32 to i8*), i8* null)
  unreachable
}

define void @badInput() align 8 {
$1:
; # (let S (b8 2) (set S (i8 (val $Chr))) (set 2 S 0) (err 0 0 ($ "Ba...
; # (b8 2)
  %0 = alloca i8, i64 2
; # (set S (i8 (val $Chr)))
; # (val $Chr)
  %1 = load i32, i32* @$Chr
; # (i8 (val $Chr))
  %2 = trunc i32 %1 to i8
  store i8 %2, i8* %0
; # (set 2 S 0)
  %3 = getelementptr i8, i8* %0, i32 1
  store i8 0, i8* %3
; # (err 0 0 ($ "Bad input '%s'") S)
  call void @err(i64 0, i64 0, i8* bitcast ([15 x i8]* @$33 to i8*), i8* %0)
  unreachable
}

define void @badFd(i64, i64) align 8 {
$1:
; # (err Exe Fd ($ "Bad FD") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([7 x i8]* @$34 to i8*), i8* null)
  unreachable
}

define void @writeErr(i8*) align 8 {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err 0 0 Fmt (strErrno))
  call void @err(i64 0, i64 0, i8* %0, i8* %1)
  unreachable
}

define void @selectErr(i64) align 8 {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err Exe 0 ($ "Select error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([17 x i8]* @$35 to i8*), i8* %1)
  unreachable
}

define void @closeOnExec(i64, i32) align 8 {
$1:
; # (when (lt0 (fcntlCloExec Fd)) (err Exe 0 ($ "SETFD %s") (strErrno...
; # (fcntlCloExec Fd)
  %2 = call i32 @fcntlCloExec(i32 %1)
; # (lt0 (fcntlCloExec Fd))
  %3 = icmp slt i32 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (strErrno)
  %4 = call i8* @strErrno()
; # (err Exe 0 ($ "SETFD %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([9 x i8]* @$36 to i8*), i8* %4)
  unreachable
$3:
  ret void
}

define void @rdLockWait(i32, i64) align 8 {
$1:
; # (while (lt0 (rdLock Fd 0 Len YES)) (unless (== (gErrno) EINTR) (l...
  br label %$2
$2:
; # (rdLock Fd 0 Len YES)
  %2 = call i32 @rdLock(i32 %0, i64 0, i64 %1, i1 1)
; # (lt0 (rdLock Fd 0 Len YES))
  %3 = icmp slt i32 %2, 0
  br i1 %3, label %$3, label %$4
$3:
; # (unless (== (gErrno) EINTR) (lockErr))
; # (gErrno)
  %4 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %5 = icmp eq i32 %4, 2
  br i1 %5, label %$6, label %$5
$5:
; # (lockErr)
  call void @lockErr()
  unreachable
$6:
  br label %$2
$4:
  ret void
}

define void @wrLockWait(i32, i64) align 8 {
$1:
; # (while (lt0 (wrLock Fd 0 Len YES)) (unless (== (gErrno) EINTR) (l...
  br label %$2
$2:
; # (wrLock Fd 0 Len YES)
  %2 = call i32 @wrLock(i32 %0, i64 0, i64 %1, i1 1)
; # (lt0 (wrLock Fd 0 Len YES))
  %3 = icmp slt i32 %2, 0
  br i1 %3, label %$3, label %$4
$3:
; # (unless (== (gErrno) EINTR) (lockErr))
; # (gErrno)
  %4 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %5 = icmp eq i32 %4, 2
  br i1 %5, label %$6, label %$5
$5:
; # (lockErr)
  call void @lockErr()
  unreachable
$6:
  br label %$2
$4:
  ret void
}

define i8* @initInFile(i32, i8*) align 8 {
$1:
; # (let I (val $InFDs) (when (>= Fd I) (let P (set $InFiles (i8** (a...
; # (val $InFDs)
  %2 = load i32, i32* @$InFDs
; # (when (>= Fd I) (let P (set $InFiles (i8** (alloc (i8* (val $InFi...
; # (>= Fd I)
  %3 = icmp sge i32 %0, %2
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i32 [%2, %$1] ; # I
; # (let P (set $InFiles (i8** (alloc (i8* (val $InFiles)) (* 8 (i64 ...
; # (set $InFiles (i8** (alloc (i8* (val $InFiles)) (* 8 (i64 (set $I...
; # (val $InFiles)
  %5 = load i8**, i8*** @$InFiles
; # (i8* (val $InFiles))
  %6 = bitcast i8** %5 to i8*
; # (set $InFDs (+ Fd 1))
; # (+ Fd 1)
  %7 = add i32 %0, 1
  store i32 %7, i32* @$InFDs
; # (i64 (set $InFDs (+ Fd 1)))
  %8 = sext i32 %7 to i64
; # (* 8 (i64 (set $InFDs (+ Fd 1))))
  %9 = mul i64 8, %8
; # (alloc (i8* (val $InFiles)) (* 8 (i64 (set $InFDs (+ Fd 1)))))
  %10 = call i8* @alloc(i8* %6, i64 %9)
; # (i8** (alloc (i8* (val $InFiles)) (* 8 (i64 (set $InFDs (+ Fd 1))...
  %11 = bitcast i8* %10 to i8**
  store i8** %11, i8*** @$InFiles
; # (loop (set (ofs P I) null) (? (== I Fd)) (inc 'I))
  br label %$4
$4:
  %12 = phi i32 [%4, %$2], [%16, %$5] ; # I
; # (set (ofs P I) null)
; # (ofs P I)
  %13 = getelementptr i8*, i8** %11, i32 %12
  store i8* null, i8** %13
; # (? (== I Fd))
; # (== I Fd)
  %14 = icmp eq i32 %12, %0
  br i1 %14, label %$6, label %$5
$5:
  %15 = phi i32 [%12, %$4] ; # I
; # (inc 'I)
  %16 = add i32 %15, 1
  br label %$4
$6:
  %17 = phi i32 [%12, %$4] ; # I
  %18 = phi i64 [0, %$4] ; # ->
  br label %$3
$3:
  %19 = phi i32 [%2, %$1], [%17, %$6] ; # I
; # (let In: (inFile (let P (ofs (val $InFiles) Fd) (if (val P) @ (se...
; # (let P (ofs (val $InFiles) Fd) (if (val P) @ (set P (alloc null (...
; # (val $InFiles)
  %20 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %21 = getelementptr i8*, i8** %20, i32 %0
; # (if (val P) @ (set P (alloc null (inFile T))))
; # (val P)
  %22 = load i8*, i8** %21
  %23 = icmp ne i8* %22, null
  br i1 %23, label %$7, label %$8
$7:
  br label %$9
$8:
; # (set P (alloc null (inFile T)))
; # (alloc null (inFile T))
  %24 = call i8* @alloc(i8* null, i64 4129)
  store i8* %24, i8** %21
  br label %$9
$9:
  %25 = phi i8* [%22, %$7], [%24, %$8] ; # ->
; # (In: name Nm)
  %26 = bitcast i8* %25 to i8**
  store i8* %1, i8** %26
; # (In: tty (n0 (isatty (In: fd Fd))))
  %27 = getelementptr i8, i8* %25, i32 4128
  %28 = bitcast i8* %27 to i1*
  %29 = getelementptr i8, i8* %25, i32 8
  %30 = bitcast i8* %29 to i32*
  store i32 %0, i32* %30
  %31 = call i32 @isatty(i32 %0)
  %32 = icmp ne i32 %31, 0
  store i1 %32, i1* %28
; # (In: chr 0)
  %33 = getelementptr i8, i8* %25, i32 12
  %34 = bitcast i8* %33 to i32*
  store i32 0, i32* %34
; # (In: line (In: src 1))
  %35 = getelementptr i8, i8* %25, i32 16
  %36 = bitcast i8* %35 to i32*
  %37 = getelementptr i8, i8* %25, i32 20
  %38 = bitcast i8* %37 to i32*
  store i32 1, i32* %38
  store i32 1, i32* %36
; # (In: ix (In: cnt 0))
  %39 = getelementptr i8, i8* %25, i32 24
  %40 = bitcast i8* %39 to i32*
  %41 = getelementptr i8, i8* %25, i32 28
  %42 = bitcast i8* %41 to i32*
  store i32 0, i32* %42
  store i32 0, i32* %40
; # (In:)
  ret i8* %25
}

define i8* @initOutFile(i32) align 8 {
$1:
; # (let I (val $OutFDs) (when (>= Fd I) (let P (set $OutFiles (i8** ...
; # (val $OutFDs)
  %1 = load i32, i32* @$OutFDs
; # (when (>= Fd I) (let P (set $OutFiles (i8** (alloc (i8* (val $Out...
; # (>= Fd I)
  %2 = icmp sge i32 %0, %1
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i32 [%1, %$1] ; # I
; # (let P (set $OutFiles (i8** (alloc (i8* (val $OutFiles)) (* 8 (i6...
; # (set $OutFiles (i8** (alloc (i8* (val $OutFiles)) (* 8 (i64 (set ...
; # (val $OutFiles)
  %4 = load i8**, i8*** @$OutFiles
; # (i8* (val $OutFiles))
  %5 = bitcast i8** %4 to i8*
; # (set $OutFDs (+ Fd 1))
; # (+ Fd 1)
  %6 = add i32 %0, 1
  store i32 %6, i32* @$OutFDs
; # (i64 (set $OutFDs (+ Fd 1)))
  %7 = sext i32 %6 to i64
; # (* 8 (i64 (set $OutFDs (+ Fd 1))))
  %8 = mul i64 8, %7
; # (alloc (i8* (val $OutFiles)) (* 8 (i64 (set $OutFDs (+ Fd 1)))))
  %9 = call i8* @alloc(i8* %5, i64 %8)
; # (i8** (alloc (i8* (val $OutFiles)) (* 8 (i64 (set $OutFDs (+ Fd 1...
  %10 = bitcast i8* %9 to i8**
  store i8** %10, i8*** @$OutFiles
; # (loop (set (ofs P I) null) (? (== I Fd)) (inc 'I))
  br label %$4
$4:
  %11 = phi i32 [%3, %$2], [%15, %$5] ; # I
; # (set (ofs P I) null)
; # (ofs P I)
  %12 = getelementptr i8*, i8** %10, i32 %11
  store i8* null, i8** %12
; # (? (== I Fd))
; # (== I Fd)
  %13 = icmp eq i32 %11, %0
  br i1 %13, label %$6, label %$5
$5:
  %14 = phi i32 [%11, %$4] ; # I
; # (inc 'I)
  %15 = add i32 %14, 1
  br label %$4
$6:
  %16 = phi i32 [%11, %$4] ; # I
  %17 = phi i64 [0, %$4] ; # ->
  br label %$3
$3:
  %18 = phi i32 [%1, %$1], [%16, %$6] ; # I
; # (let Out: (outFile (let P (ofs (val $OutFiles) Fd) (if (val P) @ ...
; # (let P (ofs (val $OutFiles) Fd) (if (val P) @ (set P (alloc null ...
; # (val $OutFiles)
  %19 = load i8**, i8*** @$OutFiles
; # (ofs (val $OutFiles) Fd)
  %20 = getelementptr i8*, i8** %19, i32 %0
; # (if (val P) @ (set P (alloc null (outFile T))))
; # (val P)
  %21 = load i8*, i8** %20
  %22 = icmp ne i8* %21, null
  br i1 %22, label %$7, label %$8
$7:
  br label %$9
$8:
; # (set P (alloc null (outFile T)))
; # (alloc null (outFile T))
  %23 = call i8* @alloc(i8* null, i64 4105)
  store i8* %23, i8** %20
  br label %$9
$9:
  %24 = phi i8* [%21, %$7], [%23, %$8] ; # ->
; # (Out: tty (n0 (isatty (Out: fd Fd))))
  %25 = getelementptr i8, i8* %24, i32 4104
  %26 = bitcast i8* %25 to i1*
  %27 = bitcast i8* %24 to i32*
  store i32 %0, i32* %27
  %28 = call i32 @isatty(i32 %0)
  %29 = icmp ne i32 %28, 0
  store i1 %29, i1* %26
; # (Out: ix 0)
  %30 = getelementptr i8, i8* %24, i32 4
  %31 = bitcast i8* %30 to i32*
  store i32 0, i32* %31
; # (Out:)
  ret i8* %24
}

define void @closeInFile(i32) align 8 {
$1:
; # (when (> (val $InFDs) Fd) (let (P (ofs (val $InFiles) Fd) In (val...
; # (val $InFDs)
  %1 = load i32, i32* @$InFDs
; # (> (val $InFDs) Fd)
  %2 = icmp sgt i32 %1, %0
  br i1 %2, label %$2, label %$3
$2:
; # (let (P (ofs (val $InFiles) Fd) In (val P)) (when (== In (val $In...
; # (val $InFiles)
  %3 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %4 = getelementptr i8*, i8** %3, i32 %0
; # (val P)
  %5 = load i8*, i8** %4
; # (when (== In (val $InFile)) (set $Chr ((inFile (set $InFile (val ...
; # (val $InFile)
  %6 = load i8*, i8** @$InFile
; # (== In (val $InFile))
  %7 = icmp eq i8* %5, %6
  br i1 %7, label %$4, label %$5
$4:
; # (set $Chr ((inFile (set $InFile (val (val $InFiles)))) chr))
; # (set $InFile (val (val $InFiles)))
; # (val $InFiles)
  %8 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %9 = load i8*, i8** %8
  store i8* %9, i8** @$InFile
; # ((inFile (set $InFile (val (val $InFiles)))) chr)
  %10 = getelementptr i8, i8* %9, i32 12
  %11 = bitcast i8* %10 to i32*
  %12 = load i32, i32* %11
  store i32 %12, i32* @$Chr
  br label %$5
$5:
; # (when In (let In: (inFile @) (free (In: name)) (In: name null) (I...
  %13 = icmp ne i8* %5, null
  br i1 %13, label %$6, label %$7
$6:
; # (let In: (inFile @) (free (In: name)) (In: name null) (In: fd -1)...
; # (In: name)
  %14 = bitcast i8* %5 to i8**
  %15 = load i8*, i8** %14
; # (free (In: name))
  call void @free(i8* %15)
; # (In: name null)
  %16 = bitcast i8* %5 to i8**
  store i8* null, i8** %16
; # (In: fd -1)
  %17 = getelementptr i8, i8* %5, i32 8
  %18 = bitcast i8* %17 to i32*
  store i32 -1, i32* %18
  br label %$7
$7:
  br label %$3
$3:
  ret void
}

define void @closeOutFile(i32) align 8 {
$1:
; # (when (> (val $OutFDs) Fd) (let (P (ofs (val $OutFiles) Fd) Out (...
; # (val $OutFDs)
  %1 = load i32, i32* @$OutFDs
; # (> (val $OutFDs) Fd)
  %2 = icmp sgt i32 %1, %0
  br i1 %2, label %$2, label %$3
$2:
; # (let (P (ofs (val $OutFiles) Fd) Out (val P)) (when (== Out (val ...
; # (val $OutFiles)
  %3 = load i8**, i8*** @$OutFiles
; # (ofs (val $OutFiles) Fd)
  %4 = getelementptr i8*, i8** %3, i32 %0
; # (val P)
  %5 = load i8*, i8** %4
; # (when (== Out (val $OutFile)) (set $OutFile (val 2 (val $OutFiles...
; # (val $OutFile)
  %6 = load i8*, i8** @$OutFile
; # (== Out (val $OutFile))
  %7 = icmp eq i8* %5, %6
  br i1 %7, label %$4, label %$5
$4:
; # (set $OutFile (val 2 (val $OutFiles)))
; # (val $OutFiles)
  %8 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %9 = getelementptr i8*, i8** %8, i32 1
  %10 = load i8*, i8** %9
  store i8* %10, i8** @$OutFile
  br label %$5
$5:
; # (when Out ((outFile @) fd -1))
  %11 = icmp ne i8* %5, null
  br i1 %11, label %$6, label %$7
$6:
; # ((outFile @) fd -1)
  %12 = bitcast i8* %5 to i32*
  store i32 -1, i32* %12
  br label %$7
$7:
  br label %$3
$3:
  ret void
}

define i32 @slow(i8*) align 8 {
$1:
; # (let In: (inFile In) (In: ix 0) (loop (? (ge0 (i32 (read (In: fd)...
; # (In: ix 0)
  %1 = getelementptr i8, i8* %0, i32 24
  %2 = bitcast i8* %1 to i32*
  store i32 0, i32* %2
; # (loop (? (ge0 (i32 (read (In: fd) (In: (buf)) BUFSIZ))) (In: cnt ...
  br label %$2
$2:
; # (? (ge0 (i32 (read (In: fd) (In: (buf)) BUFSIZ))) (In: cnt @))
; # (In: fd)
  %3 = getelementptr i8, i8* %0, i32 8
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (In: (buf))
  %6 = getelementptr i8, i8* %0, i32 32
; # (read (In: fd) (In: (buf)) BUFSIZ)
  %7 = call i64 @read(i32 %5, i8* %6, i64 4096)
; # (i32 (read (In: fd) (In: (buf)) BUFSIZ))
  %8 = trunc i64 %7 to i32
; # (ge0 (i32 (read (In: fd) (In: (buf)) BUFSIZ)))
  %9 = icmp sge i32 %8, 0
  br i1 %9, label %$5, label %$3
$5:
; # (In: cnt @)
  %10 = getelementptr i8, i8* %0, i32 28
  %11 = bitcast i8* %10 to i32*
  store i32 %8, i32* %11
  br label %$4
$3:
; # (? (<> (gErrno) EINTR) (In: cnt 0))
; # (gErrno)
  %12 = call i32 @gErrno()
; # (<> (gErrno) EINTR)
  %13 = icmp ne i32 %12, 2
  br i1 %13, label %$7, label %$6
$7:
; # (In: cnt 0)
  %14 = getelementptr i8, i8* %0, i32 28
  %15 = bitcast i8* %14 to i32*
  store i32 0, i32* %15
  br label %$4
$6:
; # (sigChk 0)
  %16 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %$8, label %$9
$8:
  call void @sighandler(i64 0)
  br label %$9
$9:
  br label %$2
$4:
  %18 = phi i32 [%8, %$5], [0, %$7] ; # ->
  ret i32 %18
}

define i32 @slowNb(i8*) align 8 {
$1:
; # (let In: (inFile In) (loop (let (Flg (nonBlocking (In: fd)) N (i3...
; # (loop (let (Flg (nonBlocking (In: fd)) N (i32 (read (In: fd) (In:...
  br label %$2
$2:
; # (let (Flg (nonBlocking (In: fd)) N (i32 (read (In: fd) (In: (buf)...
; # (In: fd)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (nonBlocking (In: fd))
  %4 = call i32 @nonBlocking(i32 %3)
; # (In: fd)
  %5 = getelementptr i8, i8* %0, i32 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
; # (In: (buf))
  %8 = getelementptr i8, i8* %0, i32 32
; # (read (In: fd) (In: (buf)) BUFSIZ)
  %9 = call i64 @read(i32 %7, i8* %8, i64 4096)
; # (i32 (read (In: fd) (In: (buf)) BUFSIZ))
  %10 = trunc i64 %9 to i32
; # (In: fd)
  %11 = getelementptr i8, i8* %0, i32 8
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
; # (fcntlSetFl (In: fd) Flg)
  call void @fcntlSetFl(i32 %13, i32 %4)
; # (? (gt0 N) (In: ix 0) (In: cnt N))
; # (gt0 N)
  %14 = icmp sgt i32 %10, 0
  br i1 %14, label %$5, label %$3
$5:
; # (In: ix 0)
  %15 = getelementptr i8, i8* %0, i32 24
  %16 = bitcast i8* %15 to i32*
  store i32 0, i32* %16
; # (In: cnt N)
  %17 = getelementptr i8, i8* %0, i32 28
  %18 = bitcast i8* %17 to i32*
  store i32 %10, i32* %18
  br label %$4
$3:
; # (? (=0 N) (In: ix (In: cnt -1)) 0)
; # (=0 N)
  %19 = icmp eq i32 %10, 0
  br i1 %19, label %$7, label %$6
$7:
; # (In: ix (In: cnt -1))
  %20 = getelementptr i8, i8* %0, i32 24
  %21 = bitcast i8* %20 to i32*
  %22 = getelementptr i8, i8* %0, i32 28
  %23 = bitcast i8* %22 to i32*
  store i32 -1, i32* %23
  store i32 -1, i32* %21
  br label %$4
$6:
; # (? (== (gErrno) EAGAIN) -1)
; # (gErrno)
  %24 = call i32 @gErrno()
; # (== (gErrno) EAGAIN)
  %25 = icmp eq i32 %24, 4
  br i1 %25, label %$9, label %$8
$9:
  br label %$4
$8:
; # (? (<> @ EINTR) (In: ix (In: cnt 0)))
; # (<> @ EINTR)
  %26 = icmp ne i32 %24, 2
  br i1 %26, label %$11, label %$10
$11:
; # (In: ix (In: cnt 0))
  %27 = getelementptr i8, i8* %0, i32 24
  %28 = bitcast i8* %27 to i32*
  %29 = getelementptr i8, i8* %0, i32 28
  %30 = bitcast i8* %29 to i32*
  store i32 0, i32* %30
  store i32 0, i32* %28
  br label %$4
$10:
; # (sigChk 0)
  %31 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %32 = icmp ne i32 %31, 0
  br i1 %32, label %$12, label %$13
$12:
  call void @sighandler(i64 0)
  br label %$13
$13:
  br label %$2
$4:
  %33 = phi i32 [%10, %$5], [0, %$7], [-1, %$9], [0, %$11] ; # ->
  ret i32 %33
}

define i1 @rdBytes(i32, i8*, i32) align 8 {
$1:
; # (loop (loop (? (gt0 (i32 (read Fd P (i64 Cnt)))) (inc 'P @) (dec ...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%37, %$13] ; # P
  %4 = phi i32 [%2, %$1], [%38, %$13] ; # Cnt
; # (loop (? (gt0 (i32 (read Fd P (i64 Cnt)))) (inc 'P @) (dec 'Cnt @...
  br label %$3
$3:
  %5 = phi i8* [%3, %$2], [%27, %$12] ; # P
  %6 = phi i32 [%4, %$2], [%28, %$12] ; # Cnt
; # (? (gt0 (i32 (read Fd P (i64 Cnt)))) (inc 'P @) (dec 'Cnt @))
; # (i64 Cnt)
  %7 = sext i32 %6 to i64
; # (read Fd P (i64 Cnt))
  %8 = call i64 @read(i32 %0, i8* %5, i64 %7)
; # (i32 (read Fd P (i64 Cnt)))
  %9 = trunc i64 %8 to i32
; # (gt0 (i32 (read Fd P (i64 Cnt))))
  %10 = icmp sgt i32 %9, 0
  br i1 %10, label %$6, label %$4
$6:
  %11 = phi i8* [%5, %$3] ; # P
  %12 = phi i32 [%6, %$3] ; # Cnt
; # (inc 'P @)
  %13 = getelementptr i8, i8* %11, i32 %9
; # (dec 'Cnt @)
  %14 = sub i32 %12, %9
  br label %$5
$4:
  %15 = phi i8* [%5, %$3] ; # P
  %16 = phi i32 [%6, %$3] ; # Cnt
; # (unless (and @ (== (gErrno) EINTR)) (ret NO))
; # (and @ (== (gErrno) EINTR))
  %17 = icmp ne i32 %9, 0
  br i1 %17, label %$8, label %$7
$8:
  %18 = phi i8* [%15, %$4] ; # P
  %19 = phi i32 [%16, %$4] ; # Cnt
; # (gErrno)
  %20 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %21 = icmp eq i32 %20, 2
  br label %$7
$7:
  %22 = phi i8* [%15, %$4], [%18, %$8] ; # P
  %23 = phi i32 [%16, %$4], [%19, %$8] ; # Cnt
  %24 = phi i1 [0, %$4], [%21, %$8] ; # ->
  br i1 %24, label %$10, label %$9
$9:
  %25 = phi i8* [%22, %$7] ; # P
  %26 = phi i32 [%23, %$7] ; # Cnt
; # (ret NO)
  ret i1 0
$10:
  %27 = phi i8* [%22, %$7] ; # P
  %28 = phi i32 [%23, %$7] ; # Cnt
; # (sigChk 0)
  %29 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %30 = icmp ne i32 %29, 0
  br i1 %30, label %$11, label %$12
$11:
  call void @sighandler(i64 0)
  br label %$12
$12:
  br label %$3
$5:
  %31 = phi i8* [%13, %$6] ; # P
  %32 = phi i32 [%14, %$6] ; # Cnt
  %33 = phi i32 [%14, %$6] ; # ->
; # (? (=0 Cnt) YES)
; # (=0 Cnt)
  %34 = icmp eq i32 %32, 0
  br i1 %34, label %$15, label %$13
$15:
  %35 = phi i8* [%31, %$5] ; # P
  %36 = phi i32 [%32, %$5] ; # Cnt
  br label %$14
$13:
  %37 = phi i8* [%31, %$5] ; # P
  %38 = phi i32 [%32, %$5] ; # Cnt
  br label %$2
$14:
  %39 = phi i8* [%35, %$15] ; # P
  %40 = phi i32 [%36, %$15] ; # Cnt
  %41 = phi i1 [1, %$15] ; # ->
  ret i1 %41
}

define i64 @rdBytesNb(i32, i8*, i32) align 8 {
$1:
; # (loop (let (Flg (nonBlocking Fd) N (i32 (read Fd P (i64 Cnt)))) (...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%75, %$25] ; # P
  %4 = phi i32 [%2, %$1], [%76, %$25] ; # Cnt
; # (let (Flg (nonBlocking Fd) N (i32 (read Fd P (i64 Cnt)))) (fcntlS...
; # (nonBlocking Fd)
  %5 = call i32 @nonBlocking(i32 %0)
; # (i64 Cnt)
  %6 = sext i32 %4 to i64
; # (read Fd P (i64 Cnt))
  %7 = call i64 @read(i32 %0, i8* %3, i64 %6)
; # (i32 (read Fd P (i64 Cnt)))
  %8 = trunc i64 %7 to i32
; # (fcntlSetFl Fd Flg)
  call void @fcntlSetFl(i32 %0, i32 %5)
; # (when (gt0 N) (loop (unless (dec 'Cnt N) (ret 1)) (inc 'P N) (whi...
; # (gt0 N)
  %9 = icmp sgt i32 %8, 0
  br i1 %9, label %$3, label %$4
$3:
  %10 = phi i8* [%3, %$2] ; # P
  %11 = phi i32 [%4, %$2] ; # Cnt
  %12 = phi i32 [%8, %$2] ; # N
; # (loop (unless (dec 'Cnt N) (ret 1)) (inc 'P N) (while (le0 (setq ...
  br label %$5
$5:
  %13 = phi i8* [%10, %$3], [%53, %$10] ; # P
  %14 = phi i32 [%11, %$3], [%54, %$10] ; # Cnt
  %15 = phi i32 [%12, %$3], [%55, %$10] ; # N
; # (unless (dec 'Cnt N) (ret 1))
; # (dec 'Cnt N)
  %16 = sub i32 %14, %15
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %$7, label %$6
$6:
  %18 = phi i8* [%13, %$5] ; # P
  %19 = phi i32 [%16, %$5] ; # Cnt
  %20 = phi i32 [%15, %$5] ; # N
; # (ret 1)
  ret i64 1
$7:
  %21 = phi i8* [%13, %$5] ; # P
  %22 = phi i32 [%16, %$5] ; # Cnt
  %23 = phi i32 [%15, %$5] ; # N
; # (inc 'P N)
  %24 = getelementptr i8, i8* %21, i32 %23
; # (while (le0 (setq N (i32 (read Fd P (i64 Cnt))))) (unless (and N ...
  br label %$8
$8:
  %25 = phi i8* [%24, %$7], [%48, %$16] ; # P
  %26 = phi i32 [%22, %$7], [%49, %$16] ; # Cnt
  %27 = phi i32 [%23, %$7], [%50, %$16] ; # N
; # (i64 Cnt)
  %28 = sext i32 %26 to i64
; # (read Fd P (i64 Cnt))
  %29 = call i64 @read(i32 %0, i8* %25, i64 %28)
; # (i32 (read Fd P (i64 Cnt)))
  %30 = trunc i64 %29 to i32
; # (le0 (setq N (i32 (read Fd P (i64 Cnt)))))
  %31 = icmp sle i32 %30, 0
  br i1 %31, label %$9, label %$10
$9:
  %32 = phi i8* [%25, %$8] ; # P
  %33 = phi i32 [%26, %$8] ; # Cnt
  %34 = phi i32 [%30, %$8] ; # N
; # (unless (and N (== (gErrno) EINTR)) (ret 0))
; # (and N (== (gErrno) EINTR))
  %35 = icmp ne i32 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  %36 = phi i8* [%32, %$9] ; # P
  %37 = phi i32 [%33, %$9] ; # Cnt
  %38 = phi i32 [%34, %$9] ; # N
; # (gErrno)
  %39 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %40 = icmp eq i32 %39, 2
  br label %$11
$11:
  %41 = phi i8* [%32, %$9], [%36, %$12] ; # P
  %42 = phi i32 [%33, %$9], [%37, %$12] ; # Cnt
  %43 = phi i32 [%34, %$9], [%38, %$12] ; # N
  %44 = phi i1 [0, %$9], [%40, %$12] ; # ->
  br i1 %44, label %$14, label %$13
$13:
  %45 = phi i8* [%41, %$11] ; # P
  %46 = phi i32 [%42, %$11] ; # Cnt
  %47 = phi i32 [%43, %$11] ; # N
; # (ret 0)
  ret i64 0
$14:
  %48 = phi i8* [%41, %$11] ; # P
  %49 = phi i32 [%42, %$11] ; # Cnt
  %50 = phi i32 [%43, %$11] ; # N
; # (sigChk 0)
  %51 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %52 = icmp ne i32 %51, 0
  br i1 %52, label %$15, label %$16
$15:
  call void @sighandler(i64 0)
  br label %$16
$16:
  br label %$8
$10:
  %53 = phi i8* [%25, %$8] ; # P
  %54 = phi i32 [%26, %$8] ; # Cnt
  %55 = phi i32 [%30, %$8] ; # N
  br label %$5
$4:
  %56 = phi i8* [%3, %$2] ; # P
  %57 = phi i32 [%4, %$2] ; # Cnt
  %58 = phi i32 [%8, %$2] ; # N
; # (? (=0 N) 0)
; # (=0 N)
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %$19, label %$17
$19:
  %60 = phi i8* [%56, %$4] ; # P
  %61 = phi i32 [%57, %$4] ; # Cnt
  %62 = phi i32 [%58, %$4] ; # N
  br label %$18
$17:
  %63 = phi i8* [%56, %$4] ; # P
  %64 = phi i32 [%57, %$4] ; # Cnt
  %65 = phi i32 [%58, %$4] ; # N
; # (? (== (gErrno) EAGAIN) -1)
; # (gErrno)
  %66 = call i32 @gErrno()
; # (== (gErrno) EAGAIN)
  %67 = icmp eq i32 %66, 4
  br i1 %67, label %$21, label %$20
$21:
  %68 = phi i8* [%63, %$17] ; # P
  %69 = phi i32 [%64, %$17] ; # Cnt
  br label %$18
$20:
  %70 = phi i8* [%63, %$17] ; # P
  %71 = phi i32 [%64, %$17] ; # Cnt
; # (? (<> @ EINTR) 0)
; # (<> @ EINTR)
  %72 = icmp ne i32 %66, 2
  br i1 %72, label %$23, label %$22
$23:
  %73 = phi i8* [%70, %$20] ; # P
  %74 = phi i32 [%71, %$20] ; # Cnt
  br label %$18
$22:
  %75 = phi i8* [%70, %$20] ; # P
  %76 = phi i32 [%71, %$20] ; # Cnt
; # (sigChk 0)
  %77 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %78 = icmp ne i32 %77, 0
  br i1 %78, label %$24, label %$25
$24:
  call void @sighandler(i64 0)
  br label %$25
$25:
  br label %$2
$18:
  %79 = phi i8* [%60, %$19], [%68, %$21], [%73, %$23] ; # P
  %80 = phi i32 [%61, %$19], [%69, %$21], [%74, %$23] ; # Cnt
  %81 = phi i64 [0, %$19], [-1, %$21], [0, %$23] ; # ->
  ret i64 %81
}

define i1 @wrBytes(i32, i8*, i32) align 8 {
$1:
; # (loop (let N (i32 (write Fd P (i64 Cnt))) (if (lt0 N) (let E (gEr...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%48, %$5] ; # P
  %4 = phi i32 [%2, %$1], [%49, %$5] ; # Cnt
; # (let N (i32 (write Fd P (i64 Cnt))) (if (lt0 N) (let E (gErrno) (...
; # (i64 Cnt)
  %5 = sext i32 %4 to i64
; # (write Fd P (i64 Cnt))
  %6 = call i64 @write(i32 %0, i8* %3, i64 %5)
; # (i32 (write Fd P (i64 Cnt)))
  %7 = trunc i64 %6 to i32
; # (if (lt0 N) (let E (gErrno) (? (== E EBADF) NO) (? (== E EPIPE) N...
; # (lt0 N)
  %8 = icmp slt i32 %7, 0
  br i1 %8, label %$3, label %$4
$3:
  %9 = phi i8* [%3, %$2] ; # P
  %10 = phi i32 [%4, %$2] ; # Cnt
; # (let E (gErrno) (? (== E EBADF) NO) (? (== E EPIPE) NO) (? (== E ...
; # (gErrno)
  %11 = call i32 @gErrno()
; # (? (== E EBADF) NO)
; # (== E EBADF)
  %12 = icmp eq i32 %11, 3
  br i1 %12, label %$8, label %$6
$8:
  %13 = phi i8* [%9, %$3] ; # P
  %14 = phi i32 [%10, %$3] ; # Cnt
  br label %$7
$6:
  %15 = phi i8* [%9, %$3] ; # P
  %16 = phi i32 [%10, %$3] ; # Cnt
; # (? (== E EPIPE) NO)
; # (== E EPIPE)
  %17 = icmp eq i32 %11, 6
  br i1 %17, label %$10, label %$9
$10:
  %18 = phi i8* [%15, %$6] ; # P
  %19 = phi i32 [%16, %$6] ; # Cnt
  br label %$7
$9:
  %20 = phi i8* [%15, %$6] ; # P
  %21 = phi i32 [%16, %$6] ; # Cnt
; # (? (== E ECONNRESET) NO)
; # (== E ECONNRESET)
  %22 = icmp eq i32 %11, 7
  br i1 %22, label %$12, label %$11
$12:
  %23 = phi i8* [%20, %$9] ; # P
  %24 = phi i32 [%21, %$9] ; # Cnt
  br label %$7
$11:
  %25 = phi i8* [%20, %$9] ; # P
  %26 = phi i32 [%21, %$9] ; # Cnt
; # (unless (== E EINTR) (when (== Fd 2) (bye 2)) (writeErr ($ "bytes...
; # (== E EINTR)
  %27 = icmp eq i32 %11, 2
  br i1 %27, label %$14, label %$13
$13:
  %28 = phi i8* [%25, %$11] ; # P
  %29 = phi i32 [%26, %$11] ; # Cnt
; # (when (== Fd 2) (bye 2))
; # (== Fd 2)
  %30 = icmp eq i32 %0, 2
  br i1 %30, label %$15, label %$16
$15:
  %31 = phi i8* [%28, %$13] ; # P
  %32 = phi i32 [%29, %$13] ; # Cnt
; # (bye 2)
  call void @bye(i32 2)
  unreachable
$16:
  %33 = phi i8* [%28, %$13] ; # P
  %34 = phi i32 [%29, %$13] ; # Cnt
; # (writeErr ($ "bytes write: %s"))
  call void @writeErr(i8* bitcast ([16 x i8]* @$37 to i8*))
  unreachable
$14:
  %35 = phi i8* [%25, %$11] ; # P
  %36 = phi i32 [%26, %$11] ; # Cnt
; # (sigChk 0)
  %37 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %$17, label %$18
$17:
  call void @sighandler(i64 0)
  br label %$18
$18:
  br label %$5
$4:
  %39 = phi i8* [%3, %$2] ; # P
  %40 = phi i32 [%4, %$2] ; # Cnt
; # (? (=0 (dec 'Cnt N)) YES)
; # (dec 'Cnt N)
  %41 = sub i32 %40, %7
; # (=0 (dec 'Cnt N))
  %42 = icmp eq i32 %41, 0
  br i1 %42, label %$20, label %$19
$20:
  %43 = phi i8* [%39, %$4] ; # P
  %44 = phi i32 [%41, %$4] ; # Cnt
  br label %$7
$19:
  %45 = phi i8* [%39, %$4] ; # P
  %46 = phi i32 [%41, %$4] ; # Cnt
; # (inc 'P N)
  %47 = getelementptr i8, i8* %45, i32 %7
  br label %$5
$5:
  %48 = phi i8* [%35, %$18], [%47, %$19] ; # P
  %49 = phi i32 [%36, %$18], [%46, %$19] ; # Cnt
  br label %$2
$7:
  %50 = phi i8* [%13, %$8], [%18, %$10], [%23, %$12], [%43, %$20] ; # P
  %51 = phi i32 [%14, %$8], [%19, %$10], [%24, %$12], [%44, %$20] ; # Cnt
  %52 = phi i1 [0, %$8], [0, %$10], [0, %$12], [1, %$20] ; # ->
  ret i1 %52
}

define void @clsChild(i8*) align 8 {
$1:
; # (let Cld: (child Cld) (when (== (Cld: pid) (val $Talking)) (set $...
; # (when (== (Cld: pid) (val $Talking)) (set $Talking 0))
; # (Cld: pid)
  %1 = getelementptr i8, i8* %0, i32 16
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (val $Talking)
  %4 = load i32, i32* @$Talking
; # (== (Cld: pid) (val $Talking))
  %5 = icmp eq i32 %3, %4
  br i1 %5, label %$2, label %$3
$2:
; # (set $Talking 0)
  store i32 0, i32* @$Talking
  br label %$3
$3:
; # (Cld: pid 0)
  %6 = getelementptr i8, i8* %0, i32 16
  %7 = bitcast i8* %6 to i32*
  store i32 0, i32* %7
; # (Cld: hear)
  %8 = getelementptr i8, i8* %0, i32 20
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (close (Cld: hear))
  %11 = call i32 @close(i32 %10)
; # (Cld: tell)
  %12 = getelementptr i8, i8* %0, i32 24
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13
; # (close (Cld: tell))
  %15 = call i32 @close(i32 %14)
; # (Cld: buf)
  %16 = bitcast i8* %0 to i8**
  %17 = load i8*, i8** %16
; # (free (Cld: buf))
  call void @free(i8* %17)
  ret void
}

define void @wrChild(i8*, i8*, i32) align 8 {
$1:
; # (let (Cld: (child Cld) C (Cld: cnt)) (unless C (loop (let N (i32 ...
; # (Cld: cnt)
  %3 = getelementptr i8, i8* %0, i32 12
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (unless C (loop (let N (i32 (write (Cld: tell) P (i64 Cnt))) (if ...
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i8* [%1, %$1] ; # P
  %8 = phi i32 [%2, %$1] ; # Cnt
; # (loop (let N (i32 (write (Cld: tell) P (i64 Cnt))) (if (lt0 N) (l...
  br label %$4
$4:
  %9 = phi i8* [%7, %$2], [%49, %$7] ; # P
  %10 = phi i32 [%8, %$2], [%50, %$7] ; # Cnt
; # (let N (i32 (write (Cld: tell) P (i64 Cnt))) (if (lt0 N) (let E (...
; # (Cld: tell)
  %11 = getelementptr i8, i8* %0, i32 24
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
; # (i64 Cnt)
  %14 = sext i32 %10 to i64
; # (write (Cld: tell) P (i64 Cnt))
  %15 = call i64 @write(i32 %13, i8* %9, i64 %14)
; # (i32 (write (Cld: tell) P (i64 Cnt)))
  %16 = trunc i64 %15 to i32
; # (if (lt0 N) (let E (gErrno) (? (== E EAGAIN)) (when (or (== E EPI...
; # (lt0 N)
  %17 = icmp slt i32 %16, 0
  br i1 %17, label %$5, label %$6
$5:
  %18 = phi i8* [%9, %$4] ; # P
  %19 = phi i32 [%10, %$4] ; # Cnt
; # (let E (gErrno) (? (== E EAGAIN)) (when (or (== E EPIPE) (== E EC...
; # (gErrno)
  %20 = call i32 @gErrno()
; # (? (== E EAGAIN))
; # (== E EAGAIN)
  %21 = icmp eq i32 %20, 4
  br i1 %21, label %$9, label %$8
$8:
  %22 = phi i8* [%18, %$5] ; # P
  %23 = phi i32 [%19, %$5] ; # Cnt
; # (when (or (== E EPIPE) (== E ECONNRESET)) (clsChild Cld) (ret))
; # (or (== E EPIPE) (== E ECONNRESET))
; # (== E EPIPE)
  %24 = icmp eq i32 %20, 6
  br i1 %24, label %$10, label %$11
$11:
  %25 = phi i8* [%22, %$8] ; # P
  %26 = phi i32 [%23, %$8] ; # Cnt
; # (== E ECONNRESET)
  %27 = icmp eq i32 %20, 7
  br label %$10
$10:
  %28 = phi i8* [%22, %$8], [%25, %$11] ; # P
  %29 = phi i32 [%23, %$8], [%26, %$11] ; # Cnt
  %30 = phi i1 [1, %$8], [%27, %$11] ; # ->
  br i1 %30, label %$12, label %$13
$12:
  %31 = phi i8* [%28, %$10] ; # P
  %32 = phi i32 [%29, %$10] ; # Cnt
; # (clsChild Cld)
  call void @clsChild(i8* %0)
; # (ret)
  ret void
$13:
  %33 = phi i8* [%28, %$10] ; # P
  %34 = phi i32 [%29, %$10] ; # Cnt
; # (unless (== E EINTR) (writeErr ($ "child write: %s")))
; # (== E EINTR)
  %35 = icmp eq i32 %20, 2
  br i1 %35, label %$15, label %$14
$14:
  %36 = phi i8* [%33, %$13] ; # P
  %37 = phi i32 [%34, %$13] ; # Cnt
; # (writeErr ($ "child write: %s"))
  call void @writeErr(i8* bitcast ([16 x i8]* @$38 to i8*))
  unreachable
$15:
  %38 = phi i8* [%33, %$13] ; # P
  %39 = phi i32 [%34, %$13] ; # Cnt
  br label %$7
$6:
  %40 = phi i8* [%9, %$4] ; # P
  %41 = phi i32 [%10, %$4] ; # Cnt
; # (unless (dec 'Cnt N) (ret))
; # (dec 'Cnt N)
  %42 = sub i32 %41, %16
  %43 = icmp ne i32 %42, 0
  br i1 %43, label %$17, label %$16
$16:
  %44 = phi i8* [%40, %$6] ; # P
  %45 = phi i32 [%42, %$6] ; # Cnt
; # (ret)
  ret void
$17:
  %46 = phi i8* [%40, %$6] ; # P
  %47 = phi i32 [%42, %$6] ; # Cnt
; # (inc 'P N)
  %48 = getelementptr i8, i8* %46, i32 %16
  br label %$7
$7:
  %49 = phi i8* [%38, %$15], [%48, %$17] ; # P
  %50 = phi i32 [%39, %$15], [%47, %$17] ; # Cnt
  br label %$4
$9:
  %51 = phi i8* [%18, %$5] ; # P
  %52 = phi i32 [%19, %$5] ; # Cnt
  %53 = phi i64 [0, %$5] ; # ->
  br label %$3
$3:
  %54 = phi i8* [%1, %$1], [%51, %$9] ; # P
  %55 = phi i32 [%2, %$1], [%52, %$9] ; # Cnt
; # (let Siz (+ C Cnt 4) (when (> Siz (hex "3FFFFFFF")) (sizeErr 0)) ...
; # (+ C Cnt 4)
  %56 = add i32 %5, %55
  %57 = add i32 %56, 4
; # (when (> Siz (hex "3FFFFFFF")) (sizeErr 0))
; # (> Siz (hex "3FFFFFFF"))
  %58 = icmp sgt i32 %57, 1073741823
  br i1 %58, label %$18, label %$19
$18:
  %59 = phi i8* [%54, %$3] ; # P
  %60 = phi i32 [%55, %$3] ; # Cnt
; # (sizeErr 0)
  call void @sizeErr(i64 0)
  unreachable
$19:
  %61 = phi i8* [%54, %$3] ; # P
  %62 = phi i32 [%55, %$3] ; # Cnt
; # (let Q (ofs (Cld: buf (alloc (Cld: buf) (i64 Siz))) C) (set (i32*...
; # (Cld: buf (alloc (Cld: buf) (i64 Siz)))
  %63 = bitcast i8* %0 to i8**
  %64 = bitcast i8* %0 to i8**
  %65 = load i8*, i8** %64
  %66 = sext i32 %57 to i64
  %67 = call i8* @alloc(i8* %65, i64 %66)
  store i8* %67, i8** %63
; # (ofs (Cld: buf (alloc (Cld: buf) (i64 Siz))) C)
  %68 = getelementptr i8, i8* %67, i32 %5
; # (set (i32* Q) Cnt)
; # (i32* Q)
  %69 = bitcast i8* %68 to i32*
  store i32 %62, i32* %69
; # (ofs Q 4)
  %70 = getelementptr i8, i8* %68, i32 4
; # (i64 Cnt)
  %71 = sext i32 %62 to i64
; # (memcpy (ofs Q 4) P (i64 Cnt))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %70, i8* %61, i64 %71, i1 0)
; # (Cld: cnt Siz)
  %72 = getelementptr i8, i8* %0, i32 12
  %73 = bitcast i8* %72 to i32*
  store i32 %57, i32* %73
  ret void
}

define i1 @flush(i8*) align 8 {
$1:
; # (ifn Out YES (let Out: (outFile Out) (ifn (Out: ix) YES (Out: ix ...
  %1 = icmp ne i8* %0, null
  br i1 %1, label %$3, label %$2
$2:
  br label %$4
$3:
; # (let Out: (outFile Out) (ifn (Out: ix) YES (Out: ix 0) (wrBytes (...
; # (ifn (Out: ix) YES (Out: ix 0) (wrBytes (Out: fd) (Out: (buf)) @)...
; # (Out: ix)
  %2 = getelementptr i8, i8* %0, i32 4
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %$6, label %$5
$5:
  br label %$7
$6:
; # (Out: ix 0)
  %6 = getelementptr i8, i8* %0, i32 4
  %7 = bitcast i8* %6 to i32*
  store i32 0, i32* %7
; # (Out: fd)
  %8 = bitcast i8* %0 to i32*
  %9 = load i32, i32* %8
; # (Out: (buf))
  %10 = getelementptr i8, i8* %0, i32 8
; # (wrBytes (Out: fd) (Out: (buf)) @)
  %11 = call i1 @wrBytes(i32 %9, i8* %10, i32 %4)
  br label %$7
$7:
  %12 = phi i1 [1, %$5], [%11, %$6] ; # ->
  br label %$4
$4:
  %13 = phi i1 [1, %$2], [%12, %$7] ; # ->
  ret i1 %13
}

define void @flushAll() align 8 {
$1:
; # (let (A (val $OutFiles) N (val $OutFDs) I (i32 0)) (while (> N I)...
; # (val $OutFiles)
  %0 = load i8**, i8*** @$OutFiles
; # (val $OutFDs)
  %1 = load i32, i32* @$OutFDs
; # (i32 0)
; # (while (> N I) (flush (val (ofs A I))) (inc 'I))
  br label %$2
$2:
  %2 = phi i32 [0, %$1], [%8, %$3] ; # I
; # (> N I)
  %3 = icmp sgt i32 %1, %2
  br i1 %3, label %$3, label %$4
$3:
  %4 = phi i32 [%2, %$2] ; # I
; # (ofs A I)
  %5 = getelementptr i8*, i8** %0, i32 %4
; # (val (ofs A I))
  %6 = load i8*, i8** %5
; # (flush (val (ofs A I)))
  %7 = call i1 @flush(i8* %6)
; # (inc 'I)
  %8 = add i32 %4, 1
  br label %$2
$4:
  %9 = phi i32 [%2, %$2] ; # I
  ret void
}

define i32 @stdinByte() align 8 {
$1:
; # (let In: (inFile (val (val $InFiles))) (cond ((and (ge0 (In: fd))...
; # (val $InFiles)
  %0 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %1 = load i8*, i8** %0
; # (cond ((and (ge0 (In: fd)) (or (<> (In: ix) (In: cnt)) (and (ge0 ...
; # (and (ge0 (In: fd)) (or (<> (In: ix) (In: cnt)) (and (ge0 @) (slo...
; # (In: fd)
  %2 = getelementptr i8, i8* %1, i32 8
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3
; # (ge0 (In: fd))
  %5 = icmp sge i32 %4, 0
  br i1 %5, label %$4, label %$3
$4:
; # (or (<> (In: ix) (In: cnt)) (and (ge0 @) (slow (In:))))
; # (In: ix)
  %6 = getelementptr i8, i8* %1, i32 24
  %7 = bitcast i8* %6 to i32*
  %8 = load i32, i32* %7
; # (In: cnt)
  %9 = getelementptr i8, i8* %1, i32 28
  %10 = bitcast i8* %9 to i32*
  %11 = load i32, i32* %10
; # (<> (In: ix) (In: cnt))
  %12 = icmp ne i32 %8, %11
  br i1 %12, label %$5, label %$6
$6:
; # (and (ge0 @) (slow (In:)))
; # (ge0 @)
  %13 = icmp sge i32 %8, 0
  br i1 %13, label %$8, label %$7
$8:
; # (In:)
; # (slow (In:))
  %14 = call i32 @slow(i8* %1)
  %15 = icmp ne i32 %14, 0
  br label %$7
$7:
  %16 = phi i1 [0, %$6], [%15, %$8] ; # ->
  br label %$5
$5:
  %17 = phi i1 [1, %$4], [%16, %$7] ; # ->
  br label %$3
$3:
  %18 = phi i1 [0, %$1], [%17, %$5] ; # ->
  br i1 %18, label %$10, label %$9
$10:
; # (let I (In: ix) (In: ix (+ I 1)) (i32 (val (ofs (In: (buf)) I))))...
; # (In: ix)
  %19 = getelementptr i8, i8* %1, i32 24
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* %20
; # (In: ix (+ I 1))
  %22 = getelementptr i8, i8* %1, i32 24
  %23 = bitcast i8* %22 to i32*
  %24 = add i32 %21, 1
  store i32 %24, i32* %23
; # (In: (buf))
  %25 = getelementptr i8, i8* %1, i32 32
; # (ofs (In: (buf)) I)
  %26 = getelementptr i8, i8* %25, i32 %21
; # (val (ofs (In: (buf)) I))
  %27 = load i8, i8* %26
; # (i32 (val (ofs (In: (buf)) I)))
  %28 = zext i8 %27 to i32
  br label %$2
$9:
; # (In: tty)
  %29 = getelementptr i8, i8* %1, i32 4128
  %30 = bitcast i8* %29 to i1*
  %31 = load i1, i1* %30
  br i1 %31, label %$12, label %$11
$12:
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$11:
  br label %$2
$2:
  %32 = phi i32 [%28, %$10], [-1, %$11] ; # ->
  ret i32 %32
}

define i32 @getBinary() align 8 {
$1:
; # (let (In: (inFile (val $InFile)) I (In: ix)) (when (== I (In: cnt...
; # (val $InFile)
  %0 = load i8*, i8** @$InFile
; # (In: ix)
  %1 = getelementptr i8, i8* %0, i32 24
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (when (== I (In: cnt)) (when (or (lt0 I) (=0 (slow (In:)))) (ret ...
; # (In: cnt)
  %4 = getelementptr i8, i8* %0, i32 28
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5
; # (== I (In: cnt))
  %7 = icmp eq i32 %3, %6
  br i1 %7, label %$2, label %$3
$2:
  %8 = phi i32 [%3, %$1] ; # I
; # (when (or (lt0 I) (=0 (slow (In:)))) (ret -1))
; # (or (lt0 I) (=0 (slow (In:))))
; # (lt0 I)
  %9 = icmp slt i32 %8, 0
  br i1 %9, label %$4, label %$5
$5:
  %10 = phi i32 [%8, %$2] ; # I
; # (In:)
; # (slow (In:))
  %11 = call i32 @slow(i8* %0)
; # (=0 (slow (In:)))
  %12 = icmp eq i32 %11, 0
  br label %$4
$4:
  %13 = phi i32 [%8, %$2], [%10, %$5] ; # I
  %14 = phi i1 [1, %$2], [%12, %$5] ; # ->
  br i1 %14, label %$6, label %$7
$6:
  %15 = phi i32 [%13, %$4] ; # I
; # (ret -1)
  ret i32 -1
$7:
  %16 = phi i32 [%13, %$4] ; # I
  br label %$3
$3:
  %17 = phi i32 [%3, %$1], [0, %$7] ; # I
; # (In: ix (+ I 1))
  %18 = getelementptr i8, i8* %0, i32 24
  %19 = bitcast i8* %18 to i32*
  %20 = add i32 %17, 1
  store i32 %20, i32* %19
; # (In: (buf))
  %21 = getelementptr i8, i8* %0, i32 32
; # (ofs (In: (buf)) I)
  %22 = getelementptr i8, i8* %21, i32 %17
; # (val (ofs (In: (buf)) I))
  %23 = load i8, i8* %22
; # (i32 (val (ofs (In: (buf)) I)))
  %24 = zext i8 %23 to i32
  ret i32 %24
}

define i64 @binRead() align 8 {
$1:
; # (case (call $GetBin) (NIX $Nil) (BEG (ifn (binRead) 0 (let (X (co...
; # (call $GetBin)
  %0 = load i32()*, i32()** @$GetBin
  %1 = call i32 %0()
  switch i32 %1, label %$2 [
    i32 0, label %$4
    i32 1, label %$5
    i32 2, label %$6
    i32 3, label %$7
  ]
$4:
  br label %$3
$5:
; # (ifn (binRead) 0 (let (X (cons @ $Nil) R (save X)) (loop (? (=0 (...
; # (binRead)
  %2 = call i64 @binRead()
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$9, label %$8
$8:
  br label %$10
$9:
; # (let (X (cons @ $Nil) R (save X)) (loop (? (=0 (binRead)) @) (? (...
; # (cons @ $Nil)
  %4 = call i64 @cons(i64 %2, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save X)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (loop (? (=0 (binRead)) @) (? (== @ END) R) (? (== @ -ZERO) (ifn ...
  br label %$11
$11:
  %13 = phi i64 [%4, %$9], [%37, %$17] ; # X
; # (? (=0 (binRead)) @)
; # (binRead)
  %14 = call i64 @binRead()
; # (=0 (binRead))
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$14, label %$12
$14:
  %16 = phi i64 [%13, %$11] ; # X
  br label %$13
$12:
  %17 = phi i64 [%13, %$11] ; # X
; # (? (== @ END) R)
; # (== @ END)
  %18 = icmp eq i64 %14, 3
  br i1 %18, label %$16, label %$15
$16:
  %19 = phi i64 [%17, %$12] ; # X
  br label %$13
$15:
  %20 = phi i64 [%17, %$12] ; # X
; # (? (== @ -ZERO) (ifn (binRead) 0 (set 2 X (if (== @ END) R @)) R)...
; # (== @ -ZERO)
  %21 = icmp eq i64 %14, 10
  br i1 %21, label %$18, label %$17
$18:
  %22 = phi i64 [%20, %$15] ; # X
; # (ifn (binRead) 0 (set 2 X (if (== @ END) R @)) R)
; # (binRead)
  %23 = call i64 @binRead()
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$20, label %$19
$19:
  %25 = phi i64 [%22, %$18] ; # X
  br label %$21
$20:
  %26 = phi i64 [%22, %$18] ; # X
; # (set 2 X (if (== @ END) R @))
; # (if (== @ END) R @)
; # (== @ END)
  %27 = icmp eq i64 %23, 3
  br i1 %27, label %$22, label %$23
$22:
  %28 = phi i64 [%26, %$20] ; # X
  br label %$24
$23:
  %29 = phi i64 [%26, %$20] ; # X
  br label %$24
$24:
  %30 = phi i64 [%28, %$22], [%29, %$23] ; # X
  %31 = phi i64 [%4, %$22], [%23, %$23] ; # ->
  %32 = inttoptr i64 %26 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %31, i64* %33
  br label %$21
$21:
  %34 = phi i64 [%25, %$19], [%30, %$24] ; # X
  %35 = phi i64 [0, %$19], [%4, %$24] ; # ->
  br label %$13
$17:
  %36 = phi i64 [%20, %$15] ; # X
; # (set 2 X (cons @ $Nil))
; # (cons @ $Nil)
  %37 = call i64 @cons(i64 %14, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %38 = inttoptr i64 %36 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  store i64 %37, i64* %39
  br label %$11
$13:
  %40 = phi i64 [%16, %$14], [%19, %$16], [%34, %$21] ; # X
  %41 = phi i64 [%14, %$14], [%4, %$16], [%35, %$21] ; # ->
; # (drop *Safe)
  %42 = inttoptr i64 %8 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %45
  br label %$10
$10:
  %46 = phi i64 [0, %$8], [%41, %$13] ; # ->
  br label %$3
$6:
  br label %$3
$7:
; # (i64 @)
  %47 = sext i32 %1 to i64
  br label %$3
$2:
; # (if (lt0 @) 0 (let (Tag (& @ 3) Cnt (shr @ 2) P (i64* (push NIL N...
; # (lt0 @)
  %48 = icmp slt i32 %1, 0
  br i1 %48, label %$25, label %$26
$25:
  br label %$27
$26:
; # (let (Tag (& @ 3) Cnt (shr @ 2) P (i64* (push NIL NIL ZERO NIL)) ...
; # (& @ 3)
  %49 = and i32 %1, 3
; # (shr @ 2)
  %50 = lshr i32 %1, 2
; # (push NIL NIL ZERO NIL)
  %51 = alloca i64, i64 4, align 16
  %52 = ptrtoint i64* %51 to i64
  %53 = add i64 %52, 16
  %54 = inttoptr i64 %53 to i64*
  store i64 2, i64* %54
; # (i64* (push NIL NIL ZERO NIL))
  %55 = inttoptr i64 %52 to i64*
; # (ofs P 2)
  %56 = getelementptr i64, i64* %55, i32 2
; # (link (ofs P 2))
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 %57 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %59, i64* %61
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %62
; # (cond ((== Tag NUMBER) (set P 3) (when (== Cnt 63) (loop (loop (w...
; # (== Tag NUMBER)
  %63 = icmp eq i32 %49, 0
  br i1 %63, label %$30, label %$29
$30:
  %64 = phi i32 [%50, %$26] ; # Cnt
; # (set P 3)
  store i64 3, i64* %55
; # (when (== Cnt 63) (loop (loop (when (lt0 (call $GetBin)) (: 1 (dr...
; # (== Cnt 63)
  %65 = icmp eq i32 %64, 63
  br i1 %65, label %$31, label %$32
$31:
  %66 = phi i32 [%64, %$30] ; # Cnt
; # (loop (loop (when (lt0 (call $GetBin)) (: 1 (drop Q) (ret 0))) (b...
  br label %$33
$33:
  %67 = phi i32 [%66, %$31], [%91, %$41] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (: 1 (drop Q) (ret 0))) (byteNum...
  br label %$34
$34:
  %68 = phi i32 [%67, %$33], [%82, %$37] ; # Cnt
; # (when (lt0 (call $GetBin)) (: 1 (drop Q) (ret 0)))
; # (call $GetBin)
  %69 = load i32()*, i32()** @$GetBin
  %70 = call i32 %69()
; # (lt0 (call $GetBin))
  %71 = icmp slt i32 %70, 0
  br i1 %71, label %$35, label %$36
$35:
  %72 = phi i32 [%68, %$34] ; # Cnt
; # (: 1 (drop Q) (ret 0))
  br label %$-1
$-1:
  %73 = phi i32 [%72, %$35], [%88, %$39], [%102, %$46], [%138, %$57], [%149, %$61], [%163, %$68] ; # Cnt
; # (drop Q)
  %74 = inttoptr i64 %57 to i64*
  %75 = getelementptr i64, i64* %74, i32 1
  %76 = load i64, i64* %75
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %76, i64* %77
; # (ret 0)
  ret i64 0
$36:
  %78 = phi i32 [%68, %$34] ; # Cnt
; # (i8 @)
  %79 = trunc i32 %70 to i8
; # (byteNum (i8 @) P)
  call void @byteNum(i8 %79, i64* %55)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %80 = sub i32 %78, 1
; # (=0 (dec 'Cnt))
  %81 = icmp eq i32 %80, 0
  br i1 %81, label %$38, label %$37
$37:
  %82 = phi i32 [%80, %$36] ; # Cnt
  br label %$34
$38:
  %83 = phi i32 [%80, %$36] ; # Cnt
  %84 = phi i64 [0, %$36] ; # ->
; # (when (lt0 (setq Cnt (call $GetBin))) (goto 1))
; # (call $GetBin)
  %85 = load i32()*, i32()** @$GetBin
  %86 = call i32 %85()
; # (lt0 (setq Cnt (call $GetBin)))
  %87 = icmp slt i32 %86, 0
  br i1 %87, label %$39, label %$40
$39:
  %88 = phi i32 [%86, %$38] ; # Cnt
; # (goto 1)
  br label %$-1
$40:
  %89 = phi i32 [%86, %$38] ; # Cnt
; # (? (<> Cnt 255))
; # (<> Cnt 255)
  %90 = icmp ne i32 %89, 255
  br i1 %90, label %$42, label %$41
$41:
  %91 = phi i32 [%89, %$40] ; # Cnt
  br label %$33
$42:
  %92 = phi i32 [%89, %$40] ; # Cnt
  %93 = phi i64 [0, %$40] ; # ->
; # (unless Cnt (goto 2))
  %94 = icmp ne i32 %92, 0
  br i1 %94, label %$44, label %$43
$43:
  %95 = phi i32 [%92, %$42] ; # Cnt
; # (goto 2)
  br label %$-2
$44:
  %96 = phi i32 [%92, %$42] ; # Cnt
  br label %$32
$32:
  %97 = phi i32 [%64, %$30], [%96, %$44] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (goto 1)) (byteNum (i8 @) P) (? ...
  br label %$45
$45:
  %98 = phi i32 [%97, %$32], [%107, %$48] ; # Cnt
; # (when (lt0 (call $GetBin)) (goto 1))
; # (call $GetBin)
  %99 = load i32()*, i32()** @$GetBin
  %100 = call i32 %99()
; # (lt0 (call $GetBin))
  %101 = icmp slt i32 %100, 0
  br i1 %101, label %$46, label %$47
$46:
  %102 = phi i32 [%98, %$45] ; # Cnt
; # (goto 1)
  br label %$-1
$47:
  %103 = phi i32 [%98, %$45] ; # Cnt
; # (i8 @)
  %104 = trunc i32 %100 to i8
; # (byteNum (i8 @) P)
  call void @byteNum(i8 %104, i64* %55)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %105 = sub i32 %103, 1
; # (=0 (dec 'Cnt))
  %106 = icmp eq i32 %105, 0
  br i1 %106, label %$49, label %$48
$48:
  %107 = phi i32 [%105, %$47] ; # Cnt
  br label %$45
$49:
  %108 = phi i32 [%105, %$47] ; # Cnt
  %109 = phi i64 [0, %$47] ; # ->
; # (: 2 (drop Q (if (cnt? (val Q)) @ (let S (& (val (dig @)) 1) (| (...
  br label %$-2
$-2:
  %110 = phi i32 [%95, %$43], [%108, %$49] ; # Cnt
; # (drop Q (if (cnt? (val Q)) @ (let S (& (val (dig @)) 1) (| (half ...
; # (if (cnt? (val Q)) @ (let S (& (val (dig @)) 1) (| (half @) (shl ...
; # (val Q)
  %111 = inttoptr i64 %57 to i64*
  %112 = load i64, i64* %111
; # (cnt? (val Q))
  %113 = and i64 %112, 2
  %114 = icmp ne i64 %113, 0
  br i1 %114, label %$50, label %$51
$50:
  %115 = phi i32 [%110, %$-2] ; # Cnt
  br label %$52
$51:
  %116 = phi i32 [%110, %$-2] ; # Cnt
; # (let S (& (val (dig @)) 1) (| (half @) (shl S 3)))
; # (dig @)
  %117 = add i64 %112, -4
; # (val (dig @))
  %118 = inttoptr i64 %117 to i64*
  %119 = load i64, i64* %118
; # (& (val (dig @)) 1)
  %120 = and i64 %119, 1
; # (half @)
  %121 = call i64 @half(i64 %112)
; # (shl S 3)
  %122 = shl i64 %120, 3
; # (| (half @) (shl S 3))
  %123 = or i64 %121, %122
  br label %$52
$52:
  %124 = phi i32 [%115, %$50], [%116, %$51] ; # Cnt
  %125 = phi i64 [%112, %$50], [%123, %$51] ; # ->
  %126 = inttoptr i64 %57 to i64*
  %127 = getelementptr i64, i64* %126, i32 1
  %128 = load i64, i64* %127
  %129 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %128, i64* %129
  br label %$28
$29:
  %130 = phi i32 [%50, %$26] ; # Cnt
; # (set P 4)
  store i64 4, i64* %55
; # (when (== Cnt 63) (loop (loop (when (lt0 (call $GetBin)) (goto 1)...
; # (== Cnt 63)
  %131 = icmp eq i32 %130, 63
  br i1 %131, label %$53, label %$54
$53:
  %132 = phi i32 [%130, %$29] ; # Cnt
; # (loop (loop (when (lt0 (call $GetBin)) (goto 1)) (byteSym (i8 @) ...
  br label %$55
$55:
  %133 = phi i32 [%132, %$53], [%152, %$63] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (goto 1)) (byteSym (i8 @) P) (? ...
  br label %$56
$56:
  %134 = phi i32 [%133, %$55], [%143, %$59] ; # Cnt
; # (when (lt0 (call $GetBin)) (goto 1))
; # (call $GetBin)
  %135 = load i32()*, i32()** @$GetBin
  %136 = call i32 %135()
; # (lt0 (call $GetBin))
  %137 = icmp slt i32 %136, 0
  br i1 %137, label %$57, label %$58
$57:
  %138 = phi i32 [%134, %$56] ; # Cnt
; # (goto 1)
  br label %$-1
$58:
  %139 = phi i32 [%134, %$56] ; # Cnt
; # (i8 @)
  %140 = trunc i32 %136 to i8
; # (byteSym (i8 @) P)
  call void @byteSym(i8 %140, i64* %55)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %141 = sub i32 %139, 1
; # (=0 (dec 'Cnt))
  %142 = icmp eq i32 %141, 0
  br i1 %142, label %$60, label %$59
$59:
  %143 = phi i32 [%141, %$58] ; # Cnt
  br label %$56
$60:
  %144 = phi i32 [%141, %$58] ; # Cnt
  %145 = phi i64 [0, %$58] ; # ->
; # (when (lt0 (setq Cnt (call $GetBin))) (goto 1))
; # (call $GetBin)
  %146 = load i32()*, i32()** @$GetBin
  %147 = call i32 %146()
; # (lt0 (setq Cnt (call $GetBin)))
  %148 = icmp slt i32 %147, 0
  br i1 %148, label %$61, label %$62
$61:
  %149 = phi i32 [%147, %$60] ; # Cnt
; # (goto 1)
  br label %$-1
$62:
  %150 = phi i32 [%147, %$60] ; # Cnt
; # (? (<> Cnt 255))
; # (<> Cnt 255)
  %151 = icmp ne i32 %150, 255
  br i1 %151, label %$64, label %$63
$63:
  %152 = phi i32 [%150, %$62] ; # Cnt
  br label %$55
$64:
  %153 = phi i32 [%150, %$62] ; # Cnt
  %154 = phi i64 [0, %$62] ; # ->
; # (unless Cnt (goto 3))
  %155 = icmp ne i32 %153, 0
  br i1 %155, label %$66, label %$65
$65:
  %156 = phi i32 [%153, %$64] ; # Cnt
; # (goto 3)
  br label %$-3
$66:
  %157 = phi i32 [%153, %$64] ; # Cnt
  br label %$54
$54:
  %158 = phi i32 [%130, %$29], [%157, %$66] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (goto 1)) (byteSym (i8 @) P) (? ...
  br label %$67
$67:
  %159 = phi i32 [%158, %$54], [%168, %$70] ; # Cnt
; # (when (lt0 (call $GetBin)) (goto 1))
; # (call $GetBin)
  %160 = load i32()*, i32()** @$GetBin
  %161 = call i32 %160()
; # (lt0 (call $GetBin))
  %162 = icmp slt i32 %161, 0
  br i1 %162, label %$68, label %$69
$68:
  %163 = phi i32 [%159, %$67] ; # Cnt
; # (goto 1)
  br label %$-1
$69:
  %164 = phi i32 [%159, %$67] ; # Cnt
; # (i8 @)
  %165 = trunc i32 %161 to i8
; # (byteSym (i8 @) P)
  call void @byteSym(i8 %165, i64* %55)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %166 = sub i32 %164, 1
; # (=0 (dec 'Cnt))
  %167 = icmp eq i32 %166, 0
  br i1 %167, label %$71, label %$70
$70:
  %168 = phi i32 [%166, %$69] ; # Cnt
  br label %$67
$71:
  %169 = phi i32 [%166, %$69] ; # Cnt
  %170 = phi i64 [0, %$69] ; # ->
; # (: 3 (drop Q (let Nm (val Q) (case Tag (TRANSIENT (consStr Nm)) (...
  br label %$-3
$-3:
  %171 = phi i32 [%156, %$65], [%169, %$71] ; # Cnt
; # (drop Q (let Nm (val Q) (case Tag (TRANSIENT (consStr Nm)) (INTER...
; # (let Nm (val Q) (case Tag (TRANSIENT (consStr Nm)) (INTERN (reque...
; # (val Q)
  %172 = inttoptr i64 %57 to i64*
  %173 = load i64, i64* %172
; # (case Tag (TRANSIENT (consStr Nm)) (INTERN (requestSym Nm)) (T (w...
  switch i32 %49, label %$72 [
    i32 2, label %$74
    i32 1, label %$75
  ]
$74:
  %174 = phi i32 [%171, %$-3] ; # Cnt
  %175 = phi i64 [%173, %$-3] ; # Nm
; # (consStr Nm)
  %176 = call i64 @consStr(i64 %175)
  br label %$73
$75:
  %177 = phi i32 [%171, %$-3] ; # Cnt
  %178 = phi i64 [%173, %$-3] ; # Nm
; # (requestSym Nm)
  %179 = call i64 @requestSym(i64 %178)
  br label %$73
$72:
  %180 = phi i32 [%171, %$-3] ; # Cnt
  %181 = phi i64 [%173, %$-3] ; # Nm
; # (when (val $Extn) (let N (shl (& (i64 (+ (objFile Nm) @)) (hex "F...
; # (val $Extn)
  %182 = load i32, i32* @$Extn
  %183 = icmp ne i32 %182, 0
  br i1 %183, label %$76, label %$77
$76:
  %184 = phi i32 [%180, %$72] ; # Cnt
  %185 = phi i64 [%181, %$72] ; # Nm
; # (let N (shl (& (i64 (+ (objFile Nm) @)) (hex "FFFF")) 24) (setq N...
; # (objFile Nm)
  %186 = call i32 @objFile(i64 %185)
; # (+ (objFile Nm) @)
  %187 = add i32 %186, %182
; # (i64 (+ (objFile Nm) @))
  %188 = sext i32 %187 to i64
; # (& (i64 (+ (objFile Nm) @)) (hex "FFFF"))
  %189 = and i64 %188, 65535
; # (shl (& (i64 (+ (objFile Nm) @)) (hex "FFFF")) 24)
  %190 = shl i64 %189, 24
; # (& Nm (hex "FFF00FFF00FFFFFF"))
  %191 = and i64 %185, 18442258061990035455
; # (shl N 12)
  %192 = shl i64 %190, 12
; # (| N (shl N 12))
  %193 = or i64 %190, %192
; # (& (| N (shl N 12)) (hex "000FF000FF000000"))
  %194 = and i64 %193, 4486011719516160
; # (| (& Nm (hex "FFF00FFF00FFFFFF")) (& (| N (shl N 12)) (hex "000F...
  %195 = or i64 %191, %194
  br label %$77
$77:
  %196 = phi i32 [%180, %$72], [%184, %$76] ; # Cnt
  %197 = phi i64 [%181, %$72], [%195, %$76] ; # Nm
; # (extern Nm)
  %198 = call i64 @extern(i64 %197)
  br label %$73
$73:
  %199 = phi i32 [%174, %$74], [%177, %$75], [%196, %$77] ; # Cnt
  %200 = phi i64 [%175, %$74], [%178, %$75], [%197, %$77] ; # Nm
  %201 = phi i64 [%176, %$74], [%179, %$75], [%198, %$77] ; # ->
  %202 = inttoptr i64 %57 to i64*
  %203 = getelementptr i64, i64* %202, i32 1
  %204 = load i64, i64* %203
  %205 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %204, i64* %205
  br label %$28
$28:
  %206 = phi i32 [%124, %$52], [%199, %$73] ; # Cnt
  %207 = phi i64 [%125, %$52], [%201, %$73] ; # ->
  br label %$27
$27:
  %208 = phi i64 [0, %$25], [%207, %$28] ; # ->
  br label %$3
$3:
  %209 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%46, %$10], [10, %$6], [%47, %$7], [%208, %$27] ; # ->
  ret i64 %209
}

define void @prCnt(i8, i64) align 8 {
$1:
; # (let N Num (while (setq N (shr N 8)) (inc 'Tag 4)))
; # (while (setq N (shr N 8)) (inc 'Tag 4))
  br label %$2
$2:
  %2 = phi i8 [%0, %$1], [%10, %$3] ; # Tag
  %3 = phi i64 [%1, %$1], [%8, %$3] ; # Num
  %4 = phi i64 [%1, %$1], [%9, %$3] ; # N
; # (shr N 8)
  %5 = lshr i64 %4, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$4
$3:
  %7 = phi i8 [%2, %$2] ; # Tag
  %8 = phi i64 [%3, %$2] ; # Num
  %9 = phi i64 [%5, %$2] ; # N
; # (inc 'Tag 4)
  %10 = add i8 %7, 4
  br label %$2
$4:
  %11 = phi i8 [%2, %$2] ; # Tag
  %12 = phi i64 [%3, %$2] ; # Num
  %13 = phi i64 [%5, %$2] ; # N
; # (call $PutBin Tag)
  %14 = load void(i8)*, void(i8)** @$PutBin
  call void %14(i8 %11)
; # (loop (call $PutBin (i8 Num)) (? (=0 (setq Num (shr Num 8)))))
  br label %$5
$5:
  %15 = phi i8 [%11, %$4], [%21, %$6] ; # Tag
  %16 = phi i64 [%12, %$4], [%22, %$6] ; # Num
; # (i8 Num)
  %17 = trunc i64 %16 to i8
; # (call $PutBin (i8 Num))
  %18 = load void(i8)*, void(i8)** @$PutBin
  call void %18(i8 %17)
; # (? (=0 (setq Num (shr Num 8))))
; # (shr Num 8)
  %19 = lshr i64 %16, 8
; # (=0 (setq Num (shr Num 8)))
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %$7, label %$6
$6:
  %21 = phi i8 [%15, %$5] ; # Tag
  %22 = phi i64 [%19, %$5] ; # Num
  br label %$5
$7:
  %23 = phi i8 [%15, %$5] ; # Tag
  %24 = phi i64 [%19, %$5] ; # Num
  %25 = phi i64 [0, %$5] ; # ->
  ret void
}

define void @binPrint(i64) align 8 {
$1:
; # (cond ((cnt? X) (tailcall (prCnt (+ NUMBER 4) (shr X 3)))) ((big?...
; # (cnt? X)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
; # (+ NUMBER 4)
; # (shr X 3)
  %4 = lshr i64 %3, 3
; # (prCnt (+ NUMBER 4) (shr X 3))
  tail call void @prCnt(i8 4, i64 %4)
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
; # (big? X)
  %6 = and i64 %5, 4
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$3] ; # X
; # (let (Y (pos X) Z Y N 8) (loop (let C (val (dig Z)) (? (cnt? (set...
; # (pos X)
  %9 = and i64 %8, -9
; # (loop (let C (val (dig Z)) (? (cnt? (setq Z (val (big Z)))) (setq...
  br label %$7
$7:
  %10 = phi i64 [%8, %$6], [%39, %$8] ; # X
  %11 = phi i64 [%9, %$6], [%40, %$8] ; # Y
  %12 = phi i64 [%9, %$6], [%41, %$8] ; # Z
  %13 = phi i64 [8, %$6], [%44, %$8] ; # N
; # (let C (val (dig Z)) (? (cnt? (setq Z (val (big Z)))) (setq Z (in...
; # (dig Z)
  %14 = add i64 %12, -4
; # (val (dig Z))
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
; # (? (cnt? (setq Z (val (big Z)))) (setq Z (int Z) C (add C C) Z (a...
; # (big Z)
  %17 = add i64 %12, 4
; # (val (big Z))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (cnt? (setq Z (val (big Z))))
  %20 = and i64 %19, 2
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$8
$10:
  %22 = phi i64 [%10, %$7] ; # X
  %23 = phi i64 [%11, %$7] ; # Y
  %24 = phi i64 [%19, %$7] ; # Z
  %25 = phi i64 [%13, %$7] ; # N
  %26 = phi i64 [%16, %$7] ; # C
; # (int Z)
  %27 = lshr i64 %24, 4
; # (add C C)
  %28 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %26, i64 %26)
  %29 = extractvalue {i64, i1} %28, 1
  %30 = extractvalue {i64, i1} %28, 0
; # (add Z Z @@)
  %31 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %27, i64 %27)
  %32 = extractvalue {i64, i1} %31, 1
  %33 = extractvalue {i64, i1} %31, 0
  %34 = zext i1 %29 to i64
  %35 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %33, i64 %34)
  %36 = extractvalue {i64, i1} %35, 1
  %37 = or i1 %32, %36
  %38 = extractvalue {i64, i1} %35, 0
  br label %$9
$8:
  %39 = phi i64 [%10, %$7] ; # X
  %40 = phi i64 [%11, %$7] ; # Y
  %41 = phi i64 [%19, %$7] ; # Z
  %42 = phi i64 [%13, %$7] ; # N
  %43 = phi i64 [%16, %$7] ; # C
; # (inc 'N 8)
  %44 = add i64 %42, 8
  br label %$7
$9:
  %45 = phi i64 [%22, %$10] ; # X
  %46 = phi i64 [%23, %$10] ; # Y
  %47 = phi i64 [%38, %$10] ; # Z
  %48 = phi i64 [%25, %$10] ; # N
  %49 = phi i64 [%38, %$10] ; # ->
; # (when Z (loop (inc 'N) (? (=0 (setq Z (shr Z 8))))))
  %50 = icmp ne i64 %47, 0
  br i1 %50, label %$11, label %$12
$11:
  %51 = phi i64 [%45, %$9] ; # X
  %52 = phi i64 [%46, %$9] ; # Y
  %53 = phi i64 [%47, %$9] ; # Z
  %54 = phi i64 [%48, %$9] ; # N
; # (loop (inc 'N) (? (=0 (setq Z (shr Z 8)))))
  br label %$13
$13:
  %55 = phi i64 [%51, %$11], [%62, %$14] ; # X
  %56 = phi i64 [%52, %$11], [%63, %$14] ; # Y
  %57 = phi i64 [%53, %$11], [%64, %$14] ; # Z
  %58 = phi i64 [%54, %$11], [%65, %$14] ; # N
; # (inc 'N)
  %59 = add i64 %58, 1
; # (? (=0 (setq Z (shr Z 8))))
; # (shr Z 8)
  %60 = lshr i64 %57, 8
; # (=0 (setq Z (shr Z 8)))
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %$15, label %$14
$14:
  %62 = phi i64 [%55, %$13] ; # X
  %63 = phi i64 [%56, %$13] ; # Y
  %64 = phi i64 [%60, %$13] ; # Z
  %65 = phi i64 [%59, %$13] ; # N
  br label %$13
$15:
  %66 = phi i64 [%55, %$13] ; # X
  %67 = phi i64 [%56, %$13] ; # Y
  %68 = phi i64 [%60, %$13] ; # Z
  %69 = phi i64 [%59, %$13] ; # N
  %70 = phi i64 [0, %$13] ; # ->
  br label %$12
$12:
  %71 = phi i64 [%45, %$9], [%66, %$15] ; # X
  %72 = phi i64 [%46, %$9], [%67, %$15] ; # Y
  %73 = phi i64 [%47, %$9], [%68, %$15] ; # Z
  %74 = phi i64 [%48, %$9], [%69, %$15] ; # N
; # (let (M (- N 63) D (val (dig Y))) (when (ge0 M) (setq N 63)) (set...
; # (- N 63)
  %75 = sub i64 %74, 63
; # (dig Y)
  %76 = add i64 %72, -4
; # (val (dig Y))
  %77 = inttoptr i64 %76 to i64*
  %78 = load i64, i64* %77
; # (when (ge0 M) (setq N 63))
; # (ge0 M)
  %79 = icmp sge i64 %75, 0
  br i1 %79, label %$16, label %$17
$16:
  %80 = phi i64 [%71, %$12] ; # X
  %81 = phi i64 [%72, %$12] ; # Y
  %82 = phi i64 [%73, %$12] ; # Z
  %83 = phi i64 [%74, %$12] ; # N
  %84 = phi i64 [%75, %$12] ; # M
  %85 = phi i64 [%78, %$12] ; # D
  br label %$17
$17:
  %86 = phi i64 [%71, %$12], [%80, %$16] ; # X
  %87 = phi i64 [%72, %$12], [%81, %$16] ; # Y
  %88 = phi i64 [%73, %$12], [%82, %$16] ; # Z
  %89 = phi i64 [%74, %$12], [63, %$16] ; # N
  %90 = phi i64 [%75, %$12], [%84, %$16] ; # M
  %91 = phi i64 [%78, %$12], [%85, %$16] ; # D
; # (big Y)
  %92 = add i64 %87, 4
; # (val (big Y))
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
; # (shr X X 4)
  %95 = call i64 @llvm.fshr.i64(i64 %86, i64 %86, i64 4)
; # (add X X)
  %96 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %95, i64 %95)
  %97 = extractvalue {i64, i1} %96, 1
  %98 = extractvalue {i64, i1} %96, 0
; # (add D D @@)
  %99 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %91, i64 %91)
  %100 = extractvalue {i64, i1} %99, 1
  %101 = extractvalue {i64, i1} %99, 0
  %102 = zext i1 %97 to i64
  %103 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %101, i64 %102)
  %104 = extractvalue {i64, i1} %103, 1
  %105 = or i1 %100, %104
  %106 = extractvalue {i64, i1} %103, 0
; # (shl N 2)
  %107 = shl i64 %89, 2
; # (i8 (shl N 2))
  %108 = trunc i64 %107 to i8
; # (call $PutBin (i8 (shl N 2)))
  %109 = load void(i8)*, void(i8)** @$PutBin
  call void %109(i8 %108)
; # (let (S @@ C 8) (loop (loop (call $PutBin (i8 D)) (if (dec 'C) (s...
; # (loop (loop (call $PutBin (i8 D)) (if (dec 'C) (setq D (shr D 8))...
  br label %$18
$18:
  %110 = phi i64 [%95, %$17], [%253, %$33] ; # X
  %111 = phi i64 [%94, %$17], [%254, %$33] ; # Y
  %112 = phi i64 [%88, %$17], [%255, %$33] ; # Z
  %113 = phi i64 [%89, %$17], [%256, %$33] ; # N
  %114 = phi i64 [%90, %$17], [%257, %$33] ; # M
  %115 = phi i64 [%106, %$17], [%258, %$33] ; # D
  %116 = phi i1 [%105, %$17], [%259, %$33] ; # S
  %117 = phi i64 [8, %$17], [%260, %$33] ; # C
; # (loop (call $PutBin (i8 D)) (if (dec 'C) (setq D (shr D 8)) (setq...
  br label %$19
$19:
  %118 = phi i64 [%110, %$18], [%199, %$26] ; # X
  %119 = phi i64 [%111, %$18], [%200, %$26] ; # Y
  %120 = phi i64 [%112, %$18], [%201, %$26] ; # Z
  %121 = phi i64 [%113, %$18], [%202, %$26] ; # N
  %122 = phi i64 [%114, %$18], [%203, %$26] ; # M
  %123 = phi i64 [%115, %$18], [%204, %$26] ; # D
  %124 = phi i1 [%116, %$18], [%205, %$26] ; # S
  %125 = phi i64 [%117, %$18], [%206, %$26] ; # C
; # (i8 D)
  %126 = trunc i64 %123 to i8
; # (call $PutBin (i8 D))
  %127 = load void(i8)*, void(i8)** @$PutBin
  call void %127(i8 %126)
; # (if (dec 'C) (setq D (shr D 8)) (setq C 8) (if (cnt? Y) (setq D (...
; # (dec 'C)
  %128 = sub i64 %125, 1
  %129 = icmp ne i64 %128, 0
  br i1 %129, label %$20, label %$21
$20:
  %130 = phi i64 [%118, %$19] ; # X
  %131 = phi i64 [%119, %$19] ; # Y
  %132 = phi i64 [%120, %$19] ; # Z
  %133 = phi i64 [%121, %$19] ; # N
  %134 = phi i64 [%122, %$19] ; # M
  %135 = phi i64 [%123, %$19] ; # D
  %136 = phi i1 [%124, %$19] ; # S
  %137 = phi i64 [%128, %$19] ; # C
; # (shr D 8)
  %138 = lshr i64 %135, 8
  br label %$22
$21:
  %139 = phi i64 [%118, %$19] ; # X
  %140 = phi i64 [%119, %$19] ; # Y
  %141 = phi i64 [%120, %$19] ; # Z
  %142 = phi i64 [%121, %$19] ; # N
  %143 = phi i64 [%122, %$19] ; # M
  %144 = phi i64 [%123, %$19] ; # D
  %145 = phi i1 [%124, %$19] ; # S
  %146 = phi i64 [%128, %$19] ; # C
; # (if (cnt? Y) (setq D (int Y)) (setq D (val (dig Y)) Y (val (big Y...
; # (cnt? Y)
  %147 = and i64 %140, 2
  %148 = icmp ne i64 %147, 0
  br i1 %148, label %$23, label %$24
$23:
  %149 = phi i64 [%139, %$21] ; # X
  %150 = phi i64 [%140, %$21] ; # Y
  %151 = phi i64 [%141, %$21] ; # Z
  %152 = phi i64 [%142, %$21] ; # N
  %153 = phi i64 [%143, %$21] ; # M
  %154 = phi i64 [%144, %$21] ; # D
  %155 = phi i1 [%145, %$21] ; # S
  %156 = phi i64 [8, %$21] ; # C
; # (int Y)
  %157 = lshr i64 %150, 4
  br label %$25
$24:
  %158 = phi i64 [%139, %$21] ; # X
  %159 = phi i64 [%140, %$21] ; # Y
  %160 = phi i64 [%141, %$21] ; # Z
  %161 = phi i64 [%142, %$21] ; # N
  %162 = phi i64 [%143, %$21] ; # M
  %163 = phi i64 [%144, %$21] ; # D
  %164 = phi i1 [%145, %$21] ; # S
  %165 = phi i64 [8, %$21] ; # C
; # (dig Y)
  %166 = add i64 %159, -4
; # (val (dig Y))
  %167 = inttoptr i64 %166 to i64*
  %168 = load i64, i64* %167
; # (big Y)
  %169 = add i64 %159, 4
; # (val (big Y))
  %170 = inttoptr i64 %169 to i64*
  %171 = load i64, i64* %170
  br label %$25
$25:
  %172 = phi i64 [%149, %$23], [%158, %$24] ; # X
  %173 = phi i64 [%150, %$23], [%171, %$24] ; # Y
  %174 = phi i64 [%151, %$23], [%160, %$24] ; # Z
  %175 = phi i64 [%152, %$23], [%161, %$24] ; # N
  %176 = phi i64 [%153, %$23], [%162, %$24] ; # M
  %177 = phi i64 [%157, %$23], [%168, %$24] ; # D
  %178 = phi i1 [%155, %$23], [%164, %$24] ; # S
  %179 = phi i64 [%156, %$23], [%165, %$24] ; # C
  %180 = phi i64 [%157, %$23], [%171, %$24] ; # ->
; # (add D D S)
  %181 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %177, i64 %177)
  %182 = extractvalue {i64, i1} %181, 1
  %183 = extractvalue {i64, i1} %181, 0
  %184 = zext i1 %178 to i64
  %185 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %183, i64 %184)
  %186 = extractvalue {i64, i1} %185, 1
  %187 = or i1 %182, %186
  %188 = extractvalue {i64, i1} %185, 0
  br label %$22
$22:
  %189 = phi i64 [%130, %$20], [%172, %$25] ; # X
  %190 = phi i64 [%131, %$20], [%173, %$25] ; # Y
  %191 = phi i64 [%132, %$20], [%174, %$25] ; # Z
  %192 = phi i64 [%133, %$20], [%175, %$25] ; # N
  %193 = phi i64 [%134, %$20], [%176, %$25] ; # M
  %194 = phi i64 [%138, %$20], [%188, %$25] ; # D
  %195 = phi i1 [%136, %$20], [%187, %$25] ; # S
  %196 = phi i64 [%137, %$20], [%179, %$25] ; # C
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %197 = sub i64 %192, 1
; # (=0 (dec 'N))
  %198 = icmp eq i64 %197, 0
  br i1 %198, label %$27, label %$26
$26:
  %199 = phi i64 [%189, %$22] ; # X
  %200 = phi i64 [%190, %$22] ; # Y
  %201 = phi i64 [%191, %$22] ; # Z
  %202 = phi i64 [%197, %$22] ; # N
  %203 = phi i64 [%193, %$22] ; # M
  %204 = phi i64 [%194, %$22] ; # D
  %205 = phi i1 [%195, %$22] ; # S
  %206 = phi i64 [%196, %$22] ; # C
  br label %$19
$27:
  %207 = phi i64 [%189, %$22] ; # X
  %208 = phi i64 [%190, %$22] ; # Y
  %209 = phi i64 [%191, %$22] ; # Z
  %210 = phi i64 [%197, %$22] ; # N
  %211 = phi i64 [%193, %$22] ; # M
  %212 = phi i64 [%194, %$22] ; # D
  %213 = phi i1 [%195, %$22] ; # S
  %214 = phi i64 [%196, %$22] ; # C
  %215 = phi i64 [0, %$22] ; # ->
; # (? (lt0 M))
; # (lt0 M)
  %216 = icmp slt i64 %211, 0
  br i1 %216, label %$29, label %$28
$28:
  %217 = phi i64 [%207, %$27] ; # X
  %218 = phi i64 [%208, %$27] ; # Y
  %219 = phi i64 [%209, %$27] ; # Z
  %220 = phi i64 [%210, %$27] ; # N
  %221 = phi i64 [%211, %$27] ; # M
  %222 = phi i64 [%212, %$27] ; # D
  %223 = phi i1 [%213, %$27] ; # S
  %224 = phi i64 [%214, %$27] ; # C
; # (? (=0 M) (call $PutBin 0))
; # (=0 M)
  %225 = icmp eq i64 %221, 0
  br i1 %225, label %$31, label %$30
$31:
  %226 = phi i64 [%217, %$28] ; # X
  %227 = phi i64 [%218, %$28] ; # Y
  %228 = phi i64 [%219, %$28] ; # Z
  %229 = phi i64 [%220, %$28] ; # N
  %230 = phi i64 [%221, %$28] ; # M
  %231 = phi i64 [%222, %$28] ; # D
  %232 = phi i1 [%223, %$28] ; # S
  %233 = phi i64 [%224, %$28] ; # C
; # (call $PutBin 0)
  %234 = load void(i8)*, void(i8)** @$PutBin
  call void %234(i8 0)
  br label %$29
$30:
  %235 = phi i64 [%217, %$28] ; # X
  %236 = phi i64 [%218, %$28] ; # Y
  %237 = phi i64 [%219, %$28] ; # Z
  %238 = phi i64 [%220, %$28] ; # N
  %239 = phi i64 [%221, %$28] ; # M
  %240 = phi i64 [%222, %$28] ; # D
  %241 = phi i1 [%223, %$28] ; # S
  %242 = phi i64 [%224, %$28] ; # C
; # (when (ge0 (setq M (- (setq N M) 255))) (setq N 255))
; # (- (setq N M) 255)
  %243 = sub i64 %239, 255
; # (ge0 (setq M (- (setq N M) 255)))
  %244 = icmp sge i64 %243, 0
  br i1 %244, label %$32, label %$33
$32:
  %245 = phi i64 [%235, %$30] ; # X
  %246 = phi i64 [%236, %$30] ; # Y
  %247 = phi i64 [%237, %$30] ; # Z
  %248 = phi i64 [%239, %$30] ; # N
  %249 = phi i64 [%243, %$30] ; # M
  %250 = phi i64 [%240, %$30] ; # D
  %251 = phi i1 [%241, %$30] ; # S
  %252 = phi i64 [%242, %$30] ; # C
  br label %$33
$33:
  %253 = phi i64 [%235, %$30], [%245, %$32] ; # X
  %254 = phi i64 [%236, %$30], [%246, %$32] ; # Y
  %255 = phi i64 [%237, %$30], [%247, %$32] ; # Z
  %256 = phi i64 [%239, %$30], [255, %$32] ; # N
  %257 = phi i64 [%243, %$30], [%249, %$32] ; # M
  %258 = phi i64 [%240, %$30], [%250, %$32] ; # D
  %259 = phi i1 [%241, %$30], [%251, %$32] ; # S
  %260 = phi i64 [%242, %$30], [%252, %$32] ; # C
; # (i8 N)
  %261 = trunc i64 %256 to i8
; # (call $PutBin (i8 N))
  %262 = load void(i8)*, void(i8)** @$PutBin
  call void %262(i8 %261)
  br label %$18
$29:
  %263 = phi i64 [%207, %$27], [%226, %$31] ; # X
  %264 = phi i64 [%208, %$27], [%227, %$31] ; # Y
  %265 = phi i64 [%209, %$27], [%228, %$31] ; # Z
  %266 = phi i64 [%210, %$27], [%229, %$31] ; # N
  %267 = phi i64 [%211, %$27], [%230, %$31] ; # M
  %268 = phi i64 [%212, %$27], [%231, %$31] ; # D
  %269 = phi i1 [%213, %$27], [%232, %$31] ; # S
  %270 = phi i64 [%214, %$27], [%233, %$31] ; # C
  br label %$2
$5:
  %271 = phi i64 [%5, %$3] ; # X
; # (nil? X)
  %272 = icmp eq i64 %271, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %272, label %$35, label %$34
$35:
  %273 = phi i64 [%271, %$5] ; # X
; # (call $PutBin NIX)
  %274 = load void(i8)*, void(i8)** @$PutBin
  call void %274(i8 0)
  br label %$2
$34:
  %275 = phi i64 [%271, %$5] ; # X
; # (pair X)
  %276 = and i64 %275, 15
  %277 = icmp eq i64 %276, 0
  br i1 %277, label %$37, label %$36
$37:
  %278 = phi i64 [%275, %$34] ; # X
; # (call $PutBin BEG)
  %279 = load void(i8)*, void(i8)** @$PutBin
  call void %279(i8 1)
; # (let P (circ X) (ifn P (loop (binPrint (car X)) (? (nil? (shift X...
; # (circ X)
  %280 = call i64 @circ(i64 %278)
; # (ifn P (loop (binPrint (car X)) (? (nil? (shift X)) (call $PutBin...
  %281 = icmp ne i64 %280, 0
  br i1 %281, label %$39, label %$38
$38:
  %282 = phi i64 [%278, %$37] ; # X
; # (loop (binPrint (car X)) (? (nil? (shift X)) (call $PutBin END)) ...
  br label %$41
$41:
  %283 = phi i64 [%282, %$38], [%297, %$45] ; # X
; # (car X)
  %284 = inttoptr i64 %283 to i64*
  %285 = load i64, i64* %284
; # (binPrint (car X))
  call void @binPrint(i64 %285)
; # (? (nil? (shift X)) (call $PutBin END))
; # (shift X)
  %286 = inttoptr i64 %283 to i64*
  %287 = getelementptr i64, i64* %286, i32 1
  %288 = load i64, i64* %287
; # (nil? (shift X))
  %289 = icmp eq i64 %288, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %289, label %$44, label %$42
$44:
  %290 = phi i64 [%288, %$41] ; # X
; # (call $PutBin END)
  %291 = load void(i8)*, void(i8)** @$PutBin
  call void %291(i8 3)
  br label %$43
$42:
  %292 = phi i64 [%288, %$41] ; # X
; # (? (atom X) (call $PutBin DOT) (binPrint X))
; # (atom X)
  %293 = and i64 %292, 15
  %294 = icmp ne i64 %293, 0
  br i1 %294, label %$46, label %$45
$46:
  %295 = phi i64 [%292, %$42] ; # X
; # (call $PutBin DOT)
  %296 = load void(i8)*, void(i8)** @$PutBin
  call void %296(i8 2)
; # (binPrint X)
  call void @binPrint(i64 %295)
  br label %$43
$45:
  %297 = phi i64 [%292, %$42] ; # X
  br label %$41
$43:
  %298 = phi i64 [%290, %$44], [%295, %$46] ; # X
  br label %$40
$39:
  %299 = phi i64 [%278, %$37] ; # X
; # (let Flg (== P X) (loop (binPrint (car X)) (? (== P (shift X)))) ...
; # (== P X)
  %300 = icmp eq i64 %280, %299
; # (loop (binPrint (car X)) (? (== P (shift X))))
  br label %$47
$47:
  %301 = phi i64 [%299, %$39], [%308, %$48] ; # X
; # (car X)
  %302 = inttoptr i64 %301 to i64*
  %303 = load i64, i64* %302
; # (binPrint (car X))
  call void @binPrint(i64 %303)
; # (? (== P (shift X)))
; # (shift X)
  %304 = inttoptr i64 %301 to i64*
  %305 = getelementptr i64, i64* %304, i32 1
  %306 = load i64, i64* %305
; # (== P (shift X))
  %307 = icmp eq i64 %280, %306
  br i1 %307, label %$49, label %$48
$48:
  %308 = phi i64 [%306, %$47] ; # X
  br label %$47
$49:
  %309 = phi i64 [%306, %$47] ; # X
  %310 = phi i64 [0, %$47] ; # ->
; # (call $PutBin DOT)
  %311 = load void(i8)*, void(i8)** @$PutBin
  call void %311(i8 2)
; # (unless Flg (call $PutBin BEG) (loop (binPrint (car X)) (? (== P ...
  br i1 %300, label %$51, label %$50
$50:
  %312 = phi i64 [%309, %$49] ; # X
; # (call $PutBin BEG)
  %313 = load void(i8)*, void(i8)** @$PutBin
  call void %313(i8 1)
; # (loop (binPrint (car X)) (? (== P (shift X))))
  br label %$52
$52:
  %314 = phi i64 [%312, %$50], [%321, %$53] ; # X
; # (car X)
  %315 = inttoptr i64 %314 to i64*
  %316 = load i64, i64* %315
; # (binPrint (car X))
  call void @binPrint(i64 %316)
; # (? (== P (shift X)))
; # (shift X)
  %317 = inttoptr i64 %314 to i64*
  %318 = getelementptr i64, i64* %317, i32 1
  %319 = load i64, i64* %318
; # (== P (shift X))
  %320 = icmp eq i64 %280, %319
  br i1 %320, label %$54, label %$53
$53:
  %321 = phi i64 [%319, %$52] ; # X
  br label %$52
$54:
  %322 = phi i64 [%319, %$52] ; # X
  %323 = phi i64 [0, %$52] ; # ->
; # (call $PutBin DOT)
  %324 = load void(i8)*, void(i8)** @$PutBin
  call void %324(i8 2)
  br label %$51
$51:
  %325 = phi i64 [%309, %$49], [%322, %$54] ; # X
; # (call $PutBin END)
  %326 = load void(i8)*, void(i8)** @$PutBin
  call void %326(i8 3)
  br label %$40
$40:
  %327 = phi i64 [%298, %$43], [%325, %$51] ; # X
  br label %$2
$36:
  %328 = phi i64 [%275, %$34] ; # X
; # (tail X)
  %329 = add i64 %328, -8
; # (val (tail X))
  %330 = inttoptr i64 %329 to i64*
  %331 = load i64, i64* %330
; # (sym? (val (tail X)))
  %332 = and i64 %331, 8
  %333 = icmp ne i64 %332, 0
  br i1 %333, label %$56, label %$55
$56:
  %334 = phi i64 [%328, %$36] ; # X
; # (let Nm (name (& @ -9)) (when (val $Extn) (let N (shl (& (i64 (- ...
; # (& @ -9)
  %335 = and i64 %331, -9
; # (name (& @ -9))
  br label %$57
$57:
  %336 = phi i64 [%335, %$56], [%342, %$58] ; # Tail
  %337 = and i64 %336, 6
  %338 = icmp ne i64 %337, 0
  br i1 %338, label %$59, label %$58
$58:
  %339 = phi i64 [%336, %$57] ; # Tail
  %340 = inttoptr i64 %339 to i64*
  %341 = getelementptr i64, i64* %340, i32 1
  %342 = load i64, i64* %341
  br label %$57
$59:
  %343 = phi i64 [%336, %$57] ; # Tail
; # (when (val $Extn) (let N (shl (& (i64 (- (objFile Nm) @)) (hex "F...
; # (val $Extn)
  %344 = load i32, i32* @$Extn
  %345 = icmp ne i32 %344, 0
  br i1 %345, label %$60, label %$61
$60:
  %346 = phi i64 [%334, %$59] ; # X
  %347 = phi i64 [%343, %$59] ; # Nm
; # (let N (shl (& (i64 (- (objFile Nm) @)) (hex "FFFF")) 24) (setq N...
; # (objFile Nm)
  %348 = call i32 @objFile(i64 %347)
; # (- (objFile Nm) @)
  %349 = sub i32 %348, %344
; # (i64 (- (objFile Nm) @))
  %350 = sext i32 %349 to i64
; # (& (i64 (- (objFile Nm) @)) (hex "FFFF"))
  %351 = and i64 %350, 65535
; # (shl (& (i64 (- (objFile Nm) @)) (hex "FFFF")) 24)
  %352 = shl i64 %351, 24
; # (& Nm (hex "FFF00FFF00FFFFFF"))
  %353 = and i64 %347, 18442258061990035455
; # (shl N 12)
  %354 = shl i64 %352, 12
; # (| N (shl N 12))
  %355 = or i64 %352, %354
; # (& (| N (shl N 12)) (hex "000FF000FF000000"))
  %356 = and i64 %355, 4486011719516160
; # (| (& Nm (hex "FFF00FFF00FFFFFF")) (& (| N (shl N 12)) (hex "000F...
  %357 = or i64 %353, %356
  br label %$61
$61:
  %358 = phi i64 [%334, %$59], [%346, %$60] ; # X
  %359 = phi i64 [%343, %$59], [%357, %$60] ; # Nm
; # (+ EXTERN 4)
; # (shl Nm 2)
  %360 = shl i64 %359, 2
; # (shr (shl Nm 2) 6)
  %361 = lshr i64 %360, 6
; # (prCnt (+ EXTERN 4) (shr (shl Nm 2) 6))
  tail call void @prCnt(i8 7, i64 %361)
  br label %$2
$55:
  %362 = phi i64 [%328, %$36] ; # X
; # (name @)
  br label %$62
$62:
  %363 = phi i64 [%331, %$55], [%369, %$63] ; # Tail
  %364 = and i64 %363, 6
  %365 = icmp ne i64 %364, 0
  br i1 %365, label %$64, label %$63
$63:
  %366 = phi i64 [%363, %$62] ; # Tail
  %367 = inttoptr i64 %366 to i64*
  %368 = getelementptr i64, i64* %367, i32 1
  %369 = load i64, i64* %368
  br label %$62
$64:
  %370 = phi i64 [%363, %$62] ; # Tail
; # (== (name @) ZERO)
  %371 = icmp eq i64 %370, 2
  br i1 %371, label %$66, label %$65
$66:
  %372 = phi i64 [%362, %$64] ; # X
; # (call $PutBin NIX)
  %373 = load void(i8)*, void(i8)** @$PutBin
  call void %373(i8 0)
  br label %$2
$65:
  %374 = phi i64 [%362, %$64] ; # X
; # (let (Nm @ Tag (if (findSym X Nm (val $Intern)) (i8 INTERN) (i8 T...
; # (if (findSym X Nm (val $Intern)) (i8 INTERN) (i8 TRANSIENT))
; # (val $Intern)
  %375 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %376 = load i64, i64* %375
; # (findSym X Nm (val $Intern))
  %377 = call i1 @findSym(i64 %374, i64 %370, i64 %376)
  br i1 %377, label %$67, label %$68
$67:
  %378 = phi i64 [%374, %$65] ; # X
; # (i8 INTERN)
  br label %$69
$68:
  %379 = phi i64 [%374, %$65] ; # X
; # (i8 TRANSIENT)
  br label %$69
$69:
  %380 = phi i64 [%378, %$67], [%379, %$68] ; # X
  %381 = phi i8 [1, %$67], [2, %$68] ; # ->
; # (if (cnt? Nm) (prCnt (+ Tag 4) (int Nm)) (let (Y Nm N 8) (while (...
; # (cnt? Nm)
  %382 = and i64 %370, 2
  %383 = icmp ne i64 %382, 0
  br i1 %383, label %$70, label %$71
$70:
  %384 = phi i64 [%380, %$69] ; # X
; # (+ Tag 4)
  %385 = add i8 %381, 4
; # (int Nm)
  %386 = lshr i64 %370, 4
; # (prCnt (+ Tag 4) (int Nm))
  call void @prCnt(i8 %385, i64 %386)
  br label %$72
$71:
  %387 = phi i64 [%380, %$69] ; # X
; # (let (Y Nm N 8) (while (big? (setq Y (val (big Y)))) (inc 'N 8)) ...
; # (while (big? (setq Y (val (big Y)))) (inc 'N 8))
  br label %$73
$73:
  %388 = phi i64 [%387, %$71], [%396, %$74] ; # X
  %389 = phi i64 [%370, %$71], [%397, %$74] ; # Y
  %390 = phi i64 [8, %$71], [%399, %$74] ; # N
; # (big Y)
  %391 = add i64 %389, 4
; # (val (big Y))
  %392 = inttoptr i64 %391 to i64*
  %393 = load i64, i64* %392
; # (big? (setq Y (val (big Y))))
  %394 = and i64 %393, 4
  %395 = icmp ne i64 %394, 0
  br i1 %395, label %$74, label %$75
$74:
  %396 = phi i64 [%388, %$73] ; # X
  %397 = phi i64 [%393, %$73] ; # Y
  %398 = phi i64 [%390, %$73] ; # N
; # (inc 'N 8)
  %399 = add i64 %398, 8
  br label %$73
$75:
  %400 = phi i64 [%388, %$73] ; # X
  %401 = phi i64 [%393, %$73] ; # Y
  %402 = phi i64 [%390, %$73] ; # N
; # (int Y)
  %403 = lshr i64 %401, 4
; # (while Y (inc 'N) (setq Y (shr Y 8)))
  br label %$76
$76:
  %404 = phi i64 [%400, %$75], [%408, %$77] ; # X
  %405 = phi i64 [%403, %$75], [%412, %$77] ; # Y
  %406 = phi i64 [%402, %$75], [%411, %$77] ; # N
  %407 = icmp ne i64 %405, 0
  br i1 %407, label %$77, label %$78
$77:
  %408 = phi i64 [%404, %$76] ; # X
  %409 = phi i64 [%405, %$76] ; # Y
  %410 = phi i64 [%406, %$76] ; # N
; # (inc 'N)
  %411 = add i64 %410, 1
; # (shr Y 8)
  %412 = lshr i64 %409, 8
  br label %$76
$78:
  %413 = phi i64 [%404, %$76] ; # X
  %414 = phi i64 [%405, %$76] ; # Y
  %415 = phi i64 [%406, %$76] ; # N
; # (let (P (push 0 Nm) M (- N 63) C 8) (when (ge0 M) (setq N 63)) (c...
; # (push 0 Nm)
  %416 = alloca i64, i64 2, align 16
  store i64 0, i64* %416
  %417 = getelementptr i64, i64* %416, i32 1
  store i64 %370, i64* %417
; # (- N 63)
  %418 = sub i64 %415, 63
; # (when (ge0 M) (setq N 63))
; # (ge0 M)
  %419 = icmp sge i64 %418, 0
  br i1 %419, label %$79, label %$80
$79:
  %420 = phi i64 [%413, %$78] ; # X
  %421 = phi i64 [%414, %$78] ; # Y
  %422 = phi i64 [%415, %$78] ; # N
  %423 = phi i64 [%418, %$78] ; # M
  br label %$80
$80:
  %424 = phi i64 [%413, %$78], [%420, %$79] ; # X
  %425 = phi i64 [%414, %$78], [%421, %$79] ; # Y
  %426 = phi i64 [%415, %$78], [63, %$79] ; # N
  %427 = phi i64 [%418, %$78], [%423, %$79] ; # M
; # (shl N 2)
  %428 = shl i64 %426, 2
; # (i8 (shl N 2))
  %429 = trunc i64 %428 to i8
; # (+ Tag (i8 (shl N 2)))
  %430 = add i8 %381, %429
; # (call $PutBin (+ Tag (i8 (shl N 2))))
  %431 = load void(i8)*, void(i8)** @$PutBin
  call void %431(i8 %430)
; # (loop (loop (call $PutBin (symByte P)) (? (=0 (dec 'N)))) (? (lt0...
  br label %$81
$81:
  %432 = phi i64 [%424, %$80], [%474, %$90] ; # X
  %433 = phi i64 [%425, %$80], [%475, %$90] ; # Y
  %434 = phi i64 [%426, %$80], [%476, %$90] ; # N
  %435 = phi i64 [%427, %$80], [%477, %$90] ; # M
; # (loop (call $PutBin (symByte P)) (? (=0 (dec 'N))))
  br label %$82
$82:
  %436 = phi i64 [%432, %$81], [%444, %$83] ; # X
  %437 = phi i64 [%433, %$81], [%445, %$83] ; # Y
  %438 = phi i64 [%434, %$81], [%446, %$83] ; # N
  %439 = phi i64 [%435, %$81], [%447, %$83] ; # M
; # (symByte P)
  %440 = call i8 @symByte(i64* %416)
; # (call $PutBin (symByte P))
  %441 = load void(i8)*, void(i8)** @$PutBin
  call void %441(i8 %440)
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %442 = sub i64 %438, 1
; # (=0 (dec 'N))
  %443 = icmp eq i64 %442, 0
  br i1 %443, label %$84, label %$83
$83:
  %444 = phi i64 [%436, %$82] ; # X
  %445 = phi i64 [%437, %$82] ; # Y
  %446 = phi i64 [%442, %$82] ; # N
  %447 = phi i64 [%439, %$82] ; # M
  br label %$82
$84:
  %448 = phi i64 [%436, %$82] ; # X
  %449 = phi i64 [%437, %$82] ; # Y
  %450 = phi i64 [%442, %$82] ; # N
  %451 = phi i64 [%439, %$82] ; # M
  %452 = phi i64 [0, %$82] ; # ->
; # (? (lt0 M))
; # (lt0 M)
  %453 = icmp slt i64 %451, 0
  br i1 %453, label %$86, label %$85
$85:
  %454 = phi i64 [%448, %$84] ; # X
  %455 = phi i64 [%449, %$84] ; # Y
  %456 = phi i64 [%450, %$84] ; # N
  %457 = phi i64 [%451, %$84] ; # M
; # (? (=0 M) (call $PutBin 0))
; # (=0 M)
  %458 = icmp eq i64 %457, 0
  br i1 %458, label %$88, label %$87
$88:
  %459 = phi i64 [%454, %$85] ; # X
  %460 = phi i64 [%455, %$85] ; # Y
  %461 = phi i64 [%456, %$85] ; # N
  %462 = phi i64 [%457, %$85] ; # M
; # (call $PutBin 0)
  %463 = load void(i8)*, void(i8)** @$PutBin
  call void %463(i8 0)
  br label %$86
$87:
  %464 = phi i64 [%454, %$85] ; # X
  %465 = phi i64 [%455, %$85] ; # Y
  %466 = phi i64 [%456, %$85] ; # N
  %467 = phi i64 [%457, %$85] ; # M
; # (when (ge0 (setq M (- (setq N M) 255))) (setq N 255))
; # (- (setq N M) 255)
  %468 = sub i64 %467, 255
; # (ge0 (setq M (- (setq N M) 255)))
  %469 = icmp sge i64 %468, 0
  br i1 %469, label %$89, label %$90
$89:
  %470 = phi i64 [%464, %$87] ; # X
  %471 = phi i64 [%465, %$87] ; # Y
  %472 = phi i64 [%467, %$87] ; # N
  %473 = phi i64 [%468, %$87] ; # M
  br label %$90
$90:
  %474 = phi i64 [%464, %$87], [%470, %$89] ; # X
  %475 = phi i64 [%465, %$87], [%471, %$89] ; # Y
  %476 = phi i64 [%467, %$87], [255, %$89] ; # N
  %477 = phi i64 [%468, %$87], [%473, %$89] ; # M
; # (i8 N)
  %478 = trunc i64 %476 to i8
; # (call $PutBin (i8 N))
  %479 = load void(i8)*, void(i8)** @$PutBin
  call void %479(i8 %478)
  br label %$81
$86:
  %480 = phi i64 [%448, %$84], [%459, %$88] ; # X
  %481 = phi i64 [%449, %$84], [%460, %$88] ; # Y
  %482 = phi i64 [%450, %$84], [%461, %$88] ; # N
  %483 = phi i64 [%451, %$84], [%462, %$88] ; # M
  br label %$72
$72:
  %484 = phi i64 [%384, %$70], [%480, %$86] ; # X
  br label %$2
$2:
  %485 = phi i64 [%3, %$4], [%263, %$29], [%273, %$35], [%327, %$40], [%358, %$61], [%372, %$66], [%484, %$72] ; # X
  ret void
}

define void @pr(i64) align 8 {
$1:
; # (set $PutBin (fun (void i8) _putStdout))
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$PutBin
; # (binPrint X)
  tail call void @binPrint(i64 %0)
  ret void
}

define void @putTell(i8) align 8 {
$1:
; # (let P (val $Ptr) (set P B) (when (== (set $Ptr (inc P)) (val $En...
; # (val $Ptr)
  %1 = load i8*, i8** @$Ptr
; # (set P B)
  store i8 %0, i8* %1
; # (when (== (set $Ptr (inc P)) (val $End)) (err 0 0 ($ "Tell PIPE_B...
; # (set $Ptr (inc P))
; # (inc P)
  %2 = getelementptr i8, i8* %1, i32 1
  store i8* %2, i8** @$Ptr
; # (val $End)
  %3 = load i8*, i8** @$End
; # (== (set $Ptr (inc P)) (val $End))
  %4 = icmp eq i8* %2, %3
  br i1 %4, label %$2, label %$3
$2:
; # (err 0 0 ($ "Tell PIPE_BUF") null)
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$39 to i8*), i8* null)
  unreachable
$3:
  ret void
}

define void @prTell(i64) align 8 {
$1:
; # (set $PutBin (fun (void i8) putTell) $Extn 0)
; # (fun (void i8) putTell)
  store void(i8)* @putTell, void(i8)** @$PutBin
  store i32 0, i32* @$Extn
; # (binPrint X)
  tail call void @binPrint(i64 %0)
  ret void
}

define void @tellBeg(i8*) align 8 {
$1:
; # (set $TellBuf P $End (ofs P (dec (val PipeBufSize))) (inc 'P 8) B...
  store i8* %0, i8** @$TellBuf
; # (val PipeBufSize)
  %1 = load i32, i32* @PipeBufSize
; # (dec (val PipeBufSize))
  %2 = sub i32 %1, 1
; # (ofs P (dec (val PipeBufSize)))
  %3 = getelementptr i8, i8* %0, i32 %2
  store i8* %3, i8** @$End
; # (inc 'P 8)
  %4 = getelementptr i8, i8* %0, i32 8
  store i8 1, i8* %4
; # (inc P)
  %5 = getelementptr i8, i8* %4, i32 1
  store i8* %5, i8** @$Ptr
  ret void
}

define void @tellEnd(i32) align 8 {
$1:
; # (let (P (val $Ptr) Q (val $TellBuf)) (set P END) (inc 'P) (let (D...
; # (val $Ptr)
  %1 = load i8*, i8** @$Ptr
; # (val $TellBuf)
  %2 = load i8*, i8** @$TellBuf
; # (set P END)
  store i8 3, i8* %1
; # (inc 'P)
  %3 = getelementptr i8, i8* %1, i32 1
; # (let (D (i32 (- P Q)) N (- D 8)) (set (i32* Q) Pid (inc (i32* Q))...
; # (- P Q)
  %4 = ptrtoint i8* %3 to i64
  %5 = ptrtoint i8* %2 to i64
  %6 = sub i64 %4, %5
; # (i32 (- P Q))
  %7 = trunc i64 %6 to i32
; # (- D 8)
  %8 = sub i32 %7, 8
; # (set (i32* Q) Pid (inc (i32* Q)) N)
; # (i32* Q)
  %9 = bitcast i8* %2 to i32*
  store i32 %0, i32* %9
; # (i32* Q)
  %10 = bitcast i8* %2 to i32*
; # (inc (i32* Q))
  %11 = getelementptr i32, i32* %10, i32 1
  store i32 %8, i32* %11
; # (when (val $Tell) (let Fd @ (unless (wrBytes Fd Q D) (close Fd) (...
; # (val $Tell)
  %12 = load i32, i32* @$Tell
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i8* [%3, %$1] ; # P
  %15 = phi i8* [%2, %$1] ; # Q
; # (let Fd @ (unless (wrBytes Fd Q D) (close Fd) (set $Tell 0)))
; # (unless (wrBytes Fd Q D) (close Fd) (set $Tell 0))
; # (wrBytes Fd Q D)
  %16 = call i1 @wrBytes(i32 %12, i8* %15, i32 %7)
  br i1 %16, label %$5, label %$4
$4:
  %17 = phi i8* [%14, %$2] ; # P
  %18 = phi i8* [%15, %$2] ; # Q
; # (close Fd)
  %19 = call i32 @close(i32 %12)
; # (set $Tell 0)
  store i32 0, i32* @$Tell
  br label %$5
$5:
  %20 = phi i8* [%14, %$2], [%17, %$4] ; # P
  %21 = phi i8* [%15, %$2], [%18, %$4] ; # Q
  br label %$3
$3:
  %22 = phi i8* [%3, %$1], [%20, %$5] ; # P
  %23 = phi i8* [%2, %$1], [%21, %$5] ; # Q
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %24 = load i8*, i8** @$Child
; # (val $Children)
  %25 = load i32, i32* @$Children
; # (* (val $Children) (child T))
  %26 = mul i32 %25, 28
; # (ofs Cld (* (val $Children) (child T)))
  %27 = getelementptr i8, i8* %24, i32 %26
; # (inc 'Q 8)
  %28 = getelementptr i8, i8* %23, i32 8
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (and (Cld: pid) ...
  br label %$6
$6:
  %29 = phi i8* [%22, %$3], [%62, %$14] ; # P
  %30 = phi i8* [%28, %$3], [%63, %$14] ; # Q
  %31 = phi i8* [%24, %$3], [%65, %$14] ; # Cld
; # (== Cld <Cld)
  %32 = icmp eq i8* %31, %27
  br i1 %32, label %$8, label %$7
$7:
  %33 = phi i8* [%29, %$6] ; # P
  %34 = phi i8* [%30, %$6] ; # Q
  %35 = phi i8* [%31, %$6] ; # Cld
; # (let Cld: (child Cld) (when (and (Cld: pid) (or (=0 Pid) (== Pid ...
; # (when (and (Cld: pid) (or (=0 Pid) (== Pid (Cld: pid)))) (wrChild...
; # (and (Cld: pid) (or (=0 Pid) (== Pid (Cld: pid))))
; # (Cld: pid)
  %36 = getelementptr i8, i8* %35, i32 16
  %37 = bitcast i8* %36 to i32*
  %38 = load i32, i32* %37
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  %40 = phi i8* [%33, %$7] ; # P
  %41 = phi i8* [%34, %$7] ; # Q
  %42 = phi i8* [%35, %$7] ; # Cld
; # (or (=0 Pid) (== Pid (Cld: pid)))
; # (=0 Pid)
  %43 = icmp eq i32 %0, 0
  br i1 %43, label %$11, label %$12
$12:
  %44 = phi i8* [%40, %$10] ; # P
  %45 = phi i8* [%41, %$10] ; # Q
  %46 = phi i8* [%42, %$10] ; # Cld
; # (Cld: pid)
  %47 = getelementptr i8, i8* %35, i32 16
  %48 = bitcast i8* %47 to i32*
  %49 = load i32, i32* %48
; # (== Pid (Cld: pid))
  %50 = icmp eq i32 %0, %49
  br label %$11
$11:
  %51 = phi i8* [%40, %$10], [%44, %$12] ; # P
  %52 = phi i8* [%41, %$10], [%45, %$12] ; # Q
  %53 = phi i8* [%42, %$10], [%46, %$12] ; # Cld
  %54 = phi i1 [1, %$10], [%50, %$12] ; # ->
  br label %$9
$9:
  %55 = phi i8* [%33, %$7], [%51, %$11] ; # P
  %56 = phi i8* [%34, %$7], [%52, %$11] ; # Q
  %57 = phi i8* [%35, %$7], [%53, %$11] ; # Cld
  %58 = phi i1 [0, %$7], [%54, %$11] ; # ->
  br i1 %58, label %$13, label %$14
$13:
  %59 = phi i8* [%55, %$9] ; # P
  %60 = phi i8* [%56, %$9] ; # Q
  %61 = phi i8* [%57, %$9] ; # Cld
; # (wrChild Cld Q N)
  call void @wrChild(i8* %61, i8* %60, i32 %8)
  br label %$14
$14:
  %62 = phi i8* [%55, %$9], [%59, %$13] ; # P
  %63 = phi i8* [%56, %$9], [%60, %$13] ; # Q
  %64 = phi i8* [%57, %$9], [%61, %$13] ; # Cld
; # (ofs Cld (child T))
  %65 = getelementptr i8, i8* %64, i32 28
  br label %$6
$8:
  %66 = phi i8* [%29, %$6] ; # P
  %67 = phi i8* [%30, %$6] ; # Q
  %68 = phi i8* [%31, %$6] ; # Cld
  ret void
}

define void @unsync() align 8 {
$1:
; # (when (val $Tell) (let Fd @ (unless (wrBytes Fd (i8* (push 0)) 8)...
; # (val $Tell)
  %0 = load i32, i32* @$Tell
  %1 = icmp ne i32 %0, 0
  br i1 %1, label %$2, label %$3
$2:
; # (let Fd @ (unless (wrBytes Fd (i8* (push 0)) 8) (close Fd) (set $...
; # (unless (wrBytes Fd (i8* (push 0)) 8) (close Fd) (set $Tell 0))
; # (push 0)
  %2 = alloca i64, i64 1
  store i64 0, i64* %2
; # (i8* (push 0))
  %3 = bitcast i64* %2 to i8*
; # (wrBytes Fd (i8* (push 0)) 8)
  %4 = call i1 @wrBytes(i32 %0, i8* %3, i32 8)
  br i1 %4, label %$5, label %$4
$4:
; # (close Fd)
  %5 = call i32 @close(i32 %0)
; # (set $Tell 0)
  store i32 0, i32* @$Tell
  br label %$5
$5:
  br label %$3
$3:
; # (set $Sync NO)
  store i1 0, i1* @$Sync
  ret void
}

define void @waitFile(i32) align 8 {
$1:
; # (let Res (b32 1) (while (lt0 (waitpid Pid Res 0)) (unless (== (gE...
; # (b32 1)
  %1 = alloca i32, i64 1
; # (while (lt0 (waitpid Pid Res 0)) (unless (== (gErrno) EINTR) (clo...
  br label %$2
$2:
; # (waitpid Pid Res 0)
  %2 = call i32 @waitpid(i32 %0, i32* %1, i32 0)
; # (lt0 (waitpid Pid Res 0))
  %3 = icmp slt i32 %2, 0
  br i1 %3, label %$3, label %$4
$3:
; # (unless (== (gErrno) EINTR) (closeErr))
; # (gErrno)
  %4 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %5 = icmp eq i32 %4, 2
  br i1 %5, label %$6, label %$5
$5:
; # (closeErr)
  call void @closeErr()
  unreachable
$6:
; # (sigChk 0)
  %6 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %$7, label %$8
$7:
  call void @sighandler(i64 0)
  br label %$8
$8:
  br label %$2
$4:
; # (set $At2 (cnt (i64 (val Res))))
; # (val Res)
  %8 = load i32, i32* %1
; # (i64 (val Res))
  %9 = sext i32 %8 to i64
; # (cnt (i64 (val Res)))
  %10 = shl i64 %9, 4
  %11 = or i64 %10, 2
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %11, i64* %12
  ret void
}

define i32 @currFd(i64) align 8 {
$1:
; # (let (In (val $InFrames) Out (val $OutFrames)) (nond ((or In Out)...
; # (val $InFrames)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (val $OutFrames)
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (nond ((or In Out) (err Exe 0 ($ "No current fd") null)) (Out ((i...
; # (or In Out)
  %3 = icmp ne i8* %1, null
  br i1 %3, label %$3, label %$4
$4:
  %4 = icmp ne i8* %2, null
  br label %$3
$3:
  %5 = phi i1 [1, %$1], [%4, %$4] ; # ->
  br i1 %5, label %$5, label %$6
$6:
; # (err Exe 0 ($ "No current fd") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([14 x i8]* @$40 to i8*), i8* null)
  unreachable
$5:
  %6 = icmp ne i8* %2, null
  br i1 %6, label %$7, label %$8
$8:
; # ((ioFrame In) file)
  %7 = getelementptr i8, i8* %1, i32 8
  %8 = bitcast i8* %7 to i8**
  %9 = load i8*, i8** %8
; # ((inFile ((ioFrame In) file)) fd)
  %10 = getelementptr i8, i8* %9, i32 8
  %11 = bitcast i8* %10 to i32*
  %12 = load i32, i32* %11
  br label %$2
$7:
  %13 = icmp ne i8* %1, null
  br i1 %13, label %$9, label %$10
$10:
; # ((ioFrame Out) file)
  %14 = getelementptr i8, i8* %2, i32 8
  %15 = bitcast i8* %14 to i8**
  %16 = load i8*, i8** %15
; # ((outFile ((ioFrame Out) file)) fd)
  %17 = bitcast i8* %16 to i32*
  %18 = load i32, i32* %17
  br label %$2
$9:
; # (if (if (> In (stack)) (> Out In) (> In Out)) ((inFile ((ioFrame ...
; # (if (> In (stack)) (> Out In) (> In Out))
; # (stack)
  %19 = call i8* @llvm.stacksave()
; # (> In (stack))
  %20 = icmp ugt i8* %1, %19
  br i1 %20, label %$11, label %$12
$11:
; # (> Out In)
  %21 = icmp ugt i8* %2, %1
  br label %$13
$12:
; # (> In Out)
  %22 = icmp ugt i8* %1, %2
  br label %$13
$13:
  %23 = phi i1 [%21, %$11], [%22, %$12] ; # ->
  br i1 %23, label %$14, label %$15
$14:
; # ((ioFrame In) file)
  %24 = getelementptr i8, i8* %1, i32 8
  %25 = bitcast i8* %24 to i8**
  %26 = load i8*, i8** %25
; # ((inFile ((ioFrame In) file)) fd)
  %27 = getelementptr i8, i8* %26, i32 8
  %28 = bitcast i8* %27 to i32*
  %29 = load i32, i32* %28
  br label %$16
$15:
; # ((ioFrame Out) file)
  %30 = getelementptr i8, i8* %2, i32 8
  %31 = bitcast i8* %30 to i8**
  %32 = load i8*, i8** %31
; # ((outFile ((ioFrame Out) file)) fd)
  %33 = bitcast i8* %32 to i32*
  %34 = load i32, i32* %33
  br label %$16
$16:
  %35 = phi i32 [%29, %$14], [%34, %$15] ; # ->
  br label %$2
$2:
  %36 = phi i32 [%12, %$8], [%18, %$10], [%35, %$16] ; # ->
  ret i32 %36
}

define void @pushInFile(i8*, i8*, i32) align 8 {
$1:
; # (let Io: (ioFrame Io) (when (val $InFile) ((inFile @) chr (val $C...
; # (when (val $InFile) ((inFile @) chr (val $Chr)))
; # (val $InFile)
  %3 = load i8*, i8** @$InFile
  %4 = icmp ne i8* %3, null
  br i1 %4, label %$2, label %$3
$2:
; # ((inFile @) chr (val $Chr))
  %5 = getelementptr i8, i8* %3, i32 12
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* @$Chr
  store i32 %7, i32* %6
  br label %$3
$3:
; # (when (Io: link (val $InFrames)) ((ioFrame @) fun (val (i8** $Get...
; # (Io: link (val $InFrames))
  %8 = bitcast i8* %0 to i8**
  %9 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
  store i8* %9, i8** %8
  %10 = icmp ne i8* %9, null
  br i1 %10, label %$4, label %$5
$4:
; # ((ioFrame @) fun (val (i8** $Get)))
  %11 = getelementptr i8, i8* %9, i32 16
  %12 = bitcast i8* %11 to i8**
  %13 = bitcast i32()** @$Get to i8**
  %14 = load i8*, i8** %13
  store i8* %14, i8** %12
  br label %$5
$5:
; # (set $Get (fun (i32) _getStdin))
; # (fun (i32) _getStdin)
  store i32()* @_getStdin, i32()** @$Get
; # (set $Chr ((inFile (Io: file (set $InFile In))) chr))
; # (Io: file (set $InFile In))
  %15 = getelementptr i8, i8* %0, i32 8
  %16 = bitcast i8* %15 to i8**
  store i8* %1, i8** @$InFile
  store i8* %1, i8** %16
; # ((inFile (Io: file (set $InFile In))) chr)
  %17 = getelementptr i8, i8* %1, i32 12
  %18 = bitcast i8* %17 to i32*
  %19 = load i32, i32* %18
  store i32 %19, i32* @$Chr
; # (Io: pid Pid)
  %20 = getelementptr i8, i8* %0, i32 24
  %21 = bitcast i8* %20 to i32*
  store i32 %2, i32* %21
; # (set $InFrames (Io:))
; # (Io:)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
  ret void
}

define void @pushOutFile(i8*, i8*, i32) align 8 {
$1:
; # (let Io: (ioFrame Io) (when (Io: link (val $OutFrames)) ((ioFrame...
; # (when (Io: link (val $OutFrames)) ((ioFrame @) fun (val (i8** $Pu...
; # (Io: link (val $OutFrames))
  %3 = bitcast i8* %0 to i8**
  %4 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
  store i8* %4, i8** %3
  %5 = icmp ne i8* %4, null
  br i1 %5, label %$2, label %$3
$2:
; # ((ioFrame @) fun (val (i8** $Put)))
  %6 = getelementptr i8, i8* %4, i32 16
  %7 = bitcast i8* %6 to i8**
  %8 = bitcast void(i8)** @$Put to i8**
  %9 = load i8*, i8** %8
  store i8* %9, i8** %7
  br label %$3
$3:
; # (set $Put (fun (void i8) _putStdout))
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$Put
; # (Io: file (set $OutFile Out))
  %10 = getelementptr i8, i8* %0, i32 8
  %11 = bitcast i8* %10 to i8**
  store i8* %1, i8** @$OutFile
  store i8* %1, i8** %11
; # (Io: pid Pid)
  %12 = getelementptr i8, i8* %0, i32 24
  %13 = bitcast i8* %12 to i32*
  store i32 %2, i32* %13
; # (set $OutFrames (Io:))
; # (Io:)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
  ret void
}

define void @pushErrFile(i8*) align 8 {
$1:
; # ((ctFrame Ct) link (val $ErrFrames))
  %1 = bitcast i8* %0 to i8**
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 48) to i8**)
  store i8* %2, i8** %1
; # (set $ErrFrames Ct)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 48) to i8**)
  ret void
}

define void @pushCtlFile(i8*) align 8 {
$1:
; # ((ctFrame Ct) link (val $CtlFrames))
  %1 = bitcast i8* %0 to i8**
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 56) to i8**)
  store i8* %2, i8** %1
; # (set $CtlFrames Ct)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 56) to i8**)
  ret void
}

define void @popInFiles() align 8 {
$1:
; # (let (Io: (ioFrame (val $InFrames)) In: (inFile (Io: file))) (whe...
; # (val $InFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (Io: file)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i8**
  %3 = load i8*, i8** %2
; # (when (ge0 (In: fd)) (ifn (Io: pid) (In: chr (val $Chr)) (close (...
; # (In: fd)
  %4 = getelementptr i8, i8* %3, i32 8
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5
; # (ge0 (In: fd))
  %7 = icmp sge i32 %6, 0
  br i1 %7, label %$2, label %$3
$2:
; # (ifn (Io: pid) (In: chr (val $Chr)) (close (In: fd)) (closeInFile...
; # (Io: pid)
  %8 = getelementptr i8, i8* %0, i32 24
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %$5, label %$4
$4:
; # (In: chr (val $Chr))
  %12 = getelementptr i8, i8* %3, i32 12
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* @$Chr
  store i32 %14, i32* %13
  br label %$6
$5:
; # (In: fd)
  %15 = getelementptr i8, i8* %3, i32 8
  %16 = bitcast i8* %15 to i32*
  %17 = load i32, i32* %16
; # (close (In: fd))
  %18 = call i32 @close(i32 %17)
; # (In: fd)
  %19 = getelementptr i8, i8* %3, i32 8
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* %20
; # (closeInFile (In: fd))
  call void @closeInFile(i32 %21)
; # (when (> (Io: pid) 1) (waitFile @))
; # (Io: pid)
  %22 = getelementptr i8, i8* %0, i32 24
  %23 = bitcast i8* %22 to i32*
  %24 = load i32, i32* %23
; # (> (Io: pid) 1)
  %25 = icmp sgt i32 %24, 1
  br i1 %25, label %$7, label %$8
$7:
; # (waitFile @)
  call void @waitFile(i32 %24)
  br label %$8
$8:
  br label %$6
$6:
  br label %$3
$3:
; # (set $InFrames (Io: link))
; # (Io: link)
  %26 = bitcast i8* %0 to i8**
  %27 = load i8*, i8** %26
  store i8* %27, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
  ret void
}

define void @tosInFile() align 8 {
$1:
; # (let Io: (ioFrame (val $InFrames)) (set $Chr ((inFile (set $InFil...
; # (val $InFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (set $Chr ((inFile (set $InFile (Io: file))) chr) (i8** $Get) (Io...
; # (set $InFile (Io: file))
; # (Io: file)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i8**
  %3 = load i8*, i8** %2
  store i8* %3, i8** @$InFile
; # ((inFile (set $InFile (Io: file))) chr)
  %4 = getelementptr i8, i8* %3, i32 12
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5
  store i32 %6, i32* @$Chr
; # (i8** $Get)
  %7 = bitcast i32()** @$Get to i8**
; # (Io: fun)
  %8 = getelementptr i8, i8* %0, i32 16
  %9 = bitcast i8* %8 to i8**
  %10 = load i8*, i8** %9
  store i8* %10, i8** %7
  ret void
}

define void @popOutFiles() align 8 {
$1:
; # (val $OutFile)
  %0 = load i8*, i8** @$OutFile
; # (flush (val $OutFile))
  %1 = call i1 @flush(i8* %0)
; # (let (Io: (ioFrame (val $OutFrames)) Out: (outFile (Io: file))) (...
; # (val $OutFrames)
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (Io: file)
  %3 = getelementptr i8, i8* %2, i32 8
  %4 = bitcast i8* %3 to i8**
  %5 = load i8*, i8** %4
; # (when (ge0 (Out: fd)) (when (Io: pid) (close (Out: fd)) (closeOut...
; # (Out: fd)
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
; # (ge0 (Out: fd))
  %8 = icmp sge i32 %7, 0
  br i1 %8, label %$2, label %$3
$2:
; # (when (Io: pid) (close (Out: fd)) (closeOutFile (Out: fd)) (when ...
; # (Io: pid)
  %9 = getelementptr i8, i8* %2, i32 24
  %10 = bitcast i8* %9 to i32*
  %11 = load i32, i32* %10
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %$4, label %$5
$4:
; # (Out: fd)
  %13 = bitcast i8* %5 to i32*
  %14 = load i32, i32* %13
; # (close (Out: fd))
  %15 = call i32 @close(i32 %14)
; # (Out: fd)
  %16 = bitcast i8* %5 to i32*
  %17 = load i32, i32* %16
; # (closeOutFile (Out: fd))
  call void @closeOutFile(i32 %17)
; # (when (> (Io: pid) 1) (waitFile @))
; # (Io: pid)
  %18 = getelementptr i8, i8* %2, i32 24
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19
; # (> (Io: pid) 1)
  %21 = icmp sgt i32 %20, 1
  br i1 %21, label %$6, label %$7
$6:
; # (waitFile @)
  call void @waitFile(i32 %20)
  br label %$7
$7:
  br label %$5
$5:
  br label %$3
$3:
; # (set $OutFrames (Io: link))
; # (Io: link)
  %22 = bitcast i8* %2 to i8**
  %23 = load i8*, i8** %22
  store i8* %23, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
  ret void
}

define void @tosOutFile() align 8 {
$1:
; # (let Io: (ioFrame (val $OutFrames)) (set $OutFile (Io: file) (i8*...
; # (val $OutFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (set $OutFile (Io: file) (i8** $Put) (Io: fun))
; # (Io: file)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i8**
  %3 = load i8*, i8** %2
  store i8* %3, i8** @$OutFile
; # (i8** $Put)
  %4 = bitcast void(i8)** @$Put to i8**
; # (Io: fun)
  %5 = getelementptr i8, i8* %0, i32 16
  %6 = bitcast i8* %5 to i8**
  %7 = load i8*, i8** %6
  store i8* %7, i8** %4
  ret void
}

define void @popErrFiles() align 8 {
$1:
; # (let Ct: (ctFrame (val $ErrFrames)) (dup2 (Ct: fd) 2) (close (Ct:...
; # (val $ErrFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 48) to i8**)
; # (Ct: fd)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (dup2 (Ct: fd) 2)
  %4 = call i32 @dup2(i32 %3, i32 2)
; # (Ct: fd)
  %5 = getelementptr i8, i8* %0, i32 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
; # (close (Ct: fd))
  %8 = call i32 @close(i32 %7)
; # (set $ErrFrames (Ct: link))
; # (Ct: link)
  %9 = bitcast i8* %0 to i8**
  %10 = load i8*, i8** %9
  store i8* %10, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 48) to i8**)
  ret void
}

define void @popCtlFiles() align 8 {
$1:
; # (let Ct: (ctFrame (val $CtlFrames)) (if (ge0 (Ct: fd)) (close @) ...
; # (val $CtlFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 56) to i8**)
; # (if (ge0 (Ct: fd)) (close @) (unLock (currFd 0) 0 0))
; # (Ct: fd)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (ge0 (Ct: fd))
  %4 = icmp sge i32 %3, 0
  br i1 %4, label %$2, label %$3
$2:
; # (close @)
  %5 = call i32 @close(i32 %3)
  br label %$4
$3:
; # (currFd 0)
  %6 = call i32 @currFd(i64 0)
; # (unLock (currFd 0) 0 0)
  %7 = call i32 @unLock(i32 %6, i64 0, i64 0)
  br label %$4
$4:
  %8 = phi i32 [%5, %$2], [%7, %$3] ; # ->
; # (set $CtlFrames (Ct: link))
; # (Ct: link)
  %9 = bitcast i8* %0 to i8**
  %10 = load i8*, i8** %9
  store i8* %10, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 56) to i8**)
  ret void
}

define i64 @_path(i64) align 8 {
$1:
; # (let Nm (xName Exe (evSym (cdr Exe))) (mkStr (pathString Nm (b8 (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym (cdr Exe)))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %6 = call i64 @pathSize(i64 %5)
; # (b8 (pathSize Nm))
  %7 = alloca i8, i64 %6
; # (pathString Nm (b8 (pathSize Nm)))
  %8 = call i8* @pathString(i64 %5, i8* %7)
; # (mkStr (pathString Nm (b8 (pathSize Nm))))
  %9 = call i64 @mkStr(i8* %8)
  ret i64 %9
}

define i64* @pollfd(i32) align 8 {
$1:
; # (let I (val $Nfds) (when (>= Fd I) (let P (set $Poll (i64* (alloc...
; # (val $Nfds)
  %1 = load i32, i32* @$Nfds
; # (when (>= Fd I) (let P (set $Poll (i64* (alloc (i8* (val $Poll)) ...
; # (>= Fd I)
  %2 = icmp sge i32 %0, %1
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i32 [%1, %$1] ; # I
; # (let P (set $Poll (i64* (alloc (i8* (val $Poll)) (* 8 (i64 (set $...
; # (set $Poll (i64* (alloc (i8* (val $Poll)) (* 8 (i64 (set $Nfds (+...
; # (val $Poll)
  %4 = load i64*, i64** @$Poll
; # (i8* (val $Poll))
  %5 = bitcast i64* %4 to i8*
; # (set $Nfds (+ Fd 1))
; # (+ Fd 1)
  %6 = add i32 %0, 1
  store i32 %6, i32* @$Nfds
; # (i64 (set $Nfds (+ Fd 1)))
  %7 = sext i32 %6 to i64
; # (* 8 (i64 (set $Nfds (+ Fd 1))))
  %8 = mul i64 8, %7
; # (alloc (i8* (val $Poll)) (* 8 (i64 (set $Nfds (+ Fd 1)))))
  %9 = call i8* @alloc(i8* %5, i64 %8)
; # (i64* (alloc (i8* (val $Poll)) (* 8 (i64 (set $Nfds (+ Fd 1))))))...
  %10 = bitcast i8* %9 to i64*
  store i64* %10, i64** @$Poll
; # (loop (pollIgn (ofs P I)) (? (== I Fd)) (inc 'I))
  br label %$4
$4:
  %11 = phi i32 [%3, %$2], [%15, %$5] ; # I
; # (ofs P I)
  %12 = getelementptr i64, i64* %10, i32 %11
; # (pollIgn (ofs P I))
  call void @pollIgn(i64* %12)
; # (? (== I Fd))
; # (== I Fd)
  %13 = icmp eq i32 %11, %0
  br i1 %13, label %$6, label %$5
$5:
  %14 = phi i32 [%11, %$4] ; # I
; # (inc 'I)
  %15 = add i32 %14, 1
  br label %$4
$6:
  %16 = phi i32 [%11, %$4] ; # I
  %17 = phi i64 [0, %$4] ; # ->
  br label %$3
$3:
  %18 = phi i32 [%1, %$1], [%16, %$6] ; # I
; # (val $Poll)
  %19 = load i64*, i64** @$Poll
; # (ofs (val $Poll) Fd)
  %20 = getelementptr i64, i64* %19, i32 %0
  ret i64* %20
}

define i1 @hasData(i32) align 8 {
$1:
; # (and (> (val $InFDs) Fd) (val (ofs (val $InFiles) Fd)) (let In: (...
; # (val $InFDs)
  %1 = load i32, i32* @$InFDs
; # (> (val $InFDs) Fd)
  %2 = icmp sgt i32 %1, %0
  br i1 %2, label %$3, label %$2
$3:
; # (val $InFiles)
  %3 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %4 = getelementptr i8*, i8** %3, i32 %0
; # (val (ofs (val $InFiles) Fd))
  %5 = load i8*, i8** %4
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$4, label %$2
$4:
; # (let In: (inFile @) (and (ge0 (In: fd)) (> (In: cnt) (In: ix))))
; # (and (ge0 (In: fd)) (> (In: cnt) (In: ix)))
; # (In: fd)
  %7 = getelementptr i8, i8* %5, i32 8
  %8 = bitcast i8* %7 to i32*
  %9 = load i32, i32* %8
; # (ge0 (In: fd))
  %10 = icmp sge i32 %9, 0
  br i1 %10, label %$6, label %$5
$6:
; # (In: cnt)
  %11 = getelementptr i8, i8* %5, i32 28
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
; # (In: ix)
  %14 = getelementptr i8, i8* %5, i32 24
  %15 = bitcast i8* %14 to i32*
  %16 = load i32, i32* %15
; # (> (In: cnt) (In: ix))
  %17 = icmp sgt i32 %13, %16
  br label %$5
$5:
  %18 = phi i1 [0, %$4], [%17, %$6] ; # ->
  br label %$2
$2:
  %19 = phi i1 [0, %$1], [0, %$3], [%18, %$5] ; # ->
  ret i1 %19
}

define i1 @inReady(i32, i1) align 8 {
$1:
; # (let P (pollfd Fd) (cond ((>= Fd (val $InFDs)) (readyIn P)) ((=0 ...
; # (pollfd Fd)
  %2 = call i64* @pollfd(i32 %0)
; # (cond ((>= Fd (val $InFDs)) (readyIn P)) ((=0 (val (ofs (val $InF...
; # (val $InFDs)
  %3 = load i32, i32* @$InFDs
; # (>= Fd (val $InFDs))
  %4 = icmp sge i32 %0, %3
  br i1 %4, label %$4, label %$3
$4:
; # (readyIn P)
  %5 = call i1 @readyIn(i64* %2)
  br label %$2
$3:
; # (val $InFiles)
  %6 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %7 = getelementptr i8*, i8** %6, i32 %0
; # (val (ofs (val $InFiles) Fd))
  %8 = load i8*, i8** %7
; # (=0 (val (ofs (val $InFiles) Fd)))
  %9 = icmp eq i8* %8, null
  br i1 %9, label %$6, label %$5
$6:
; # (readyIn P)
  %10 = call i1 @readyIn(i64* %2)
  br label %$2
$5:
; # (let In: (inFile @) (if (lt0 (In: fd)) (readyIn P) (or (> (In: cn...
; # (if (lt0 (In: fd)) (readyIn P) (or (> (In: cnt) (In: ix)) (and (r...
; # (In: fd)
  %11 = getelementptr i8, i8* %8, i32 8
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
; # (lt0 (In: fd))
  %14 = icmp slt i32 %13, 0
  br i1 %14, label %$7, label %$8
$7:
; # (readyIn P)
  %15 = call i1 @readyIn(i64* %2)
  br label %$9
$8:
; # (or (> (In: cnt) (In: ix)) (and (readyIn P) (or Flg (ge0 (slowNb ...
; # (In: cnt)
  %16 = getelementptr i8, i8* %8, i32 28
  %17 = bitcast i8* %16 to i32*
  %18 = load i32, i32* %17
; # (In: ix)
  %19 = getelementptr i8, i8* %8, i32 24
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* %20
; # (> (In: cnt) (In: ix))
  %22 = icmp sgt i32 %18, %21
  br i1 %22, label %$10, label %$11
$11:
; # (and (readyIn P) (or Flg (ge0 (slowNb (In:)))))
; # (readyIn P)
  %23 = call i1 @readyIn(i64* %2)
  br i1 %23, label %$13, label %$12
$13:
; # (or Flg (ge0 (slowNb (In:))))
  br i1 %1, label %$14, label %$15
$15:
; # (In:)
; # (slowNb (In:))
  %24 = call i32 @slowNb(i8* %8)
; # (ge0 (slowNb (In:)))
  %25 = icmp sge i32 %24, 0
  br label %$14
$14:
  %26 = phi i1 [1, %$13], [%25, %$15] ; # ->
  br label %$12
$12:
  %27 = phi i1 [0, %$11], [%26, %$14] ; # ->
  br label %$10
$10:
  %28 = phi i1 [1, %$8], [%27, %$12] ; # ->
  br label %$9
$9:
  %29 = phi i1 [%15, %$7], [%28, %$10] ; # ->
  br label %$2
$2:
  %30 = phi i1 [%5, %$4], [%10, %$6], [%29, %$9] ; # ->
  ret i1 %30
}

define i64 @waitFd(i64, i32, i64) align 8 {
$1:
; # (let (Run (save (val $Run)) At (save (val $At)) Buf (b8 (val Pipe...
; # (val $Run)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  %4 = load i64, i64* %3
; # (save (val $Run))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (val $At)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %14 = load i64, i64* %13
; # (save (val $At))
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %22
; # (val PipeBufSize)
  %23 = load i32, i32* @PipeBufSize
; # (b8 (val PipeBufSize))
  %24 = alloca i8, i32 %23
; # (b32 2)
  %25 = alloca i32, i64 2
; # (getMsec)
  %26 = call i64 @getMsec()
; # (stkChk Exe)
  %27 = load i8*, i8** @$StkLimit
  %28 = call i8* @llvm.stacksave()
  %29 = icmp ugt i8* %27, %28
  br i1 %29, label %$2, label %$3
$2:
  call void @stkErr(i64 %0)
  unreachable
$3:
; # (loop (let Dly Ms (when (ge0 Fd) (if (hasData Fd) (setq Dly 0) (p...
  br label %$4
$4:
  %30 = phi i64 [%2, %$3], [%859, %$148] ; # Ms
  %31 = phi i64 [%4, %$3], [%863, %$148] ; # Run
  %32 = phi i64 [%26, %$3], [%861, %$148] ; # Tim
; # (let Dly Ms (when (ge0 Fd) (if (hasData Fd) (setq Dly 0) (pollIn ...
; # (when (ge0 Fd) (if (hasData Fd) (setq Dly 0) (pollIn Fd (pollfd F...
; # (ge0 Fd)
  %33 = icmp sge i32 %1, 0
  br i1 %33, label %$5, label %$6
$5:
  %34 = phi i64 [%30, %$4] ; # Ms
  %35 = phi i64 [%31, %$4] ; # Run
  %36 = phi i64 [%32, %$4] ; # Tim
  %37 = phi i64 [%30, %$4] ; # Dly
; # (if (hasData Fd) (setq Dly 0) (pollIn Fd (pollfd Fd)))
; # (hasData Fd)
  %38 = call i1 @hasData(i32 %1)
  br i1 %38, label %$7, label %$8
$7:
  %39 = phi i64 [%34, %$5] ; # Ms
  %40 = phi i64 [%35, %$5] ; # Run
  %41 = phi i64 [%36, %$5] ; # Tim
  %42 = phi i64 [%37, %$5] ; # Dly
  br label %$9
$8:
  %43 = phi i64 [%34, %$5] ; # Ms
  %44 = phi i64 [%35, %$5] ; # Run
  %45 = phi i64 [%36, %$5] ; # Tim
  %46 = phi i64 [%37, %$5] ; # Dly
; # (pollfd Fd)
  %47 = call i64* @pollfd(i32 %1)
; # (pollIn Fd (pollfd Fd))
  call void @pollIn(i32 %1, i64* %47)
  br label %$9
$9:
  %48 = phi i64 [%39, %$7], [%43, %$8] ; # Ms
  %49 = phi i64 [%40, %$7], [%44, %$8] ; # Run
  %50 = phi i64 [%41, %$7], [%45, %$8] ; # Tim
  %51 = phi i64 [0, %$7], [%46, %$8] ; # Dly
  br label %$6
$6:
  %52 = phi i64 [%30, %$4], [%48, %$9] ; # Ms
  %53 = phi i64 [%31, %$4], [%49, %$9] ; # Run
  %54 = phi i64 [%32, %$4], [%50, %$9] ; # Tim
  %55 = phi i64 [%30, %$4], [%51, %$9] ; # Dly
; # (let R Run (while (pair R) (let X (++ R) (cond ((sign? (car X)) (...
; # (while (pair R) (let X (++ R) (cond ((sign? (car X)) (let N (int ...
  br label %$10
$10:
  %56 = phi i64 [%52, %$6], [%133, %$13] ; # Ms
  %57 = phi i64 [%53, %$6], [%134, %$13] ; # Run
  %58 = phi i64 [%54, %$6], [%135, %$13] ; # Tim
  %59 = phi i64 [%55, %$6], [%136, %$13] ; # Dly
  %60 = phi i64 [%53, %$6], [%137, %$13] ; # R
; # (pair R)
  %61 = and i64 %60, 15
  %62 = icmp eq i64 %61, 0
  br i1 %62, label %$11, label %$12
$11:
  %63 = phi i64 [%56, %$10] ; # Ms
  %64 = phi i64 [%57, %$10] ; # Run
  %65 = phi i64 [%58, %$10] ; # Tim
  %66 = phi i64 [%59, %$10] ; # Dly
  %67 = phi i64 [%60, %$10] ; # R
; # (let X (++ R) (cond ((sign? (car X)) (let N (int (cadr X)) (when ...
; # (++ R)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
  %70 = getelementptr i64, i64* %68, i32 1
  %71 = load i64, i64* %70
; # (cond ((sign? (car X)) (let N (int (cadr X)) (when (> Dly N) (set...
; # (car X)
  %72 = inttoptr i64 %69 to i64*
  %73 = load i64, i64* %72
; # (sign? (car X))
  %74 = and i64 %73, 8
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$15, label %$14
$15:
  %76 = phi i64 [%63, %$11] ; # Ms
  %77 = phi i64 [%64, %$11] ; # Run
  %78 = phi i64 [%65, %$11] ; # Tim
  %79 = phi i64 [%66, %$11] ; # Dly
  %80 = phi i64 [%71, %$11] ; # R
; # (let N (int (cadr X)) (when (> Dly N) (setq Dly N)))
; # (cadr X)
  %81 = inttoptr i64 %69 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 %83 to i64*
  %85 = load i64, i64* %84
; # (int (cadr X))
  %86 = lshr i64 %85, 4
; # (when (> Dly N) (setq Dly N))
; # (> Dly N)
  %87 = icmp ugt i64 %79, %86
  br i1 %87, label %$16, label %$17
$16:
  %88 = phi i64 [%76, %$15] ; # Ms
  %89 = phi i64 [%77, %$15] ; # Run
  %90 = phi i64 [%78, %$15] ; # Tim
  %91 = phi i64 [%79, %$15] ; # Dly
  %92 = phi i64 [%80, %$15] ; # R
  br label %$17
$17:
  %93 = phi i64 [%76, %$15], [%88, %$16] ; # Ms
  %94 = phi i64 [%77, %$15], [%89, %$16] ; # Run
  %95 = phi i64 [%78, %$15], [%90, %$16] ; # Tim
  %96 = phi i64 [%79, %$15], [%86, %$16] ; # Dly
  %97 = phi i64 [%80, %$15], [%92, %$16] ; # R
  br label %$13
$14:
  %98 = phi i64 [%63, %$11] ; # Ms
  %99 = phi i64 [%64, %$11] ; # Run
  %100 = phi i64 [%65, %$11] ; # Tim
  %101 = phi i64 [%66, %$11] ; # Dly
  %102 = phi i64 [%71, %$11] ; # R
; # (int @)
  %103 = lshr i64 %73, 4
; # (i32 (int @))
  %104 = trunc i64 %103 to i32
; # (<> (i32 (int @)) Fd)
  %105 = icmp ne i32 %104, %1
  br i1 %105, label %$19, label %$18
$19:
  %106 = phi i64 [%98, %$14] ; # Ms
  %107 = phi i64 [%99, %$14] ; # Run
  %108 = phi i64 [%100, %$14] ; # Tim
  %109 = phi i64 [%101, %$14] ; # Dly
  %110 = phi i64 [%102, %$14] ; # R
; # (let N @ (if (hasData N) (setq Dly 0) (pollIn N (pollfd N))))
; # (if (hasData N) (setq Dly 0) (pollIn N (pollfd N)))
; # (hasData N)
  %111 = call i1 @hasData(i32 %104)
  br i1 %111, label %$20, label %$21
$20:
  %112 = phi i64 [%106, %$19] ; # Ms
  %113 = phi i64 [%107, %$19] ; # Run
  %114 = phi i64 [%108, %$19] ; # Tim
  %115 = phi i64 [%109, %$19] ; # Dly
  %116 = phi i64 [%110, %$19] ; # R
  br label %$22
$21:
  %117 = phi i64 [%106, %$19] ; # Ms
  %118 = phi i64 [%107, %$19] ; # Run
  %119 = phi i64 [%108, %$19] ; # Tim
  %120 = phi i64 [%109, %$19] ; # Dly
  %121 = phi i64 [%110, %$19] ; # R
; # (pollfd N)
  %122 = call i64* @pollfd(i32 %104)
; # (pollIn N (pollfd N))
  call void @pollIn(i32 %104, i64* %122)
  br label %$22
$22:
  %123 = phi i64 [%112, %$20], [%117, %$21] ; # Ms
  %124 = phi i64 [%113, %$20], [%118, %$21] ; # Run
  %125 = phi i64 [%114, %$20], [%119, %$21] ; # Tim
  %126 = phi i64 [0, %$20], [%120, %$21] ; # Dly
  %127 = phi i64 [%116, %$20], [%121, %$21] ; # R
  br label %$13
$18:
  %128 = phi i64 [%98, %$14] ; # Ms
  %129 = phi i64 [%99, %$14] ; # Run
  %130 = phi i64 [%100, %$14] ; # Tim
  %131 = phi i64 [%101, %$14] ; # Dly
  %132 = phi i64 [%102, %$14] ; # R
  br label %$13
$13:
  %133 = phi i64 [%93, %$17], [%123, %$22], [%128, %$18] ; # Ms
  %134 = phi i64 [%94, %$17], [%124, %$22], [%129, %$18] ; # Run
  %135 = phi i64 [%95, %$17], [%125, %$22], [%130, %$18] ; # Tim
  %136 = phi i64 [%96, %$17], [%126, %$22], [%131, %$18] ; # Dly
  %137 = phi i64 [%97, %$17], [%127, %$22], [%132, %$18] ; # R
  br label %$10
$12:
  %138 = phi i64 [%56, %$10] ; # Ms
  %139 = phi i64 [%57, %$10] ; # Run
  %140 = phi i64 [%58, %$10] ; # Tim
  %141 = phi i64 [%59, %$10] ; # Dly
  %142 = phi i64 [%60, %$10] ; # R
; # (when (and (val $Hear) (<> @ Fd)) (let N @ (if (hasData N) (setq ...
; # (and (val $Hear) (<> @ Fd))
; # (val $Hear)
  %143 = load i32, i32* @$Hear
  %144 = icmp ne i32 %143, 0
  br i1 %144, label %$24, label %$23
$24:
  %145 = phi i64 [%138, %$12] ; # Ms
  %146 = phi i64 [%139, %$12] ; # Run
  %147 = phi i64 [%140, %$12] ; # Tim
  %148 = phi i64 [%141, %$12] ; # Dly
; # (<> @ Fd)
  %149 = icmp ne i32 %143, %1
  br label %$23
$23:
  %150 = phi i64 [%138, %$12], [%145, %$24] ; # Ms
  %151 = phi i64 [%139, %$12], [%146, %$24] ; # Run
  %152 = phi i64 [%140, %$12], [%147, %$24] ; # Tim
  %153 = phi i64 [%141, %$12], [%148, %$24] ; # Dly
  %154 = phi i1 [0, %$12], [%149, %$24] ; # ->
  br i1 %154, label %$25, label %$26
$25:
  %155 = phi i64 [%150, %$23] ; # Ms
  %156 = phi i64 [%151, %$23] ; # Run
  %157 = phi i64 [%152, %$23] ; # Tim
  %158 = phi i64 [%153, %$23] ; # Dly
; # (let N @ (if (hasData N) (setq Dly 0) (pollIn N (pollfd N))))
; # (if (hasData N) (setq Dly 0) (pollIn N (pollfd N)))
; # (hasData N)
  %159 = call i1 @hasData(i32 %143)
  br i1 %159, label %$27, label %$28
$27:
  %160 = phi i64 [%155, %$25] ; # Ms
  %161 = phi i64 [%156, %$25] ; # Run
  %162 = phi i64 [%157, %$25] ; # Tim
  %163 = phi i64 [%158, %$25] ; # Dly
  br label %$29
$28:
  %164 = phi i64 [%155, %$25] ; # Ms
  %165 = phi i64 [%156, %$25] ; # Run
  %166 = phi i64 [%157, %$25] ; # Tim
  %167 = phi i64 [%158, %$25] ; # Dly
; # (pollfd N)
  %168 = call i64* @pollfd(i32 %143)
; # (pollIn N (pollfd N))
  call void @pollIn(i32 %143, i64* %168)
  br label %$29
$29:
  %169 = phi i64 [%160, %$27], [%164, %$28] ; # Ms
  %170 = phi i64 [%161, %$27], [%165, %$28] ; # Run
  %171 = phi i64 [%162, %$27], [%166, %$28] ; # Tim
  %172 = phi i64 [0, %$27], [%167, %$28] ; # Dly
  br label %$26
$26:
  %173 = phi i64 [%150, %$23], [%169, %$29] ; # Ms
  %174 = phi i64 [%151, %$23], [%170, %$29] ; # Run
  %175 = phi i64 [%152, %$23], [%171, %$29] ; # Tim
  %176 = phi i64 [%153, %$23], [%172, %$29] ; # Dly
; # (when (val $Spkr) (pollIn @ (pollfd @)) (let (Cld (val $Child) <C...
; # (val $Spkr)
  %177 = load i32, i32* @$Spkr
  %178 = icmp ne i32 %177, 0
  br i1 %178, label %$30, label %$31
$30:
  %179 = phi i64 [%173, %$26] ; # Ms
  %180 = phi i64 [%174, %$26] ; # Run
  %181 = phi i64 [%175, %$26] ; # Tim
  %182 = phi i64 [%176, %$26] ; # Dly
; # (pollfd @)
  %183 = call i64* @pollfd(i32 %177)
; # (pollIn @ (pollfd @))
  call void @pollIn(i32 %177, i64* %183)
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %184 = load i8*, i8** @$Child
; # (val $Children)
  %185 = load i32, i32* @$Children
; # (* (val $Children) (child T))
  %186 = mul i32 %185, 28
; # (ofs Cld (* (val $Children) (child T)))
  %187 = getelementptr i8, i8* %184, i32 %186
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (Cld: pid) (poll...
  br label %$32
$32:
  %188 = phi i64 [%179, %$30], [%236, %$36] ; # Ms
  %189 = phi i64 [%180, %$30], [%237, %$36] ; # Run
  %190 = phi i64 [%181, %$30], [%238, %$36] ; # Tim
  %191 = phi i64 [%182, %$30], [%239, %$36] ; # Dly
  %192 = phi i8* [%184, %$30], [%241, %$36] ; # Cld
; # (== Cld <Cld)
  %193 = icmp eq i8* %192, %187
  br i1 %193, label %$34, label %$33
$33:
  %194 = phi i64 [%188, %$32] ; # Ms
  %195 = phi i64 [%189, %$32] ; # Run
  %196 = phi i64 [%190, %$32] ; # Tim
  %197 = phi i64 [%191, %$32] ; # Dly
  %198 = phi i8* [%192, %$32] ; # Cld
; # (let Cld: (child Cld) (when (Cld: pid) (pollIn (Cld: hear) (pollf...
; # (when (Cld: pid) (pollIn (Cld: hear) (pollfd (Cld: hear))) (when ...
; # (Cld: pid)
  %199 = getelementptr i8, i8* %198, i32 16
  %200 = bitcast i8* %199 to i32*
  %201 = load i32, i32* %200
  %202 = icmp ne i32 %201, 0
  br i1 %202, label %$35, label %$36
$35:
  %203 = phi i64 [%194, %$33] ; # Ms
  %204 = phi i64 [%195, %$33] ; # Run
  %205 = phi i64 [%196, %$33] ; # Tim
  %206 = phi i64 [%197, %$33] ; # Dly
  %207 = phi i8* [%198, %$33] ; # Cld
; # (Cld: hear)
  %208 = getelementptr i8, i8* %198, i32 20
  %209 = bitcast i8* %208 to i32*
  %210 = load i32, i32* %209
; # (Cld: hear)
  %211 = getelementptr i8, i8* %198, i32 20
  %212 = bitcast i8* %211 to i32*
  %213 = load i32, i32* %212
; # (pollfd (Cld: hear))
  %214 = call i64* @pollfd(i32 %213)
; # (pollIn (Cld: hear) (pollfd (Cld: hear)))
  call void @pollIn(i32 %210, i64* %214)
; # (when (Cld: cnt) (pollOut (Cld: tell) (pollfd (Cld: tell))))
; # (Cld: cnt)
  %215 = getelementptr i8, i8* %198, i32 12
  %216 = bitcast i8* %215 to i32*
  %217 = load i32, i32* %216
  %218 = icmp ne i32 %217, 0
  br i1 %218, label %$37, label %$38
$37:
  %219 = phi i64 [%203, %$35] ; # Ms
  %220 = phi i64 [%204, %$35] ; # Run
  %221 = phi i64 [%205, %$35] ; # Tim
  %222 = phi i64 [%206, %$35] ; # Dly
  %223 = phi i8* [%207, %$35] ; # Cld
; # (Cld: tell)
  %224 = getelementptr i8, i8* %198, i32 24
  %225 = bitcast i8* %224 to i32*
  %226 = load i32, i32* %225
; # (Cld: tell)
  %227 = getelementptr i8, i8* %198, i32 24
  %228 = bitcast i8* %227 to i32*
  %229 = load i32, i32* %228
; # (pollfd (Cld: tell))
  %230 = call i64* @pollfd(i32 %229)
; # (pollOut (Cld: tell) (pollfd (Cld: tell)))
  call void @pollOut(i32 %226, i64* %230)
  br label %$38
$38:
  %231 = phi i64 [%203, %$35], [%219, %$37] ; # Ms
  %232 = phi i64 [%204, %$35], [%220, %$37] ; # Run
  %233 = phi i64 [%205, %$35], [%221, %$37] ; # Tim
  %234 = phi i64 [%206, %$35], [%222, %$37] ; # Dly
  %235 = phi i8* [%207, %$35], [%223, %$37] ; # Cld
  br label %$36
$36:
  %236 = phi i64 [%194, %$33], [%231, %$38] ; # Ms
  %237 = phi i64 [%195, %$33], [%232, %$38] ; # Run
  %238 = phi i64 [%196, %$33], [%233, %$38] ; # Tim
  %239 = phi i64 [%197, %$33], [%234, %$38] ; # Dly
  %240 = phi i8* [%198, %$33], [%235, %$38] ; # Cld
; # (ofs Cld (child T))
  %241 = getelementptr i8, i8* %240, i32 28
  br label %$32
$34:
  %242 = phi i64 [%188, %$32] ; # Ms
  %243 = phi i64 [%189, %$32] ; # Run
  %244 = phi i64 [%190, %$32] ; # Tim
  %245 = phi i64 [%191, %$32] ; # Dly
  %246 = phi i8* [%192, %$32] ; # Cld
  br label %$31
$31:
  %247 = phi i64 [%173, %$26], [%242, %$34] ; # Ms
  %248 = phi i64 [%174, %$26], [%243, %$34] ; # Run
  %249 = phi i64 [%175, %$26], [%244, %$34] ; # Tim
  %250 = phi i64 [%176, %$26], [%245, %$34] ; # Dly
; # (while (lt0 (gPoll (val $Poll) (val $Nfds) Dly)) (unless (== (gEr...
  br label %$39
$39:
  %251 = phi i64 [%247, %$31], [%270, %$45] ; # Ms
  %252 = phi i64 [%248, %$31], [%271, %$45] ; # Run
  %253 = phi i64 [%249, %$31], [%272, %$45] ; # Tim
  %254 = phi i64 [%250, %$31], [%273, %$45] ; # Dly
; # (val $Poll)
  %255 = load i64*, i64** @$Poll
; # (val $Nfds)
  %256 = load i32, i32* @$Nfds
; # (gPoll (val $Poll) (val $Nfds) Dly)
  %257 = call i32 @gPoll(i64* %255, i32 %256, i64 %254)
; # (lt0 (gPoll (val $Poll) (val $Nfds) Dly))
  %258 = icmp slt i32 %257, 0
  br i1 %258, label %$40, label %$41
$40:
  %259 = phi i64 [%251, %$39] ; # Ms
  %260 = phi i64 [%252, %$39] ; # Run
  %261 = phi i64 [%253, %$39] ; # Tim
  %262 = phi i64 [%254, %$39] ; # Dly
; # (unless (== (gErrno) EINTR) (set $Run $Nil) (selectErr Exe))
; # (gErrno)
  %263 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %264 = icmp eq i32 %263, 2
  br i1 %264, label %$43, label %$42
$42:
  %265 = phi i64 [%259, %$40] ; # Ms
  %266 = phi i64 [%260, %$40] ; # Run
  %267 = phi i64 [%261, %$40] ; # Tim
  %268 = phi i64 [%262, %$40] ; # Dly
; # (set $Run $Nil)
  %269 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %269
; # (selectErr Exe)
  call void @selectErr(i64 %0)
  unreachable
$43:
  %270 = phi i64 [%259, %$40] ; # Ms
  %271 = phi i64 [%260, %$40] ; # Run
  %272 = phi i64 [%261, %$40] ; # Tim
  %273 = phi i64 [%262, %$40] ; # Dly
; # (sigChk Exe)
  %274 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %275 = icmp ne i32 %274, 0
  br i1 %275, label %$44, label %$45
$44:
  call void @sighandler(i64 %0)
  br label %$45
$45:
  br label %$39
$41:
  %276 = phi i64 [%251, %$39] ; # Ms
  %277 = phi i64 [%252, %$39] ; # Run
  %278 = phi i64 [%253, %$39] ; # Tim
  %279 = phi i64 [%254, %$39] ; # Dly
; # (let (Now (getMsec) Dif (- Now Tim)) (when (val $Spkr) (set $Prot...
; # (getMsec)
  %280 = call i64 @getMsec()
; # (- Now Tim)
  %281 = sub i64 %280, %278
; # (when (val $Spkr) (set $Protect (inc (val $Protect))) (let (Cld (...
; # (val $Spkr)
  %282 = load i32, i32* @$Spkr
  %283 = icmp ne i32 %282, 0
  br i1 %283, label %$46, label %$47
$46:
  %284 = phi i64 [%276, %$41] ; # Ms
  %285 = phi i64 [%277, %$41] ; # Run
  %286 = phi i64 [%278, %$41] ; # Tim
; # (set $Protect (inc (val $Protect)))
; # (val $Protect)
  %287 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (inc (val $Protect))
  %288 = add i32 %287, 1
  store i32 %288, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %289 = load i8*, i8** @$Child
; # (val $Children)
  %290 = load i32, i32* @$Children
; # (* (val $Children) (child T))
  %291 = mul i32 %290, 28
; # (ofs Cld (* (val $Children) (child T)))
  %292 = getelementptr i8, i8* %289, i32 %291
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (Cld: pid) (when...
  br label %$48
$48:
  %293 = phi i64 [%284, %$46], [%576, %$-1] ; # Ms
  %294 = phi i64 [%285, %$46], [%577, %$-1] ; # Run
  %295 = phi i64 [%286, %$46], [%578, %$-1] ; # Tim
  %296 = phi i8* [%289, %$46], [%580, %$-1] ; # Cld
; # (== Cld <Cld)
  %297 = icmp eq i8* %296, %292
  br i1 %297, label %$50, label %$49
$49:
  %298 = phi i64 [%293, %$48] ; # Ms
  %299 = phi i64 [%294, %$48] ; # Run
  %300 = phi i64 [%295, %$48] ; # Tim
  %301 = phi i8* [%296, %$48] ; # Cld
; # (let Cld: (child Cld) (when (Cld: pid) (when (readyIn (pollfd (Cl...
; # (when (Cld: pid) (when (readyIn (pollfd (Cld: hear))) (cond ((=0 ...
; # (Cld: pid)
  %302 = getelementptr i8, i8* %301, i32 16
  %303 = bitcast i8* %302 to i32*
  %304 = load i32, i32* %303
  %305 = icmp ne i32 %304, 0
  br i1 %305, label %$51, label %$52
$51:
  %306 = phi i64 [%298, %$49] ; # Ms
  %307 = phi i64 [%299, %$49] ; # Run
  %308 = phi i64 [%300, %$49] ; # Tim
  %309 = phi i8* [%301, %$49] ; # Cld
; # (when (readyIn (pollfd (Cld: hear))) (cond ((=0 (rdBytesNb (Cld: ...
; # (Cld: hear)
  %310 = getelementptr i8, i8* %301, i32 20
  %311 = bitcast i8* %310 to i32*
  %312 = load i32, i32* %311
; # (pollfd (Cld: hear))
  %313 = call i64* @pollfd(i32 %312)
; # (readyIn (pollfd (Cld: hear)))
  %314 = call i1 @readyIn(i64* %313)
  br i1 %314, label %$53, label %$54
$53:
  %315 = phi i64 [%306, %$51] ; # Ms
  %316 = phi i64 [%307, %$51] ; # Run
  %317 = phi i64 [%308, %$51] ; # Tim
  %318 = phi i8* [%309, %$51] ; # Cld
; # (cond ((=0 (rdBytesNb (Cld: hear) (i8* Pn) (* 2 4))) (clsChild Cl...
; # (Cld: hear)
  %319 = getelementptr i8, i8* %301, i32 20
  %320 = bitcast i8* %319 to i32*
  %321 = load i32, i32* %320
; # (i8* Pn)
  %322 = bitcast i32* %25 to i8*
; # (* 2 4)
; # (rdBytesNb (Cld: hear) (i8* Pn) (* 2 4))
  %323 = call i64 @rdBytesNb(i32 %321, i8* %322, i32 8)
; # (=0 (rdBytesNb (Cld: hear) (i8* Pn) (* 2 4)))
  %324 = icmp eq i64 %323, 0
  br i1 %324, label %$57, label %$56
$57:
  %325 = phi i64 [%315, %$53] ; # Ms
  %326 = phi i64 [%316, %$53] ; # Run
  %327 = phi i64 [%317, %$53] ; # Tim
  %328 = phi i8* [%318, %$53] ; # Cld
; # (clsChild Cld)
  call void @clsChild(i8* %328)
; # (goto 1)
  br label %$-1
$56:
  %329 = phi i64 [%315, %$53] ; # Ms
  %330 = phi i64 [%316, %$53] ; # Run
  %331 = phi i64 [%317, %$53] ; # Tim
  %332 = phi i8* [%318, %$53] ; # Cld
; # (gt0 @)
  %333 = icmp sgt i64 %323, 0
  br i1 %333, label %$59, label %$58
$59:
  %334 = phi i64 [%329, %$56] ; # Ms
  %335 = phi i64 [%330, %$56] ; # Run
  %336 = phi i64 [%331, %$56] ; # Tim
  %337 = phi i8* [%332, %$56] ; # Cld
; # (cond ((=0 (val (i64* Pn))) (when (== (Cld: pid) (val $Talking)) ...
; # (i64* Pn)
  %338 = bitcast i32* %25 to i64*
; # (val (i64* Pn))
  %339 = load i64, i64* %338
; # (=0 (val (i64* Pn)))
  %340 = icmp eq i64 %339, 0
  br i1 %340, label %$62, label %$61
$62:
  %341 = phi i64 [%334, %$59] ; # Ms
  %342 = phi i64 [%335, %$59] ; # Run
  %343 = phi i64 [%336, %$59] ; # Tim
  %344 = phi i8* [%337, %$59] ; # Cld
; # (when (== (Cld: pid) (val $Talking)) (set $Talking 0))
; # (Cld: pid)
  %345 = getelementptr i8, i8* %301, i32 16
  %346 = bitcast i8* %345 to i32*
  %347 = load i32, i32* %346
; # (val $Talking)
  %348 = load i32, i32* @$Talking
; # (== (Cld: pid) (val $Talking))
  %349 = icmp eq i32 %347, %348
  br i1 %349, label %$63, label %$64
$63:
  %350 = phi i64 [%341, %$62] ; # Ms
  %351 = phi i64 [%342, %$62] ; # Run
  %352 = phi i64 [%343, %$62] ; # Tim
  %353 = phi i8* [%344, %$62] ; # Cld
; # (set $Talking 0)
  store i32 0, i32* @$Talking
  br label %$64
$64:
  %354 = phi i64 [%341, %$62], [%350, %$63] ; # Ms
  %355 = phi i64 [%342, %$62], [%351, %$63] ; # Run
  %356 = phi i64 [%343, %$62], [%352, %$63] ; # Tim
  %357 = phi i8* [%344, %$62], [%353, %$63] ; # Cld
  br label %$60
$61:
  %358 = phi i64 [%334, %$59] ; # Ms
  %359 = phi i64 [%335, %$59] ; # Run
  %360 = phi i64 [%336, %$59] ; # Tim
  %361 = phi i8* [%337, %$59] ; # Cld
; # (val 2 Pn)
  %362 = getelementptr i32, i32* %25, i32 1
  %363 = load i32, i32* %362
; # (val PipeBufSize)
  %364 = load i32, i32* @PipeBufSize
; # (> (val 2 Pn) (val PipeBufSize))
  %365 = icmp sgt i32 %363, %364
  br i1 %365, label %$66, label %$65
$66:
  %366 = phi i64 [%358, %$61] ; # Ms
  %367 = phi i64 [%359, %$61] ; # Run
  %368 = phi i64 [%360, %$61] ; # Tim
  %369 = phi i8* [%361, %$61] ; # Cld
; # (sizeErr Exe)
  call void @sizeErr(i64 %0)
  unreachable
$65:
  %370 = phi i64 [%358, %$61] ; # Ms
  %371 = phi i64 [%359, %$61] ; # Run
  %372 = phi i64 [%360, %$61] ; # Tim
  %373 = phi i8* [%361, %$61] ; # Cld
; # (Cld: hear)
  %374 = getelementptr i8, i8* %301, i32 20
  %375 = bitcast i8* %374 to i32*
  %376 = load i32, i32* %375
; # (rdBytes (Cld: hear) Buf @)
  %377 = call i1 @rdBytes(i32 %376, i8* %24, i32 %363)
  br i1 %377, label %$68, label %$67
$68:
  %378 = phi i64 [%370, %$65] ; # Ms
  %379 = phi i64 [%371, %$65] ; # Run
  %380 = phi i64 [%372, %$65] ; # Tim
  %381 = phi i8* [%373, %$65] ; # Cld
; # (let (Cld2 (val $Child) <Cld2 (ofs Cld2 (* (val $Children) (child...
; # (val $Child)
  %382 = load i8*, i8** @$Child
; # (val $Children)
  %383 = load i32, i32* @$Children
; # (* (val $Children) (child T))
  %384 = mul i32 %383, 28
; # (ofs Cld2 (* (val $Children) (child T)))
  %385 = getelementptr i8, i8* %382, i32 %384
; # (until (== Cld2 <Cld2) (let Cld2: (child Cld2) (when (and (<> Cld...
  br label %$69
$69:
  %386 = phi i64 [%378, %$68], [%442, %$78] ; # Ms
  %387 = phi i64 [%379, %$68], [%443, %$78] ; # Run
  %388 = phi i64 [%380, %$68], [%444, %$78] ; # Tim
  %389 = phi i8* [%381, %$68], [%445, %$78] ; # Cld
  %390 = phi i8* [%382, %$68], [%447, %$78] ; # Cld2
; # (== Cld2 <Cld2)
  %391 = icmp eq i8* %390, %385
  br i1 %391, label %$71, label %$70
$70:
  %392 = phi i64 [%386, %$69] ; # Ms
  %393 = phi i64 [%387, %$69] ; # Run
  %394 = phi i64 [%388, %$69] ; # Tim
  %395 = phi i8* [%389, %$69] ; # Cld
  %396 = phi i8* [%390, %$69] ; # Cld2
; # (let Cld2: (child Cld2) (when (and (<> Cld Cld2) (Cld2: pid) (or ...
; # (when (and (<> Cld Cld2) (Cld2: pid) (or (=0 (val Pn)) (== @ (Cld...
; # (and (<> Cld Cld2) (Cld2: pid) (or (=0 (val Pn)) (== @ (Cld2: pid...
; # (<> Cld Cld2)
  %397 = icmp ne i8* %395, %396
  br i1 %397, label %$73, label %$72
$73:
  %398 = phi i64 [%392, %$70] ; # Ms
  %399 = phi i64 [%393, %$70] ; # Run
  %400 = phi i64 [%394, %$70] ; # Tim
  %401 = phi i8* [%395, %$70] ; # Cld
  %402 = phi i8* [%396, %$70] ; # Cld2
; # (Cld2: pid)
  %403 = getelementptr i8, i8* %396, i32 16
  %404 = bitcast i8* %403 to i32*
  %405 = load i32, i32* %404
  %406 = icmp ne i32 %405, 0
  br i1 %406, label %$74, label %$72
$74:
  %407 = phi i64 [%398, %$73] ; # Ms
  %408 = phi i64 [%399, %$73] ; # Run
  %409 = phi i64 [%400, %$73] ; # Tim
  %410 = phi i8* [%401, %$73] ; # Cld
  %411 = phi i8* [%402, %$73] ; # Cld2
; # (or (=0 (val Pn)) (== @ (Cld2: pid)))
; # (val Pn)
  %412 = load i32, i32* %25
; # (=0 (val Pn))
  %413 = icmp eq i32 %412, 0
  br i1 %413, label %$75, label %$76
$76:
  %414 = phi i64 [%407, %$74] ; # Ms
  %415 = phi i64 [%408, %$74] ; # Run
  %416 = phi i64 [%409, %$74] ; # Tim
  %417 = phi i8* [%410, %$74] ; # Cld
  %418 = phi i8* [%411, %$74] ; # Cld2
; # (Cld2: pid)
  %419 = getelementptr i8, i8* %396, i32 16
  %420 = bitcast i8* %419 to i32*
  %421 = load i32, i32* %420
; # (== @ (Cld2: pid))
  %422 = icmp eq i32 %412, %421
  br label %$75
$75:
  %423 = phi i64 [%407, %$74], [%414, %$76] ; # Ms
  %424 = phi i64 [%408, %$74], [%415, %$76] ; # Run
  %425 = phi i64 [%409, %$74], [%416, %$76] ; # Tim
  %426 = phi i8* [%410, %$74], [%417, %$76] ; # Cld
  %427 = phi i8* [%411, %$74], [%418, %$76] ; # Cld2
  %428 = phi i1 [1, %$74], [%422, %$76] ; # ->
  br label %$72
$72:
  %429 = phi i64 [%392, %$70], [%398, %$73], [%423, %$75] ; # Ms
  %430 = phi i64 [%393, %$70], [%399, %$73], [%424, %$75] ; # Run
  %431 = phi i64 [%394, %$70], [%400, %$73], [%425, %$75] ; # Tim
  %432 = phi i8* [%395, %$70], [%401, %$73], [%426, %$75] ; # Cld
  %433 = phi i8* [%396, %$70], [%402, %$73], [%427, %$75] ; # Cld2
  %434 = phi i1 [0, %$70], [0, %$73], [%428, %$75] ; # ->
  br i1 %434, label %$77, label %$78
$77:
  %435 = phi i64 [%429, %$72] ; # Ms
  %436 = phi i64 [%430, %$72] ; # Run
  %437 = phi i64 [%431, %$72] ; # Tim
  %438 = phi i8* [%432, %$72] ; # Cld
  %439 = phi i8* [%433, %$72] ; # Cld2
; # (val 2 Pn)
  %440 = getelementptr i32, i32* %25, i32 1
  %441 = load i32, i32* %440
; # (wrChild Cld2 Buf (val 2 Pn))
  call void @wrChild(i8* %439, i8* %24, i32 %441)
  br label %$78
$78:
  %442 = phi i64 [%429, %$72], [%435, %$77] ; # Ms
  %443 = phi i64 [%430, %$72], [%436, %$77] ; # Run
  %444 = phi i64 [%431, %$72], [%437, %$77] ; # Tim
  %445 = phi i8* [%432, %$72], [%438, %$77] ; # Cld
  %446 = phi i8* [%433, %$72], [%439, %$77] ; # Cld2
; # (ofs Cld2 (child T))
  %447 = getelementptr i8, i8* %446, i32 28
  br label %$69
$71:
  %448 = phi i64 [%386, %$69] ; # Ms
  %449 = phi i64 [%387, %$69] ; # Run
  %450 = phi i64 [%388, %$69] ; # Tim
  %451 = phi i8* [%389, %$69] ; # Cld
  %452 = phi i8* [%390, %$69] ; # Cld2
  br label %$60
$67:
  %453 = phi i64 [%370, %$65] ; # Ms
  %454 = phi i64 [%371, %$65] ; # Run
  %455 = phi i64 [%372, %$65] ; # Tim
  %456 = phi i8* [%373, %$65] ; # Cld
; # (clsChild Cld)
  call void @clsChild(i8* %456)
; # (goto 1)
  br label %$-1
$60:
  %457 = phi i64 [%354, %$64], [%448, %$71] ; # Ms
  %458 = phi i64 [%355, %$64], [%449, %$71] ; # Run
  %459 = phi i64 [%356, %$64], [%450, %$71] ; # Tim
  %460 = phi i8* [%357, %$64], [%451, %$71] ; # Cld
  br label %$55
$58:
  %461 = phi i64 [%329, %$56] ; # Ms
  %462 = phi i64 [%330, %$56] ; # Run
  %463 = phi i64 [%331, %$56] ; # Tim
  %464 = phi i8* [%332, %$56] ; # Cld
  br label %$55
$55:
  %465 = phi i64 [%457, %$60], [%461, %$58] ; # Ms
  %466 = phi i64 [%458, %$60], [%462, %$58] ; # Run
  %467 = phi i64 [%459, %$60], [%463, %$58] ; # Tim
  %468 = phi i8* [%460, %$60], [%464, %$58] ; # Cld
  br label %$54
$54:
  %469 = phi i64 [%306, %$51], [%465, %$55] ; # Ms
  %470 = phi i64 [%307, %$51], [%466, %$55] ; # Run
  %471 = phi i64 [%308, %$51], [%467, %$55] ; # Tim
  %472 = phi i8* [%309, %$51], [%468, %$55] ; # Cld
; # (when (readyOut (pollfd (Cld: tell))) (let (P (ofs (Cld: buf) (Cl...
; # (Cld: tell)
  %473 = getelementptr i8, i8* %301, i32 24
  %474 = bitcast i8* %473 to i32*
  %475 = load i32, i32* %474
; # (pollfd (Cld: tell))
  %476 = call i64* @pollfd(i32 %475)
; # (readyOut (pollfd (Cld: tell)))
  %477 = call i1 @readyOut(i64* %476)
  br i1 %477, label %$79, label %$80
$79:
  %478 = phi i64 [%469, %$54] ; # Ms
  %479 = phi i64 [%470, %$54] ; # Run
  %480 = phi i64 [%471, %$54] ; # Tim
  %481 = phi i8* [%472, %$54] ; # Cld
; # (let (P (ofs (Cld: buf) (Cld: ofs)) N (val (i32* P))) (ifn (wrByt...
; # (Cld: buf)
  %482 = bitcast i8* %301 to i8**
  %483 = load i8*, i8** %482
; # (Cld: ofs)
  %484 = getelementptr i8, i8* %301, i32 8
  %485 = bitcast i8* %484 to i32*
  %486 = load i32, i32* %485
; # (ofs (Cld: buf) (Cld: ofs))
  %487 = getelementptr i8, i8* %483, i32 %486
; # (i32* P)
  %488 = bitcast i8* %487 to i32*
; # (val (i32* P))
  %489 = load i32, i32* %488
; # (ifn (wrBytes (Cld: tell) (ofs P 4) N) (clsChild Cld) (setq N (Cl...
; # (Cld: tell)
  %490 = getelementptr i8, i8* %301, i32 24
  %491 = bitcast i8* %490 to i32*
  %492 = load i32, i32* %491
; # (ofs P 4)
  %493 = getelementptr i8, i8* %487, i32 4
; # (wrBytes (Cld: tell) (ofs P 4) N)
  %494 = call i1 @wrBytes(i32 %492, i8* %493, i32 %489)
  br i1 %494, label %$82, label %$81
$81:
  %495 = phi i64 [%478, %$79] ; # Ms
  %496 = phi i64 [%479, %$79] ; # Run
  %497 = phi i64 [%480, %$79] ; # Tim
  %498 = phi i8* [%481, %$79] ; # Cld
  %499 = phi i32 [%489, %$79] ; # N
; # (clsChild Cld)
  call void @clsChild(i8* %498)
  br label %$83
$82:
  %500 = phi i64 [%478, %$79] ; # Ms
  %501 = phi i64 [%479, %$79] ; # Run
  %502 = phi i64 [%480, %$79] ; # Tim
  %503 = phi i8* [%481, %$79] ; # Cld
  %504 = phi i32 [%489, %$79] ; # N
; # (Cld: ofs (+ (Cld: ofs) N 4))
  %505 = getelementptr i8, i8* %301, i32 8
  %506 = bitcast i8* %505 to i32*
  %507 = getelementptr i8, i8* %301, i32 8
  %508 = bitcast i8* %507 to i32*
  %509 = load i32, i32* %508
  %510 = add i32 %509, %504
  %511 = add i32 %510, 4
  store i32 %511, i32* %506
; # (when (>= (* 2 N) (Cld: cnt)) (when (Cld: cnt (- (Cld: cnt) N)) (...
; # (* 2 N)
  %512 = mul i32 2, %511
; # (Cld: cnt)
  %513 = getelementptr i8, i8* %301, i32 12
  %514 = bitcast i8* %513 to i32*
  %515 = load i32, i32* %514
; # (>= (* 2 N) (Cld: cnt))
  %516 = icmp sge i32 %512, %515
  br i1 %516, label %$84, label %$85
$84:
  %517 = phi i64 [%500, %$82] ; # Ms
  %518 = phi i64 [%501, %$82] ; # Run
  %519 = phi i64 [%502, %$82] ; # Tim
  %520 = phi i8* [%503, %$82] ; # Cld
  %521 = phi i32 [%511, %$82] ; # N
; # (when (Cld: cnt (- (Cld: cnt) N)) (memcpy (Cld: buf) (ofs (Cld: b...
; # (Cld: cnt (- (Cld: cnt) N))
  %522 = getelementptr i8, i8* %301, i32 12
  %523 = bitcast i8* %522 to i32*
  %524 = getelementptr i8, i8* %301, i32 12
  %525 = bitcast i8* %524 to i32*
  %526 = load i32, i32* %525
  %527 = sub i32 %526, %521
  store i32 %527, i32* %523
  %528 = icmp ne i32 %527, 0
  br i1 %528, label %$86, label %$87
$86:
  %529 = phi i64 [%517, %$84] ; # Ms
  %530 = phi i64 [%518, %$84] ; # Run
  %531 = phi i64 [%519, %$84] ; # Tim
  %532 = phi i8* [%520, %$84] ; # Cld
  %533 = phi i32 [%521, %$84] ; # N
; # (Cld: buf)
  %534 = bitcast i8* %301 to i8**
  %535 = load i8*, i8** %534
; # (Cld: buf)
  %536 = bitcast i8* %301 to i8**
  %537 = load i8*, i8** %536
; # (ofs (Cld: buf) N)
  %538 = getelementptr i8, i8* %537, i32 %533
; # (Cld: cnt)
  %539 = getelementptr i8, i8* %301, i32 12
  %540 = bitcast i8* %539 to i32*
  %541 = load i32, i32* %540
; # (i64 (Cld: cnt))
  %542 = sext i32 %541 to i64
; # (memcpy (Cld: buf) (ofs (Cld: buf) N) (i64 (Cld: cnt)))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %535, i8* %538, i64 %542, i1 0)
; # (Cld: buf (alloc (Cld: buf) (i64 (Cld: cnt))))
  %543 = bitcast i8* %301 to i8**
  %544 = bitcast i8* %301 to i8**
  %545 = load i8*, i8** %544
  %546 = getelementptr i8, i8* %301, i32 12
  %547 = bitcast i8* %546 to i32*
  %548 = load i32, i32* %547
  %549 = sext i32 %548 to i64
  %550 = call i8* @alloc(i8* %545, i64 %549)
  store i8* %550, i8** %543
  br label %$87
$87:
  %551 = phi i64 [%517, %$84], [%529, %$86] ; # Ms
  %552 = phi i64 [%518, %$84], [%530, %$86] ; # Run
  %553 = phi i64 [%519, %$84], [%531, %$86] ; # Tim
  %554 = phi i8* [%520, %$84], [%532, %$86] ; # Cld
  %555 = phi i32 [%521, %$84], [%533, %$86] ; # N
; # (Cld: ofs 0)
  %556 = getelementptr i8, i8* %301, i32 8
  %557 = bitcast i8* %556 to i32*
  store i32 0, i32* %557
  br label %$85
$85:
  %558 = phi i64 [%500, %$82], [%551, %$87] ; # Ms
  %559 = phi i64 [%501, %$82], [%552, %$87] ; # Run
  %560 = phi i64 [%502, %$82], [%553, %$87] ; # Tim
  %561 = phi i8* [%503, %$82], [%554, %$87] ; # Cld
  %562 = phi i32 [%511, %$82], [%555, %$87] ; # N
  br label %$83
$83:
  %563 = phi i64 [%495, %$81], [%558, %$85] ; # Ms
  %564 = phi i64 [%496, %$81], [%559, %$85] ; # Run
  %565 = phi i64 [%497, %$81], [%560, %$85] ; # Tim
  %566 = phi i8* [%498, %$81], [%561, %$85] ; # Cld
  %567 = phi i32 [%499, %$81], [%562, %$85] ; # N
  br label %$80
$80:
  %568 = phi i64 [%469, %$54], [%563, %$83] ; # Ms
  %569 = phi i64 [%470, %$54], [%564, %$83] ; # Run
  %570 = phi i64 [%471, %$54], [%565, %$83] ; # Tim
  %571 = phi i8* [%472, %$54], [%566, %$83] ; # Cld
  br label %$52
$52:
  %572 = phi i64 [%298, %$49], [%568, %$80] ; # Ms
  %573 = phi i64 [%299, %$49], [%569, %$80] ; # Run
  %574 = phi i64 [%300, %$49], [%570, %$80] ; # Tim
  %575 = phi i8* [%301, %$49], [%571, %$80] ; # Cld
; # (: 1 (setq Cld (ofs Cld (child T))))
  br label %$-1
$-1:
  %576 = phi i64 [%325, %$57], [%453, %$67], [%572, %$52] ; # Ms
  %577 = phi i64 [%326, %$57], [%454, %$67], [%573, %$52] ; # Run
  %578 = phi i64 [%327, %$57], [%455, %$67], [%574, %$52] ; # Tim
  %579 = phi i8* [%328, %$57], [%456, %$67], [%575, %$52] ; # Cld
; # (ofs Cld (child T))
  %580 = getelementptr i8, i8* %579, i32 28
  br label %$48
$50:
  %581 = phi i64 [%293, %$48] ; # Ms
  %582 = phi i64 [%294, %$48] ; # Run
  %583 = phi i64 [%295, %$48] ; # Tim
  %584 = phi i8* [%296, %$48] ; # Cld
; # (when (and (=0 (val $Talking)) (readyIn (pollfd (val $Spkr))) (gt...
; # (and (=0 (val $Talking)) (readyIn (pollfd (val $Spkr))) (gt0 (rdB...
; # (val $Talking)
  %585 = load i32, i32* @$Talking
; # (=0 (val $Talking))
  %586 = icmp eq i32 %585, 0
  br i1 %586, label %$89, label %$88
$89:
  %587 = phi i64 [%581, %$50] ; # Ms
  %588 = phi i64 [%582, %$50] ; # Run
  %589 = phi i64 [%583, %$50] ; # Tim
; # (val $Spkr)
  %590 = load i32, i32* @$Spkr
; # (pollfd (val $Spkr))
  %591 = call i64* @pollfd(i32 %590)
; # (readyIn (pollfd (val $Spkr)))
  %592 = call i1 @readyIn(i64* %591)
  br i1 %592, label %$90, label %$88
$90:
  %593 = phi i64 [%587, %$89] ; # Ms
  %594 = phi i64 [%588, %$89] ; # Run
  %595 = phi i64 [%589, %$89] ; # Tim
; # (val $Spkr)
  %596 = load i32, i32* @$Spkr
; # (i8* Pn)
  %597 = bitcast i32* %25 to i8*
; # (rdBytesNb (val $Spkr) (i8* Pn) 4)
  %598 = call i64 @rdBytesNb(i32 %596, i8* %597, i32 4)
; # (gt0 (rdBytesNb (val $Spkr) (i8* Pn) 4))
  %599 = icmp sgt i64 %598, 0
  br label %$88
$88:
  %600 = phi i64 [%581, %$50], [%587, %$89], [%593, %$90] ; # Ms
  %601 = phi i64 [%582, %$50], [%588, %$89], [%594, %$90] ; # Run
  %602 = phi i64 [%583, %$50], [%589, %$89], [%595, %$90] ; # Tim
  %603 = phi i1 [0, %$50], [0, %$89], [%599, %$90] ; # ->
  br i1 %603, label %$91, label %$92
$91:
  %604 = phi i64 [%600, %$88] ; # Ms
  %605 = phi i64 [%601, %$88] ; # Run
  %606 = phi i64 [%602, %$88] ; # Tim
; # (let Cld (ofs (val $Child) (* (val Pn) (child T))) (when ((child ...
; # (val $Child)
  %607 = load i8*, i8** @$Child
; # (val Pn)
  %608 = load i32, i32* %25
; # (* (val Pn) (child T))
  %609 = mul i32 %608, 28
; # (ofs (val $Child) (* (val Pn) (child T)))
  %610 = getelementptr i8, i8* %607, i32 %609
; # (when ((child Cld) pid) (set $Talking @) (wrChild Cld $TBuf 2))
; # ((child Cld) pid)
  %611 = getelementptr i8, i8* %610, i32 16
  %612 = bitcast i8* %611 to i32*
  %613 = load i32, i32* %612
  %614 = icmp ne i32 %613, 0
  br i1 %614, label %$93, label %$94
$93:
  %615 = phi i64 [%604, %$91] ; # Ms
  %616 = phi i64 [%605, %$91] ; # Run
  %617 = phi i64 [%606, %$91] ; # Tim
; # (set $Talking @)
  store i32 %613, i32* @$Talking
; # (wrChild Cld $TBuf 2)
  call void @wrChild(i8* %610, i8* bitcast ([2 x i8]* @$TBuf to i8*), i32 2)
  br label %$94
$94:
  %618 = phi i64 [%604, %$91], [%615, %$93] ; # Ms
  %619 = phi i64 [%605, %$91], [%616, %$93] ; # Run
  %620 = phi i64 [%606, %$91], [%617, %$93] ; # Tim
  br label %$92
$92:
  %621 = phi i64 [%600, %$88], [%618, %$94] ; # Ms
  %622 = phi i64 [%601, %$88], [%619, %$94] ; # Run
  %623 = phi i64 [%602, %$88], [%620, %$94] ; # Tim
; # (set $Protect (dec (val $Protect)))
; # (val $Protect)
  %624 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (dec (val $Protect))
  %625 = sub i32 %624, 1
  store i32 %625, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
  br label %$47
$47:
  %626 = phi i64 [%276, %$41], [%621, %$92] ; # Ms
  %627 = phi i64 [%277, %$41], [%622, %$92] ; # Run
  %628 = phi i64 [%278, %$41], [%623, %$92] ; # Tim
; # (let N (val $Hear) (when (and N (<> N Fd) (inReady N NO)) (let In...
; # (val $Hear)
  %629 = load i32, i32* @$Hear
; # (when (and N (<> N Fd) (inReady N NO)) (let In (val $InFile) (set...
; # (and N (<> N Fd) (inReady N NO))
  %630 = icmp ne i32 %629, 0
  br i1 %630, label %$96, label %$95
$96:
  %631 = phi i64 [%626, %$47] ; # Ms
  %632 = phi i64 [%627, %$47] ; # Run
  %633 = phi i64 [%628, %$47] ; # Tim
; # (<> N Fd)
  %634 = icmp ne i32 %629, %1
  br i1 %634, label %$97, label %$95
$97:
  %635 = phi i64 [%631, %$96] ; # Ms
  %636 = phi i64 [%632, %$96] ; # Run
  %637 = phi i64 [%633, %$96] ; # Tim
; # (inReady N NO)
  %638 = call i1 @inReady(i32 %629, i1 0)
  br label %$95
$95:
  %639 = phi i64 [%626, %$47], [%631, %$96], [%635, %$97] ; # Ms
  %640 = phi i64 [%627, %$47], [%632, %$96], [%636, %$97] ; # Run
  %641 = phi i64 [%628, %$47], [%633, %$96], [%637, %$97] ; # Tim
  %642 = phi i1 [0, %$47], [0, %$96], [%638, %$97] ; # ->
  br i1 %642, label %$98, label %$99
$98:
  %643 = phi i64 [%639, %$95] ; # Ms
  %644 = phi i64 [%640, %$95] ; # Run
  %645 = phi i64 [%641, %$95] ; # Tim
; # (let In (val $InFile) (set $InFile (val (ofs (val $InFiles) (val ...
; # (val $InFile)
  %646 = load i8*, i8** @$InFile
; # (set $InFile (val (ofs (val $InFiles) (val $Hear))) $GetBin (fun ...
; # (val $InFiles)
  %647 = load i8**, i8*** @$InFiles
; # (val $Hear)
  %648 = load i32, i32* @$Hear
; # (ofs (val $InFiles) (val $Hear))
  %649 = getelementptr i8*, i8** %647, i32 %648
; # (val (ofs (val $InFiles) (val $Hear)))
  %650 = load i8*, i8** %649
  store i8* %650, i8** @$InFile
; # (fun (i32) getBinary)
  store i32()* @getBinary, i32()** @$GetBin
  store i32 0, i32* @$Extn
; # (let E (binRead) (cond ((=0 E) (close N) (closeInFile N) (closeOu...
; # (binRead)
  %651 = call i64 @binRead()
; # (cond ((=0 E) (close N) (closeInFile N) (closeOutFile N) (set $He...
; # (=0 E)
  %652 = icmp eq i64 %651, 0
  br i1 %652, label %$102, label %$101
$102:
  %653 = phi i64 [%643, %$98] ; # Ms
  %654 = phi i64 [%644, %$98] ; # Run
  %655 = phi i64 [%645, %$98] ; # Tim
; # (close N)
  %656 = call i32 @close(i32 %629)
; # (closeInFile N)
  call void @closeInFile(i32 %629)
; # (closeOutFile N)
  call void @closeOutFile(i32 %629)
; # (set $Hear 0)
  store i32 0, i32* @$Hear
  br label %$100
$101:
  %657 = phi i64 [%643, %$98] ; # Ms
  %658 = phi i64 [%644, %$98] ; # Run
  %659 = phi i64 [%645, %$98] ; # Tim
; # (t? E)
  %660 = icmp eq i64 %651, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %660, label %$104, label %$103
$104:
  %661 = phi i64 [%657, %$101] ; # Ms
  %662 = phi i64 [%658, %$101] ; # Run
  %663 = phi i64 [%659, %$101] ; # Tim
; # (set $Sync YES)
  store i1 1, i1* @$Sync
  br label %$100
$103:
  %664 = phi i64 [%657, %$101] ; # Ms
  %665 = phi i64 [%658, %$101] ; # Run
  %666 = phi i64 [%659, %$101] ; # Tim
; # (save E (evList E))
  %667 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %668 = load i64, i64* %667
  %669 = alloca i64, i64 2, align 16
  %670 = ptrtoint i64* %669 to i64
  %671 = inttoptr i64 %670 to i64*
  store i64 %651, i64* %671
  %672 = add i64 %670, 8
  %673 = inttoptr i64 %672 to i64*
  store i64 %668, i64* %673
  %674 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %670, i64* %674
; # (evList E)
  %675 = call i64 @evList(i64 %651)
; # drop
  %676 = inttoptr i64 %670 to i64*
  %677 = getelementptr i64, i64* %676, i32 1
  %678 = load i64, i64* %677
  %679 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %678, i64* %679
  br label %$100
$100:
  %680 = phi i64 [%653, %$102], [%661, %$104], [%664, %$103] ; # Ms
  %681 = phi i64 [%654, %$102], [%662, %$104], [%665, %$103] ; # Run
  %682 = phi i64 [%655, %$102], [%663, %$104], [%666, %$103] ; # Tim
; # (set $InFile In)
  store i8* %646, i8** @$InFile
  br label %$99
$99:
  %683 = phi i64 [%639, %$95], [%680, %$100] ; # Ms
  %684 = phi i64 [%640, %$95], [%681, %$100] ; # Run
  %685 = phi i64 [%641, %$95], [%682, %$100] ; # Tim
; # (let R Run (while (pair R) (let X (++ R) (cond ((sign? (car X)) (...
; # (while (pair R) (let X (++ R) (cond ((sign? (car X)) (let Y (cdr ...
  br label %$105
$105:
  %686 = phi i64 [%683, %$99], [%823, %$108] ; # Ms
  %687 = phi i64 [%684, %$99], [%824, %$108] ; # Run
  %688 = phi i64 [%685, %$99], [%825, %$108] ; # Tim
  %689 = phi i64 [%684, %$99], [%826, %$108] ; # R
; # (pair R)
  %690 = and i64 %689, 15
  %691 = icmp eq i64 %690, 0
  br i1 %691, label %$106, label %$107
$106:
  %692 = phi i64 [%686, %$105] ; # Ms
  %693 = phi i64 [%687, %$105] ; # Run
  %694 = phi i64 [%688, %$105] ; # Tim
  %695 = phi i64 [%689, %$105] ; # R
; # (let X (++ R) (cond ((sign? (car X)) (let Y (cdr X) (if (gt0 (- (...
; # (++ R)
  %696 = inttoptr i64 %695 to i64*
  %697 = load i64, i64* %696
  %698 = getelementptr i64, i64* %696, i32 1
  %699 = load i64, i64* %698
; # (cond ((sign? (car X)) (let Y (cdr X) (if (gt0 (- (int (car Y)) D...
; # (car X)
  %700 = inttoptr i64 %697 to i64*
  %701 = load i64, i64* %700
; # (sign? (car X))
  %702 = and i64 %701, 8
  %703 = icmp ne i64 %702, 0
  br i1 %703, label %$110, label %$109
$110:
  %704 = phi i64 [%692, %$106] ; # Ms
  %705 = phi i64 [%693, %$106] ; # Run
  %706 = phi i64 [%694, %$106] ; # Tim
  %707 = phi i64 [%699, %$106] ; # R
; # (let Y (cdr X) (if (gt0 (- (int (car Y)) Dif)) (set Y (sign (cnt ...
; # (cdr X)
  %708 = inttoptr i64 %697 to i64*
  %709 = getelementptr i64, i64* %708, i32 1
  %710 = load i64, i64* %709
; # (if (gt0 (- (int (car Y)) Dif)) (set Y (sign (cnt @))) (let V (ca...
; # (car Y)
  %711 = inttoptr i64 %710 to i64*
  %712 = load i64, i64* %711
; # (int (car Y))
  %713 = lshr i64 %712, 4
; # (- (int (car Y)) Dif)
  %714 = sub i64 %713, %281
; # (gt0 (- (int (car Y)) Dif))
  %715 = icmp sgt i64 %714, 0
  br i1 %715, label %$111, label %$112
$111:
  %716 = phi i64 [%704, %$110] ; # Ms
  %717 = phi i64 [%705, %$110] ; # Run
  %718 = phi i64 [%706, %$110] ; # Tim
  %719 = phi i64 [%707, %$110] ; # R
; # (set Y (sign (cnt @)))
; # (cnt @)
  %720 = shl i64 %714, 4
  %721 = or i64 %720, 2
; # (sign (cnt @))
  %722 = or i64 %721, 8
  %723 = inttoptr i64 %710 to i64*
  store i64 %722, i64* %723
  br label %$113
$112:
  %724 = phi i64 [%704, %$110] ; # Ms
  %725 = phi i64 [%705, %$110] ; # Run
  %726 = phi i64 [%706, %$110] ; # Tim
  %727 = phi i64 [%707, %$110] ; # R
; # (let V (car X) (set Y (pos V) $At V) (run (cdr Y)))
; # (car X)
  %728 = inttoptr i64 %697 to i64*
  %729 = load i64, i64* %728
; # (set Y (pos V) $At V)
; # (pos V)
  %730 = and i64 %729, -9
  %731 = inttoptr i64 %710 to i64*
  store i64 %730, i64* %731
  %732 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %729, i64* %732
; # (cdr Y)
  %733 = inttoptr i64 %710 to i64*
  %734 = getelementptr i64, i64* %733, i32 1
  %735 = load i64, i64* %734
; # (run (cdr Y))
  br label %$114
$114:
  %736 = phi i64 [%735, %$112], [%758, %$123] ; # Prg
  %737 = inttoptr i64 %736 to i64*
  %738 = load i64, i64* %737
  %739 = getelementptr i64, i64* %737, i32 1
  %740 = load i64, i64* %739
  %741 = and i64 %740, 15
  %742 = icmp ne i64 %741, 0
  br i1 %742, label %$117, label %$115
$117:
  %743 = phi i64 [%740, %$114] ; # Prg
  %744 = and i64 %738, 6
  %745 = icmp ne i64 %744, 0
  br i1 %745, label %$120, label %$119
$120:
  br label %$118
$119:
  %746 = and i64 %738, 8
  %747 = icmp ne i64 %746, 0
  br i1 %747, label %$122, label %$121
$122:
  %748 = inttoptr i64 %738 to i64*
  %749 = load i64, i64* %748
  br label %$118
$121:
  %750 = call i64 @evList(i64 %738)
  br label %$118
$118:
  %751 = phi i64 [%738, %$120], [%749, %$122], [%750, %$121] ; # ->
  br label %$116
$115:
  %752 = phi i64 [%740, %$114] ; # Prg
  %753 = and i64 %738, 15
  %754 = icmp eq i64 %753, 0
  br i1 %754, label %$124, label %$123
$124:
  %755 = phi i64 [%752, %$115] ; # Prg
  %756 = call i64 @evList(i64 %738)
  %757 = icmp ne i64 %756, 0
  br label %$123
$123:
  %758 = phi i64 [%752, %$115], [%755, %$124] ; # Prg
  %759 = phi i1 [0, %$115], [%757, %$124] ; # ->
  br label %$114
$116:
  %760 = phi i64 [%743, %$118] ; # Prg
  %761 = phi i64 [%751, %$118] ; # ->
  br label %$113
$113:
  %762 = phi i64 [%716, %$111], [%724, %$116] ; # Ms
  %763 = phi i64 [%717, %$111], [%725, %$116] ; # Run
  %764 = phi i64 [%718, %$111], [%726, %$116] ; # Tim
  %765 = phi i64 [%719, %$111], [%727, %$116] ; # R
  %766 = phi i64 [%722, %$111], [%761, %$116] ; # ->
  br label %$108
$109:
  %767 = phi i64 [%692, %$106] ; # Ms
  %768 = phi i64 [%693, %$106] ; # Run
  %769 = phi i64 [%694, %$106] ; # Tim
  %770 = phi i64 [%699, %$106] ; # R
; # (int @)
  %771 = lshr i64 %701, 4
; # (i32 (int @))
  %772 = trunc i64 %771 to i32
; # (<> (i32 (int @)) Fd)
  %773 = icmp ne i32 %772, %1
  br i1 %773, label %$126, label %$125
$126:
  %774 = phi i64 [%767, %$109] ; # Ms
  %775 = phi i64 [%768, %$109] ; # Run
  %776 = phi i64 [%769, %$109] ; # Tim
  %777 = phi i64 [%770, %$109] ; # R
; # (when (inReady @ NO) (set $At (car X)) (run (cdr X)))
; # (inReady @ NO)
  %778 = call i1 @inReady(i32 %772, i1 0)
  br i1 %778, label %$127, label %$128
$127:
  %779 = phi i64 [%774, %$126] ; # Ms
  %780 = phi i64 [%775, %$126] ; # Run
  %781 = phi i64 [%776, %$126] ; # Tim
  %782 = phi i64 [%777, %$126] ; # R
; # (set $At (car X))
; # (car X)
  %783 = inttoptr i64 %697 to i64*
  %784 = load i64, i64* %783
  %785 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %784, i64* %785
; # (cdr X)
  %786 = inttoptr i64 %697 to i64*
  %787 = getelementptr i64, i64* %786, i32 1
  %788 = load i64, i64* %787
; # (run (cdr X))
  br label %$129
$129:
  %789 = phi i64 [%788, %$127], [%811, %$138] ; # Prg
  %790 = inttoptr i64 %789 to i64*
  %791 = load i64, i64* %790
  %792 = getelementptr i64, i64* %790, i32 1
  %793 = load i64, i64* %792
  %794 = and i64 %793, 15
  %795 = icmp ne i64 %794, 0
  br i1 %795, label %$132, label %$130
$132:
  %796 = phi i64 [%793, %$129] ; # Prg
  %797 = and i64 %791, 6
  %798 = icmp ne i64 %797, 0
  br i1 %798, label %$135, label %$134
$135:
  br label %$133
$134:
  %799 = and i64 %791, 8
  %800 = icmp ne i64 %799, 0
  br i1 %800, label %$137, label %$136
$137:
  %801 = inttoptr i64 %791 to i64*
  %802 = load i64, i64* %801
  br label %$133
$136:
  %803 = call i64 @evList(i64 %791)
  br label %$133
$133:
  %804 = phi i64 [%791, %$135], [%802, %$137], [%803, %$136] ; # ->
  br label %$131
$130:
  %805 = phi i64 [%793, %$129] ; # Prg
  %806 = and i64 %791, 15
  %807 = icmp eq i64 %806, 0
  br i1 %807, label %$139, label %$138
$139:
  %808 = phi i64 [%805, %$130] ; # Prg
  %809 = call i64 @evList(i64 %791)
  %810 = icmp ne i64 %809, 0
  br label %$138
$138:
  %811 = phi i64 [%805, %$130], [%808, %$139] ; # Prg
  %812 = phi i1 [0, %$130], [%810, %$139] ; # ->
  br label %$129
$131:
  %813 = phi i64 [%796, %$133] ; # Prg
  %814 = phi i64 [%804, %$133] ; # ->
  br label %$128
$128:
  %815 = phi i64 [%774, %$126], [%779, %$131] ; # Ms
  %816 = phi i64 [%775, %$126], [%780, %$131] ; # Run
  %817 = phi i64 [%776, %$126], [%781, %$131] ; # Tim
  %818 = phi i64 [%777, %$126], [%782, %$131] ; # R
  br label %$108
$125:
  %819 = phi i64 [%767, %$109] ; # Ms
  %820 = phi i64 [%768, %$109] ; # Run
  %821 = phi i64 [%769, %$109] ; # Tim
  %822 = phi i64 [%770, %$109] ; # R
  br label %$108
$108:
  %823 = phi i64 [%762, %$113], [%815, %$128], [%819, %$125] ; # Ms
  %824 = phi i64 [%763, %$113], [%816, %$128], [%820, %$125] ; # Run
  %825 = phi i64 [%764, %$113], [%817, %$128], [%821, %$125] ; # Tim
  %826 = phi i64 [%765, %$113], [%818, %$128], [%822, %$125] ; # R
  br label %$105
$107:
  %827 = phi i64 [%686, %$105] ; # Ms
  %828 = phi i64 [%687, %$105] ; # Run
  %829 = phi i64 [%688, %$105] ; # Tim
  %830 = phi i64 [%689, %$105] ; # R
; # (and (gt0 Ms) (lt0 (dec 'Ms Dif)) (setq Ms 0))
; # (gt0 Ms)
  %831 = icmp sgt i64 %827, 0
  br i1 %831, label %$141, label %$140
$141:
  %832 = phi i64 [%827, %$107] ; # Ms
  %833 = phi i64 [%828, %$107] ; # Run
  %834 = phi i64 [%829, %$107] ; # Tim
; # (dec 'Ms Dif)
  %835 = sub i64 %832, %281
; # (lt0 (dec 'Ms Dif))
  %836 = icmp slt i64 %835, 0
  br i1 %836, label %$142, label %$140
$142:
  %837 = phi i64 [%835, %$141] ; # Ms
  %838 = phi i64 [%833, %$141] ; # Run
  %839 = phi i64 [%834, %$141] ; # Tim
  br label %$140
$140:
  %840 = phi i64 [%827, %$107], [%835, %$141], [0, %$142] ; # Ms
  %841 = phi i64 [%828, %$107], [%833, %$141], [%838, %$142] ; # Run
  %842 = phi i64 [%829, %$107], [%834, %$141], [%839, %$142] ; # Tim
  %843 = phi i1 [0, %$107], [0, %$141], [0, %$142] ; # ->
; # (sigChk Exe)
  %844 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %845 = icmp ne i32 %844, 0
  br i1 %845, label %$143, label %$144
$143:
  call void @sighandler(i64 %0)
  br label %$144
$144:
; # (? (or (=0 Ms) (lt0 Fd) (inReady Fd YES)))
; # (or (=0 Ms) (lt0 Fd) (inReady Fd YES))
; # (=0 Ms)
  %846 = icmp eq i64 %840, 0
  br i1 %846, label %$145, label %$146
$146:
  %847 = phi i64 [%840, %$144] ; # Ms
  %848 = phi i64 [%841, %$144] ; # Run
  %849 = phi i64 [%280, %$144] ; # Tim
; # (lt0 Fd)
  %850 = icmp slt i32 %1, 0
  br i1 %850, label %$145, label %$147
$147:
  %851 = phi i64 [%847, %$146] ; # Ms
  %852 = phi i64 [%848, %$146] ; # Run
  %853 = phi i64 [%849, %$146] ; # Tim
; # (inReady Fd YES)
  %854 = call i1 @inReady(i32 %1, i1 1)
  br label %$145
$145:
  %855 = phi i64 [%840, %$144], [%847, %$146], [%851, %$147] ; # Ms
  %856 = phi i64 [%841, %$144], [%848, %$146], [%852, %$147] ; # Run
  %857 = phi i64 [%280, %$144], [%849, %$146], [%853, %$147] ; # Tim
  %858 = phi i1 [1, %$144], [1, %$146], [%854, %$147] ; # ->
  br i1 %858, label %$149, label %$148
$148:
  %859 = phi i64 [%855, %$145] ; # Ms
  %860 = phi i64 [%856, %$145] ; # Run
  %861 = phi i64 [%857, %$145] ; # Tim
; # (val $Run)
  %862 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  %863 = load i64, i64* %862
; # (safe (val $Run))
  %864 = inttoptr i64 %8 to i64*
  store i64 %863, i64* %864
  br label %$4
$149:
  %865 = phi i64 [%855, %$145] ; # Ms
  %866 = phi i64 [%856, %$145] ; # Run
  %867 = phi i64 [%857, %$145] ; # Tim
  %868 = phi i64 [0, %$145] ; # ->
; # (set $At At)
  %869 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %14, i64* %869
; # (drop *Safe)
  %870 = inttoptr i64 %8 to i64*
  %871 = getelementptr i64, i64* %870, i32 1
  %872 = load i64, i64* %871
  %873 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %872, i64* %873
  ret i64 %865
}

define i64 @_wait(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (if (nil? (eval (++ X))) 292MY (xCnt Exe @)))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) 292MY (xCnt Exe @))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  br label %$9
$8:
; # (xCnt Exe @)
  %17 = call i64 @xCnt(i64 %0, i64 %15)
  br label %$9
$9:
  %18 = phi i64 [9223372036854775807, %$7], [%17, %$8] ; # ->
; # (if (t? (car X)) (let Fd (evCnt Exe (cdr X)) (if (waitFd Exe (i32...
; # (car X)
  %19 = inttoptr i64 %7 to i64*
  %20 = load i64, i64* %19
; # (t? (car X))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %21, label %$10, label %$11
$10:
  %22 = phi i64 [%18, %$9] ; # N
; # (let Fd (evCnt Exe (cdr X)) (if (waitFd Exe (i32 Fd) N) (cnt Fd) ...
; # (cdr X)
  %23 = inttoptr i64 %7 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (evCnt Exe (cdr X))
  %26 = call i64 @evCnt(i64 %0, i64 %25)
; # (if (waitFd Exe (i32 Fd) N) (cnt Fd) $Nil)
; # (i32 Fd)
  %27 = trunc i64 %26 to i32
; # (waitFd Exe (i32 Fd) N)
  %28 = call i64 @waitFd(i64 %0, i32 %27, i64 %22)
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$13, label %$14
$13:
  %30 = phi i64 [%22, %$10] ; # N
; # (cnt Fd)
  %31 = shl i64 %26, 4
  %32 = or i64 %31, 2
  br label %$15
$14:
  %33 = phi i64 [%22, %$10] ; # N
  br label %$15
$15:
  %34 = phi i64 [%30, %$13], [%33, %$14] ; # N
  %35 = phi i64 [%32, %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$14] ; # ->
  br label %$12
$11:
  %36 = phi i64 [%18, %$9] ; # N
; # (loop (? (not (nil? (run X))) @) (? (=0 (waitFd Exe -1 N)) (run X...
  br label %$16
$16:
  %37 = phi i64 [%36, %$11], [%68, %$31] ; # N
; # (? (not (nil? (run X))) @)
; # (run X)
  br label %$17
$17:
  %38 = phi i64 [%7, %$16], [%60, %$26] ; # Prg
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  %41 = getelementptr i64, i64* %39, i32 1
  %42 = load i64, i64* %41
  %43 = and i64 %42, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$20, label %$18
$20:
  %45 = phi i64 [%42, %$17] ; # Prg
  %46 = and i64 %40, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$23, label %$22
$23:
  br label %$21
$22:
  %48 = and i64 %40, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$25, label %$24
$25:
  %50 = inttoptr i64 %40 to i64*
  %51 = load i64, i64* %50
  br label %$21
$24:
  %52 = call i64 @evList(i64 %40)
  br label %$21
$21:
  %53 = phi i64 [%40, %$23], [%51, %$25], [%52, %$24] ; # ->
  br label %$19
$18:
  %54 = phi i64 [%42, %$17] ; # Prg
  %55 = and i64 %40, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$27, label %$26
$27:
  %57 = phi i64 [%54, %$18] ; # Prg
  %58 = call i64 @evList(i64 %40)
  %59 = icmp ne i64 %58, 0
  br label %$26
$26:
  %60 = phi i64 [%54, %$18], [%57, %$27] ; # Prg
  %61 = phi i1 [0, %$18], [%59, %$27] ; # ->
  br label %$17
$19:
  %62 = phi i64 [%45, %$21] ; # Prg
  %63 = phi i64 [%53, %$21] ; # ->
; # (nil? (run X))
  %64 = icmp eq i64 %63, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (run X)))
  %65 = icmp eq i1 %64, 0
  br i1 %65, label %$30, label %$28
$30:
  %66 = phi i64 [%37, %$19] ; # N
  br label %$29
$28:
  %67 = phi i64 [%37, %$19] ; # N
; # (? (=0 (waitFd Exe -1 N)) (run X))
; # (waitFd Exe -1 N)
  %68 = call i64 @waitFd(i64 %0, i32 -1, i64 %67)
; # (=0 (waitFd Exe -1 N))
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %$32, label %$31
$32:
  %70 = phi i64 [%67, %$28] ; # N
; # (run X)
  br label %$33
$33:
  %71 = phi i64 [%7, %$32], [%93, %$42] ; # Prg
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
  %74 = getelementptr i64, i64* %72, i32 1
  %75 = load i64, i64* %74
  %76 = and i64 %75, 15
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$36, label %$34
$36:
  %78 = phi i64 [%75, %$33] ; # Prg
  %79 = and i64 %73, 6
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$39, label %$38
$39:
  br label %$37
$38:
  %81 = and i64 %73, 8
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$41, label %$40
$41:
  %83 = inttoptr i64 %73 to i64*
  %84 = load i64, i64* %83
  br label %$37
$40:
  %85 = call i64 @evList(i64 %73)
  br label %$37
$37:
  %86 = phi i64 [%73, %$39], [%84, %$41], [%85, %$40] ; # ->
  br label %$35
$34:
  %87 = phi i64 [%75, %$33] ; # Prg
  %88 = and i64 %73, 15
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %$43, label %$42
$43:
  %90 = phi i64 [%87, %$34] ; # Prg
  %91 = call i64 @evList(i64 %73)
  %92 = icmp ne i64 %91, 0
  br label %$42
$42:
  %93 = phi i64 [%87, %$34], [%90, %$43] ; # Prg
  %94 = phi i1 [0, %$34], [%92, %$43] ; # ->
  br label %$33
$35:
  %95 = phi i64 [%78, %$37] ; # Prg
  %96 = phi i64 [%86, %$37] ; # ->
  br label %$29
$31:
  %97 = phi i64 [%67, %$28] ; # N
  br label %$16
$29:
  %98 = phi i64 [%66, %$30], [%70, %$35] ; # N
  %99 = phi i64 [%63, %$30], [%96, %$35] ; # ->
  br label %$12
$12:
  %100 = phi i64 [%34, %$15], [%98, %$29] ; # N
  %101 = phi i64 [%35, %$15], [%99, %$29] ; # ->
  ret i64 %101
}

define i64 @_sync(i64) align 8 {
$1:
; # (cond ((or (=0 (val $Mic)) (=0 (val $Hear))) $Nil) ((val $Sync) $...
; # (or (=0 (val $Mic)) (=0 (val $Hear)))
; # (val $Mic)
  %1 = load i32, i32* @$Mic
; # (=0 (val $Mic))
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %$3, label %$4
$4:
; # (val $Hear)
  %3 = load i32, i32* @$Hear
; # (=0 (val $Hear))
  %4 = icmp eq i32 %3, 0
  br label %$3
$3:
  %5 = phi i1 [1, %$1], [%4, %$4] ; # ->
  br i1 %5, label %$6, label %$5
$6:
  br label %$2
$5:
; # (val $Sync)
  %6 = load i1, i1* @$Sync
  br i1 %6, label %$8, label %$7
$8:
  br label %$2
$7:
; # (let (Mic (val $Mic) P (i8* $Slot) Cnt 4) (loop (let N (write Mic...
; # (val $Mic)
  %7 = load i32, i32* @$Mic
; # (i8* $Slot)
  %8 = bitcast i32* @$Slot to i8*
; # (loop (let N (write Mic P Cnt) (cond ((ge0 N) (? (=0 (dec 'Cnt N)...
  br label %$9
$9:
  %9 = phi i8* [%8, %$7], [%30, %$10] ; # P
  %10 = phi i64 [4, %$7], [%31, %$10] ; # Cnt
; # (let N (write Mic P Cnt) (cond ((ge0 N) (? (=0 (dec 'Cnt N))) (se...
; # (write Mic P Cnt)
  %11 = call i64 @write(i32 %7, i8* %9, i64 %10)
; # (cond ((ge0 N) (? (=0 (dec 'Cnt N))) (setq P (ofs P N))) ((== (gE...
; # (ge0 N)
  %12 = icmp sge i64 %11, 0
  br i1 %12, label %$12, label %$11
$12:
  %13 = phi i8* [%9, %$9] ; # P
  %14 = phi i64 [%10, %$9] ; # Cnt
; # (? (=0 (dec 'Cnt N)))
; # (dec 'Cnt N)
  %15 = sub i64 %14, %11
; # (=0 (dec 'Cnt N))
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$14, label %$13
$13:
  %17 = phi i8* [%13, %$12] ; # P
  %18 = phi i64 [%15, %$12] ; # Cnt
; # (ofs P N)
  %19 = getelementptr i8, i8* %17, i64 %11
  br label %$10
$11:
  %20 = phi i8* [%9, %$9] ; # P
  %21 = phi i64 [%10, %$9] ; # Cnt
; # (gErrno)
  %22 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %23 = icmp eq i32 %22, 2
  br i1 %23, label %$16, label %$15
$16:
  %24 = phi i8* [%20, %$11] ; # P
  %25 = phi i64 [%21, %$11] ; # Cnt
; # (sigChk Exe)
  %26 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$17, label %$18
$17:
  call void @sighandler(i64 %0)
  br label %$18
$18:
  br label %$10
$15:
  %28 = phi i8* [%20, %$11] ; # P
  %29 = phi i64 [%21, %$11] ; # Cnt
; # (writeErr ($ "sync write: %s"))
  call void @writeErr(i8* bitcast ([15 x i8]* @$41 to i8*))
  unreachable
$10:
  %30 = phi i8* [%19, %$13], [%24, %$18] ; # P
  %31 = phi i64 [%18, %$13], [%25, %$18] ; # Cnt
  br label %$9
$14:
  %32 = phi i8* [%13, %$12] ; # P
  %33 = phi i64 [%15, %$12] ; # Cnt
  %34 = phi i64 [0, %$12] ; # ->
; # (set $Sync NO)
  store i1 0, i1* @$Sync
; # (loop (waitFd Exe -1 292MY) (? (val $Sync)))
  br label %$19
$19:
; # (waitFd Exe -1 292MY)
  %35 = call i64 @waitFd(i64 %0, i32 -1, i64 9223372036854775807)
; # (? (val $Sync))
; # (val $Sync)
  %36 = load i1, i1* @$Sync
  br i1 %36, label %$21, label %$20
$20:
  br label %$19
$21:
  %37 = phi i64 [0, %$19] ; # ->
  br label %$2
$2:
  %38 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$6], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$21] ; # ->
  ret i64 %38
}

define i64 @_hear(i64) align 8 {
$1:
; # (let (X (eval (cadr Exe)) Fd (i32 (xCnt Exe X))) (when (or (lt0 F...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (xCnt Exe X)
  %14 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe X))
  %15 = trunc i64 %14 to i32
; # (when (or (lt0 Fd) (>= Fd (val $InFDs)) (=0 (val (ofs (val $InFil...
; # (or (lt0 Fd) (>= Fd (val $InFDs)) (=0 (val (ofs (val $InFiles) Fd...
; # (lt0 Fd)
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %$7, label %$8
$8:
; # (val $InFDs)
  %17 = load i32, i32* @$InFDs
; # (>= Fd (val $InFDs))
  %18 = icmp sge i32 %15, %17
  br i1 %18, label %$7, label %$9
$9:
; # (val $InFiles)
  %19 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %20 = getelementptr i8*, i8** %19, i32 %15
; # (val (ofs (val $InFiles) Fd))
  %21 = load i8*, i8** %20
; # (=0 (val (ofs (val $InFiles) Fd)))
  %22 = icmp eq i8* %21, null
  br i1 %22, label %$7, label %$10
$10:
; # ((inFile @) fd)
  %23 = getelementptr i8, i8* %21, i32 8
  %24 = bitcast i8* %23 to i32*
  %25 = load i32, i32* %24
; # (lt0 ((inFile @) fd))
  %26 = icmp slt i32 %25, 0
  br label %$7
$7:
  %27 = phi i1 [1, %$2], [1, %$8], [1, %$9], [%26, %$10] ; # ->
  br i1 %27, label %$11, label %$12
$11:
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %13)
  unreachable
$12:
; # (when (val $Hear) (close @) (closeInFile @) (closeOutFile @))
; # (val $Hear)
  %28 = load i32, i32* @$Hear
  %29 = icmp ne i32 %28, 0
  br i1 %29, label %$13, label %$14
$13:
; # (close @)
  %30 = call i32 @close(i32 %28)
; # (closeInFile @)
  call void @closeInFile(i32 %28)
; # (closeOutFile @)
  call void @closeOutFile(i32 %28)
  br label %$14
$14:
; # (set $Hear Fd)
  store i32 %15, i32* @$Hear
  ret i64 %13
}

define i64 @_tell(i64) align 8 {
$1:
; # (cond ((and (=0 (val $Tell)) (=0 (val $Children))) $Nil) ((atom (...
; # (and (=0 (val $Tell)) (=0 (val $Children)))
; # (val $Tell)
  %1 = load i32, i32* @$Tell
; # (=0 (val $Tell))
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %$4, label %$3
$4:
; # (val $Children)
  %3 = load i32, i32* @$Children
; # (=0 (val $Children))
  %4 = icmp eq i32 %3, 0
  br label %$3
$3:
  %5 = phi i1 [0, %$1], [%4, %$4] ; # ->
  br i1 %5, label %$6, label %$5
$6:
  br label %$2
$5:
; # (cdr Exe)
  %6 = inttoptr i64 %0 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
; # (atom (cdr Exe))
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$8, label %$7
$8:
; # (unsync)
  call void @unsync()
  br label %$2
$7:
; # (let (X @ Y (eval (car X)) Pid (i32 0)) (when (cnt? Y) (setq Pid ...
; # (car X)
  %11 = inttoptr i64 %8 to i64*
  %12 = load i64, i64* %11
; # (eval (car X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$11, label %$10
$11:
  br label %$9
$10:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$13, label %$12
$13:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$9
$12:
  %19 = call i64 @evList(i64 %12)
  br label %$9
$9:
  %20 = phi i64 [%12, %$11], [%18, %$13], [%19, %$12] ; # ->
; # (i32 0)
; # (when (cnt? Y) (setq Pid (i32 (int @)) Y (eval (car (shift X)))))...
; # (cnt? Y)
  %21 = and i64 %20, 2
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$14, label %$15
$14:
  %23 = phi i64 [%8, %$9] ; # X
  %24 = phi i64 [%20, %$9] ; # Y
  %25 = phi i32 [0, %$9] ; # Pid
; # (int @)
  %26 = lshr i64 %20, 4
; # (i32 (int @))
  %27 = trunc i64 %26 to i32
; # (shift X)
  %28 = inttoptr i64 %23 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (car (shift X))
  %31 = inttoptr i64 %30 to i64*
  %32 = load i64, i64* %31
; # (eval (car (shift X)))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$18, label %$17
$18:
  br label %$16
$17:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$20, label %$19
$20:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$16
$19:
  %39 = call i64 @evList(i64 %32)
  br label %$16
$16:
  %40 = phi i64 [%32, %$18], [%38, %$20], [%39, %$19] ; # ->
  br label %$15
$15:
  %41 = phi i64 [%8, %$9], [%30, %$16] ; # X
  %42 = phi i64 [%20, %$9], [%40, %$16] ; # Y
  %43 = phi i32 [0, %$9], [%27, %$16] ; # Pid
; # (let (TellBuf (val $TellBuf) Ptr (val $Ptr) End (val $End)) (tell...
; # (val $TellBuf)
  %44 = load i8*, i8** @$TellBuf
; # (val $Ptr)
  %45 = load i8*, i8** @$Ptr
; # (val $End)
  %46 = load i8*, i8** @$End
; # (val PipeBufSize)
  %47 = load i32, i32* @PipeBufSize
; # (b8 (val PipeBufSize))
  %48 = alloca i8, i32 %47
; # (tellBeg (b8 (val PipeBufSize)))
  call void @tellBeg(i8* %48)
; # (stkChk Exe)
  %49 = load i8*, i8** @$StkLimit
  %50 = call i8* @llvm.stacksave()
  %51 = icmp ugt i8* %49, %50
  br i1 %51, label %$21, label %$22
$21:
  call void @stkErr(i64 %0)
  unreachable
$22:
; # (loop (prTell Y) (? (atom (shift X))) (setq Y (eval (car X))))
  br label %$23
$23:
  %52 = phi i64 [%41, %$22], [%60, %$26] ; # X
  %53 = phi i64 [%42, %$22], [%72, %$26] ; # Y
  %54 = phi i32 [%43, %$22], [%62, %$26] ; # Pid
; # (prTell Y)
  call void @prTell(i64 %53)
; # (? (atom (shift X)))
; # (shift X)
  %55 = inttoptr i64 %52 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
; # (atom (shift X))
  %58 = and i64 %57, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$25, label %$24
$24:
  %60 = phi i64 [%57, %$23] ; # X
  %61 = phi i64 [%53, %$23] ; # Y
  %62 = phi i32 [%54, %$23] ; # Pid
; # (car X)
  %63 = inttoptr i64 %60 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$28, label %$27
$28:
  br label %$26
$27:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$30, label %$29
$30:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$26
$29:
  %71 = call i64 @evList(i64 %64)
  br label %$26
$26:
  %72 = phi i64 [%64, %$28], [%70, %$30], [%71, %$29] ; # ->
  br label %$23
$25:
  %73 = phi i64 [%57, %$23] ; # X
  %74 = phi i64 [%53, %$23] ; # Y
  %75 = phi i32 [%54, %$23] ; # Pid
  %76 = phi i64 [0, %$23] ; # ->
; # (tellEnd Pid)
  call void @tellEnd(i32 %75)
; # (set $TellBuf TellBuf $Ptr Ptr $End End)
  store i8* %44, i8** @$TellBuf
  store i8* %45, i8** @$Ptr
  store i8* %46, i8** @$End
  br label %$2
$2:
  %77 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$6], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8], [%74, %$25] ; # ->
  ret i64 %77
}

define i64 @_poll(i64) align 8 {
$1:
; # (let (C (eval (cadr Exe)) Fd (i32 (xCnt Exe C))) (when (or (lt0 F...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (xCnt Exe C)
  %14 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe C))
  %15 = trunc i64 %14 to i32
; # (when (or (lt0 Fd) (>= Fd (val $InFDs))) (badFd Exe C))
; # (or (lt0 Fd) (>= Fd (val $InFDs)))
; # (lt0 Fd)
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %$7, label %$8
$8:
; # (val $InFDs)
  %17 = load i32, i32* @$InFDs
; # (>= Fd (val $InFDs))
  %18 = icmp sge i32 %15, %17
  br label %$7
$7:
  %19 = phi i1 [1, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
; # (badFd Exe C)
  call void @badFd(i64 %0, i64 %13)
  unreachable
$10:
; # (let In: (inFile (val (ofs (val $InFiles) Fd))) (ifn (and (In:) (...
; # (val $InFiles)
  %20 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %21 = getelementptr i8*, i8** %20, i32 %15
; # (val (ofs (val $InFiles) Fd))
  %22 = load i8*, i8** %21
; # (ifn (and (In:) (ge0 (In: fd))) $Nil (let Poll (b64 1) (pollIn Fd...
; # (and (In:) (ge0 (In: fd)))
; # (In:)
  %23 = icmp ne i8* %22, null
  br i1 %23, label %$12, label %$11
$12:
; # (In: fd)
  %24 = getelementptr i8, i8* %22, i32 8
  %25 = bitcast i8* %24 to i32*
  %26 = load i32, i32* %25
; # (ge0 (In: fd))
  %27 = icmp sge i32 %26, 0
  br label %$11
$11:
  %28 = phi i1 [0, %$10], [%27, %$12] ; # ->
  br i1 %28, label %$14, label %$13
$13:
  br label %$15
$14:
; # (let Poll (b64 1) (pollIn Fd Poll) (loop (? (> (In: cnt) (In: ix)...
; # (b64 1)
  %29 = alloca i64, i64 1
; # (pollIn Fd Poll)
  call void @pollIn(i32 %15, i64* %29)
; # (loop (? (> (In: cnt) (In: ix)) C) (while (lt0 (gPoll Poll 1 0)) ...
  br label %$16
$16:
; # (? (> (In: cnt) (In: ix)) C)
; # (In: cnt)
  %30 = getelementptr i8, i8* %22, i32 28
  %31 = bitcast i8* %30 to i32*
  %32 = load i32, i32* %31
; # (In: ix)
  %33 = getelementptr i8, i8* %22, i32 24
  %34 = bitcast i8* %33 to i32*
  %35 = load i32, i32* %34
; # (> (In: cnt) (In: ix))
  %36 = icmp sgt i32 %32, %35
  br i1 %36, label %$19, label %$17
$19:
  br label %$18
$17:
; # (while (lt0 (gPoll Poll 1 0)) (unless (== (gErrno) EINTR) (select...
  br label %$20
$20:
; # (gPoll Poll 1 0)
  %37 = call i32 @gPoll(i64* %29, i32 1, i64 0)
; # (lt0 (gPoll Poll 1 0))
  %38 = icmp slt i32 %37, 0
  br i1 %38, label %$21, label %$22
$21:
; # (unless (== (gErrno) EINTR) (selectErr Exe))
; # (gErrno)
  %39 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %40 = icmp eq i32 %39, 2
  br i1 %40, label %$24, label %$23
$23:
; # (selectErr Exe)
  call void @selectErr(i64 %0)
  unreachable
$24:
  br label %$20
$22:
; # (? (not (readyIn Poll)) $Nil)
; # (readyIn Poll)
  %41 = call i1 @readyIn(i64* %29)
; # (not (readyIn Poll))
  %42 = icmp eq i1 %41, 0
  br i1 %42, label %$26, label %$25
$26:
  br label %$18
$25:
; # (? (ge0 (slowNb (In:))) C)
; # (In:)
; # (slowNb (In:))
  %43 = call i32 @slowNb(i8* %22)
; # (ge0 (slowNb (In:)))
  %44 = icmp sge i32 %43, 0
  br i1 %44, label %$28, label %$27
$28:
  br label %$18
$27:
  br label %$16
$18:
  %45 = phi i64 [%13, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$26], [%13, %$28] ; # ->
  br label %$15
$15:
  %46 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%45, %$18] ; # ->
  ret i64 %46
}

define void @rdOpen(i64, i64, i8*) align 8 {
$1:
; # (cond ((nil? X) (pushInFile Io (val (val $InFiles)) 0)) ((num? X)...
; # (nil? X)
  %3 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%1, %$1] ; # X
; # (val $InFiles)
  %5 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %6 = load i8*, i8** %5
; # (pushInFile Io (val (val $InFiles)) 0)
  call void @pushInFile(i8* %2, i8* %6, i32 0)
  br label %$2
$3:
  %7 = phi i64 [%1, %$1] ; # X
; # (num? X)
  %8 = and i64 %7, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = phi i64 [%7, %$3] ; # X
; # (let N (i32 (int X)) (pushInFile Io (cond ((sign? X) (let In (val...
; # (int X)
  %11 = lshr i64 %10, 4
; # (i32 (int X))
  %12 = trunc i64 %11 to i32
; # (cond ((sign? X) (let In (val $InFrames) (loop (unless (setq In (...
; # (sign? X)
  %13 = and i64 %10, 8
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%10, %$6] ; # X
  %16 = phi i32 [%12, %$6] ; # N
; # (let In (val $InFrames) (loop (unless (setq In ((ioFrame In) link...
; # (val $InFrames)
  %17 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (loop (unless (setq In ((ioFrame In) link)) (badFd Exe X)) (? (=0...
  br label %$10
$10:
  %18 = phi i64 [%15, %$9], [%32, %$13] ; # X
  %19 = phi i32 [%16, %$9], [%33, %$13] ; # N
  %20 = phi i8* [%17, %$9], [%34, %$13] ; # In
; # (unless (setq In ((ioFrame In) link)) (badFd Exe X))
; # ((ioFrame In) link)
  %21 = bitcast i8* %20 to i8**
  %22 = load i8*, i8** %21
  %23 = icmp ne i8* %22, null
  br i1 %23, label %$12, label %$11
$11:
  %24 = phi i64 [%18, %$10] ; # X
  %25 = phi i32 [%19, %$10] ; # N
  %26 = phi i8* [%22, %$10] ; # In
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %24)
  unreachable
$12:
  %27 = phi i64 [%18, %$10] ; # X
  %28 = phi i32 [%19, %$10] ; # N
  %29 = phi i8* [%22, %$10] ; # In
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %30 = sub i32 %28, 1
; # (=0 (dec 'N))
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %$14, label %$13
$13:
  %32 = phi i64 [%27, %$12] ; # X
  %33 = phi i32 [%30, %$12] ; # N
  %34 = phi i8* [%29, %$12] ; # In
  br label %$10
$14:
  %35 = phi i64 [%27, %$12] ; # X
  %36 = phi i32 [%30, %$12] ; # N
  %37 = phi i8* [%29, %$12] ; # In
  %38 = phi i64 [0, %$12] ; # ->
; # ((ioFrame In) file)
  %39 = getelementptr i8, i8* %37, i32 8
  %40 = bitcast i8* %39 to i8**
  %41 = load i8*, i8** %40
  br label %$7
$8:
  %42 = phi i64 [%10, %$6] ; # X
  %43 = phi i32 [%12, %$6] ; # N
; # (val $InFDs)
  %44 = load i32, i32* @$InFDs
; # (>= N (val $InFDs))
  %45 = icmp sge i32 %43, %44
  br i1 %45, label %$16, label %$15
$16:
  %46 = phi i64 [%42, %$8] ; # X
  %47 = phi i32 [%43, %$8] ; # N
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %46)
  unreachable
$15:
  %48 = phi i64 [%42, %$8] ; # X
  %49 = phi i32 [%43, %$8] ; # N
; # (val $InFiles)
  %50 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) N)
  %51 = getelementptr i8*, i8** %50, i32 %49
; # (val (ofs (val $InFiles) N))
  %52 = load i8*, i8** %51
; # (=0 (val (ofs (val $InFiles) N)))
  %53 = icmp eq i8* %52, null
  br i1 %53, label %$18, label %$17
$18:
  %54 = phi i64 [%48, %$15] ; # X
  %55 = phi i32 [%49, %$15] ; # N
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %54)
  unreachable
$17:
  %56 = phi i64 [%48, %$15] ; # X
  %57 = phi i32 [%49, %$15] ; # N
  br label %$7
$7:
  %58 = phi i64 [%35, %$14], [%56, %$17] ; # X
  %59 = phi i32 [%36, %$14], [%57, %$17] ; # N
  %60 = phi i8* [%41, %$14], [%52, %$17] ; # ->
; # (pushInFile Io (cond ((sign? X) (let In (val $InFrames) (loop (un...
  call void @pushInFile(i8* %2, i8* %60, i32 0)
  br label %$2
$5:
  %61 = phi i64 [%7, %$3] ; # X
; # (sym? X)
  %62 = and i64 %61, 8
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$20, label %$19
$20:
  %64 = phi i64 [%61, %$5] ; # X
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %65 = call i64 @xName(i64 %0, i64 %64)
; # (pathSize Nm)
  %66 = call i64 @pathSize(i64 %65)
; # (b8 (pathSize Nm))
  %67 = alloca i8, i64 %66
; # (pathString Nm (b8 (pathSize Nm)))
  %68 = call i8* @pathString(i64 %65, i8* %67)
; # (val S)
  %69 = load i8, i8* %68
; # (== (val S) (char "+"))
  %70 = icmp eq i8 %69, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %70, label %$21, label %$22
$21:
  %71 = phi i64 [%64, %$20] ; # X
  %72 = phi i8* [%68, %$20] ; # S
; # (ofs S 1)
  %73 = getelementptr i8, i8* %72, i32 1
  br label %$22
$22:
  %74 = phi i64 [%64, %$20], [%71, %$21] ; # X
  %75 = phi i8* [%68, %$20], [%73, %$21] ; # S
; # (while (lt0 (setq Fd (if Flg (openRdWrAppend S) (openRd S)))) (un...
  br label %$23
$23:
  %76 = phi i64 [%74, %$22], [%96, %$32] ; # X
  %77 = phi i8* [%75, %$22], [%97, %$32] ; # S
; # (if Flg (openRdWrAppend S) (openRd S))
  br i1 %70, label %$24, label %$25
$24:
  %78 = phi i64 [%76, %$23] ; # X
  %79 = phi i8* [%77, %$23] ; # S
; # (openRdWrAppend S)
  %80 = call i32 @openRdWrAppend(i8* %79)
  br label %$26
$25:
  %81 = phi i64 [%76, %$23] ; # X
  %82 = phi i8* [%77, %$23] ; # S
; # (openRd S)
  %83 = call i32 @openRd(i8* %82)
  br label %$26
$26:
  %84 = phi i64 [%78, %$24], [%81, %$25] ; # X
  %85 = phi i8* [%79, %$24], [%82, %$25] ; # S
  %86 = phi i32 [%80, %$24], [%83, %$25] ; # ->
; # (lt0 (setq Fd (if Flg (openRdWrAppend S) (openRd S))))
  %87 = icmp slt i32 %86, 0
  br i1 %87, label %$27, label %$28
$27:
  %88 = phi i64 [%84, %$26] ; # X
  %89 = phi i8* [%85, %$26] ; # S
  %90 = phi i32 [%86, %$26] ; # Fd
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %91 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %92 = icmp eq i32 %91, 2
  br i1 %92, label %$30, label %$29
$29:
  %93 = phi i64 [%88, %$27] ; # X
  %94 = phi i8* [%89, %$27] ; # S
  %95 = phi i32 [%90, %$27] ; # Fd
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %93)
  unreachable
$30:
  %96 = phi i64 [%88, %$27] ; # X
  %97 = phi i8* [%89, %$27] ; # S
  %98 = phi i32 [%90, %$27] ; # Fd
; # (sigChk Exe)
  %99 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %100 = icmp ne i32 %99, 0
  br i1 %100, label %$31, label %$32
$31:
  call void @sighandler(i64 %0)
  br label %$32
$32:
  br label %$23
$28:
  %101 = phi i64 [%84, %$26] ; # X
  %102 = phi i8* [%85, %$26] ; # S
  %103 = phi i32 [%86, %$26] ; # Fd
; # (closeOnExec Exe Fd)
  call void @closeOnExec(i64 %0, i32 %103)
; # (strdup S)
  %104 = call i8* @strdup(i8* %102)
; # (initInFile Fd (strdup S))
  %105 = call i8* @initInFile(i32 %103, i8* %104)
; # (pushInFile Io (initInFile Fd (strdup S)) 1)
  call void @pushInFile(i8* %2, i8* %105, i32 1)
  br label %$2
$19:
  %106 = phi i64 [%61, %$5] ; # X
; # (let (Pfd (b32 2) Av (b8* (inc (length X))) Cmd (xName Exe (xSym ...
; # (b32 2)
  %107 = alloca i32, i64 2
; # (length X)
  br label %$33
$33:
  %108 = phi i64 [%106, %$19], [%117, %$34] ; # X
  %109 = phi i64 [0, %$19], [%114, %$34] ; # N
  %110 = and i64 %108, 15
  %111 = icmp eq i64 %110, 0
  br i1 %111, label %$34, label %$35
$34:
  %112 = phi i64 [%108, %$33] ; # X
  %113 = phi i64 [%109, %$33] ; # N
  %114 = add i64 %113, 1
  %115 = inttoptr i64 %112 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  %117 = load i64, i64* %116
  br label %$33
$35:
  %118 = phi i64 [%108, %$33] ; # X
  %119 = phi i64 [%109, %$33] ; # N
; # (inc (length X))
  %120 = add i64 %119, 1
; # (b8* (inc (length X)))
  %121 = alloca i8*, i64 %120
; # (car X)
  %122 = inttoptr i64 %106 to i64*
  %123 = load i64, i64* %122
; # (xSym (car X))
  %124 = call i64 @xSym(i64 %123)
; # (xName Exe (xSym (car X)))
  %125 = call i64 @xName(i64 %0, i64 %124)
; # (when (lt0 (pipe Pfd)) (pipeErr Exe))
; # (pipe Pfd)
  %126 = call i32 @pipe(i32* %107)
; # (lt0 (pipe Pfd))
  %127 = icmp slt i32 %126, 0
  br i1 %127, label %$36, label %$37
$36:
  %128 = phi i64 [%106, %$35] ; # X
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$37:
  %129 = phi i64 [%106, %$35] ; # X
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %130 = call i64 @pathSize(i64 %125)
; # (b8 (pathSize Cmd))
  %131 = alloca i8, i64 %130
; # (pathString Cmd (b8 (pathSize Cmd)))
  %132 = call i8* @pathString(i64 %125, i8* %131)
  store i8* %132, i8** %121
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (xSym (car X...
; # (while (pair (shift X)) (let Nm (xName Exe (xSym (car X))) (set (...
  br label %$38
$38:
  %133 = phi i64 [%129, %$37], [%140, %$39] ; # X
  %134 = phi i8** [%121, %$37], [%146, %$39] ; # A
; # (shift X)
  %135 = inttoptr i64 %133 to i64*
  %136 = getelementptr i64, i64* %135, i32 1
  %137 = load i64, i64* %136
; # (pair (shift X))
  %138 = and i64 %137, 15
  %139 = icmp eq i64 %138, 0
  br i1 %139, label %$39, label %$40
$39:
  %140 = phi i64 [%137, %$38] ; # X
  %141 = phi i8** [%134, %$38] ; # A
; # (let Nm (xName Exe (xSym (car X))) (set (inc 'A) (bufString Nm (b...
; # (car X)
  %142 = inttoptr i64 %140 to i64*
  %143 = load i64, i64* %142
; # (xSym (car X))
  %144 = call i64 @xSym(i64 %143)
; # (xName Exe (xSym (car X)))
  %145 = call i64 @xName(i64 %0, i64 %144)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %146 = getelementptr i8*, i8** %141, i32 1
; # (bufSize Nm)
  %147 = call i64 @bufSize(i64 %145)
; # (b8 (bufSize Nm))
  %148 = alloca i8, i64 %147
; # (bufString Nm (b8 (bufSize Nm)))
  %149 = call i8* @bufString(i64 %145, i8* %148)
  store i8* %149, i8** %146
  br label %$38
$40:
  %150 = phi i64 [%137, %$38] ; # X
  %151 = phi i8** [%134, %$38] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %152 = getelementptr i8*, i8** %151, i32 1
  store i8* null, i8** %152
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (setpgid 0 0) (close (...
; # (fork)
  %153 = call i32 @fork()
; # (lt0 (fork))
  %154 = icmp slt i32 %153, 0
  br i1 %154, label %$43, label %$42
$43:
  %155 = phi i64 [%150, %$40] ; # X
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$42:
  %156 = phi i64 [%150, %$40] ; # X
; # (=0 @)
  %157 = icmp eq i32 %153, 0
  br i1 %157, label %$45, label %$44
$45:
  %158 = phi i64 [%156, %$42] ; # X
; # (setpgid 0 0)
  %159 = call i32 @setpgid(i32 0, i32 0)
; # (val Pfd)
  %160 = load i32, i32* %107
; # (close (val Pfd))
  %161 = call i32 @close(i32 %160)
; # (unless (== (val 2 Pfd) 1) (dup2 @ 1) (close @))
; # (val 2 Pfd)
  %162 = getelementptr i32, i32* %107, i32 1
  %163 = load i32, i32* %162
; # (== (val 2 Pfd) 1)
  %164 = icmp eq i32 %163, 1
  br i1 %164, label %$47, label %$46
$46:
  %165 = phi i64 [%158, %$45] ; # X
; # (dup2 @ 1)
  %166 = call i32 @dup2(i32 %163, i32 1)
; # (close @)
  %167 = call i32 @close(i32 %163)
  br label %$47
$47:
  %168 = phi i64 [%158, %$45], [%165, %$46] ; # X
; # (val SIGPIPE Sig)
  %169 = getelementptr i32, i32* @Sig, i32 4
  %170 = load i32, i32* %169
; # (val SigDfl)
  %171 = load i8*, i8** @SigDfl
; # (signal (val SIGPIPE Sig) (val SigDfl))
  %172 = call i8* @signal(i32 %170, i8* %171)
; # (val Av)
  %173 = load i8*, i8** %121
; # (execvp (val Av) Av)
  %174 = call i32 @execvp(i8* %173, i8** %121)
; # (val Av)
  %175 = load i8*, i8** %121
; # (execErr (val Av))
  call void @execErr(i8* %175)
  unreachable
$44:
  %176 = phi i64 [%156, %$42] ; # X
  br label %$41
$41:
  %177 = phi i64 [%176, %$44] ; # X
  %178 = phi i64 [0, %$44] ; # ->
; # (let (Pid @ Fd (val Pfd)) (setpgid Pid 0) (close (val 2 Pfd)) (cl...
; # (val Pfd)
  %179 = load i32, i32* %107
; # (setpgid Pid 0)
  %180 = call i32 @setpgid(i32 %153, i32 0)
; # (val 2 Pfd)
  %181 = getelementptr i32, i32* %107, i32 1
  %182 = load i32, i32* %181
; # (close (val 2 Pfd))
  %183 = call i32 @close(i32 %182)
; # (closeOnExec Exe Fd)
  call void @closeOnExec(i64 %0, i32 %179)
; # (initInFile Fd null)
  %184 = call i8* @initInFile(i32 %179, i8* null)
; # (pushInFile Io (initInFile Fd null) Pid)
  call void @pushInFile(i8* %2, i8* %184, i32 %153)
  br label %$2
$2:
  %185 = phi i64 [%4, %$4], [%58, %$7], [%101, %$28], [%177, %$41] ; # X
  ret void
}

define void @wrOpen(i64, i64, i8*) align 8 {
$1:
; # (cond ((nil? X) (pushOutFile Io (val 2 (val $OutFiles)) 0)) ((num...
; # (nil? X)
  %3 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%1, %$1] ; # X
; # (val $OutFiles)
  %5 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %6 = getelementptr i8*, i8** %5, i32 1
  %7 = load i8*, i8** %6
; # (pushOutFile Io (val 2 (val $OutFiles)) 0)
  call void @pushOutFile(i8* %2, i8* %7, i32 0)
  br label %$2
$3:
  %8 = phi i64 [%1, %$1] ; # X
; # (num? X)
  %9 = and i64 %8, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$6, label %$5
$6:
  %11 = phi i64 [%8, %$3] ; # X
; # (let N (i32 (int X)) (pushOutFile Io (cond ((sign? X) (let Out (v...
; # (int X)
  %12 = lshr i64 %11, 4
; # (i32 (int X))
  %13 = trunc i64 %12 to i32
; # (cond ((sign? X) (let Out (val $OutFrames) (loop (unless (setq Ou...
; # (sign? X)
  %14 = and i64 %11, 8
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%11, %$6] ; # X
  %17 = phi i32 [%13, %$6] ; # N
; # (let Out (val $OutFrames) (loop (unless (setq Out ((ioFrame Out) ...
; # (val $OutFrames)
  %18 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (loop (unless (setq Out ((ioFrame Out) link)) (badFd Exe X)) (? (...
  br label %$10
$10:
  %19 = phi i64 [%16, %$9], [%33, %$13] ; # X
  %20 = phi i32 [%17, %$9], [%34, %$13] ; # N
  %21 = phi i8* [%18, %$9], [%35, %$13] ; # Out
; # (unless (setq Out ((ioFrame Out) link)) (badFd Exe X))
; # ((ioFrame Out) link)
  %22 = bitcast i8* %21 to i8**
  %23 = load i8*, i8** %22
  %24 = icmp ne i8* %23, null
  br i1 %24, label %$12, label %$11
$11:
  %25 = phi i64 [%19, %$10] ; # X
  %26 = phi i32 [%20, %$10] ; # N
  %27 = phi i8* [%23, %$10] ; # Out
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %25)
  unreachable
$12:
  %28 = phi i64 [%19, %$10] ; # X
  %29 = phi i32 [%20, %$10] ; # N
  %30 = phi i8* [%23, %$10] ; # Out
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %31 = sub i32 %29, 1
; # (=0 (dec 'N))
  %32 = icmp eq i32 %31, 0
  br i1 %32, label %$14, label %$13
$13:
  %33 = phi i64 [%28, %$12] ; # X
  %34 = phi i32 [%31, %$12] ; # N
  %35 = phi i8* [%30, %$12] ; # Out
  br label %$10
$14:
  %36 = phi i64 [%28, %$12] ; # X
  %37 = phi i32 [%31, %$12] ; # N
  %38 = phi i8* [%30, %$12] ; # Out
  %39 = phi i64 [0, %$12] ; # ->
; # ((ioFrame Out) file)
  %40 = getelementptr i8, i8* %38, i32 8
  %41 = bitcast i8* %40 to i8**
  %42 = load i8*, i8** %41
  br label %$7
$8:
  %43 = phi i64 [%11, %$6] ; # X
  %44 = phi i32 [%13, %$6] ; # N
; # (val $OutFDs)
  %45 = load i32, i32* @$OutFDs
; # (>= N (val $OutFDs))
  %46 = icmp sge i32 %44, %45
  br i1 %46, label %$16, label %$15
$16:
  %47 = phi i64 [%43, %$8] ; # X
  %48 = phi i32 [%44, %$8] ; # N
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %47)
  unreachable
$15:
  %49 = phi i64 [%43, %$8] ; # X
  %50 = phi i32 [%44, %$8] ; # N
; # (val $OutFiles)
  %51 = load i8**, i8*** @$OutFiles
; # (ofs (val $OutFiles) N)
  %52 = getelementptr i8*, i8** %51, i32 %50
; # (val (ofs (val $OutFiles) N))
  %53 = load i8*, i8** %52
; # (=0 (val (ofs (val $OutFiles) N)))
  %54 = icmp eq i8* %53, null
  br i1 %54, label %$18, label %$17
$18:
  %55 = phi i64 [%49, %$15] ; # X
  %56 = phi i32 [%50, %$15] ; # N
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %55)
  unreachable
$17:
  %57 = phi i64 [%49, %$15] ; # X
  %58 = phi i32 [%50, %$15] ; # N
  br label %$7
$7:
  %59 = phi i64 [%36, %$14], [%57, %$17] ; # X
  %60 = phi i32 [%37, %$14], [%58, %$17] ; # N
  %61 = phi i8* [%42, %$14], [%53, %$17] ; # ->
; # (pushOutFile Io (cond ((sign? X) (let Out (val $OutFrames) (loop ...
  call void @pushOutFile(i8* %2, i8* %61, i32 0)
  br label %$2
$5:
  %62 = phi i64 [%8, %$3] ; # X
; # (sym? X)
  %63 = and i64 %62, 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$20, label %$19
$20:
  %65 = phi i64 [%62, %$5] ; # X
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %66 = call i64 @xName(i64 %0, i64 %65)
; # (pathSize Nm)
  %67 = call i64 @pathSize(i64 %66)
; # (b8 (pathSize Nm))
  %68 = alloca i8, i64 %67
; # (pathString Nm (b8 (pathSize Nm)))
  %69 = call i8* @pathString(i64 %66, i8* %68)
; # (val S)
  %70 = load i8, i8* %69
; # (== (val S) (char "+"))
  %71 = icmp eq i8 %70, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %71, label %$21, label %$22
$21:
  %72 = phi i64 [%65, %$20] ; # X
  %73 = phi i8* [%69, %$20] ; # S
; # (ofs S 1)
  %74 = getelementptr i8, i8* %73, i32 1
  br label %$22
$22:
  %75 = phi i64 [%65, %$20], [%72, %$21] ; # X
  %76 = phi i8* [%69, %$20], [%74, %$21] ; # S
; # (while (lt0 (setq Fd (if Flg (openWrAppend S) (openWr S)))) (unle...
  br label %$23
$23:
  %77 = phi i64 [%75, %$22], [%97, %$32] ; # X
  %78 = phi i8* [%76, %$22], [%98, %$32] ; # S
; # (if Flg (openWrAppend S) (openWr S))
  br i1 %71, label %$24, label %$25
$24:
  %79 = phi i64 [%77, %$23] ; # X
  %80 = phi i8* [%78, %$23] ; # S
; # (openWrAppend S)
  %81 = call i32 @openWrAppend(i8* %80)
  br label %$26
$25:
  %82 = phi i64 [%77, %$23] ; # X
  %83 = phi i8* [%78, %$23] ; # S
; # (openWr S)
  %84 = call i32 @openWr(i8* %83)
  br label %$26
$26:
  %85 = phi i64 [%79, %$24], [%82, %$25] ; # X
  %86 = phi i8* [%80, %$24], [%83, %$25] ; # S
  %87 = phi i32 [%81, %$24], [%84, %$25] ; # ->
; # (lt0 (setq Fd (if Flg (openWrAppend S) (openWr S))))
  %88 = icmp slt i32 %87, 0
  br i1 %88, label %$27, label %$28
$27:
  %89 = phi i64 [%85, %$26] ; # X
  %90 = phi i8* [%86, %$26] ; # S
  %91 = phi i32 [%87, %$26] ; # Fd
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %92 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %93 = icmp eq i32 %92, 2
  br i1 %93, label %$30, label %$29
$29:
  %94 = phi i64 [%89, %$27] ; # X
  %95 = phi i8* [%90, %$27] ; # S
  %96 = phi i32 [%91, %$27] ; # Fd
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %94)
  unreachable
$30:
  %97 = phi i64 [%89, %$27] ; # X
  %98 = phi i8* [%90, %$27] ; # S
  %99 = phi i32 [%91, %$27] ; # Fd
; # (sigChk Exe)
  %100 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %101 = icmp ne i32 %100, 0
  br i1 %101, label %$31, label %$32
$31:
  call void @sighandler(i64 %0)
  br label %$32
$32:
  br label %$23
$28:
  %102 = phi i64 [%85, %$26] ; # X
  %103 = phi i8* [%86, %$26] ; # S
  %104 = phi i32 [%87, %$26] ; # Fd
; # (closeOnExec Exe Fd)
  call void @closeOnExec(i64 %0, i32 %104)
; # (initOutFile Fd)
  %105 = call i8* @initOutFile(i32 %104)
; # (pushOutFile Io (initOutFile Fd) 1)
  call void @pushOutFile(i8* %2, i8* %105, i32 1)
  br label %$2
$19:
  %106 = phi i64 [%62, %$5] ; # X
; # (let (Pfd (b32 2) Av (b8* (inc (length X))) Cmd (xName Exe (xSym ...
; # (b32 2)
  %107 = alloca i32, i64 2
; # (length X)
  br label %$33
$33:
  %108 = phi i64 [%106, %$19], [%117, %$34] ; # X
  %109 = phi i64 [0, %$19], [%114, %$34] ; # N
  %110 = and i64 %108, 15
  %111 = icmp eq i64 %110, 0
  br i1 %111, label %$34, label %$35
$34:
  %112 = phi i64 [%108, %$33] ; # X
  %113 = phi i64 [%109, %$33] ; # N
  %114 = add i64 %113, 1
  %115 = inttoptr i64 %112 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  %117 = load i64, i64* %116
  br label %$33
$35:
  %118 = phi i64 [%108, %$33] ; # X
  %119 = phi i64 [%109, %$33] ; # N
; # (inc (length X))
  %120 = add i64 %119, 1
; # (b8* (inc (length X)))
  %121 = alloca i8*, i64 %120
; # (car X)
  %122 = inttoptr i64 %106 to i64*
  %123 = load i64, i64* %122
; # (xSym (car X))
  %124 = call i64 @xSym(i64 %123)
; # (xName Exe (xSym (car X)))
  %125 = call i64 @xName(i64 %0, i64 %124)
; # (when (lt0 (pipe Pfd)) (pipeErr Exe))
; # (pipe Pfd)
  %126 = call i32 @pipe(i32* %107)
; # (lt0 (pipe Pfd))
  %127 = icmp slt i32 %126, 0
  br i1 %127, label %$36, label %$37
$36:
  %128 = phi i64 [%106, %$35] ; # X
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$37:
  %129 = phi i64 [%106, %$35] ; # X
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %130 = call i64 @pathSize(i64 %125)
; # (b8 (pathSize Cmd))
  %131 = alloca i8, i64 %130
; # (pathString Cmd (b8 (pathSize Cmd)))
  %132 = call i8* @pathString(i64 %125, i8* %131)
  store i8* %132, i8** %121
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (xSym (car X...
; # (while (pair (shift X)) (let Nm (xName Exe (xSym (car X))) (set (...
  br label %$38
$38:
  %133 = phi i64 [%129, %$37], [%140, %$39] ; # X
  %134 = phi i8** [%121, %$37], [%146, %$39] ; # A
; # (shift X)
  %135 = inttoptr i64 %133 to i64*
  %136 = getelementptr i64, i64* %135, i32 1
  %137 = load i64, i64* %136
; # (pair (shift X))
  %138 = and i64 %137, 15
  %139 = icmp eq i64 %138, 0
  br i1 %139, label %$39, label %$40
$39:
  %140 = phi i64 [%137, %$38] ; # X
  %141 = phi i8** [%134, %$38] ; # A
; # (let Nm (xName Exe (xSym (car X))) (set (inc 'A) (bufString Nm (b...
; # (car X)
  %142 = inttoptr i64 %140 to i64*
  %143 = load i64, i64* %142
; # (xSym (car X))
  %144 = call i64 @xSym(i64 %143)
; # (xName Exe (xSym (car X)))
  %145 = call i64 @xName(i64 %0, i64 %144)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %146 = getelementptr i8*, i8** %141, i32 1
; # (bufSize Nm)
  %147 = call i64 @bufSize(i64 %145)
; # (b8 (bufSize Nm))
  %148 = alloca i8, i64 %147
; # (bufString Nm (b8 (bufSize Nm)))
  %149 = call i8* @bufString(i64 %145, i8* %148)
  store i8* %149, i8** %146
  br label %$38
$40:
  %150 = phi i64 [%137, %$38] ; # X
  %151 = phi i8** [%134, %$38] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %152 = getelementptr i8*, i8** %151, i32 1
  store i8* null, i8** %152
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (setpgid 0 0) (close (...
; # (fork)
  %153 = call i32 @fork()
; # (lt0 (fork))
  %154 = icmp slt i32 %153, 0
  br i1 %154, label %$43, label %$42
$43:
  %155 = phi i64 [%150, %$40] ; # X
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$42:
  %156 = phi i64 [%150, %$40] ; # X
; # (=0 @)
  %157 = icmp eq i32 %153, 0
  br i1 %157, label %$45, label %$44
$45:
  %158 = phi i64 [%156, %$42] ; # X
; # (setpgid 0 0)
  %159 = call i32 @setpgid(i32 0, i32 0)
; # (val 2 Pfd)
  %160 = getelementptr i32, i32* %107, i32 1
  %161 = load i32, i32* %160
; # (close (val 2 Pfd))
  %162 = call i32 @close(i32 %161)
; # (when (val Pfd) (dup2 @ 0) (close @))
; # (val Pfd)
  %163 = load i32, i32* %107
  %164 = icmp ne i32 %163, 0
  br i1 %164, label %$46, label %$47
$46:
  %165 = phi i64 [%158, %$45] ; # X
; # (dup2 @ 0)
  %166 = call i32 @dup2(i32 %163, i32 0)
; # (close @)
  %167 = call i32 @close(i32 %163)
  br label %$47
$47:
  %168 = phi i64 [%158, %$45], [%165, %$46] ; # X
; # (val Av)
  %169 = load i8*, i8** %121
; # (execvp (val Av) Av)
  %170 = call i32 @execvp(i8* %169, i8** %121)
; # (val Av)
  %171 = load i8*, i8** %121
; # (execErr (val Av))
  call void @execErr(i8* %171)
  unreachable
$44:
  %172 = phi i64 [%156, %$42] ; # X
  br label %$41
$41:
  %173 = phi i64 [%172, %$44] ; # X
  %174 = phi i64 [0, %$44] ; # ->
; # (let (Pid @ Fd (val 2 Pfd)) (setpgid Pid 0) (close (val Pfd)) (cl...
; # (val 2 Pfd)
  %175 = getelementptr i32, i32* %107, i32 1
  %176 = load i32, i32* %175
; # (setpgid Pid 0)
  %177 = call i32 @setpgid(i32 %153, i32 0)
; # (val Pfd)
  %178 = load i32, i32* %107
; # (close (val Pfd))
  %179 = call i32 @close(i32 %178)
; # (closeOnExec Exe Fd)
  call void @closeOnExec(i64 %0, i32 %176)
; # (initOutFile Fd)
  %180 = call i8* @initOutFile(i32 %176)
; # (pushOutFile Io (initOutFile Fd) Pid)
  call void @pushOutFile(i8* %2, i8* %180, i32 %153)
  br label %$2
$2:
  %181 = phi i64 [%4, %$4], [%59, %$7], [%102, %$28], [%173, %$41] ; # X
  ret void
}

define void @erOpen(i64, i64, i8*) align 8 {
$1:
; # (let Ct: (ctFrame Ct) (Ct: fd (dup 2)) (let Fd (if (nil? (needSym...
; # (Ct: fd (dup 2))
  %3 = getelementptr i8, i8* %2, i32 8
  %4 = bitcast i8* %3 to i32*
  %5 = call i32 @dup(i32 2)
  store i32 %5, i32* %4
; # (let Fd (if (nil? (needSymb Exe X)) (dup ((outFile (val $OutFile)...
; # (if (nil? (needSymb Exe X)) (dup ((outFile (val $OutFile)) fd)) (...
; # (needSymb Exe X)
  %6 = xor i64 %1, 8
  %7 = and i64 %6, 14
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %$3, label %$2
$2:
  call void @symErr(i64 %0, i64 %1)
  unreachable
$3:
; # (nil? (needSymb Exe X))
  %9 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %9, label %$4, label %$5
$4:
; # (val $OutFile)
  %10 = load i8*, i8** @$OutFile
; # ((outFile (val $OutFile)) fd)
  %11 = bitcast i8* %10 to i32*
  %12 = load i32, i32* %11
; # (dup ((outFile (val $OutFile)) fd))
  %13 = call i32 @dup(i32 %12)
  br label %$6
$5:
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %14 = call i64 @xName(i64 %0, i64 %1)
; # (pathSize Nm)
  %15 = call i64 @pathSize(i64 %14)
; # (b8 (pathSize Nm))
  %16 = alloca i8, i64 %15
; # (pathString Nm (b8 (pathSize Nm)))
  %17 = call i8* @pathString(i64 %14, i8* %16)
; # (val S)
  %18 = load i8, i8* %17
; # (== (val S) (char "+"))
  %19 = icmp eq i8 %18, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %19, label %$7, label %$8
$7:
  %20 = phi i8* [%17, %$5] ; # S
; # (ofs S 1)
  %21 = getelementptr i8, i8* %20, i32 1
  br label %$8
$8:
  %22 = phi i8* [%17, %$5], [%21, %$7] ; # S
; # (while (lt0 (if Flg (openWrAppend S) (openWr S))) (unless (== (gE...
  br label %$9
$9:
  %23 = phi i8* [%22, %$8], [%35, %$18] ; # S
; # (if Flg (openWrAppend S) (openWr S))
  br i1 %19, label %$10, label %$11
$10:
  %24 = phi i8* [%23, %$9] ; # S
; # (openWrAppend S)
  %25 = call i32 @openWrAppend(i8* %24)
  br label %$12
$11:
  %26 = phi i8* [%23, %$9] ; # S
; # (openWr S)
  %27 = call i32 @openWr(i8* %26)
  br label %$12
$12:
  %28 = phi i8* [%24, %$10], [%26, %$11] ; # S
  %29 = phi i32 [%25, %$10], [%27, %$11] ; # ->
; # (lt0 (if Flg (openWrAppend S) (openWr S)))
  %30 = icmp slt i32 %29, 0
  br i1 %30, label %$13, label %$14
$13:
  %31 = phi i8* [%28, %$12] ; # S
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %32 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %33 = icmp eq i32 %32, 2
  br i1 %33, label %$16, label %$15
$15:
  %34 = phi i8* [%31, %$13] ; # S
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %1)
  unreachable
$16:
  %35 = phi i8* [%31, %$13] ; # S
; # (sigChk Exe)
  %36 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %37 = icmp ne i32 %36, 0
  br i1 %37, label %$17, label %$18
$17:
  call void @sighandler(i64 %0)
  br label %$18
$18:
  br label %$9
$14:
  %38 = phi i8* [%28, %$12] ; # S
; # (closeOnExec Exe @)
  call void @closeOnExec(i64 %0, i32 %29)
  br label %$6
$6:
  %39 = phi i32 [%13, %$4], [%29, %$14] ; # ->
; # (dup2 Fd 2)
  %40 = call i32 @dup2(i32 %39, i32 2)
; # (close Fd)
  %41 = call i32 @close(i32 %39)
; # (pushErrFile Ct)
  call void @pushErrFile(i8* %2)
  ret void
}

define void @ctOpen(i64, i64, i8*) align 8 {
$1:
; # (let Ct: (ctFrame Ct) (cond ((nil? (needSymb Exe X)) (Ct: fd -1) ...
; # (cond ((nil? (needSymb Exe X)) (Ct: fd -1) (rdLockWait (currFd Ex...
; # (needSymb Exe X)
  %3 = xor i64 %1, 8
  %4 = and i64 %3, 14
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$4, label %$3
$3:
  call void @symErr(i64 %0, i64 %1)
  unreachable
$4:
; # (nil? (needSymb Exe X))
  %6 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %6, label %$6, label %$5
$6:
; # (Ct: fd -1)
  %7 = getelementptr i8, i8* %2, i32 8
  %8 = bitcast i8* %7 to i32*
  store i32 -1, i32* %8
; # (currFd Exe)
  %9 = call i32 @currFd(i64 %0)
; # (rdLockWait (currFd Exe) 0)
  call void @rdLockWait(i32 %9, i64 0)
  br label %$2
$5:
; # (t? X)
  %10 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %10, label %$8, label %$7
$8:
; # (Ct: fd -1)
  %11 = getelementptr i8, i8* %2, i32 8
  %12 = bitcast i8* %11 to i32*
  store i32 -1, i32* %12
; # (currFd Exe)
  %13 = call i32 @currFd(i64 %0)
; # (wrLockWait (currFd Exe) 0)
  call void @wrLockWait(i32 %13, i64 0)
  br label %$2
$7:
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %14 = call i64 @xName(i64 %0, i64 %1)
; # (pathSize Nm)
  %15 = call i64 @pathSize(i64 %14)
; # (b8 (pathSize Nm))
  %16 = alloca i8, i64 %15
; # (pathString Nm (b8 (pathSize Nm)))
  %17 = call i8* @pathString(i64 %14, i8* %16)
; # (val S)
  %18 = load i8, i8* %17
; # (== (val S) (char "+"))
  %19 = icmp eq i8 %18, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %19, label %$9, label %$10
$9:
  %20 = phi i8* [%17, %$7] ; # S
; # (ofs S 1)
  %21 = getelementptr i8, i8* %20, i32 1
  br label %$10
$10:
  %22 = phi i8* [%17, %$7], [%21, %$9] ; # S
; # (while (lt0 (openRdWrCreate S)) (unless (== (gErrno) EINTR) (open...
  br label %$11
$11:
  %23 = phi i8* [%22, %$10], [%30, %$17] ; # S
; # (openRdWrCreate S)
  %24 = call i32 @openRdWrCreate(i8* %23)
; # (lt0 (openRdWrCreate S))
  %25 = icmp slt i32 %24, 0
  br i1 %25, label %$12, label %$13
$12:
  %26 = phi i8* [%23, %$11] ; # S
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %27 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %28 = icmp eq i32 %27, 2
  br i1 %28, label %$15, label %$14
$14:
  %29 = phi i8* [%26, %$12] ; # S
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %1)
  unreachable
$15:
  %30 = phi i8* [%26, %$12] ; # S
; # (sigChk Exe)
  %31 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %32 = icmp ne i32 %31, 0
  br i1 %32, label %$16, label %$17
$16:
  call void @sighandler(i64 %0)
  br label %$17
$17:
  br label %$11
$13:
  %33 = phi i8* [%23, %$11] ; # S
; # (let Fd (Ct: fd @) (if Flg (rdLockWait Fd 0) (wrLockWait Fd 0)) (...
; # (Ct: fd @)
  %34 = getelementptr i8, i8* %2, i32 8
  %35 = bitcast i8* %34 to i32*
  store i32 %24, i32* %35
; # (if Flg (rdLockWait Fd 0) (wrLockWait Fd 0))
  br i1 %19, label %$18, label %$19
$18:
  %36 = phi i8* [%33, %$13] ; # S
; # (rdLockWait Fd 0)
  call void @rdLockWait(i32 %24, i64 0)
  br label %$20
$19:
  %37 = phi i8* [%33, %$13] ; # S
; # (wrLockWait Fd 0)
  call void @wrLockWait(i32 %24, i64 0)
  br label %$20
$20:
  %38 = phi i8* [%36, %$18], [%37, %$19] ; # S
; # (closeOnExec Exe Fd)
  call void @closeOnExec(i64 %0, i32 %24)
  br label %$2
$2:
; # (pushCtlFile Ct)
  call void @pushCtlFile(i8* %2)
  ret void
}

define i32 @rlGetc(i8*) align 8 {
$1:
; # (if (waitFd 0 0 292MY) (stdinByte) -1)
; # (waitFd 0 0 292MY)
  %1 = call i64 @waitFd(i64 0, i32 0, i64 9223372036854775807)
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (stdinByte)
  %3 = call i32 @stdinByte()
  br label %$4
$3:
  br label %$4
$4:
  %4 = phi i32 [%3, %$2], [-1, %$3] ; # ->
  ret i32 %4
}

define i32 @rlAvail() align 8 {
$1:
; # (waitFd 0 0 60)
  %0 = call i64 @waitFd(i64 0, i32 0, i64 60)
; # (i32 (waitFd 0 0 60))
  %1 = trunc i64 %0 to i32
  ret i32 %1
}

define i32 @_getStdin() align 8 {
$1:
; # (let In: (inFile (val $InFile)) (set $Chr (cond ((lt0 (In: fd)) -...
; # (val $InFile)
  %0 = load i8*, i8** @$InFile
; # (set $Chr (cond ((lt0 (In: fd)) -1) ((or (In: fd) (not (In: tty))...
; # (cond ((lt0 (In: fd)) -1) ((or (In: fd) (not (In: tty))) (if (and...
; # (In: fd)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (lt0 (In: fd))
  %4 = icmp slt i32 %3, 0
  br i1 %4, label %$4, label %$3
$4:
  br label %$2
$3:
; # (or (In: fd) (not (In: tty)))
; # (In: fd)
  %5 = getelementptr i8, i8* %0, i32 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %$5, label %$6
$6:
; # (In: tty)
  %9 = getelementptr i8, i8* %0, i32 4128
  %10 = bitcast i8* %9 to i1*
  %11 = load i1, i1* %10
; # (not (In: tty))
  %12 = icmp eq i1 %11, 0
  br label %$5
$5:
  %13 = phi i1 [1, %$3], [%12, %$6] ; # ->
  br i1 %13, label %$8, label %$7
$8:
; # (if (and (== (In: ix) (In: cnt)) (or (lt0 (In: ix)) (=0 (slow (In...
; # (and (== (In: ix) (In: cnt)) (or (lt0 (In: ix)) (=0 (slow (In:)))...
; # (In: ix)
  %14 = getelementptr i8, i8* %0, i32 24
  %15 = bitcast i8* %14 to i32*
  %16 = load i32, i32* %15
; # (In: cnt)
  %17 = getelementptr i8, i8* %0, i32 28
  %18 = bitcast i8* %17 to i32*
  %19 = load i32, i32* %18
; # (== (In: ix) (In: cnt))
  %20 = icmp eq i32 %16, %19
  br i1 %20, label %$10, label %$9
$10:
; # (or (lt0 (In: ix)) (=0 (slow (In:))))
; # (In: ix)
  %21 = getelementptr i8, i8* %0, i32 24
  %22 = bitcast i8* %21 to i32*
  %23 = load i32, i32* %22
; # (lt0 (In: ix))
  %24 = icmp slt i32 %23, 0
  br i1 %24, label %$11, label %$12
$12:
; # (In:)
; # (slow (In:))
  %25 = call i32 @slow(i8* %0)
; # (=0 (slow (In:)))
  %26 = icmp eq i32 %25, 0
  br label %$11
$11:
  %27 = phi i1 [1, %$10], [%26, %$12] ; # ->
  br label %$9
$9:
  %28 = phi i1 [0, %$8], [%27, %$11] ; # ->
  br i1 %28, label %$13, label %$14
$13:
  br label %$15
$14:
; # (let I (In: ix) (prog1 (i32 (val (ofs (In: (buf)) I))) (when (== ...
; # (In: ix)
  %29 = getelementptr i8, i8* %0, i32 24
  %30 = bitcast i8* %29 to i32*
  %31 = load i32, i32* %30
; # (prog1 (i32 (val (ofs (In: (buf)) I))) (when (== @ (char "^J")) (...
; # (In: (buf))
  %32 = getelementptr i8, i8* %0, i32 32
; # (ofs (In: (buf)) I)
  %33 = getelementptr i8, i8* %32, i32 %31
; # (val (ofs (In: (buf)) I))
  %34 = load i8, i8* %33
; # (i32 (val (ofs (In: (buf)) I)))
  %35 = zext i8 %34 to i32
; # (when (== @ (char "^J")) (In: line (+ (In: line) 1)))
; # (== @ (char "^J"))
  %36 = icmp eq i32 %35, 10
  br i1 %36, label %$16, label %$17
$16:
; # (In: line (+ (In: line) 1))
  %37 = getelementptr i8, i8* %0, i32 16
  %38 = bitcast i8* %37 to i32*
  %39 = getelementptr i8, i8* %0, i32 16
  %40 = bitcast i8* %39 to i32*
  %41 = load i32, i32* %40
  %42 = add i32 %41, 1
  store i32 %42, i32* %38
  br label %$17
$17:
; # (In: ix (+ I 1))
  %43 = getelementptr i8, i8* %0, i32 24
  %44 = bitcast i8* %43 to i32*
  %45 = add i32 %31, 1
  store i32 %45, i32* %44
  br label %$15
$15:
  %46 = phi i32 [-1, %$13], [%35, %$17] ; # ->
  br label %$2
$7:
; # (let P (val $LinePtr) (unless P (when (val $LineBuf) (free @) (se...
; # (val $LinePtr)
  %47 = load i8*, i8** @$LinePtr
; # (unless P (when (val $LineBuf) (free @) (set $LineBuf null)) (flu...
  %48 = icmp ne i8* %47, null
  br i1 %48, label %$19, label %$18
$18:
  %49 = phi i8* [%47, %$7] ; # P
; # (when (val $LineBuf) (free @) (set $LineBuf null))
; # (val $LineBuf)
  %50 = load i8*, i8** @$LineBuf
  %51 = icmp ne i8* %50, null
  br i1 %51, label %$20, label %$21
$20:
  %52 = phi i8* [%49, %$18] ; # P
; # (free @)
  call void @free(i8* %50)
; # (set $LineBuf null)
  store i8* null, i8** @$LineBuf
  br label %$21
$21:
  %53 = phi i8* [%49, %$18], [%52, %$20] ; # P
; # (flushAll)
  call void @flushAll()
; # (unless (setq P (set $LineBuf (gReadline (val $LinePrmt)))) (wrnl...
; # (set $LineBuf (gReadline (val $LinePrmt)))
; # (val $LinePrmt)
  %54 = load i8*, i8** @$LinePrmt
; # (gReadline (val $LinePrmt))
  %55 = call i8* @gReadline(i8* %54)
  store i8* %55, i8** @$LineBuf
  %56 = icmp ne i8* %55, null
  br i1 %56, label %$23, label %$22
$22:
  %57 = phi i8* [%55, %$21] ; # P
; # (wrnl)
  %58 = call i64 @wrnl()
; # (when (or (val $Bind) (== (val $LinePrmt) (val $ContPrmt))) (err ...
; # (or (val $Bind) (== (val $LinePrmt) (val $ContPrmt)))
; # (val $Bind)
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$24, label %$25
$25:
  %62 = phi i8* [%57, %$22] ; # P
; # (val $LinePrmt)
  %63 = load i8*, i8** @$LinePrmt
; # (val $ContPrmt)
  %64 = load i8*, i8** @$ContPrmt
; # (== (val $LinePrmt) (val $ContPrmt))
  %65 = icmp eq i8* %63, %64
  br label %$24
$24:
  %66 = phi i8* [%57, %$22], [%62, %$25] ; # P
  %67 = phi i1 [1, %$22], [%65, %$25] ; # ->
  br i1 %67, label %$26, label %$27
$26:
  %68 = phi i8* [%66, %$24] ; # P
; # (err 0 0 $Empty null)
  call void @err(i64 0, i64 0, i8* bitcast ([1 x i8]* @$Empty to i8*), i8* null)
  unreachable
$27:
  %69 = phi i8* [%66, %$24] ; # P
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$23:
  %70 = phi i8* [%55, %$21] ; # P
; # (set $LinePrmt (val $ContPrmt))
; # (val $ContPrmt)
  %71 = load i8*, i8** @$ContPrmt
  store i8* %71, i8** @$LinePrmt
; # (unless (or (=0 (val P)) (== @ 32) (and (== @ (char ".")) (=0 (va...
; # (or (=0 (val P)) (== @ 32) (and (== @ (char ".")) (=0 (val (inc P...
; # (val P)
  %72 = load i8, i8* %70
; # (=0 (val P))
  %73 = icmp eq i8 %72, 0
  br i1 %73, label %$28, label %$29
$29:
  %74 = phi i8* [%70, %$23] ; # P
; # (== @ 32)
  %75 = icmp eq i8 %72, 32
  br i1 %75, label %$28, label %$30
$30:
  %76 = phi i8* [%74, %$29] ; # P
; # (and (== @ (char ".")) (=0 (val (inc P))))
; # (== @ (char "."))
  %77 = icmp eq i8 %72, 46
  br i1 %77, label %$32, label %$31
$32:
  %78 = phi i8* [%76, %$30] ; # P
; # (inc P)
  %79 = getelementptr i8, i8* %78, i32 1
; # (val (inc P))
  %80 = load i8, i8* %79
; # (=0 (val (inc P)))
  %81 = icmp eq i8 %80, 0
  br label %$31
$31:
  %82 = phi i8* [%76, %$30], [%78, %$32] ; # P
  %83 = phi i1 [0, %$30], [%81, %$32] ; # ->
  br i1 %83, label %$28, label %$33
$33:
  %84 = phi i8* [%82, %$31] ; # P
; # (and (currentLine) (=0 (strcmp @ P)))
; # (currentLine)
  %85 = call i8* @currentLine()
  %86 = icmp ne i8* %85, null
  br i1 %86, label %$35, label %$34
$35:
  %87 = phi i8* [%84, %$33] ; # P
; # (strcmp @ P)
  %88 = call i32 @strcmp(i8* %85, i8* %87)
; # (=0 (strcmp @ P))
  %89 = icmp eq i32 %88, 0
  br label %$34
$34:
  %90 = phi i8* [%84, %$33], [%87, %$35] ; # P
  %91 = phi i1 [0, %$33], [%89, %$35] ; # ->
  br label %$28
$28:
  %92 = phi i8* [%70, %$23], [%74, %$29], [%82, %$31], [%90, %$34] ; # P
  %93 = phi i1 [1, %$23], [1, %$29], [1, %$31], [%91, %$34] ; # ->
  br i1 %93, label %$37, label %$36
$36:
  %94 = phi i8* [%92, %$28] ; # P
; # (add_history P)
  call void @add_history(i8* %94)
  br label %$37
$37:
  %95 = phi i8* [%92, %$28], [%94, %$36] ; # P
  br label %$19
$19:
  %96 = phi i8* [%47, %$7], [%95, %$37] ; # P
; # (nond ((val P) (set $LinePtr null) (char "^J")) (NIL (set $LinePt...
; # (val P)
  %97 = load i8, i8* %96
  %98 = icmp ne i8 %97, 0
  br i1 %98, label %$39, label %$40
$40:
  %99 = phi i8* [%96, %$19] ; # P
; # (set $LinePtr null)
  store i8* null, i8** @$LinePtr
  br label %$38
$39:
  %100 = phi i8* [%96, %$19] ; # P
; # (set $LinePtr (inc P))
; # (inc P)
  %101 = getelementptr i8, i8* %100, i32 1
  store i8* %101, i8** @$LinePtr
; # (i32 @)
  %102 = zext i8 %97 to i32
  br label %$38
$38:
  %103 = phi i8* [%99, %$40], [%100, %$39] ; # P
  %104 = phi i32 [10, %$40], [%102, %$39] ; # ->
  br label %$2
$2:
  %105 = phi i32 [-1, %$4], [%46, %$15], [%104, %$38] ; # ->
  store i32 %105, i32* @$Chr
  ret i32 %105
}

define i32 @getChar(i32) align 8 {
$1:
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (let B (ifn...
; # (>= 127 C)
  %1 = icmp sge i32 127, %0
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (== C (hex "FF"))
  %2 = icmp eq i32 %0, 255
  br i1 %2, label %$6, label %$5
$6:
; # (i32 TOP)
  br label %$2
$5:
; # (let B (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (h...
; # (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (hex "10"...
; # (& C (hex "20"))
  %3 = and i32 %0, 32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %$8, label %$7
$7:
; # (& C (hex "1F"))
  %5 = and i32 %0, 31
  br label %$9
$8:
; # (let A (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) ...
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) (& (cal...
; # (& C (hex "10"))
  %6 = and i32 %0, 16
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %$11, label %$10
$10:
; # (& C (hex "0F"))
  %8 = and i32 %0, 15
  br label %$12
$11:
; # (& C 7)
  %9 = and i32 %0, 7
; # (shl (& C 7) 6)
  %10 = shl i32 %9, 6
; # (call $Get)
  %11 = load i32()*, i32()** @$Get
  %12 = call i32 %11()
; # (& (call $Get) (hex "3F"))
  %13 = and i32 %12, 63
; # (| (shl (& C 7) 6) (& (call $Get) (hex "3F")))
  %14 = or i32 %10, %13
  br label %$12
$12:
  %15 = phi i32 [%8, %$10], [%14, %$11] ; # ->
; # (shl A 6)
  %16 = shl i32 %15, 6
; # (call $Get)
  %17 = load i32()*, i32()** @$Get
  %18 = call i32 %17()
; # (& (call $Get) (hex "3F"))
  %19 = and i32 %18, 63
; # (| (shl A 6) (& (call $Get) (hex "3F")))
  %20 = or i32 %16, %19
  br label %$9
$9:
  %21 = phi i32 [%5, %$7], [%20, %$12] ; # ->
; # (shl B 6)
  %22 = shl i32 %21, 6
; # (call $Get)
  %23 = load i32()*, i32()** @$Get
  %24 = call i32 %23()
; # (& (call $Get) (hex "3F"))
  %25 = and i32 %24, 63
; # (| (shl B 6) (& (call $Get) (hex "3F")))
  %26 = or i32 %22, %25
  br label %$2
$2:
  %27 = phi i32 [%0, %$4], [1114112, %$6], [%26, %$9] ; # ->
  ret i32 %27
}

define i32 @skipc(i32) align 8 {
$1:
; # (let Chr (val $Chr) (loop (while (>= 32 Chr) (when (lt0 (setq Chr...
; # (val $Chr)
  %1 = load i32, i32* @$Chr
; # (loop (while (>= 32 Chr) (when (lt0 (setq Chr (call $Get))) (ret ...
  br label %$2
$2:
  %2 = phi i32 [%1, %$1], [%25, %$12] ; # Chr
; # (while (>= 32 Chr) (when (lt0 (setq Chr (call $Get))) (ret Chr)))...
  br label %$3
$3:
  %3 = phi i32 [%2, %$2], [%10, %$7] ; # Chr
; # (>= 32 Chr)
  %4 = icmp sge i32 32, %3
  br i1 %4, label %$4, label %$5
$4:
  %5 = phi i32 [%3, %$3] ; # Chr
; # (when (lt0 (setq Chr (call $Get))) (ret Chr))
; # (call $Get)
  %6 = load i32()*, i32()** @$Get
  %7 = call i32 %6()
; # (lt0 (setq Chr (call $Get)))
  %8 = icmp slt i32 %7, 0
  br i1 %8, label %$6, label %$7
$6:
  %9 = phi i32 [%7, %$4] ; # Chr
; # (ret Chr)
  ret i32 %9
$7:
  %10 = phi i32 [%7, %$4] ; # Chr
  br label %$3
$5:
  %11 = phi i32 [%3, %$3] ; # Chr
; # (unless (== Chr C) (ret Chr))
; # (== Chr C)
  %12 = icmp eq i32 %11, %0
  br i1 %12, label %$9, label %$8
$8:
  %13 = phi i32 [%11, %$5] ; # Chr
; # (ret Chr)
  ret i32 %13
$9:
  %14 = phi i32 [%11, %$5] ; # Chr
; # (until (== (setq Chr (call $Get)) (char "^J")) (when (lt0 Chr) (r...
  br label %$10
$10:
  %15 = phi i32 [%14, %$9], [%22, %$14] ; # Chr
; # (call $Get)
  %16 = load i32()*, i32()** @$Get
  %17 = call i32 %16()
; # (== (setq Chr (call $Get)) (char "^J"))
  %18 = icmp eq i32 %17, 10
  br i1 %18, label %$12, label %$11
$11:
  %19 = phi i32 [%17, %$10] ; # Chr
; # (when (lt0 Chr) (ret Chr))
; # (lt0 Chr)
  %20 = icmp slt i32 %19, 0
  br i1 %20, label %$13, label %$14
$13:
  %21 = phi i32 [%19, %$11] ; # Chr
; # (ret Chr)
  ret i32 %21
$14:
  %22 = phi i32 [%19, %$11] ; # Chr
  br label %$10
$12:
  %23 = phi i32 [%17, %$10] ; # Chr
; # (call $Get)
  %24 = load i32()*, i32()** @$Get
  %25 = call i32 %24()
  br label %$2
}

define void @comment() align 8 {
$1:
; # (let Chr (call $Get) (if (== Chr (char "{")) (let N 0 (loop (? (l...
; # (call $Get)
  %0 = load i32()*, i32()** @$Get
  %1 = call i32 %0()
; # (if (== Chr (char "{")) (let N 0 (loop (? (lt0 (setq Chr (call $G...
; # (== Chr (char "{"))
  %2 = icmp eq i32 %1, 123
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i32 [%1, %$1] ; # Chr
; # (let N 0 (loop (? (lt0 (setq Chr (call $Get)))) (if (and (== Chr ...
; # (loop (? (lt0 (setq Chr (call $Get)))) (if (and (== Chr (char "#"...
  br label %$5
$5:
  %4 = phi i32 [%3, %$2], [%40, %$12] ; # Chr
  %5 = phi i64 [0, %$2], [%41, %$12] ; # N
; # (? (lt0 (setq Chr (call $Get))))
; # (call $Get)
  %6 = load i32()*, i32()** @$Get
  %7 = call i32 %6()
; # (lt0 (setq Chr (call $Get)))
  %8 = icmp slt i32 %7, 0
  br i1 %8, label %$7, label %$6
$6:
  %9 = phi i32 [%7, %$5] ; # Chr
  %10 = phi i64 [%5, %$5] ; # N
; # (if (and (== Chr (char "#")) (== (setq Chr (call $Get)) (char "{"...
; # (and (== Chr (char "#")) (== (setq Chr (call $Get)) (char "{")))
; # (== Chr (char "#"))
  %11 = icmp eq i32 %9, 35
  br i1 %11, label %$9, label %$8
$9:
  %12 = phi i32 [%9, %$6] ; # Chr
  %13 = phi i64 [%10, %$6] ; # N
; # (call $Get)
  %14 = load i32()*, i32()** @$Get
  %15 = call i32 %14()
; # (== (setq Chr (call $Get)) (char "{"))
  %16 = icmp eq i32 %15, 123
  br label %$8
$8:
  %17 = phi i32 [%9, %$6], [%15, %$9] ; # Chr
  %18 = phi i64 [%10, %$6], [%13, %$9] ; # N
  %19 = phi i1 [0, %$6], [%16, %$9] ; # ->
  br i1 %19, label %$10, label %$11
$10:
  %20 = phi i32 [%17, %$8] ; # Chr
  %21 = phi i64 [%18, %$8] ; # N
; # (inc 'N)
  %22 = add i64 %21, 1
  br label %$12
$11:
  %23 = phi i32 [%17, %$8] ; # Chr
  %24 = phi i64 [%18, %$8] ; # N
; # (? (and (== Chr (char "}")) (== (setq Chr (call $Get)) (char "#")...
; # (and (== Chr (char "}")) (== (setq Chr (call $Get)) (char "#")) (...
; # (== Chr (char "}"))
  %25 = icmp eq i32 %23, 125
  br i1 %25, label %$14, label %$13
$14:
  %26 = phi i32 [%23, %$11] ; # Chr
  %27 = phi i64 [%24, %$11] ; # N
; # (call $Get)
  %28 = load i32()*, i32()** @$Get
  %29 = call i32 %28()
; # (== (setq Chr (call $Get)) (char "#"))
  %30 = icmp eq i32 %29, 35
  br i1 %30, label %$15, label %$13
$15:
  %31 = phi i32 [%29, %$14] ; # Chr
  %32 = phi i64 [%27, %$14] ; # N
; # (dec 'N)
  %33 = sub i64 %32, 1
; # (lt0 (dec 'N))
  %34 = icmp slt i64 %33, 0
  br label %$13
$13:
  %35 = phi i32 [%23, %$11], [%29, %$14], [%31, %$15] ; # Chr
  %36 = phi i64 [%24, %$11], [%27, %$14], [%33, %$15] ; # N
  %37 = phi i1 [0, %$11], [0, %$14], [%34, %$15] ; # ->
  br i1 %37, label %$7, label %$16
$16:
  %38 = phi i32 [%35, %$13] ; # Chr
  %39 = phi i64 [%36, %$13] ; # N
  br label %$12
$12:
  %40 = phi i32 [%20, %$10], [%38, %$16] ; # Chr
  %41 = phi i64 [%22, %$10], [%39, %$16] ; # N
  br label %$5
$7:
  %42 = phi i32 [%7, %$5], [%35, %$13] ; # Chr
  %43 = phi i64 [%5, %$5], [%36, %$13] ; # N
  %44 = phi i64 [0, %$5], [0, %$13] ; # ->
  br label %$4
$3:
  %45 = phi i32 [%1, %$1] ; # Chr
; # (until (== Chr (char "^J")) (? (lt0 Chr)) (setq Chr (call $Get)))...
  br label %$17
$17:
  %46 = phi i32 [%45, %$3], [%52, %$20] ; # Chr
; # (== Chr (char "^J"))
  %47 = icmp eq i32 %46, 10
  br i1 %47, label %$19, label %$18
$18:
  %48 = phi i32 [%46, %$17] ; # Chr
; # (? (lt0 Chr))
; # (lt0 Chr)
  %49 = icmp slt i32 %48, 0
  br i1 %49, label %$19, label %$20
$20:
  %50 = phi i32 [%48, %$18] ; # Chr
; # (call $Get)
  %51 = load i32()*, i32()** @$Get
  %52 = call i32 %51()
  br label %$17
$19:
  %53 = phi i32 [%46, %$17], [%48, %$18] ; # Chr
  br label %$4
$4:
  %54 = phi i32 [%42, %$7], [%53, %$19] ; # Chr
; # (call $Get)
  %55 = load i32()*, i32()** @$Get
  %56 = call i32 %55()
  ret void
}

define i32 @skip() align 8 {
$1:
; # (loop (let Chr (val $Chr) (when (lt0 Chr) (ret Chr)) (while (>= (...
  br label %$2
$2:
; # (let Chr (val $Chr) (when (lt0 Chr) (ret Chr)) (while (>= (char "...
; # (val $Chr)
  %0 = load i32, i32* @$Chr
; # (when (lt0 Chr) (ret Chr))
; # (lt0 Chr)
  %1 = icmp slt i32 %0, 0
  br i1 %1, label %$3, label %$4
$3:
  %2 = phi i32 [%0, %$2] ; # Chr
; # (ret Chr)
  ret i32 %2
$4:
  %3 = phi i32 [%0, %$2] ; # Chr
; # (while (>= (char " ") Chr) (when (lt0 (setq Chr (call $Get))) (re...
  br label %$5
$5:
  %4 = phi i32 [%3, %$4], [%11, %$9] ; # Chr
; # (>= (char " ") Chr)
  %5 = icmp sge i32 32, %4
  br i1 %5, label %$6, label %$7
$6:
  %6 = phi i32 [%4, %$5] ; # Chr
; # (when (lt0 (setq Chr (call $Get))) (ret Chr))
; # (call $Get)
  %7 = load i32()*, i32()** @$Get
  %8 = call i32 %7()
; # (lt0 (setq Chr (call $Get)))
  %9 = icmp slt i32 %8, 0
  br i1 %9, label %$8, label %$9
$8:
  %10 = phi i32 [%8, %$6] ; # Chr
; # (ret Chr)
  ret i32 %10
$9:
  %11 = phi i32 [%8, %$6] ; # Chr
  br label %$5
$7:
  %12 = phi i32 [%4, %$5] ; # Chr
; # (unless (== Chr (char "#")) (ret Chr))
; # (== Chr (char "#"))
  %13 = icmp eq i32 %12, 35
  br i1 %13, label %$11, label %$10
$10:
  %14 = phi i32 [%12, %$7] ; # Chr
; # (ret Chr)
  ret i32 %14
$11:
  %15 = phi i32 [%12, %$7] ; # Chr
; # (comment)
  call void @comment()
  br label %$2
}

define i1 @testEsc(i32) align 8 {
$1:
; # (loop (? (lt0 Chr) NO) (? (== Chr (char "\^")) (when (== (setq Ch...
  br label %$2
$2:
  %1 = phi i32 [%0, %$1], [%72, %$39] ; # Chr
; # (? (lt0 Chr) NO)
; # (lt0 Chr)
  %2 = icmp slt i32 %1, 0
  br i1 %2, label %$5, label %$3
$5:
  %3 = phi i32 [%1, %$2] ; # Chr
  br label %$4
$3:
  %4 = phi i32 [%1, %$2] ; # Chr
; # (? (== Chr (char "\^")) (when (== (setq Chr (call $Get)) (char "@...
; # (== Chr (char "\^"))
  %5 = icmp eq i32 %4, 94
  br i1 %5, label %$7, label %$6
$7:
  %6 = phi i32 [%4, %$3] ; # Chr
; # (when (== (setq Chr (call $Get)) (char "@")) (badInput))
; # (call $Get)
  %7 = load i32()*, i32()** @$Get
  %8 = call i32 %7()
; # (== (setq Chr (call $Get)) (char "@"))
  %9 = icmp eq i32 %8, 64
  br i1 %9, label %$8, label %$9
$8:
  %10 = phi i32 [%8, %$7] ; # Chr
; # (badInput)
  call void @badInput()
  unreachable
$9:
  %11 = phi i32 [%8, %$7] ; # Chr
; # (set $Chr (if (== Chr (char "?")) 127 (& Chr (hex "1F"))))
; # (if (== Chr (char "?")) 127 (& Chr (hex "1F")))
; # (== Chr (char "?"))
  %12 = icmp eq i32 %11, 63
  br i1 %12, label %$10, label %$11
$10:
  %13 = phi i32 [%11, %$9] ; # Chr
  br label %$12
$11:
  %14 = phi i32 [%11, %$9] ; # Chr
; # (& Chr (hex "1F"))
  %15 = and i32 %14, 31
  br label %$12
$12:
  %16 = phi i32 [%13, %$10], [%14, %$11] ; # Chr
  %17 = phi i32 [127, %$10], [%15, %$11] ; # ->
  store i32 %17, i32* @$Chr
  br label %$4
$6:
  %18 = phi i32 [%4, %$3] ; # Chr
; # (? (<> Chr (char "\\")) (set $Chr (getChar Chr)) YES)
; # (<> Chr (char "\\"))
  %19 = icmp ne i32 %18, 92
  br i1 %19, label %$14, label %$13
$14:
  %20 = phi i32 [%18, %$6] ; # Chr
; # (set $Chr (getChar Chr))
; # (getChar Chr)
  %21 = call i32 @getChar(i32 %20)
  store i32 %21, i32* @$Chr
  br label %$4
$13:
  %22 = phi i32 [%18, %$6] ; # Chr
; # (? (<> (char "^J") (setq Chr (call $Get))) (case Chr ((char "b") ...
; # (call $Get)
  %23 = load i32()*, i32()** @$Get
  %24 = call i32 %23()
; # (<> (char "^J") (setq Chr (call $Get)))
  %25 = icmp ne i32 10, %24
  br i1 %25, label %$16, label %$15
$16:
  %26 = phi i32 [%24, %$13] ; # Chr
; # (case Chr ((char "b") (set $Chr (char "^H"))) ((char "e") (set $C...
  switch i32 %26, label %$17 [
    i32 98, label %$19
    i32 101, label %$20
    i32 110, label %$21
    i32 114, label %$22
    i32 116, label %$23
  ]
$19:
  %27 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^H"))
  store i32 8, i32* @$Chr
  br label %$18
$20:
  %28 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^["))
  store i32 27, i32* @$Chr
  br label %$18
$21:
  %29 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^J"))
  store i32 10, i32* @$Chr
  br label %$18
$22:
  %30 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^M"))
  store i32 13, i32* @$Chr
  br label %$18
$23:
  %31 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^I"))
  store i32 9, i32* @$Chr
  br label %$18
$17:
  %32 = phi i32 [%26, %$16] ; # Chr
; # (when (and (>= Chr (char "0")) (>= (char "9") Chr)) (dec 'Chr (ch...
; # (and (>= Chr (char "0")) (>= (char "9") Chr))
; # (>= Chr (char "0"))
  %33 = icmp sge i32 %32, 48
  br i1 %33, label %$25, label %$24
$25:
  %34 = phi i32 [%32, %$17] ; # Chr
; # (>= (char "9") Chr)
  %35 = icmp sge i32 57, %34
  br label %$24
$24:
  %36 = phi i32 [%32, %$17], [%34, %$25] ; # Chr
  %37 = phi i1 [0, %$17], [%35, %$25] ; # ->
  br i1 %37, label %$26, label %$27
$26:
  %38 = phi i32 [%36, %$24] ; # Chr
; # (dec 'Chr (char "0"))
  %39 = sub i32 %38, 48
; # (until (== (call $Get) (char "\\")) (unless (and (>= (val $Chr) (...
  br label %$28
$28:
  %40 = phi i32 [%39, %$26], [%57, %$34] ; # Chr
; # (call $Get)
  %41 = load i32()*, i32()** @$Get
  %42 = call i32 %41()
; # (== (call $Get) (char "\\"))
  %43 = icmp eq i32 %42, 92
  br i1 %43, label %$30, label %$29
$29:
  %44 = phi i32 [%40, %$28] ; # Chr
; # (unless (and (>= (val $Chr) (char "0")) (>= (char "9") (val $Chr)...
; # (and (>= (val $Chr) (char "0")) (>= (char "9") (val $Chr)))
; # (val $Chr)
  %45 = load i32, i32* @$Chr
; # (>= (val $Chr) (char "0"))
  %46 = icmp sge i32 %45, 48
  br i1 %46, label %$32, label %$31
$32:
  %47 = phi i32 [%44, %$29] ; # Chr
; # (val $Chr)
  %48 = load i32, i32* @$Chr
; # (>= (char "9") (val $Chr))
  %49 = icmp sge i32 57, %48
  br label %$31
$31:
  %50 = phi i32 [%44, %$29], [%47, %$32] ; # Chr
  %51 = phi i1 [0, %$29], [%49, %$32] ; # ->
  br i1 %51, label %$34, label %$33
$33:
  %52 = phi i32 [%50, %$31] ; # Chr
; # (badInput)
  call void @badInput()
  unreachable
$34:
  %53 = phi i32 [%50, %$31] ; # Chr
; # (* Chr 10)
  %54 = mul i32 %53, 10
; # (val $Chr)
  %55 = load i32, i32* @$Chr
; # (- (val $Chr) (char "0"))
  %56 = sub i32 %55, 48
; # (+ (* Chr 10) (- (val $Chr) (char "0")))
  %57 = add i32 %54, %56
  br label %$28
$30:
  %58 = phi i32 [%40, %$28] ; # Chr
  br label %$27
$27:
  %59 = phi i32 [%36, %$24], [%58, %$30] ; # Chr
; # (set $Chr Chr)
  store i32 %59, i32* @$Chr
  br label %$18
$18:
  %60 = phi i32 [%27, %$19], [%28, %$20], [%29, %$21], [%30, %$22], [%31, %$23], [%59, %$27] ; # Chr
  %61 = phi i32 [8, %$19], [27, %$20], [10, %$21], [13, %$22], [9, %$23], [%59, %$27] ; # ->
  br label %$4
$15:
  %62 = phi i32 [%24, %$13] ; # Chr
; # (loop (setq Chr (call $Get)) (? (and (<> Chr (char " ")) (<> Chr ...
  br label %$35
$35:
  %63 = phi i32 [%62, %$15], [%71, %$38] ; # Chr
; # (call $Get)
  %64 = load i32()*, i32()** @$Get
  %65 = call i32 %64()
; # (? (and (<> Chr (char " ")) (<> Chr (char "^I"))))
; # (and (<> Chr (char " ")) (<> Chr (char "^I")))
; # (<> Chr (char " "))
  %66 = icmp ne i32 %65, 32
  br i1 %66, label %$37, label %$36
$37:
  %67 = phi i32 [%65, %$35] ; # Chr
; # (<> Chr (char "^I"))
  %68 = icmp ne i32 %67, 9
  br label %$36
$36:
  %69 = phi i32 [%65, %$35], [%67, %$37] ; # Chr
  %70 = phi i1 [0, %$35], [%68, %$37] ; # ->
  br i1 %70, label %$39, label %$38
$38:
  %71 = phi i32 [%69, %$36] ; # Chr
  br label %$35
$39:
  %72 = phi i32 [%69, %$36] ; # Chr
  %73 = phi i64 [0, %$36] ; # ->
  br label %$2
$4:
  %74 = phi i32 [%3, %$5], [%16, %$12], [%20, %$14], [%60, %$18] ; # Chr
  %75 = phi i1 [0, %$5], [1, %$12], [1, %$14], [1, %$18] ; # ->
  ret i1 %75
}

define i64 @anonymous(i64) align 8 {
$1:
; # (let P (push 0 Nm) (unless (== (symByte P) (char "$")) (ret 0)) (...
; # (push 0 Nm)
  %1 = alloca i64, i64 2, align 16
  store i64 0, i64* %1
  %2 = getelementptr i64, i64* %1, i32 1
  store i64 %0, i64* %2
; # (unless (== (symByte P) (char "$")) (ret 0))
; # (symByte P)
  %3 = call i8 @symByte(i64* %1)
; # (== (symByte P) (char "$"))
  %4 = icmp eq i8 %3, 36
  br i1 %4, label %$3, label %$2
$2:
; # (ret 0)
  ret i64 0
$3:
; # (let B (- (symByte P) (char "0")) (unless (>= 7 B) (ret 0)) (let ...
; # (symByte P)
  %5 = call i8 @symByte(i64* %1)
; # (- (symByte P) (char "0"))
  %6 = sub i8 %5, 48
; # (unless (>= 7 B) (ret 0))
; # (>= 7 B)
  %7 = icmp uge i8 7, %6
  br i1 %7, label %$5, label %$4
$4:
; # (ret 0)
  ret i64 0
$5:
; # (let N (i64 B) (loop (? (=0 (symByte P)) (sym (shl N 4))) (? (> (...
; # (i64 B)
  %8 = zext i8 %6 to i64
; # (loop (? (=0 (symByte P)) (sym (shl N 4))) (? (> (- @ (char "0"))...
  br label %$6
$6:
  %9 = phi i64 [%8, %$5], [%22, %$10] ; # N
; # (? (=0 (symByte P)) (sym (shl N 4)))
; # (symByte P)
  %10 = call i8 @symByte(i64* %1)
; # (=0 (symByte P))
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %$9, label %$7
$9:
  %12 = phi i64 [%9, %$6] ; # N
; # (shl N 4)
  %13 = shl i64 %12, 4
; # (sym (shl N 4))
  %14 = or i64 %13, 8
  br label %$8
$7:
  %15 = phi i64 [%9, %$6] ; # N
; # (? (> (- @ (char "0")) 7) 0)
; # (- @ (char "0"))
  %16 = sub i8 %10, 48
; # (> (- @ (char "0")) 7)
  %17 = icmp ugt i8 %16, 7
  br i1 %17, label %$11, label %$10
$11:
  %18 = phi i64 [%15, %$7] ; # N
  br label %$8
$10:
  %19 = phi i64 [%15, %$7] ; # N
; # (i64 @)
  %20 = zext i8 %16 to i64
; # (shl N 3)
  %21 = shl i64 %19, 3
; # (| (i64 @) (shl N 3))
  %22 = or i64 %20, %21
  br label %$6
$8:
  %23 = phi i64 [%12, %$9], [%18, %$11] ; # N
  %24 = phi i64 [%14, %$9], [0, %$11] ; # ->
  ret i64 %24
}

define i64 @rdAtom(i32) align 8 {
$1:
; # (let (Int (save (val $Intern)) P (push 4 NIL ZERO NIL) C (val $Ch...
; # (val $Intern)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %2 = load i64, i64* %1
; # (save (val $Intern))
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %2, i64* %7
  %8 = add i64 %6, 8
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %10
; # (push 4 NIL ZERO NIL)
  %11 = alloca i64, i64 4, align 16
  store i64 4, i64* %11
  %12 = getelementptr i64, i64* %11, i32 2
  store i64 2, i64* %12
; # (val $Chr)
  %13 = load i32, i32* @$Chr
; # (when (and (== Chr (char "%")) (== C (char "~"))) (when (nil? (cd...
; # (and (== Chr (char "%")) (== C (char "~")))
; # (== Chr (char "%"))
  %14 = icmp eq i32 %0, 37
  br i1 %14, label %$3, label %$2
$3:
  %15 = phi i32 [%0, %$1] ; # Chr
  %16 = phi i32 [%13, %$1] ; # C
; # (== C (char "~"))
  %17 = icmp eq i32 %16, 126
  br label %$2
$2:
  %18 = phi i32 [%0, %$1], [%15, %$3] ; # Chr
  %19 = phi i32 [%13, %$1], [%16, %$3] ; # C
  %20 = phi i1 [0, %$1], [%17, %$3] ; # ->
  br i1 %20, label %$4, label %$5
$4:
  %21 = phi i32 [%18, %$2] ; # Chr
  %22 = phi i32 [%19, %$2] ; # C
; # (when (nil? (cdr Int)) (symNspErr 0 $rem))
; # (cdr Int)
  %23 = inttoptr i64 %2 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (nil? (cdr Int))
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %26, label %$6, label %$7
$6:
  %27 = phi i32 [%21, %$4] ; # Chr
  %28 = phi i32 [%22, %$4] ; # C
; # (symNspErr 0 $rem)
  call void @symNspErr(i64 0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 1016) to i64))
  unreachable
$7:
  %29 = phi i32 [%21, %$4] ; # Chr
  %30 = phi i32 [%22, %$4] ; # C
; # (set $Intern @)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %31
; # (call $Get)
  %32 = load i32()*, i32()** @$Get
  %33 = call i32 %32()
; # (call $Get)
  %34 = load i32()*, i32()** @$Get
  %35 = call i32 %34()
  br label %$5
$5:
  %36 = phi i32 [%18, %$2], [%33, %$7] ; # Chr
  %37 = phi i32 [%19, %$2], [%35, %$7] ; # C
; # (ofs P 2)
  %38 = getelementptr i64, i64* %11, i32 2
; # (link (ofs P 2))
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = inttoptr i64 %39 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  store i64 %41, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %44
; # (i8 Chr)
  %45 = trunc i32 %36 to i8
; # (byteSym (i8 Chr) P)
  call void @byteSym(i8 %45, i64* %11)
; # (while (ge0 Chr) (if (== Chr (char "~")) (let S (requestSym (val ...
  br label %$8
$8:
  %46 = phi i32 [%37, %$5], [%86, %$13] ; # Chr
  %47 = phi i32 [%37, %$5], [%84, %$13] ; # C
; # (ge0 Chr)
  %48 = icmp sge i32 %46, 0
  br i1 %48, label %$9, label %$10
$9:
  %49 = phi i32 [%46, %$8] ; # Chr
  %50 = phi i32 [%47, %$8] ; # C
; # (if (== Chr (char "~")) (let S (requestSym (val 3 P)) (needNsp 0 ...
; # (== Chr (char "~"))
  %51 = icmp eq i32 %49, 126
  br i1 %51, label %$11, label %$12
$11:
  %52 = phi i32 [%49, %$9] ; # Chr
  %53 = phi i32 [%50, %$9] ; # C
; # (let S (requestSym (val 3 P)) (needNsp 0 S) (set (set $Intern (an...
; # (val 3 P)
  %54 = getelementptr i64, i64* %11, i32 2
  %55 = load i64, i64* %54
; # (requestSym (val 3 P))
  %56 = call i64 @requestSym(i64 %55)
; # (needNsp 0 S)
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$15, label %$14
$15:
  %61 = inttoptr i64 %58 to i64*
  %62 = load i64, i64* %61
  %63 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 40) to i64), %62
  br label %$14
$14:
  %64 = phi i1 [0, %$11], [%63, %$15] ; # ->
  br i1 %64, label %$17, label %$16
$16:
  call void @symNspErr(i64 0, i64 %56)
  unreachable
$17:
; # (set (set $Intern (any $Cell)) S)
; # (set $Intern (any $Cell))
; # (any $Cell)
  %65 = ptrtoint i64* bitcast ([2 x i64]* @$Cell to i64*) to i64
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %66
  %67 = inttoptr i64 %65 to i64*
  store i64 %56, i64* %67
; # (set P 4 3 P ZERO)
  store i64 4, i64* %11
  %68 = getelementptr i64, i64* %11, i32 2
  store i64 2, i64* %68
  br label %$13
$12:
  %69 = phi i32 [%49, %$9] ; # Chr
  %70 = phi i32 [%50, %$9] ; # C
; # (? (strchr $Delim Chr))
; # (strchr $Delim Chr)
  %71 = call i8* @strchr(i8* bitcast ([16 x i8]* @$Delim to i8*), i32 %69)
  %72 = icmp ne i8* %71, null
  br i1 %72, label %$10, label %$18
$18:
  %73 = phi i32 [%69, %$12] ; # Chr
  %74 = phi i32 [%70, %$12] ; # C
; # (when (== Chr (char "\\")) (setq Chr (call $Get)))
; # (== Chr (char "\\"))
  %75 = icmp eq i32 %73, 92
  br i1 %75, label %$19, label %$20
$19:
  %76 = phi i32 [%73, %$18] ; # Chr
  %77 = phi i32 [%74, %$18] ; # C
; # (call $Get)
  %78 = load i32()*, i32()** @$Get
  %79 = call i32 %78()
  br label %$20
$20:
  %80 = phi i32 [%73, %$18], [%79, %$19] ; # Chr
  %81 = phi i32 [%74, %$18], [%77, %$19] ; # C
; # (i8 Chr)
  %82 = trunc i32 %80 to i8
; # (byteSym (i8 Chr) P)
  call void @byteSym(i8 %82, i64* %11)
  br label %$13
$13:
  %83 = phi i32 [%52, %$17], [%80, %$20] ; # Chr
  %84 = phi i32 [%53, %$17], [%81, %$20] ; # C
; # (call $Get)
  %85 = load i32()*, i32()** @$Get
  %86 = call i32 %85()
  br label %$8
$10:
  %87 = phi i32 [%46, %$8], [%69, %$12] ; # Chr
  %88 = phi i32 [%47, %$8], [%70, %$12] ; # C
; # (prog1 (let (Nm (val 3 P) L (val $Intern)) (cond ((== Nm ZERO) (b...
; # (let (Nm (val 3 P) L (val $Intern)) (cond ((== Nm ZERO) (badInput...
; # (val 3 P)
  %89 = getelementptr i64, i64* %11, i32 2
  %90 = load i64, i64* %89
; # (val $Intern)
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %92 = load i64, i64* %91
; # (cond ((== Nm ZERO) (badInput)) ((== L (any $Cell)) (intern 0 $Ni...
; # (== Nm ZERO)
  %93 = icmp eq i64 %90, 2
  br i1 %93, label %$23, label %$22
$23:
  %94 = phi i32 [%87, %$10] ; # Chr
  %95 = phi i32 [%88, %$10] ; # C
; # (badInput)
  call void @badInput()
  unreachable
$22:
  %96 = phi i32 [%87, %$10] ; # Chr
  %97 = phi i32 [%88, %$10] ; # C
; # (any $Cell)
  %98 = ptrtoint i64* bitcast ([2 x i64]* @$Cell to i64*) to i64
; # (== L (any $Cell))
  %99 = icmp eq i64 %92, %98
  br i1 %99, label %$25, label %$24
$25:
  %100 = phi i32 [%96, %$22] ; # Chr
  %101 = phi i32 [%97, %$22] ; # C
; # (car @)
  %102 = inttoptr i64 %92 to i64*
  %103 = load i64, i64* %102
; # (cdar (car @))
  %104 = inttoptr i64 %103 to i64*
  %105 = load i64, i64* %104
  %106 = inttoptr i64 %105 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
; # (intern 0 $Nil Nm (cdar (car @)) $Nil NO)
  %109 = call i64 @intern(i64 0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %90, i64 %108, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i1 0)
  br label %$21
$24:
  %110 = phi i32 [%96, %$22] ; # Chr
  %111 = phi i32 [%97, %$22] ; # C
; # (val $Scl)
  %112 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  %113 = load i64, i64* %112
; # (int (val $Scl))
  %114 = lshr i64 %113, 4
; # (symToNum Nm (int (val $Scl)) (char ".") 0)
  %115 = call i64 @symToNum(i64 %90, i64 %114, i8 46, i8 0)
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$27, label %$26
$27:
  %117 = phi i32 [%110, %$24] ; # Chr
  %118 = phi i32 [%111, %$24] ; # C
  br label %$21
$26:
  %119 = phi i32 [%110, %$24] ; # Chr
  %120 = phi i32 [%111, %$24] ; # C
; # (anonymous Nm)
  %121 = call i64 @anonymous(i64 %90)
  %122 = icmp ne i64 %121, 0
  br i1 %122, label %$29, label %$28
$29:
  %123 = phi i32 [%119, %$26] ; # Chr
  %124 = phi i32 [%120, %$26] ; # C
  br label %$21
$28:
  %125 = phi i32 [%119, %$26] ; # Chr
  %126 = phi i32 [%120, %$26] ; # C
; # (and (== (car L) $priv) (nil? (cdr L)))
; # (car L)
  %127 = inttoptr i64 %92 to i64*
  %128 = load i64, i64* %127
; # (== (car L) $priv)
  %129 = icmp eq i64 %128, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 152) to i64)
  br i1 %129, label %$31, label %$30
$31:
  %130 = phi i32 [%125, %$28] ; # Chr
  %131 = phi i32 [%126, %$28] ; # C
; # (cdr L)
  %132 = inttoptr i64 %92 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
; # (nil? (cdr L))
  %135 = icmp eq i64 %134, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$30
$30:
  %136 = phi i32 [%125, %$28], [%130, %$31] ; # Chr
  %137 = phi i32 [%126, %$28], [%131, %$31] ; # C
  %138 = phi i1 [0, %$28], [%135, %$31] ; # ->
  br i1 %138, label %$33, label %$32
$33:
  %139 = phi i32 [%136, %$30] ; # Chr
  %140 = phi i32 [%137, %$30] ; # C
; # (consSym Nm $Nil)
  %141 = call i64 @consSym(i64 %90, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (intern (consSym Nm $Nil) 0 Nm $PrivT $Nil YES)
  %142 = call i64 @intern(i64 %141, i64 0, i64 %90, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i1 1)
  br label %$21
$32:
  %143 = phi i32 [%136, %$30] ; # Chr
  %144 = phi i32 [%137, %$30] ; # C
; # (requestSym Nm)
  %145 = call i64 @requestSym(i64 %90)
  br label %$21
$21:
  %146 = phi i32 [%100, %$25], [%117, %$27], [%123, %$29], [%139, %$33], [%143, %$32] ; # Chr
  %147 = phi i32 [%101, %$25], [%118, %$27], [%124, %$29], [%140, %$33], [%144, %$32] ; # C
  %148 = phi i64 [%109, %$25], [%115, %$27], [%121, %$29], [%142, %$33], [%145, %$32] ; # ->
; # (set $Intern Int)
  %149 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %2, i64* %149
; # (drop *Safe)
  %150 = inttoptr i64 %6 to i64*
  %151 = getelementptr i64, i64* %150, i32 1
  %152 = load i64, i64* %151
  %153 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %152, i64* %153
  ret i64 %148
}

define void @rdl(i64, i64) align 8 {
$1:
; # (loop (? (== (skip) (char ")")) (call $Get)) (? (== @ (char "]"))...
  br label %$2
$2:
  %2 = phi i64 [%1, %$1], [%105, %$7] ; # P
; # (? (== (skip) (char ")")) (call $Get))
; # (skip)
  %3 = call i32 @skip()
; # (== (skip) (char ")"))
  %4 = icmp eq i32 %3, 41
  br i1 %4, label %$5, label %$3
$5:
  %5 = phi i64 [%2, %$2] ; # P
; # (call $Get)
  %6 = load i32()*, i32()** @$Get
  %7 = call i32 %6()
  br label %$4
$3:
  %8 = phi i64 [%2, %$2] ; # P
; # (? (== @ (char "]")))
; # (== @ (char "]"))
  %9 = icmp eq i32 %3, 93
  br i1 %9, label %$4, label %$6
$6:
  %10 = phi i64 [%8, %$3] ; # P
; # (cond ((== @ (char ".")) (? (strchr $Delim (call $Get)) (setq P (...
; # (== @ (char "."))
  %11 = icmp eq i32 %3, 46
  br i1 %11, label %$9, label %$8
$9:
  %12 = phi i64 [%10, %$6] ; # P
; # (? (strchr $Delim (call $Get)) (setq P (set 2 P (if (or (== (skip...
; # (call $Get)
  %13 = load i32()*, i32()** @$Get
  %14 = call i32 %13()
; # (strchr $Delim (call $Get))
  %15 = call i8* @strchr(i8* bitcast ([16 x i8]* @$Delim to i8*), i32 %14)
  %16 = icmp ne i8* %15, null
  br i1 %16, label %$11, label %$10
$11:
  %17 = phi i64 [%12, %$9] ; # P
; # (set 2 P (if (or (== (skip) (char ")")) (== @ (char "]"))) R (rea...
; # (if (or (== (skip) (char ")")) (== @ (char "]"))) R (read0 NO))
; # (or (== (skip) (char ")")) (== @ (char "]")))
; # (skip)
  %18 = call i32 @skip()
; # (== (skip) (char ")"))
  %19 = icmp eq i32 %18, 41
  br i1 %19, label %$12, label %$13
$13:
  %20 = phi i64 [%17, %$11] ; # P
; # (== @ (char "]"))
  %21 = icmp eq i32 %18, 93
  br label %$12
$12:
  %22 = phi i64 [%17, %$11], [%20, %$13] ; # P
  %23 = phi i1 [1, %$11], [%21, %$13] ; # ->
  br i1 %23, label %$14, label %$15
$14:
  %24 = phi i64 [%22, %$12] ; # P
  br label %$16
$15:
  %25 = phi i64 [%22, %$12] ; # P
; # (read0 NO)
  %26 = call i64 @read0(i1 0)
  br label %$16
$16:
  %27 = phi i64 [%24, %$14], [%25, %$15] ; # P
  %28 = phi i64 [%0, %$14], [%26, %$15] ; # ->
  %29 = inttoptr i64 %17 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
; # (cond ((== (skip) (char ")")) (call $Get)) ((<> (val $Chr) (char ...
; # (skip)
  %31 = call i32 @skip()
; # (== (skip) (char ")"))
  %32 = icmp eq i32 %31, 41
  br i1 %32, label %$19, label %$18
$19:
  %33 = phi i64 [%28, %$16] ; # P
; # (call $Get)
  %34 = load i32()*, i32()** @$Get
  %35 = call i32 %34()
  br label %$17
$18:
  %36 = phi i64 [%28, %$16] ; # P
; # (val $Chr)
  %37 = load i32, i32* @$Chr
; # (<> (val $Chr) (char "]"))
  %38 = icmp ne i32 %37, 93
  br i1 %38, label %$21, label %$20
$21:
  %39 = phi i64 [%36, %$18] ; # P
; # (err 0 P ($ "Bad dotted pair") null)
  call void @err(i64 0, i64 %39, i8* bitcast ([16 x i8]* @$42 to i8*), i8* null)
  unreachable
$20:
  %40 = phi i64 [%36, %$18] ; # P
  br label %$17
$17:
  %41 = phi i64 [%33, %$19], [%40, %$20] ; # P
  %42 = phi i32 [%35, %$19], [0, %$20] ; # ->
  br label %$4
$10:
  %43 = phi i64 [%12, %$9] ; # P
; # (set 2 P (cons (rdAtom (char ".")) $Nil))
; # (rdAtom (char "."))
  %44 = call i64 @rdAtom(i32 46)
; # (cons (rdAtom (char ".")) $Nil)
  %45 = call i64 @cons(i64 %44, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %46 = inttoptr i64 %43 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  br label %$7
$8:
  %48 = phi i64 [%10, %$6] ; # P
; # (== @ (char "~"))
  %49 = icmp eq i32 %3, 126
  br i1 %49, label %$23, label %$22
$23:
  %50 = phi i64 [%48, %$8] ; # P
; # (call $Get)
  %51 = load i32()*, i32()** @$Get
  %52 = call i32 %51()
; # (let (X (save (read0 NO)) R (eval X)) (cond ((nil? R)) ((atom R) ...
; # (read0 NO)
  %53 = call i64 @read0(i1 0)
; # (save (read0 NO))
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %53, i64* %58
  %59 = add i64 %57, 8
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %61
; # (eval X)
  %62 = and i64 %53, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$26, label %$25
$26:
  br label %$24
$25:
  %64 = and i64 %53, 8
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$28, label %$27
$28:
  %66 = inttoptr i64 %53 to i64*
  %67 = load i64, i64* %66
  br label %$24
$27:
  %68 = call i64 @evList(i64 %53)
  br label %$24
$24:
  %69 = phi i64 [%53, %$26], [%67, %$28], [%68, %$27] ; # ->
; # (cond ((nil? R)) ((atom R) (set 2 P (cons R $Nil)) (shift P)) (T ...
; # (nil? R)
  %70 = icmp eq i64 %69, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %70, label %$29, label %$30
$30:
  %71 = phi i64 [%50, %$24] ; # P
; # (atom R)
  %72 = and i64 %69, 15
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$32, label %$31
$32:
  %74 = phi i64 [%71, %$30] ; # P
; # (set 2 P (cons R $Nil))
; # (cons R $Nil)
  %75 = call i64 @cons(i64 %69, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %76 = inttoptr i64 %74 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  store i64 %75, i64* %77
; # (shift P)
  %78 = inttoptr i64 %74 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  %80 = load i64, i64* %79
  br label %$29
$31:
  %81 = phi i64 [%71, %$30] ; # P
; # (set 2 P R)
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  store i64 %69, i64* %83
; # (while (pair (cdr P)) (shift P))
  br label %$33
$33:
  %84 = phi i64 [%81, %$31], [%93, %$34] ; # P
; # (cdr P)
  %85 = inttoptr i64 %84 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  %87 = load i64, i64* %86
; # (pair (cdr P))
  %88 = and i64 %87, 15
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %$34, label %$35
$34:
  %90 = phi i64 [%84, %$33] ; # P
; # (shift P)
  %91 = inttoptr i64 %90 to i64*
  %92 = getelementptr i64, i64* %91, i32 1
  %93 = load i64, i64* %92
  br label %$33
$35:
  %94 = phi i64 [%84, %$33] ; # P
  br label %$29
$29:
  %95 = phi i64 [%50, %$24], [%80, %$32], [%94, %$35] ; # P
; # (drop *Safe)
  %96 = inttoptr i64 %57 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  %98 = load i64, i64* %97
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %98, i64* %99
  br label %$7
$22:
  %100 = phi i64 [%48, %$8] ; # P
; # (set 2 P (cons (read0 NO) $Nil))
; # (read0 NO)
  %101 = call i64 @read0(i1 0)
; # (cons (read0 NO) $Nil)
  %102 = call i64 @cons(i64 %101, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %103 = inttoptr i64 %100 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  store i64 %102, i64* %104
  br label %$7
$7:
  %105 = phi i64 [%45, %$10], [%95, %$29], [%102, %$22] ; # P
  %106 = phi i64 [%45, %$10], [%95, %$29], [%102, %$22] ; # ->
  br label %$2
$4:
  %107 = phi i64 [%5, %$5], [%8, %$3], [%41, %$17] ; # P
  ret void
}

define i64 @rdList() align 8 {
$1:
; # (stkChk 0)
  %0 = load i8*, i8** @$StkLimit
  %1 = call i8* @llvm.stacksave()
  %2 = icmp ugt i8* %0, %1
  br i1 %2, label %$2, label %$3
$2:
  call void @stkErr(i64 0)
  unreachable
$3:
; # (call $Get)
  %3 = load i32()*, i32()** @$Get
  %4 = call i32 %3()
; # (loop (? (== (skip) (char ")")) (call $Get) $Nil) (? (== @ (char ...
  br label %$4
$4:
; # (? (== (skip) (char ")")) (call $Get) $Nil)
; # (skip)
  %5 = call i32 @skip()
; # (== (skip) (char ")"))
  %6 = icmp eq i32 %5, 41
  br i1 %6, label %$7, label %$5
$7:
; # (call $Get)
  %7 = load i32()*, i32()** @$Get
  %8 = call i32 %7()
  br label %$6
$5:
; # (? (== @ (char "]")) $Nil)
; # (== @ (char "]"))
  %9 = icmp eq i32 %5, 93
  br i1 %9, label %$9, label %$8
$9:
  br label %$6
$8:
; # (? (<> @ (char "~")) (let R (save (cons (read0 NO) $Nil)) (rdl R ...
; # (<> @ (char "~"))
  %10 = icmp ne i32 %5, 126
  br i1 %10, label %$11, label %$10
$11:
; # (let R (save (cons (read0 NO) $Nil)) (rdl R R) R)
; # (read0 NO)
  %11 = call i64 @read0(i1 0)
; # (cons (read0 NO) $Nil)
  %12 = call i64 @cons(i64 %11, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons (read0 NO) $Nil))
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %14 = load i64, i64* %13
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %12, i64* %17
  %18 = add i64 %16, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %20
; # (rdl R R)
  call void @rdl(i64 %12, i64 %12)
; # (drop *Safe)
  %21 = inttoptr i64 %16 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %24
  br label %$6
$10:
; # (call $Get)
  %25 = load i32()*, i32()** @$Get
  %26 = call i32 %25()
; # (let (X (save (read0 NO)) R (eval X)) (? (not (nil? R)) (if (atom...
; # (read0 NO)
  %27 = call i64 @read0(i1 0)
; # (save (read0 NO))
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %27, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %29, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
; # (eval X)
  %36 = and i64 %27, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  br label %$12
$13:
  %38 = and i64 %27, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$16, label %$15
$16:
  %40 = inttoptr i64 %27 to i64*
  %41 = load i64, i64* %40
  br label %$12
$15:
  %42 = call i64 @evList(i64 %27)
  br label %$12
$12:
  %43 = phi i64 [%27, %$14], [%41, %$16], [%42, %$15] ; # ->
; # (? (not (nil? R)) (if (atom (safe R)) (rdl (safe (setq R (cons R ...
; # (nil? R)
  %44 = icmp eq i64 %43, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? R))
  %45 = icmp eq i1 %44, 0
  br i1 %45, label %$18, label %$17
$18:
  %46 = phi i64 [%43, %$12] ; # R
; # (if (atom (safe R)) (rdl (safe (setq R (cons R $Nil))) R) (let L ...
; # (safe R)
  %47 = inttoptr i64 %31 to i64*
  store i64 %46, i64* %47
; # (atom (safe R))
  %48 = and i64 %46, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$19, label %$20
$19:
  %50 = phi i64 [%46, %$18] ; # R
; # (cons R $Nil)
  %51 = call i64 @cons(i64 %50, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (safe (setq R (cons R $Nil)))
  %52 = inttoptr i64 %31 to i64*
  store i64 %51, i64* %52
; # (rdl (safe (setq R (cons R $Nil))) R)
  call void @rdl(i64 %51, i64 %51)
  br label %$21
$20:
  %53 = phi i64 [%46, %$18] ; # R
; # (let L R (while (pair (cdr L)) (setq L @)) (rdl R L))
; # (while (pair (cdr L)) (setq L @))
  br label %$22
$22:
  %54 = phi i64 [%53, %$20], [%61, %$23] ; # R
  %55 = phi i64 [%53, %$20], [%58, %$23] ; # L
; # (cdr L)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (pair (cdr L))
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$23, label %$24
$23:
  %61 = phi i64 [%54, %$22] ; # R
  %62 = phi i64 [%55, %$22] ; # L
  br label %$22
$24:
  %63 = phi i64 [%54, %$22] ; # R
  %64 = phi i64 [%55, %$22] ; # L
; # (rdl R L)
  call void @rdl(i64 %63, i64 %64)
  br label %$21
$21:
  %65 = phi i64 [%51, %$19], [%63, %$24] ; # R
  br label %$6
$17:
  %66 = phi i64 [%43, %$12] ; # R
; # (drop *Safe)
  %67 = inttoptr i64 %31 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %69, i64* %70
  br label %$4
$6:
  %71 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%12, %$11], [%65, %$21] ; # ->
  ret i64 %71
}

define i64 @read0(i1) align 8 {
$1:
; # (let C (skip) (when Top (let In: (inFile (val $InFile)) (In: src ...
; # (skip)
  %1 = call i32 @skip()
; # (when Top (let In: (inFile (val $InFile)) (In: src (In: line))))
  br i1 %0, label %$2, label %$3
$2:
  %2 = phi i32 [%1, %$1] ; # C
; # (let In: (inFile (val $InFile)) (In: src (In: line)))
; # (val $InFile)
  %3 = load i8*, i8** @$InFile
; # (In: src (In: line))
  %4 = getelementptr i8, i8* %3, i32 20
  %5 = bitcast i8* %4 to i32*
  %6 = getelementptr i8, i8* %3, i32 16
  %7 = bitcast i8* %6 to i32*
  %8 = load i32, i32* %7
  store i32 %8, i32* %5
  br label %$3
$3:
  %9 = phi i32 [%1, %$1], [%2, %$2] ; # C
; # (cond ((lt0 C) (unless Top (eofErr)) $Nil) ((== C (char "(")) (pr...
; # (lt0 C)
  %10 = icmp slt i32 %9, 0
  br i1 %10, label %$6, label %$5
$6:
  %11 = phi i32 [%9, %$3] ; # C
; # (unless Top (eofErr))
  br i1 %0, label %$8, label %$7
$7:
  %12 = phi i32 [%11, %$6] ; # C
; # (eofErr)
  call void @eofErr()
  unreachable
$8:
  %13 = phi i32 [%11, %$6] ; # C
  br label %$4
$5:
  %14 = phi i32 [%9, %$3] ; # C
; # (== C (char "("))
  %15 = icmp eq i32 %14, 40
  br i1 %15, label %$10, label %$9
$10:
  %16 = phi i32 [%14, %$5] ; # C
; # (prog1 (rdList) (and Top (== (val $Chr) (char "]")) (call $Get)))...
; # (rdList)
  %17 = call i64 @rdList()
; # (and Top (== (val $Chr) (char "]")) (call $Get))
  br i1 %0, label %$12, label %$11
$12:
  %18 = phi i32 [%16, %$10] ; # C
; # (val $Chr)
  %19 = load i32, i32* @$Chr
; # (== (val $Chr) (char "]"))
  %20 = icmp eq i32 %19, 93
  br i1 %20, label %$13, label %$11
$13:
  %21 = phi i32 [%18, %$12] ; # C
; # (call $Get)
  %22 = load i32()*, i32()** @$Get
  %23 = call i32 %22()
  %24 = icmp ne i32 %23, 0
  br label %$11
$11:
  %25 = phi i32 [%16, %$10], [%18, %$12], [%21, %$13] ; # C
  %26 = phi i1 [0, %$10], [0, %$12], [%24, %$13] ; # ->
  br label %$4
$9:
  %27 = phi i32 [%14, %$5] ; # C
; # (== C (char "["))
  %28 = icmp eq i32 %27, 91
  br i1 %28, label %$15, label %$14
$15:
  %29 = phi i32 [%27, %$9] ; # C
; # (let X (rdList) (unless (== (val $Chr) (char "]")) (err 0 X ($ "S...
; # (rdList)
  %30 = call i64 @rdList()
; # (unless (== (val $Chr) (char "]")) (err 0 X ($ "Super parentheses...
; # (val $Chr)
  %31 = load i32, i32* @$Chr
; # (== (val $Chr) (char "]"))
  %32 = icmp eq i32 %31, 93
  br i1 %32, label %$17, label %$16
$16:
  %33 = phi i32 [%29, %$15] ; # C
; # (err 0 X ($ "Super parentheses mismatch") null)
  call void @err(i64 0, i64 %30, i8* bitcast ([27 x i8]* @$43 to i8*), i8* null)
  unreachable
$17:
  %34 = phi i32 [%29, %$15] ; # C
; # (call $Get)
  %35 = load i32()*, i32()** @$Get
  %36 = call i32 %35()
  br label %$4
$14:
  %37 = phi i32 [%27, %$9] ; # C
; # (== C (char "'"))
  %38 = icmp eq i32 %37, 39
  br i1 %38, label %$19, label %$18
$19:
  %39 = phi i32 [%37, %$14] ; # C
; # (call $Get)
  %40 = load i32()*, i32()** @$Get
  %41 = call i32 %40()
; # (read0 Top)
  %42 = call i64 @read0(i1 %0)
; # (cons $Quote (read0 Top))
  %43 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 264) to i64), i64 %42)
  br label %$4
$18:
  %44 = phi i32 [%37, %$14] ; # C
; # (== C (char ","))
  %45 = icmp eq i32 %44, 44
  br i1 %45, label %$21, label %$20
$21:
  %46 = phi i32 [%44, %$18] ; # C
; # (call $Get)
  %47 = load i32()*, i32()** @$Get
  %48 = call i32 %47()
; # (let (Tr1 (save (val $Transient)) Tr2 (save (val 2 $Transient))) ...
; # (val $Transient)
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %50 = load i64, i64* %49
; # (save (val $Transient))
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %52 = load i64, i64* %51
  %53 = alloca i64, i64 2, align 16
  %54 = ptrtoint i64* %53 to i64
  %55 = inttoptr i64 %54 to i64*
  store i64 %50, i64* %55
  %56 = add i64 %54, 8
  %57 = inttoptr i64 %56 to i64*
  store i64 %52, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %58
; # (val 2 $Transient)
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
; # (save (val 2 $Transient))
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %63 = load i64, i64* %62
  %64 = alloca i64, i64 2, align 16
  %65 = ptrtoint i64* %64 to i64
  %66 = inttoptr i64 %65 to i64*
  store i64 %61, i64* %66
  %67 = add i64 %65, 8
  %68 = inttoptr i64 %67 to i64*
  store i64 %63, i64* %68
  %69 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %69
; # (set $Transient (set 2 $Transient $Nil))
; # (set 2 $Transient $Nil)
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %71
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %72
; # (prog1 (let X (read0 Top) (if (t? (val $Uni)) X (save X (if (pair...
; # (let X (read0 Top) (if (t? (val $Uni)) X (save X (if (pair (idxPu...
; # (read0 Top)
  %73 = call i64 @read0(i1 %0)
; # (if (t? (val $Uni)) X (save X (if (pair (idxPut $Uni X)) (car @) ...
; # (val $Uni)
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 776) to i64) to i64*
  %75 = load i64, i64* %74
; # (t? (val $Uni))
  %76 = icmp eq i64 %75, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %76, label %$22, label %$23
$22:
  %77 = phi i32 [%46, %$21] ; # C
  br label %$24
$23:
  %78 = phi i32 [%46, %$21] ; # C
; # (save X (if (pair (idxPut $Uni X)) (car @) X))
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %80 = load i64, i64* %79
  %81 = alloca i64, i64 2, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = inttoptr i64 %82 to i64*
  store i64 %73, i64* %83
  %84 = add i64 %82, 8
  %85 = inttoptr i64 %84 to i64*
  store i64 %80, i64* %85
  %86 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %82, i64* %86
; # (if (pair (idxPut $Uni X)) (car @) X)
; # (idxPut $Uni X)
  %87 = call i64 @idxPut(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 776) to i64), i64 %73)
; # (pair (idxPut $Uni X))
  %88 = and i64 %87, 15
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %$25, label %$26
$25:
  %90 = phi i32 [%78, %$23] ; # C
; # (car @)
  %91 = inttoptr i64 %87 to i64*
  %92 = load i64, i64* %91
  br label %$27
$26:
  %93 = phi i32 [%78, %$23] ; # C
  br label %$27
$27:
  %94 = phi i32 [%90, %$25], [%93, %$26] ; # C
  %95 = phi i64 [%92, %$25], [%73, %$26] ; # ->
; # drop
  %96 = inttoptr i64 %82 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  %98 = load i64, i64* %97
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %98, i64* %99
  br label %$24
$24:
  %100 = phi i32 [%77, %$22], [%94, %$27] ; # C
  %101 = phi i64 [%73, %$22], [%95, %$27] ; # ->
; # (set 2 $Transient Tr2)
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  store i64 %61, i64* %103
; # (set $Transient Tr1)
  %104 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  store i64 %50, i64* %104
; # (drop *Safe)
  %105 = inttoptr i64 %54 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %108
  br label %$4
$20:
  %109 = phi i32 [%44, %$18] ; # C
; # (== C (char "`"))
  %110 = icmp eq i32 %109, 96
  br i1 %110, label %$29, label %$28
$29:
  %111 = phi i32 [%109, %$20] ; # C
; # (call $Get)
  %112 = load i32()*, i32()** @$Get
  %113 = call i32 %112()
; # (let E (read0 Top) (save E (eval E)))
; # (read0 Top)
  %114 = call i64 @read0(i1 %0)
; # (save E (eval E))
  %115 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %116 = load i64, i64* %115
  %117 = alloca i64, i64 2, align 16
  %118 = ptrtoint i64* %117 to i64
  %119 = inttoptr i64 %118 to i64*
  store i64 %114, i64* %119
  %120 = add i64 %118, 8
  %121 = inttoptr i64 %120 to i64*
  store i64 %116, i64* %121
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %118, i64* %122
; # (eval E)
  %123 = and i64 %114, 6
  %124 = icmp ne i64 %123, 0
  br i1 %124, label %$32, label %$31
$32:
  br label %$30
$31:
  %125 = and i64 %114, 8
  %126 = icmp ne i64 %125, 0
  br i1 %126, label %$34, label %$33
$34:
  %127 = inttoptr i64 %114 to i64*
  %128 = load i64, i64* %127
  br label %$30
$33:
  %129 = call i64 @evList(i64 %114)
  br label %$30
$30:
  %130 = phi i64 [%114, %$32], [%128, %$34], [%129, %$33] ; # ->
; # drop
  %131 = inttoptr i64 %118 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  %133 = load i64, i64* %132
  %134 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %133, i64* %134
  br label %$4
$28:
  %135 = phi i32 [%109, %$20] ; # C
; # (== C (char "\""))
  %136 = icmp eq i32 %135, 34
  br i1 %136, label %$36, label %$35
$36:
  %137 = phi i32 [%135, %$28] ; # C
; # (if (== (setq C (call $Get)) (char "\"")) (prog (call $Get) $Nil)...
; # (call $Get)
  %138 = load i32()*, i32()** @$Get
  %139 = call i32 %138()
; # (== (setq C (call $Get)) (char "\""))
  %140 = icmp eq i32 %139, 34
  br i1 %140, label %$37, label %$38
$37:
  %141 = phi i32 [%139, %$36] ; # C
; # (call $Get)
  %142 = load i32()*, i32()** @$Get
  %143 = call i32 %142()
  br label %$39
$38:
  %144 = phi i32 [%139, %$36] ; # C
; # (unless (testEsc C) (eofErr))
; # (testEsc C)
  %145 = call i1 @testEsc(i32 %144)
  br i1 %145, label %$41, label %$40
$40:
  %146 = phi i32 [%144, %$38] ; # C
; # (eofErr)
  call void @eofErr()
  unreachable
$41:
  %147 = phi i32 [%144, %$38] ; # C
; # (let (P (push 4 NIL ZERO NIL) Q (link (ofs P 2))) (loop (charSym ...
; # (push 4 NIL ZERO NIL)
  %148 = alloca i64, i64 4, align 16
  store i64 4, i64* %148
  %149 = getelementptr i64, i64* %148, i32 2
  store i64 2, i64* %149
; # (ofs P 2)
  %150 = getelementptr i64, i64* %148, i32 2
; # (link (ofs P 2))
  %151 = ptrtoint i64* %150 to i64
  %152 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %153 = load i64, i64* %152
  %154 = inttoptr i64 %151 to i64*
  %155 = getelementptr i64, i64* %154, i32 1
  store i64 %153, i64* %155
  %156 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %151, i64* %156
; # (loop (charSym (val $Chr) P) (? (== (setq C (call $Get)) (char "\...
  br label %$42
$42:
  %157 = phi i32 [%147, %$41], [%165, %$46] ; # C
; # (val $Chr)
  %158 = load i32, i32* @$Chr
; # (charSym (val $Chr) P)
  call void @charSym(i32 %158, i64* %148)
; # (? (== (setq C (call $Get)) (char "\"")))
; # (call $Get)
  %159 = load i32()*, i32()** @$Get
  %160 = call i32 %159()
; # (== (setq C (call $Get)) (char "\""))
  %161 = icmp eq i32 %160, 34
  br i1 %161, label %$44, label %$43
$43:
  %162 = phi i32 [%160, %$42] ; # C
; # (unless (testEsc C) (eofErr))
; # (testEsc C)
  %163 = call i1 @testEsc(i32 %162)
  br i1 %163, label %$46, label %$45
$45:
  %164 = phi i32 [%162, %$43] ; # C
; # (eofErr)
  call void @eofErr()
  unreachable
$46:
  %165 = phi i32 [%162, %$43] ; # C
  br label %$42
$44:
  %166 = phi i32 [%160, %$42] ; # C
  %167 = phi i64 [0, %$42] ; # ->
; # (call $Get)
  %168 = load i32()*, i32()** @$Get
  %169 = call i32 %168()
; # (drop Q (intern 0 0 (val Q) $Transient $Nil NO))
; # (val Q)
  %170 = inttoptr i64 %151 to i64*
  %171 = load i64, i64* %170
; # (intern 0 0 (val Q) $Transient $Nil NO)
  %172 = call i64 @intern(i64 0, i64 0, i64 %171, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i1 0)
  %173 = inttoptr i64 %151 to i64*
  %174 = getelementptr i64, i64* %173, i32 1
  %175 = load i64, i64* %174
  %176 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %175, i64* %176
  br label %$39
$39:
  %177 = phi i32 [%141, %$37], [%166, %$44] ; # C
  %178 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$37], [%172, %$44] ; # ->
  br label %$4
$35:
  %179 = phi i32 [%135, %$28] ; # C
; # (== C (char "{"))
  %180 = icmp eq i32 %179, 123
  br i1 %180, label %$48, label %$47
$48:
  %181 = phi i32 [%179, %$35] ; # C
; # (prog1 (if (== (setq C (call $Get)) (char "}")) (consSym ZERO $Ni...
; # (if (== (setq C (call $Get)) (char "}")) (consSym ZERO $Nil) (let...
; # (call $Get)
  %182 = load i32()*, i32()** @$Get
  %183 = call i32 %182()
; # (== (setq C (call $Get)) (char "}"))
  %184 = icmp eq i32 %183, 125
  br i1 %184, label %$49, label %$50
$49:
  %185 = phi i32 [%183, %$48] ; # C
; # (consSym ZERO $Nil)
  %186 = call i64 @consSym(i64 2, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$51
$50:
  %187 = phi i32 [%183, %$48] ; # C
; # (let F (i32 0) (while (>= C (char "@")) (when (> C (char "O")) (b...
; # (i32 0)
; # (while (>= C (char "@")) (when (> C (char "O")) (badInput)) (setq...
  br label %$52
$52:
  %188 = phi i32 [%187, %$50], [%202, %$56] ; # C
  %189 = phi i32 [0, %$50], [%200, %$56] ; # F
; # (>= C (char "@"))
  %190 = icmp sge i32 %188, 64
  br i1 %190, label %$53, label %$54
$53:
  %191 = phi i32 [%188, %$52] ; # C
  %192 = phi i32 [%189, %$52] ; # F
; # (when (> C (char "O")) (badInput))
; # (> C (char "O"))
  %193 = icmp sgt i32 %191, 79
  br i1 %193, label %$55, label %$56
$55:
  %194 = phi i32 [%191, %$53] ; # C
  %195 = phi i32 [%192, %$53] ; # F
; # (badInput)
  call void @badInput()
  unreachable
$56:
  %196 = phi i32 [%191, %$53] ; # C
  %197 = phi i32 [%192, %$53] ; # F
; # (shl F 4)
  %198 = shl i32 %197, 4
; # (- C (char "@"))
  %199 = sub i32 %196, 64
; # (| (shl F 4) (- C (char "@")))
  %200 = or i32 %198, %199
; # (call $Get)
  %201 = load i32()*, i32()** @$Get
  %202 = call i32 %201()
  br label %$52
$54:
  %203 = phi i32 [%188, %$52] ; # C
  %204 = phi i32 [%189, %$52] ; # F
; # (let N 0 (loop (unless (and (>= C (char "0")) (>= (char "7") C)) ...
; # (loop (unless (and (>= C (char "0")) (>= (char "7") C)) (badInput...
  br label %$57
$57:
  %205 = phi i32 [%203, %$54], [%230, %$62] ; # C
  %206 = phi i32 [%204, %$54], [%231, %$62] ; # F
  %207 = phi i64 [0, %$54], [%232, %$62] ; # N
; # (unless (and (>= C (char "0")) (>= (char "7") C)) (badInput))
; # (and (>= C (char "0")) (>= (char "7") C))
; # (>= C (char "0"))
  %208 = icmp sge i32 %205, 48
  br i1 %208, label %$59, label %$58
$59:
  %209 = phi i32 [%205, %$57] ; # C
  %210 = phi i32 [%206, %$57] ; # F
  %211 = phi i64 [%207, %$57] ; # N
; # (>= (char "7") C)
  %212 = icmp sge i32 55, %209
  br label %$58
$58:
  %213 = phi i32 [%205, %$57], [%209, %$59] ; # C
  %214 = phi i32 [%206, %$57], [%210, %$59] ; # F
  %215 = phi i64 [%207, %$57], [%211, %$59] ; # N
  %216 = phi i1 [0, %$57], [%212, %$59] ; # ->
  br i1 %216, label %$61, label %$60
$60:
  %217 = phi i32 [%213, %$58] ; # C
  %218 = phi i32 [%214, %$58] ; # F
  %219 = phi i64 [%215, %$58] ; # N
; # (badInput)
  call void @badInput()
  unreachable
$61:
  %220 = phi i32 [%213, %$58] ; # C
  %221 = phi i32 [%214, %$58] ; # F
  %222 = phi i64 [%215, %$58] ; # N
; # (shl N 3)
  %223 = shl i64 %222, 3
; # (- C (char "0"))
  %224 = sub i32 %220, 48
; # (i64 (- C (char "0")))
  %225 = sext i32 %224 to i64
; # (| (shl N 3) (i64 (- C (char "0"))))
  %226 = or i64 %223, %225
; # (? (== (setq C (call $Get)) (char "}")))
; # (call $Get)
  %227 = load i32()*, i32()** @$Get
  %228 = call i32 %227()
; # (== (setq C (call $Get)) (char "}"))
  %229 = icmp eq i32 %228, 125
  br i1 %229, label %$63, label %$62
$62:
  %230 = phi i32 [%228, %$61] ; # C
  %231 = phi i32 [%221, %$61] ; # F
  %232 = phi i64 [%226, %$61] ; # N
  br label %$57
$63:
  %233 = phi i32 [%228, %$61] ; # C
  %234 = phi i32 [%221, %$61] ; # F
  %235 = phi i64 [%226, %$61] ; # N
  %236 = phi i64 [0, %$61] ; # ->
; # (extNm F N)
  %237 = call i64 @extNm(i32 %234, i64 %235)
; # (extern (extNm F N))
  %238 = call i64 @extern(i64 %237)
  br label %$51
$51:
  %239 = phi i32 [%185, %$49], [%233, %$63] ; # C
  %240 = phi i64 [%186, %$49], [%238, %$63] ; # ->
; # (call $Get)
  %241 = load i32()*, i32()** @$Get
  %242 = call i32 %241()
  br label %$4
$47:
  %243 = phi i32 [%179, %$35] ; # C
; # (or (== C (char ")")) (== C (char "]")) (== C (char "~")))
; # (== C (char ")"))
  %244 = icmp eq i32 %243, 41
  br i1 %244, label %$64, label %$65
$65:
  %245 = phi i32 [%243, %$47] ; # C
; # (== C (char "]"))
  %246 = icmp eq i32 %245, 93
  br i1 %246, label %$64, label %$66
$66:
  %247 = phi i32 [%245, %$65] ; # C
; # (== C (char "~"))
  %248 = icmp eq i32 %247, 126
  br label %$64
$64:
  %249 = phi i32 [%243, %$47], [%245, %$65], [%247, %$66] ; # C
  %250 = phi i1 [1, %$47], [1, %$65], [%248, %$66] ; # ->
  br i1 %250, label %$68, label %$67
$68:
  %251 = phi i32 [%249, %$64] ; # C
; # (badInput)
  call void @badInput()
  unreachable
$67:
  %252 = phi i32 [%249, %$64] ; # C
; # (when (== C (char "\\")) (call $Get))
; # (== C (char "\\"))
  %253 = icmp eq i32 %252, 92
  br i1 %253, label %$69, label %$70
$69:
  %254 = phi i32 [%252, %$67] ; # C
; # (call $Get)
  %255 = load i32()*, i32()** @$Get
  %256 = call i32 %255()
  br label %$70
$70:
  %257 = phi i32 [%252, %$67], [%254, %$69] ; # C
; # (val $Chr)
  %258 = load i32, i32* @$Chr
; # (call $Get)
  %259 = load i32()*, i32()** @$Get
  %260 = call i32 %259()
; # (rdAtom C)
  %261 = call i64 @rdAtom(i32 %258)
  br label %$4
$4:
  %262 = phi i32 [%13, %$8], [%25, %$11], [%34, %$17], [%39, %$19], [%100, %$24], [%111, %$30], [%177, %$39], [%239, %$51], [%258, %$70] ; # C
  %263 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8], [%17, %$11], [%30, %$17], [%43, %$19], [%101, %$24], [%130, %$30], [%178, %$39], [%240, %$51], [%261, %$70] ; # ->
  ret i64 %263
}

define i64 @read1(i32) align 8 {
$1:
; # (unless (val $Chr) (call $Get))
; # (val $Chr)
  %1 = load i32, i32* @$Chr
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
; # (call $Get)
  %3 = load i32()*, i32()** @$Get
  %4 = call i32 %3()
  br label %$3
$3:
; # (if (== End (val $Chr)) $Nil (read0 YES))
; # (val $Chr)
  %5 = load i32, i32* @$Chr
; # (== End (val $Chr))
  %6 = icmp eq i32 %0, %5
  br i1 %6, label %$4, label %$5
$4:
  br label %$6
$5:
; # (read0 YES)
  %7 = call i64 @read0(i1 1)
  br label %$6
$6:
  %8 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%7, %$5] ; # ->
  ret i64 %8
}

define i64 @token(i64, i32) align 8 {
$1:
; # (let C (val $Chr) (unless C (setq C (call $Get))) (cond ((lt0 (sk...
; # (val $Chr)
  %2 = load i32, i32* @$Chr
; # (unless C (setq C (call $Get)))
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i32 [%2, %$1] ; # C
; # (call $Get)
  %5 = load i32()*, i32()** @$Get
  %6 = call i32 %5()
  br label %$3
$3:
  %7 = phi i32 [%2, %$1], [%6, %$2] ; # C
; # (cond ((lt0 (skipc Cmt)) 0) ((== (setq C @) (char "\"")) (cond ((...
; # (skipc Cmt)
  %8 = call i32 @skipc(i32 %1)
; # (lt0 (skipc Cmt))
  %9 = icmp slt i32 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = phi i32 [%7, %$3] ; # C
  br label %$4
$5:
  %11 = phi i32 [%7, %$3] ; # C
; # (== (setq C @) (char "\""))
  %12 = icmp eq i32 %8, 34
  br i1 %12, label %$8, label %$7
$8:
  %13 = phi i32 [%8, %$5] ; # C
; # (cond ((== (setq C (call $Get)) (char "\"")) (call $Get) $Nil) ((...
; # (call $Get)
  %14 = load i32()*, i32()** @$Get
  %15 = call i32 %14()
; # (== (setq C (call $Get)) (char "\""))
  %16 = icmp eq i32 %15, 34
  br i1 %16, label %$11, label %$10
$11:
  %17 = phi i32 [%15, %$8] ; # C
; # (call $Get)
  %18 = load i32()*, i32()** @$Get
  %19 = call i32 %18()
  br label %$9
$10:
  %20 = phi i32 [%15, %$8] ; # C
; # (testEsc C)
  %21 = call i1 @testEsc(i32 %20)
; # (not (testEsc C))
  %22 = icmp eq i1 %21, 0
  br i1 %22, label %$13, label %$12
$13:
  %23 = phi i32 [%20, %$10] ; # C
  br label %$9
$12:
  %24 = phi i32 [%20, %$10] ; # C
; # (let (Y (cons (mkChar (val $Chr)) $Nil) R (save Y)) (loop (? (== ...
; # (val $Chr)
  %25 = load i32, i32* @$Chr
; # (mkChar (val $Chr))
  %26 = call i64 @mkChar(i32 %25)
; # (cons (mkChar (val $Chr)) $Nil)
  %27 = call i64 @cons(i64 %26, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %27, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %29, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
; # (loop (? (== (setq C (call $Get)) (char "\"")) (call $Get)) (? (n...
  br label %$14
$14:
  %36 = phi i32 [%24, %$12], [%49, %$18] ; # C
  %37 = phi i64 [%27, %$12], [%53, %$18] ; # Y
; # (? (== (setq C (call $Get)) (char "\"")) (call $Get))
; # (call $Get)
  %38 = load i32()*, i32()** @$Get
  %39 = call i32 %38()
; # (== (setq C (call $Get)) (char "\""))
  %40 = icmp eq i32 %39, 34
  br i1 %40, label %$17, label %$15
$17:
  %41 = phi i32 [%39, %$14] ; # C
  %42 = phi i64 [%37, %$14] ; # Y
; # (call $Get)
  %43 = load i32()*, i32()** @$Get
  %44 = call i32 %43()
  br label %$16
$15:
  %45 = phi i32 [%39, %$14] ; # C
  %46 = phi i64 [%37, %$14] ; # Y
; # (? (not (testEsc C)))
; # (testEsc C)
  %47 = call i1 @testEsc(i32 %45)
; # (not (testEsc C))
  %48 = icmp eq i1 %47, 0
  br i1 %48, label %$16, label %$18
$18:
  %49 = phi i32 [%45, %$15] ; # C
  %50 = phi i64 [%46, %$15] ; # Y
; # (set 2 Y (cons (mkChar (val $Chr)) $Nil))
; # (val $Chr)
  %51 = load i32, i32* @$Chr
; # (mkChar (val $Chr))
  %52 = call i64 @mkChar(i32 %51)
; # (cons (mkChar (val $Chr)) $Nil)
  %53 = call i64 @cons(i64 %52, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %54 = inttoptr i64 %50 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %53, i64* %55
  br label %$14
$16:
  %56 = phi i32 [%41, %$17], [%45, %$15] ; # C
  %57 = phi i64 [%42, %$17], [%46, %$15] ; # Y
  %58 = phi i32 [%44, %$17], [0, %$15] ; # ->
; # (drop *Safe)
  %59 = inttoptr i64 %31 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %61, i64* %62
  br label %$9
$9:
  %63 = phi i32 [%17, %$11], [%23, %$13], [%56, %$16] ; # C
  %64 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%27, %$16] ; # ->
  br label %$4
$7:
  %65 = phi i32 [%8, %$5] ; # C
; # (and (>= (char "9") C) (>= C (char "0")))
; # (>= (char "9") C)
  %66 = icmp sge i32 57, %65
  br i1 %66, label %$20, label %$19
$20:
  %67 = phi i32 [%65, %$7] ; # C
; # (>= C (char "0"))
  %68 = icmp sge i32 %67, 48
  br label %$19
$19:
  %69 = phi i32 [%65, %$7], [%67, %$20] ; # C
  %70 = phi i1 [0, %$7], [%68, %$20] ; # ->
  br i1 %70, label %$22, label %$21
$22:
  %71 = phi i32 [%69, %$19] ; # C
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (loop (byteSym (i...
; # (push 4 NIL ZERO NIL)
  %72 = alloca i64, i64 4, align 16
  store i64 4, i64* %72
  %73 = getelementptr i64, i64* %72, i32 2
  store i64 2, i64* %73
; # (ofs P 2)
  %74 = getelementptr i64, i64* %72, i32 2
; # (link (ofs P 2) T)
  %75 = ptrtoint i64* %74 to i64
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %75 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %77, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %80
; # (loop (byteSym (i8 C) P) (? (and (<> (setq C (call $Get)) (char "...
  br label %$23
$23:
  %81 = phi i32 [%71, %$22], [%94, %$28] ; # C
; # (i8 C)
  %82 = trunc i32 %81 to i8
; # (byteSym (i8 C) P)
  call void @byteSym(i8 %82, i64* %72)
; # (? (and (<> (setq C (call $Get)) (char ".")) (or (> (char "0") C)...
; # (and (<> (setq C (call $Get)) (char ".")) (or (> (char "0") C) (>...
; # (call $Get)
  %83 = load i32()*, i32()** @$Get
  %84 = call i32 %83()
; # (<> (setq C (call $Get)) (char "."))
  %85 = icmp ne i32 %84, 46
  br i1 %85, label %$25, label %$24
$25:
  %86 = phi i32 [%84, %$23] ; # C
; # (or (> (char "0") C) (> C (char "9")))
; # (> (char "0") C)
  %87 = icmp sgt i32 48, %86
  br i1 %87, label %$26, label %$27
$27:
  %88 = phi i32 [%86, %$25] ; # C
; # (> C (char "9"))
  %89 = icmp sgt i32 %88, 57
  br label %$26
$26:
  %90 = phi i32 [%86, %$25], [%88, %$27] ; # C
  %91 = phi i1 [1, %$25], [%89, %$27] ; # ->
  br label %$24
$24:
  %92 = phi i32 [%84, %$23], [%90, %$26] ; # C
  %93 = phi i1 [0, %$23], [%91, %$26] ; # ->
  br i1 %93, label %$29, label %$28
$28:
  %94 = phi i32 [%92, %$24] ; # C
  br label %$23
$29:
  %95 = phi i32 [%92, %$24] ; # C
  %96 = phi i64 [0, %$24] ; # ->
; # (val 3 P)
  %97 = getelementptr i64, i64* %72, i32 2
  %98 = load i64, i64* %97
; # (val $Scl)
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  %100 = load i64, i64* %99
; # (int (val $Scl))
  %101 = lshr i64 %100, 4
; # (symToNum (val 3 P) (int (val $Scl)) (char ".") 0)
  %102 = call i64 @symToNum(i64 %98, i64 %101, i8 46, i8 0)
; # (drop *Safe)
  %103 = inttoptr i64 %75 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
  %106 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %105, i64* %106
  br label %$4
$21:
  %107 = phi i32 [%69, %$19] ; # C
; # (let (Nm (xName 0 Set) S (bufString Nm (b8 (bufSize Nm)))) (if (o...
; # (xName 0 Set)
  %108 = call i64 @xName(i64 0, i64 %0)
; # (bufSize Nm)
  %109 = call i64 @bufSize(i64 %108)
; # (b8 (bufSize Nm))
  %110 = alloca i8, i64 %109
; # (bufString Nm (b8 (bufSize Nm)))
  %111 = call i8* @bufString(i64 %108, i8* %110)
; # (if (or (== C (char "+")) (== C (char "-")) (noToken C S)) (prog1...
; # (or (== C (char "+")) (== C (char "-")) (noToken C S))
; # (== C (char "+"))
  %112 = icmp eq i32 %107, 43
  br i1 %112, label %$30, label %$31
$31:
  %113 = phi i32 [%107, %$21] ; # C
; # (== C (char "-"))
  %114 = icmp eq i32 %113, 45
  br i1 %114, label %$30, label %$32
$32:
  %115 = phi i32 [%113, %$31] ; # C
; # (noToken C S)
  %116 = icmp eq i32 %115, 92
  br i1 %116, label %$33, label %$34
$34:
  %117 = icmp sge i32 122, %115
  br i1 %117, label %$36, label %$35
$36:
  %118 = icmp sge i32 %115, 97
  br label %$35
$35:
  %119 = phi i1 [0, %$34], [%118, %$36] ; # ->
  br i1 %119, label %$33, label %$37
$37:
  %120 = icmp sge i32 90, %115
  br i1 %120, label %$39, label %$38
$39:
  %121 = icmp sge i32 %115, 65
  br label %$38
$38:
  %122 = phi i1 [0, %$37], [%121, %$39] ; # ->
  br i1 %122, label %$33, label %$40
$40:
  %123 = call i8* @strchr(i8* %111, i32 %115)
  %124 = icmp ne i8* %123, null
  br label %$33
$33:
  %125 = phi i1 [1, %$32], [1, %$35], [1, %$38], [%124, %$40] ; # ->
  %126 = icmp eq i1 %125, 0
  br label %$30
$30:
  %127 = phi i32 [%107, %$21], [%113, %$31], [%115, %$33] ; # C
  %128 = phi i1 [1, %$21], [1, %$31], [%126, %$33] ; # ->
  br i1 %128, label %$41, label %$42
$41:
  %129 = phi i32 [%127, %$30] ; # C
; # (prog1 (mkChar (getChar C)) (call $Get))
; # (getChar C)
  %130 = call i32 @getChar(i32 %129)
; # (mkChar (getChar C))
  %131 = call i64 @mkChar(i32 %130)
; # (call $Get)
  %132 = load i32()*, i32()** @$Get
  %133 = call i32 %132()
  br label %$43
$42:
  %134 = phi i32 [%127, %$30] ; # C
; # (when (== C (char "\\")) (call $Get))
; # (== C (char "\\"))
  %135 = icmp eq i32 %134, 92
  br i1 %135, label %$44, label %$45
$44:
  %136 = phi i32 [%134, %$42] ; # C
; # (call $Get)
  %137 = load i32()*, i32()** @$Get
  %138 = call i32 %137()
  br label %$45
$45:
  %139 = phi i32 [%134, %$42], [%136, %$44] ; # C
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (loop (byteSym (i...
; # (push 4 NIL ZERO NIL)
  %140 = alloca i64, i64 4, align 16
  store i64 4, i64* %140
  %141 = getelementptr i64, i64* %140, i32 2
  store i64 2, i64* %141
; # (ofs P 2)
  %142 = getelementptr i64, i64* %140, i32 2
; # (link (ofs P 2) T)
  %143 = ptrtoint i64* %142 to i64
  %144 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %145 = load i64, i64* %144
  %146 = inttoptr i64 %143 to i64*
  %147 = getelementptr i64, i64* %146, i32 1
  store i64 %145, i64* %147
  %148 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %143, i64* %148
; # (loop (byteSym (i8 C) P) (? (and (noToken (setq C (call $Get)) S)...
  br label %$46
$46:
  %149 = phi i32 [%139, %$45], [%177, %$62] ; # C
; # (i8 C)
  %150 = trunc i32 %149 to i8
; # (byteSym (i8 C) P)
  call void @byteSym(i8 %150, i64* %140)
; # (? (and (noToken (setq C (call $Get)) S) (or (> (char "0") C) (> ...
; # (and (noToken (setq C (call $Get)) S) (or (> (char "0") C) (> C (...
; # (call $Get)
  %151 = load i32()*, i32()** @$Get
  %152 = call i32 %151()
; # (noToken (setq C (call $Get)) S)
  %153 = icmp eq i32 %152, 92
  br i1 %153, label %$48, label %$49
$49:
  %154 = icmp sge i32 122, %152
  br i1 %154, label %$51, label %$50
$51:
  %155 = icmp sge i32 %152, 97
  br label %$50
$50:
  %156 = phi i1 [0, %$49], [%155, %$51] ; # ->
  br i1 %156, label %$48, label %$52
$52:
  %157 = icmp sge i32 90, %152
  br i1 %157, label %$54, label %$53
$54:
  %158 = icmp sge i32 %152, 65
  br label %$53
$53:
  %159 = phi i1 [0, %$52], [%158, %$54] ; # ->
  br i1 %159, label %$48, label %$55
$55:
  %160 = call i8* @strchr(i8* %111, i32 %152)
  %161 = icmp ne i8* %160, null
  br label %$48
$48:
  %162 = phi i1 [1, %$46], [1, %$50], [1, %$53], [%161, %$55] ; # ->
  %163 = icmp eq i1 %162, 0
  br i1 %163, label %$56, label %$47
$56:
  %164 = phi i32 [%152, %$48] ; # C
; # (or (> (char "0") C) (> C (char "9")))
; # (> (char "0") C)
  %165 = icmp sgt i32 48, %164
  br i1 %165, label %$57, label %$58
$58:
  %166 = phi i32 [%164, %$56] ; # C
; # (> C (char "9"))
  %167 = icmp sgt i32 %166, 57
  br label %$57
$57:
  %168 = phi i32 [%164, %$56], [%166, %$58] ; # C
  %169 = phi i1 [1, %$56], [%167, %$58] ; # ->
  br label %$47
$47:
  %170 = phi i32 [%152, %$48], [%168, %$57] ; # C
  %171 = phi i1 [0, %$48], [%169, %$57] ; # ->
  br i1 %171, label %$60, label %$59
$59:
  %172 = phi i32 [%170, %$47] ; # C
; # (when (== C (char "\\")) (call $Get))
; # (== C (char "\\"))
  %173 = icmp eq i32 %172, 92
  br i1 %173, label %$61, label %$62
$61:
  %174 = phi i32 [%172, %$59] ; # C
; # (call $Get)
  %175 = load i32()*, i32()** @$Get
  %176 = call i32 %175()
  br label %$62
$62:
  %177 = phi i32 [%172, %$59], [%174, %$61] ; # C
  br label %$46
$60:
  %178 = phi i32 [%170, %$47] ; # C
  %179 = phi i64 [0, %$47] ; # ->
; # (val 3 P)
  %180 = getelementptr i64, i64* %140, i32 2
  %181 = load i64, i64* %180
; # (requestSym (val 3 P))
  %182 = call i64 @requestSym(i64 %181)
; # (drop *Safe)
  %183 = inttoptr i64 %143 to i64*
  %184 = getelementptr i64, i64* %183, i32 1
  %185 = load i64, i64* %184
  %186 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %185, i64* %186
  br label %$43
$43:
  %187 = phi i32 [%129, %$41], [%178, %$60] ; # C
  %188 = phi i64 [%131, %$41], [%182, %$60] ; # ->
  br label %$4
$4:
  %189 = phi i32 [%10, %$6], [%63, %$9], [%95, %$29], [%187, %$43] ; # C
  %190 = phi i64 [0, %$6], [%64, %$9], [%102, %$29], [%188, %$43] ; # ->
  ret i64 %190
}

define i64 @_read(i64) align 8 {
$1:
; # (let X (cdr Exe) (prog1 (if (atom X) (read1 0) (let Y (save (need...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog1 (if (atom X) (read1 0) (let Y (save (needSymb Exe (eval (+...
; # (if (atom X) (read1 0) (let Y (save (needSymb Exe (eval (++ X))))...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
; # (read1 0)
  %7 = call i64 @read1(i32 0)
  br label %$4
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (let Y (save (needSymb Exe (eval (++ X)))) (if (token Y (firstCha...
; # (++ X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
; # (eval (++ X))
  %13 = and i64 %10, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  br label %$5
$6:
  %15 = and i64 %10, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = inttoptr i64 %10 to i64*
  %18 = load i64, i64* %17
  br label %$5
$8:
  %19 = call i64 @evList(i64 %10)
  br label %$5
$5:
  %20 = phi i64 [%10, %$7], [%18, %$9], [%19, %$8] ; # ->
; # (needSymb Exe (eval (++ X)))
  %21 = xor i64 %20, 8
  %22 = and i64 %21, 14
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$10
$10:
  call void @symErr(i64 %0, i64 %20)
  unreachable
$11:
; # (save (needSymb Exe (eval (++ X))))
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = alloca i64, i64 2, align 16
  %27 = ptrtoint i64* %26 to i64
  %28 = inttoptr i64 %27 to i64*
  store i64 %20, i64* %28
  %29 = add i64 %27, 8
  %30 = inttoptr i64 %29 to i64*
  store i64 %25, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %27, i64* %31
; # (if (token Y (firstChar (needSymb Exe (eval (car X))))) @ $Nil)
; # (car X)
  %32 = inttoptr i64 %12 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$14, label %$13
$14:
  br label %$12
$13:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$16, label %$15
$16:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$12
$15:
  %40 = call i64 @evList(i64 %33)
  br label %$12
$12:
  %41 = phi i64 [%33, %$14], [%39, %$16], [%40, %$15] ; # ->
; # (needSymb Exe (eval (car X)))
  %42 = xor i64 %41, 8
  %43 = and i64 %42, 14
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$18, label %$17
$17:
  call void @symErr(i64 %0, i64 %41)
  unreachable
$18:
; # (firstChar (needSymb Exe (eval (car X))))
  %45 = call i32 @firstChar(i64 %41)
; # (token Y (firstChar (needSymb Exe (eval (car X)))))
  %46 = call i64 @token(i64 %20, i32 %45)
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$19, label %$20
$19:
  %48 = phi i64 [%12, %$18] ; # X
  br label %$21
$20:
  %49 = phi i64 [%12, %$18] ; # X
  br label %$21
$21:
  %50 = phi i64 [%48, %$19], [%49, %$20] ; # X
  %51 = phi i64 [%46, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$20] ; # ->
; # (drop *Safe)
  %52 = inttoptr i64 %27 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %55
  br label %$4
$4:
  %56 = phi i64 [%6, %$2], [%50, %$21] ; # X
  %57 = phi i64 [%7, %$2], [%51, %$21] ; # ->
; # (and (== (val $Chr) (char "^J")) (== (val $InFile) (val (val $InF...
; # (val $Chr)
  %58 = load i32, i32* @$Chr
; # (== (val $Chr) (char "^J"))
  %59 = icmp eq i32 %58, 10
  br i1 %59, label %$23, label %$22
$23:
  %60 = phi i64 [%56, %$4] ; # X
; # (val $InFile)
  %61 = load i8*, i8** @$InFile
; # (val $InFiles)
  %62 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %63 = load i8*, i8** %62
; # (== (val $InFile) (val (val $InFiles)))
  %64 = icmp eq i8* %61, %63
  br i1 %64, label %$24, label %$22
$24:
  %65 = phi i64 [%60, %$23] ; # X
; # (set $Chr 0)
  store i32 0, i32* @$Chr
  %66 = icmp ne i32 0, 0
  br label %$22
$22:
  %67 = phi i64 [%56, %$4], [%60, %$23], [%65, %$24] ; # X
  %68 = phi i1 [0, %$4], [0, %$23], [%66, %$24] ; # ->
  ret i64 %57
}

define i64 @_key(i64) align 8 {
$1:
; # (flushAll)
  call void @flushAll()
; # (let Raw (val Termio) (prog2 (setRaw) (if (waitFd Exe 0 (if (nil?...
; # (val Termio)
  %1 = load i8*, i8** @Termio
; # (prog2 (setRaw) (if (waitFd Exe 0 (if (nil? (eval (cadr Exe))) 29...
; # (setRaw)
  call void @setRaw()
; # (if (waitFd Exe 0 (if (nil? (eval (cadr Exe))) 292MY (xCnt Exe @)...
; # (if (nil? (eval (cadr Exe))) 292MY (xCnt Exe @))
; # (cadr Exe)
  %2 = inttoptr i64 %0 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (cadr Exe))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$4, label %$3
$4:
  br label %$2
$3:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$6, label %$5
$6:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$2
$5:
  %13 = call i64 @evList(i64 %6)
  br label %$2
$2:
  %14 = phi i64 [%6, %$4], [%12, %$6], [%13, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
; # (xCnt Exe @)
  %16 = call i64 @xCnt(i64 %0, i64 %14)
  br label %$9
$9:
  %17 = phi i64 [9223372036854775807, %$7], [%16, %$8] ; # ->
; # (waitFd Exe 0 (if (nil? (eval (cadr Exe))) 292MY (xCnt Exe @)))
  %18 = call i64 @waitFd(i64 %0, i32 0, i64 %17)
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$10, label %$11
$10:
; # (let C (stdinByte) (mkChar (cond ((>= 127 C) C) ((== C (hex "FF")...
; # (stdinByte)
  %20 = call i32 @stdinByte()
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (let B (ifn...
; # (>= 127 C)
  %21 = icmp sge i32 127, %20
  br i1 %21, label %$15, label %$14
$15:
  br label %$13
$14:
; # (== C (hex "FF"))
  %22 = icmp eq i32 %20, 255
  br i1 %22, label %$17, label %$16
$17:
; # (i32 TOP)
  br label %$13
$16:
; # (let B (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (h...
; # (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (hex "10"...
; # (& C (hex "20"))
  %23 = and i32 %20, 32
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %$19, label %$18
$18:
; # (& C (hex "1F"))
  %25 = and i32 %20, 31
  br label %$20
$19:
; # (let A (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) ...
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) (& (std...
; # (& C (hex "10"))
  %26 = and i32 %20, 16
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$22, label %$21
$21:
; # (& C (hex "0F"))
  %28 = and i32 %20, 15
  br label %$23
$22:
; # (& C 7)
  %29 = and i32 %20, 7
; # (shl (& C 7) 6)
  %30 = shl i32 %29, 6
; # (stdinByte)
  %31 = call i32 @stdinByte()
; # (& (stdinByte) (hex "3F"))
  %32 = and i32 %31, 63
; # (| (shl (& C 7) 6) (& (stdinByte) (hex "3F")))
  %33 = or i32 %30, %32
  br label %$23
$23:
  %34 = phi i32 [%28, %$21], [%33, %$22] ; # ->
; # (shl A 6)
  %35 = shl i32 %34, 6
; # (stdinByte)
  %36 = call i32 @stdinByte()
; # (& (stdinByte) (hex "3F"))
  %37 = and i32 %36, 63
; # (| (shl A 6) (& (stdinByte) (hex "3F")))
  %38 = or i32 %35, %37
  br label %$20
$20:
  %39 = phi i32 [%25, %$18], [%38, %$23] ; # ->
; # (shl B 6)
  %40 = shl i32 %39, 6
; # (stdinByte)
  %41 = call i32 @stdinByte()
; # (& (stdinByte) (hex "3F"))
  %42 = and i32 %41, 63
; # (| (shl B 6) (& (stdinByte) (hex "3F")))
  %43 = or i32 %40, %42
  br label %$13
$13:
  %44 = phi i32 [%20, %$15], [1114112, %$17], [%43, %$20] ; # ->
; # (mkChar (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (le...
  %45 = call i64 @mkChar(i32 %44)
  br label %$12
$11:
  br label %$12
$12:
  %46 = phi i64 [%45, %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
; # (unless Raw (setCooked))
  %47 = icmp ne i8* %1, null
  br i1 %47, label %$25, label %$24
$24:
; # (setCooked)
  call void @setCooked()
  br label %$25
$25:
  ret i64 %46
}

define i64 @_peek(i64) align 8 {
$1:
; # (let Chr (val $Chr) (unless Chr (setq Chr (call $Get))) (if (lt0 ...
; # (val $Chr)
  %1 = load i32, i32* @$Chr
; # (unless Chr (setq Chr (call $Get)))
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i32 [%1, %$1] ; # Chr
; # (call $Get)
  %4 = load i32()*, i32()** @$Get
  %5 = call i32 %4()
  br label %$3
$3:
  %6 = phi i32 [%1, %$1], [%5, %$2] ; # Chr
; # (if (lt0 Chr) $Nil (mkChar Chr))
; # (lt0 Chr)
  %7 = icmp slt i32 %6, 0
  br i1 %7, label %$4, label %$5
$4:
  %8 = phi i32 [%6, %$3] ; # Chr
  br label %$6
$5:
  %9 = phi i32 [%6, %$3] ; # Chr
; # (mkChar Chr)
  %10 = call i64 @mkChar(i32 %9)
  br label %$6
$6:
  %11 = phi i32 [%8, %$4], [%9, %$5] ; # Chr
  %12 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%10, %$5] ; # ->
  ret i64 %12
}

define i64 @_char(i64) align 8 {
$1:
; # (let X (cdr Exe) (cond ((atom X) (let Chr (val $Chr) (unless Chr ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (let Chr (val $Chr) (unless Chr (setq Chr (call $...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
; # (let Chr (val $Chr) (unless Chr (setq Chr (call $Get))) (prog1 (i...
; # (val $Chr)
  %6 = load i32, i32* @$Chr
; # (unless Chr (setq Chr (call $Get)))
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %$6, label %$5
$5:
  %8 = phi i32 [%6, %$4] ; # Chr
; # (call $Get)
  %9 = load i32()*, i32()** @$Get
  %10 = call i32 %9()
  br label %$6
$6:
  %11 = phi i32 [%6, %$4], [%10, %$5] ; # Chr
; # (prog1 (if (lt0 Chr) $Nil (mkChar (getChar Chr))) (call $Get))
; # (if (lt0 Chr) $Nil (mkChar (getChar Chr)))
; # (lt0 Chr)
  %12 = icmp slt i32 %11, 0
  br i1 %12, label %$7, label %$8
$7:
  %13 = phi i32 [%11, %$6] ; # Chr
  br label %$9
$8:
  %14 = phi i32 [%11, %$6] ; # Chr
; # (getChar Chr)
  %15 = call i32 @getChar(i32 %14)
; # (mkChar (getChar Chr))
  %16 = call i64 @mkChar(i32 %15)
  br label %$9
$9:
  %17 = phi i32 [%13, %$7], [%14, %$8] ; # Chr
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%16, %$8] ; # ->
; # (call $Get)
  %19 = load i32()*, i32()** @$Get
  %20 = call i32 %19()
  br label %$2
$3:
; # (car X)
  %21 = inttoptr i64 %3 to i64*
  %22 = load i64, i64* %21
; # (eval (car X))
  %23 = and i64 %22, 6
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  br label %$10
$11:
  %25 = and i64 %22, 8
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$14, label %$13
$14:
  %27 = inttoptr i64 %22 to i64*
  %28 = load i64, i64* %27
  br label %$10
$13:
  %29 = call i64 @evList(i64 %22)
  br label %$10
$10:
  %30 = phi i64 [%22, %$12], [%28, %$14], [%29, %$13] ; # ->
; # (cnt? (eval (car X)))
  %31 = and i64 %30, 2
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$15
$16:
; # (if (int @) (mkChar (i32 @)) $Nil)
; # (int @)
  %33 = lshr i64 %30, 4
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$17, label %$18
$17:
; # (i32 @)
  %35 = trunc i64 %33 to i32
; # (mkChar (i32 @))
  %36 = call i64 @mkChar(i32 %35)
  br label %$19
$18:
  br label %$19
$19:
  %37 = phi i64 [%36, %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$18] ; # ->
  br label %$2
$15:
; # (t? @)
  %38 = icmp eq i64 %30, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %38, label %$21, label %$20
$21:
; # (mkChar TOP)
  %39 = call i64 @mkChar(i32 1114112)
  br label %$2
$20:
; # (symb? @)
  %40 = xor i64 %30, 8
  %41 = and i64 %40, 14
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$23, label %$22
$23:
; # (firstChar @)
  %43 = call i32 @firstChar(i64 %30)
; # (i64 (firstChar @))
  %44 = sext i32 %43 to i64
; # (cnt (i64 (firstChar @)))
  %45 = shl i64 %44, 4
  %46 = or i64 %45, 2
  br label %$2
$22:
; # (atomErr Exe @)
  call void @atomErr(i64 %0, i64 %30)
  unreachable
$2:
  %47 = phi i64 [%18, %$9], [%37, %$19], [%39, %$21], [%46, %$23] ; # ->
  ret i64 %47
}

define i64 @_skip(i64) align 8 {
$1:
; # (if (lt0 (skipc (firstChar (evSym (cdr Exe))))) $Nil (mkChar @))
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (firstChar (evSym (cdr Exe)))
  %5 = call i32 @firstChar(i64 %4)
; # (skipc (firstChar (evSym (cdr Exe))))
  %6 = call i32 @skipc(i32 %5)
; # (lt0 (skipc (firstChar (evSym (cdr Exe)))))
  %7 = icmp slt i32 %6, 0
  br i1 %7, label %$2, label %$3
$2:
  br label %$4
$3:
; # (mkChar @)
  %8 = call i64 @mkChar(i32 %6)
  br label %$4
$4:
  %9 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%8, %$3] ; # ->
  ret i64 %9
}

define i64 @_eol(i64) align 8 {
$1:
; # (let C (if (val $Chr) @ (call $Get)) (if (or (le0 C) (== C (char ...
; # (if (val $Chr) @ (call $Get))
; # (val $Chr)
  %1 = load i32, i32* @$Chr
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  br label %$4
$3:
; # (call $Get)
  %3 = load i32()*, i32()** @$Get
  %4 = call i32 %3()
  br label %$4
$4:
  %5 = phi i32 [%1, %$2], [%4, %$3] ; # ->
; # (if (or (le0 C) (== C (char "^J"))) $T $Nil)
; # (or (le0 C) (== C (char "^J")))
; # (le0 C)
  %6 = icmp sle i32 %5, 0
  br i1 %6, label %$5, label %$6
$6:
; # (== C (char "^J"))
  %7 = icmp eq i32 %5, 10
  br label %$5
$5:
  %8 = phi i1 [1, %$4], [%7, %$6] ; # ->
  br i1 %8, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %9 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %9
}

define i64 @_eof(i64) align 8 {
$1:
; # (nond ((nil? (eval (cadr Exe))) (set $Chr -1) $T) ((=0 (val $Chr)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$8, label %$9
$9:
; # (set $Chr -1)
  store i32 -1, i32* @$Chr
  br label %$2
$8:
; # (val $Chr)
  %15 = load i32, i32* @$Chr
; # (=0 (val $Chr))
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %$10, label %$11
$11:
; # (if (lt0 @) $T $Nil)
; # (lt0 @)
  %17 = icmp slt i32 %15, 0
  br i1 %17, label %$12, label %$13
$12:
  br label %$14
$13:
  br label %$14
$14:
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13] ; # ->
  br label %$2
$10:
; # (if (lt0 (call $Get)) $T $Nil)
; # (call $Get)
  %19 = load i32()*, i32()** @$Get
  %20 = call i32 %19()
; # (lt0 (call $Get))
  %21 = icmp slt i32 %20, 0
  br i1 %21, label %$15, label %$16
$15:
  br label %$17
$16:
  br label %$17
$17:
  %22 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$16] ; # ->
  br label %$2
$2:
  %23 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$9], [%18, %$14], [%22, %$17] ; # ->
  ret i64 %23
}

define i64 @_from(i64) align 8 {
$1:
; # (let (X (cdr Exe) N 1 Y (evSym X) Nm (xName Exe Y) L (link (push ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe Y)
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (bufSize Nm)
  %6 = call i64 @bufSize(i64 %5)
; # (b8 (bufSize Nm))
  %7 = alloca i8, i64 %6
; # (bufString Nm (b8 (bufSize Nm)))
  %8 = call i8* @bufString(i64 %5, i8* %7)
; # (any (bufString Nm (b8 (bufSize Nm))))
  %9 = ptrtoint i8* %8 to i64
; # (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm)))))
  %10 = alloca i64, i64 4, align 16
  %11 = ptrtoint i64* %10 to i64
  %12 = inttoptr i64 %11 to i64*
  store i64 %4, i64* %12
  %13 = add i64 %11, 16
  %14 = inttoptr i64 %13 to i64*
  store i64 0, i64* %14
  %15 = add i64 %11, 24
  %16 = inttoptr i64 %15 to i64*
  store i64 %9, i64* %16
; # (link (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm))))))
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %11 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %11, i64* %21
; # (while (pair (shift X)) (setq Y (evSym X) Nm (xName Exe Y) L (lin...
  br label %$2
$2:
  %22 = phi i64 [%3, %$1], [%32, %$3] ; # X
  %23 = phi i64 [1, %$1], [%55, %$3] ; # N
  %24 = phi i64 [%4, %$1], [%37, %$3] ; # Y
  %25 = phi i64 [%5, %$1], [%38, %$3] ; # Nm
  %26 = phi i64 [%11, %$1], [%44, %$3] ; # L
; # (shift X)
  %27 = inttoptr i64 %22 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
; # (pair (shift X))
  %30 = and i64 %29, 15
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$3, label %$4
$3:
  %32 = phi i64 [%29, %$2] ; # X
  %33 = phi i64 [%23, %$2] ; # N
  %34 = phi i64 [%24, %$2] ; # Y
  %35 = phi i64 [%25, %$2] ; # Nm
  %36 = phi i64 [%26, %$2] ; # L
; # (evSym X)
  %37 = call i64 @evSym(i64 %32)
; # (xName Exe Y)
  %38 = call i64 @xName(i64 %0, i64 %37)
; # (bufSize Nm)
  %39 = call i64 @bufSize(i64 %38)
; # (b8 (bufSize Nm))
  %40 = alloca i8, i64 %39
; # (bufString Nm (b8 (bufSize Nm)))
  %41 = call i8* @bufString(i64 %38, i8* %40)
; # (any (bufString Nm (b8 (bufSize Nm))))
  %42 = ptrtoint i8* %41 to i64
; # (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm)))))
  %43 = alloca i64, i64 4, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %37, i64* %45
  %46 = add i64 %44, 16
  %47 = inttoptr i64 %46 to i64*
  store i64 0, i64* %47
  %48 = add i64 %44, 24
  %49 = inttoptr i64 %48 to i64*
  store i64 %42, i64* %49
; # (link (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm))))))
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %44 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  store i64 %51, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %54
; # (inc 'N)
  %55 = add i64 %33, 1
  br label %$2
$4:
  %56 = phi i64 [%29, %$2] ; # X
  %57 = phi i64 [%23, %$2] ; # N
  %58 = phi i64 [%24, %$2] ; # Y
  %59 = phi i64 [%25, %$2] ; # Nm
  %60 = phi i64 [%26, %$2] ; # L
; # (unless (val $Chr) (call $Get))
; # (val $Chr)
  %61 = load i32, i32* @$Chr
  %62 = icmp ne i32 %61, 0
  br i1 %62, label %$6, label %$5
$5:
  %63 = phi i64 [%56, %$4] ; # X
  %64 = phi i64 [%57, %$4] ; # N
  %65 = phi i64 [%58, %$4] ; # Y
  %66 = phi i64 [%59, %$4] ; # Nm
  %67 = phi i64 [%60, %$4] ; # L
; # (call $Get)
  %68 = load i32()*, i32()** @$Get
  %69 = call i32 %68()
  br label %$6
$6:
  %70 = phi i64 [%56, %$4], [%63, %$5] ; # X
  %71 = phi i64 [%57, %$4], [%64, %$5] ; # N
  %72 = phi i64 [%58, %$4], [%65, %$5] ; # Y
  %73 = phi i64 [%59, %$4], [%66, %$5] ; # Nm
  %74 = phi i64 [%60, %$4], [%67, %$5] ; # L
; # (while (ge0 (val $Chr)) (let (B (i8 @) Q (i64* L) I N) (loop (loo...
  br label %$7
$7:
  %75 = phi i64 [%70, %$6], [%223, %$22] ; # X
  %76 = phi i64 [%71, %$6], [%224, %$22] ; # N
  %77 = phi i64 [%72, %$6], [%225, %$22] ; # Y
  %78 = phi i64 [%73, %$6], [%226, %$22] ; # Nm
  %79 = phi i64 [%74, %$6], [%227, %$22] ; # L
; # (val $Chr)
  %80 = load i32, i32* @$Chr
; # (ge0 (val $Chr))
  %81 = icmp sge i32 %80, 0
  br i1 %81, label %$8, label %$9
$8:
  %82 = phi i64 [%75, %$7] ; # X
  %83 = phi i64 [%76, %$7] ; # N
  %84 = phi i64 [%77, %$7] ; # Y
  %85 = phi i64 [%78, %$7] ; # Nm
  %86 = phi i64 [%79, %$7] ; # L
; # (let (B (i8 @) Q (i64* L) I N) (loop (loop (let S (ofs (i8* (val ...
; # (i8 @)
  %87 = trunc i32 %80 to i8
; # (i64* L)
  %88 = inttoptr i64 %86 to i64*
; # (loop (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (v...
  br label %$10
$10:
  %89 = phi i64 [%82, %$8], [%213, %$21] ; # X
  %90 = phi i64 [%83, %$8], [%214, %$21] ; # N
  %91 = phi i64 [%84, %$8], [%215, %$21] ; # Y
  %92 = phi i64 [%85, %$8], [%216, %$21] ; # Nm
  %93 = phi i64 [%86, %$8], [%217, %$21] ; # L
  %94 = phi i64* [%88, %$8], [%222, %$21] ; # Q
  %95 = phi i64 [%83, %$8], [%219, %$21] ; # I
; # (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S))...
  br label %$11
$11:
  %96 = phi i64 [%89, %$10], [%195, %$19] ; # X
  %97 = phi i64 [%90, %$10], [%196, %$19] ; # N
  %98 = phi i64 [%91, %$10], [%197, %$19] ; # Y
  %99 = phi i64 [%92, %$10], [%198, %$19] ; # Nm
  %100 = phi i64 [%93, %$10], [%199, %$19] ; # L
  %101 = phi i64* [%94, %$10], [%200, %$19] ; # Q
  %102 = phi i64 [%95, %$10], [%201, %$19] ; # I
; # (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S)) (set ...
; # (val 4 Q)
  %103 = getelementptr i64, i64* %101, i32 3
  %104 = load i64, i64* %103
; # (i8* (val 4 Q))
  %105 = inttoptr i64 %104 to i8*
; # (val 3 Q)
  %106 = getelementptr i64, i64* %101, i32 2
  %107 = load i64, i64* %106
; # (ofs (i8* (val 4 Q)) (val 3 Q))
  %108 = getelementptr i8, i8* %105, i64 %107
; # (when (== B (val S)) (set 3 Q (inc (val 3 Q))) (? (val 2 S)) (cal...
; # (val S)
  %109 = load i8, i8* %108
; # (== B (val S))
  %110 = icmp eq i8 %87, %109
  br i1 %110, label %$12, label %$13
$12:
  %111 = phi i64 [%96, %$11] ; # X
  %112 = phi i64 [%97, %$11] ; # N
  %113 = phi i64 [%98, %$11] ; # Y
  %114 = phi i64 [%99, %$11] ; # Nm
  %115 = phi i64 [%100, %$11] ; # L
  %116 = phi i64* [%101, %$11] ; # Q
  %117 = phi i64 [%102, %$11] ; # I
; # (set 3 Q (inc (val 3 Q)))
; # (val 3 Q)
  %118 = getelementptr i64, i64* %116, i32 2
  %119 = load i64, i64* %118
; # (inc (val 3 Q))
  %120 = add i64 %119, 1
  %121 = getelementptr i64, i64* %116, i32 2
  store i64 %120, i64* %121
; # (? (val 2 S))
; # (val 2 S)
  %122 = getelementptr i8, i8* %108, i32 1
  %123 = load i8, i8* %122
  %124 = icmp ne i8 %123, 0
  br i1 %124, label %$15, label %$14
$14:
  %125 = phi i64 [%111, %$12] ; # X
  %126 = phi i64 [%112, %$12] ; # N
  %127 = phi i64 [%113, %$12] ; # Y
  %128 = phi i64 [%114, %$12] ; # Nm
  %129 = phi i64 [%115, %$12] ; # L
  %130 = phi i64* [%116, %$12] ; # Q
  %131 = phi i64 [%117, %$12] ; # I
; # (call $Get)
  %132 = load i32()*, i32()** @$Get
  %133 = call i32 %132()
; # (drop P)
  %134 = inttoptr i64 %11 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  %136 = load i64, i64* %135
  %137 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %136, i64* %137
; # (val Q)
  %138 = load i64, i64* %130
; # (ret (val Q))
  ret i64 %138
$13:
  %139 = phi i64 [%96, %$11] ; # X
  %140 = phi i64 [%97, %$11] ; # N
  %141 = phi i64 [%98, %$11] ; # Y
  %142 = phi i64 [%99, %$11] ; # Nm
  %143 = phi i64 [%100, %$11] ; # L
  %144 = phi i64* [%101, %$11] ; # Q
  %145 = phi i64 [%102, %$11] ; # I
; # (? (=0 (val 3 Q)))
; # (val 3 Q)
  %146 = getelementptr i64, i64* %144, i32 2
  %147 = load i64, i64* %146
; # (=0 (val 3 Q))
  %148 = icmp eq i64 %147, 0
  br i1 %148, label %$15, label %$16
$16:
  %149 = phi i64 [%139, %$13] ; # X
  %150 = phi i64 [%140, %$13] ; # N
  %151 = phi i64 [%141, %$13] ; # Y
  %152 = phi i64 [%142, %$13] ; # Nm
  %153 = phi i64 [%143, %$13] ; # L
  %154 = phi i64* [%144, %$13] ; # Q
  %155 = phi i64 [%145, %$13] ; # I
; # (let S (ofs (i8* (val 4 Q)) 1) (while (set 3 Q (dec (val 3 Q))) (...
; # (val 4 Q)
  %156 = getelementptr i64, i64* %154, i32 3
  %157 = load i64, i64* %156
; # (i8* (val 4 Q))
  %158 = inttoptr i64 %157 to i8*
; # (ofs (i8* (val 4 Q)) 1)
  %159 = getelementptr i8, i8* %158, i32 1
; # (while (set 3 Q (dec (val 3 Q))) (? (=0 (memcmp (i8* (val 4 Q)) S...
  br label %$17
$17:
  %160 = phi i64 [%149, %$16], [%186, %$20] ; # X
  %161 = phi i64 [%150, %$16], [%187, %$20] ; # N
  %162 = phi i64 [%151, %$16], [%188, %$20] ; # Y
  %163 = phi i64 [%152, %$16], [%189, %$20] ; # Nm
  %164 = phi i64 [%153, %$16], [%190, %$20] ; # L
  %165 = phi i64* [%154, %$16], [%191, %$20] ; # Q
  %166 = phi i64 [%155, %$16], [%192, %$20] ; # I
  %167 = phi i8* [%159, %$16], [%194, %$20] ; # S
; # (set 3 Q (dec (val 3 Q)))
; # (val 3 Q)
  %168 = getelementptr i64, i64* %165, i32 2
  %169 = load i64, i64* %168
; # (dec (val 3 Q))
  %170 = sub i64 %169, 1
  %171 = getelementptr i64, i64* %165, i32 2
  store i64 %170, i64* %171
  %172 = icmp ne i64 %170, 0
  br i1 %172, label %$18, label %$19
$18:
  %173 = phi i64 [%160, %$17] ; # X
  %174 = phi i64 [%161, %$17] ; # N
  %175 = phi i64 [%162, %$17] ; # Y
  %176 = phi i64 [%163, %$17] ; # Nm
  %177 = phi i64 [%164, %$17] ; # L
  %178 = phi i64* [%165, %$17] ; # Q
  %179 = phi i64 [%166, %$17] ; # I
  %180 = phi i8* [%167, %$17] ; # S
; # (? (=0 (memcmp (i8* (val 4 Q)) S @)))
; # (val 4 Q)
  %181 = getelementptr i64, i64* %178, i32 3
  %182 = load i64, i64* %181
; # (i8* (val 4 Q))
  %183 = inttoptr i64 %182 to i8*
; # (memcmp (i8* (val 4 Q)) S @)
  %184 = call i32 @memcmp(i8* %183, i8* %180, i64 %170)
; # (=0 (memcmp (i8* (val 4 Q)) S @))
  %185 = icmp eq i32 %184, 0
  br i1 %185, label %$19, label %$20
$20:
  %186 = phi i64 [%173, %$18] ; # X
  %187 = phi i64 [%174, %$18] ; # N
  %188 = phi i64 [%175, %$18] ; # Y
  %189 = phi i64 [%176, %$18] ; # Nm
  %190 = phi i64 [%177, %$18] ; # L
  %191 = phi i64* [%178, %$18] ; # Q
  %192 = phi i64 [%179, %$18] ; # I
  %193 = phi i8* [%180, %$18] ; # S
; # (inc 'S)
  %194 = getelementptr i8, i8* %193, i32 1
  br label %$17
$19:
  %195 = phi i64 [%160, %$17], [%173, %$18] ; # X
  %196 = phi i64 [%161, %$17], [%174, %$18] ; # N
  %197 = phi i64 [%162, %$17], [%175, %$18] ; # Y
  %198 = phi i64 [%163, %$17], [%176, %$18] ; # Nm
  %199 = phi i64 [%164, %$17], [%177, %$18] ; # L
  %200 = phi i64* [%165, %$17], [%178, %$18] ; # Q
  %201 = phi i64 [%166, %$17], [%179, %$18] ; # I
  %202 = phi i8* [%167, %$17], [%180, %$18] ; # S
  br label %$11
$15:
  %203 = phi i64 [%111, %$12], [%139, %$13] ; # X
  %204 = phi i64 [%112, %$12], [%140, %$13] ; # N
  %205 = phi i64 [%113, %$12], [%141, %$13] ; # Y
  %206 = phi i64 [%114, %$12], [%142, %$13] ; # Nm
  %207 = phi i64 [%115, %$12], [%143, %$13] ; # L
  %208 = phi i64* [%116, %$12], [%144, %$13] ; # Q
  %209 = phi i64 [%117, %$12], [%145, %$13] ; # I
  %210 = phi i64 [0, %$12], [0, %$13] ; # ->
; # (? (=0 (dec 'I)))
; # (dec 'I)
  %211 = sub i64 %209, 1
; # (=0 (dec 'I))
  %212 = icmp eq i64 %211, 0
  br i1 %212, label %$22, label %$21
$21:
  %213 = phi i64 [%203, %$15] ; # X
  %214 = phi i64 [%204, %$15] ; # N
  %215 = phi i64 [%205, %$15] ; # Y
  %216 = phi i64 [%206, %$15] ; # Nm
  %217 = phi i64 [%207, %$15] ; # L
  %218 = phi i64* [%208, %$15] ; # Q
  %219 = phi i64 [%211, %$15] ; # I
; # (val 2 Q)
  %220 = getelementptr i64, i64* %218, i32 1
  %221 = load i64, i64* %220
; # (i64* (val 2 Q))
  %222 = inttoptr i64 %221 to i64*
  br label %$10
$22:
  %223 = phi i64 [%203, %$15] ; # X
  %224 = phi i64 [%204, %$15] ; # N
  %225 = phi i64 [%205, %$15] ; # Y
  %226 = phi i64 [%206, %$15] ; # Nm
  %227 = phi i64 [%207, %$15] ; # L
  %228 = phi i64* [%208, %$15] ; # Q
  %229 = phi i64 [%211, %$15] ; # I
  %230 = phi i64 [0, %$15] ; # ->
; # (call $Get)
  %231 = load i32()*, i32()** @$Get
  %232 = call i32 %231()
  br label %$7
$9:
  %233 = phi i64 [%75, %$7] ; # X
  %234 = phi i64 [%76, %$7] ; # N
  %235 = phi i64 [%77, %$7] ; # Y
  %236 = phi i64 [%78, %$7] ; # Nm
  %237 = phi i64 [%79, %$7] ; # L
; # (drop P)
  %238 = inttoptr i64 %11 to i64*
  %239 = getelementptr i64, i64* %238, i32 1
  %240 = load i64, i64* %239
  %241 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %240, i64* %241
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_till(i64) align 8 {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) S (bufString Nm (b8 (b...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (bufSize Nm)
  %6 = call i64 @bufSize(i64 %5)
; # (b8 (bufSize Nm))
  %7 = alloca i8, i64 %6
; # (bufString Nm (b8 (bufSize Nm)))
  %8 = call i8* @bufString(i64 %5, i8* %7)
; # (let C (if (val $Chr) @ (call $Get)) (cond ((or (lt0 C) (strchr S...
; # (if (val $Chr) @ (call $Get))
; # (val $Chr)
  %9 = load i32, i32* @$Chr
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %$2, label %$3
$2:
  br label %$4
$3:
; # (call $Get)
  %11 = load i32()*, i32()** @$Get
  %12 = call i32 %11()
  br label %$4
$4:
  %13 = phi i32 [%9, %$2], [%12, %$3] ; # ->
; # (cond ((or (lt0 C) (strchr S C)) $Nil) ((nil? (eval (cadr X))) (l...
; # (or (lt0 C) (strchr S C))
; # (lt0 C)
  %14 = icmp slt i32 %13, 0
  br i1 %14, label %$6, label %$7
$7:
  %15 = phi i32 [%13, %$4] ; # C
; # (strchr S C)
  %16 = call i8* @strchr(i8* %8, i32 %15)
  %17 = icmp ne i8* %16, null
  br label %$6
$6:
  %18 = phi i32 [%13, %$4], [%15, %$7] ; # C
  %19 = phi i1 [1, %$4], [%17, %$7] ; # ->
  br i1 %19, label %$9, label %$8
$9:
  %20 = phi i32 [%18, %$6] ; # C
  br label %$5
$8:
  %21 = phi i32 [%18, %$6] ; # C
; # (cadr X)
  %22 = inttoptr i64 %3 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (eval (cadr X))
  %27 = and i64 %26, 6
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$12, label %$11
$12:
  br label %$10
$11:
  %29 = and i64 %26, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = inttoptr i64 %26 to i64*
  %32 = load i64, i64* %31
  br label %$10
$13:
  %33 = call i64 @evList(i64 %26)
  br label %$10
$10:
  %34 = phi i64 [%26, %$12], [%32, %$14], [%33, %$13] ; # ->
; # (nil? (eval (cadr X)))
  %35 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %35, label %$16, label %$15
$16:
  %36 = phi i32 [%21, %$10] ; # C
; # (let (Y (cons (mkChar (getChar C)) $Nil) R (save Y)) (until (or (...
; # (getChar C)
  %37 = call i32 @getChar(i32 %36)
; # (mkChar (getChar C))
  %38 = call i64 @mkChar(i32 %37)
; # (cons (mkChar (getChar C)) $Nil)
  %39 = call i64 @cons(i64 %38, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 %39, i64* %44
  %45 = add i64 %43, 8
  %46 = inttoptr i64 %45 to i64*
  store i64 %41, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %47
; # (until (or (le0 (setq C (call $Get))) (strchr S C)) (setq Y (set ...
  br label %$17
$17:
  %48 = phi i32 [%36, %$16], [%60, %$20] ; # C
  %49 = phi i64 [%39, %$16], [%64, %$20] ; # Y
; # (or (le0 (setq C (call $Get))) (strchr S C))
; # (call $Get)
  %50 = load i32()*, i32()** @$Get
  %51 = call i32 %50()
; # (le0 (setq C (call $Get)))
  %52 = icmp sle i32 %51, 0
  br i1 %52, label %$18, label %$19
$19:
  %53 = phi i32 [%51, %$17] ; # C
  %54 = phi i64 [%49, %$17] ; # Y
; # (strchr S C)
  %55 = call i8* @strchr(i8* %8, i32 %53)
  %56 = icmp ne i8* %55, null
  br label %$18
$18:
  %57 = phi i32 [%51, %$17], [%53, %$19] ; # C
  %58 = phi i64 [%49, %$17], [%54, %$19] ; # Y
  %59 = phi i1 [1, %$17], [%56, %$19] ; # ->
  br i1 %59, label %$21, label %$20
$20:
  %60 = phi i32 [%57, %$18] ; # C
  %61 = phi i64 [%58, %$18] ; # Y
; # (set 2 Y (cons (mkChar (getChar C)) $Nil))
; # (getChar C)
  %62 = call i32 @getChar(i32 %60)
; # (mkChar (getChar C))
  %63 = call i64 @mkChar(i32 %62)
; # (cons (mkChar (getChar C)) $Nil)
  %64 = call i64 @cons(i64 %63, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %65 = inttoptr i64 %61 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  store i64 %64, i64* %66
  br label %$17
$21:
  %67 = phi i32 [%57, %$18] ; # C
  %68 = phi i64 [%58, %$18] ; # Y
; # (drop *Safe)
  %69 = inttoptr i64 %43 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  br label %$5
$15:
  %73 = phi i32 [%21, %$10] ; # C
; # (let (P (push 4 NIL ZERO NIL) Q (link (ofs P 2))) (loop (charSym ...
; # (push 4 NIL ZERO NIL)
  %74 = alloca i64, i64 4, align 16
  store i64 4, i64* %74
  %75 = getelementptr i64, i64* %74, i32 2
  store i64 2, i64* %75
; # (ofs P 2)
  %76 = getelementptr i64, i64* %74, i32 2
; # (link (ofs P 2))
  %77 = ptrtoint i64* %76 to i64
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
; # (loop (charSym (getChar C) P) (? (le0 (setq C (call $Get)))) (? (...
  br label %$22
$22:
  %83 = phi i32 [%73, %$15], [%91, %$25] ; # C
; # (getChar C)
  %84 = call i32 @getChar(i32 %83)
; # (charSym (getChar C) P)
  call void @charSym(i32 %84, i64* %74)
; # (? (le0 (setq C (call $Get))))
; # (call $Get)
  %85 = load i32()*, i32()** @$Get
  %86 = call i32 %85()
; # (le0 (setq C (call $Get)))
  %87 = icmp sle i32 %86, 0
  br i1 %87, label %$24, label %$23
$23:
  %88 = phi i32 [%86, %$22] ; # C
; # (? (strchr S C))
; # (strchr S C)
  %89 = call i8* @strchr(i8* %8, i32 %88)
  %90 = icmp ne i8* %89, null
  br i1 %90, label %$24, label %$25
$25:
  %91 = phi i32 [%88, %$23] ; # C
  br label %$22
$24:
  %92 = phi i32 [%86, %$22], [%88, %$23] ; # C
  %93 = phi i64 [0, %$22], [0, %$23] ; # ->
; # (drop Q (consStr (val 3 P)))
; # (val 3 P)
  %94 = getelementptr i64, i64* %74, i32 2
  %95 = load i64, i64* %94
; # (consStr (val 3 P))
  %96 = call i64 @consStr(i64 %95)
  %97 = inttoptr i64 %77 to i64*
  %98 = getelementptr i64, i64* %97, i32 1
  %99 = load i64, i64* %98
  %100 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %99, i64* %100
  br label %$5
$5:
  %101 = phi i32 [%20, %$9], [%67, %$21], [%92, %$24] ; # C
  %102 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%39, %$21], [%96, %$24] ; # ->
  ret i64 %102
}

define i1 @eol(i32) align 8 {
$1:
; # (cond ((lt0 C) YES) ((== C (char "^J")) (set $Chr 0) YES) ((== C ...
; # (lt0 C)
  %1 = icmp slt i32 %0, 0
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (== C (char "^J"))
  %2 = icmp eq i32 %0, 10
  br i1 %2, label %$6, label %$5
$6:
; # (set $Chr 0)
  store i32 0, i32* @$Chr
  br label %$2
$5:
; # (== C (char "^M"))
  %3 = icmp eq i32 %0, 13
  br i1 %3, label %$8, label %$7
$8:
; # (when (== (call $Get) (char "^J")) (set $Chr 0))
; # (call $Get)
  %4 = load i32()*, i32()** @$Get
  %5 = call i32 %4()
; # (== (call $Get) (char "^J"))
  %6 = icmp eq i32 %5, 10
  br i1 %6, label %$9, label %$10
$9:
; # (set $Chr 0)
  store i32 0, i32* @$Chr
  br label %$10
$10:
  br label %$2
$7:
  br label %$2
$2:
  %7 = phi i1 [1, %$4], [1, %$6], [1, %$10], [0, %$7] ; # ->
  ret i1 %7
}

define i64 @_line(i64) align 8 {
$1:
; # (let C (val $Chr) (unless C (setq C (call $Get))) (if (eol C) $Ni...
; # (val $Chr)
  %1 = load i32, i32* @$Chr
; # (unless C (setq C (call $Get)))
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i32 [%1, %$1] ; # C
; # (call $Get)
  %4 = load i32()*, i32()** @$Get
  %5 = call i32 %4()
  br label %$3
$3:
  %6 = phi i32 [%1, %$1], [%5, %$2] ; # C
; # (if (eol C) $Nil (let X (cdr Exe) (cond ((nil? (eval (++ X))) (le...
; # (eol C)
  %7 = call i1 @eol(i32 %6)
  br i1 %7, label %$4, label %$5
$4:
  %8 = phi i32 [%6, %$3] ; # C
  br label %$6
$5:
  %9 = phi i32 [%6, %$3] ; # C
; # (let X (cdr Exe) (cond ((nil? (eval (++ X))) (let (Y (cons (mkCha...
; # (cdr Exe)
  %10 = inttoptr i64 %0 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
; # (cond ((nil? (eval (++ X))) (let (Y (cons (mkChar (getChar C)) $N...
; # (++ X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
  %15 = getelementptr i64, i64* %13, i32 1
  %16 = load i64, i64* %15
; # (eval (++ X))
  %17 = and i64 %14, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$9
$10:
  br label %$8
$9:
  %19 = and i64 %14, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$12, label %$11
$12:
  %21 = inttoptr i64 %14 to i64*
  %22 = load i64, i64* %21
  br label %$8
$11:
  %23 = call i64 @evList(i64 %14)
  br label %$8
$8:
  %24 = phi i64 [%14, %$10], [%22, %$12], [%23, %$11] ; # ->
; # (nil? (eval (++ X)))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %25, label %$14, label %$13
$14:
  %26 = phi i32 [%9, %$8] ; # C
  %27 = phi i64 [%16, %$8] ; # X
; # (let (Y (cons (mkChar (getChar C)) $Nil) R (save Y)) (when (pair ...
; # (getChar C)
  %28 = call i32 @getChar(i32 %26)
; # (mkChar (getChar C))
  %29 = call i64 @mkChar(i32 %28)
; # (cons (mkChar (getChar C)) $Nil)
  %30 = call i64 @cons(i64 %29, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = alloca i64, i64 2, align 16
  %34 = ptrtoint i64* %33 to i64
  %35 = inttoptr i64 %34 to i64*
  store i64 %30, i64* %35
  %36 = add i64 %34, 8
  %37 = inttoptr i64 %36 to i64*
  store i64 %32, i64* %37
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %38
; # (when (pair X) (let Z (set Y (cons (car Y) $Nil)) (loop (let N (e...
; # (pair X)
  %39 = and i64 %27, 15
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %$15, label %$16
$15:
  %41 = phi i32 [%26, %$14] ; # C
  %42 = phi i64 [%27, %$14] ; # X
  %43 = phi i64 [%30, %$14] ; # Y
; # (let Z (set Y (cons (car Y) $Nil)) (loop (let N (evCnt Exe X) (wh...
; # (set Y (cons (car Y) $Nil))
; # (car Y)
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
; # (cons (car Y) $Nil)
  %46 = call i64 @cons(i64 %45, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %47 = inttoptr i64 %43 to i64*
  store i64 %46, i64* %47
; # (loop (let N (evCnt Exe X) (while (gt0 (dec 'N)) (when (eol (setq...
  br label %$17
$17:
  %48 = phi i32 [%41, %$15], [%112, %$26] ; # C
  %49 = phi i64 [%42, %$15], [%113, %$26] ; # X
  %50 = phi i64 [%43, %$15], [%119, %$26] ; # Y
  %51 = phi i64 [%46, %$15], [%118, %$26] ; # Z
; # (let N (evCnt Exe X) (while (gt0 (dec 'N)) (when (eol (setq C (ca...
; # (evCnt Exe X)
  %52 = call i64 @evCnt(i64 %0, i64 %49)
; # (while (gt0 (dec 'N)) (when (eol (setq C (call $Get))) (ret R)) (...
  br label %$18
$18:
  %53 = phi i32 [%48, %$17], [%77, %$22] ; # C
  %54 = phi i64 [%49, %$17], [%78, %$22] ; # X
  %55 = phi i64 [%50, %$17], [%79, %$22] ; # Y
  %56 = phi i64 [%51, %$17], [%84, %$22] ; # Z
  %57 = phi i64 [%52, %$17], [%81, %$22] ; # N
; # (dec 'N)
  %58 = sub i64 %57, 1
; # (gt0 (dec 'N))
  %59 = icmp sgt i64 %58, 0
  br i1 %59, label %$19, label %$20
$19:
  %60 = phi i32 [%53, %$18] ; # C
  %61 = phi i64 [%54, %$18] ; # X
  %62 = phi i64 [%55, %$18] ; # Y
  %63 = phi i64 [%56, %$18] ; # Z
  %64 = phi i64 [%58, %$18] ; # N
; # (when (eol (setq C (call $Get))) (ret R))
; # (call $Get)
  %65 = load i32()*, i32()** @$Get
  %66 = call i32 %65()
; # (eol (setq C (call $Get)))
  %67 = call i1 @eol(i32 %66)
  br i1 %67, label %$21, label %$22
$21:
  %68 = phi i32 [%66, %$19] ; # C
  %69 = phi i64 [%61, %$19] ; # X
  %70 = phi i64 [%62, %$19] ; # Y
  %71 = phi i64 [%63, %$19] ; # Z
  %72 = phi i64 [%64, %$19] ; # N
; # (ret R)
; # (drop *Safe)
  %73 = inttoptr i64 %34 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %76
  ret i64 %30
$22:
  %77 = phi i32 [%66, %$19] ; # C
  %78 = phi i64 [%61, %$19] ; # X
  %79 = phi i64 [%62, %$19] ; # Y
  %80 = phi i64 [%63, %$19] ; # Z
  %81 = phi i64 [%64, %$19] ; # N
; # (set 2 Z (cons (mkChar (getChar C)) $Nil))
; # (getChar C)
  %82 = call i32 @getChar(i32 %77)
; # (mkChar (getChar C))
  %83 = call i64 @mkChar(i32 %82)
; # (cons (mkChar (getChar C)) $Nil)
  %84 = call i64 @cons(i64 %83, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %85 = inttoptr i64 %80 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  store i64 %84, i64* %86
  br label %$18
$20:
  %87 = phi i32 [%53, %$18] ; # C
  %88 = phi i64 [%54, %$18] ; # X
  %89 = phi i64 [%55, %$18] ; # Y
  %90 = phi i64 [%56, %$18] ; # Z
  %91 = phi i64 [%58, %$18] ; # N
; # (? (atom (shift X)))
; # (shift X)
  %92 = inttoptr i64 %88 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
; # (atom (shift X))
  %95 = and i64 %94, 15
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$24, label %$23
$23:
  %97 = phi i32 [%87, %$20] ; # C
  %98 = phi i64 [%94, %$20] ; # X
  %99 = phi i64 [%89, %$20] ; # Y
  %100 = phi i64 [%90, %$20] ; # Z
; # (when (eol (setq C (call $Get))) (ret R))
; # (call $Get)
  %101 = load i32()*, i32()** @$Get
  %102 = call i32 %101()
; # (eol (setq C (call $Get)))
  %103 = call i1 @eol(i32 %102)
  br i1 %103, label %$25, label %$26
$25:
  %104 = phi i32 [%102, %$23] ; # C
  %105 = phi i64 [%98, %$23] ; # X
  %106 = phi i64 [%99, %$23] ; # Y
  %107 = phi i64 [%100, %$23] ; # Z
; # (ret R)
; # (drop *Safe)
  %108 = inttoptr i64 %34 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  %110 = load i64, i64* %109
  %111 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %110, i64* %111
  ret i64 %30
$26:
  %112 = phi i32 [%102, %$23] ; # C
  %113 = phi i64 [%98, %$23] ; # X
  %114 = phi i64 [%99, %$23] ; # Y
  %115 = phi i64 [%100, %$23] ; # Z
; # (set 2 Y (cons (setq Z (cons (mkChar (getChar C)) $Nil)) $Nil))
; # (getChar C)
  %116 = call i32 @getChar(i32 %112)
; # (mkChar (getChar C))
  %117 = call i64 @mkChar(i32 %116)
; # (cons (mkChar (getChar C)) $Nil)
  %118 = call i64 @cons(i64 %117, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (setq Z (cons (mkChar (getChar C)) $Nil)) $Nil)
  %119 = call i64 @cons(i64 %118, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %120 = inttoptr i64 %114 to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  store i64 %119, i64* %121
  br label %$17
$24:
  %122 = phi i32 [%87, %$20] ; # C
  %123 = phi i64 [%94, %$20] ; # X
  %124 = phi i64 [%89, %$20] ; # Y
  %125 = phi i64 [%90, %$20] ; # Z
  %126 = phi i64 [0, %$20] ; # ->
  br label %$16
$16:
  %127 = phi i32 [%26, %$14], [%122, %$24] ; # C
  %128 = phi i64 [%27, %$14], [%123, %$24] ; # X
  %129 = phi i64 [%30, %$14], [%124, %$24] ; # Y
; # (until (eol (setq C (call $Get))) (setq Y (set 2 Y (cons (mkChar ...
  br label %$27
$27:
  %130 = phi i32 [%127, %$16], [%136, %$28] ; # C
  %131 = phi i64 [%128, %$16], [%137, %$28] ; # X
  %132 = phi i64 [%129, %$16], [%141, %$28] ; # Y
; # (call $Get)
  %133 = load i32()*, i32()** @$Get
  %134 = call i32 %133()
; # (eol (setq C (call $Get)))
  %135 = call i1 @eol(i32 %134)
  br i1 %135, label %$29, label %$28
$28:
  %136 = phi i32 [%134, %$27] ; # C
  %137 = phi i64 [%131, %$27] ; # X
  %138 = phi i64 [%132, %$27] ; # Y
; # (set 2 Y (cons (mkChar (getChar C)) $Nil))
; # (getChar C)
  %139 = call i32 @getChar(i32 %136)
; # (mkChar (getChar C))
  %140 = call i64 @mkChar(i32 %139)
; # (cons (mkChar (getChar C)) $Nil)
  %141 = call i64 @cons(i64 %140, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %142 = inttoptr i64 %138 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  store i64 %141, i64* %143
  br label %$27
$29:
  %144 = phi i32 [%134, %$27] ; # C
  %145 = phi i64 [%131, %$27] ; # X
  %146 = phi i64 [%132, %$27] ; # Y
; # (drop *Safe)
  %147 = inttoptr i64 %34 to i64*
  %148 = getelementptr i64, i64* %147, i32 1
  %149 = load i64, i64* %148
  %150 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %149, i64* %150
  br label %$7
$13:
  %151 = phi i32 [%9, %$8] ; # C
  %152 = phi i64 [%16, %$8] ; # X
; # (atom X)
  %153 = and i64 %152, 15
  %154 = icmp ne i64 %153, 0
  br i1 %154, label %$31, label %$30
$31:
  %155 = phi i32 [%151, %$13] ; # C
  %156 = phi i64 [%152, %$13] ; # X
; # (let (P (push 4 NIL ZERO NIL) Q (link (ofs P 2))) (loop (charSym ...
; # (push 4 NIL ZERO NIL)
  %157 = alloca i64, i64 4, align 16
  store i64 4, i64* %157
  %158 = getelementptr i64, i64* %157, i32 2
  store i64 2, i64* %158
; # (ofs P 2)
  %159 = getelementptr i64, i64* %157, i32 2
; # (link (ofs P 2))
  %160 = ptrtoint i64* %159 to i64
  %161 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %162 = load i64, i64* %161
  %163 = inttoptr i64 %160 to i64*
  %164 = getelementptr i64, i64* %163, i32 1
  store i64 %162, i64* %164
  %165 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %160, i64* %165
; # (loop (charSym (getChar C) P) (? (eol (setq C (call $Get)))))
  br label %$32
$32:
  %166 = phi i32 [%155, %$31], [%172, %$33] ; # C
  %167 = phi i64 [%156, %$31], [%173, %$33] ; # X
; # (getChar C)
  %168 = call i32 @getChar(i32 %166)
; # (charSym (getChar C) P)
  call void @charSym(i32 %168, i64* %157)
; # (? (eol (setq C (call $Get))))
; # (call $Get)
  %169 = load i32()*, i32()** @$Get
  %170 = call i32 %169()
; # (eol (setq C (call $Get)))
  %171 = call i1 @eol(i32 %170)
  br i1 %171, label %$34, label %$33
$33:
  %172 = phi i32 [%170, %$32] ; # C
  %173 = phi i64 [%167, %$32] ; # X
  br label %$32
$34:
  %174 = phi i32 [%170, %$32] ; # C
  %175 = phi i64 [%167, %$32] ; # X
  %176 = phi i64 [0, %$32] ; # ->
; # (drop Q (consStr (val 3 P)))
; # (val 3 P)
  %177 = getelementptr i64, i64* %157, i32 2
  %178 = load i64, i64* %177
; # (consStr (val 3 P))
  %179 = call i64 @consStr(i64 %178)
  %180 = inttoptr i64 %160 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %182, i64* %183
  br label %$7
$30:
  %184 = phi i32 [%151, %$13] ; # C
  %185 = phi i64 [%152, %$13] ; # X
; # (let (N (evCnt Exe X) P (push 4 NIL ZERO NIL) Q (link (ofs P 2) T...
; # (evCnt Exe X)
  %186 = call i64 @evCnt(i64 %0, i64 %185)
; # (push 4 NIL ZERO NIL)
  %187 = alloca i64, i64 4, align 16
  store i64 4, i64* %187
  %188 = getelementptr i64, i64* %187, i32 2
  store i64 2, i64* %188
; # (ofs P 2)
  %189 = getelementptr i64, i64* %187, i32 2
; # (link (ofs P 2) T)
  %190 = ptrtoint i64* %189 to i64
  %191 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %192 = load i64, i64* %191
  %193 = inttoptr i64 %190 to i64*
  %194 = getelementptr i64, i64* %193, i32 1
  store i64 %192, i64* %194
  %195 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %190, i64* %195
; # (loop (charSym (getChar C) P) (when (eol (setq C (call $Get))) (r...
  br label %$35
$35:
  %196 = phi i32 [%184, %$30], [%219, %$38] ; # C
  %197 = phi i64 [%185, %$30], [%220, %$38] ; # X
  %198 = phi i64 [%186, %$30], [%221, %$38] ; # N
; # (getChar C)
  %199 = call i32 @getChar(i32 %196)
; # (charSym (getChar C) P)
  call void @charSym(i32 %199, i64* %187)
; # (when (eol (setq C (call $Get))) (ret (cons (consStr (val Q)) $Ni...
; # (call $Get)
  %200 = load i32()*, i32()** @$Get
  %201 = call i32 %200()
; # (eol (setq C (call $Get)))
  %202 = call i1 @eol(i32 %201)
  br i1 %202, label %$36, label %$37
$36:
  %203 = phi i32 [%201, %$35] ; # C
  %204 = phi i64 [%197, %$35] ; # X
  %205 = phi i64 [%198, %$35] ; # N
; # (val Q)
  %206 = inttoptr i64 %190 to i64*
  %207 = load i64, i64* %206
; # (consStr (val Q))
  %208 = call i64 @consStr(i64 %207)
; # (cons (consStr (val Q)) $Nil)
  %209 = call i64 @cons(i64 %208, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (ret (cons (consStr (val Q)) $Nil))
; # (drop *Safe)
  %210 = inttoptr i64 %190 to i64*
  %211 = getelementptr i64, i64* %210, i32 1
  %212 = load i64, i64* %211
  %213 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %212, i64* %213
  ret i64 %209
$37:
  %214 = phi i32 [%201, %$35] ; # C
  %215 = phi i64 [%197, %$35] ; # X
  %216 = phi i64 [%198, %$35] ; # N
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %217 = sub i64 %216, 1
; # (=0 (dec 'N))
  %218 = icmp eq i64 %217, 0
  br i1 %218, label %$39, label %$38
$38:
  %219 = phi i32 [%214, %$37] ; # C
  %220 = phi i64 [%215, %$37] ; # X
  %221 = phi i64 [%217, %$37] ; # N
  br label %$35
$39:
  %222 = phi i32 [%214, %$37] ; # C
  %223 = phi i64 [%215, %$37] ; # X
  %224 = phi i64 [%217, %$37] ; # N
  %225 = phi i64 [0, %$37] ; # ->
; # (let (Y (cons (consStr (val Q)) $Nil) R (save Y)) (while (pair (s...
; # (val Q)
  %226 = inttoptr i64 %190 to i64*
  %227 = load i64, i64* %226
; # (consStr (val Q))
  %228 = call i64 @consStr(i64 %227)
; # (cons (consStr (val Q)) $Nil)
  %229 = call i64 @cons(i64 %228, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %230 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %231 = load i64, i64* %230
  %232 = alloca i64, i64 2, align 16
  %233 = ptrtoint i64* %232 to i64
  %234 = inttoptr i64 %233 to i64*
  store i64 %229, i64* %234
  %235 = add i64 %233, 8
  %236 = inttoptr i64 %235 to i64*
  store i64 %231, i64* %236
  %237 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %233, i64* %237
; # (while (pair (shift X)) (setq N (evCnt Exe X)) (set P 4 3 P ZERO)...
  br label %$40
$40:
  %238 = phi i32 [%222, %$39], [%285, %$47] ; # C
  %239 = phi i64 [%223, %$39], [%286, %$47] ; # X
  %240 = phi i64 [%224, %$39], [%287, %$47] ; # N
  %241 = phi i64 [%229, %$39], [%293, %$47] ; # Y
; # (shift X)
  %242 = inttoptr i64 %239 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
; # (pair (shift X))
  %245 = and i64 %244, 15
  %246 = icmp eq i64 %245, 0
  br i1 %246, label %$41, label %$42
$41:
  %247 = phi i32 [%238, %$40] ; # C
  %248 = phi i64 [%244, %$40] ; # X
  %249 = phi i64 [%240, %$40] ; # N
  %250 = phi i64 [%241, %$40] ; # Y
; # (evCnt Exe X)
  %251 = call i64 @evCnt(i64 %0, i64 %248)
; # (set P 4 3 P ZERO)
  store i64 4, i64* %187
  %252 = getelementptr i64, i64* %187, i32 2
  store i64 2, i64* %252
; # (loop (charSym (getChar C) P) (when (eol (setq C (call $Get))) (s...
  br label %$43
$43:
  %253 = phi i32 [%247, %$41], [%281, %$46] ; # C
  %254 = phi i64 [%248, %$41], [%282, %$46] ; # X
  %255 = phi i64 [%251, %$41], [%283, %$46] ; # N
  %256 = phi i64 [%250, %$41], [%284, %$46] ; # Y
; # (getChar C)
  %257 = call i32 @getChar(i32 %253)
; # (charSym (getChar C) P)
  call void @charSym(i32 %257, i64* %187)
; # (when (eol (setq C (call $Get))) (set 2 Y (cons (consStr (val Q))...
; # (call $Get)
  %258 = load i32()*, i32()** @$Get
  %259 = call i32 %258()
; # (eol (setq C (call $Get)))
  %260 = call i1 @eol(i32 %259)
  br i1 %260, label %$44, label %$45
$44:
  %261 = phi i32 [%259, %$43] ; # C
  %262 = phi i64 [%254, %$43] ; # X
  %263 = phi i64 [%255, %$43] ; # N
  %264 = phi i64 [%256, %$43] ; # Y
; # (set 2 Y (cons (consStr (val Q)) $Nil))
; # (val Q)
  %265 = inttoptr i64 %190 to i64*
  %266 = load i64, i64* %265
; # (consStr (val Q))
  %267 = call i64 @consStr(i64 %266)
; # (cons (consStr (val Q)) $Nil)
  %268 = call i64 @cons(i64 %267, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %269 = inttoptr i64 %264 to i64*
  %270 = getelementptr i64, i64* %269, i32 1
  store i64 %268, i64* %270
; # (ret R)
; # (drop *Safe)
  %271 = inttoptr i64 %190 to i64*
  %272 = getelementptr i64, i64* %271, i32 1
  %273 = load i64, i64* %272
  %274 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %273, i64* %274
  ret i64 %229
$45:
  %275 = phi i32 [%259, %$43] ; # C
  %276 = phi i64 [%254, %$43] ; # X
  %277 = phi i64 [%255, %$43] ; # N
  %278 = phi i64 [%256, %$43] ; # Y
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %279 = sub i64 %277, 1
; # (=0 (dec 'N))
  %280 = icmp eq i64 %279, 0
  br i1 %280, label %$47, label %$46
$46:
  %281 = phi i32 [%275, %$45] ; # C
  %282 = phi i64 [%276, %$45] ; # X
  %283 = phi i64 [%279, %$45] ; # N
  %284 = phi i64 [%278, %$45] ; # Y
  br label %$43
$47:
  %285 = phi i32 [%275, %$45] ; # C
  %286 = phi i64 [%276, %$45] ; # X
  %287 = phi i64 [%279, %$45] ; # N
  %288 = phi i64 [%278, %$45] ; # Y
  %289 = phi i64 [0, %$45] ; # ->
; # (set 2 Y (cons (consStr (val Q)) $Nil))
; # (val Q)
  %290 = inttoptr i64 %190 to i64*
  %291 = load i64, i64* %290
; # (consStr (val Q))
  %292 = call i64 @consStr(i64 %291)
; # (cons (consStr (val Q)) $Nil)
  %293 = call i64 @cons(i64 %292, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %294 = inttoptr i64 %288 to i64*
  %295 = getelementptr i64, i64* %294, i32 1
  store i64 %293, i64* %295
  br label %$40
$42:
  %296 = phi i32 [%238, %$40] ; # C
  %297 = phi i64 [%244, %$40] ; # X
  %298 = phi i64 [%240, %$40] ; # N
  %299 = phi i64 [%241, %$40] ; # Y
; # (loop (setq Y (set 2 Y (cons (mkChar (getChar C)) $Nil))) (? (eol...
  br label %$48
$48:
  %300 = phi i32 [%296, %$42], [%312, %$49] ; # C
  %301 = phi i64 [%297, %$42], [%313, %$49] ; # X
  %302 = phi i64 [%298, %$42], [%314, %$49] ; # N
  %303 = phi i64 [%299, %$42], [%315, %$49] ; # Y
; # (set 2 Y (cons (mkChar (getChar C)) $Nil))
; # (getChar C)
  %304 = call i32 @getChar(i32 %300)
; # (mkChar (getChar C))
  %305 = call i64 @mkChar(i32 %304)
; # (cons (mkChar (getChar C)) $Nil)
  %306 = call i64 @cons(i64 %305, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %307 = inttoptr i64 %303 to i64*
  %308 = getelementptr i64, i64* %307, i32 1
  store i64 %306, i64* %308
; # (? (eol (setq C (call $Get))))
; # (call $Get)
  %309 = load i32()*, i32()** @$Get
  %310 = call i32 %309()
; # (eol (setq C (call $Get)))
  %311 = call i1 @eol(i32 %310)
  br i1 %311, label %$50, label %$49
$49:
  %312 = phi i32 [%310, %$48] ; # C
  %313 = phi i64 [%301, %$48] ; # X
  %314 = phi i64 [%302, %$48] ; # N
  %315 = phi i64 [%306, %$48] ; # Y
  br label %$48
$50:
  %316 = phi i32 [%310, %$48] ; # C
  %317 = phi i64 [%301, %$48] ; # X
  %318 = phi i64 [%302, %$48] ; # N
  %319 = phi i64 [%306, %$48] ; # Y
  %320 = phi i64 [0, %$48] ; # ->
; # (drop *Safe)
  %321 = inttoptr i64 %190 to i64*
  %322 = getelementptr i64, i64* %321, i32 1
  %323 = load i64, i64* %322
  %324 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %323, i64* %324
  br label %$7
$7:
  %325 = phi i32 [%144, %$29], [%174, %$34], [%316, %$50] ; # C
  %326 = phi i64 [%145, %$29], [%175, %$34], [%317, %$50] ; # X
  %327 = phi i64 [%30, %$29], [%179, %$34], [%229, %$50] ; # ->
  br label %$6
$6:
  %328 = phi i32 [%8, %$4], [%325, %$7] ; # C
  %329 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%327, %$7] ; # ->
  ret i64 %329
}

define i64 @_in(i64) align 8 {
$1:
; # (let X (cdr Exe) (rdOpen Exe (eval (++ X)) (b8 (ioFrame T))) (pro...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (b8 (ioFrame T))
  %16 = alloca i8, i64 28
; # (rdOpen Exe (eval (++ X)) (b8 (ioFrame T)))
  call void @rdOpen(i64 %0, i64 %15, i8* %16)
; # (prog1 (run X) (popInFiles) (tosInFile))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%7, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popInFiles)
  call void @popInFiles()
; # (tosInFile)
  call void @tosInFile()
  ret i64 %42
}

define i64 @_out(i64) align 8 {
$1:
; # (let X (cdr Exe) (wrOpen Exe (eval (++ X)) (b8 (ioFrame T))) (pro...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (b8 (ioFrame T))
  %16 = alloca i8, i64 28
; # (wrOpen Exe (eval (++ X)) (b8 (ioFrame T)))
  call void @wrOpen(i64 %0, i64 %15, i8* %16)
; # (prog1 (run X) (popOutFiles) (tosOutFile))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%7, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popOutFiles)
  call void @popOutFiles()
; # (tosOutFile)
  call void @tosOutFile()
  ret i64 %42
}

define i64 @_err(i64) align 8 {
$1:
; # (let X (cdr Exe) (erOpen Exe (eval (++ X)) (b8 (ctFrame T))) (pro...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (b8 (ctFrame T))
  %16 = alloca i8, i64 12
; # (erOpen Exe (eval (++ X)) (b8 (ctFrame T)))
  call void @erOpen(i64 %0, i64 %15, i8* %16)
; # (prog1 (run X) (popErrFiles))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%7, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popErrFiles)
  call void @popErrFiles()
  ret i64 %42
}

define i64 @_ctl(i64) align 8 {
$1:
; # (let X (cdr Exe) (ctOpen Exe (eval (++ X)) (b8 (ctFrame T))) (pro...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (b8 (ctFrame T))
  %16 = alloca i8, i64 12
; # (ctOpen Exe (eval (++ X)) (b8 (ctFrame T)))
  call void @ctOpen(i64 %0, i64 %15, i8* %16)
; # (prog1 (run X) (popCtlFiles))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%7, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popCtlFiles)
  call void @popCtlFiles()
  ret i64 %42
}

define i32 @getIn() align 8 {
$1:
; # (set $Chr (cond ((val $IoChar) (set $IoChar (shr @ 8)) (i32 (i8 @...
; # (cond ((val $IoChar) (set $IoChar (shr @ 8)) (i32 (i8 @))) ((nil?...
; # (val $IoChar)
  %0 = load i64, i64* @$IoChar
  %1 = icmp ne i64 %0, 0
  br i1 %1, label %$4, label %$3
$4:
; # (set $IoChar (shr @ 8))
; # (shr @ 8)
  %2 = lshr i64 %0, 8
  store i64 %2, i64* @$IoChar
; # (i8 @)
  %3 = trunc i64 %0 to i8
; # (i32 (i8 @))
  %4 = zext i8 %3 to i32
  br label %$2
$3:
; # (let Get: (getFrame (val $Input)) (prog2 (set $Chr (Get: chr) (i8...
; # (val $Input)
  %5 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 64) to i8**)
; # (prog2 (set $Chr (Get: chr) (i8** $Get) (Get: fun) $Input (Get: l...
; # (set $Chr (Get: chr) (i8** $Get) (Get: fun) $Input (Get: link))
; # (Get: chr)
  %6 = getelementptr i8, i8* %5, i32 24
  %7 = bitcast i8* %6 to i32*
  %8 = load i32, i32* %7
  store i32 %8, i32* @$Chr
; # (i8** $Get)
  %9 = bitcast i32()** @$Get to i8**
; # (Get: fun)
  %10 = getelementptr i8, i8* %5, i32 16
  %11 = bitcast i8* %10 to i8**
  %12 = load i8*, i8** %11
  store i8* %12, i8** %9
; # (Get: link)
  %13 = bitcast i8* %5 to i8**
  %14 = load i8*, i8** %13
  store i8* %14, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 64) to i8**)
; # (Get: exe)
  %15 = getelementptr i8, i8* %5, i32 8
  %16 = ptrtoint i8* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
; # (eval (Get: exe))
  %19 = and i64 %18, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  br label %$5
$6:
  %21 = and i64 %18, 8
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$9, label %$8
$9:
  %23 = inttoptr i64 %18 to i64*
  %24 = load i64, i64* %23
  br label %$5
$8:
  %25 = call i64 @evList(i64 %18)
  br label %$5
$5:
  %26 = phi i64 [%18, %$7], [%24, %$9], [%25, %$8] ; # ->
; # (set $Input (Get:) $Get (fun (i32) getIn))
; # (Get:)
  store i8* %5, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 64) to i8**)
; # (fun (i32) getIn)
  store i32()* @getIn, i32()** @$Get
; # (Get: chr (val $Chr))
  %27 = getelementptr i8, i8* %5, i32 24
  %28 = bitcast i8* %27 to i32*
  %29 = load i32, i32* @$Chr
  store i32 %29, i32* %28
; # (nil? (let Get: (getFrame (val $Input)) (prog2 (set $Chr (Get: ch...
  %30 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %30, label %$11, label %$10
$11:
  br label %$2
$10:
; # (sym? @)
  %31 = and i64 %26, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$13, label %$12
$13:
; # (let (S @ V (val (tail @))) (if (or (sym? V) (not (cnt? (setq V (...
; # (tail @)
  %33 = add i64 %26, -8
; # (val (tail @))
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (if (or (sym? V) (not (cnt? (setq V (name V))))) (charErr 0 S) (l...
; # (or (sym? V) (not (cnt? (setq V (name V)))))
; # (sym? V)
  %36 = and i64 %35, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$15
$15:
  %38 = phi i64 [%35, %$13] ; # V
; # (name V)
  br label %$16
$16:
  %39 = phi i64 [%38, %$15], [%45, %$17] ; # Tail
  %40 = and i64 %39, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$18, label %$17
$17:
  %42 = phi i64 [%39, %$16] ; # Tail
  %43 = inttoptr i64 %42 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  br label %$16
$18:
  %46 = phi i64 [%39, %$16] ; # Tail
; # (cnt? (setq V (name V)))
  %47 = and i64 %46, 2
  %48 = icmp ne i64 %47, 0
; # (not (cnt? (setq V (name V))))
  %49 = icmp eq i1 %48, 0
  br label %$14
$14:
  %50 = phi i64 [%35, %$13], [%46, %$18] ; # V
  %51 = phi i1 [1, %$13], [%49, %$18] ; # ->
  br i1 %51, label %$19, label %$20
$19:
  %52 = phi i64 [%50, %$14] ; # V
; # (charErr 0 S)
  call void @charErr(i64 0, i64 %26)
  unreachable
$20:
  %53 = phi i64 [%50, %$14] ; # V
; # (let C (int V) (set $IoChar (shr C 8)) (i32 (i8 C)))
; # (int V)
  %54 = lshr i64 %53, 4
; # (set $IoChar (shr C 8))
; # (shr C 8)
  %55 = lshr i64 %54, 8
  store i64 %55, i64* @$IoChar
; # (i8 C)
  %56 = trunc i64 %54 to i8
; # (i32 (i8 C))
  %57 = zext i8 %56 to i32
  br label %$21
$21:
  %58 = phi i64 [%53, %$20] ; # V
  %59 = phi i32 [%57, %$20] ; # ->
  br label %$2
$12:
; # (symErr 0 @)
  call void @symErr(i64 0, i64 %26)
  unreachable
$2:
  %60 = phi i32 [%4, %$4], [-1, %$11], [%59, %$21] ; # ->
  store i32 %60, i32* @$Chr
  ret i32 %60
}

define i64 @_input(i64) align 8 {
$1:
; # (let (X (cdr Exe) Get: (getFrame (b8 (getFrame T)))) (Get: link (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (b8 (getFrame T))
  %4 = alloca i8, i64 28
; # (Get: link (val $Input))
  %5 = bitcast i8* %4 to i8**
  %6 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 64) to i8**)
  store i8* %6, i8** %5
; # (Get: exe (++ X))
  %7 = getelementptr i8, i8* %4, i32 8
  %8 = ptrtoint i8* %7 to i64
  %9 = inttoptr i64 %3 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
  %13 = inttoptr i64 %8 to i64*
  store i64 %10, i64* %13
; # (Get: fun (val (i8** $Get)))
  %14 = getelementptr i8, i8* %4, i32 16
  %15 = bitcast i8* %14 to i8**
  %16 = bitcast i32()** @$Get to i8**
  %17 = load i8*, i8** %16
  store i8* %17, i8** %15
; # (Get: chr (val $Chr))
  %18 = getelementptr i8, i8* %4, i32 24
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* @$Chr
  store i32 %20, i32* %19
; # (set $Input (Get:) $Get (fun (i32) getIn) $IoChar 0 $Chr 0)
; # (Get:)
  store i8* %4, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 64) to i8**)
; # (fun (i32) getIn)
  store i32()* @getIn, i32()** @$Get
  store i64 0, i64* @$IoChar
  store i32 0, i32* @$Chr
; # (prog1 (run X) (set (i8** $Get) (Get: fun) $Input (Get: link) $Ch...
; # (run X)
  br label %$2
$2:
  %21 = phi i64 [%12, %$1], [%43, %$11] ; # Prg
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  %24 = getelementptr i64, i64* %22, i32 1
  %25 = load i64, i64* %24
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$5, label %$3
$5:
  %28 = phi i64 [%25, %$2] ; # Prg
  %29 = and i64 %23, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$8, label %$7
$8:
  br label %$6
$7:
  %31 = and i64 %23, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$10, label %$9
$10:
  %33 = inttoptr i64 %23 to i64*
  %34 = load i64, i64* %33
  br label %$6
$9:
  %35 = call i64 @evList(i64 %23)
  br label %$6
$6:
  %36 = phi i64 [%23, %$8], [%34, %$10], [%35, %$9] ; # ->
  br label %$4
$3:
  %37 = phi i64 [%25, %$2] ; # Prg
  %38 = and i64 %23, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$12, label %$11
$12:
  %40 = phi i64 [%37, %$3] ; # Prg
  %41 = call i64 @evList(i64 %23)
  %42 = icmp ne i64 %41, 0
  br label %$11
$11:
  %43 = phi i64 [%37, %$3], [%40, %$12] ; # Prg
  %44 = phi i1 [0, %$3], [%42, %$12] ; # ->
  br label %$2
$4:
  %45 = phi i64 [%28, %$6] ; # Prg
  %46 = phi i64 [%36, %$6] ; # ->
; # (set (i8** $Get) (Get: fun) $Input (Get: link) $Chr 0)
; # (i8** $Get)
  %47 = bitcast i32()** @$Get to i8**
; # (Get: fun)
  %48 = getelementptr i8, i8* %4, i32 16
  %49 = bitcast i8* %48 to i8**
  %50 = load i8*, i8** %49
  store i8* %50, i8** %47
; # (Get: link)
  %51 = bitcast i8* %4 to i8**
  %52 = load i8*, i8** %51
  store i8* %52, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 64) to i8**)
  store i32 0, i32* @$Chr
  ret i64 %46
}

define void @put1(i8*, i64, i64) align 8 {
$1:
; # (let (Put: (putFrame Put) At2 (save (val $At2)) At3 (save (val $A...
; # (val $At2)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  %4 = load i64, i64* %3
; # (save (val $At2))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (val $At3)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 472) to i64) to i64*
  %14 = load i64, i64* %13
; # (save (val $At3))
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %22
; # (set (i8** $Put) (Put: fun) $Output (Put: link) $At2 C $At3 D)
; # (i8** $Put)
  %23 = bitcast void(i8)** @$Put to i8**
; # (Put: fun)
  %24 = getelementptr i8, i8* %0, i32 16
  %25 = bitcast i8* %24 to i8**
  %26 = load i8*, i8** %25
  store i8* %26, i8** %23
; # (Put: link)
  %27 = bitcast i8* %0 to i8**
  %28 = load i8*, i8** %27
  store i8* %28, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 72) to i8**)
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %1, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 472) to i64) to i64*
  store i64 %2, i64* %30
; # (Put: exe)
  %31 = getelementptr i8, i8* %0, i32 8
  %32 = ptrtoint i8* %31 to i64
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (eval (Put: exe))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$4, label %$3
$4:
  br label %$2
$3:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$6, label %$5
$6:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$2
$5:
  %41 = call i64 @evList(i64 %34)
  br label %$2
$2:
  %42 = phi i64 [%34, %$4], [%40, %$6], [%41, %$5] ; # ->
; # (set $At3 At3 $At2 At2 $Output (Put:) $Put (fun (void i8) putOut)...
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 472) to i64) to i64*
  store i64 %14, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %4, i64* %44
; # (Put:)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 72) to i8**)
; # (fun (void i8) putOut)
  store void(i8)* @putOut, void(i8)** @$Put
; # (drop *Safe)
  %45 = inttoptr i64 %8 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret void
}

define void @putOut(i8) align 8 {
$1:
; # (nond ((& B (hex "80")) (set $IoChar (i64 B))) ((& B (hex "40")) ...
; # (& B (hex "80"))
  %1 = and i8 %0, 128
  %2 = icmp ne i8 %1, 0
  br i1 %2, label %$3, label %$4
$4:
; # (set $IoChar (i64 B))
; # (i64 B)
  %3 = zext i8 %0 to i64
  store i64 %3, i64* @$IoChar
  br label %$2
$3:
; # (& B (hex "40"))
  %4 = and i8 %0, 64
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %$5, label %$6
$6:
; # (set $IoChar (| (val $IoChar) (shl (i64 B) (set $IoIx (+ (val $Io...
; # (val $IoChar)
  %6 = load i64, i64* @$IoChar
; # (i64 B)
  %7 = zext i8 %0 to i64
; # (set $IoIx (+ (val $IoIx) 8))
; # (val $IoIx)
  %8 = load i64, i64* @$IoIx
; # (+ (val $IoIx) 8)
  %9 = add i64 %8, 8
  store i64 %9, i64* @$IoIx
; # (shl (i64 B) (set $IoIx (+ (val $IoIx) 8)))
  %10 = shl i64 %7, %9
; # (| (val $IoChar) (shl (i64 B) (set $IoIx (+ (val $IoIx) 8))))
  %11 = or i64 %6, %10
  store i64 %11, i64* @$IoChar
; # (when (set $IoCnt (dec (val $IoCnt))) (ret))
; # (set $IoCnt (dec (val $IoCnt)))
; # (val $IoCnt)
  %12 = load i32, i32* @$IoCnt
; # (dec (val $IoCnt))
  %13 = sub i32 %12, 1
  store i32 %13, i32* @$IoCnt
  %14 = icmp ne i32 %13, 0
  br i1 %14, label %$7, label %$8
$7:
; # (ret)
  ret void
$8:
  br label %$2
$5:
; # (& B (hex "20"))
  %15 = and i8 %0, 32
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %$9, label %$10
$10:
; # (set $IoCnt 1 $IoIx 0 $IoChar (i64 B))
  store i32 1, i32* @$IoCnt
  store i64 0, i64* @$IoIx
; # (i64 B)
  %17 = zext i8 %0 to i64
  store i64 %17, i64* @$IoChar
; # (ret)
  ret void
$9:
; # (& B (hex "10"))
  %18 = and i8 %0, 16
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %$11, label %$12
$12:
; # (set $IoCnt 2 $IoIx 0 $IoChar (i64 B))
  store i32 2, i32* @$IoCnt
  store i64 0, i64* @$IoIx
; # (i64 B)
  %20 = zext i8 %0 to i64
  store i64 %20, i64* @$IoChar
; # (ret)
  ret void
$11:
; # (set $IoCnt 3 $IoIx 0 $IoChar (i64 B))
  store i32 3, i32* @$IoCnt
  store i64 0, i64* @$IoIx
; # (i64 B)
  %21 = zext i8 %0 to i64
  store i64 %21, i64* @$IoChar
; # (ret)
  ret void
$2:
; # (let (Put: (putFrame (val $Output)) C (consStr (cnt (val $IoChar)...
; # (val $Output)
  %22 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 72) to i8**)
; # (val $IoChar)
  %23 = load i64, i64* @$IoChar
; # (cnt (val $IoChar))
  %24 = shl i64 %23, 4
  %25 = or i64 %24, 2
; # (consStr (cnt (val $IoChar)))
  %26 = call i64 @consStr(i64 %25)
; # (unless (nil? (Put: char)) (put1 (Put:) @ C))
; # (Put: char)
  %27 = getelementptr i8, i8* %22, i32 24
  %28 = ptrtoint i8* %27 to i64
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (nil? (Put: char))
  %31 = icmp eq i64 %30, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %31, label %$14, label %$13
$13:
; # (Put:)
; # (put1 (Put:) @ C)
  call void @put1(i8* %22, i64 %30, i64 %26)
  br label %$14
$14:
; # (Put: char C)
  %32 = getelementptr i8, i8* %22, i32 24
  %33 = ptrtoint i8* %32 to i64
  %34 = inttoptr i64 %33 to i64*
  store i64 %26, i64* %34
  ret void
}

define i64 @_output(i64) align 8 {
$1:
; # (let (X (cdr Exe) Put: (putFrame (b8 (putFrame T)))) (Put: link (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (b8 (putFrame T))
  %4 = alloca i8, i64 32
; # (Put: link (val $Output))
  %5 = bitcast i8* %4 to i8**
  %6 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 72) to i8**)
  store i8* %6, i8** %5
; # (Put: exe (++ X))
  %7 = getelementptr i8, i8* %4, i32 8
  %8 = ptrtoint i8* %7 to i64
  %9 = inttoptr i64 %3 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
  %13 = inttoptr i64 %8 to i64*
  store i64 %10, i64* %13
; # (Put: fun (val (i8** $Put)))
  %14 = getelementptr i8, i8* %4, i32 16
  %15 = bitcast i8* %14 to i8**
  %16 = bitcast void(i8)** @$Put to i8**
  %17 = load i8*, i8** %16
  store i8* %17, i8** %15
; # (Put: char $Nil)
  %18 = getelementptr i8, i8* %4, i32 24
  %19 = ptrtoint i8* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %20
; # (set $Output (Put:) $Put (fun (void i8) putOut))
; # (Put:)
  store i8* %4, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 72) to i8**)
; # (fun (void i8) putOut)
  store void(i8)* @putOut, void(i8)** @$Put
; # (prog1 (run X) (unless (nil? (Put: char)) (put1 (Put:) @ $Nil)) (...
; # (run X)
  br label %$2
$2:
  %21 = phi i64 [%12, %$1], [%43, %$11] ; # Prg
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  %24 = getelementptr i64, i64* %22, i32 1
  %25 = load i64, i64* %24
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$5, label %$3
$5:
  %28 = phi i64 [%25, %$2] ; # Prg
  %29 = and i64 %23, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$8, label %$7
$8:
  br label %$6
$7:
  %31 = and i64 %23, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$10, label %$9
$10:
  %33 = inttoptr i64 %23 to i64*
  %34 = load i64, i64* %33
  br label %$6
$9:
  %35 = call i64 @evList(i64 %23)
  br label %$6
$6:
  %36 = phi i64 [%23, %$8], [%34, %$10], [%35, %$9] ; # ->
  br label %$4
$3:
  %37 = phi i64 [%25, %$2] ; # Prg
  %38 = and i64 %23, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$12, label %$11
$12:
  %40 = phi i64 [%37, %$3] ; # Prg
  %41 = call i64 @evList(i64 %23)
  %42 = icmp ne i64 %41, 0
  br label %$11
$11:
  %43 = phi i64 [%37, %$3], [%40, %$12] ; # Prg
  %44 = phi i1 [0, %$3], [%42, %$12] ; # ->
  br label %$2
$4:
  %45 = phi i64 [%28, %$6] ; # Prg
  %46 = phi i64 [%36, %$6] ; # ->
; # (unless (nil? (Put: char)) (put1 (Put:) @ $Nil))
; # (Put: char)
  %47 = getelementptr i8, i8* %4, i32 24
  %48 = ptrtoint i8* %47 to i64
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (nil? (Put: char))
  %51 = icmp eq i64 %50, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %51, label %$14, label %$13
$13:
  %52 = phi i64 [%12, %$4] ; # X
; # (Put:)
; # (put1 (Put:) @ $Nil)
  call void @put1(i8* %4, i64 %50, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$14
$14:
  %53 = phi i64 [%12, %$4], [%52, %$13] ; # X
; # (set (i8** $Put) (Put: fun) $Output (Put: link))
; # (i8** $Put)
  %54 = bitcast void(i8)** @$Put to i8**
; # (Put: fun)
  %55 = getelementptr i8, i8* %4, i32 16
  %56 = bitcast i8* %55 to i8**
  %57 = load i8*, i8** %56
  store i8* %57, i8** %54
; # (Put: link)
  %58 = bitcast i8* %4 to i8**
  %59 = load i8*, i8** %58
  store i8* %59, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 72) to i8**)
  ret i64 %46
}

define i64 @_fd(i64) align 8 {
$1:
; # (let (X (eval (cadr Exe)) Fd (currFd Exe)) (unless (nil? X) (dup2...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (currFd Exe)
  %14 = call i32 @currFd(i64 %0)
; # (unless (nil? X) (dup2 Fd (i32 (xCnt Exe X))))
; # (nil? X)
  %15 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$8, label %$7
$7:
; # (xCnt Exe X)
  %16 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe X))
  %17 = trunc i64 %16 to i32
; # (dup2 Fd (i32 (xCnt Exe X)))
  %18 = call i32 @dup2(i32 %14, i32 %17)
  br label %$8
$8:
; # (i64 Fd)
  %19 = sext i32 %14 to i64
; # (cnt (i64 Fd))
  %20 = shl i64 %19, 4
  %21 = or i64 %20, 2
  ret i64 %21
}

define i32 @forkLisp(i64) align 8 {
$1:
; # (flushAll)
  call void @flushAll()
; # (unless (val $Spkr) (when (lt0 (pipe $SpMiPipe)) (pipeErr Exe)) (...
; # (val $Spkr)
  %1 = load i32, i32* @$Spkr
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
; # (when (lt0 (pipe $SpMiPipe)) (pipeErr Exe))
; # (pipe $SpMiPipe)
  %3 = call i32 @pipe(i32* bitcast ([2 x i32]* @$SpMiPipe to i32*))
; # (lt0 (pipe $SpMiPipe))
  %4 = icmp slt i32 %3, 0
  br i1 %4, label %$4, label %$5
$4:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$5:
; # (set $Spkr (val $SpMiPipe))
; # (val $SpMiPipe)
  %5 = load i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*)
  store i32 %5, i32* @$Spkr
; # (closeOnExec Exe (set $Spkr (val $SpMiPipe)))
  call void @closeOnExec(i64 %0, i32 %5)
; # (val 2 $SpMiPipe)
  %6 = getelementptr i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*), i32 1
  %7 = load i32, i32* %6
; # (closeOnExec Exe (val 2 $SpMiPipe))
  call void @closeOnExec(i64 %0, i32 %7)
  br label %$3
$3:
; # (let (Hear (b32 2) Tell (b32 2)) (when (or (lt0 (pipe Hear)) (lt0...
; # (b32 2)
  %8 = alloca i32, i64 2
; # (b32 2)
  %9 = alloca i32, i64 2
; # (when (or (lt0 (pipe Hear)) (lt0 (pipe Tell))) (pipeErr Exe))
; # (or (lt0 (pipe Hear)) (lt0 (pipe Tell)))
; # (pipe Hear)
  %10 = call i32 @pipe(i32* %8)
; # (lt0 (pipe Hear))
  %11 = icmp slt i32 %10, 0
  br i1 %11, label %$6, label %$7
$7:
; # (pipe Tell)
  %12 = call i32 @pipe(i32* %9)
; # (lt0 (pipe Tell))
  %13 = icmp slt i32 %12, 0
  br label %$6
$6:
  %14 = phi i1 [1, %$3], [%13, %$7] ; # ->
  br i1 %14, label %$8, label %$9
$8:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$9:
; # (val Hear)
  %15 = load i32, i32* %8
; # (closeOnExec Exe (val Hear))
  call void @closeOnExec(i64 %0, i32 %15)
; # (val 2 Hear)
  %16 = getelementptr i32, i32* %8, i32 1
  %17 = load i32, i32* %16
; # (closeOnExec Exe (val 2 Hear))
  call void @closeOnExec(i64 %0, i32 %17)
; # (val Tell)
  %18 = load i32, i32* %9
; # (closeOnExec Exe (val Tell))
  call void @closeOnExec(i64 %0, i32 %18)
; # (val 2 Tell)
  %19 = getelementptr i32, i32* %9, i32 1
  %20 = load i32, i32* %19
; # (closeOnExec Exe (val 2 Tell))
  call void @closeOnExec(i64 %0, i32 %20)
; # (let (I (i32 0) N (val $Children)) (let Cld (val $Child) (while (...
; # (i32 0)
; # (val $Children)
  %21 = load i32, i32* @$Children
; # (let Cld (val $Child) (while (> N I) (? (=0 ((child Cld) pid))) (...
; # (val $Child)
  %22 = load i8*, i8** @$Child
; # (while (> N I) (? (=0 ((child Cld) pid))) (inc 'I) (setq Cld (ofs...
  br label %$10
$10:
  %23 = phi i32 [0, %$9], [%37, %$13] ; # I
  %24 = phi i32 [%21, %$9], [%35, %$13] ; # N
  %25 = phi i8* [%22, %$9], [%38, %$13] ; # Cld
; # (> N I)
  %26 = icmp sgt i32 %24, %23
  br i1 %26, label %$11, label %$12
$11:
  %27 = phi i32 [%23, %$10] ; # I
  %28 = phi i32 [%24, %$10] ; # N
  %29 = phi i8* [%25, %$10] ; # Cld
; # (? (=0 ((child Cld) pid)))
; # ((child Cld) pid)
  %30 = getelementptr i8, i8* %29, i32 16
  %31 = bitcast i8* %30 to i32*
  %32 = load i32, i32* %31
; # (=0 ((child Cld) pid))
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %$12, label %$13
$13:
  %34 = phi i32 [%27, %$11] ; # I
  %35 = phi i32 [%28, %$11] ; # N
  %36 = phi i8* [%29, %$11] ; # Cld
; # (inc 'I)
  %37 = add i32 %34, 1
; # (ofs Cld (child T))
  %38 = getelementptr i8, i8* %36, i32 28
  br label %$10
$12:
  %39 = phi i32 [%23, %$10], [%27, %$11] ; # I
  %40 = phi i32 [%24, %$10], [%28, %$11] ; # N
  %41 = phi i8* [%25, %$10], [%29, %$11] ; # Cld
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (set $Slot I $Spkr 0 $...
; # (fork)
  %42 = call i32 @fork()
; # (lt0 (fork))
  %43 = icmp slt i32 %42, 0
  br i1 %43, label %$16, label %$15
$16:
  %44 = phi i32 [%39, %$12] ; # I
  %45 = phi i32 [%40, %$12] ; # N
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$15:
  %46 = phi i32 [%39, %$12] ; # I
  %47 = phi i32 [%40, %$12] ; # N
; # (=0 @)
  %48 = icmp eq i32 %42, 0
  br i1 %48, label %$18, label %$17
$18:
  %49 = phi i32 [%46, %$15] ; # I
  %50 = phi i32 [%47, %$15] ; # N
; # (set $Slot I $Spkr 0 $Mic (val 2 $SpMiPipe))
  store i32 %49, i32* @$Slot
  store i32 0, i32* @$Spkr
; # (val 2 $SpMiPipe)
  %51 = getelementptr i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*), i32 1
  %52 = load i32, i32* %51
  store i32 %52, i32* @$Mic
; # (val 2 Hear)
  %53 = getelementptr i32, i32* %8, i32 1
  %54 = load i32, i32* %53
; # (close (val 2 Hear))
  %55 = call i32 @close(i32 %54)
; # (val Tell)
  %56 = load i32, i32* %9
; # (close (val Tell))
  %57 = call i32 @close(i32 %56)
; # (val $SpMiPipe)
  %58 = load i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*)
; # (close (val $SpMiPipe))
  %59 = call i32 @close(i32 %58)
; # (when (val $Hear) (close @) (closeInFile @) (closeOutFile @))
; # (val $Hear)
  %60 = load i32, i32* @$Hear
  %61 = icmp ne i32 %60, 0
  br i1 %61, label %$19, label %$20
$19:
  %62 = phi i32 [%49, %$18] ; # I
  %63 = phi i32 [%50, %$18] ; # N
; # (close @)
  %64 = call i32 @close(i32 %60)
; # (closeInFile @)
  call void @closeInFile(i32 %60)
; # (closeOutFile @)
  call void @closeOutFile(i32 %60)
  br label %$20
$20:
  %65 = phi i32 [%49, %$18], [%62, %$19] ; # I
  %66 = phi i32 [%50, %$18], [%63, %$19] ; # N
; # (set $Hear (val Hear))
; # (val Hear)
  %67 = load i32, i32* %8
  store i32 %67, i32* @$Hear
; # (initInFile (set $Hear (val Hear)) null)
  %68 = call i8* @initInFile(i32 %67, i8* null)
; # (when (val $Tell) (close @))
; # (val $Tell)
  %69 = load i32, i32* @$Tell
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %$21, label %$22
$21:
  %71 = phi i32 [%65, %$20] ; # I
  %72 = phi i32 [%66, %$20] ; # N
; # (close @)
  %73 = call i32 @close(i32 %69)
  br label %$22
$22:
  %74 = phi i32 [%65, %$20], [%71, %$21] ; # I
  %75 = phi i32 [%66, %$20], [%72, %$21] ; # N
; # (set $Tell (val 2 Tell))
; # (val 2 Tell)
  %76 = getelementptr i32, i32* %9, i32 1
  %77 = load i32, i32* %76
  store i32 %77, i32* @$Tell
; # (set $Nfds 0)
  store i32 0, i32* @$Nfds
; # (val $Poll)
  %78 = load i64*, i64** @$Poll
; # (i8* (val $Poll))
  %79 = bitcast i64* %78 to i8*
; # (free (i8* (val $Poll)))
  call void @free(i8* %79)
; # (set $Poll (i64* null))
; # (i64* null)
  %80 = inttoptr i64 0 to i64*
  store i64* %80, i64** @$Poll
; # (let Cld (val $Child) (while (ge0 (dec 'N)) (let Cld: (child Cld)...
; # (val $Child)
  %81 = load i8*, i8** @$Child
; # (while (ge0 (dec 'N)) (let Cld: (child Cld) (when (Cld: pid) (fre...
  br label %$23
$23:
  %82 = phi i32 [%74, %$22], [%107, %$27] ; # I
  %83 = phi i32 [%75, %$22], [%108, %$27] ; # N
  %84 = phi i8* [%81, %$22], [%110, %$27] ; # Cld
; # (dec 'N)
  %85 = sub i32 %83, 1
; # (ge0 (dec 'N))
  %86 = icmp sge i32 %85, 0
  br i1 %86, label %$24, label %$25
$24:
  %87 = phi i32 [%82, %$23] ; # I
  %88 = phi i32 [%85, %$23] ; # N
  %89 = phi i8* [%84, %$23] ; # Cld
; # (let Cld: (child Cld) (when (Cld: pid) (free (Cld: buf)) (close (...
; # (when (Cld: pid) (free (Cld: buf)) (close (Cld: hear)) (close (Cl...
; # (Cld: pid)
  %90 = getelementptr i8, i8* %89, i32 16
  %91 = bitcast i8* %90 to i32*
  %92 = load i32, i32* %91
  %93 = icmp ne i32 %92, 0
  br i1 %93, label %$26, label %$27
$26:
  %94 = phi i32 [%87, %$24] ; # I
  %95 = phi i32 [%88, %$24] ; # N
  %96 = phi i8* [%89, %$24] ; # Cld
; # (Cld: buf)
  %97 = bitcast i8* %89 to i8**
  %98 = load i8*, i8** %97
; # (free (Cld: buf))
  call void @free(i8* %98)
; # (Cld: hear)
  %99 = getelementptr i8, i8* %89, i32 20
  %100 = bitcast i8* %99 to i32*
  %101 = load i32, i32* %100
; # (close (Cld: hear))
  %102 = call i32 @close(i32 %101)
; # (Cld: tell)
  %103 = getelementptr i8, i8* %89, i32 24
  %104 = bitcast i8* %103 to i32*
  %105 = load i32, i32* %104
; # (close (Cld: tell))
  %106 = call i32 @close(i32 %105)
  br label %$27
$27:
  %107 = phi i32 [%87, %$24], [%94, %$26] ; # I
  %108 = phi i32 [%88, %$24], [%95, %$26] ; # N
  %109 = phi i8* [%89, %$24], [%96, %$26] ; # Cld
; # (ofs Cld (child T))
  %110 = getelementptr i8, i8* %109, i32 28
  br label %$23
$25:
  %111 = phi i32 [%82, %$23] ; # I
  %112 = phi i32 [%85, %$23] ; # N
  %113 = phi i8* [%84, %$23] ; # Cld
; # (set $Children 0)
  store i32 0, i32* @$Children
; # (val $Child)
  %114 = load i8*, i8** @$Child
; # (free (val $Child))
  call void @free(i8* %114)
; # (set $Child null)
  store i8* null, i8** @$Child
; # (let In (val $InFrames) (while In (let In: (ioFrame In) (In: pid ...
; # (val $InFrames)
  %115 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (while In (let In: (ioFrame In) (In: pid 0) (setq In (In: link)))...
  br label %$28
$28:
  %116 = phi i32 [%111, %$25], [%120, %$29] ; # I
  %117 = phi i32 [%112, %$25], [%121, %$29] ; # N
  %118 = phi i8* [%115, %$25], [%126, %$29] ; # In
  %119 = icmp ne i8* %118, null
  br i1 %119, label %$29, label %$30
$29:
  %120 = phi i32 [%116, %$28] ; # I
  %121 = phi i32 [%117, %$28] ; # N
  %122 = phi i8* [%118, %$28] ; # In
; # (let In: (ioFrame In) (In: pid 0) (setq In (In: link)))
; # (In: pid 0)
  %123 = getelementptr i8, i8* %122, i32 24
  %124 = bitcast i8* %123 to i32*
  store i32 0, i32* %124
; # (In: link)
  %125 = bitcast i8* %122 to i8**
  %126 = load i8*, i8** %125
  br label %$28
$30:
  %127 = phi i32 [%116, %$28] ; # I
  %128 = phi i32 [%117, %$28] ; # N
  %129 = phi i8* [%118, %$28] ; # In
; # (let Out (val $OutFrames) (while Out (let Out: (ioFrame Out) (Out...
; # (val $OutFrames)
  %130 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (while Out (let Out: (ioFrame Out) (Out: pid 0) (setq Out (Out: l...
  br label %$31
$31:
  %131 = phi i32 [%127, %$30], [%135, %$32] ; # I
  %132 = phi i32 [%128, %$30], [%136, %$32] ; # N
  %133 = phi i8* [%130, %$30], [%141, %$32] ; # Out
  %134 = icmp ne i8* %133, null
  br i1 %134, label %$32, label %$33
$32:
  %135 = phi i32 [%131, %$31] ; # I
  %136 = phi i32 [%132, %$31] ; # N
  %137 = phi i8* [%133, %$31] ; # Out
; # (let Out: (ioFrame Out) (Out: pid 0) (setq Out (Out: link)))
; # (Out: pid 0)
  %138 = getelementptr i8, i8* %137, i32 24
  %139 = bitcast i8* %138 to i32*
  store i32 0, i32* %139
; # (Out: link)
  %140 = bitcast i8* %137 to i8**
  %141 = load i8*, i8** %140
  br label %$31
$33:
  %142 = phi i32 [%131, %$31] ; # I
  %143 = phi i32 [%132, %$31] ; # N
  %144 = phi i8* [%133, %$31] ; # Out
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (Ca: fin ZER...
; # (val $Catch)
  %145 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (Ca: fin ZERO) (setq Ca (Ca: link...
  br label %$34
$34:
  %146 = phi i32 [%142, %$33], [%150, %$35] ; # I
  %147 = phi i32 [%143, %$33], [%151, %$35] ; # N
  %148 = phi i8* [%145, %$33], [%157, %$35] ; # Ca
  %149 = icmp ne i8* %148, null
  br i1 %149, label %$35, label %$36
$35:
  %150 = phi i32 [%146, %$34] ; # I
  %151 = phi i32 [%147, %$34] ; # N
  %152 = phi i8* [%148, %$34] ; # Ca
; # (let Ca: (caFrame Ca) (Ca: fin ZERO) (setq Ca (Ca: link)))
; # (Ca: fin ZERO)
  %153 = getelementptr i8, i8* %152, i32 16
  %154 = ptrtoint i8* %153 to i64
  %155 = inttoptr i64 %154 to i64*
  store i64 2, i64* %155
; # (Ca: link)
  %156 = bitcast i8* %152 to i8**
  %157 = load i8*, i8** %156
  br label %$34
$36:
  %158 = phi i32 [%146, %$34] ; # I
  %159 = phi i32 [%147, %$34] ; # N
  %160 = phi i8* [%148, %$34] ; # Ca
; # (let R (val $Run) (while (pair R) (let X (++ R) (unless (sign? (c...
; # (val $Run)
  %161 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  %162 = load i64, i64* %161
; # (while (pair R) (let X (++ R) (unless (sign? (car X)) (let Fd (i3...
  br label %$37
$37:
  %163 = phi i32 [%158, %$36], [%185, %$41] ; # I
  %164 = phi i32 [%159, %$36], [%186, %$41] ; # N
  %165 = phi i64 [%162, %$36], [%187, %$41] ; # R
; # (pair R)
  %166 = and i64 %165, 15
  %167 = icmp eq i64 %166, 0
  br i1 %167, label %$38, label %$39
$38:
  %168 = phi i32 [%163, %$37] ; # I
  %169 = phi i32 [%164, %$37] ; # N
  %170 = phi i64 [%165, %$37] ; # R
; # (let X (++ R) (unless (sign? (car X)) (let Fd (i32 (int @)) (clos...
; # (++ R)
  %171 = inttoptr i64 %170 to i64*
  %172 = load i64, i64* %171
  %173 = getelementptr i64, i64* %171, i32 1
  %174 = load i64, i64* %173
; # (unless (sign? (car X)) (let Fd (i32 (int @)) (close Fd) (closeIn...
; # (car X)
  %175 = inttoptr i64 %172 to i64*
  %176 = load i64, i64* %175
; # (sign? (car X))
  %177 = and i64 %176, 8
  %178 = icmp ne i64 %177, 0
  br i1 %178, label %$41, label %$40
$40:
  %179 = phi i32 [%168, %$38] ; # I
  %180 = phi i32 [%169, %$38] ; # N
  %181 = phi i64 [%174, %$38] ; # R
; # (let Fd (i32 (int @)) (close Fd) (closeInFile Fd) (closeOutFile F...
; # (int @)
  %182 = lshr i64 %176, 4
; # (i32 (int @))
  %183 = trunc i64 %182 to i32
; # (close Fd)
  %184 = call i32 @close(i32 %183)
; # (closeInFile Fd)
  call void @closeInFile(i32 %183)
; # (closeOutFile Fd)
  call void @closeOutFile(i32 %183)
  br label %$41
$41:
  %185 = phi i32 [%168, %$38], [%179, %$40] ; # I
  %186 = phi i32 [%169, %$38], [%180, %$40] ; # N
  %187 = phi i64 [%174, %$38], [%181, %$40] ; # R
  br label %$37
$39:
  %188 = phi i32 [%163, %$37] ; # I
  %189 = phi i32 [%164, %$37] ; # N
  %190 = phi i64 [%165, %$37] ; # R
; # (set $Bye $Nil)
  %191 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 808) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %191
; # (set $Run $Nil)
  %192 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %192
; # (val Termio)
  %193 = load i8*, i8** @Termio
; # (free (val Termio))
  call void @free(i8* %193)
; # (set Termio null)
  store i8* null, i8** @Termio
; # (set $PRepl (val $Repl) $PPid (val $Pid))
; # (val $Repl)
  %194 = load i1, i1* @$Repl
  store i1 %194, i1* @$PRepl
; # (val $Pid)
  %195 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 200) to i64) to i64*
  %196 = load i64, i64* %195
  %197 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 216) to i64) to i64*
  store i64 %196, i64* %197
; # (set $Pid (cnt (i64 (getpid))))
; # (getpid)
  %198 = call i32 @getpid()
; # (i64 (getpid))
  %199 = sext i32 %198 to i64
; # (cnt (i64 (getpid)))
  %200 = shl i64 %199, 4
  %201 = or i64 %200, 2
  %202 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 200) to i64) to i64*
  store i64 %201, i64* %202
; # (val $Fork)
  %203 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 792) to i64) to i64*
  %204 = load i64, i64* %203
; # (execAt (val $Fork))
  %205 = call i64 @execAt(i64 %204)
; # (set $Fork $Nil)
  %206 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 792) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %206
  br label %$14
$17:
  %207 = phi i32 [%46, %$15] ; # I
  %208 = phi i32 [%47, %$15] ; # N
; # (let Pid @ (when (== I N) (set $Children (inc 'N 8)) (let P (set ...
; # (when (== I N) (set $Children (inc 'N 8)) (let P (set $Child (all...
; # (== I N)
  %209 = icmp eq i32 %207, %208
  br i1 %209, label %$42, label %$43
$42:
  %210 = phi i32 [%207, %$17] ; # I
  %211 = phi i32 [%208, %$17] ; # N
; # (set $Children (inc 'N 8))
; # (inc 'N 8)
  %212 = add i32 %211, 8
  store i32 %212, i32* @$Children
; # (let P (set $Child (alloc (val $Child) (i64 (* N (child T))))) (l...
; # (set $Child (alloc (val $Child) (i64 (* N (child T)))))
; # (val $Child)
  %213 = load i8*, i8** @$Child
; # (* N (child T))
  %214 = mul i32 %212, 28
; # (i64 (* N (child T)))
  %215 = sext i32 %214 to i64
; # (alloc (val $Child) (i64 (* N (child T))))
  %216 = call i8* @alloc(i8* %213, i64 %215)
  store i8* %216, i8** @$Child
; # (let Cld (ofs P (* I (child T))) (loop ((child Cld) pid 0) (? (==...
; # (* I (child T))
  %217 = mul i32 %210, 28
; # (ofs P (* I (child T)))
  %218 = getelementptr i8, i8* %216, i32 %217
; # (loop ((child Cld) pid 0) (? (== I (dec 'N))) (setq Cld (ofs Cld ...
  br label %$44
$44:
  %219 = phi i32 [%210, %$42], [%226, %$45] ; # I
  %220 = phi i32 [%212, %$42], [%227, %$45] ; # N
  %221 = phi i8* [%218, %$42], [%229, %$45] ; # Cld
; # ((child Cld) pid 0)
  %222 = getelementptr i8, i8* %221, i32 16
  %223 = bitcast i8* %222 to i32*
  store i32 0, i32* %223
; # (? (== I (dec 'N)))
; # (dec 'N)
  %224 = sub i32 %220, 1
; # (== I (dec 'N))
  %225 = icmp eq i32 %219, %224
  br i1 %225, label %$46, label %$45
$45:
  %226 = phi i32 [%219, %$44] ; # I
  %227 = phi i32 [%224, %$44] ; # N
  %228 = phi i8* [%221, %$44] ; # Cld
; # (ofs Cld (child T))
  %229 = getelementptr i8, i8* %228, i32 28
  br label %$44
$46:
  %230 = phi i32 [%219, %$44] ; # I
  %231 = phi i32 [%224, %$44] ; # N
  %232 = phi i8* [%221, %$44] ; # Cld
  %233 = phi i64 [0, %$44] ; # ->
  br label %$43
$43:
  %234 = phi i32 [%207, %$17], [%230, %$46] ; # I
  %235 = phi i32 [%208, %$17], [%231, %$46] ; # N
; # (val Hear)
  %236 = load i32, i32* %8
; # (close (val Hear))
  %237 = call i32 @close(i32 %236)
; # (val 2 Tell)
  %238 = getelementptr i32, i32* %9, i32 1
  %239 = load i32, i32* %238
; # (close (val 2 Tell))
  %240 = call i32 @close(i32 %239)
; # (let Cld: (child (ofs (val $Child) (* I (child T)))) (Cld: buf nu...
; # (val $Child)
  %241 = load i8*, i8** @$Child
; # (* I (child T))
  %242 = mul i32 %234, 28
; # (ofs (val $Child) (* I (child T)))
  %243 = getelementptr i8, i8* %241, i32 %242
; # (Cld: buf null)
  %244 = bitcast i8* %243 to i8**
  store i8* null, i8** %244
; # (Cld: ofs (Cld: cnt 0))
  %245 = getelementptr i8, i8* %243, i32 8
  %246 = bitcast i8* %245 to i32*
  %247 = getelementptr i8, i8* %243, i32 12
  %248 = bitcast i8* %247 to i32*
  store i32 0, i32* %248
  store i32 0, i32* %246
; # (Cld: pid Pid)
  %249 = getelementptr i8, i8* %243, i32 16
  %250 = bitcast i8* %249 to i32*
  store i32 %42, i32* %250
; # (Cld: hear (val Tell))
  %251 = getelementptr i8, i8* %243, i32 20
  %252 = bitcast i8* %251 to i32*
  %253 = load i32, i32* %9
  store i32 %253, i32* %252
; # (Cld: tell (val 2 Hear))
  %254 = getelementptr i8, i8* %243, i32 24
  %255 = bitcast i8* %254 to i32*
  %256 = getelementptr i32, i32* %8, i32 1
  %257 = load i32, i32* %256
  store i32 %257, i32* %255
; # (nonBlocking (Cld: tell (val 2 Hear)))
  %258 = call i32 @nonBlocking(i32 %257)
  br label %$14
$14:
  %259 = phi i32 [%188, %$39], [%234, %$43] ; # I
  %260 = phi i32 [%189, %$39], [%235, %$43] ; # N
  %261 = phi i32 [0, %$39], [%42, %$43] ; # ->
  ret i32 %261
}

define i64 @_pipe(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (++ X) Pfd (b32 2) Io: (ioFrame (b8 (ioFrame ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (b32 2)
  %8 = alloca i32, i64 2
; # (b8 (ioFrame T))
  %9 = alloca i8, i64 28
; # (when (lt0 (if (pair X) (pipe Pfd) (socketPair Pfd))) (pipeErr Ex...
; # (if (pair X) (pipe Pfd) (socketPair Pfd))
; # (pair X)
  %10 = and i64 %7, 15
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$2, label %$3
$2:
; # (pipe Pfd)
  %12 = call i32 @pipe(i32* %8)
  br label %$4
$3:
; # (socketPair Pfd)
  %13 = call i32 @socketPair(i32* %8)
  br label %$4
$4:
  %14 = phi i32 [%12, %$2], [%13, %$3] ; # ->
; # (lt0 (if (pair X) (pipe Pfd) (socketPair Pfd)))
  %15 = icmp slt i32 %14, 0
  br i1 %15, label %$5, label %$6
$5:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$6:
; # (when (< (val 2 Pfd) 2) (pipeErr Exe))
; # (val 2 Pfd)
  %16 = getelementptr i32, i32* %8, i32 1
  %17 = load i32, i32* %16
; # (< (val 2 Pfd) 2)
  %18 = icmp slt i32 %17, 2
  br i1 %18, label %$7, label %$8
$7:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$8:
; # (if (forkLisp Exe) (let Pid @ (close (val 2 Pfd)) (let Fd (val Pf...
; # (forkLisp Exe)
  %19 = call i32 @forkLisp(i64 %0)
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %$9, label %$10
$9:
; # (let Pid @ (close (val 2 Pfd)) (let Fd (val Pfd) (closeOnExec Exe...
; # (val 2 Pfd)
  %21 = getelementptr i32, i32* %8, i32 1
  %22 = load i32, i32* %21
; # (close (val 2 Pfd))
  %23 = call i32 @close(i32 %22)
; # (let Fd (val Pfd) (closeOnExec Exe Fd) (cond ((atom X) (initInFil...
; # (val Pfd)
  %24 = load i32, i32* %8
; # (closeOnExec Exe Fd)
  call void @closeOnExec(i64 %0, i32 %24)
; # (cond ((atom X) (initInFile Fd null) (initOutFile Fd) (cnt (i64 F...
; # (atom X)
  %25 = and i64 %7, 15
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$14, label %$13
$14:
; # (initInFile Fd null)
  %27 = call i8* @initInFile(i32 %24, i8* null)
; # (initOutFile Fd)
  %28 = call i8* @initOutFile(i32 %24)
; # (i64 Fd)
  %29 = sext i32 %24 to i64
; # (cnt (i64 Fd))
  %30 = shl i64 %29, 4
  %31 = or i64 %30, 2
  br label %$12
$13:
; # (setpgid Pid 0)
  %32 = call i32 @setpgid(i32 %19, i32 0)
; # (Io:)
; # (initInFile Fd null)
  %33 = call i8* @initInFile(i32 %24, i8* null)
; # (pushInFile (Io:) (initInFile Fd null) Pid)
  call void @pushInFile(i8* %9, i8* %33, i32 %19)
; # (prog1 (run X) (popInFiles) (tosInFile))
; # (run X)
  br label %$15
$15:
  %34 = phi i64 [%7, %$13], [%56, %$24] ; # Prg
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
  %37 = getelementptr i64, i64* %35, i32 1
  %38 = load i64, i64* %37
  %39 = and i64 %38, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$18, label %$16
$18:
  %41 = phi i64 [%38, %$15] ; # Prg
  %42 = and i64 %36, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$21, label %$20
$21:
  br label %$19
$20:
  %44 = and i64 %36, 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$23, label %$22
$23:
  %46 = inttoptr i64 %36 to i64*
  %47 = load i64, i64* %46
  br label %$19
$22:
  %48 = call i64 @evList(i64 %36)
  br label %$19
$19:
  %49 = phi i64 [%36, %$21], [%47, %$23], [%48, %$22] ; # ->
  br label %$17
$16:
  %50 = phi i64 [%38, %$15] ; # Prg
  %51 = and i64 %36, 15
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %$25, label %$24
$25:
  %53 = phi i64 [%50, %$16] ; # Prg
  %54 = call i64 @evList(i64 %36)
  %55 = icmp ne i64 %54, 0
  br label %$24
$24:
  %56 = phi i64 [%50, %$16], [%53, %$25] ; # Prg
  %57 = phi i1 [0, %$16], [%55, %$25] ; # ->
  br label %$15
$17:
  %58 = phi i64 [%41, %$19] ; # Prg
  %59 = phi i64 [%49, %$19] ; # ->
; # (popInFiles)
  call void @popInFiles()
; # (tosInFile)
  call void @tosInFile()
  br label %$12
$12:
  %60 = phi i64 [%31, %$14], [%59, %$17] ; # ->
  br label %$11
$10:
; # (val Pfd)
  %61 = load i32, i32* %8
; # (close (val Pfd))
  %62 = call i32 @close(i32 %61)
; # (let Fd (val 2 Pfd) (if (pair X) (setpgid 0 0) (dup2 Fd 0) ((inFi...
; # (val 2 Pfd)
  %63 = getelementptr i32, i32* %8, i32 1
  %64 = load i32, i32* %63
; # (if (pair X) (setpgid 0 0) (dup2 Fd 0) ((inFile (val (val $InFile...
; # (pair X)
  %65 = and i64 %7, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$26, label %$27
$26:
; # (setpgid 0 0)
  %67 = call i32 @setpgid(i32 0, i32 0)
  br label %$28
$27:
; # (dup2 Fd 0)
  %68 = call i32 @dup2(i32 %64, i32 0)
; # (val $InFiles)
  %69 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %70 = load i8*, i8** %69
; # ((inFile (val (val $InFiles))) tty NO)
  %71 = getelementptr i8, i8* %70, i32 4128
  %72 = bitcast i8* %71 to i1*
  store i1 0, i1* %72
  br label %$28
$28:
; # (dup2 Fd 1)
  %73 = call i32 @dup2(i32 %64, i32 1)
; # (close Fd)
  %74 = call i32 @close(i32 %64)
; # (val SIGPIPE Sig)
  %75 = getelementptr i32, i32* @Sig, i32 4
  %76 = load i32, i32* %75
; # (val SigDfl)
  %77 = load i8*, i8** @SigDfl
; # (signal (val SIGPIPE Sig) (val SigDfl))
  %78 = call i8* @signal(i32 %76, i8* %77)
; # (val $OutFile)
  %79 = load i8*, i8** @$OutFile
; # ((outFile (val $OutFile)) tty NO)
  %80 = getelementptr i8, i8* %79, i32 4104
  %81 = bitcast i8* %80 to i1*
  store i1 0, i1* %81
; # (Io:)
; # (val $OutFiles)
  %82 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %83 = getelementptr i8*, i8** %82, i32 1
  %84 = load i8*, i8** %83
; # (pushOutFile (Io:) (val 2 (val $OutFiles)) 0)
  call void @pushOutFile(i8* %9, i8* %84, i32 0)
; # (set $LinePtr null)
  store i8* null, i8** @$LinePtr
; # (when (pair E) (evList E))
; # (pair E)
  %85 = and i64 %5, 15
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$29, label %$30
$29:
; # (evList E)
  %87 = call i64 @evList(i64 %5)
  br label %$30
$30:
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$11:
  %88 = phi i64 [%60, %$12] ; # ->
  ret i64 %88
}

define i64 @_open(i64) align 8 {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) S (pathString Nm (b8 (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %6 = call i64 @pathSize(i64 %5)
; # (b8 (pathSize Nm))
  %7 = alloca i8, i64 %6
; # (pathString Nm (b8 (pathSize Nm)))
  %8 = call i8* @pathString(i64 %5, i8* %7)
; # (cadr X)
  %9 = inttoptr i64 %3 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
; # (eval (cadr X))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$4, label %$3
$4:
  br label %$2
$3:
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$6, label %$5
$6:
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
  br label %$2
$5:
  %20 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %21 = phi i64 [%13, %$4], [%19, %$6], [%20, %$5] ; # ->
; # (nil? (eval (cadr X)))
  %22 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (loop (? (ge0 (if Flg (openRdWrCreate S) (openRd S))) (closeOnExe...
  br label %$7
$7:
; # (? (ge0 (if Flg (openRdWrCreate S) (openRd S))) (closeOnExec Exe ...
; # (if Flg (openRdWrCreate S) (openRd S))
  br i1 %22, label %$8, label %$9
$8:
; # (openRdWrCreate S)
  %23 = call i32 @openRdWrCreate(i8* %8)
  br label %$10
$9:
; # (openRd S)
  %24 = call i32 @openRd(i8* %8)
  br label %$10
$10:
  %25 = phi i32 [%23, %$8], [%24, %$9] ; # ->
; # (ge0 (if Flg (openRdWrCreate S) (openRd S)))
  %26 = icmp sge i32 %25, 0
  br i1 %26, label %$13, label %$11
$13:
; # (closeOnExec Exe @)
  call void @closeOnExec(i64 %0, i32 %25)
; # (strdup S)
  %27 = call i8* @strdup(i8* %8)
; # (initInFile @ (strdup S))
  %28 = call i8* @initInFile(i32 %25, i8* %27)
; # (initOutFile @)
  %29 = call i8* @initOutFile(i32 %25)
; # (i64 @)
  %30 = sext i32 %25 to i64
; # (cnt (i64 @))
  %31 = shl i64 %30, 4
  %32 = or i64 %31, 2
  br label %$12
$11:
; # (? (<> (gErrno) EINTR) $Nil)
; # (gErrno)
  %33 = call i32 @gErrno()
; # (<> (gErrno) EINTR)
  %34 = icmp ne i32 %33, 2
  br i1 %34, label %$15, label %$14
$15:
  br label %$12
$14:
; # (sigChk Exe)
  %35 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %$16, label %$17
$16:
  call void @sighandler(i64 %0)
  br label %$17
$17:
  br label %$7
$12:
  %37 = phi i64 [%32, %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15] ; # ->
  ret i64 %37
}

define i64 @_close(i64) align 8 {
$1:
; # (let (X (eval (cadr Exe)) Fd (i32 (xCnt Exe X))) (loop (? (=0 (cl...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (xCnt Exe X)
  %14 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe X))
  %15 = trunc i64 %14 to i32
; # (loop (? (=0 (close Fd)) (closeInFile Fd) (closeOutFile Fd) X) (?...
  br label %$7
$7:
; # (? (=0 (close Fd)) (closeInFile Fd) (closeOutFile Fd) X)
; # (close Fd)
  %16 = call i32 @close(i32 %15)
; # (=0 (close Fd))
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %$10, label %$8
$10:
; # (closeInFile Fd)
  call void @closeInFile(i32 %15)
; # (closeOutFile Fd)
  call void @closeOutFile(i32 %15)
  br label %$9
$8:
; # (? (<> (gErrno) EINTR) $Nil)
; # (gErrno)
  %18 = call i32 @gErrno()
; # (<> (gErrno) EINTR)
  %19 = icmp ne i32 %18, 2
  br i1 %19, label %$12, label %$11
$12:
  br label %$9
$11:
; # (sigChk Exe)
  %20 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %$13, label %$14
$13:
  call void @sighandler(i64 %0)
  br label %$14
$14:
  br label %$7
$9:
  %22 = phi i64 [%13, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %22
}

define i64 @_echo(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((and (nil? Y) (atom X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((and (nil? Y) (atom X)) (let C (if (val $Chr) @ (call $Get...
; # (and (nil? Y) (atom X))
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i64 [%7, %$2] ; # X
  %18 = phi i64 [%15, %$2] ; # Y
; # (atom X)
  %19 = and i64 %17, 15
  %20 = icmp ne i64 %19, 0
  br label %$8
$8:
  %21 = phi i64 [%7, %$2], [%17, %$9] ; # X
  %22 = phi i64 [%15, %$2], [%18, %$9] ; # Y
  %23 = phi i1 [0, %$2], [%20, %$9] ; # ->
  br i1 %23, label %$11, label %$10
$11:
  %24 = phi i64 [%21, %$8] ; # X
  %25 = phi i64 [%22, %$8] ; # Y
; # (let C (if (val $Chr) @ (call $Get)) (until (lt0 C) (call $Put (i...
; # (if (val $Chr) @ (call $Get))
; # (val $Chr)
  %26 = load i32, i32* @$Chr
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$12, label %$13
$12:
  %28 = phi i64 [%24, %$11] ; # X
  %29 = phi i64 [%25, %$11] ; # Y
  br label %$14
$13:
  %30 = phi i64 [%24, %$11] ; # X
  %31 = phi i64 [%25, %$11] ; # Y
; # (call $Get)
  %32 = load i32()*, i32()** @$Get
  %33 = call i32 %32()
  br label %$14
$14:
  %34 = phi i64 [%28, %$12], [%30, %$13] ; # X
  %35 = phi i64 [%29, %$12], [%31, %$13] ; # Y
  %36 = phi i32 [%26, %$12], [%33, %$13] ; # ->
; # (until (lt0 C) (call $Put (i8 C)) (setq C (call $Get)))
  br label %$15
$15:
  %37 = phi i64 [%34, %$14], [%41, %$16] ; # X
  %38 = phi i64 [%35, %$14], [%42, %$16] ; # Y
  %39 = phi i32 [%36, %$14], [%47, %$16] ; # C
; # (lt0 C)
  %40 = icmp slt i32 %39, 0
  br i1 %40, label %$17, label %$16
$16:
  %41 = phi i64 [%37, %$15] ; # X
  %42 = phi i64 [%38, %$15] ; # Y
  %43 = phi i32 [%39, %$15] ; # C
; # (i8 C)
  %44 = trunc i32 %43 to i8
; # (call $Put (i8 C))
  %45 = load void(i8)*, void(i8)** @$Put
  call void %45(i8 %44)
; # (call $Get)
  %46 = load i32()*, i32()** @$Get
  %47 = call i32 %46()
  br label %$15
$17:
  %48 = phi i64 [%37, %$15] ; # X
  %49 = phi i64 [%38, %$15] ; # Y
  %50 = phi i32 [%39, %$15] ; # C
  br label %$7
$10:
  %51 = phi i64 [%21, %$8] ; # X
  %52 = phi i64 [%22, %$8] ; # Y
; # (num? Y)
  %53 = and i64 %52, 6
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$19, label %$18
$19:
  %55 = phi i64 [%51, %$10] ; # X
  %56 = phi i64 [%52, %$10] ; # Y
; # (let N (xCnt Exe Y) (when (pair X) (let C (evCnt Exe X) (while (g...
; # (xCnt Exe Y)
  %57 = call i64 @xCnt(i64 %0, i64 %56)
; # (when (pair X) (let C (evCnt Exe X) (while (ge0 (dec 'N)) (when (...
; # (pair X)
  %58 = and i64 %55, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$20, label %$21
$20:
  %60 = phi i64 [%55, %$19] ; # X
  %61 = phi i64 [%56, %$19] ; # Y
  %62 = phi i64 [%57, %$19] ; # N
; # (let C (evCnt Exe X) (while (ge0 (dec 'N)) (when (lt0 (call $Get)...
; # (evCnt Exe X)
  %63 = call i64 @evCnt(i64 %0, i64 %60)
; # (while (ge0 (dec 'N)) (when (lt0 (call $Get)) (ret $Nil)))
  br label %$22
$22:
  %64 = phi i64 [%60, %$20], [%78, %$26] ; # X
  %65 = phi i64 [%61, %$20], [%79, %$26] ; # Y
  %66 = phi i64 [%62, %$20], [%80, %$26] ; # N
; # (dec 'N)
  %67 = sub i64 %66, 1
; # (ge0 (dec 'N))
  %68 = icmp sge i64 %67, 0
  br i1 %68, label %$23, label %$24
$23:
  %69 = phi i64 [%64, %$22] ; # X
  %70 = phi i64 [%65, %$22] ; # Y
  %71 = phi i64 [%67, %$22] ; # N
; # (when (lt0 (call $Get)) (ret $Nil))
; # (call $Get)
  %72 = load i32()*, i32()** @$Get
  %73 = call i32 %72()
; # (lt0 (call $Get))
  %74 = icmp slt i32 %73, 0
  br i1 %74, label %$25, label %$26
$25:
  %75 = phi i64 [%69, %$23] ; # X
  %76 = phi i64 [%70, %$23] ; # Y
  %77 = phi i64 [%71, %$23] ; # N
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$26:
  %78 = phi i64 [%69, %$23] ; # X
  %79 = phi i64 [%70, %$23] ; # Y
  %80 = phi i64 [%71, %$23] ; # N
  br label %$22
$24:
  %81 = phi i64 [%64, %$22] ; # X
  %82 = phi i64 [%65, %$22] ; # Y
  %83 = phi i64 [%67, %$22] ; # N
  br label %$21
$21:
  %84 = phi i64 [%55, %$19], [%81, %$24] ; # X
  %85 = phi i64 [%56, %$19], [%82, %$24] ; # Y
  %86 = phi i64 [%57, %$19], [%63, %$24] ; # N
; # (while (ge0 (dec 'N)) (when (lt0 (call $Get)) (ret $Nil)) (call $...
  br label %$27
$27:
  %87 = phi i64 [%84, %$21], [%101, %$31] ; # X
  %88 = phi i64 [%85, %$21], [%102, %$31] ; # Y
  %89 = phi i64 [%86, %$21], [%103, %$31] ; # N
; # (dec 'N)
  %90 = sub i64 %89, 1
; # (ge0 (dec 'N))
  %91 = icmp sge i64 %90, 0
  br i1 %91, label %$28, label %$29
$28:
  %92 = phi i64 [%87, %$27] ; # X
  %93 = phi i64 [%88, %$27] ; # Y
  %94 = phi i64 [%90, %$27] ; # N
; # (when (lt0 (call $Get)) (ret $Nil))
; # (call $Get)
  %95 = load i32()*, i32()** @$Get
  %96 = call i32 %95()
; # (lt0 (call $Get))
  %97 = icmp slt i32 %96, 0
  br i1 %97, label %$30, label %$31
$30:
  %98 = phi i64 [%92, %$28] ; # X
  %99 = phi i64 [%93, %$28] ; # Y
  %100 = phi i64 [%94, %$28] ; # N
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$31:
  %101 = phi i64 [%92, %$28] ; # X
  %102 = phi i64 [%93, %$28] ; # Y
  %103 = phi i64 [%94, %$28] ; # N
; # (i8 @)
  %104 = trunc i32 %96 to i8
; # (call $Put (i8 @))
  %105 = load void(i8)*, void(i8)** @$Put
  call void %105(i8 %104)
  br label %$27
$29:
  %106 = phi i64 [%87, %$27] ; # X
  %107 = phi i64 [%88, %$27] ; # Y
  %108 = phi i64 [%90, %$27] ; # N
; # (set $Chr 0)
  store i32 0, i32* @$Chr
  br label %$7
$18:
  %109 = phi i64 [%51, %$10] ; # X
  %110 = phi i64 [%52, %$10] ; # Y
; # (pair Y)
  %111 = and i64 %110, 15
  %112 = icmp eq i64 %111, 0
  br i1 %112, label %$33, label %$32
$33:
  %113 = phi i64 [%109, %$18] ; # X
  %114 = phi i64 [%110, %$18] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %114)
  unreachable
$32:
  %115 = phi i64 [%109, %$18] ; # X
  %116 = phi i64 [%110, %$18] ; # Y
; # (let (M (i64* null) N 1 Nm (xName Exe Y) L (link (push Y NIL 0 (a...
; # (i64* null)
  %117 = inttoptr i64 0 to i64*
; # (xName Exe Y)
  %118 = call i64 @xName(i64 %0, i64 %116)
; # (bufSize Nm)
  %119 = call i64 @bufSize(i64 %118)
; # (b8 (bufSize Nm))
  %120 = alloca i8, i64 %119
; # (bufString Nm (b8 (bufSize Nm)))
  %121 = call i8* @bufString(i64 %118, i8* %120)
; # (any (bufString Nm (b8 (bufSize Nm))))
  %122 = ptrtoint i8* %121 to i64
; # (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm)))))
  %123 = alloca i64, i64 4, align 16
  %124 = ptrtoint i64* %123 to i64
  %125 = inttoptr i64 %124 to i64*
  store i64 %116, i64* %125
  %126 = add i64 %124, 16
  %127 = inttoptr i64 %126 to i64*
  store i64 0, i64* %127
  %128 = add i64 %124, 24
  %129 = inttoptr i64 %128 to i64*
  store i64 %122, i64* %129
; # (link (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm))))))
  %130 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %131 = load i64, i64* %130
  %132 = inttoptr i64 %124 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  store i64 %131, i64* %133
  %134 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %124, i64* %134
; # (while (pair X) (setq Y (evSym (++ X)) Nm (xName Exe Y) L (link (...
  br label %$34
$34:
  %135 = phi i64 [%115, %$32], [%152, %$35] ; # X
  %136 = phi i64 [%116, %$32], [%153, %$35] ; # Y
  %137 = phi i64* [%117, %$32], [%145, %$35] ; # M
  %138 = phi i64 [1, %$32], [%171, %$35] ; # N
  %139 = phi i64 [%118, %$32], [%154, %$35] ; # Nm
  %140 = phi i64 [%124, %$32], [%160, %$35] ; # L
; # (pair X)
  %141 = and i64 %135, 15
  %142 = icmp eq i64 %141, 0
  br i1 %142, label %$35, label %$36
$35:
  %143 = phi i64 [%135, %$34] ; # X
  %144 = phi i64 [%136, %$34] ; # Y
  %145 = phi i64* [%137, %$34] ; # M
  %146 = phi i64 [%138, %$34] ; # N
  %147 = phi i64 [%139, %$34] ; # Nm
  %148 = phi i64 [%140, %$34] ; # L
; # (++ X)
  %149 = inttoptr i64 %143 to i64*
  %150 = load i64, i64* %149
  %151 = getelementptr i64, i64* %149, i32 1
  %152 = load i64, i64* %151
; # (evSym (++ X))
  %153 = call i64 @evSym(i64 %150)
; # (xName Exe Y)
  %154 = call i64 @xName(i64 %0, i64 %153)
; # (bufSize Nm)
  %155 = call i64 @bufSize(i64 %154)
; # (b8 (bufSize Nm))
  %156 = alloca i8, i64 %155
; # (bufString Nm (b8 (bufSize Nm)))
  %157 = call i8* @bufString(i64 %154, i8* %156)
; # (any (bufString Nm (b8 (bufSize Nm))))
  %158 = ptrtoint i8* %157 to i64
; # (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm)))))
  %159 = alloca i64, i64 4, align 16
  %160 = ptrtoint i64* %159 to i64
  %161 = inttoptr i64 %160 to i64*
  store i64 %153, i64* %161
  %162 = add i64 %160, 16
  %163 = inttoptr i64 %162 to i64*
  store i64 0, i64* %163
  %164 = add i64 %160, 24
  %165 = inttoptr i64 %164 to i64*
  store i64 %158, i64* %165
; # (link (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm))))))
  %166 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %167 = load i64, i64* %166
  %168 = inttoptr i64 %160 to i64*
  %169 = getelementptr i64, i64* %168, i32 1
  store i64 %167, i64* %169
  %170 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %160, i64* %170
; # (inc 'N)
  %171 = add i64 %146, 1
  br label %$34
$36:
  %172 = phi i64 [%135, %$34] ; # X
  %173 = phi i64 [%136, %$34] ; # Y
  %174 = phi i64* [%137, %$34] ; # M
  %175 = phi i64 [%138, %$34] ; # N
  %176 = phi i64 [%139, %$34] ; # Nm
  %177 = phi i64 [%140, %$34] ; # L
; # (unless (val $Chr) (call $Get))
; # (val $Chr)
  %178 = load i32, i32* @$Chr
  %179 = icmp ne i32 %178, 0
  br i1 %179, label %$38, label %$37
$37:
  %180 = phi i64 [%172, %$36] ; # X
  %181 = phi i64 [%173, %$36] ; # Y
  %182 = phi i64* [%174, %$36] ; # M
  %183 = phi i64 [%175, %$36] ; # N
  %184 = phi i64 [%176, %$36] ; # Nm
  %185 = phi i64 [%177, %$36] ; # L
; # (call $Get)
  %186 = load i32()*, i32()** @$Get
  %187 = call i32 %186()
  br label %$38
$38:
  %188 = phi i64 [%172, %$36], [%180, %$37] ; # X
  %189 = phi i64 [%173, %$36], [%181, %$37] ; # Y
  %190 = phi i64* [%174, %$36], [%182, %$37] ; # M
  %191 = phi i64 [%175, %$36], [%183, %$37] ; # N
  %192 = phi i64 [%176, %$36], [%184, %$37] ; # Nm
  %193 = phi i64 [%177, %$36], [%185, %$37] ; # L
; # (while (ge0 (val $Chr)) (let (B (i8 @) Q (i64* L) I N OutM M OutC...
  br label %$39
$39:
  %194 = phi i64 [%188, %$38], [%802, %$79] ; # X
  %195 = phi i64 [%189, %$38], [%803, %$79] ; # Y
  %196 = phi i64* [%190, %$38], [%804, %$79] ; # M
  %197 = phi i64 [%191, %$38], [%805, %$79] ; # N
  %198 = phi i64 [%192, %$38], [%806, %$79] ; # Nm
  %199 = phi i64 [%193, %$38], [%807, %$79] ; # L
; # (val $Chr)
  %200 = load i32, i32* @$Chr
; # (ge0 (val $Chr))
  %201 = icmp sge i32 %200, 0
  br i1 %201, label %$40, label %$41
$40:
  %202 = phi i64 [%194, %$39] ; # X
  %203 = phi i64 [%195, %$39] ; # Y
  %204 = phi i64* [%196, %$39] ; # M
  %205 = phi i64 [%197, %$39] ; # N
  %206 = phi i64 [%198, %$39] ; # Nm
  %207 = phi i64 [%199, %$39] ; # L
; # (let (B (i8 @) Q (i64* L) I N OutM M OutC (if M (val 3 M) 0)) (lo...
; # (i8 @)
  %208 = trunc i32 %200 to i8
; # (i64* L)
  %209 = inttoptr i64 %207 to i64*
; # (if M (val 3 M) 0)
  %210 = icmp ne i64* %204, null
  br i1 %210, label %$42, label %$43
$42:
  %211 = phi i64 [%202, %$40] ; # X
  %212 = phi i64 [%203, %$40] ; # Y
  %213 = phi i64* [%204, %$40] ; # M
  %214 = phi i64 [%205, %$40] ; # N
  %215 = phi i64 [%206, %$40] ; # Nm
  %216 = phi i64 [%207, %$40] ; # L
  %217 = phi i64* [%209, %$40] ; # Q
  %218 = phi i64 [%205, %$40] ; # I
; # (val 3 M)
  %219 = getelementptr i64, i64* %213, i32 2
  %220 = load i64, i64* %219
  br label %$44
$43:
  %221 = phi i64 [%202, %$40] ; # X
  %222 = phi i64 [%203, %$40] ; # Y
  %223 = phi i64* [%204, %$40] ; # M
  %224 = phi i64 [%205, %$40] ; # N
  %225 = phi i64 [%206, %$40] ; # Nm
  %226 = phi i64 [%207, %$40] ; # L
  %227 = phi i64* [%209, %$40] ; # Q
  %228 = phi i64 [%205, %$40] ; # I
  br label %$44
$44:
  %229 = phi i64 [%211, %$42], [%221, %$43] ; # X
  %230 = phi i64 [%212, %$42], [%222, %$43] ; # Y
  %231 = phi i64* [%213, %$42], [%223, %$43] ; # M
  %232 = phi i64 [%214, %$42], [%224, %$43] ; # N
  %233 = phi i64 [%215, %$42], [%225, %$43] ; # Nm
  %234 = phi i64 [%216, %$42], [%226, %$43] ; # L
  %235 = phi i64* [%217, %$42], [%227, %$43] ; # Q
  %236 = phi i64 [%218, %$42], [%228, %$43] ; # I
  %237 = phi i64 [%220, %$42], [0, %$43] ; # ->
; # (loop (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (v...
  br label %$45
$45:
  %238 = phi i64 [%229, %$44], [%639, %$77] ; # X
  %239 = phi i64 [%230, %$44], [%640, %$77] ; # Y
  %240 = phi i64* [%231, %$44], [%641, %$77] ; # M
  %241 = phi i64 [%232, %$44], [%642, %$77] ; # N
  %242 = phi i64 [%233, %$44], [%643, %$77] ; # Nm
  %243 = phi i64 [%234, %$44], [%644, %$77] ; # L
  %244 = phi i64* [%235, %$44], [%650, %$77] ; # Q
  %245 = phi i64 [%236, %$44], [%646, %$77] ; # I
  %246 = phi i64 [%237, %$44], [%647, %$77] ; # OutC
; # (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S))...
  br label %$46
$46:
  %247 = phi i64 [%238, %$45], [%619, %$67] ; # X
  %248 = phi i64 [%239, %$45], [%620, %$67] ; # Y
  %249 = phi i64* [%240, %$45], [%621, %$67] ; # M
  %250 = phi i64 [%241, %$45], [%622, %$67] ; # N
  %251 = phi i64 [%242, %$45], [%623, %$67] ; # Nm
  %252 = phi i64 [%243, %$45], [%624, %$67] ; # L
  %253 = phi i64* [%244, %$45], [%625, %$67] ; # Q
  %254 = phi i64 [%245, %$45], [%626, %$67] ; # I
  %255 = phi i64 [%246, %$45], [%627, %$67] ; # OutC
; # (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S)) (set ...
; # (val 4 Q)
  %256 = getelementptr i64, i64* %253, i32 3
  %257 = load i64, i64* %256
; # (i8* (val 4 Q))
  %258 = inttoptr i64 %257 to i8*
; # (val 3 Q)
  %259 = getelementptr i64, i64* %253, i32 2
  %260 = load i64, i64* %259
; # (ofs (i8* (val 4 Q)) (val 3 Q))
  %261 = getelementptr i8, i8* %258, i64 %260
; # (when (== B (val S)) (set 3 Q (inc (val 3 Q))) (? (val 2 S) (unle...
; # (val S)
  %262 = load i8, i8* %261
; # (== B (val S))
  %263 = icmp eq i8 %208, %262
  br i1 %263, label %$47, label %$48
$47:
  %264 = phi i64 [%247, %$46] ; # X
  %265 = phi i64 [%248, %$46] ; # Y
  %266 = phi i64* [%249, %$46] ; # M
  %267 = phi i64 [%250, %$46] ; # N
  %268 = phi i64 [%251, %$46] ; # Nm
  %269 = phi i64 [%252, %$46] ; # L
  %270 = phi i64* [%253, %$46] ; # Q
  %271 = phi i64 [%254, %$46] ; # I
  %272 = phi i64 [%255, %$46] ; # OutC
  %273 = phi i8* [%261, %$46] ; # S
; # (set 3 Q (inc (val 3 Q)))
; # (val 3 Q)
  %274 = getelementptr i64, i64* %270, i32 2
  %275 = load i64, i64* %274
; # (inc (val 3 Q))
  %276 = add i64 %275, 1
  %277 = getelementptr i64, i64* %270, i32 2
  store i64 %276, i64* %277
; # (? (val 2 S) (unless (and M (>= (val 3 M) (val 3 Q))) (setq M Q))...
; # (val 2 S)
  %278 = getelementptr i8, i8* %273, i32 1
  %279 = load i8, i8* %278
  %280 = icmp ne i8 %279, 0
  br i1 %280, label %$51, label %$49
$51:
  %281 = phi i64 [%264, %$47] ; # X
  %282 = phi i64 [%265, %$47] ; # Y
  %283 = phi i64* [%266, %$47] ; # M
  %284 = phi i64 [%267, %$47] ; # N
  %285 = phi i64 [%268, %$47] ; # Nm
  %286 = phi i64 [%269, %$47] ; # L
  %287 = phi i64* [%270, %$47] ; # Q
  %288 = phi i64 [%271, %$47] ; # I
  %289 = phi i64 [%272, %$47] ; # OutC
  %290 = phi i8* [%273, %$47] ; # S
; # (unless (and M (>= (val 3 M) (val 3 Q))) (setq M Q))
; # (and M (>= (val 3 M) (val 3 Q)))
  %291 = icmp ne i64* %283, null
  br i1 %291, label %$53, label %$52
$53:
  %292 = phi i64 [%281, %$51] ; # X
  %293 = phi i64 [%282, %$51] ; # Y
  %294 = phi i64* [%283, %$51] ; # M
  %295 = phi i64 [%284, %$51] ; # N
  %296 = phi i64 [%285, %$51] ; # Nm
  %297 = phi i64 [%286, %$51] ; # L
  %298 = phi i64* [%287, %$51] ; # Q
  %299 = phi i64 [%288, %$51] ; # I
  %300 = phi i64 [%289, %$51] ; # OutC
  %301 = phi i8* [%290, %$51] ; # S
; # (val 3 M)
  %302 = getelementptr i64, i64* %294, i32 2
  %303 = load i64, i64* %302
; # (val 3 Q)
  %304 = getelementptr i64, i64* %298, i32 2
  %305 = load i64, i64* %304
; # (>= (val 3 M) (val 3 Q))
  %306 = icmp uge i64 %303, %305
  br label %$52
$52:
  %307 = phi i64 [%281, %$51], [%292, %$53] ; # X
  %308 = phi i64 [%282, %$51], [%293, %$53] ; # Y
  %309 = phi i64* [%283, %$51], [%294, %$53] ; # M
  %310 = phi i64 [%284, %$51], [%295, %$53] ; # N
  %311 = phi i64 [%285, %$51], [%296, %$53] ; # Nm
  %312 = phi i64 [%286, %$51], [%297, %$53] ; # L
  %313 = phi i64* [%287, %$51], [%298, %$53] ; # Q
  %314 = phi i64 [%288, %$51], [%299, %$53] ; # I
  %315 = phi i64 [%289, %$51], [%300, %$53] ; # OutC
  %316 = phi i8* [%290, %$51], [%301, %$53] ; # S
  %317 = phi i1 [0, %$51], [%306, %$53] ; # ->
  br i1 %317, label %$55, label %$54
$54:
  %318 = phi i64 [%307, %$52] ; # X
  %319 = phi i64 [%308, %$52] ; # Y
  %320 = phi i64* [%309, %$52] ; # M
  %321 = phi i64 [%310, %$52] ; # N
  %322 = phi i64 [%311, %$52] ; # Nm
  %323 = phi i64 [%312, %$52] ; # L
  %324 = phi i64* [%313, %$52] ; # Q
  %325 = phi i64 [%314, %$52] ; # I
  %326 = phi i64 [%315, %$52] ; # OutC
  %327 = phi i8* [%316, %$52] ; # S
  br label %$55
$55:
  %328 = phi i64 [%307, %$52], [%318, %$54] ; # X
  %329 = phi i64 [%308, %$52], [%319, %$54] ; # Y
  %330 = phi i64* [%309, %$52], [%324, %$54] ; # M
  %331 = phi i64 [%310, %$52], [%321, %$54] ; # N
  %332 = phi i64 [%311, %$52], [%322, %$54] ; # Nm
  %333 = phi i64 [%312, %$52], [%323, %$54] ; # L
  %334 = phi i64* [%313, %$52], [%324, %$54] ; # Q
  %335 = phi i64 [%314, %$52], [%325, %$54] ; # I
  %336 = phi i64 [%315, %$52], [%326, %$54] ; # OutC
  %337 = phi i8* [%316, %$52], [%327, %$54] ; # S
  br label %$50
$49:
  %338 = phi i64 [%264, %$47] ; # X
  %339 = phi i64 [%265, %$47] ; # Y
  %340 = phi i64* [%266, %$47] ; # M
  %341 = phi i64 [%267, %$47] ; # N
  %342 = phi i64 [%268, %$47] ; # Nm
  %343 = phi i64 [%269, %$47] ; # L
  %344 = phi i64* [%270, %$47] ; # Q
  %345 = phi i64 [%271, %$47] ; # I
  %346 = phi i64 [%272, %$47] ; # OutC
  %347 = phi i8* [%273, %$47] ; # S
; # (when OutM (setq S (i8* (val 4 OutM))) (dec 'OutC (val 3 Q)) (unt...
  %348 = icmp ne i64* %204, null
  br i1 %348, label %$56, label %$57
$56:
  %349 = phi i64 [%338, %$49] ; # X
  %350 = phi i64 [%339, %$49] ; # Y
  %351 = phi i64* [%340, %$49] ; # M
  %352 = phi i64 [%341, %$49] ; # N
  %353 = phi i64 [%342, %$49] ; # Nm
  %354 = phi i64 [%343, %$49] ; # L
  %355 = phi i64* [%344, %$49] ; # Q
  %356 = phi i64 [%345, %$49] ; # I
  %357 = phi i64 [%346, %$49] ; # OutC
  %358 = phi i8* [%347, %$49] ; # S
; # (val 4 OutM)
  %359 = getelementptr i64, i64* %204, i32 3
  %360 = load i64, i64* %359
; # (i8* (val 4 OutM))
  %361 = inttoptr i64 %360 to i8*
; # (val 3 Q)
  %362 = getelementptr i64, i64* %355, i32 2
  %363 = load i64, i64* %362
; # (dec 'OutC (val 3 Q))
  %364 = sub i64 %357, %363
; # (until (lt0 OutC) (call $Put (val S)) (inc 'S) (dec 'OutC))
  br label %$58
$58:
  %365 = phi i64 [%349, %$56], [%376, %$59] ; # X
  %366 = phi i64 [%350, %$56], [%377, %$59] ; # Y
  %367 = phi i64* [%351, %$56], [%378, %$59] ; # M
  %368 = phi i64 [%352, %$56], [%379, %$59] ; # N
  %369 = phi i64 [%353, %$56], [%380, %$59] ; # Nm
  %370 = phi i64 [%354, %$56], [%381, %$59] ; # L
  %371 = phi i64* [%355, %$56], [%382, %$59] ; # Q
  %372 = phi i64 [%356, %$56], [%383, %$59] ; # I
  %373 = phi i64 [%364, %$56], [%389, %$59] ; # OutC
  %374 = phi i8* [%361, %$56], [%388, %$59] ; # S
; # (lt0 OutC)
  %375 = icmp slt i64 %373, 0
  br i1 %375, label %$60, label %$59
$59:
  %376 = phi i64 [%365, %$58] ; # X
  %377 = phi i64 [%366, %$58] ; # Y
  %378 = phi i64* [%367, %$58] ; # M
  %379 = phi i64 [%368, %$58] ; # N
  %380 = phi i64 [%369, %$58] ; # Nm
  %381 = phi i64 [%370, %$58] ; # L
  %382 = phi i64* [%371, %$58] ; # Q
  %383 = phi i64 [%372, %$58] ; # I
  %384 = phi i64 [%373, %$58] ; # OutC
  %385 = phi i8* [%374, %$58] ; # S
; # (val S)
  %386 = load i8, i8* %385
; # (call $Put (val S))
  %387 = load void(i8)*, void(i8)** @$Put
  call void %387(i8 %386)
; # (inc 'S)
  %388 = getelementptr i8, i8* %385, i32 1
; # (dec 'OutC)
  %389 = sub i64 %384, 1
  br label %$58
$60:
  %390 = phi i64 [%365, %$58] ; # X
  %391 = phi i64 [%366, %$58] ; # Y
  %392 = phi i64* [%367, %$58] ; # M
  %393 = phi i64 [%368, %$58] ; # N
  %394 = phi i64 [%369, %$58] ; # Nm
  %395 = phi i64 [%370, %$58] ; # L
  %396 = phi i64* [%371, %$58] ; # Q
  %397 = phi i64 [%372, %$58] ; # I
  %398 = phi i64 [%373, %$58] ; # OutC
  %399 = phi i8* [%374, %$58] ; # S
  br label %$57
$57:
  %400 = phi i64 [%338, %$49], [%390, %$60] ; # X
  %401 = phi i64 [%339, %$49], [%391, %$60] ; # Y
  %402 = phi i64* [%340, %$49], [%392, %$60] ; # M
  %403 = phi i64 [%341, %$49], [%393, %$60] ; # N
  %404 = phi i64 [%342, %$49], [%394, %$60] ; # Nm
  %405 = phi i64 [%343, %$49], [%395, %$60] ; # L
  %406 = phi i64* [%344, %$49], [%396, %$60] ; # Q
  %407 = phi i64 [%345, %$49], [%397, %$60] ; # I
  %408 = phi i64 [%346, %$49], [%398, %$60] ; # OutC
  %409 = phi i8* [%347, %$49], [%399, %$60] ; # S
; # (set $Chr 0)
  store i32 0, i32* @$Chr
; # (drop P)
  %410 = inttoptr i64 %124 to i64*
  %411 = getelementptr i64, i64* %410, i32 1
  %412 = load i64, i64* %411
  %413 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %412, i64* %413
; # (val Q)
  %414 = load i64, i64* %406
; # (ret (val Q))
  ret i64 %414
$48:
  %415 = phi i64 [%247, %$46] ; # X
  %416 = phi i64 [%248, %$46] ; # Y
  %417 = phi i64* [%249, %$46] ; # M
  %418 = phi i64 [%250, %$46] ; # N
  %419 = phi i64 [%251, %$46] ; # Nm
  %420 = phi i64 [%252, %$46] ; # L
  %421 = phi i64* [%253, %$46] ; # Q
  %422 = phi i64 [%254, %$46] ; # I
  %423 = phi i64 [%255, %$46] ; # OutC
  %424 = phi i8* [%261, %$46] ; # S
; # (? (=0 (val 3 Q)))
; # (val 3 Q)
  %425 = getelementptr i64, i64* %421, i32 2
  %426 = load i64, i64* %425
; # (=0 (val 3 Q))
  %427 = icmp eq i64 %426, 0
  br i1 %427, label %$50, label %$61
$61:
  %428 = phi i64 [%415, %$48] ; # X
  %429 = phi i64 [%416, %$48] ; # Y
  %430 = phi i64* [%417, %$48] ; # M
  %431 = phi i64 [%418, %$48] ; # N
  %432 = phi i64 [%419, %$48] ; # Nm
  %433 = phi i64 [%420, %$48] ; # L
  %434 = phi i64* [%421, %$48] ; # Q
  %435 = phi i64 [%422, %$48] ; # I
  %436 = phi i64 [%423, %$48] ; # OutC
; # (let S (ofs (i8* (val 4 Q)) 1) (while (set 3 Q (dec (val 3 Q))) (...
; # (val 4 Q)
  %437 = getelementptr i64, i64* %434, i32 3
  %438 = load i64, i64* %437
; # (i8* (val 4 Q))
  %439 = inttoptr i64 %438 to i8*
; # (ofs (i8* (val 4 Q)) 1)
  %440 = getelementptr i8, i8* %439, i32 1
; # (while (set 3 Q (dec (val 3 Q))) (? (=0 (memcmp (i8* (val 4 Q)) S...
  br label %$62
$62:
  %441 = phi i64 [%428, %$61], [%471, %$65] ; # X
  %442 = phi i64 [%429, %$61], [%472, %$65] ; # Y
  %443 = phi i64* [%430, %$61], [%473, %$65] ; # M
  %444 = phi i64 [%431, %$61], [%474, %$65] ; # N
  %445 = phi i64 [%432, %$61], [%475, %$65] ; # Nm
  %446 = phi i64 [%433, %$61], [%476, %$65] ; # L
  %447 = phi i64* [%434, %$61], [%477, %$65] ; # Q
  %448 = phi i64 [%435, %$61], [%478, %$65] ; # I
  %449 = phi i64 [%436, %$61], [%479, %$65] ; # OutC
  %450 = phi i8* [%440, %$61], [%481, %$65] ; # S
; # (set 3 Q (dec (val 3 Q)))
; # (val 3 Q)
  %451 = getelementptr i64, i64* %447, i32 2
  %452 = load i64, i64* %451
; # (dec (val 3 Q))
  %453 = sub i64 %452, 1
  %454 = getelementptr i64, i64* %447, i32 2
  store i64 %453, i64* %454
  %455 = icmp ne i64 %453, 0
  br i1 %455, label %$63, label %$64
$63:
  %456 = phi i64 [%441, %$62] ; # X
  %457 = phi i64 [%442, %$62] ; # Y
  %458 = phi i64* [%443, %$62] ; # M
  %459 = phi i64 [%444, %$62] ; # N
  %460 = phi i64 [%445, %$62] ; # Nm
  %461 = phi i64 [%446, %$62] ; # L
  %462 = phi i64* [%447, %$62] ; # Q
  %463 = phi i64 [%448, %$62] ; # I
  %464 = phi i64 [%449, %$62] ; # OutC
  %465 = phi i8* [%450, %$62] ; # S
; # (? (=0 (memcmp (i8* (val 4 Q)) S @)))
; # (val 4 Q)
  %466 = getelementptr i64, i64* %462, i32 3
  %467 = load i64, i64* %466
; # (i8* (val 4 Q))
  %468 = inttoptr i64 %467 to i8*
; # (memcmp (i8* (val 4 Q)) S @)
  %469 = call i32 @memcmp(i8* %468, i8* %465, i64 %453)
; # (=0 (memcmp (i8* (val 4 Q)) S @))
  %470 = icmp eq i32 %469, 0
  br i1 %470, label %$64, label %$65
$65:
  %471 = phi i64 [%456, %$63] ; # X
  %472 = phi i64 [%457, %$63] ; # Y
  %473 = phi i64* [%458, %$63] ; # M
  %474 = phi i64 [%459, %$63] ; # N
  %475 = phi i64 [%460, %$63] ; # Nm
  %476 = phi i64 [%461, %$63] ; # L
  %477 = phi i64* [%462, %$63] ; # Q
  %478 = phi i64 [%463, %$63] ; # I
  %479 = phi i64 [%464, %$63] ; # OutC
  %480 = phi i8* [%465, %$63] ; # S
; # (inc 'S)
  %481 = getelementptr i8, i8* %480, i32 1
  br label %$62
$64:
  %482 = phi i64 [%441, %$62], [%456, %$63] ; # X
  %483 = phi i64 [%442, %$62], [%457, %$63] ; # Y
  %484 = phi i64* [%443, %$62], [%458, %$63] ; # M
  %485 = phi i64 [%444, %$62], [%459, %$63] ; # N
  %486 = phi i64 [%445, %$62], [%460, %$63] ; # Nm
  %487 = phi i64 [%446, %$62], [%461, %$63] ; # L
  %488 = phi i64* [%447, %$62], [%462, %$63] ; # Q
  %489 = phi i64 [%448, %$62], [%463, %$63] ; # I
  %490 = phi i64 [%449, %$62], [%464, %$63] ; # OutC
  %491 = phi i8* [%450, %$62], [%465, %$63] ; # S
; # (when (== Q M) (setq M (i64* null)) (let (Z (i64* L) J N) (loop (...
; # (== Q M)
  %492 = icmp eq i64* %488, %484
  br i1 %492, label %$66, label %$67
$66:
  %493 = phi i64 [%482, %$64] ; # X
  %494 = phi i64 [%483, %$64] ; # Y
  %495 = phi i64* [%484, %$64] ; # M
  %496 = phi i64 [%485, %$64] ; # N
  %497 = phi i64 [%486, %$64] ; # Nm
  %498 = phi i64 [%487, %$64] ; # L
  %499 = phi i64* [%488, %$64] ; # Q
  %500 = phi i64 [%489, %$64] ; # I
  %501 = phi i64 [%490, %$64] ; # OutC
; # (i64* null)
  %502 = inttoptr i64 0 to i64*
; # (let (Z (i64* L) J N) (loop (when (val 3 Z) (unless (and M (>= (v...
; # (i64* L)
  %503 = inttoptr i64 %498 to i64*
; # (loop (when (val 3 Z) (unless (and M (>= (val 3 M) (val 3 Z))) (s...
  br label %$68
$68:
  %504 = phi i64 [%493, %$66], [%593, %$75] ; # X
  %505 = phi i64 [%494, %$66], [%594, %$75] ; # Y
  %506 = phi i64* [%502, %$66], [%595, %$75] ; # M
  %507 = phi i64 [%496, %$66], [%596, %$75] ; # N
  %508 = phi i64 [%497, %$66], [%597, %$75] ; # Nm
  %509 = phi i64 [%498, %$66], [%598, %$75] ; # L
  %510 = phi i64* [%499, %$66], [%599, %$75] ; # Q
  %511 = phi i64 [%500, %$66], [%600, %$75] ; # I
  %512 = phi i64 [%501, %$66], [%601, %$75] ; # OutC
  %513 = phi i64* [%503, %$66], [%606, %$75] ; # Z
  %514 = phi i64 [%496, %$66], [%603, %$75] ; # J
; # (when (val 3 Z) (unless (and M (>= (val 3 M) (val 3 Z))) (setq M ...
; # (val 3 Z)
  %515 = getelementptr i64, i64* %513, i32 2
  %516 = load i64, i64* %515
  %517 = icmp ne i64 %516, 0
  br i1 %517, label %$69, label %$70
$69:
  %518 = phi i64 [%504, %$68] ; # X
  %519 = phi i64 [%505, %$68] ; # Y
  %520 = phi i64* [%506, %$68] ; # M
  %521 = phi i64 [%507, %$68] ; # N
  %522 = phi i64 [%508, %$68] ; # Nm
  %523 = phi i64 [%509, %$68] ; # L
  %524 = phi i64* [%510, %$68] ; # Q
  %525 = phi i64 [%511, %$68] ; # I
  %526 = phi i64 [%512, %$68] ; # OutC
  %527 = phi i64* [%513, %$68] ; # Z
  %528 = phi i64 [%514, %$68] ; # J
; # (unless (and M (>= (val 3 M) (val 3 Z))) (setq M Z))
; # (and M (>= (val 3 M) (val 3 Z)))
  %529 = icmp ne i64* %520, null
  br i1 %529, label %$72, label %$71
$72:
  %530 = phi i64 [%518, %$69] ; # X
  %531 = phi i64 [%519, %$69] ; # Y
  %532 = phi i64* [%520, %$69] ; # M
  %533 = phi i64 [%521, %$69] ; # N
  %534 = phi i64 [%522, %$69] ; # Nm
  %535 = phi i64 [%523, %$69] ; # L
  %536 = phi i64* [%524, %$69] ; # Q
  %537 = phi i64 [%525, %$69] ; # I
  %538 = phi i64 [%526, %$69] ; # OutC
  %539 = phi i64* [%527, %$69] ; # Z
  %540 = phi i64 [%528, %$69] ; # J
; # (val 3 M)
  %541 = getelementptr i64, i64* %532, i32 2
  %542 = load i64, i64* %541
; # (val 3 Z)
  %543 = getelementptr i64, i64* %539, i32 2
  %544 = load i64, i64* %543
; # (>= (val 3 M) (val 3 Z))
  %545 = icmp uge i64 %542, %544
  br label %$71
$71:
  %546 = phi i64 [%518, %$69], [%530, %$72] ; # X
  %547 = phi i64 [%519, %$69], [%531, %$72] ; # Y
  %548 = phi i64* [%520, %$69], [%532, %$72] ; # M
  %549 = phi i64 [%521, %$69], [%533, %$72] ; # N
  %550 = phi i64 [%522, %$69], [%534, %$72] ; # Nm
  %551 = phi i64 [%523, %$69], [%535, %$72] ; # L
  %552 = phi i64* [%524, %$69], [%536, %$72] ; # Q
  %553 = phi i64 [%525, %$69], [%537, %$72] ; # I
  %554 = phi i64 [%526, %$69], [%538, %$72] ; # OutC
  %555 = phi i64* [%527, %$69], [%539, %$72] ; # Z
  %556 = phi i64 [%528, %$69], [%540, %$72] ; # J
  %557 = phi i1 [0, %$69], [%545, %$72] ; # ->
  br i1 %557, label %$74, label %$73
$73:
  %558 = phi i64 [%546, %$71] ; # X
  %559 = phi i64 [%547, %$71] ; # Y
  %560 = phi i64* [%548, %$71] ; # M
  %561 = phi i64 [%549, %$71] ; # N
  %562 = phi i64 [%550, %$71] ; # Nm
  %563 = phi i64 [%551, %$71] ; # L
  %564 = phi i64* [%552, %$71] ; # Q
  %565 = phi i64 [%553, %$71] ; # I
  %566 = phi i64 [%554, %$71] ; # OutC
  %567 = phi i64* [%555, %$71] ; # Z
  %568 = phi i64 [%556, %$71] ; # J
  br label %$74
$74:
  %569 = phi i64 [%546, %$71], [%558, %$73] ; # X
  %570 = phi i64 [%547, %$71], [%559, %$73] ; # Y
  %571 = phi i64* [%548, %$71], [%567, %$73] ; # M
  %572 = phi i64 [%549, %$71], [%561, %$73] ; # N
  %573 = phi i64 [%550, %$71], [%562, %$73] ; # Nm
  %574 = phi i64 [%551, %$71], [%563, %$73] ; # L
  %575 = phi i64* [%552, %$71], [%564, %$73] ; # Q
  %576 = phi i64 [%553, %$71], [%565, %$73] ; # I
  %577 = phi i64 [%554, %$71], [%566, %$73] ; # OutC
  %578 = phi i64* [%555, %$71], [%567, %$73] ; # Z
  %579 = phi i64 [%556, %$71], [%568, %$73] ; # J
  br label %$70
$70:
  %580 = phi i64 [%504, %$68], [%569, %$74] ; # X
  %581 = phi i64 [%505, %$68], [%570, %$74] ; # Y
  %582 = phi i64* [%506, %$68], [%571, %$74] ; # M
  %583 = phi i64 [%507, %$68], [%572, %$74] ; # N
  %584 = phi i64 [%508, %$68], [%573, %$74] ; # Nm
  %585 = phi i64 [%509, %$68], [%574, %$74] ; # L
  %586 = phi i64* [%510, %$68], [%575, %$74] ; # Q
  %587 = phi i64 [%511, %$68], [%576, %$74] ; # I
  %588 = phi i64 [%512, %$68], [%577, %$74] ; # OutC
  %589 = phi i64* [%513, %$68], [%578, %$74] ; # Z
  %590 = phi i64 [%514, %$68], [%579, %$74] ; # J
; # (? (=0 (dec 'J)))
; # (dec 'J)
  %591 = sub i64 %590, 1
; # (=0 (dec 'J))
  %592 = icmp eq i64 %591, 0
  br i1 %592, label %$76, label %$75
$75:
  %593 = phi i64 [%580, %$70] ; # X
  %594 = phi i64 [%581, %$70] ; # Y
  %595 = phi i64* [%582, %$70] ; # M
  %596 = phi i64 [%583, %$70] ; # N
  %597 = phi i64 [%584, %$70] ; # Nm
  %598 = phi i64 [%585, %$70] ; # L
  %599 = phi i64* [%586, %$70] ; # Q
  %600 = phi i64 [%587, %$70] ; # I
  %601 = phi i64 [%588, %$70] ; # OutC
  %602 = phi i64* [%589, %$70] ; # Z
  %603 = phi i64 [%591, %$70] ; # J
; # (val 2 Z)
  %604 = getelementptr i64, i64* %602, i32 1
  %605 = load i64, i64* %604
; # (i64* (val 2 Z))
  %606 = inttoptr i64 %605 to i64*
  br label %$68
$76:
  %607 = phi i64 [%580, %$70] ; # X
  %608 = phi i64 [%581, %$70] ; # Y
  %609 = phi i64* [%582, %$70] ; # M
  %610 = phi i64 [%583, %$70] ; # N
  %611 = phi i64 [%584, %$70] ; # Nm
  %612 = phi i64 [%585, %$70] ; # L
  %613 = phi i64* [%586, %$70] ; # Q
  %614 = phi i64 [%587, %$70] ; # I
  %615 = phi i64 [%588, %$70] ; # OutC
  %616 = phi i64* [%589, %$70] ; # Z
  %617 = phi i64 [%591, %$70] ; # J
  %618 = phi i64 [0, %$70] ; # ->
  br label %$67
$67:
  %619 = phi i64 [%482, %$64], [%607, %$76] ; # X
  %620 = phi i64 [%483, %$64], [%608, %$76] ; # Y
  %621 = phi i64* [%484, %$64], [%609, %$76] ; # M
  %622 = phi i64 [%485, %$64], [%610, %$76] ; # N
  %623 = phi i64 [%486, %$64], [%611, %$76] ; # Nm
  %624 = phi i64 [%487, %$64], [%612, %$76] ; # L
  %625 = phi i64* [%488, %$64], [%613, %$76] ; # Q
  %626 = phi i64 [%489, %$64], [%614, %$76] ; # I
  %627 = phi i64 [%490, %$64], [%615, %$76] ; # OutC
  br label %$46
$50:
  %628 = phi i64 [%328, %$55], [%415, %$48] ; # X
  %629 = phi i64 [%329, %$55], [%416, %$48] ; # Y
  %630 = phi i64* [%330, %$55], [%417, %$48] ; # M
  %631 = phi i64 [%331, %$55], [%418, %$48] ; # N
  %632 = phi i64 [%332, %$55], [%419, %$48] ; # Nm
  %633 = phi i64 [%333, %$55], [%420, %$48] ; # L
  %634 = phi i64* [%334, %$55], [%421, %$48] ; # Q
  %635 = phi i64 [%335, %$55], [%422, %$48] ; # I
  %636 = phi i64 [%336, %$55], [%423, %$48] ; # OutC
; # (? (=0 (dec 'I)))
; # (dec 'I)
  %637 = sub i64 %635, 1
; # (=0 (dec 'I))
  %638 = icmp eq i64 %637, 0
  br i1 %638, label %$78, label %$77
$77:
  %639 = phi i64 [%628, %$50] ; # X
  %640 = phi i64 [%629, %$50] ; # Y
  %641 = phi i64* [%630, %$50] ; # M
  %642 = phi i64 [%631, %$50] ; # N
  %643 = phi i64 [%632, %$50] ; # Nm
  %644 = phi i64 [%633, %$50] ; # L
  %645 = phi i64* [%634, %$50] ; # Q
  %646 = phi i64 [%637, %$50] ; # I
  %647 = phi i64 [%636, %$50] ; # OutC
; # (val 2 Q)
  %648 = getelementptr i64, i64* %645, i32 1
  %649 = load i64, i64* %648
; # (i64* (val 2 Q))
  %650 = inttoptr i64 %649 to i64*
  br label %$45
$78:
  %651 = phi i64 [%628, %$50] ; # X
  %652 = phi i64 [%629, %$50] ; # Y
  %653 = phi i64* [%630, %$50] ; # M
  %654 = phi i64 [%631, %$50] ; # N
  %655 = phi i64 [%632, %$50] ; # Nm
  %656 = phi i64 [%633, %$50] ; # L
  %657 = phi i64* [%634, %$50] ; # Q
  %658 = phi i64 [%637, %$50] ; # I
  %659 = phi i64 [%636, %$50] ; # OutC
  %660 = phi i64 [0, %$50] ; # ->
; # (cond ((=0 M) (when OutM (let (S (i8* (val 4 OutM)) C OutC) (loop...
; # (=0 M)
  %661 = icmp eq i64* %653, null
  br i1 %661, label %$81, label %$80
$81:
  %662 = phi i64 [%651, %$78] ; # X
  %663 = phi i64 [%652, %$78] ; # Y
  %664 = phi i64* [%653, %$78] ; # M
  %665 = phi i64 [%654, %$78] ; # N
  %666 = phi i64 [%655, %$78] ; # Nm
  %667 = phi i64 [%656, %$78] ; # L
  %668 = phi i64* [%657, %$78] ; # Q
  %669 = phi i64 [%658, %$78] ; # I
  %670 = phi i64 [%659, %$78] ; # OutC
; # (when OutM (let (S (i8* (val 4 OutM)) C OutC) (loop (call $Put (v...
  %671 = icmp ne i64* %204, null
  br i1 %671, label %$82, label %$83
$82:
  %672 = phi i64 [%662, %$81] ; # X
  %673 = phi i64 [%663, %$81] ; # Y
  %674 = phi i64* [%664, %$81] ; # M
  %675 = phi i64 [%665, %$81] ; # N
  %676 = phi i64 [%666, %$81] ; # Nm
  %677 = phi i64 [%667, %$81] ; # L
  %678 = phi i64* [%668, %$81] ; # Q
  %679 = phi i64 [%669, %$81] ; # I
  %680 = phi i64 [%670, %$81] ; # OutC
; # (let (S (i8* (val 4 OutM)) C OutC) (loop (call $Put (val S)) (inc...
; # (val 4 OutM)
  %681 = getelementptr i64, i64* %204, i32 3
  %682 = load i64, i64* %681
; # (i8* (val 4 OutM))
  %683 = inttoptr i64 %682 to i8*
; # (loop (call $Put (val S)) (inc 'S) (? (=0 (dec 'C))))
  br label %$84
$84:
  %684 = phi i64 [%672, %$82], [%700, %$85] ; # X
  %685 = phi i64 [%673, %$82], [%701, %$85] ; # Y
  %686 = phi i64* [%674, %$82], [%702, %$85] ; # M
  %687 = phi i64 [%675, %$82], [%703, %$85] ; # N
  %688 = phi i64 [%676, %$82], [%704, %$85] ; # Nm
  %689 = phi i64 [%677, %$82], [%705, %$85] ; # L
  %690 = phi i64* [%678, %$82], [%706, %$85] ; # Q
  %691 = phi i64 [%679, %$82], [%707, %$85] ; # I
  %692 = phi i64 [%680, %$82], [%708, %$85] ; # OutC
  %693 = phi i8* [%683, %$82], [%709, %$85] ; # S
  %694 = phi i64 [%680, %$82], [%710, %$85] ; # C
; # (val S)
  %695 = load i8, i8* %693
; # (call $Put (val S))
  %696 = load void(i8)*, void(i8)** @$Put
  call void %696(i8 %695)
; # (inc 'S)
  %697 = getelementptr i8, i8* %693, i32 1
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %698 = sub i64 %694, 1
; # (=0 (dec 'C))
  %699 = icmp eq i64 %698, 0
  br i1 %699, label %$86, label %$85
$85:
  %700 = phi i64 [%684, %$84] ; # X
  %701 = phi i64 [%685, %$84] ; # Y
  %702 = phi i64* [%686, %$84] ; # M
  %703 = phi i64 [%687, %$84] ; # N
  %704 = phi i64 [%688, %$84] ; # Nm
  %705 = phi i64 [%689, %$84] ; # L
  %706 = phi i64* [%690, %$84] ; # Q
  %707 = phi i64 [%691, %$84] ; # I
  %708 = phi i64 [%692, %$84] ; # OutC
  %709 = phi i8* [%697, %$84] ; # S
  %710 = phi i64 [%698, %$84] ; # C
  br label %$84
$86:
  %711 = phi i64 [%684, %$84] ; # X
  %712 = phi i64 [%685, %$84] ; # Y
  %713 = phi i64* [%686, %$84] ; # M
  %714 = phi i64 [%687, %$84] ; # N
  %715 = phi i64 [%688, %$84] ; # Nm
  %716 = phi i64 [%689, %$84] ; # L
  %717 = phi i64* [%690, %$84] ; # Q
  %718 = phi i64 [%691, %$84] ; # I
  %719 = phi i64 [%692, %$84] ; # OutC
  %720 = phi i8* [%697, %$84] ; # S
  %721 = phi i64 [%698, %$84] ; # C
  %722 = phi i64 [0, %$84] ; # ->
  br label %$83
$83:
  %723 = phi i64 [%662, %$81], [%711, %$86] ; # X
  %724 = phi i64 [%663, %$81], [%712, %$86] ; # Y
  %725 = phi i64* [%664, %$81], [%713, %$86] ; # M
  %726 = phi i64 [%665, %$81], [%714, %$86] ; # N
  %727 = phi i64 [%666, %$81], [%715, %$86] ; # Nm
  %728 = phi i64 [%667, %$81], [%716, %$86] ; # L
  %729 = phi i64* [%668, %$81], [%717, %$86] ; # Q
  %730 = phi i64 [%669, %$81], [%718, %$86] ; # I
  %731 = phi i64 [%670, %$81], [%719, %$86] ; # OutC
; # (call $Put B)
  %732 = load void(i8)*, void(i8)** @$Put
  call void %732(i8 %208)
  br label %$79
$80:
  %733 = phi i64 [%651, %$78] ; # X
  %734 = phi i64 [%652, %$78] ; # Y
  %735 = phi i64* [%653, %$78] ; # M
  %736 = phi i64 [%654, %$78] ; # N
  %737 = phi i64 [%655, %$78] ; # Nm
  %738 = phi i64 [%656, %$78] ; # L
  %739 = phi i64* [%657, %$78] ; # Q
  %740 = phi i64 [%658, %$78] ; # I
  %741 = phi i64 [%659, %$78] ; # OutC
  %742 = icmp ne i64* %204, null
  br i1 %742, label %$88, label %$87
$88:
  %743 = phi i64 [%733, %$80] ; # X
  %744 = phi i64 [%734, %$80] ; # Y
  %745 = phi i64* [%735, %$80] ; # M
  %746 = phi i64 [%736, %$80] ; # N
  %747 = phi i64 [%737, %$80] ; # Nm
  %748 = phi i64 [%738, %$80] ; # L
  %749 = phi i64* [%739, %$80] ; # Q
  %750 = phi i64 [%740, %$80] ; # I
  %751 = phi i64 [%741, %$80] ; # OutC
; # (let S (i8* (val 4 OutM)) (dec 'OutC (val 3 M)) (until (lt0 OutC)...
; # (val 4 OutM)
  %752 = getelementptr i64, i64* %204, i32 3
  %753 = load i64, i64* %752
; # (i8* (val 4 OutM))
  %754 = inttoptr i64 %753 to i8*
; # (val 3 M)
  %755 = getelementptr i64, i64* %745, i32 2
  %756 = load i64, i64* %755
; # (dec 'OutC (val 3 M))
  %757 = sub i64 %751, %756
; # (until (lt0 OutC) (call $Put (val S)) (inc 'S) (dec 'OutC))
  br label %$89
$89:
  %758 = phi i64 [%743, %$88], [%769, %$90] ; # X
  %759 = phi i64 [%744, %$88], [%770, %$90] ; # Y
  %760 = phi i64* [%745, %$88], [%771, %$90] ; # M
  %761 = phi i64 [%746, %$88], [%772, %$90] ; # N
  %762 = phi i64 [%747, %$88], [%773, %$90] ; # Nm
  %763 = phi i64 [%748, %$88], [%774, %$90] ; # L
  %764 = phi i64* [%749, %$88], [%775, %$90] ; # Q
  %765 = phi i64 [%750, %$88], [%776, %$90] ; # I
  %766 = phi i64 [%757, %$88], [%782, %$90] ; # OutC
  %767 = phi i8* [%754, %$88], [%781, %$90] ; # S
; # (lt0 OutC)
  %768 = icmp slt i64 %766, 0
  br i1 %768, label %$91, label %$90
$90:
  %769 = phi i64 [%758, %$89] ; # X
  %770 = phi i64 [%759, %$89] ; # Y
  %771 = phi i64* [%760, %$89] ; # M
  %772 = phi i64 [%761, %$89] ; # N
  %773 = phi i64 [%762, %$89] ; # Nm
  %774 = phi i64 [%763, %$89] ; # L
  %775 = phi i64* [%764, %$89] ; # Q
  %776 = phi i64 [%765, %$89] ; # I
  %777 = phi i64 [%766, %$89] ; # OutC
  %778 = phi i8* [%767, %$89] ; # S
; # (val S)
  %779 = load i8, i8* %778
; # (call $Put (val S))
  %780 = load void(i8)*, void(i8)** @$Put
  call void %780(i8 %779)
; # (inc 'S)
  %781 = getelementptr i8, i8* %778, i32 1
; # (dec 'OutC)
  %782 = sub i64 %777, 1
  br label %$89
$91:
  %783 = phi i64 [%758, %$89] ; # X
  %784 = phi i64 [%759, %$89] ; # Y
  %785 = phi i64* [%760, %$89] ; # M
  %786 = phi i64 [%761, %$89] ; # N
  %787 = phi i64 [%762, %$89] ; # Nm
  %788 = phi i64 [%763, %$89] ; # L
  %789 = phi i64* [%764, %$89] ; # Q
  %790 = phi i64 [%765, %$89] ; # I
  %791 = phi i64 [%766, %$89] ; # OutC
  %792 = phi i8* [%767, %$89] ; # S
  br label %$79
$87:
  %793 = phi i64 [%733, %$80] ; # X
  %794 = phi i64 [%734, %$80] ; # Y
  %795 = phi i64* [%735, %$80] ; # M
  %796 = phi i64 [%736, %$80] ; # N
  %797 = phi i64 [%737, %$80] ; # Nm
  %798 = phi i64 [%738, %$80] ; # L
  %799 = phi i64* [%739, %$80] ; # Q
  %800 = phi i64 [%740, %$80] ; # I
  %801 = phi i64 [%741, %$80] ; # OutC
  br label %$79
$79:
  %802 = phi i64 [%723, %$83], [%783, %$91], [%793, %$87] ; # X
  %803 = phi i64 [%724, %$83], [%784, %$91], [%794, %$87] ; # Y
  %804 = phi i64* [%725, %$83], [%785, %$91], [%795, %$87] ; # M
  %805 = phi i64 [%726, %$83], [%786, %$91], [%796, %$87] ; # N
  %806 = phi i64 [%727, %$83], [%787, %$91], [%797, %$87] ; # Nm
  %807 = phi i64 [%728, %$83], [%788, %$91], [%798, %$87] ; # L
  %808 = phi i64* [%729, %$83], [%789, %$91], [%799, %$87] ; # Q
  %809 = phi i64 [%730, %$83], [%790, %$91], [%800, %$87] ; # I
  %810 = phi i64 [%731, %$83], [%791, %$91], [%801, %$87] ; # OutC
; # (call $Get)
  %811 = load i32()*, i32()** @$Get
  %812 = call i32 %811()
  br label %$39
$41:
  %813 = phi i64 [%194, %$39] ; # X
  %814 = phi i64 [%195, %$39] ; # Y
  %815 = phi i64* [%196, %$39] ; # M
  %816 = phi i64 [%197, %$39] ; # N
  %817 = phi i64 [%198, %$39] ; # Nm
  %818 = phi i64 [%199, %$39] ; # L
; # (drop P)
  %819 = inttoptr i64 %124 to i64*
  %820 = getelementptr i64, i64* %819, i32 1
  %821 = load i64, i64* %820
  %822 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %821, i64* %822
  br label %$7
$7:
  %823 = phi i64 [%48, %$17], [%106, %$29], [%813, %$41] ; # X
  %824 = phi i64 [%49, %$17], [%107, %$29], [%814, %$41] ; # Y
  %825 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$29], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$41] ; # ->
  ret i64 %825
}

define void @_putStdout(i8) align 8 {
$1:
; # (let Out: (outFile (val $OutFile)) (when (Out:) (let I (Out: ix) ...
; # (val $OutFile)
  %1 = load i8*, i8** @$OutFile
; # (when (Out:) (let I (Out: ix) (when (== I BUFSIZ) (Out: ix (setq ...
; # (Out:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$2, label %$3
$2:
; # (let I (Out: ix) (when (== I BUFSIZ) (Out: ix (setq I 0)) (wrByte...
; # (Out: ix)
  %3 = getelementptr i8, i8* %1, i32 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (when (== I BUFSIZ) (Out: ix (setq I 0)) (wrBytes (Out: fd) (Out:...
; # (== I BUFSIZ)
  %6 = icmp eq i32 %5, 4096
  br i1 %6, label %$4, label %$5
$4:
  %7 = phi i32 [%5, %$2] ; # I
; # (Out: ix (setq I 0))
  %8 = getelementptr i8, i8* %1, i32 4
  %9 = bitcast i8* %8 to i32*
  store i32 0, i32* %9
; # (Out: fd)
  %10 = bitcast i8* %1 to i32*
  %11 = load i32, i32* %10
; # (Out: (buf))
  %12 = getelementptr i8, i8* %1, i32 8
; # (wrBytes (Out: fd) (Out: (buf)) BUFSIZ)
  %13 = call i1 @wrBytes(i32 %11, i8* %12, i32 4096)
  br label %$5
$5:
  %14 = phi i32 [%5, %$2], [0, %$4] ; # I
; # (set (ofs (Out: (buf)) I) B)
; # (Out: (buf))
  %15 = getelementptr i8, i8* %1, i32 8
; # (ofs (Out: (buf)) I)
  %16 = getelementptr i8, i8* %15, i32 %14
  store i8 %0, i8* %16
; # (Out: ix (inc 'I))
  %17 = getelementptr i8, i8* %1, i32 4
  %18 = bitcast i8* %17 to i32*
  %19 = add i32 %14, 1
  store i32 %19, i32* %18
; # (when (and (== B (char "^J")) (Out: tty)) (Out: ix 0) (wrBytes (O...
; # (and (== B (char "^J")) (Out: tty))
; # (== B (char "^J"))
  %20 = icmp eq i8 %0, 10
  br i1 %20, label %$7, label %$6
$7:
  %21 = phi i32 [%19, %$5] ; # I
; # (Out: tty)
  %22 = getelementptr i8, i8* %1, i32 4104
  %23 = bitcast i8* %22 to i1*
  %24 = load i1, i1* %23
  br label %$6
$6:
  %25 = phi i32 [%19, %$5], [%21, %$7] ; # I
  %26 = phi i1 [0, %$5], [%24, %$7] ; # ->
  br i1 %26, label %$8, label %$9
$8:
  %27 = phi i32 [%25, %$6] ; # I
; # (Out: ix 0)
  %28 = getelementptr i8, i8* %1, i32 4
  %29 = bitcast i8* %28 to i32*
  store i32 0, i32* %29
; # (Out: fd)
  %30 = bitcast i8* %1 to i32*
  %31 = load i32, i32* %30
; # (Out: (buf))
  %32 = getelementptr i8, i8* %1, i32 8
; # (wrBytes (Out: fd) (Out: (buf)) I)
  %33 = call i1 @wrBytes(i32 %31, i8* %32, i32 %27)
  br label %$9
$9:
  %34 = phi i32 [%25, %$6], [%27, %$8] ; # I
  br label %$3
$3:
  ret void
}

define void @newline() align 8 {
$1:
; # (call $Put (char "^J"))
  %0 = load void(i8)*, void(i8)** @$Put
  call void %0(i8 10)
  ret void
}

define void @space() align 8 {
$1:
; # (call $Put (char " "))
  %0 = load void(i8)*, void(i8)** @$Put
  call void %0(i8 32)
  ret void
}

define void @outWord(i64) align 8 {
$1:
; # (when (> N 9) (outWord (/ N 10)) (setq N (% N 10)))
; # (> N 9)
  %1 = icmp ugt i64 %0, 9
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i64 [%0, %$1] ; # N
; # (/ N 10)
  %3 = udiv i64 %2, 10
; # (outWord (/ N 10))
  call void @outWord(i64 %3)
; # (% N 10)
  %4 = urem i64 %2, 10
  br label %$3
$3:
  %5 = phi i64 [%0, %$1], [%4, %$2] ; # N
; # (i8 N)
  %6 = trunc i64 %5 to i8
; # (+ (i8 N) (char "0"))
  %7 = add i8 %6, 48
; # (call $Put (+ (i8 N) (char "0")))
  %8 = load void(i8)*, void(i8)** @$Put
  call void %8(i8 %7)
  ret void
}

define void @outNum(i64) align 8 {
$1:
; # (when (sign? X) (call $Put (char "-")))
; # (sign? X)
  %1 = and i64 %0, 8
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (call $Put (char "-"))
  %3 = load void(i8)*, void(i8)** @$Put
  call void %3(i8 45)
  br label %$3
$3:
; # (i64 X)
; # (shr (i64 X) 4)
  %4 = lshr i64 %0, 4
; # (outWord (shr (i64 X) 4))
  call void @outWord(i64 %4)
  ret void
}

define void @outOct(i64) align 8 {
$1:
; # (when (> N 7) (outOct (shr N 3)) (setq N (& N 7)))
; # (> N 7)
  %1 = icmp ugt i64 %0, 7
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i64 [%0, %$1] ; # N
; # (shr N 3)
  %3 = lshr i64 %2, 3
; # (outOct (shr N 3))
  call void @outOct(i64 %3)
; # (& N 7)
  %4 = and i64 %2, 7
  br label %$3
$3:
  %5 = phi i64 [%0, %$1], [%4, %$2] ; # N
; # (i8 N)
  %6 = trunc i64 %5 to i8
; # (+ (i8 N) (char "0"))
  %7 = add i8 %6, 48
; # (call $Put (+ (i8 N) (char "0")))
  %8 = load void(i8)*, void(i8)** @$Put
  call void %8(i8 %7)
  ret void
}

define void @outAo(i32) align 8 {
$1:
; # (when (> N 15) (outAo (shr N 4)) (setq N (& N 15)))
; # (> N 15)
  %1 = icmp sgt i32 %0, 15
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i32 [%0, %$1] ; # N
; # (shr N 4)
  %3 = lshr i32 %2, 4
; # (outAo (shr N 4))
  call void @outAo(i32 %3)
; # (& N 15)
  %4 = and i32 %2, 15
  br label %$3
$3:
  %5 = phi i32 [%0, %$1], [%4, %$2] ; # N
; # (i8 N)
  %6 = trunc i32 %5 to i8
; # (+ (i8 N) (char "@"))
  %7 = add i8 %6, 64
; # (call $Put (+ (i8 N) (char "@")))
  %8 = load void(i8)*, void(i8)** @$Put
  call void %8(i8 %7)
  ret void
}

define i8* @bufAo(i8*, i32) align 8 {
$1:
; # (when (> N 15) (setq P (bufAo P (shr N 4)) N (& N 15)))
; # (> N 15)
  %2 = icmp sgt i32 %1, 15
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i8* [%0, %$1] ; # P
  %4 = phi i32 [%1, %$1] ; # N
; # (shr N 4)
  %5 = lshr i32 %4, 4
; # (bufAo P (shr N 4))
  %6 = call i8* @bufAo(i8* %3, i32 %5)
; # (& N 15)
  %7 = and i32 %4, 15
  br label %$3
$3:
  %8 = phi i8* [%0, %$1], [%6, %$2] ; # P
  %9 = phi i32 [%1, %$1], [%7, %$2] ; # N
; # (set P (+ (i8 N) (char "@")))
; # (i8 N)
  %10 = trunc i32 %9 to i8
; # (+ (i8 N) (char "@"))
  %11 = add i8 %10, 64
  store i8 %11, i8* %8
; # (inc P)
  %12 = getelementptr i8, i8* %8, i32 1
  ret i8* %12
}

define void @prExt(i64) align 8 {
$1:
; # (when (objFile Nm) (outAo @))
; # (objFile Nm)
  %1 = call i32 @objFile(i64 %0)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (outAo @)
  call void @outAo(i32 %1)
  br label %$3
$3:
; # (objId Nm)
  %3 = call i64 @objId(i64 %0)
; # (outOct (objId Nm))
  call void @outOct(i64 %3)
  ret void
}

define void @outString(i8*) align 8 {
$1:
; # (while (val S) (call $Put @) (inc 'S))
  br label %$2
$2:
  %1 = phi i8* [%0, %$1], [%6, %$3] ; # S
; # (val S)
  %2 = load i8, i8* %1
  %3 = icmp ne i8 %2, 0
  br i1 %3, label %$3, label %$4
$3:
  %4 = phi i8* [%1, %$2] ; # S
; # (call $Put @)
  %5 = load void(i8)*, void(i8)** @$Put
  call void %5(i8 %2)
; # (inc 'S)
  %6 = getelementptr i8, i8* %4, i32 1
  br label %$2
$4:
  %7 = phi i8* [%1, %$2] ; # S
  ret void
}

define void @prName(i64) align 8 {
$1:
; # (let P (push 0 Nm) (while (symByte P) (call $Put @)))
; # (push 0 Nm)
  %1 = alloca i64, i64 2, align 16
  store i64 0, i64* %1
  %2 = getelementptr i64, i64* %1, i32 1
  store i64 %0, i64* %2
; # (while (symByte P) (call $Put @))
  br label %$2
$2:
; # (symByte P)
  %3 = call i8 @symByte(i64* %1)
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %$3, label %$4
$3:
; # (call $Put @)
  %5 = load void(i8)*, void(i8)** @$Put
  call void %5(i8 %3)
  br label %$2
$4:
  ret void
}

define void @prSym(i64) align 8 {
$1:
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (name (val (tail Sym)))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%10, %$3] ; # Tail
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$4, label %$3
$3:
  %7 = phi i64 [%4, %$2] ; # Tail
  %8 = inttoptr i64 %7 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  br label %$2
$4:
  %11 = phi i64 [%4, %$2] ; # Tail
; # (prName (name (val (tail Sym))))
  call void @prName(i64 %11)
  ret void
}

define void @printName(i64) align 8 {
$1:
; # (ifn (== Nm (hex "2E2")) (let (P (push 0 Nm) B (symByte P)) (when...
; # (== Nm (hex "2E2"))
  %1 = icmp eq i64 %0, 738
  br i1 %1, label %$3, label %$2
$2:
; # (let (P (push 0 Nm) B (symByte P)) (when (== B (char "#")) (call ...
; # (push 0 Nm)
  %2 = alloca i64, i64 2, align 16
  store i64 0, i64* %2
  %3 = getelementptr i64, i64* %2, i32 1
  store i64 %0, i64* %3
; # (symByte P)
  %4 = call i8 @symByte(i64* %2)
; # (when (== B (char "#")) (call $Put (char "\\")))
; # (== B (char "#"))
  %5 = icmp eq i8 %4, 35
  br i1 %5, label %$5, label %$6
$5:
  %6 = phi i8 [%4, %$2] ; # B
; # (call $Put (char "\\"))
  %7 = load void(i8)*, void(i8)** @$Put
  call void %7(i8 92)
  br label %$6
$6:
  %8 = phi i8 [%4, %$2], [%6, %$5] ; # B
; # (loop (when (or (== B (char "\\")) (strchr $Delim (i32 B))) (call...
  br label %$7
$7:
  %9 = phi i8 [%8, %$6], [%23, %$12] ; # B
; # (when (or (== B (char "\\")) (strchr $Delim (i32 B))) (call $Put ...
; # (or (== B (char "\\")) (strchr $Delim (i32 B)))
; # (== B (char "\\"))
  %10 = icmp eq i8 %9, 92
  br i1 %10, label %$8, label %$9
$9:
  %11 = phi i8 [%9, %$7] ; # B
; # (i32 B)
  %12 = zext i8 %11 to i32
; # (strchr $Delim (i32 B))
  %13 = call i8* @strchr(i8* bitcast ([16 x i8]* @$Delim to i8*), i32 %12)
  %14 = icmp ne i8* %13, null
  br label %$8
$8:
  %15 = phi i8 [%9, %$7], [%11, %$9] ; # B
  %16 = phi i1 [1, %$7], [%14, %$9] ; # ->
  br i1 %16, label %$10, label %$11
$10:
  %17 = phi i8 [%15, %$8] ; # B
; # (call $Put (char "\\"))
  %18 = load void(i8)*, void(i8)** @$Put
  call void %18(i8 92)
  br label %$11
$11:
  %19 = phi i8 [%15, %$8], [%17, %$10] ; # B
; # (call $Put B)
  %20 = load void(i8)*, void(i8)** @$Put
  call void %20(i8 %19)
; # (? (=0 (setq B (symByte P))))
; # (symByte P)
  %21 = call i8 @symByte(i64* %2)
; # (=0 (setq B (symByte P)))
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %$13, label %$12
$12:
  %23 = phi i8 [%21, %$11] ; # B
  br label %$7
$13:
  %24 = phi i8 [%21, %$11] ; # B
  %25 = phi i64 [0, %$11] ; # ->
  br label %$4
$3:
; # (call $Put (char "\\"))
  %26 = load void(i8)*, void(i8)** @$Put
  call void %26(i8 92)
; # (call $Put (char "."))
  %27 = load void(i8)*, void(i8)** @$Put
  call void %27(i8 46)
  br label %$4
$4:
  ret void
}

define void @printSym(i64) align 8 {
$1:
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (name (val (tail Sym)))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%10, %$3] ; # Tail
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$4, label %$3
$3:
  %7 = phi i64 [%4, %$2] ; # Tail
  %8 = inttoptr i64 %7 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  br label %$2
$4:
  %11 = phi i64 [%4, %$2] ; # Tail
; # (printName (name (val (tail Sym))))
  call void @printName(i64 %11)
  ret void
}

define void @print(i64) align 8 {
$1:
; # (sigChk 0)
  %1 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  call void @sighandler(i64 0)
  br label %$3
$3:
; # (cond ((cnt? X) (outNum X)) ((big? X) (fmtNum X -1 0 0 null)) ((s...
; # (cnt? X)
  %3 = and i64 %0, 2
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$6, label %$5
$6:
  %5 = phi i64 [%0, %$3] ; # X
; # (outNum X)
  call void @outNum(i64 %5)
  br label %$4
$5:
  %6 = phi i64 [%0, %$3] ; # X
; # (big? X)
  %7 = and i64 %6, 4
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$8, label %$7
$8:
  %9 = phi i64 [%6, %$5] ; # X
; # (fmtNum X -1 0 0 null)
  %10 = call i64 @fmtNum(i64 %9, i64 -1, i8 0, i8 0, i64* null)
  br label %$4
$7:
  %11 = phi i64 [%6, %$5] ; # X
; # (sym? X)
  %12 = and i64 %11, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$10, label %$9
$10:
  %14 = phi i64 [%11, %$7] ; # X
; # (cond ((sym? (val (tail X))) (call $Put (char "{")) (prExt (name ...
; # (tail X)
  %15 = add i64 %14, -8
; # (val (tail X))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (sym? (val (tail X)))
  %18 = and i64 %17, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$13, label %$12
$13:
  %20 = phi i64 [%14, %$10] ; # X
; # (call $Put (char "{"))
  %21 = load void(i8)*, void(i8)** @$Put
  call void %21(i8 123)
; # (& @ -9)
  %22 = and i64 %17, -9
; # (name (& @ -9))
  br label %$14
$14:
  %23 = phi i64 [%22, %$13], [%29, %$15] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$16, label %$15
$15:
  %26 = phi i64 [%23, %$14] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$14
$16:
  %30 = phi i64 [%23, %$14] ; # Tail
; # (prExt (name (& @ -9)))
  call void @prExt(i64 %30)
; # (call $Put (char "}"))
  %31 = load void(i8)*, void(i8)** @$Put
  call void %31(i8 125)
  br label %$11
$12:
  %32 = phi i64 [%14, %$10] ; # X
; # (name @)
  br label %$17
$17:
  %33 = phi i64 [%17, %$12], [%39, %$18] ; # Tail
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$19, label %$18
$18:
  %36 = phi i64 [%33, %$17] ; # Tail
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  br label %$17
$19:
  %40 = phi i64 [%33, %$17] ; # Tail
; # (== (name @) ZERO)
  %41 = icmp eq i64 %40, 2
  br i1 %41, label %$21, label %$20
$21:
  %42 = phi i64 [%32, %$19] ; # X
; # (call $Put (char "$"))
  %43 = load void(i8)*, void(i8)** @$Put
  call void %43(i8 36)
; # (int X)
  %44 = lshr i64 %42, 4
; # (outOct (int X))
  call void @outOct(i64 %44)
  br label %$11
$20:
  %45 = phi i64 [%32, %$19] ; # X
; # (let Nm @ (ifn (== X (isIntern Nm $PrivT)) (let (Lst (val $Intern...
; # (ifn (== X (isIntern Nm $PrivT)) (let (Lst (val $Intern) F NO) (l...
; # (isIntern Nm $PrivT)
  %46 = call i64 @isIntern(i64 %40, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64))
; # (== X (isIntern Nm $PrivT))
  %47 = icmp eq i64 %45, %46
  br i1 %47, label %$23, label %$22
$22:
  %48 = phi i64 [%45, %$20] ; # X
; # (let (Lst (val $Intern) F NO) (loop (? (atom Lst) (call $Put (cha...
; # (val $Intern)
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
; # (loop (? (atom Lst) (call $Put (char "\"")) (let (P (push 0 Nm) B...
  br label %$25
$25:
  %51 = phi i64 [%48, %$22], [%159, %$43] ; # X
  %52 = phi i64 [%50, %$22], [%164, %$43] ; # Lst
  %53 = phi i1 [0, %$22], [%161, %$43] ; # F
; # (? (atom Lst) (call $Put (char "\"")) (let (P (push 0 Nm) B (symB...
; # (atom Lst)
  %54 = and i64 %52, 15
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$28, label %$26
$28:
  %56 = phi i64 [%51, %$25] ; # X
  %57 = phi i64 [%52, %$25] ; # Lst
  %58 = phi i1 [%53, %$25] ; # F
; # (call $Put (char "\""))
  %59 = load void(i8)*, void(i8)** @$Put
  call void %59(i8 34)
; # (let (P (push 0 Nm) B (symByte P)) (loop (cond ((or (== B (char "...
; # (push 0 Nm)
  %60 = alloca i64, i64 2, align 16
  store i64 0, i64* %60
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %40, i64* %61
; # (symByte P)
  %62 = call i8 @symByte(i64* %60)
; # (loop (cond ((or (== B (char "\\")) (== B (char "\^")) (== B (cha...
  br label %$29
$29:
  %63 = phi i64 [%56, %$28], [%120, %$40] ; # X
  %64 = phi i64 [%57, %$28], [%121, %$40] ; # Lst
  %65 = phi i1 [%58, %$28], [%122, %$40] ; # F
  %66 = phi i8 [%62, %$28], [%123, %$40] ; # B
; # (cond ((or (== B (char "\\")) (== B (char "\^")) (== B (char "\""...
; # (or (== B (char "\\")) (== B (char "\^")) (== B (char "\"")))
; # (== B (char "\\"))
  %67 = icmp eq i8 %66, 92
  br i1 %67, label %$31, label %$32
$32:
  %68 = phi i64 [%63, %$29] ; # X
  %69 = phi i64 [%64, %$29] ; # Lst
  %70 = phi i1 [%65, %$29] ; # F
  %71 = phi i8 [%66, %$29] ; # B
; # (== B (char "\^"))
  %72 = icmp eq i8 %71, 94
  br i1 %72, label %$31, label %$33
$33:
  %73 = phi i64 [%68, %$32] ; # X
  %74 = phi i64 [%69, %$32] ; # Lst
  %75 = phi i1 [%70, %$32] ; # F
  %76 = phi i8 [%71, %$32] ; # B
; # (== B (char "\""))
  %77 = icmp eq i8 %76, 34
  br label %$31
$31:
  %78 = phi i64 [%63, %$29], [%68, %$32], [%73, %$33] ; # X
  %79 = phi i64 [%64, %$29], [%69, %$32], [%74, %$33] ; # Lst
  %80 = phi i1 [%65, %$29], [%70, %$32], [%75, %$33] ; # F
  %81 = phi i8 [%66, %$29], [%71, %$32], [%76, %$33] ; # B
  %82 = phi i1 [1, %$29], [1, %$32], [%77, %$33] ; # ->
  br i1 %82, label %$35, label %$34
$35:
  %83 = phi i64 [%78, %$31] ; # X
  %84 = phi i64 [%79, %$31] ; # Lst
  %85 = phi i1 [%80, %$31] ; # F
  %86 = phi i8 [%81, %$31] ; # B
; # (call $Put (char "\\"))
  %87 = load void(i8)*, void(i8)** @$Put
  call void %87(i8 92)
  br label %$30
$34:
  %88 = phi i64 [%78, %$31] ; # X
  %89 = phi i64 [%79, %$31] ; # Lst
  %90 = phi i1 [%80, %$31] ; # F
  %91 = phi i8 [%81, %$31] ; # B
; # (== B 127)
  %92 = icmp eq i8 %91, 127
  br i1 %92, label %$37, label %$36
$37:
  %93 = phi i64 [%88, %$34] ; # X
  %94 = phi i64 [%89, %$34] ; # Lst
  %95 = phi i1 [%90, %$34] ; # F
  %96 = phi i8 [%91, %$34] ; # B
; # (call $Put (char "\^"))
  %97 = load void(i8)*, void(i8)** @$Put
  call void %97(i8 94)
  br label %$30
$36:
  %98 = phi i64 [%88, %$34] ; # X
  %99 = phi i64 [%89, %$34] ; # Lst
  %100 = phi i1 [%90, %$34] ; # F
  %101 = phi i8 [%91, %$34] ; # B
; # (> 32 B)
  %102 = icmp ugt i8 32, %101
  br i1 %102, label %$39, label %$38
$39:
  %103 = phi i64 [%98, %$36] ; # X
  %104 = phi i64 [%99, %$36] ; # Lst
  %105 = phi i1 [%100, %$36] ; # F
  %106 = phi i8 [%101, %$36] ; # B
; # (call $Put (char "\^"))
  %107 = load void(i8)*, void(i8)** @$Put
  call void %107(i8 94)
; # (| B 64)
  %108 = or i8 %106, 64
  br label %$30
$38:
  %109 = phi i64 [%98, %$36] ; # X
  %110 = phi i64 [%99, %$36] ; # Lst
  %111 = phi i1 [%100, %$36] ; # F
  %112 = phi i8 [%101, %$36] ; # B
  br label %$30
$30:
  %113 = phi i64 [%83, %$35], [%93, %$37], [%103, %$39], [%109, %$38] ; # X
  %114 = phi i64 [%84, %$35], [%94, %$37], [%104, %$39], [%110, %$38] ; # Lst
  %115 = phi i1 [%85, %$35], [%95, %$37], [%105, %$39], [%111, %$38] ; # F
  %116 = phi i8 [%86, %$35], [63, %$37], [%108, %$39], [%112, %$38] ; # B
; # (call $Put B)
  %117 = load void(i8)*, void(i8)** @$Put
  call void %117(i8 %116)
; # (? (=0 (setq B (symByte P))))
; # (symByte P)
  %118 = call i8 @symByte(i64* %60)
; # (=0 (setq B (symByte P)))
  %119 = icmp eq i8 %118, 0
  br i1 %119, label %$41, label %$40
$40:
  %120 = phi i64 [%113, %$30] ; # X
  %121 = phi i64 [%114, %$30] ; # Lst
  %122 = phi i1 [%115, %$30] ; # F
  %123 = phi i8 [%118, %$30] ; # B
  br label %$29
$41:
  %124 = phi i64 [%113, %$30] ; # X
  %125 = phi i64 [%114, %$30] ; # Lst
  %126 = phi i1 [%115, %$30] ; # F
  %127 = phi i8 [%118, %$30] ; # B
  %128 = phi i64 [0, %$30] ; # ->
; # (call $Put (char "\""))
  %129 = load void(i8)*, void(i8)** @$Put
  call void %129(i8 34)
  br label %$27
$26:
  %130 = phi i64 [%51, %$25] ; # X
  %131 = phi i64 [%52, %$25] ; # Lst
  %132 = phi i1 [%53, %$25] ; # F
; # (let Nsp (car Lst) (when (isIntern Nm (cdar Nsp)) (? (== @ X) (wh...
; # (car Lst)
  %133 = inttoptr i64 %131 to i64*
  %134 = load i64, i64* %133
; # (when (isIntern Nm (cdar Nsp)) (? (== @ X) (when F (printSym Nsp)...
; # (cdar Nsp)
  %135 = inttoptr i64 %134 to i64*
  %136 = load i64, i64* %135
  %137 = inttoptr i64 %136 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
; # (isIntern Nm (cdar Nsp))
  %140 = call i64 @isIntern(i64 %40, i64 %139)
  %141 = icmp ne i64 %140, 0
  br i1 %141, label %$42, label %$43
$42:
  %142 = phi i64 [%130, %$26] ; # X
  %143 = phi i64 [%131, %$26] ; # Lst
  %144 = phi i1 [%132, %$26] ; # F
; # (? (== @ X) (when F (printSym Nsp) (call $Put (char "~"))) (print...
; # (== @ X)
  %145 = icmp eq i64 %140, %142
  br i1 %145, label %$45, label %$44
$45:
  %146 = phi i64 [%142, %$42] ; # X
  %147 = phi i64 [%143, %$42] ; # Lst
  %148 = phi i1 [%144, %$42] ; # F
; # (when F (printSym Nsp) (call $Put (char "~")))
  br i1 %148, label %$46, label %$47
$46:
  %149 = phi i64 [%146, %$45] ; # X
  %150 = phi i64 [%147, %$45] ; # Lst
  %151 = phi i1 [%148, %$45] ; # F
; # (printSym Nsp)
  call void @printSym(i64 %134)
; # (call $Put (char "~"))
  %152 = load void(i8)*, void(i8)** @$Put
  call void %152(i8 126)
  br label %$47
$47:
  %153 = phi i64 [%146, %$45], [%149, %$46] ; # X
  %154 = phi i64 [%147, %$45], [%150, %$46] ; # Lst
  %155 = phi i1 [%148, %$45], [%151, %$46] ; # F
; # (printName Nm)
  call void @printName(i64 %40)
  br label %$27
$44:
  %156 = phi i64 [%142, %$42] ; # X
  %157 = phi i64 [%143, %$42] ; # Lst
  %158 = phi i1 [%144, %$42] ; # F
  br label %$43
$43:
  %159 = phi i64 [%130, %$26], [%156, %$44] ; # X
  %160 = phi i64 [%131, %$26], [%157, %$44] ; # Lst
  %161 = phi i1 [%132, %$26], [1, %$44] ; # F
; # (shift Lst)
  %162 = inttoptr i64 %160 to i64*
  %163 = getelementptr i64, i64* %162, i32 1
  %164 = load i64, i64* %163
  br label %$25
$27:
  %165 = phi i64 [%124, %$41], [%153, %$47] ; # X
  %166 = phi i64 [%125, %$41], [%154, %$47] ; # Lst
  %167 = phi i1 [%126, %$41], [%155, %$47] ; # F
  br label %$24
$23:
  %168 = phi i64 [%45, %$20] ; # X
; # (outString ($ "priv~"))
  call void @outString(i8* bitcast ([6 x i8]* @$44 to i8*))
; # (printName Nm)
  call void @printName(i64 %40)
  br label %$24
$24:
  %169 = phi i64 [%165, %$27], [%168, %$23] ; # X
  br label %$11
$11:
  %170 = phi i64 [%20, %$16], [%42, %$21], [%169, %$24] ; # X
  br label %$4
$9:
  %171 = phi i64 [%11, %$7] ; # X
; # (and (== (car X) $Quote) (<> X (cdr X)))
; # (car X)
  %172 = inttoptr i64 %171 to i64*
  %173 = load i64, i64* %172
; # (== (car X) $Quote)
  %174 = icmp eq i64 %173, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 264) to i64)
  br i1 %174, label %$49, label %$48
$49:
  %175 = phi i64 [%171, %$9] ; # X
; # (cdr X)
  %176 = inttoptr i64 %175 to i64*
  %177 = getelementptr i64, i64* %176, i32 1
  %178 = load i64, i64* %177
; # (<> X (cdr X))
  %179 = icmp ne i64 %175, %178
  br label %$48
$48:
  %180 = phi i64 [%171, %$9], [%175, %$49] ; # X
  %181 = phi i1 [0, %$9], [%179, %$49] ; # ->
  br i1 %181, label %$51, label %$50
$51:
  %182 = phi i64 [%180, %$48] ; # X
; # (call $Put (char "'"))
  %183 = load void(i8)*, void(i8)** @$Put
  call void %183(i8 39)
; # (cdr X)
  %184 = inttoptr i64 %182 to i64*
  %185 = getelementptr i64, i64* %184, i32 1
  %186 = load i64, i64* %185
; # (print (cdr X))
  call void @print(i64 %186)
  br label %$4
$50:
  %187 = phi i64 [%180, %$48] ; # X
; # (stkChk 0)
  %188 = load i8*, i8** @$StkLimit
  %189 = call i8* @llvm.stacksave()
  %190 = icmp ugt i8* %188, %189
  br i1 %190, label %$52, label %$53
$52:
  call void @stkErr(i64 0)
  unreachable
$53:
; # (call $Put (char "("))
  %191 = load void(i8)*, void(i8)** @$Put
  call void %191(i8 40)
; # (let P (circ X) (ifn P (loop (print (car X)) (? (nil? (shift X)))...
; # (circ X)
  %192 = call i64 @circ(i64 %187)
; # (ifn P (loop (print (car X)) (? (nil? (shift X))) (? (atom X) (ou...
  %193 = icmp ne i64 %192, 0
  br i1 %193, label %$55, label %$54
$54:
  %194 = phi i64 [%187, %$53] ; # X
; # (loop (print (car X)) (? (nil? (shift X))) (? (atom X) (outString...
  br label %$57
$57:
  %195 = phi i64 [%194, %$54], [%206, %$60] ; # X
; # (car X)
  %196 = inttoptr i64 %195 to i64*
  %197 = load i64, i64* %196
; # (print (car X))
  call void @print(i64 %197)
; # (? (nil? (shift X)))
; # (shift X)
  %198 = inttoptr i64 %195 to i64*
  %199 = getelementptr i64, i64* %198, i32 1
  %200 = load i64, i64* %199
; # (nil? (shift X))
  %201 = icmp eq i64 %200, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %201, label %$59, label %$58
$58:
  %202 = phi i64 [%200, %$57] ; # X
; # (? (atom X) (outString ($ " . ")) (print X))
; # (atom X)
  %203 = and i64 %202, 15
  %204 = icmp ne i64 %203, 0
  br i1 %204, label %$61, label %$60
$61:
  %205 = phi i64 [%202, %$58] ; # X
; # (outString ($ " . "))
  call void @outString(i8* bitcast ([4 x i8]* @$45 to i8*))
; # (print X)
  call void @print(i64 %205)
  br label %$59
$60:
  %206 = phi i64 [%202, %$58] ; # X
; # (space)
  call void @space()
  br label %$57
$59:
  %207 = phi i64 [%200, %$57], [%205, %$61] ; # X
  br label %$56
$55:
  %208 = phi i64 [%187, %$53] ; # X
; # (let Flg (== P X) (loop (print (car X)) (space) (? (== P (shift X...
; # (== P X)
  %209 = icmp eq i64 %192, %208
; # (loop (print (car X)) (space) (? (== P (shift X))))
  br label %$62
$62:
  %210 = phi i64 [%208, %$55], [%217, %$63] ; # X
; # (car X)
  %211 = inttoptr i64 %210 to i64*
  %212 = load i64, i64* %211
; # (print (car X))
  call void @print(i64 %212)
; # (space)
  call void @space()
; # (? (== P (shift X)))
; # (shift X)
  %213 = inttoptr i64 %210 to i64*
  %214 = getelementptr i64, i64* %213, i32 1
  %215 = load i64, i64* %214
; # (== P (shift X))
  %216 = icmp eq i64 %192, %215
  br i1 %216, label %$64, label %$63
$63:
  %217 = phi i64 [%215, %$62] ; # X
  br label %$62
$64:
  %218 = phi i64 [%215, %$62] ; # X
  %219 = phi i64 [0, %$62] ; # ->
; # (call $Put (char "."))
  %220 = load void(i8)*, void(i8)** @$Put
  call void %220(i8 46)
; # (unless Flg (space) (call $Put (char "(")) (loop (print (car X)) ...
  br i1 %209, label %$66, label %$65
$65:
  %221 = phi i64 [%218, %$64] ; # X
; # (space)
  call void @space()
; # (call $Put (char "("))
  %222 = load void(i8)*, void(i8)** @$Put
  call void %222(i8 40)
; # (loop (print (car X)) (space) (? (== P (shift X))))
  br label %$67
$67:
  %223 = phi i64 [%221, %$65], [%230, %$68] ; # X
; # (car X)
  %224 = inttoptr i64 %223 to i64*
  %225 = load i64, i64* %224
; # (print (car X))
  call void @print(i64 %225)
; # (space)
  call void @space()
; # (? (== P (shift X)))
; # (shift X)
  %226 = inttoptr i64 %223 to i64*
  %227 = getelementptr i64, i64* %226, i32 1
  %228 = load i64, i64* %227
; # (== P (shift X))
  %229 = icmp eq i64 %192, %228
  br i1 %229, label %$69, label %$68
$68:
  %230 = phi i64 [%228, %$67] ; # X
  br label %$67
$69:
  %231 = phi i64 [%228, %$67] ; # X
  %232 = phi i64 [0, %$67] ; # ->
; # (call $Put (char "."))
  %233 = load void(i8)*, void(i8)** @$Put
  call void %233(i8 46)
; # (call $Put (char ")"))
  %234 = load void(i8)*, void(i8)** @$Put
  call void %234(i8 41)
  br label %$66
$66:
  %235 = phi i64 [%218, %$64], [%231, %$69] ; # X
  br label %$56
$56:
  %236 = phi i64 [%207, %$59], [%235, %$66] ; # X
; # (call $Put (char ")"))
  %237 = load void(i8)*, void(i8)** @$Put
  call void %237(i8 41)
  br label %$4
$4:
  %238 = phi i64 [%5, %$6], [%9, %$8], [%170, %$11], [%182, %$51], [%236, %$56] ; # X
  ret void
}

define void @prin(i64) align 8 {
$1:
; # (sigChk 0)
  %1 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  call void @sighandler(i64 0)
  br label %$3
$3:
; # (unless (nil? X) (cond ((cnt? X) (outNum X)) ((big? X) (fmtNum X ...
; # (nil? X)
  %3 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$5, label %$4
$4:
  %4 = phi i64 [%0, %$3] ; # X
; # (cond ((cnt? X) (outNum X)) ((big? X) (fmtNum X -1 0 0 null)) ((p...
; # (cnt? X)
  %5 = and i64 %4, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$8, label %$7
$8:
  %7 = phi i64 [%4, %$4] ; # X
; # (outNum X)
  call void @outNum(i64 %7)
  br label %$6
$7:
  %8 = phi i64 [%4, %$4] ; # X
; # (big? X)
  %9 = and i64 %8, 4
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$10, label %$9
$10:
  %11 = phi i64 [%8, %$7] ; # X
; # (fmtNum X -1 0 0 null)
  %12 = call i64 @fmtNum(i64 %11, i64 -1, i8 0, i8 0, i64* null)
  br label %$6
$9:
  %13 = phi i64 [%8, %$7] ; # X
; # (pair X)
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$12, label %$11
$12:
  %16 = phi i64 [%13, %$9] ; # X
; # (stkChk 0)
  %17 = load i8*, i8** @$StkLimit
  %18 = call i8* @llvm.stacksave()
  %19 = icmp ugt i8* %17, %18
  br i1 %19, label %$13, label %$14
$13:
  call void @stkErr(i64 0)
  unreachable
$14:
; # (loop (prin (car X)) (? (nil? (shift X))) (? (atom X) (prin X)))
  br label %$15
$15:
  %20 = phi i64 [%16, %$14], [%31, %$18] ; # X
; # (car X)
  %21 = inttoptr i64 %20 to i64*
  %22 = load i64, i64* %21
; # (prin (car X))
  call void @prin(i64 %22)
; # (? (nil? (shift X)))
; # (shift X)
  %23 = inttoptr i64 %20 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (nil? (shift X))
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %26, label %$17, label %$16
$16:
  %27 = phi i64 [%25, %$15] ; # X
; # (? (atom X) (prin X))
; # (atom X)
  %28 = and i64 %27, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$19, label %$18
$19:
  %30 = phi i64 [%27, %$16] ; # X
; # (prin X)
  call void @prin(i64 %30)
  br label %$17
$18:
  %31 = phi i64 [%27, %$16] ; # X
  br label %$15
$17:
  %32 = phi i64 [%25, %$15], [%30, %$19] ; # X
  br label %$6
$11:
  %33 = phi i64 [%13, %$9] ; # X
; # (tail X)
  %34 = add i64 %33, -8
; # (val (tail X))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (sym? (val (tail X)))
  %37 = and i64 %36, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$21, label %$20
$21:
  %39 = phi i64 [%33, %$11] ; # X
; # (call $Put (char "{"))
  %40 = load void(i8)*, void(i8)** @$Put
  call void %40(i8 123)
; # (& @ -9)
  %41 = and i64 %36, -9
; # (name (& @ -9))
  br label %$22
$22:
  %42 = phi i64 [%41, %$21], [%48, %$23] ; # Tail
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$24, label %$23
$23:
  %45 = phi i64 [%42, %$22] ; # Tail
  %46 = inttoptr i64 %45 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
  br label %$22
$24:
  %49 = phi i64 [%42, %$22] ; # Tail
; # (prExt (name (& @ -9)))
  call void @prExt(i64 %49)
; # (call $Put (char "}"))
  %50 = load void(i8)*, void(i8)** @$Put
  call void %50(i8 125)
  br label %$6
$20:
  %51 = phi i64 [%33, %$11] ; # X
; # (name @)
  br label %$25
$25:
  %52 = phi i64 [%36, %$20], [%58, %$26] ; # Tail
  %53 = and i64 %52, 6
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$27, label %$26
$26:
  %55 = phi i64 [%52, %$25] ; # Tail
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  br label %$25
$27:
  %59 = phi i64 [%52, %$25] ; # Tail
; # (prName (name @))
  call void @prName(i64 %59)
  br label %$6
$6:
  %60 = phi i64 [%7, %$8], [%11, %$10], [%32, %$17], [%39, %$24], [%51, %$27] ; # X
  br label %$5
$5:
  %61 = phi i64 [%0, %$3], [%60, %$6] ; # X
  ret void
}

define i64 @_prin(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (++ X)) (prin Y) (? (atom X) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (++ X)) (prin Y) (? (atom X) Y)))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%20, %$8] ; # X
; # (let Y (eval (++ X)) (prin Y) (? (atom X) Y))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (prin Y)
  call void @prin(i64 %16)
; # (? (atom X) Y)
; # (atom X)
  %17 = and i64 %8, 15
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$8
$10:
  %19 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %20 = phi i64 [%8, %$3] ; # X
  br label %$2
$9:
  %21 = phi i64 [%19, %$10] ; # X
  %22 = phi i64 [%16, %$10] ; # ->
  ret i64 %22
}

define i64 @_prinl(i64) align 8 {
$1:
; # (prog1 (_prin Exe) (newline))
; # (_prin Exe)
  %1 = call i64 @_prin(i64 %0)
; # (newline)
  call void @newline()
  ret i64 %1
}

define i64 @_space(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (ifn (nil? X) (let N (xCnt Exe X) (while...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (ifn (nil? X) (let N (xCnt Exe X) (while (ge0 (dec 'N)) (space)) ...
; # (nil? X)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$8, label %$7
$7:
; # (let N (xCnt Exe X) (while (ge0 (dec 'N)) (space)) X)
; # (xCnt Exe X)
  %15 = call i64 @xCnt(i64 %0, i64 %13)
; # (while (ge0 (dec 'N)) (space))
  br label %$10
$10:
  %16 = phi i64 [%15, %$7], [%19, %$11] ; # N
; # (dec 'N)
  %17 = sub i64 %16, 1
; # (ge0 (dec 'N))
  %18 = icmp sge i64 %17, 0
  br i1 %18, label %$11, label %$12
$11:
  %19 = phi i64 [%17, %$10] ; # N
; # (space)
  call void @space()
  br label %$10
$12:
  %20 = phi i64 [%17, %$10] ; # N
  br label %$9
$8:
; # (space)
  call void @space()
  br label %$9
$9:
  %21 = phi i64 [%13, %$12], [18, %$8] ; # ->
  ret i64 %21
}

define i64 @_print(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (++ X)) (print Y) (? (atom X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (++ X)) (print Y) (? (atom X) Y) (space)))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%20, %$8] ; # X
; # (let Y (eval (++ X)) (print Y) (? (atom X) Y) (space))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (print Y)
  call void @print(i64 %16)
; # (? (atom X) Y)
; # (atom X)
  %17 = and i64 %8, 15
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$8
$10:
  %19 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %20 = phi i64 [%8, %$3] ; # X
; # (space)
  call void @space()
  br label %$2
$9:
  %21 = phi i64 [%19, %$10] ; # X
  %22 = phi i64 [%16, %$10] ; # ->
  ret i64 %22
}

define i64 @_printsp(i64) align 8 {
$1:
; # (prog1 (_print Exe) (space))
; # (_print Exe)
  %1 = call i64 @_print(i64 %0)
; # (space)
  call void @space()
  ret i64 %1
}

define i64 @_println(i64) align 8 {
$1:
; # (prog1 (_print Exe) (newline))
; # (_print Exe)
  %1 = call i64 @_print(i64 %0)
; # (newline)
  call void @newline()
  ret i64 %1
}

define i64 @_flush(i64) align 8 {
$1:
; # (if (flush (val $OutFile)) $T $Nil)
; # (val $OutFile)
  %1 = load i8*, i8** @$OutFile
; # (flush (val $OutFile))
  %2 = call i1 @flush(i8* %1)
  br i1 %2, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %3 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %3
}

define i64 @_rewind(i64) align 8 {
$1:
; # (let Out: (outFile (val $OutFile)) (if (and (Out:) (let Fd (Out: ...
; # (val $OutFile)
  %1 = load i8*, i8** @$OutFile
; # (if (and (Out:) (let Fd (Out: fd) (Out: ix 0) (and (seek0 Fd) (tr...
; # (and (Out:) (let Fd (Out: fd) (Out: ix 0) (and (seek0 Fd) (trunca...
; # (Out:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (let Fd (Out: fd) (Out: ix 0) (and (seek0 Fd) (truncate0 Fd)))
; # (Out: fd)
  %3 = bitcast i8* %1 to i32*
  %4 = load i32, i32* %3
; # (Out: ix 0)
  %5 = getelementptr i8, i8* %1, i32 4
  %6 = bitcast i8* %5 to i32*
  store i32 0, i32* %6
; # (and (seek0 Fd) (truncate0 Fd))
; # (seek0 Fd)
  %7 = call i1 @seek0(i32 %4)
  br i1 %7, label %$5, label %$4
$5:
; # (truncate0 Fd)
  %8 = call i1 @truncate0(i32 %4)
  br label %$4
$4:
  %9 = phi i1 [0, %$3], [%8, %$5] ; # ->
  br label %$2
$2:
  %10 = phi i1 [0, %$1], [%9, %$4] ; # ->
  br i1 %10, label %$6, label %$7
$6:
  br label %$8
$7:
  br label %$8
$8:
  %11 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$6], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7] ; # ->
  ret i64 %11
}

define i64 @_ext(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) Old (val $ExtN)) (set $ExtN (i3...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (val $ExtN)
  %5 = load i32, i32* @$ExtN
; # (set $ExtN (i32 N))
; # (i32 N)
  %6 = trunc i64 %4 to i32
  store i32 %6, i32* @$ExtN
; # (prog1 (run (cdr X)) (set $ExtN Old))
; # (cdr X)
  %7 = inttoptr i64 %3 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
; # (run (cdr X))
  br label %$2
$2:
  %10 = phi i64 [%9, %$1], [%32, %$11] ; # Prg
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
  %13 = getelementptr i64, i64* %11, i32 1
  %14 = load i64, i64* %13
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$5, label %$3
$5:
  %17 = phi i64 [%14, %$2] ; # Prg
  %18 = and i64 %12, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$8:
  br label %$6
$7:
  %20 = and i64 %12, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$9
$10:
  %22 = inttoptr i64 %12 to i64*
  %23 = load i64, i64* %22
  br label %$6
$9:
  %24 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %25 = phi i64 [%12, %$8], [%23, %$10], [%24, %$9] ; # ->
  br label %$4
$3:
  %26 = phi i64 [%14, %$2] ; # Prg
  %27 = and i64 %12, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$12, label %$11
$12:
  %29 = phi i64 [%26, %$3] ; # Prg
  %30 = call i64 @evList(i64 %12)
  %31 = icmp ne i64 %30, 0
  br label %$11
$11:
  %32 = phi i64 [%26, %$3], [%29, %$12] ; # Prg
  %33 = phi i1 [0, %$3], [%31, %$12] ; # ->
  br label %$2
$4:
  %34 = phi i64 [%17, %$6] ; # Prg
  %35 = phi i64 [%25, %$6] ; # ->
; # (set $ExtN Old)
  store i32 %5, i32* @$ExtN
  ret i64 %35
}

define i32 @getPlio() align 8 {
$1:
; # (let P (val $Ptr) (set $Ptr (inc P)) (i32 (val P)))
; # (val $Ptr)
  %0 = load i8*, i8** @$Ptr
; # (set $Ptr (inc P))
; # (inc P)
  %1 = getelementptr i8, i8* %0, i32 1
  store i8* %1, i8** @$Ptr
; # (val P)
  %2 = load i8, i8* %0
; # (i32 (val P))
  %3 = zext i8 %2 to i32
  ret i32 %3
}

define void @putPlio(i8) align 8 {
$1:
; # (let P (val $Ptr) (set P B) (when (== (set $Ptr (inc P)) (val $En...
; # (val $Ptr)
  %1 = load i8*, i8** @$Ptr
; # (set P B)
  store i8 %0, i8* %1
; # (when (== (set $Ptr (inc P)) (val $End)) (sizeErr 0))
; # (set $Ptr (inc P))
; # (inc P)
  %2 = getelementptr i8, i8* %1, i32 1
  store i8* %2, i8** @$Ptr
; # (val $End)
  %3 = load i8*, i8** @$End
; # (== (set $Ptr (inc P)) (val $End))
  %4 = icmp eq i8* %2, %3
  br i1 %4, label %$2, label %$3
$2:
; # (sizeErr 0)
  call void @sizeErr(i64 0)
  unreachable
$3:
  ret void
}

define i64 @_plio(i64) align 8 {
$1:
; # (let (X (cdr Exe) P (i8* (if (cnt? (needNum Exe (eval (++ X)))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cnt? (needNum Exe (eval (++ X))))
  %18 = and i64 %15, 2
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  %20 = phi i64 [%7, %$8] ; # X
; # (int @)
  %21 = lshr i64 %15, 4
  br label %$11
$10:
  %22 = phi i64 [%7, %$8] ; # X
; # (dig @)
  %23 = add i64 %15, -4
; # (val (dig @))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  br label %$11
$11:
  %26 = phi i64 [%20, %$9], [%22, %$10] ; # X
  %27 = phi i64 [%21, %$9], [%25, %$10] ; # ->
; # (i8* (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @))...
  %28 = inttoptr i64 %27 to i8*
; # (let (Ptr (val $Ptr) End (val $End)) (set $Extn (val $ExtN) $Ptr ...
; # (val $Ptr)
  %29 = load i8*, i8** @$Ptr
; # (val $End)
  %30 = load i8*, i8** @$End
; # (set $Extn (val $ExtN) $Ptr P)
; # (val $ExtN)
  %31 = load i32, i32* @$ExtN
  store i32 %31, i32* @$Extn
  store i8* %28, i8** @$Ptr
; # (prog1 (if (pair X) (let (N (evCnt Exe X) Y (eval (car (shift X))...
; # (if (pair X) (let (N (evCnt Exe X) Y (eval (car (shift X)))) (set...
; # (pair X)
  %32 = and i64 %26, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$12, label %$13
$12:
  %34 = phi i64 [%26, %$11] ; # X
; # (let (N (evCnt Exe X) Y (eval (car (shift X)))) (set $PutBin (fun...
; # (evCnt Exe X)
  %35 = call i64 @evCnt(i64 %0, i64 %34)
; # (shift X)
  %36 = inttoptr i64 %34 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
; # (car (shift X))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (eval (car (shift X)))
  %41 = and i64 %40, 6
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  br label %$15
$16:
  %43 = and i64 %40, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$19, label %$18
$19:
  %45 = inttoptr i64 %40 to i64*
  %46 = load i64, i64* %45
  br label %$15
$18:
  %47 = call i64 @evList(i64 %40)
  br label %$15
$15:
  %48 = phi i64 [%40, %$17], [%46, %$19], [%47, %$18] ; # ->
; # (set $PutBin (fun (void i8) putPlio) $End (ofs P N))
; # (fun (void i8) putPlio)
  store void(i8)* @putPlio, void(i8)** @$PutBin
; # (ofs P N)
  %49 = getelementptr i8, i8* %28, i64 %35
  store i8* %49, i8** @$End
; # (binPrint Y)
  call void @binPrint(i64 %48)
; # (val $Ptr)
  %50 = load i8*, i8** @$Ptr
; # (- (val $Ptr) P)
  %51 = ptrtoint i8* %50 to i64
  %52 = ptrtoint i8* %28 to i64
  %53 = sub i64 %51, %52
; # (cnt (- (val $Ptr) P))
  %54 = shl i64 %53, 4
  %55 = or i64 %54, 2
  br label %$14
$13:
  %56 = phi i64 [%26, %$11] ; # X
; # (set $GetBin (fun (i32) getPlio))
; # (fun (i32) getPlio)
  store i32()* @getPlio, i32()** @$GetBin
; # (if (binRead) @ $Nil)
; # (binRead)
  %57 = call i64 @binRead()
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$20, label %$21
$20:
  %59 = phi i64 [%56, %$13] ; # X
  br label %$22
$21:
  %60 = phi i64 [%56, %$13] ; # X
  br label %$22
$22:
  %61 = phi i64 [%59, %$20], [%60, %$21] ; # X
  %62 = phi i64 [%57, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
  br label %$14
$14:
  %63 = phi i64 [%38, %$15], [%61, %$22] ; # X
  %64 = phi i64 [%55, %$15], [%62, %$22] ; # ->
; # (set $Ptr Ptr $End End)
  store i8* %29, i8** @$Ptr
  store i8* %30, i8** @$End
  ret i64 %64
}

define i64 @_rd(i64) align 8 {
$1:
; # (let X (save (eval (cadr Exe))) (cond ((lt0 ((inFile (val $InFile...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (cadr Exe)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (cond ((lt0 ((inFile (val $InFile)) fd)) $Nil) ((num? X) (let (P ...
; # (val $InFile)
  %22 = load i8*, i8** @$InFile
; # ((inFile (val $InFile)) fd)
  %23 = getelementptr i8, i8* %22, i32 8
  %24 = bitcast i8* %23 to i32*
  %25 = load i32, i32* %24
; # (lt0 ((inFile (val $InFile)) fd))
  %26 = icmp slt i32 %25, 0
  br i1 %26, label %$9, label %$8
$9:
  br label %$7
$8:
; # (num? X)
  %27 = and i64 %13, 6
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$11, label %$10
$11:
; # (let (P (push 3 NIL ZERO NIL) Q (link (ofs P 2)) Cnt (int X)) (co...
; # (push 3 NIL ZERO NIL)
  %29 = alloca i64, i64 4, align 16
  store i64 3, i64* %29
  %30 = getelementptr i64, i64* %29, i32 2
  store i64 2, i64* %30
; # (ofs P 2)
  %31 = getelementptr i64, i64* %29, i32 2
; # (link (ofs P 2))
  %32 = ptrtoint i64* %31 to i64
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %32 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %37
; # (int X)
  %38 = lshr i64 %13, 4
; # (cond ((=0 Cnt) $Nil) ((sign? X) (loop (when (lt0 (getBinary)) (:...
; # (=0 Cnt)
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$14, label %$13
$14:
  %40 = phi i64 [%38, %$11] ; # Cnt
  br label %$12
$13:
  %41 = phi i64 [%38, %$11] ; # Cnt
; # (sign? X)
  %42 = and i64 %13, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$16, label %$15
$16:
  %44 = phi i64 [%41, %$13] ; # Cnt
; # (loop (when (lt0 (getBinary)) (: 1 (ret $Nil))) (byteNum (i8 @) P...
  br label %$17
$17:
  %45 = phi i64 [%44, %$16], [%58, %$20] ; # Cnt
; # (when (lt0 (getBinary)) (: 1 (ret $Nil)))
; # (getBinary)
  %46 = call i32 @getBinary()
; # (lt0 (getBinary))
  %47 = icmp slt i32 %46, 0
  br i1 %47, label %$18, label %$19
$18:
  %48 = phi i64 [%45, %$17] ; # Cnt
; # (: 1 (ret $Nil))
  br label %$-1
$-1:
  %49 = phi i64 [%48, %$18], [%75, %$26] ; # Cnt
; # (ret $Nil)
; # (drop *Safe)
  %50 = inttoptr i64 %17 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$19:
  %54 = phi i64 [%45, %$17] ; # Cnt
; # (i8 @)
  %55 = trunc i32 %46 to i8
; # (byteNum (i8 @) P)
  call void @byteNum(i8 %55, i64* %29)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %56 = sub i64 %54, 1
; # (=0 (dec 'Cnt))
  %57 = icmp eq i64 %56, 0
  br i1 %57, label %$21, label %$20
$20:
  %58 = phi i64 [%56, %$19] ; # Cnt
  br label %$17
$21:
  %59 = phi i64 [%56, %$19] ; # Cnt
  %60 = phi i64 [0, %$19] ; # ->
; # (if (cnt? (val Q)) (twice @) (zapZero @))
; # (val Q)
  %61 = inttoptr i64 %32 to i64*
  %62 = load i64, i64* %61
; # (cnt? (val Q))
  %63 = and i64 %62, 2
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$22, label %$23
$22:
  %65 = phi i64 [%59, %$21] ; # Cnt
; # (twice @)
  %66 = call i64 @twice(i64 %62)
  br label %$24
$23:
  %67 = phi i64 [%59, %$21] ; # Cnt
; # (zapZero @)
  %68 = call i64 @zapZero(i64 %62)
  br label %$24
$24:
  %69 = phi i64 [%65, %$22], [%67, %$23] ; # Cnt
  %70 = phi i64 [%66, %$22], [%68, %$23] ; # ->
  br label %$12
$15:
  %71 = phi i64 [%41, %$13] ; # Cnt
; # (loop (when (lt0 (getBinary)) (goto 1)) (set Q (addu (cnt (i64 @)...
  br label %$25
$25:
  %72 = phi i64 [%71, %$15], [%88, %$28] ; # Cnt
; # (when (lt0 (getBinary)) (goto 1))
; # (getBinary)
  %73 = call i32 @getBinary()
; # (lt0 (getBinary))
  %74 = icmp slt i32 %73, 0
  br i1 %74, label %$26, label %$27
$26:
  %75 = phi i64 [%72, %$25] ; # Cnt
; # (goto 1)
  br label %$-1
$27:
  %76 = phi i64 [%72, %$25] ; # Cnt
; # (set Q (addu (cnt (i64 @)) (set Q (mulu (val Q) (hex "1002")))))
; # (i64 @)
  %77 = sext i32 %73 to i64
; # (cnt (i64 @))
  %78 = shl i64 %77, 4
  %79 = or i64 %78, 2
; # (set Q (mulu (val Q) (hex "1002")))
; # (val Q)
  %80 = inttoptr i64 %32 to i64*
  %81 = load i64, i64* %80
; # (mulu (val Q) (hex "1002"))
  %82 = call i64 @mulu(i64 %81, i64 4098)
  %83 = inttoptr i64 %32 to i64*
  store i64 %82, i64* %83
; # (addu (cnt (i64 @)) (set Q (mulu (val Q) (hex "1002"))))
  %84 = call i64 @addu(i64 %79, i64 %82)
  %85 = inttoptr i64 %32 to i64*
  store i64 %84, i64* %85
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %86 = sub i64 %76, 1
; # (=0 (dec 'Cnt))
  %87 = icmp eq i64 %86, 0
  br i1 %87, label %$29, label %$28
$28:
  %88 = phi i64 [%86, %$27] ; # Cnt
  br label %$25
$29:
  %89 = phi i64 [%86, %$27] ; # Cnt
  %90 = phi i64 [0, %$27] ; # ->
; # (if (cnt? (val Q)) @ (zapZero @))
; # (val Q)
  %91 = inttoptr i64 %32 to i64*
  %92 = load i64, i64* %91
; # (cnt? (val Q))
  %93 = and i64 %92, 2
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$30, label %$31
$30:
  %95 = phi i64 [%89, %$29] ; # Cnt
  br label %$32
$31:
  %96 = phi i64 [%89, %$29] ; # Cnt
; # (zapZero @)
  %97 = call i64 @zapZero(i64 %92)
  br label %$32
$32:
  %98 = phi i64 [%95, %$30], [%96, %$31] ; # Cnt
  %99 = phi i64 [%92, %$30], [%97, %$31] ; # ->
  br label %$12
$12:
  %100 = phi i64 [%40, %$14], [%69, %$24], [%98, %$32] ; # Cnt
  %101 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$14], [%70, %$24], [%99, %$32] ; # ->
  br label %$7
$10:
; # (set $GetBin (fun (i32) getBinary) $Extn (val $ExtN))
; # (fun (i32) getBinary)
  store i32()* @getBinary, i32()** @$GetBin
; # (val $ExtN)
  %102 = load i32, i32* @$ExtN
  store i32 %102, i32* @$Extn
; # (if (binRead) @ X)
; # (binRead)
  %103 = call i64 @binRead()
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$33, label %$34
$33:
  br label %$35
$34:
  br label %$35
$35:
  %105 = phi i64 [%103, %$33], [%13, %$34] ; # ->
  br label %$7
$7:
  %106 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%101, %$12], [%105, %$35] ; # ->
; # (drop *Safe)
  %107 = inttoptr i64 %17 to i64*
  %108 = getelementptr i64, i64* %107, i32 1
  %109 = load i64, i64* %108
  %110 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %109, i64* %110
  ret i64 %106
}

define i64 @_pr(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (++ X)) (set $Extn (val $ExtN...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (++ X)) (set $Extn (val $ExtN)) (pr Y) (? (ato...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%21, %$8] ; # X
; # (let Y (eval (++ X)) (set $Extn (val $ExtN)) (pr Y) (? (atom X) Y...
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (set $Extn (val $ExtN))
; # (val $ExtN)
  %17 = load i32, i32* @$ExtN
  store i32 %17, i32* @$Extn
; # (pr Y)
  call void @pr(i64 %16)
; # (? (atom X) Y)
; # (atom X)
  %18 = and i64 %8, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$10, label %$8
$10:
  %20 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %21 = phi i64 [%8, %$3] ; # X
  br label %$2
$9:
  %22 = phi i64 [%20, %$10] ; # X
  %23 = phi i64 [%16, %$10] ; # ->
  ret i64 %23
}

define i64 @_wr(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let N (eval (++ X)) (_putStdout (i8 (int ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let N (eval (++ X)) (_putStdout (i8 (int N))) (? (atom X) ...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%22, %$8] ; # X
; # (let N (eval (++ X)) (_putStdout (i8 (int N))) (? (atom X) N))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (int N)
  %17 = lshr i64 %16, 4
; # (i8 (int N))
  %18 = trunc i64 %17 to i8
; # (_putStdout (i8 (int N)))
  call void @_putStdout(i8 %18)
; # (? (atom X) N)
; # (atom X)
  %19 = and i64 %8, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$8
$10:
  %21 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %22 = phi i64 [%8, %$3] ; # X
  br label %$2
$9:
  %23 = phi i64 [%21, %$10] ; # X
  %24 = phi i64 [%16, %$10] ; # ->
  ret i64 %24
}

define i32 @getParse() align 8 {
$1:
; # (let P (val $Parser) (set $Chr (if (i32 (symByte P)) @ (let C (va...
; # (val $Parser)
  %0 = load i64*, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 80) to i64**)
; # (set $Chr (if (i32 (symByte P)) @ (let C (val 3 P) (set 3 P (shr ...
; # (if (i32 (symByte P)) @ (let C (val 3 P) (set 3 P (shr C 8)) (if ...
; # (symByte P)
  %1 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %2 = zext i8 %1 to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let C (val 3 P) (set 3 P (shr C 8)) (if C (i32 (i8 C)) -1))
; # (val 3 P)
  %4 = getelementptr i64, i64* %0, i32 2
  %5 = load i64, i64* %4
; # (set 3 P (shr C 8))
; # (shr C 8)
  %6 = lshr i64 %5, 8
  %7 = getelementptr i64, i64* %0, i32 2
  store i64 %6, i64* %7
; # (if C (i32 (i8 C)) -1)
  %8 = icmp ne i64 %5, 0
  br i1 %8, label %$5, label %$6
$5:
; # (i8 C)
  %9 = trunc i64 %5 to i8
; # (i32 (i8 C))
  %10 = zext i8 %9 to i32
  br label %$7
$6:
  br label %$7
$7:
  %11 = phi i32 [%10, %$5], [-1, %$6] ; # ->
  br label %$4
$4:
  %12 = phi i32 [%2, %$2], [%11, %$7] ; # ->
  store i32 %12, i32* @$Chr
  ret i32 %12
}

define i64 @parse(i64, i1, i64, i64) align 8 {
$1:
; # (let (Chr (val $Chr) Get (val (i8** $Get)) Pars (val $Parser)) (s...
; # (val $Chr)
  %4 = load i32, i32* @$Chr
; # (i8** $Get)
  %5 = bitcast i32()** @$Get to i8**
; # (val (i8** $Get))
  %6 = load i8*, i8** %5
; # (val $Parser)
  %7 = load i64*, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 80) to i64**)
; # (set $Chr 0 $Get (fun (i32) getParse) $Parser (push 0 (save Nm) E...
  store i32 0, i32* @$Chr
; # (fun (i32) getParse)
  store i32()* @getParse, i32()** @$Get
; # (save Nm)
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = alloca i64, i64 2, align 16
  %11 = ptrtoint i64* %10 to i64
  %12 = inttoptr i64 %11 to i64*
  store i64 %0, i64* %12
  %13 = add i64 %11, 8
  %14 = inttoptr i64 %13 to i64*
  store i64 %9, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %11, i64* %15
; # (push 0 (save Nm) Eof)
  %16 = alloca i64, i64 3, align 16
  store i64 0, i64* %16
  %17 = getelementptr i64, i64* %16, i32 1
  store i64 %0, i64* %17
  %18 = getelementptr i64, i64* %16, i32 2
  store i64 %2, i64* %18
  store i64* %16, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 80) to i64**)
; # (when Skip (getParse))
  br i1 %1, label %$2, label %$3
$2:
; # (getParse)
  %19 = call i32 @getParse()
  br label %$3
$3:
; # (prog1 (cond ((=0 Set) (rdList)) ((== 1 Set) (read0 YES)) ((=0 (t...
; # (cond ((=0 Set) (rdList)) ((== 1 Set) (read0 YES)) ((=0 (token Se...
; # (=0 Set)
  %20 = icmp eq i64 %3, 0
  br i1 %20, label %$6, label %$5
$6:
; # (rdList)
  %21 = call i64 @rdList()
  br label %$4
$5:
; # (== 1 Set)
  %22 = icmp eq i64 1, %3
  br i1 %22, label %$8, label %$7
$8:
; # (read0 YES)
  %23 = call i64 @read0(i1 1)
  br label %$4
$7:
; # (token Set 0)
  %24 = call i64 @token(i64 %3, i32 0)
; # (=0 (token Set 0))
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %$10, label %$9
$10:
  br label %$4
$9:
; # (let (R (save (cons @ $Nil)) P R) (while (token Set 0) (setq P (s...
; # (cons @ $Nil)
  %26 = call i64 @cons(i64 %24, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons @ $Nil))
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = alloca i64, i64 2, align 16
  %30 = ptrtoint i64* %29 to i64
  %31 = inttoptr i64 %30 to i64*
  store i64 %26, i64* %31
  %32 = add i64 %30, 8
  %33 = inttoptr i64 %32 to i64*
  store i64 %28, i64* %33
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %34
; # (while (token Set 0) (setq P (set 2 P (cons @ $Nil))))
  br label %$11
$11:
  %35 = phi i64 [%26, %$9], [%39, %$12] ; # P
; # (token Set 0)
  %36 = call i64 @token(i64 %3, i32 0)
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = phi i64 [%35, %$11] ; # P
; # (set 2 P (cons @ $Nil))
; # (cons @ $Nil)
  %39 = call i64 @cons(i64 %36, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %40 = inttoptr i64 %38 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  store i64 %39, i64* %41
  br label %$11
$13:
  %42 = phi i64 [%35, %$11] ; # P
  br label %$4
$4:
  %43 = phi i64 [%21, %$6], [%23, %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [%26, %$13] ; # ->
; # (set $Parser Pars (i8** $Get) Get $Chr Chr)
  store i64* %7, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 80) to i64**)
; # (i8** $Get)
  %44 = bitcast i32()** @$Get to i8**
  store i8* %6, i8** %44
  store i32 %4, i32* @$Chr
; # (drop *Safe)
  %45 = inttoptr i64 %11 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret i64 %43
}

define void @putString(i8) align 8 {
$1:
; # (val $StrP)
  %1 = load i64*, i64** @$StrP
; # (byteSym B (val $StrP))
  call void @byteSym(i8 %0, i64* %1)
  ret void
}

define void @begString(i64*) align 8 {
$1:
; # (set 6 P (i64 (val $StrP)))
; # (val $StrP)
  %1 = load i64*, i64** @$StrP
; # (i64 (val $StrP))
  %2 = ptrtoint i64* %1 to i64
  %3 = getelementptr i64, i64* %0, i32 5
  store i64 %2, i64* %3
; # (set $StrP P)
  store i64* %0, i64** @$StrP
; # (ofs (set $StrP P) 2)
  %4 = getelementptr i64, i64* %0, i32 2
; # (link (ofs (set $StrP P) 2))
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %5 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %10
; # (set 5 P (val (i64* $Put)) $Put (fun (void i8) putString))
; # (i64* $Put)
  %11 = bitcast void(i8)** @$Put to i64*
; # (val (i64* $Put))
  %12 = load i64, i64* %11
  %13 = getelementptr i64, i64* %0, i32 4
  store i64 %12, i64* %13
; # (fun (void i8) putString)
  store void(i8)* @putString, void(i8)** @$Put
  ret void
}

define void @tglString(i64*) align 8 {
$1:
; # (ofs P 4)
  %1 = getelementptr i64, i64* %0, i32 4
; # (any (ofs P 4))
  %2 = ptrtoint i64* %1 to i64
; # (i64* $Put)
  %3 = bitcast void(i8)** @$Put to i64*
; # (any (i64* $Put))
  %4 = ptrtoint i64* %3 to i64
; # (xchg (any (ofs P 4)) (any (i64* $Put)))
  %5 = inttoptr i64 %2 to i64*
  %6 = load i64, i64* %5
  %7 = inttoptr i64 %4 to i64*
  %8 = load i64, i64* %7
  store i64 %8, i64* %5
  store i64 %6, i64* %7
  ret void
}

define i64 @endString() align 8 {
$1:
; # (let (P (val $StrP) Q (ofs P 2)) (set (i64* $Put) (val 5 P) $StrP...
; # (val $StrP)
  %0 = load i64*, i64** @$StrP
; # (ofs P 2)
  %1 = getelementptr i64, i64* %0, i32 2
; # (set (i64* $Put) (val 5 P) $StrP (i64* (val 6 P)))
; # (i64* $Put)
  %2 = bitcast void(i8)** @$Put to i64*
; # (val 5 P)
  %3 = getelementptr i64, i64* %0, i32 4
  %4 = load i64, i64* %3
  store i64 %4, i64* %2
; # (val 6 P)
  %5 = getelementptr i64, i64* %0, i32 5
  %6 = load i64, i64* %5
; # (i64* (val 6 P))
  %7 = inttoptr i64 %6 to i64*
  store i64* %7, i64** @$StrP
; # (drop Q (consStr (val Q)))
  %8 = ptrtoint i64* %1 to i64
; # (val Q)
  %9 = load i64, i64* %1
; # (consStr (val Q))
  %10 = call i64 @consStr(i64 %9)
  %11 = inttoptr i64 %8 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %13, i64* %14
  ret i64 %10
}

define i64 @_any(i64) align 8 {
$1:
; # (if (sym? (val (tail (save (evSym (cdr Exe)))))) $Nil (parse (nam...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (save (evSym (cdr Exe)))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (tail (save (evSym (cdr Exe))))
  %13 = add i64 %4, -8
; # (val (tail (save (evSym (cdr Exe)))))
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
; # (sym? (val (tail (save (evSym (cdr Exe))))))
  %16 = and i64 %15, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$2, label %$3
$2:
  br label %$4
$3:
; # (name @)
  br label %$5
$5:
  %18 = phi i64 [%15, %$3], [%24, %$6] ; # Tail
  %19 = and i64 %18, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$6:
  %21 = phi i64 [%18, %$5] ; # Tail
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  br label %$5
$7:
  %25 = phi i64 [%18, %$5] ; # Tail
; # (parse (name @) YES (hex "20") 1)
  %26 = call i64 @parse(i64 %25, i1 1, i64 32, i64 1)
  br label %$4
$4:
  %27 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%26, %$7] ; # ->
; # (drop *Safe)
  %28 = inttoptr i64 %8 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %31
  ret i64 %27
}

define i64 @_sym(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (begString (push 4 NIL ZERO NIL NIL NIL)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (push 4 NIL ZERO NIL NIL NIL)
  %14 = alloca i64, i64 6, align 16
  store i64 4, i64* %14
  %15 = getelementptr i64, i64* %14, i32 2
  store i64 2, i64* %15
; # (begString (push 4 NIL ZERO NIL NIL NIL))
  call void @begString(i64* %14)
; # (print X)
  call void @print(i64 %13)
; # (endString)
  %16 = call i64 @endString()
  ret i64 %16
}

define i64 @_str(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (cond ((nil? Y) Y) ((num? Y) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((nil? Y) Y) ((num? Y) (argErr Exe Y)) ((pair Y) (begString...
; # (nil? Y)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%3, %$2] ; # X
  %16 = phi i64 [%13, %$2] ; # Y
  br label %$7
$8:
  %17 = phi i64 [%3, %$2] ; # X
  %18 = phi i64 [%13, %$2] ; # Y
; # (num? Y)
  %19 = and i64 %18, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$11, label %$10
$11:
  %21 = phi i64 [%17, %$8] ; # X
  %22 = phi i64 [%18, %$8] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %22)
  unreachable
$10:
  %23 = phi i64 [%17, %$8] ; # X
  %24 = phi i64 [%18, %$8] ; # Y
; # (pair Y)
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  %27 = phi i64 [%23, %$10] ; # X
  %28 = phi i64 [%24, %$10] ; # Y
; # (push 4 NIL ZERO NIL NIL NIL)
  %29 = alloca i64, i64 6, align 16
  store i64 4, i64* %29
  %30 = getelementptr i64, i64* %29, i32 2
  store i64 2, i64* %30
; # (begString (push 4 NIL ZERO NIL NIL NIL))
  call void @begString(i64* %29)
; # (loop (print (++ Y)) (? (atom Y)) (space))
  br label %$14
$14:
  %31 = phi i64 [%27, %$13], [%39, %$15] ; # X
  %32 = phi i64 [%28, %$13], [%40, %$15] ; # Y
; # (++ Y)
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = getelementptr i64, i64* %33, i32 1
  %36 = load i64, i64* %35
; # (print (++ Y))
  call void @print(i64 %34)
; # (? (atom Y))
; # (atom Y)
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$16, label %$15
$15:
  %39 = phi i64 [%31, %$14] ; # X
  %40 = phi i64 [%36, %$14] ; # Y
; # (space)
  call void @space()
  br label %$14
$16:
  %41 = phi i64 [%31, %$14] ; # X
  %42 = phi i64 [%36, %$14] ; # Y
  %43 = phi i64 [0, %$14] ; # ->
; # (endString)
  %44 = call i64 @endString()
  br label %$7
$12:
  %45 = phi i64 [%23, %$10] ; # X
  %46 = phi i64 [%24, %$10] ; # Y
; # (tail @)
  %47 = add i64 %24, -8
; # (val (tail @))
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (sym? (setq Y (val (tail @))))
  %50 = and i64 %49, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$18, label %$17
$18:
  %52 = phi i64 [%45, %$12] ; # X
  %53 = phi i64 [%49, %$12] ; # Y
  br label %$7
$17:
  %54 = phi i64 [%45, %$12] ; # X
  %55 = phi i64 [%49, %$12] ; # Y
; # (shift X)
  %56 = inttoptr i64 %54 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (atom (shift X))
  %59 = and i64 %58, 15
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$20, label %$19
$20:
  %61 = phi i64 [%58, %$17] ; # X
  %62 = phi i64 [%55, %$17] ; # Y
; # (name Y)
  br label %$21
$21:
  %63 = phi i64 [%62, %$20], [%69, %$22] ; # Tail
  %64 = and i64 %63, 6
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$23, label %$22
$22:
  %66 = phi i64 [%63, %$21] ; # Tail
  %67 = inttoptr i64 %66 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  br label %$21
$23:
  %70 = phi i64 [%63, %$21] ; # Tail
; # (parse (name Y) NO (hex "5D0A") 0)
  %71 = call i64 @parse(i64 %70, i1 0, i64 23818, i64 0)
  br label %$7
$19:
  %72 = phi i64 [%58, %$17] ; # X
  %73 = phi i64 [%55, %$17] ; # Y
; # (save Y (parse (name Y) NO 0 (save (evSym X))))
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %75 = load i64, i64* %74
  %76 = alloca i64, i64 2, align 16
  %77 = ptrtoint i64* %76 to i64
  %78 = inttoptr i64 %77 to i64*
  store i64 %73, i64* %78
  %79 = add i64 %77, 8
  %80 = inttoptr i64 %79 to i64*
  store i64 %75, i64* %80
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %81
; # (name Y)
  br label %$24
$24:
  %82 = phi i64 [%73, %$19], [%88, %$25] ; # Tail
  %83 = and i64 %82, 6
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$26, label %$25
$25:
  %85 = phi i64 [%82, %$24] ; # Tail
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
  br label %$24
$26:
  %89 = phi i64 [%82, %$24] ; # Tail
; # (evSym X)
  %90 = call i64 @evSym(i64 %72)
; # (save (evSym X))
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %92 = load i64, i64* %91
  %93 = alloca i64, i64 2, align 16
  %94 = ptrtoint i64* %93 to i64
  %95 = inttoptr i64 %94 to i64*
  store i64 %90, i64* %95
  %96 = add i64 %94, 8
  %97 = inttoptr i64 %96 to i64*
  store i64 %92, i64* %97
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %94, i64* %98
; # (parse (name Y) NO 0 (save (evSym X)))
  %99 = call i64 @parse(i64 %89, i1 0, i64 0, i64 %90)
; # drop
  %100 = inttoptr i64 %77 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
  %103 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %102, i64* %103
  br label %$7
$7:
  %104 = phi i64 [%15, %$9], [%41, %$16], [%52, %$18], [%61, %$23], [%72, %$26] ; # X
  %105 = phi i64 [%16, %$9], [%42, %$16], [%53, %$18], [%62, %$23], [%73, %$26] ; # Y
  %106 = phi i64 [%16, %$9], [%44, %$16], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$18], [%71, %$23], [%99, %$26] ; # ->
  ret i64 %106
}

define i64 @stdRead(i8*) align 8 {
$1:
; # (prog2 (set $LinePrmt (if (or (nil? (runAt (val $Prompt))) (not (...
; # (set $LinePrmt (if (or (nil? (runAt (val $Prompt))) (not (symb? @...
; # (if (or (nil? (runAt (val $Prompt))) (not (symb? @))) Prmt (let (...
; # (or (nil? (runAt (val $Prompt))) (not (symb? @)))
; # (val $Prompt)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 504) to i64) to i64*
  %2 = load i64, i64* %1
; # (runAt (val $Prompt))
  %3 = call i64 @runAt(i64 %2)
; # (nil? (runAt (val $Prompt)))
  %4 = icmp eq i64 %3, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %4, label %$2, label %$3
$3:
; # (symb? @)
  %5 = xor i64 %3, 8
  %6 = and i64 %5, 14
  %7 = icmp eq i64 %6, 0
; # (not (symb? @))
  %8 = icmp eq i1 %7, 0
  br label %$2
$2:
  %9 = phi i1 [1, %$1], [%8, %$3] ; # ->
  br i1 %9, label %$4, label %$5
$4:
  br label %$6
$5:
; # (let (Nm (name (val (tail @))) N (bufSize Nm) P (set $ReplPrmt (a...
; # (tail @)
  %10 = add i64 %3, -8
; # (val (tail @))
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (name (val (tail @)))
  br label %$7
$7:
  %13 = phi i64 [%12, %$5], [%19, %$8] ; # Tail
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$8:
  %16 = phi i64 [%13, %$7] ; # Tail
  %17 = inttoptr i64 %16 to i64*
  %18 = getelementptr i64, i64* %17, i32 1
  %19 = load i64, i64* %18
  br label %$7
$9:
  %20 = phi i64 [%13, %$7] ; # Tail
; # (bufSize Nm)
  %21 = call i64 @bufSize(i64 %20)
; # (set $ReplPrmt (alloc (val $ReplPrmt) (+ N (strlen Prmt))))
; # (val $ReplPrmt)
  %22 = load i8*, i8** @$ReplPrmt
; # (strlen Prmt)
  %23 = call i64 @strlen(i8* %0)
; # (+ N (strlen Prmt))
  %24 = add i64 %21, %23
; # (alloc (val $ReplPrmt) (+ N (strlen Prmt)))
  %25 = call i8* @alloc(i8* %22, i64 %24)
  store i8* %25, i8** @$ReplPrmt
; # (bufString Nm P)
  %26 = call i8* @bufString(i64 %20, i8* %25)
; # (dec N)
  %27 = sub i64 %21, 1
; # (ofs P (dec N))
  %28 = getelementptr i8, i8* %25, i64 %27
; # (strcpy (ofs P (dec N)) Prmt)
  %29 = call i8* @strcpy(i8* %28, i8* %0)
  br label %$6
$6:
  %30 = phi i8* [%0, %$4], [%25, %$9] ; # ->
  store i8* %30, i8** @$LinePrmt
  store i8* bitcast ([4 x i8]* @$46 to i8*), i8** @$ContPrmt
; # (if ((inFile (val $InFile)) tty) (char "^J") (i32 0))
; # (val $InFile)
  %31 = load i8*, i8** @$InFile
; # ((inFile (val $InFile)) tty)
  %32 = getelementptr i8, i8* %31, i32 4128
  %33 = bitcast i8* %32 to i1*
  %34 = load i1, i1* %33
  br i1 %34, label %$10, label %$11
$10:
  br label %$12
$11:
; # (i32 0)
  br label %$12
$12:
  %35 = phi i32 [10, %$10], [0, %$11] ; # ->
; # (read1 (if ((inFile (val $InFile)) tty) (char "^J") (i32 0)))
  %36 = call i64 @read1(i32 %35)
; # (set $LinePrmt (set $ContPrmt null))
; # (set $ContPrmt null)
  store i8* null, i8** @$ContPrmt
  store i8* null, i8** @$LinePrmt
; # (while (gt0 (val $Chr)) (? (== (val $Chr) (char "^J")) (set $Chr ...
  br label %$13
$13:
; # (val $Chr)
  %37 = load i32, i32* @$Chr
; # (gt0 (val $Chr))
  %38 = icmp sgt i32 %37, 0
  br i1 %38, label %$14, label %$15
$14:
; # (? (== (val $Chr) (char "^J")) (set $Chr 0))
; # (val $Chr)
  %39 = load i32, i32* @$Chr
; # (== (val $Chr) (char "^J"))
  %40 = icmp eq i32 %39, 10
  br i1 %40, label %$17, label %$16
$17:
; # (set $Chr 0)
  store i32 0, i32* @$Chr
  br label %$15
$16:
; # (if (== (val $Chr) (char "#")) (comment) (? (> (val $Chr) (char "...
; # (val $Chr)
  %41 = load i32, i32* @$Chr
; # (== (val $Chr) (char "#"))
  %42 = icmp eq i32 %41, 35
  br i1 %42, label %$18, label %$19
$18:
; # (comment)
  call void @comment()
  br label %$20
$19:
; # (? (> (val $Chr) (char " ")))
; # (val $Chr)
  %43 = load i32, i32* @$Chr
; # (> (val $Chr) (char " "))
  %44 = icmp sgt i32 %43, 32
  br i1 %44, label %$15, label %$21
$21:
; # (call $Get)
  %45 = load i32()*, i32()** @$Get
  %46 = call i32 %45()
  br label %$20
$20:
  br label %$13
$15:
  ret i64 %36
}

define i64 @stdEval(i64) align 8 {
$1:
; # (flushAll)
  call void @flushAll()
; # (let (At (save (val $At)) X (eval Exe)) (set $At3 (val $At2) $At2...
; # (val $At)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %2 = load i64, i64* %1
; # (save (val $At))
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %2, i64* %7
  %8 = add i64 %6, 8
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %10
; # (eval Exe)
  %11 = and i64 %0, 6
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$4, label %$3
$4:
  br label %$2
$3:
  %13 = and i64 %0, 8
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$6, label %$5
$6:
  %15 = inttoptr i64 %0 to i64*
  %16 = load i64, i64* %15
  br label %$2
$5:
  %17 = call i64 @evList(i64 %0)
  br label %$2
$2:
  %18 = phi i64 [%0, %$4], [%16, %$6], [%17, %$5] ; # ->
; # (set $At3 (val $At2) $At2 At $At X)
; # (val $At2)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 472) to i64) to i64*
  store i64 %20, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %2, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %18, i64* %23
; # (outString ($ "-> "))
  call void @outString(i8* bitcast ([4 x i8]* @$47 to i8*))
; # (flushAll)
  call void @flushAll()
; # (print X)
  call void @print(i64 %18)
; # (newline)
  call void @newline()
; # (drop *Safe)
  %24 = inttoptr i64 %6 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %27
  ret i64 %18
}

define i64 @repl(i64, i8*, i64) align 8 {
$1:
; # (when (num? X) (argErr Exe X))
; # (num? X)
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%2, %$1] ; # X
; # (argErr Exe X)
  call void @argErr(i64 %0, i64 %5)
  unreachable
$3:
  %6 = phi i64 [%2, %$1] ; # X
; # (if (and (sym? X) (== (firstByte X) (char "-"))) (let E (save (pa...
; # (and (sym? X) (== (firstByte X) (char "-")))
; # (sym? X)
  %7 = and i64 %6, 8
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  %9 = phi i64 [%6, %$3] ; # X
; # (firstByte X)
  %10 = call i8 @firstByte(i64 %9)
; # (== (firstByte X) (char "-"))
  %11 = icmp eq i8 %10, 45
  br label %$4
$4:
  %12 = phi i64 [%6, %$3], [%9, %$5] ; # X
  %13 = phi i1 [0, %$3], [%11, %$5] ; # ->
  br i1 %13, label %$6, label %$7
$6:
  %14 = phi i64 [%12, %$4] ; # X
; # (let E (save (parse (xName Exe X) YES (hex "5D0A") 0)) (evList E)...
; # (xName Exe X)
  %15 = call i64 @xName(i64 %0, i64 %14)
; # (parse (xName Exe X) YES (hex "5D0A") 0)
  %16 = call i64 @parse(i64 %15, i1 1, i64 23818, i64 0)
; # (save (parse (xName Exe X) YES (hex "5D0A") 0))
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (evList E)
  %25 = call i64 @evList(i64 %16)
; # (drop *Safe)
  %26 = inttoptr i64 %20 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %29
  br label %$8
$7:
  %30 = phi i64 [%12, %$4] ; # X
; # (let (Int (save (val $Intern)) Tr1 (save (val $Transient)) Tr2 (s...
; # (val $Intern)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
; # (save (val $Intern))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = alloca i64, i64 2, align 16
  %36 = ptrtoint i64* %35 to i64
  %37 = inttoptr i64 %36 to i64*
  store i64 %32, i64* %37
  %38 = add i64 %36, 8
  %39 = inttoptr i64 %38 to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %36, i64* %40
; # (val $Transient)
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %42 = load i64, i64* %41
; # (save (val $Transient))
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %44 = load i64, i64* %43
  %45 = alloca i64, i64 2, align 16
  %46 = ptrtoint i64* %45 to i64
  %47 = inttoptr i64 %46 to i64*
  store i64 %42, i64* %47
  %48 = add i64 %46, 8
  %49 = inttoptr i64 %48 to i64*
  store i64 %44, i64* %49
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %46, i64* %50
; # (val 2 $Transient)
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
; # (save (val 2 $Transient))
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %53, i64* %58
  %59 = add i64 %57, 8
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %61
; # (val $PrivT)
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %63 = load i64, i64* %62
; # (save (val $PrivT))
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %65 = load i64, i64* %64
  %66 = alloca i64, i64 2, align 16
  %67 = ptrtoint i64* %66 to i64
  %68 = inttoptr i64 %67 to i64*
  store i64 %63, i64* %68
  %69 = add i64 %67, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 %65, i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %71
; # (val 2 $PrivT)
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (save (val 2 $PrivT))
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %76 = load i64, i64* %75
  %77 = alloca i64, i64 2, align 16
  %78 = ptrtoint i64* %77 to i64
  %79 = inttoptr i64 %78 to i64*
  store i64 %74, i64* %79
  %80 = add i64 %78, 8
  %81 = inttoptr i64 %80 to i64*
  store i64 %76, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %78, i64* %82
; # (push -ZERO NIL)
  %83 = alloca i64, i64 2, align 16
  %84 = ptrtoint i64* %83 to i64
  %85 = inttoptr i64 %84 to i64*
  store i64 10, i64* %85
; # (link (push -ZERO NIL))
  %86 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %87 = load i64, i64* %86
  %88 = inttoptr i64 %84 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  store i64 %87, i64* %89
  %90 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %84, i64* %90
; # (val Termio)
  %91 = load i8*, i8** @Termio
; # (when (nil? X) (setCooked) (unless (val $Repl) (set $Repl YES) (i...
; # (nil? X)
  %92 = icmp eq i64 %30, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %92, label %$9, label %$10
$9:
  %93 = phi i64 [%30, %$7] ; # X
; # (setCooked)
  call void @setCooked()
; # (unless (val $Repl) (set $Repl YES) (iSignal (val SIGINT Sig) (fu...
; # (val $Repl)
  %94 = load i1, i1* @$Repl
  br i1 %94, label %$12, label %$11
$11:
  %95 = phi i64 [%93, %$9] ; # X
; # (set $Repl YES)
  store i1 1, i1* @$Repl
; # (val SIGINT Sig)
  %96 = getelementptr i32, i32* @Sig, i32 1
  %97 = load i32, i32* %96
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %98 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGINT Sig) (fun sig))
  call void @iSignal(i32 %97, i8* %98)
  br label %$12
$12:
  %99 = phi i64 [%93, %$9], [%95, %$11] ; # X
  br label %$10
$10:
  %100 = phi i64 [%30, %$7], [%99, %$12] ; # X
; # (b8 (ioFrame T))
  %101 = alloca i8, i64 28
; # (rdOpen Exe X (b8 (ioFrame T)))
  call void @rdOpen(i64 %0, i64 %100, i8* %101)
; # (set $PrivT (set 2 $PrivT $Nil))
; # (set 2 $PrivT $Nil)
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %103
  %104 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %104
; # (set $Rule (set $Transient (set 2 $Transient $Nil)))
; # (set $Transient (set 2 $Transient $Nil))
; # (set 2 $Transient $Nil)
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %106
  %107 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %107
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 568) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %108
; # (if (== (val $InFile) (val (val $InFiles))) (until (nil? (stdRead...
; # (val $InFile)
  %109 = load i8*, i8** @$InFile
; # (val $InFiles)
  %110 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %111 = load i8*, i8** %110
; # (== (val $InFile) (val (val $InFiles)))
  %112 = icmp eq i8* %109, %111
  br i1 %112, label %$13, label %$14
$13:
  %113 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # X
; # (until (nil? (stdRead Prmt)) (let Y (set V @) (setq X (if (and (=...
  br label %$16
$16:
  %114 = phi i64 [%113, %$13], [%137, %$23] ; # X
; # (stdRead Prmt)
  %115 = call i64 @stdRead(i8* %1)
; # (nil? (stdRead Prmt))
  %116 = icmp eq i64 %115, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %116, label %$18, label %$17
$17:
  %117 = phi i64 [%114, %$16] ; # X
; # (let Y (set V @) (setq X (if (and (=0 (val $Chr)) Prmt) (stdEval ...
; # (set V @)
  %118 = inttoptr i64 %84 to i64*
  store i64 %115, i64* %118
; # (if (and (=0 (val $Chr)) Prmt) (stdEval Y) (eval Y))
; # (and (=0 (val $Chr)) Prmt)
; # (val $Chr)
  %119 = load i32, i32* @$Chr
; # (=0 (val $Chr))
  %120 = icmp eq i32 %119, 0
  br i1 %120, label %$20, label %$19
$20:
  %121 = phi i64 [%117, %$17] ; # X
  %122 = icmp ne i8* %1, null
  br label %$19
$19:
  %123 = phi i64 [%117, %$17], [%121, %$20] ; # X
  %124 = phi i1 [0, %$17], [%122, %$20] ; # ->
  br i1 %124, label %$21, label %$22
$21:
  %125 = phi i64 [%123, %$19] ; # X
; # (stdEval Y)
  %126 = call i64 @stdEval(i64 %115)
  br label %$23
$22:
  %127 = phi i64 [%123, %$19] ; # X
; # (eval Y)
  %128 = and i64 %115, 6
  %129 = icmp ne i64 %128, 0
  br i1 %129, label %$26, label %$25
$26:
  br label %$24
$25:
  %130 = and i64 %115, 8
  %131 = icmp ne i64 %130, 0
  br i1 %131, label %$28, label %$27
$28:
  %132 = inttoptr i64 %115 to i64*
  %133 = load i64, i64* %132
  br label %$24
$27:
  %134 = call i64 @evList(i64 %115)
  br label %$24
$24:
  %135 = phi i64 [%115, %$26], [%133, %$28], [%134, %$27] ; # ->
  br label %$23
$23:
  %136 = phi i64 [%125, %$21], [%127, %$24] ; # X
  %137 = phi i64 [%126, %$21], [%135, %$24] ; # ->
  br label %$16
$18:
  %138 = phi i64 [%114, %$16] ; # X
  br label %$15
$14:
  %139 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # X
; # (until (nil? (read1 0)) (setq X (eval (set V @))))
  br label %$29
$29:
  %140 = phi i64 [%139, %$14], [%152, %$32] ; # X
; # (read1 0)
  %141 = call i64 @read1(i32 0)
; # (nil? (read1 0))
  %142 = icmp eq i64 %141, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %142, label %$31, label %$30
$30:
  %143 = phi i64 [%140, %$29] ; # X
; # (set V @)
  %144 = inttoptr i64 %84 to i64*
  store i64 %141, i64* %144
; # (eval (set V @))
  %145 = and i64 %141, 6
  %146 = icmp ne i64 %145, 0
  br i1 %146, label %$34, label %$33
$34:
  br label %$32
$33:
  %147 = and i64 %141, 8
  %148 = icmp ne i64 %147, 0
  br i1 %148, label %$36, label %$35
$36:
  %149 = inttoptr i64 %141 to i64*
  %150 = load i64, i64* %149
  br label %$32
$35:
  %151 = call i64 @evList(i64 %141)
  br label %$32
$32:
  %152 = phi i64 [%141, %$34], [%150, %$36], [%151, %$35] ; # ->
  br label %$29
$31:
  %153 = phi i64 [%140, %$29] ; # X
  br label %$15
$15:
  %154 = phi i64 [%138, %$18], [%153, %$31] ; # X
; # (popInFiles)
  call void @popInFiles()
; # (tosInFile)
  call void @tosInFile()
; # (when Raw (setRaw))
  %155 = icmp ne i8* %91, null
  br i1 %155, label %$37, label %$38
$37:
  %156 = phi i64 [%154, %$15] ; # X
; # (setRaw)
  call void @setRaw()
  br label %$38
$38:
  %157 = phi i64 [%154, %$15], [%156, %$37] ; # X
; # (set 2 $PrivT Pr2)
  %158 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %159 = getelementptr i64, i64* %158, i32 1
  store i64 %74, i64* %159
; # (set $PrivT Pr1)
  %160 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  store i64 %63, i64* %160
; # (set 2 $Transient Tr2)
  %161 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %162 = getelementptr i64, i64* %161, i32 1
  store i64 %53, i64* %162
; # (set $Transient Tr1)
  %163 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  store i64 %42, i64* %163
; # (set $Intern Int)
  %164 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %164
; # (drop *Safe)
  %165 = inttoptr i64 %36 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
  %168 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %167, i64* %168
  br label %$8
$8:
  %169 = phi i64 [%14, %$6], [%157, %$38] ; # X
  %170 = phi i64 [%25, %$6], [%157, %$38] ; # ->
  ret i64 %170
}

define i64 @loadAll(i64) align 8 {
$1:
; # (let X $Nil (loop (let (A (val $AV) P (val A)) (? (or (=0 P) (and...
; # (loop (let (A (val $AV) P (val A)) (? (or (=0 P) (and (== (val P)...
  br label %$2
$2:
  %1 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%19, %$7] ; # X
; # (let (A (val $AV) P (val A)) (? (or (=0 P) (and (== (val P) (char...
; # (val $AV)
  %2 = load i8**, i8*** @$AV
; # (val A)
  %3 = load i8*, i8** %2
; # (? (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P)))))
; # (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P))))
; # (=0 P)
  %4 = icmp eq i8* %3, null
  br i1 %4, label %$3, label %$4
$4:
  %5 = phi i64 [%1, %$2] ; # X
; # (and (== (val P) (char "-")) (=0 (val 2 P)))
; # (val P)
  %6 = load i8, i8* %3
; # (== (val P) (char "-"))
  %7 = icmp eq i8 %6, 45
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$4] ; # X
; # (val 2 P)
  %9 = getelementptr i8, i8* %3, i32 1
  %10 = load i8, i8* %9
; # (=0 (val 2 P))
  %11 = icmp eq i8 %10, 0
  br label %$5
$5:
  %12 = phi i64 [%5, %$4], [%8, %$6] ; # X
  %13 = phi i1 [0, %$4], [%11, %$6] ; # ->
  br label %$3
$3:
  %14 = phi i64 [%1, %$2], [%12, %$5] ; # X
  %15 = phi i1 [1, %$2], [%13, %$5] ; # ->
  br i1 %15, label %$8, label %$7
$7:
  %16 = phi i64 [%14, %$3] ; # X
; # (set $AV (inc A))
; # (inc A)
  %17 = getelementptr i8*, i8** %2, i32 1
  store i8** %17, i8*** @$AV
; # (mkStr P)
  %18 = call i64 @mkStr(i8* %3)
; # (repl Exe null (mkStr P))
  %19 = call i64 @repl(i64 %0, i8* null, i64 %18)
  br label %$2
$8:
  %20 = phi i64 [%14, %$3] ; # X
  %21 = phi i64 [0, %$3] ; # ->
  ret i64 %20
}

define i64 @_load(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (if (t? (eval (++ X))) (loadAll Exe...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (if (t? (eval (++ X))) (loadAll Exe) (repl Exe ($ ">...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%27, %$11] ; # X
; # (let Y (if (t? (eval (++ X))) (loadAll Exe) (repl Exe ($ "> ") @)...
; # (if (t? (eval (++ X))) (loadAll Exe) (repl Exe ($ "> ") @))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (t? (eval (++ X)))
  %17 = icmp eq i64 %16, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %17, label %$8, label %$9
$8:
  %18 = phi i64 [%8, %$3] ; # X
; # (loadAll Exe)
  %19 = call i64 @loadAll(i64 %0)
  br label %$10
$9:
  %20 = phi i64 [%8, %$3] ; # X
; # (repl Exe ($ "> ") @)
  %21 = call i64 @repl(i64 %0, i8* bitcast ([3 x i8]* @$48 to i8*), i64 %16)
  br label %$10
$10:
  %22 = phi i64 [%18, %$8], [%20, %$9] ; # X
  %23 = phi i64 [%19, %$8], [%21, %$9] ; # ->
; # (? (atom X) Y)
; # (atom X)
  %24 = and i64 %22, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$13, label %$11
$13:
  %26 = phi i64 [%22, %$10] ; # X
  br label %$12
$11:
  %27 = phi i64 [%22, %$10] ; # X
  br label %$2
$12:
  %28 = phi i64 [%26, %$13] ; # X
  %29 = phi i64 [%23, %$13] ; # ->
  ret i64 %29
}

define void @dbfErr(i64) align 8 {
$1:
; # (err Exe 0 ($ "Bad DB file") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([12 x i8]* @$49 to i8*), i8* null)
  unreachable
}

define void @dbRdErr() align 8 {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "DB read: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([12 x i8]* @$50 to i8*), i8* %0)
  unreachable
}

define void @dbWrErr() align 8 {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "DB write: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([13 x i8]* @$51 to i8*), i8* %0)
  unreachable
}

define void @jnlErr(i64) align 8 {
$1:
; # (err Exe 0 ($ "Bad Journal") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([12 x i8]* @$52 to i8*), i8* null)
  unreachable
}

define void @dbSyncErr(i64) align 8 {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err Exe 0 ($ "DB fsync error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([19 x i8]* @$53 to i8*), i8* %1)
  unreachable
}

define i64 @getAdr(i8*) align 8 {
$1:
; # (val 6 P)
  %1 = getelementptr i8, i8* %0, i32 5
  %2 = load i8, i8* %1
; # (i64 (val 6 P))
  %3 = zext i8 %2 to i64
; # (shl (i64 (val 6 P)) 8)
  %4 = shl i64 %3, 8
; # (val 5 P)
  %5 = getelementptr i8, i8* %0, i32 4
  %6 = load i8, i8* %5
; # (i64 (val 5 P))
  %7 = zext i8 %6 to i64
; # (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P)))
  %8 = or i64 %4, %7
; # (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8)
  %9 = shl i64 %8, 8
; # (val 4 P)
  %10 = getelementptr i8, i8* %0, i32 3
  %11 = load i8, i8* %10
; # (i64 (val 4 P))
  %12 = zext i8 %11 to i64
; # (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8) (i64 (val ...
  %13 = or i64 %9, %12
; # (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8) (i64 ...
  %14 = shl i64 %13, 8
; # (val 3 P)
  %15 = getelementptr i8, i8* %0, i32 2
  %16 = load i8, i8* %15
; # (i64 (val 3 P))
  %17 = zext i8 %16 to i64
; # (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8) (i...
  %18 = or i64 %14, %17
; # (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) ...
  %19 = shl i64 %18, 8
; # (val 2 P)
  %20 = getelementptr i8, i8* %0, i32 1
  %21 = load i8, i8* %20
; # (i64 (val 2 P))
  %22 = zext i8 %21 to i64
; # (| (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P)...
  %23 = or i64 %19, %22
; # (shl (| (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val...
  %24 = shl i64 %23, 8
; # (val P)
  %25 = load i8, i8* %0
; # (i64 (val P))
  %26 = zext i8 %25 to i64
; # (| (shl (| (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (...
  %27 = or i64 %24, %26
  ret i64 %27
}

define void @setAdr(i64, i8*) align 8 {
$1:
; # (set P (i8 N))
; # (i8 N)
  %2 = trunc i64 %0 to i8
  store i8 %2, i8* %1
; # (set 2 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %3 = lshr i64 %0, 8
; # (i8 (setq N (shr N 8)))
  %4 = trunc i64 %3 to i8
  %5 = getelementptr i8, i8* %1, i32 1
  store i8 %4, i8* %5
; # (set 3 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %6 = lshr i64 %3, 8
; # (i8 (setq N (shr N 8)))
  %7 = trunc i64 %6 to i8
  %8 = getelementptr i8, i8* %1, i32 2
  store i8 %7, i8* %8
; # (set 4 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %9 = lshr i64 %6, 8
; # (i8 (setq N (shr N 8)))
  %10 = trunc i64 %9 to i8
  %11 = getelementptr i8, i8* %1, i32 3
  store i8 %10, i8* %11
; # (set 5 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %12 = lshr i64 %9, 8
; # (i8 (setq N (shr N 8)))
  %13 = trunc i64 %12 to i8
  %14 = getelementptr i8, i8* %1, i32 4
  store i8 %13, i8* %14
; # (set 6 P (i8 (shr N 8)))
; # (shr N 8)
  %15 = lshr i64 %12, 8
; # (i8 (shr N 8))
  %16 = trunc i64 %15 to i8
  %17 = getelementptr i8, i8* %1, i32 5
  store i8 %16, i8* %17
  ret void
}

define i8* @dbfBuf(i8*) align 8 {
$1:
; # (let N (| (shl (i32 (val 2 P)) 8) (i32 (val P))) (if (> (val $DBs...
; # (val 2 P)
  %1 = getelementptr i8, i8* %0, i32 1
  %2 = load i8, i8* %1
; # (i32 (val 2 P))
  %3 = zext i8 %2 to i32
; # (shl (i32 (val 2 P)) 8)
  %4 = shl i32 %3, 8
; # (val P)
  %5 = load i8, i8* %0
; # (i32 (val P))
  %6 = zext i8 %5 to i32
; # (| (shl (i32 (val 2 P)) 8) (i32 (val P)))
  %7 = or i32 %4, %6
; # (if (> (val $DBs) N) (set $DbFile (ofs (val $DbFiles) (* N (dbFil...
; # (val $DBs)
  %8 = load i32, i32* @$DBs
; # (> (val $DBs) N)
  %9 = icmp sgt i32 %8, %7
  br i1 %9, label %$2, label %$3
$2:
; # (set $DbFile (ofs (val $DbFiles) (* N (dbFile T))))
; # (val $DbFiles)
  %10 = load i8*, i8** @$DbFiles
; # (* N (dbFile T))
  %11 = mul i32 %7, 42
; # (ofs (val $DbFiles) (* N (dbFile T)))
  %12 = getelementptr i8, i8* %10, i32 %11
  store i8* %12, i8** @$DbFile
  br label %$4
$3:
  br label %$4
$4:
  %13 = phi i8* [%12, %$2], [null, %$3] ; # ->
  ret i8* %13
}

define void @rdLockDb() align 8 {
$1:
; # (unless (t? (val $Solo)) (rdLockWait ((dbFile (val $DbFiles)) fd)...
; # (val $Solo)
  %0 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  %1 = load i64, i64* %0
; # (t? (val $Solo))
  %2 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %2, label %$3, label %$2
$2:
; # (val $DbFiles)
  %3 = load i8*, i8** @$DbFiles
; # ((dbFile (val $DbFiles)) fd)
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (rdLockWait ((dbFile (val $DbFiles)) fd) 1)
  call void @rdLockWait(i32 %5, i64 1)
  br label %$3
$3:
  ret void
}

define void @wrLockDb() align 8 {
$1:
; # (unless (t? (val $Solo)) (wrLockWait ((dbFile (val $DbFiles)) fd)...
; # (val $Solo)
  %0 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  %1 = load i64, i64* %0
; # (t? (val $Solo))
  %2 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %2, label %$3, label %$2
$2:
; # (val $DbFiles)
  %3 = load i8*, i8** @$DbFiles
; # ((dbFile (val $DbFiles)) fd)
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (wrLockWait ((dbFile (val $DbFiles)) fd) 1)
  call void @wrLockWait(i32 %5, i64 1)
  br label %$3
$3:
  ret void
}

define void @unLockDb(i64) align 8 {
$1:
; # (unless (t? (val $Solo)) (unless Len (let (Db (val $DbFiles) C (v...
; # (val $Solo)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  %2 = load i64, i64* %1
; # (t? (val $Solo))
  %3 = icmp eq i64 %2, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %3, label %$3, label %$2
$2:
; # (unless Len (let (Db (val $DbFiles) C (val $DBs)) (while (dec 'C)...
  %4 = icmp ne i64 %0, 0
  br i1 %4, label %$5, label %$4
$4:
; # (let (Db (val $DbFiles) C (val $DBs)) (while (dec 'C) (let Db: (d...
; # (val $DbFiles)
  %5 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %6 = load i32, i32* @$DBs
; # (while (dec 'C) (let Db: (dbFile (setq Db (ofs Db (dbFile T)))) (...
  br label %$6
$6:
  %7 = phi i8* [%5, %$4], [%24, %$10] ; # Db
  %8 = phi i32 [%6, %$4], [%25, %$10] ; # C
; # (dec 'C)
  %9 = sub i32 %8, 1
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %$7, label %$8
$7:
  %11 = phi i8* [%7, %$6] ; # Db
  %12 = phi i32 [%9, %$6] ; # C
; # (let Db: (dbFile (setq Db (ofs Db (dbFile T)))) (when (Db: lck) (...
; # (ofs Db (dbFile T))
  %13 = getelementptr i8, i8* %11, i32 42
; # (when (Db: lck) (unLock (Db: fd) 0 0) (Db: lck NO))
; # (Db: lck)
  %14 = getelementptr i8, i8* %13, i32 40
  %15 = bitcast i8* %14 to i1*
  %16 = load i1, i1* %15
  br i1 %16, label %$9, label %$10
$9:
  %17 = phi i8* [%13, %$7] ; # Db
  %18 = phi i32 [%12, %$7] ; # C
; # (Db: fd)
  %19 = bitcast i8* %13 to i32*
  %20 = load i32, i32* %19
; # (unLock (Db: fd) 0 0)
  %21 = call i32 @unLock(i32 %20, i64 0, i64 0)
; # (Db: lck NO)
  %22 = getelementptr i8, i8* %13, i32 40
  %23 = bitcast i8* %22 to i1*
  store i1 0, i1* %23
  br label %$10
$10:
  %24 = phi i8* [%13, %$7], [%17, %$9] ; # Db
  %25 = phi i32 [%12, %$7], [%18, %$9] ; # C
  br label %$6
$8:
  %26 = phi i8* [%7, %$6] ; # Db
  %27 = phi i32 [%9, %$6] ; # C
; # (set $Solo ZERO)
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  store i64 2, i64* %28
  br label %$5
$5:
; # (val $DbFiles)
  %29 = load i8*, i8** @$DbFiles
; # ((dbFile (val $DbFiles)) fd)
  %30 = bitcast i8* %29 to i32*
  %31 = load i32, i32* %30
; # (unLock ((dbFile (val $DbFiles)) fd) 0 Len)
  %32 = call i32 @unLock(i32 %31, i64 0, i64 %0)
  br label %$3
$3:
  ret void
}

define i32 @tryLock(i8*, i64, i64) align 8 {
$1:
; # (let Db: (dbFile DbFile) (loop (? (ge0 (wrLock (Db: fd) N Len NO)...
; # (loop (? (ge0 (wrLock (Db: fd) N Len NO)) (Db: lck YES) (nond (N ...
  br label %$2
$2:
; # (? (ge0 (wrLock (Db: fd) N Len NO)) (Db: lck YES) (nond (N (set $...
; # (Db: fd)
  %3 = bitcast i8* %0 to i32*
  %4 = load i32, i32* %3
; # (wrLock (Db: fd) N Len NO)
  %5 = call i32 @wrLock(i32 %4, i64 %1, i64 %2, i1 0)
; # (ge0 (wrLock (Db: fd) N Len NO))
  %6 = icmp sge i32 %5, 0
  br i1 %6, label %$5, label %$3
$5:
; # (Db: lck YES)
  %7 = getelementptr i8, i8* %0, i32 40
  %8 = bitcast i8* %7 to i1*
  store i1 1, i1* %8
; # (nond (N (set $Solo $T)) ((t? (val $Solo)) (set $Solo $Nil)))
  %9 = icmp ne i64 %1, 0
  br i1 %9, label %$7, label %$8
$8:
; # (set $Solo $T)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), i64* %10
  br label %$6
$7:
; # (val $Solo)
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  %12 = load i64, i64* %11
; # (t? (val $Solo))
  %13 = icmp eq i64 %12, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %13, label %$9, label %$10
$10:
; # (set $Solo $Nil)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %14
  br label %$6
$9:
  br label %$6
$6:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [0, %$9] ; # ->
  br label %$4
$3:
; # (unless (or (== (gErrno) EINTR) (== @ EACCES) (== @ EAGAIN)) (loc...
; # (or (== (gErrno) EINTR) (== @ EACCES) (== @ EAGAIN))
; # (gErrno)
  %16 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %17 = icmp eq i32 %16, 2
  br i1 %17, label %$11, label %$12
$12:
; # (== @ EACCES)
  %18 = icmp eq i32 %16, 5
  br i1 %18, label %$11, label %$13
$13:
; # (== @ EAGAIN)
  %19 = icmp eq i32 %16, 4
  br label %$11
$11:
  %20 = phi i1 [1, %$3], [1, %$12], [%19, %$13] ; # ->
  br i1 %20, label %$15, label %$14
$14:
; # (lockErr)
  call void @lockErr()
  unreachable
$15:
; # (while (lt0 (getLock (Db: fd) N Len)) (unless (== (gErrno) EINTR)...
  br label %$16
$16:
; # (Db: fd)
  %21 = bitcast i8* %0 to i32*
  %22 = load i32, i32* %21
; # (getLock (Db: fd) N Len)
  %23 = call i32 @getLock(i32 %22, i64 %1, i64 %2)
; # (lt0 (getLock (Db: fd) N Len))
  %24 = icmp slt i32 %23, 0
  br i1 %24, label %$17, label %$18
$17:
; # (unless (== (gErrno) EINTR) (lockErr))
; # (gErrno)
  %25 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %26 = icmp eq i32 %25, 2
  br i1 %26, label %$20, label %$19
$19:
; # (lockErr)
  call void @lockErr()
  unreachable
$20:
  br label %$16
$18:
; # (? (gt0 @) @)
; # (gt0 @)
  %27 = icmp sgt i32 %23, 0
  br i1 %27, label %$22, label %$21
$22:
  br label %$4
$21:
  br label %$2
$4:
  %28 = phi i32 [0, %$6], [%23, %$22] ; # ->
  ret i32 %28
}

define void @lockJnl() align 8 {
$1:
; # (val $DbJnl)
  %0 = load i8*, i8** @$DbJnl
; # (fileno (val $DbJnl))
  %1 = call i32 @fileno(i8* %0)
; # (wrLockWait (fileno (val $DbJnl)) 0)
  call void @wrLockWait(i32 %1, i64 0)
  ret void
}

define void @unLockJnl() align 8 {
$1:
; # (let Jnl (val $DbJnl) (fflush Jnl) (unLock (fileno Jnl) 0 0))
; # (val $DbJnl)
  %0 = load i8*, i8** @$DbJnl
; # (fflush Jnl)
  %1 = call i32 @fflush(i8* %0)
; # (fileno Jnl)
  %2 = call i32 @fileno(i8* %0)
; # (unLock (fileno Jnl) 0 0)
  %3 = call i32 @unLock(i32 %2, i64 0, i64 0)
  ret void
}

define void @blkPeek(i64, i8*, i32) align 8 {
$1:
; # (let (S (i64 Siz) Db: (dbFile (val $DbFile))) (unless (== S (prea...
; # (i64 Siz)
  %3 = sext i32 %2 to i64
; # (val $DbFile)
  %4 = load i8*, i8** @$DbFile
; # (unless (== S (pread (Db: fd) Buf S Pos)) (dbRdErr))
; # (Db: fd)
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5
; # (pread (Db: fd) Buf S Pos)
  %7 = call i64 @pread(i32 %6, i8* %1, i64 %3, i64 %0)
; # (== S (pread (Db: fd) Buf S Pos))
  %8 = icmp eq i64 %3, %7
  br i1 %8, label %$3, label %$2
$2:
; # (dbRdErr)
  call void @dbRdErr()
  unreachable
$3:
  ret void
}

define i8* @rdBlock(i64) align 8 {
$1:
; # (let (Db: (dbFile (val $DbFile)) Blk (val $DbBlock)) (blkPeek (sh...
; # (val $DbFile)
  %1 = load i8*, i8** @$DbFile
; # (val $DbBlock)
  %2 = load i8*, i8** @$DbBlock
; # (set $BlkIndex N)
  store i64 %0, i64* @$BlkIndex
; # (Db: sh)
  %3 = getelementptr i8, i8* %1, i32 8
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (i64 (Db: sh))
  %6 = sext i32 %5 to i64
; # (shl (set $BlkIndex N) (i64 (Db: sh)))
  %7 = shl i64 %0, %6
; # (Db: siz)
  %8 = getelementptr i8, i8* %1, i32 12
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (blkPeek (shl (set $BlkIndex N) (i64 (Db: sh))) Blk (Db: siz))
  call void @blkPeek(i64 %7, i8* %2, i32 %10)
; # (set $BlkLink (& (getAdr Blk) BLKMASK) $BlkEnd (ofs Blk (Db: siz)...
; # (getAdr Blk)
  %11 = call i64 @getAdr(i8* %2)
; # (& (getAdr Blk) BLKMASK)
  %12 = and i64 %11, -64
  store i64 %12, i64* @$BlkLink
; # (Db: siz)
  %13 = getelementptr i8, i8* %1, i32 12
  %14 = bitcast i8* %13 to i32*
  %15 = load i32, i32* %14
; # (ofs Blk (Db: siz))
  %16 = getelementptr i8, i8* %2, i32 %15
  store i8* %16, i8** @$BlkEnd
; # (ofs Blk BLK)
  %17 = getelementptr i8, i8* %2, i32 6
  store i8* %17, i8** @$BlkPtr
  ret i8* %2
}

define void @blkPoke(i64, i8*, i32) align 8 {
$1:
; # (let Db: (dbFile (val $DbFile)) (unless (== Siz (i32 (pwrite (Db:...
; # (val $DbFile)
  %3 = load i8*, i8** @$DbFile
; # (unless (== Siz (i32 (pwrite (Db: fd) Buf (i64 Siz) Pos))) (dbWrE...
; # (Db: fd)
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (i64 Siz)
  %6 = sext i32 %2 to i64
; # (pwrite (Db: fd) Buf (i64 Siz) Pos)
  %7 = call i64 @pwrite(i32 %5, i8* %1, i64 %6, i64 %0)
; # (i32 (pwrite (Db: fd) Buf (i64 Siz) Pos))
  %8 = trunc i64 %7 to i32
; # (== Siz (i32 (pwrite (Db: fd) Buf (i64 Siz) Pos)))
  %9 = icmp eq i32 %2, %8
  br i1 %9, label %$3, label %$2
$2:
; # (dbWrErr)
  call void @dbWrErr()
  unreachable
$3:
; # (when (val $DbJnl) (let Jnl @ (putc_unlocked (if (== Siz (Db: siz...
; # (val $DbJnl)
  %10 = load i8*, i8** @$DbJnl
  %11 = icmp ne i8* %10, null
  br i1 %11, label %$4, label %$5
$4:
; # (let Jnl @ (putc_unlocked (if (== Siz (Db: siz)) 0 Siz) Jnl) (let...
; # (if (== Siz (Db: siz)) 0 Siz)
; # (Db: siz)
  %12 = getelementptr i8, i8* %3, i32 12
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13
; # (== Siz (Db: siz))
  %15 = icmp eq i32 %2, %14
  br i1 %15, label %$6, label %$7
$6:
  br label %$8
$7:
  br label %$8
$8:
  %16 = phi i32 [0, %$6], [%2, %$7] ; # ->
; # (putc_unlocked (if (== Siz (Db: siz)) 0 Siz) Jnl)
  %17 = call i32 @putc_unlocked(i32 %16, i8* %10)
; # (let P (b8 (+ BLK 2)) (set P (i8 (Db: db))) (set 2 P (i8 (shr (Db...
; # (+ BLK 2)
; # (b8 (+ BLK 2))
  %18 = alloca i8, i64 8
; # (set P (i8 (Db: db)))
; # (Db: db)
  %19 = getelementptr i8, i8* %3, i32 4
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* %20
; # (i8 (Db: db))
  %22 = trunc i32 %21 to i8
  store i8 %22, i8* %18
; # (set 2 P (i8 (shr (Db: db) 8)))
; # (Db: db)
  %23 = getelementptr i8, i8* %3, i32 4
  %24 = bitcast i8* %23 to i32*
  %25 = load i32, i32* %24
; # (shr (Db: db) 8)
  %26 = lshr i32 %25, 8
; # (i8 (shr (Db: db) 8))
  %27 = trunc i32 %26 to i8
  %28 = getelementptr i8, i8* %18, i32 1
  store i8 %27, i8* %28
; # (Db: sh)
  %29 = getelementptr i8, i8* %3, i32 8
  %30 = bitcast i8* %29 to i32*
  %31 = load i32, i32* %30
; # (i64 (Db: sh))
  %32 = sext i32 %31 to i64
; # (shr Pos (i64 (Db: sh)))
  %33 = lshr i64 %0, %32
; # (ofs P 2)
  %34 = getelementptr i8, i8* %18, i32 2
; # (setAdr (shr Pos (i64 (Db: sh))) (ofs P 2))
  call void @setAdr(i64 %33, i8* %34)
; # (unless (and (== 1 (fwrite P (+ BLK 2) 1 Jnl)) (== 1 (fwrite Buf ...
; # (and (== 1 (fwrite P (+ BLK 2) 1 Jnl)) (== 1 (fwrite Buf (i64 Siz...
; # (+ BLK 2)
; # (fwrite P (+ BLK 2) 1 Jnl)
  %35 = call i32 @fwrite(i8* %18, i64 8, i64 1, i8* %10)
; # (== 1 (fwrite P (+ BLK 2) 1 Jnl))
  %36 = icmp eq i32 1, %35
  br i1 %36, label %$10, label %$9
$10:
; # (i64 Siz)
  %37 = sext i32 %2 to i64
; # (fwrite Buf (i64 Siz) 1 Jnl)
  %38 = call i32 @fwrite(i8* %1, i64 %37, i64 1, i8* %10)
; # (== 1 (fwrite Buf (i64 Siz) 1 Jnl))
  %39 = icmp eq i32 1, %38
  br label %$9
$9:
  %40 = phi i1 [0, %$8], [%39, %$10] ; # ->
  br i1 %40, label %$12, label %$11
$11:
; # (strErrno)
  %41 = call i8* @strErrno()
; # (err 0 0 ($ "Journal write: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([18 x i8]* @$54 to i8*), i8* %41)
  unreachable
$12:
  br label %$5
$5:
  ret void
}

define void @wrBlock() align 8 {
$1:
; # (let Db: (dbFile (val $DbFile)) (blkPoke (shl (val $BlkIndex) (i6...
; # (val $DbFile)
  %0 = load i8*, i8** @$DbFile
; # (val $BlkIndex)
  %1 = load i64, i64* @$BlkIndex
; # (Db: sh)
  %2 = getelementptr i8, i8* %0, i32 8
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3
; # (i64 (Db: sh))
  %5 = sext i32 %4 to i64
; # (shl (val $BlkIndex) (i64 (Db: sh)))
  %6 = shl i64 %1, %5
; # (val $DbBlock)
  %7 = load i8*, i8** @$DbBlock
; # (Db: siz)
  %8 = getelementptr i8, i8* %0, i32 12
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (blkPoke (shl (val $BlkIndex) (i64 (Db: sh))) (val $DbBlock) (Db:...
  call void @blkPoke(i64 %6, i8* %7, i32 %10)
  ret void
}

define void @logBlock() align 8 {
$1:
; # (let (Db: (dbFile (val $DbFile)) Log (val $DbLog) P (b8 (+ BLK 2)...
; # (val $DbFile)
  %0 = load i8*, i8** @$DbFile
; # (val $DbLog)
  %1 = load i8*, i8** @$DbLog
; # (+ BLK 2)
; # (b8 (+ BLK 2))
  %2 = alloca i8, i64 8
; # (set P (i8 (Db: db)))
; # (Db: db)
  %3 = getelementptr i8, i8* %0, i32 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (i8 (Db: db))
  %6 = trunc i32 %5 to i8
  store i8 %6, i8* %2
; # (set 2 P (i8 (shr (Db: db) 8)))
; # (Db: db)
  %7 = getelementptr i8, i8* %0, i32 4
  %8 = bitcast i8* %7 to i32*
  %9 = load i32, i32* %8
; # (shr (Db: db) 8)
  %10 = lshr i32 %9, 8
; # (i8 (shr (Db: db) 8))
  %11 = trunc i32 %10 to i8
  %12 = getelementptr i8, i8* %2, i32 1
  store i8 %11, i8* %12
; # (val $BlkIndex)
  %13 = load i64, i64* @$BlkIndex
; # (ofs P 2)
  %14 = getelementptr i8, i8* %2, i32 2
; # (setAdr (val $BlkIndex) (ofs P 2))
  call void @setAdr(i64 %13, i8* %14)
; # (unless (and (== 1 (fwrite P (+ BLK 2) 1 Log)) (== 1 (fwrite (val...
; # (and (== 1 (fwrite P (+ BLK 2) 1 Log)) (== 1 (fwrite (val $DbBloc...
; # (+ BLK 2)
; # (fwrite P (+ BLK 2) 1 Log)
  %15 = call i32 @fwrite(i8* %2, i64 8, i64 1, i8* %1)
; # (== 1 (fwrite P (+ BLK 2) 1 Log))
  %16 = icmp eq i32 1, %15
  br i1 %16, label %$3, label %$2
$3:
; # (val $DbBlock)
  %17 = load i8*, i8** @$DbBlock
; # (Db: siz)
  %18 = getelementptr i8, i8* %0, i32 12
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19
; # (i64 (Db: siz))
  %21 = sext i32 %20 to i64
; # (fwrite (val $DbBlock) (i64 (Db: siz)) 1 Log)
  %22 = call i32 @fwrite(i8* %17, i64 %21, i64 1, i8* %1)
; # (== 1 (fwrite (val $DbBlock) (i64 (Db: siz)) 1 Log))
  %23 = icmp eq i32 1, %22
  br label %$2
$2:
  %24 = phi i1 [0, %$1], [%23, %$3] ; # ->
  br i1 %24, label %$5, label %$4
$4:
; # (strErrno)
  %25 = call i8* @strErrno()
; # (err 0 0 ($ "Log write: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$55 to i8*), i8* %25)
  unreachable
$5:
  ret void
}

define i64 @newBlock() align 8 {
$1:
; # (let (Db: (dbFile (val $DbFile)) Siz (Db: siz) P (b8 Siz)) (blkPe...
; # (val $DbFile)
  %0 = load i8*, i8** @$DbFile
; # (Db: siz)
  %1 = getelementptr i8, i8* %0, i32 12
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (b8 Siz)
  %4 = alloca i8, i32 %3
; # (* 2 BLK)
; # (blkPeek 0 P (* 2 BLK))
  call void @blkPeek(i64 0, i8* %4, i32 12)
; # (let N (getAdr P) (cond ((and N (Db: flu)) (blkPeek (shl N (i64 (...
; # (getAdr P)
  %5 = call i64 @getAdr(i8* %4)
; # (cond ((and N (Db: flu)) (blkPeek (shl N (i64 (Db: sh))) P BLK) (...
; # (and N (Db: flu))
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$4, label %$3
$4:
  %7 = phi i64 [%5, %$1] ; # N
; # (Db: flu)
  %8 = getelementptr i8, i8* %0, i32 32
  %9 = bitcast i8* %8 to i64*
  %10 = load i64, i64* %9
  %11 = icmp ne i64 %10, 0
  br label %$3
$3:
  %12 = phi i64 [%5, %$1], [%7, %$4] ; # N
  %13 = phi i1 [0, %$1], [%11, %$4] ; # ->
  br i1 %13, label %$6, label %$5
$6:
  %14 = phi i64 [%12, %$3] ; # N
; # (Db: sh)
  %15 = getelementptr i8, i8* %0, i32 8
  %16 = bitcast i8* %15 to i32*
  %17 = load i32, i32* %16
; # (i64 (Db: sh))
  %18 = sext i32 %17 to i64
; # (shl N (i64 (Db: sh)))
  %19 = shl i64 %14, %18
; # (blkPeek (shl N (i64 (Db: sh))) P BLK)
  call void @blkPeek(i64 %19, i8* %4, i32 6)
; # (Db: flu (dec (Db: flu)))
  %20 = getelementptr i8, i8* %0, i32 32
  %21 = bitcast i8* %20 to i64*
  %22 = getelementptr i8, i8* %0, i32 32
  %23 = bitcast i8* %22 to i64*
  %24 = load i64, i64* %23
  %25 = sub i64 %24, 1
  store i64 %25, i64* %21
  br label %$2
$5:
  %26 = phi i64 [%12, %$3] ; # N
; # (ofs P BLK)
  %27 = getelementptr i8, i8* %4, i32 6
; # (getAdr (ofs P BLK))
  %28 = call i64 @getAdr(i8* %27)
; # (== (setq N (getAdr (ofs P BLK))) (hex "FFFFFFFFFFC0"))
  %29 = icmp eq i64 %28, 281474976710592
  br i1 %29, label %$8, label %$7
$8:
  %30 = phi i64 [%28, %$5] ; # N
; # (err 0 0 ($ "DB Oversize") null)
  call void @err(i64 0, i64 0, i8* bitcast ([12 x i8]* @$56 to i8*), i8* null)
  unreachable
$7:
  %31 = phi i64 [%28, %$5] ; # N
; # (+ N BLKSIZE)
  %32 = add i64 %31, 64
; # (ofs P BLK)
  %33 = getelementptr i8, i8* %4, i32 6
; # (setAdr (+ N BLKSIZE) (ofs P BLK))
  call void @setAdr(i64 %32, i8* %33)
  br label %$2
$2:
  %34 = phi i64 [%14, %$6], [%31, %$7] ; # N
; # (* 2 BLK)
; # (blkPoke 0 P (* 2 BLK))
  call void @blkPoke(i64 0, i8* %4, i32 12)
; # (i64 Siz)
  %35 = sext i32 %3 to i64
; # (memset P 0 (i64 Siz) T)
  call void @llvm.memset.p0i8.i64(i8* align 8 %4, i8 0, i64 %35, i1 0)
; # (Db: sh)
  %36 = getelementptr i8, i8* %0, i32 8
  %37 = bitcast i8* %36 to i32*
  %38 = load i32, i32* %37
; # (i64 (Db: sh))
  %39 = sext i32 %38 to i64
; # (shl N (i64 (Db: sh)))
  %40 = shl i64 %34, %39
; # (blkPoke (shl N (i64 (Db: sh))) P Siz)
  call void @blkPoke(i64 %40, i8* %4, i32 %3)
  ret i64 %34
}

define i64 @newId(i64, i32) align 8 {
$1:
; # (when (>= (dec 'N) (val $DBs)) (dbfErr Exe))
; # (dec 'N)
  %2 = sub i32 %1, 1
; # (val $DBs)
  %3 = load i32, i32* @$DBs
; # (>= (dec 'N) (val $DBs))
  %4 = icmp sge i32 %2, %3
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i32 [%2, %$1] ; # N
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$3:
  %6 = phi i32 [%2, %$1] ; # N
; # (set $DbFile (ofs (val $DbFiles) (* N (dbFile T))))
; # (val $DbFiles)
  %7 = load i8*, i8** @$DbFiles
; # (* N (dbFile T))
  %8 = mul i32 %6, 42
; # (ofs (val $DbFiles) (* N (dbFile T)))
  %9 = getelementptr i8, i8* %7, i32 %8
  store i8* %9, i8** @$DbFile
; # (set $Protect (inc (val $Protect)))
; # (val $Protect)
  %10 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (inc (val $Protect))
  %11 = add i32 %10, 1
  store i32 %11, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (wrLockDb)
  call void @wrLockDb()
; # (when (val $DbJnl) (lockJnl))
; # (val $DbJnl)
  %12 = load i8*, i8** @$DbJnl
  %13 = icmp ne i8* %12, null
  br i1 %13, label %$4, label %$5
$4:
  %14 = phi i32 [%6, %$3] ; # N
; # (lockJnl)
  call void @lockJnl()
  br label %$5
$5:
  %15 = phi i32 [%6, %$3], [%14, %$4] ; # N
; # (prog1 (extNm ((dbFile (val $DbFile)) db) (shr (newBlock) 6)) (wh...
; # (val $DbFile)
  %16 = load i8*, i8** @$DbFile
; # ((dbFile (val $DbFile)) db)
  %17 = getelementptr i8, i8* %16, i32 4
  %18 = bitcast i8* %17 to i32*
  %19 = load i32, i32* %18
; # (newBlock)
  %20 = call i64 @newBlock()
; # (shr (newBlock) 6)
  %21 = lshr i64 %20, 6
; # (extNm ((dbFile (val $DbFile)) db) (shr (newBlock) 6))
  %22 = call i64 @extNm(i32 %19, i64 %21)
; # (when (val $DbJnl) (unLockJnl))
; # (val $DbJnl)
  %23 = load i8*, i8** @$DbJnl
  %24 = icmp ne i8* %23, null
  br i1 %24, label %$6, label %$7
$6:
  %25 = phi i32 [%15, %$5] ; # N
; # (unLockJnl)
  call void @unLockJnl()
  br label %$7
$7:
  %26 = phi i32 [%15, %$5], [%25, %$6] ; # N
; # (unLockDb 1)
  call void @unLockDb(i64 1)
; # (set $Protect (dec (val $Protect)))
; # (val $Protect)
  %27 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (dec (val $Protect))
  %28 = sub i32 %27, 1
  store i32 %28, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
  ret i64 %22
}

define i1 @isLife(i64) align 8 {
$1:
; # (let (Nm (name (& (val (tail Sym)) -9)) F (objFile Nm) N (shl (ob...
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (& (val (tail Sym)) -9)
  %4 = and i64 %3, -9
; # (name (& (val (tail Sym)) -9))
  br label %$2
$2:
  %5 = phi i64 [%4, %$1], [%11, %$3] ; # Tail
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$3:
  %8 = phi i64 [%5, %$2] ; # Tail
  %9 = inttoptr i64 %8 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
  br label %$2
$4:
  %12 = phi i64 [%5, %$2] ; # Tail
; # (objFile Nm)
  %13 = call i32 @objFile(i64 %12)
; # (objId Nm)
  %14 = call i64 @objId(i64 %12)
; # (shl (objId Nm) 6)
  %15 = shl i64 %14, 6
; # (when N (cond ((> (val $DBs) F) (setq Nm (add Nm Nm)) (when @@ (r...
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$5, label %$6
$5:
  %17 = phi i64 [%12, %$4] ; # Nm
; # (cond ((> (val $DBs) F) (setq Nm (add Nm Nm)) (when @@ (ret YES))...
; # (val $DBs)
  %18 = load i32, i32* @$DBs
; # (> (val $DBs) F)
  %19 = icmp sgt i32 %18, %13
  br i1 %19, label %$9, label %$8
$9:
  %20 = phi i64 [%17, %$5] ; # Nm
; # (add Nm Nm)
  %21 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %20, i64 %20)
  %22 = extractvalue {i64, i1} %21, 1
  %23 = extractvalue {i64, i1} %21, 0
; # (when @@ (ret YES))
  br i1 %22, label %$10, label %$11
$10:
  %24 = phi i64 [%23, %$9] ; # Nm
; # (ret YES)
  ret i1 1
$11:
  %25 = phi i64 [%23, %$9] ; # Nm
; # (add Nm Nm)
  %26 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %25, i64 %25)
  %27 = extractvalue {i64, i1} %26, 1
  %28 = extractvalue {i64, i1} %26, 0
; # (when @@ (ret YES))
  br i1 %27, label %$12, label %$13
$12:
  %29 = phi i64 [%25, %$11] ; # Nm
; # (ret YES)
  ret i1 1
$13:
  %30 = phi i64 [%25, %$11] ; # Nm
; # (let (Db: (dbFile (set $DbFile (ofs (val $DbFiles) (* F (dbFile T...
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %31 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %32 = mul i32 %13, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %33 = getelementptr i8, i8* %31, i32 %32
  store i8* %33, i8** @$DbFile
; # (* BLK 2)
; # (b8 (* BLK 2))
  %34 = alloca i8, i64 12
; # (blkPeek BLK P BLK)
  call void @blkPeek(i64 6, i8* %34, i32 6)
; # (when (> (getAdr P) N) (blkPeek (shl N (i64 (Db: sh))) P BLK) (wh...
; # (getAdr P)
  %35 = call i64 @getAdr(i8* %34)
; # (> (getAdr P) N)
  %36 = icmp ugt i64 %35, %15
  br i1 %36, label %$14, label %$15
$14:
  %37 = phi i64 [%30, %$13] ; # Nm
; # (Db: sh)
  %38 = getelementptr i8, i8* %33, i32 8
  %39 = bitcast i8* %38 to i32*
  %40 = load i32, i32* %39
; # (i64 (Db: sh))
  %41 = sext i32 %40 to i64
; # (shl N (i64 (Db: sh)))
  %42 = shl i64 %15, %41
; # (blkPeek (shl N (i64 (Db: sh))) P BLK)
  call void @blkPeek(i64 %42, i8* %34, i32 6)
; # (when (== 1 (& (val P) BLKTAG)) (ret YES))
; # (val P)
  %43 = load i8, i8* %34
; # (& (val P) BLKTAG)
  %44 = and i8 %43, 63
; # (== 1 (& (val P) BLKTAG))
  %45 = icmp eq i8 1, %44
  br i1 %45, label %$16, label %$17
$16:
  %46 = phi i64 [%37, %$14] ; # Nm
; # (ret YES)
  ret i1 1
$17:
  %47 = phi i64 [%37, %$14] ; # Nm
  br label %$15
$15:
  %48 = phi i64 [%30, %$13], [%47, %$17] ; # Nm
  br label %$7
$8:
  %49 = phi i64 [%17, %$5] ; # Nm
; # (val $Ext)
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 536) to i64) to i64*
  %51 = load i64, i64* %50
; # (pair (val $Ext))
  %52 = and i64 %51, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$19, label %$18
$19:
  %54 = phi i64 [%49, %$8] ; # Nm
; # (ret YES)
  ret i1 1
$18:
  %55 = phi i64 [%49, %$8] ; # Nm
  br label %$7
$7:
  %56 = phi i64 [%48, %$15], [%55, %$18] ; # Nm
  br label %$6
$6:
  %57 = phi i64 [%12, %$4], [%56, %$7] ; # Nm
  ret i1 0
}

define i64 @_extQ(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (sym? (val (tail X)))...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (sym? (val (tail X))) (isLife X)) X $Nil)
; # (and (symb? X) (sym? (val (tail X))) (isLife X))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (tail X)
  %17 = add i64 %13, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$7
$9:
; # (isLife X)
  %22 = call i1 @isLife(i64 %13)
  br label %$7
$7:
  %23 = phi i1 [0, %$2], [0, %$8], [%22, %$9] ; # ->
  br i1 %23, label %$10, label %$11
$10:
  br label %$12
$11:
  br label %$12
$12:
  %24 = phi i64 [%13, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  ret i64 %24
}

define void @cleanUp(i64) align 8 {
$1:
; # (let (P (b8 BLK) Db: (dbFile (val $DbFile))) (blkPeek 0 P BLK) (l...
; # (b8 BLK)
  %1 = alloca i8, i64 6
; # (val $DbFile)
  %2 = load i8*, i8** @$DbFile
; # (blkPeek 0 P BLK)
  call void @blkPeek(i64 0, i8* %1, i32 6)
; # (let Free (getAdr P) (setAdr N P) (blkPoke 0 P BLK) (loop (let Po...
; # (getAdr P)
  %3 = call i64 @getAdr(i8* %1)
; # (setAdr N P)
  call void @setAdr(i64 %0, i8* %1)
; # (blkPoke 0 P BLK)
  call void @blkPoke(i64 0, i8* %1, i32 6)
; # (loop (let Pos (shl N (i64 (Db: sh))) (blkPeek Pos P BLK) (set P ...
  br label %$2
$2:
  %4 = phi i64 [%0, %$1], [%15, %$3] ; # N
; # (let Pos (shl N (i64 (Db: sh))) (blkPeek Pos P BLK) (set P (& (va...
; # (Db: sh)
  %5 = getelementptr i8, i8* %2, i32 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
; # (i64 (Db: sh))
  %8 = sext i32 %7 to i64
; # (shl N (i64 (Db: sh)))
  %9 = shl i64 %4, %8
; # (blkPeek Pos P BLK)
  call void @blkPeek(i64 %9, i8* %1, i32 6)
; # (set P (& (val P) BLKMASK))
; # (val P)
  %10 = load i8, i8* %1
; # (& (val P) BLKMASK)
  %11 = and i8 %10, -64
  store i8 %11, i8* %1
; # (? (=0 (setq N (getAdr P))) (setAdr Free P) (blkPoke Pos P BLK))
; # (getAdr P)
  %12 = call i64 @getAdr(i8* %1)
; # (=0 (setq N (getAdr P)))
  %13 = icmp eq i64 %12, 0
  br i1 %13, label %$5, label %$3
$5:
  %14 = phi i64 [%12, %$2] ; # N
; # (setAdr Free P)
  call void @setAdr(i64 %3, i8* %1)
; # (blkPoke Pos P BLK)
  call void @blkPoke(i64 %9, i8* %1, i32 6)
  br label %$4
$3:
  %15 = phi i64 [%12, %$2] ; # N
; # (blkPoke Pos P BLK)
  call void @blkPoke(i64 %9, i8* %1, i32 6)
  br label %$2
$4:
  %16 = phi i64 [%14, %$5] ; # N
  ret void
}

define i32 @getBlock() align 8 {
$1:
; # (let P (val $BlkPtr) (when (== P (val $BlkEnd)) (unless (val $Blk...
; # (val $BlkPtr)
  %0 = load i8*, i8** @$BlkPtr
; # (when (== P (val $BlkEnd)) (unless (val $BlkLink) (ret -1)) (setq...
; # (val $BlkEnd)
  %1 = load i8*, i8** @$BlkEnd
; # (== P (val $BlkEnd))
  %2 = icmp eq i8* %0, %1
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i8* [%0, %$1] ; # P
; # (unless (val $BlkLink) (ret -1))
; # (val $BlkLink)
  %4 = load i64, i64* @$BlkLink
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$5, label %$4
$4:
  %6 = phi i8* [%3, %$2] ; # P
; # (ret -1)
  ret i32 -1
$5:
  %7 = phi i8* [%3, %$2] ; # P
; # (rdBlock @)
  %8 = call i8* @rdBlock(i64 %4)
; # (ofs (rdBlock @) BLK)
  %9 = getelementptr i8, i8* %8, i32 6
  br label %$3
$3:
  %10 = phi i8* [%0, %$1], [%9, %$5] ; # P
; # (set $BlkPtr (inc P))
; # (inc P)
  %11 = getelementptr i8, i8* %10, i32 1
  store i8* %11, i8** @$BlkPtr
; # (val P)
  %12 = load i8, i8* %10
; # (i32 (val P))
  %13 = zext i8 %12 to i32
  ret i32 %13
}

define void @putBlock(i8) align 8 {
$1:
; # (let P (val $BlkPtr) (when (== P (val $BlkEnd)) (let Link (val $B...
; # (val $BlkPtr)
  %1 = load i8*, i8** @$BlkPtr
; # (when (== P (val $BlkEnd)) (let Link (val $BlkLink) (ifn Link (le...
; # (val $BlkEnd)
  %2 = load i8*, i8** @$BlkEnd
; # (== P (val $BlkEnd))
  %3 = icmp eq i8* %1, %2
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i8* [%1, %$1] ; # P
; # (let Link (val $BlkLink) (ifn Link (let (New (newBlock) Cnt (i64 ...
; # (val $BlkLink)
  %5 = load i64, i64* @$BlkLink
; # (ifn Link (let (New (newBlock) Cnt (i64 (val (setq P (val $DbBloc...
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$4
$4:
  %7 = phi i8* [%4, %$2] ; # P
; # (let (New (newBlock) Cnt (i64 (val (setq P (val $DbBlock))))) (se...
; # (newBlock)
  %8 = call i64 @newBlock()
; # (val $DbBlock)
  %9 = load i8*, i8** @$DbBlock
; # (val (setq P (val $DbBlock)))
  %10 = load i8, i8* %9
; # (i64 (val (setq P (val $DbBlock))))
  %11 = zext i8 %10 to i64
; # (| New Cnt)
  %12 = or i64 %8, %11
; # (setAdr (| New Cnt) P)
  call void @setAdr(i64 %12, i8* %9)
; # (wrBlock)
  call void @wrBlock()
; # (set $BlkIndex New)
  store i64 %8, i64* @$BlkIndex
; # (if (== Cnt BLKTAG) Cnt (inc Cnt))
; # (== Cnt BLKTAG)
  %13 = icmp eq i64 %11, 63
  br i1 %13, label %$7, label %$8
$7:
  %14 = phi i8* [%9, %$4] ; # P
  br label %$9
$8:
  %15 = phi i8* [%9, %$4] ; # P
; # (inc Cnt)
  %16 = add i64 %11, 1
  br label %$9
$9:
  %17 = phi i8* [%14, %$7], [%15, %$8] ; # P
  %18 = phi i64 [%11, %$7], [%16, %$8] ; # ->
; # (setAdr (if (== Cnt BLKTAG) Cnt (inc Cnt)) P)
  call void @setAdr(i64 %18, i8* %17)
; # (ofs P BLK)
  %19 = getelementptr i8, i8* %17, i32 6
  br label %$6
$5:
  %20 = phi i8* [%4, %$2] ; # P
; # (wrBlock)
  call void @wrBlock()
; # (rdBlock Link)
  %21 = call i8* @rdBlock(i64 %5)
; # (ofs (rdBlock Link) BLK)
  %22 = getelementptr i8, i8* %21, i32 6
  br label %$6
$6:
  %23 = phi i8* [%19, %$9], [%22, %$5] ; # P
  %24 = phi i8* [%19, %$9], [%22, %$5] ; # ->
  br label %$3
$3:
  %25 = phi i8* [%1, %$1], [%23, %$6] ; # P
; # (set P B)
  store i8 %0, i8* %25
; # (set $BlkPtr (inc P))
; # (inc P)
  %26 = getelementptr i8, i8* %25, i32 1
  store i8* %26, i8** @$BlkPtr
  ret void
}

define i64 @_rollback(i64) align 8 {
$1:
; # (if (and (=0 (val $DBs)) (atom (val $Ext))) $Nil (let (Tos 0 P (v...
; # (and (=0 (val $DBs)) (atom (val $Ext)))
; # (val $DBs)
  %1 = load i32, i32* @$DBs
; # (=0 (val $DBs))
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %$3, label %$2
$3:
; # (val $Ext)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 536) to i64) to i64*
  %4 = load i64, i64* %3
; # (atom (val $Ext))
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br label %$2
$2:
  %7 = phi i1 [0, %$1], [%6, %$3] ; # ->
  br i1 %7, label %$4, label %$5
$4:
  br label %$6
$5:
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (cdr P) (? (atom ...
; # (val $Extern)
  %8 = load i64, i64* @$Extern
; # (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @)...
  br label %$7
$7:
  %9 = phi i64 [0, %$5], [%109, %$18] ; # Tos
  %10 = phi i64 [%8, %$5], [%110, %$18] ; # P
; # (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set ...
  br label %$8
$8:
  %11 = phi i64 [%9, %$7], [%22, %$9] ; # Tos
  %12 = phi i64 [%10, %$7], [%18, %$9] ; # P
; # (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set 2 X To...
; # (cdr P)
  %13 = inttoptr i64 %12 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (? (atom (cdr X)))
; # (cdr X)
  %16 = inttoptr i64 %15 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (atom (cdr X))
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$9
$9:
  %21 = phi i64 [%11, %$8] ; # Tos
  %22 = phi i64 [%12, %$8] ; # P
; # (let Y P (setq P @) (set 2 X Tos) (setq Tos Y))
; # (set 2 X Tos)
  %23 = inttoptr i64 %15 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %21, i64* %24
  br label %$8
$10:
  %25 = phi i64 [%11, %$8] ; # Tos
  %26 = phi i64 [%12, %$8] ; # P
  %27 = phi i64 [0, %$8] ; # ->
; # (loop (let (S (val P) Tail (val (tail S))) (unless (num? Tail) (s...
  br label %$11
$11:
  %28 = phi i64 [%25, %$10], [%106, %$24] ; # Tos
  %29 = phi i64 [%26, %$10], [%107, %$24] ; # P
; # (let (S (val P) Tail (val (tail S))) (unless (num? Tail) (setq Ta...
; # (val P)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (tail S)
  %32 = add i64 %31, -8
; # (val (tail S))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (unless (num? Tail) (setq Tail (& Tail -9)) (loop (? (num? (shift...
; # (num? Tail)
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$12:
  %37 = phi i64 [%28, %$11] ; # Tos
  %38 = phi i64 [%29, %$11] ; # P
  %39 = phi i64 [%34, %$11] ; # Tail
; # (& Tail -9)
  %40 = and i64 %39, -9
; # (loop (? (num? (shift Tail))))
  br label %$14
$14:
  %41 = phi i64 [%37, %$12], [%49, %$15] ; # Tos
  %42 = phi i64 [%38, %$12], [%50, %$15] ; # P
  %43 = phi i64 [%40, %$12], [%51, %$15] ; # Tail
; # (? (num? (shift Tail)))
; # (shift Tail)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (num? (shift Tail))
  %47 = and i64 %46, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$16, label %$15
$15:
  %49 = phi i64 [%41, %$14] ; # Tos
  %50 = phi i64 [%42, %$14] ; # P
  %51 = phi i64 [%46, %$14] ; # Tail
  br label %$14
$16:
  %52 = phi i64 [%41, %$14] ; # Tos
  %53 = phi i64 [%42, %$14] ; # P
  %54 = phi i64 [%46, %$14] ; # Tail
  %55 = phi i64 [0, %$14] ; # ->
; # (sym Tail)
  %56 = or i64 %54, 8
  br label %$13
$13:
  %57 = phi i64 [%28, %$11], [%52, %$16] ; # Tos
  %58 = phi i64 [%29, %$11], [%53, %$16] ; # P
  %59 = phi i64 [%34, %$11], [%56, %$16] ; # Tail
; # (set (tail S) (shr (shl Tail 2) 2))
; # (tail S)
  %60 = add i64 %31, -8
; # (shl Tail 2)
  %61 = shl i64 %59, 2
; # (shr (shl Tail 2) 2)
  %62 = lshr i64 %61, 2
  %63 = inttoptr i64 %60 to i64*
  store i64 %62, i64* %63
; # (set S $Nil)
  %64 = inttoptr i64 %31 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %64
; # (let X (cdr P) (? (pair (car X)) (let Y P (setq P @) (set X Tos) ...
; # (cdr P)
  %65 = inttoptr i64 %58 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (? (pair (car X)) (let Y P (setq P @) (set X Tos) (setq Tos (| Y ...
; # (car X)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (pair (car X))
  %70 = and i64 %69, 15
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %$19, label %$17
$19:
  %72 = phi i64 [%57, %$13] ; # Tos
  %73 = phi i64 [%58, %$13] ; # P
; # (let Y P (setq P @) (set X Tos) (setq Tos (| Y 8)))
; # (set X Tos)
  %74 = inttoptr i64 %67 to i64*
  store i64 %72, i64* %74
; # (| Y 8)
  %75 = or i64 %73, 8
  br label %$18
$17:
  %76 = phi i64 [%57, %$13] ; # Tos
  %77 = phi i64 [%58, %$13] ; # P
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$20
$20:
  %78 = phi i64 [%76, %$17], [%104, %$23] ; # Tos
  %79 = phi i64 [%77, %$17], [%99, %$23] ; # P
; # (unless Tos (goto 1))
  %80 = icmp ne i64 %78, 0
  br i1 %80, label %$22, label %$21
$21:
  %81 = phi i64 [%78, %$20] ; # Tos
  %82 = phi i64 [%79, %$20] ; # P
; # (goto 1)
  br label %$-1
$22:
  %83 = phi i64 [%78, %$20] ; # Tos
  %84 = phi i64 [%79, %$20] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set ...
; # (& Tos 8)
  %85 = and i64 %83, 8
; # (=0 (& Tos 8))
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$25, label %$23
$25:
  %87 = phi i64 [%83, %$22] ; # Tos
  %88 = phi i64 [%84, %$22] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %89 = inttoptr i64 %87 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  %91 = load i64, i64* %90
; # (cdr Y)
  %92 = inttoptr i64 %91 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
; # (set 2 Y P)
  %95 = inttoptr i64 %91 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %88, i64* %96
  br label %$24
$23:
  %97 = phi i64 [%83, %$22] ; # Tos
  %98 = phi i64 [%84, %$22] ; # P
; # (& Tos -9)
  %99 = and i64 %97, -9
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %100 = inttoptr i64 %99 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
; # (car Y)
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
; # (set Y P)
  %105 = inttoptr i64 %102 to i64*
  store i64 %98, i64* %105
  br label %$20
$24:
  %106 = phi i64 [%94, %$25] ; # Tos
  %107 = phi i64 [%87, %$25] ; # P
  %108 = phi i64 [%87, %$25] ; # ->
  br label %$11
$18:
  %109 = phi i64 [%75, %$19] ; # Tos
  %110 = phi i64 [%69, %$19] ; # P
  %111 = phi i64 [%75, %$19] ; # ->
  br label %$7
$26:
; # (: 1 (when (pair (val $Zap)) (set @ $Nil)))
  br label %$-1
$-1:
; # (when (pair (val $Zap)) (set @ $Nil))
; # (val $Zap)
  %112 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 520) to i64) to i64*
  %113 = load i64, i64* %112
; # (pair (val $Zap))
  %114 = and i64 %113, 15
  %115 = icmp eq i64 %114, 0
  br i1 %115, label %$27, label %$28
$27:
; # (set @ $Nil)
  %116 = inttoptr i64 %113 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %116
  br label %$28
$28:
; # (when (val $DBs) (unLockDb 0))
; # (val $DBs)
  %117 = load i32, i32* @$DBs
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %$29, label %$30
$29:
; # (unLockDb 0)
  call void @unLockDb(i64 0)
  br label %$30
$30:
; # (unsync)
  call void @unsync()
  br label %$6
$6:
  %119 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$30] ; # ->
  ret i64 %119
}

define i64 @_extern(i64) align 8 {
$1:
; # (let (Sym (needSymb Exe (eval (cadr Exe))) Nm (name (& (val (tail...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (tail Sym)
  %17 = add i64 %13, -8
; # (val (tail Sym))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (& (val (tail Sym)) -9)
  %20 = and i64 %19, -9
; # (name (& (val (tail Sym)) -9))
  br label %$9
$9:
  %21 = phi i64 [%20, %$8], [%27, %$10] ; # Tail
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$10:
  %24 = phi i64 [%21, %$9] ; # Tail
  %25 = inttoptr i64 %24 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
  br label %$9
$11:
  %28 = phi i64 [%21, %$9] ; # Tail
; # (when (== Nm ZERO) (ret $Nil))
; # (== Nm ZERO)
  %29 = icmp eq i64 %28, 2
  br i1 %29, label %$12, label %$13
$12:
  %30 = phi i64 [%13, %$11] ; # Sym
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$13:
  %31 = phi i64 [%13, %$11] ; # Sym
; # (let (P (push 0 Nm) C (symChar P) F (i32 0)) (when (== C (char "{...
; # (push 0 Nm)
  %32 = alloca i64, i64 2, align 16
  store i64 0, i64* %32
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %28, i64* %33
; # (symChar P)
  %34 = call i32 @symChar(i64* %32)
; # (i32 0)
; # (when (== C (char "{")) (setq C (symChar P)))
; # (== C (char "{"))
  %35 = icmp eq i32 %34, 123
  br i1 %35, label %$14, label %$15
$14:
  %36 = phi i64 [%31, %$13] ; # Sym
  %37 = phi i32 [%34, %$13] ; # C
  %38 = phi i32 [0, %$13] ; # F
; # (symChar P)
  %39 = call i32 @symChar(i64* %32)
  br label %$15
$15:
  %40 = phi i64 [%31, %$13], [%36, %$14] ; # Sym
  %41 = phi i32 [%34, %$13], [%39, %$14] ; # C
  %42 = phi i32 [0, %$13], [%38, %$14] ; # F
; # (while (>= C (char "@")) (when (> C (char "O")) (ret $Nil)) (setq...
  br label %$16
$16:
  %43 = phi i64 [%40, %$15], [%54, %$20] ; # Sym
  %44 = phi i32 [%41, %$15], [%60, %$20] ; # C
  %45 = phi i32 [%42, %$15], [%59, %$20] ; # F
; # (>= C (char "@"))
  %46 = icmp sge i32 %44, 64
  br i1 %46, label %$17, label %$18
$17:
  %47 = phi i64 [%43, %$16] ; # Sym
  %48 = phi i32 [%44, %$16] ; # C
  %49 = phi i32 [%45, %$16] ; # F
; # (when (> C (char "O")) (ret $Nil))
; # (> C (char "O"))
  %50 = icmp sgt i32 %48, 79
  br i1 %50, label %$19, label %$20
$19:
  %51 = phi i64 [%47, %$17] ; # Sym
  %52 = phi i32 [%48, %$17] ; # C
  %53 = phi i32 [%49, %$17] ; # F
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$20:
  %54 = phi i64 [%47, %$17] ; # Sym
  %55 = phi i32 [%48, %$17] ; # C
  %56 = phi i32 [%49, %$17] ; # F
; # (shl F 4)
  %57 = shl i32 %56, 4
; # (- C (char "@"))
  %58 = sub i32 %55, 64
; # (| (shl F 4) (- C (char "@")))
  %59 = or i32 %57, %58
; # (symChar P)
  %60 = call i32 @symChar(i64* %32)
  br label %$16
$18:
  %61 = phi i64 [%43, %$16] ; # Sym
  %62 = phi i32 [%44, %$16] ; # C
  %63 = phi i32 [%45, %$16] ; # F
; # (let N 0 (loop (unless (and (>= C (char "0")) (>= (char "7") C)) ...
; # (loop (unless (and (>= C (char "0")) (>= (char "7") C)) (ret $Nil...
  br label %$21
$21:
  %64 = phi i64 [%61, %$18], [%103, %$28] ; # Sym
  %65 = phi i32 [%62, %$18], [%104, %$28] ; # C
  %66 = phi i32 [%63, %$18], [%105, %$28] ; # F
  %67 = phi i64 [0, %$18], [%106, %$28] ; # N
; # (unless (and (>= C (char "0")) (>= (char "7") C)) (ret $Nil))
; # (and (>= C (char "0")) (>= (char "7") C))
; # (>= C (char "0"))
  %68 = icmp sge i32 %65, 48
  br i1 %68, label %$23, label %$22
$23:
  %69 = phi i64 [%64, %$21] ; # Sym
  %70 = phi i32 [%65, %$21] ; # C
  %71 = phi i32 [%66, %$21] ; # F
  %72 = phi i64 [%67, %$21] ; # N
; # (>= (char "7") C)
  %73 = icmp sge i32 55, %70
  br label %$22
$22:
  %74 = phi i64 [%64, %$21], [%69, %$23] ; # Sym
  %75 = phi i32 [%65, %$21], [%70, %$23] ; # C
  %76 = phi i32 [%66, %$21], [%71, %$23] ; # F
  %77 = phi i64 [%67, %$21], [%72, %$23] ; # N
  %78 = phi i1 [0, %$21], [%73, %$23] ; # ->
  br i1 %78, label %$25, label %$24
$24:
  %79 = phi i64 [%74, %$22] ; # Sym
  %80 = phi i32 [%75, %$22] ; # C
  %81 = phi i32 [%76, %$22] ; # F
  %82 = phi i64 [%77, %$22] ; # N
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$25:
  %83 = phi i64 [%74, %$22] ; # Sym
  %84 = phi i32 [%75, %$22] ; # C
  %85 = phi i32 [%76, %$22] ; # F
  %86 = phi i64 [%77, %$22] ; # N
; # (shl N 3)
  %87 = shl i64 %86, 3
; # (- C (char "0"))
  %88 = sub i32 %84, 48
; # (i64 (- C (char "0")))
  %89 = sext i32 %88 to i64
; # (| (shl N 3) (i64 (- C (char "0"))))
  %90 = or i64 %87, %89
; # (? (or (=0 (setq C (symChar P))) (== C (char "}"))))
; # (or (=0 (setq C (symChar P))) (== C (char "}")))
; # (symChar P)
  %91 = call i32 @symChar(i64* %32)
; # (=0 (setq C (symChar P)))
  %92 = icmp eq i32 %91, 0
  br i1 %92, label %$26, label %$27
$27:
  %93 = phi i64 [%83, %$25] ; # Sym
  %94 = phi i32 [%91, %$25] ; # C
  %95 = phi i32 [%85, %$25] ; # F
  %96 = phi i64 [%90, %$25] ; # N
; # (== C (char "}"))
  %97 = icmp eq i32 %94, 125
  br label %$26
$26:
  %98 = phi i64 [%83, %$25], [%93, %$27] ; # Sym
  %99 = phi i32 [%91, %$25], [%94, %$27] ; # C
  %100 = phi i32 [%85, %$25], [%95, %$27] ; # F
  %101 = phi i64 [%90, %$25], [%96, %$27] ; # N
  %102 = phi i1 [1, %$25], [%97, %$27] ; # ->
  br i1 %102, label %$29, label %$28
$28:
  %103 = phi i64 [%98, %$26] ; # Sym
  %104 = phi i32 [%99, %$26] ; # C
  %105 = phi i32 [%100, %$26] ; # F
  %106 = phi i64 [%101, %$26] ; # N
  br label %$21
$29:
  %107 = phi i64 [%98, %$26] ; # Sym
  %108 = phi i32 [%99, %$26] ; # C
  %109 = phi i32 [%100, %$26] ; # F
  %110 = phi i64 [%101, %$26] ; # N
  %111 = phi i64 [0, %$26] ; # ->
; # (if (isLife (setq Sym (extern (extNm F N)))) Sym $Nil)
; # (extNm F N)
  %112 = call i64 @extNm(i32 %109, i64 %110)
; # (extern (extNm F N))
  %113 = call i64 @extern(i64 %112)
; # (isLife (setq Sym (extern (extNm F N))))
  %114 = call i1 @isLife(i64 %113)
  br i1 %114, label %$30, label %$31
$30:
  %115 = phi i64 [%113, %$29] ; # Sym
  %116 = phi i32 [%108, %$29] ; # C
  %117 = phi i32 [%109, %$29] ; # F
  %118 = phi i64 [%110, %$29] ; # N
  br label %$32
$31:
  %119 = phi i64 [%113, %$29] ; # Sym
  %120 = phi i32 [%108, %$29] ; # C
  %121 = phi i32 [%109, %$29] ; # F
  %122 = phi i64 [%110, %$29] ; # N
  br label %$32
$32:
  %123 = phi i64 [%115, %$30], [%119, %$31] ; # Sym
  %124 = phi i32 [%116, %$30], [%120, %$31] ; # C
  %125 = phi i32 [%117, %$30], [%121, %$31] ; # F
  %126 = phi i64 [%118, %$30], [%122, %$31] ; # N
  %127 = phi i64 [%115, %$30], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$31] ; # ->
  ret i64 %127
}

define void @ignLog() align 8 {
$1:
; # (stderrMsg ($ "Discarding incomplete transaction^J") null)
  %0 = call i8* @stderrMsg(i8* bitcast ([35 x i8]* @$57 to i8*), i8* null)
  ret void
}

define i1 @transaction() align 8 {
$1:
; # (let (Log (val $DbLog) Blk (b8 BLK)) (fseek0 Log) (if (fread Blk ...
; # (val $DbLog)
  %0 = load i8*, i8** @$DbLog
; # (b8 BLK)
  %1 = alloca i8, i64 6
; # (fseek0 Log)
  %2 = call i1 @fseek0(i8* %0)
; # (if (fread Blk 2 1 Log) (loop (? (== (val (i16* Blk)) (hex "FFFF"...
; # (fread Blk 2 1 Log)
  %3 = call i32 @fread(i8* %1, i64 2, i64 1, i8* %0)
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %$2, label %$3
$2:
; # (loop (? (== (val (i16* Blk)) (hex "FFFF")) YES) (? (or (=0 (dbfB...
  br label %$5
$5:
; # (? (== (val (i16* Blk)) (hex "FFFF")) YES)
; # (i16* Blk)
  %5 = bitcast i8* %1 to i16*
; # (val (i16* Blk))
  %6 = load i16, i16* %5
; # (== (val (i16* Blk)) (hex "FFFF"))
  %7 = icmp eq i16 %6, 65535
  br i1 %7, label %$8, label %$6
$8:
  br label %$7
$6:
; # (? (or (=0 (dbfBuf Blk)) (<> (fread Blk BLK 1 Log) 1) (not (fseek...
; # (or (=0 (dbfBuf Blk)) (<> (fread Blk BLK 1 Log) 1) (not (fseekOfs...
; # (dbfBuf Blk)
  %8 = call i8* @dbfBuf(i8* %1)
; # (=0 (dbfBuf Blk))
  %9 = icmp eq i8* %8, null
  br i1 %9, label %$9, label %$10
$10:
; # (fread Blk BLK 1 Log)
  %10 = call i32 @fread(i8* %1, i64 6, i64 1, i8* %0)
; # (<> (fread Blk BLK 1 Log) 1)
  %11 = icmp ne i32 %10, 1
  br i1 %11, label %$9, label %$11
$11:
; # (val $DbFile)
  %12 = load i8*, i8** @$DbFile
; # ((dbFile (val $DbFile)) siz)
  %13 = getelementptr i8, i8* %12, i32 12
  %14 = bitcast i8* %13 to i32*
  %15 = load i32, i32* %14
; # (fseekOfs Log ((dbFile (val $DbFile)) siz))
  %16 = call i1 @fseekOfs(i8* %0, i32 %15)
; # (not (fseekOfs Log ((dbFile (val $DbFile)) siz)))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$9, label %$12
$12:
; # (fread Blk 2 1 Log)
  %18 = call i32 @fread(i8* %1, i64 2, i64 1, i8* %0)
; # (<> (fread Blk 2 1 Log) 1)
  %19 = icmp ne i32 %18, 1
  br label %$9
$9:
  %20 = phi i1 [1, %$6], [1, %$10], [1, %$11], [%19, %$12] ; # ->
  br i1 %20, label %$14, label %$13
$14:
; # (ignLog)
  call void @ignLog()
  br label %$7
$13:
  br label %$5
$7:
  %21 = phi i1 [1, %$8], [0, %$14] ; # ->
  br label %$4
$3:
; # (unless (feof Log) (ignLog))
; # (feof Log)
  %22 = call i32 @feof(i8* %0)
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %$16, label %$15
$15:
; # (ignLog)
  call void @ignLog()
  br label %$16
$16:
  br label %$4
$4:
  %24 = phi i1 [%21, %$7], [0, %$16] ; # ->
  ret i1 %24
}

define void @fsyncDB(i64) align 8 {
$1:
; # (let (Db (val $DbFiles) C (val $DBs)) (loop (let Db: (dbFile Db) ...
; # (val $DbFiles)
  %1 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %2 = load i32, i32* @$DBs
; # (loop (let Db: (dbFile Db) (when (and (Db: drt) (lt0 (fsync (Db: ...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%25, %$7] ; # Db
  %4 = phi i32 [%2, %$1], [%24, %$7] ; # C
; # (let Db: (dbFile Db) (when (and (Db: drt) (lt0 (fsync (Db: fd))))...
; # (when (and (Db: drt) (lt0 (fsync (Db: fd)))) (dbSyncErr Exe))
; # (and (Db: drt) (lt0 (fsync (Db: fd))))
; # (Db: drt)
  %5 = getelementptr i8, i8* %3, i32 41
  %6 = bitcast i8* %5 to i1*
  %7 = load i1, i1* %6
  br i1 %7, label %$4, label %$3
$4:
  %8 = phi i8* [%3, %$2] ; # Db
  %9 = phi i32 [%4, %$2] ; # C
; # (Db: fd)
  %10 = bitcast i8* %3 to i32*
  %11 = load i32, i32* %10
; # (fsync (Db: fd))
  %12 = call i32 @fsync(i32 %11)
; # (lt0 (fsync (Db: fd)))
  %13 = icmp slt i32 %12, 0
  br label %$3
$3:
  %14 = phi i8* [%3, %$2], [%8, %$4] ; # Db
  %15 = phi i32 [%4, %$2], [%9, %$4] ; # C
  %16 = phi i1 [0, %$2], [%13, %$4] ; # ->
  br i1 %16, label %$5, label %$6
$5:
  %17 = phi i8* [%14, %$3] ; # Db
  %18 = phi i32 [%15, %$3] ; # C
; # (dbSyncErr Exe)
  call void @dbSyncErr(i64 %0)
  unreachable
$6:
  %19 = phi i8* [%14, %$3] ; # Db
  %20 = phi i32 [%15, %$3] ; # C
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %21 = sub i32 %20, 1
; # (=0 (dec 'C))
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %$8, label %$7
$7:
  %23 = phi i8* [%19, %$6] ; # Db
  %24 = phi i32 [%21, %$6] ; # C
; # (ofs Db (dbFile T))
  %25 = getelementptr i8, i8* %23, i32 42
  br label %$2
$8:
  %26 = phi i8* [%19, %$6] ; # Db
  %27 = phi i32 [%21, %$6] ; # C
  %28 = phi i64 [0, %$6] ; # ->
  ret void
}

define void @restore(i64) align 8 {
$1:
; # (stderrMsg ($ "Last transaction not completed: Rollback^J") null)...
  %1 = call i8* @stderrMsg(i8* bitcast ([42 x i8]* @$58 to i8*), i8* null)
; # (let Log (val $DbLog) (fseek0 Log) (let (Db (val $DbFiles) C (val...
; # (val $DbLog)
  %2 = load i8*, i8** @$DbLog
; # (fseek0 Log)
  %3 = call i1 @fseek0(i8* %2)
; # (let (Db (val $DbFiles) C (val $DBs)) (loop ((dbFile Db) drt NO) ...
; # (val $DbFiles)
  %4 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %5 = load i32, i32* @$DBs
; # (loop ((dbFile Db) drt NO) (? (=0 (dec 'C))) (setq Db (ofs Db (db...
  br label %$2
$2:
  %6 = phi i8* [%4, %$1], [%14, %$3] ; # Db
  %7 = phi i32 [%5, %$1], [%13, %$3] ; # C
; # ((dbFile Db) drt NO)
  %8 = getelementptr i8, i8* %6, i32 41
  %9 = bitcast i8* %8 to i1*
  store i1 0, i1* %9
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %10 = sub i32 %7, 1
; # (=0 (dec 'C))
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i8* [%6, %$2] ; # Db
  %13 = phi i32 [%10, %$2] ; # C
; # (ofs Db (dbFile T))
  %14 = getelementptr i8, i8* %12, i32 42
  br label %$2
$4:
  %15 = phi i8* [%6, %$2] ; # Db
  %16 = phi i32 [%10, %$2] ; # C
  %17 = phi i64 [0, %$2] ; # ->
; # (let (Blk (b8 BLK) Buf (b8 (val $MaxBlkSize))) (loop (unless (== ...
; # (b8 BLK)
  %18 = alloca i8, i64 6
; # (val $MaxBlkSize)
  %19 = load i32, i32* @$MaxBlkSize
; # (b8 (val $MaxBlkSize))
  %20 = alloca i8, i32 %19
; # (loop (unless (== (fread Blk 2 1 Log) 1) (jnlErr Exe)) (? (== (va...
  br label %$5
$5:
; # (unless (== (fread Blk 2 1 Log) 1) (jnlErr Exe))
; # (fread Blk 2 1 Log)
  %21 = call i32 @fread(i8* %18, i64 2, i64 1, i8* %2)
; # (== (fread Blk 2 1 Log) 1)
  %22 = icmp eq i32 %21, 1
  br i1 %22, label %$7, label %$6
$6:
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$7:
; # (? (== (val (i16* Blk)) (hex "FFFF")))
; # (i16* Blk)
  %23 = bitcast i8* %18 to i16*
; # (val (i16* Blk))
  %24 = load i16, i16* %23
; # (== (val (i16* Blk)) (hex "FFFF"))
  %25 = icmp eq i16 %24, 65535
  br i1 %25, label %$9, label %$8
$8:
; # (if (dbfBuf Blk) (let Db: (dbFile @) (unless (and (== (fread Blk ...
; # (dbfBuf Blk)
  %26 = call i8* @dbfBuf(i8* %18)
  %27 = icmp ne i8* %26, null
  br i1 %27, label %$10, label %$11
$10:
; # (let Db: (dbFile @) (unless (and (== (fread Blk BLK 1 Log) 1) (==...
; # (unless (and (== (fread Blk BLK 1 Log) 1) (== (fread Buf (i64 (Db...
; # (and (== (fread Blk BLK 1 Log) 1) (== (fread Buf (i64 (Db: siz)) ...
; # (fread Blk BLK 1 Log)
  %28 = call i32 @fread(i8* %18, i64 6, i64 1, i8* %2)
; # (== (fread Blk BLK 1 Log) 1)
  %29 = icmp eq i32 %28, 1
  br i1 %29, label %$14, label %$13
$14:
; # (Db: siz)
  %30 = getelementptr i8, i8* %26, i32 12
  %31 = bitcast i8* %30 to i32*
  %32 = load i32, i32* %31
; # (i64 (Db: siz))
  %33 = sext i32 %32 to i64
; # (fread Buf (i64 (Db: siz)) 1 Log)
  %34 = call i32 @fread(i8* %20, i64 %33, i64 1, i8* %2)
; # (== (fread Buf (i64 (Db: siz)) 1 Log) 1)
  %35 = icmp eq i32 %34, 1
  br label %$13
$13:
  %36 = phi i1 [0, %$10], [%35, %$14] ; # ->
  br i1 %36, label %$16, label %$15
$15:
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$16:
; # (unless (== (pwrite (Db: fd) Buf (i64 (Db: siz)) (shl (getAdr Blk...
; # (Db: fd)
  %37 = bitcast i8* %26 to i32*
  %38 = load i32, i32* %37
; # (Db: siz)
  %39 = getelementptr i8, i8* %26, i32 12
  %40 = bitcast i8* %39 to i32*
  %41 = load i32, i32* %40
; # (i64 (Db: siz))
  %42 = sext i32 %41 to i64
; # (getAdr Blk)
  %43 = call i64 @getAdr(i8* %18)
; # (Db: sh)
  %44 = getelementptr i8, i8* %26, i32 8
  %45 = bitcast i8* %44 to i32*
  %46 = load i32, i32* %45
; # (i64 (Db: sh))
  %47 = sext i32 %46 to i64
; # (shl (getAdr Blk) (i64 (Db: sh)))
  %48 = shl i64 %43, %47
; # (pwrite (Db: fd) Buf (i64 (Db: siz)) (shl (getAdr Blk) (i64 (Db: ...
  %49 = call i64 @pwrite(i32 %38, i8* %20, i64 %42, i64 %48)
; # (Db: siz)
  %50 = getelementptr i8, i8* %26, i32 12
  %51 = bitcast i8* %50 to i32*
  %52 = load i32, i32* %51
; # (i64 (Db: siz))
  %53 = sext i32 %52 to i64
; # (== (pwrite (Db: fd) Buf (i64 (Db: siz)) (shl (getAdr Blk) (i64 (...
  %54 = icmp eq i64 %49, %53
  br i1 %54, label %$18, label %$17
$17:
; # (dbWrErr)
  call void @dbWrErr()
  unreachable
$18:
; # (Db: drt YES)
  %55 = getelementptr i8, i8* %26, i32 41
  %56 = bitcast i8* %55 to i1*
  store i1 1, i1* %56
  br label %$12
$11:
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$12:
  %57 = phi i1 [1, %$18] ; # ->
  br label %$5
$9:
  %58 = phi i64 [0, %$7] ; # ->
; # (fsyncDB Exe)
  call void @fsyncDB(i64 %0)
  ret void
}

define void @truncLog(i64) align 8 {
$1:
; # (let Log (val $DbLog) (unless (and (fseek0 Log) (truncate0 (filen...
; # (val $DbLog)
  %1 = load i8*, i8** @$DbLog
; # (unless (and (fseek0 Log) (truncate0 (fileno Log))) (err Exe 0 ($...
; # (and (fseek0 Log) (truncate0 (fileno Log)))
; # (fseek0 Log)
  %2 = call i1 @fseek0(i8* %1)
  br i1 %2, label %$3, label %$2
$3:
; # (fileno Log)
  %3 = call i32 @fileno(i8* %1)
; # (truncate0 (fileno Log))
  %4 = call i1 @truncate0(i32 %3)
  br label %$2
$2:
  %5 = phi i1 [0, %$1], [%4, %$3] ; # ->
  br i1 %5, label %$5, label %$4
$4:
; # (strErrno)
  %6 = call i8* @strErrno()
; # (err Exe 0 ($ "Log truncate error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([23 x i8]* @$59 to i8*), i8* %6)
  unreachable
$5:
  ret void
}

define i64 @_pool(i64) align 8 {
$1:
; # (let (X (cdr Exe) Sym1 (save (evSym X)) Dbs (save (evLst (shift X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (save (evSym X))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %6 = load i64, i64* %5
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = add i64 %8, 8
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %12
; # (shift X)
  %13 = inttoptr i64 %3 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (evLst (shift X))
  %16 = call i64 @evLst(i64 %15)
; # (save (evLst (shift X)))
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (shift X)
  %25 = inttoptr i64 %15 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (evSym (shift X))
  %28 = call i64 @evSym(i64 %27)
; # (save (evSym (shift X)))
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %30 = load i64, i64* %29
  %31 = alloca i64, i64 2, align 16
  %32 = ptrtoint i64* %31 to i64
  %33 = inttoptr i64 %32 to i64*
  store i64 %28, i64* %33
  %34 = add i64 %32, 8
  %35 = inttoptr i64 %34 to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %36
; # (shift X)
  %37 = inttoptr i64 %27 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (evSym (shift X))
  %40 = call i64 @evSym(i64 %39)
; # (save (evSym (shift X)))
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %42 = load i64, i64* %41
  %43 = alloca i64, i64 2, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %40, i64* %45
  %46 = add i64 %44, 8
  %47 = inttoptr i64 %46 to i64*
  store i64 %42, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %48
; # (set $Solo ZERO)
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  store i64 2, i64* %49
; # (when (val $DBs) (_rollback ZERO) (let (Db (val $DbFiles) C @) (l...
; # (val $DBs)
  %50 = load i32, i32* @$DBs
  %51 = icmp ne i32 %50, 0
  br i1 %51, label %$2, label %$3
$2:
  %52 = phi i64 [%16, %$1] ; # Dbs
; # (_rollback ZERO)
  %53 = call i64 @_rollback(i64 2)
; # (let (Db (val $DbFiles) C @) (loop (let Db: (dbFile Db) (close (D...
; # (val $DbFiles)
  %54 = load i8*, i8** @$DbFiles
; # (loop (let Db: (dbFile Db) (close (Db: fd)) (free (Db: mark))) (?...
  br label %$4
$4:
  %55 = phi i64 [%52, %$2], [%66, %$5] ; # Dbs
  %56 = phi i8* [%54, %$2], [%69, %$5] ; # Db
  %57 = phi i32 [%50, %$2], [%68, %$5] ; # C
; # (let Db: (dbFile Db) (close (Db: fd)) (free (Db: mark)))
; # (Db: fd)
  %58 = bitcast i8* %56 to i32*
  %59 = load i32, i32* %58
; # (close (Db: fd))
  %60 = call i32 @close(i32 %59)
; # (Db: mark)
  %61 = getelementptr i8, i8* %56, i32 16
  %62 = bitcast i8* %61 to i8**
  %63 = load i8*, i8** %62
; # (free (Db: mark))
  call void @free(i8* %63)
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %64 = sub i32 %57, 1
; # (=0 (dec 'C))
  %65 = icmp eq i32 %64, 0
  br i1 %65, label %$6, label %$5
$5:
  %66 = phi i64 [%55, %$4] ; # Dbs
  %67 = phi i8* [%56, %$4] ; # Db
  %68 = phi i32 [%64, %$4] ; # C
; # (ofs Db (dbFile T))
  %69 = getelementptr i8, i8* %67, i32 42
  br label %$4
$6:
  %70 = phi i64 [%55, %$4] ; # Dbs
  %71 = phi i8* [%56, %$4] ; # Db
  %72 = phi i32 [%64, %$4] ; # C
  %73 = phi i64 [0, %$4] ; # ->
; # (set $DBs 0)
  store i32 0, i32* @$DBs
; # (when (val $DbJnl) (fclose @) (set $DbJnl null))
; # (val $DbJnl)
  %74 = load i8*, i8** @$DbJnl
  %75 = icmp ne i8* %74, null
  br i1 %75, label %$7, label %$8
$7:
  %76 = phi i64 [%70, %$6] ; # Dbs
; # (fclose @)
  %77 = call i32 @fclose(i8* %74)
; # (set $DbJnl null)
  store i8* null, i8** @$DbJnl
  br label %$8
$8:
  %78 = phi i64 [%70, %$6], [%76, %$7] ; # Dbs
; # (when (val $DbLog) (fclose @) (set $DbLog null))
; # (val $DbLog)
  %79 = load i8*, i8** @$DbLog
  %80 = icmp ne i8* %79, null
  br i1 %80, label %$9, label %$10
$9:
  %81 = phi i64 [%78, %$8] ; # Dbs
; # (fclose @)
  %82 = call i32 @fclose(i8* %79)
; # (set $DbLog null)
  store i8* null, i8** @$DbLog
  br label %$10
$10:
  %83 = phi i64 [%78, %$8], [%81, %$9] ; # Dbs
  br label %$3
$3:
  %84 = phi i64 [%16, %$1], [%83, %$10] ; # Dbs
; # (unless (nil? Sym1) (let (Nm (xName Exe Sym1) Len (pathSize Nm) B...
; # (nil? Sym1)
  %85 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %85, label %$12, label %$11
$11:
  %86 = phi i64 [%84, %$3] ; # Dbs
; # (let (Nm (xName Exe Sym1) Len (pathSize Nm) Buf (pathString Nm (b...
; # (xName Exe Sym1)
  %87 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %88 = call i64 @pathSize(i64 %87)
; # (+ Len 4)
  %89 = add i64 %88, 4
; # (b8 (+ Len 4))
  %90 = alloca i8, i64 %89
; # (pathString Nm (b8 (+ Len 4)))
  %91 = call i8* @pathString(i64 %87, i8* %90)
; # (dec Len)
  %92 = sub i64 %88, 1
; # (ofs Buf (dec Len))
  %93 = getelementptr i8, i8* %91, i64 %92
; # (when (pair Dbs) (let L Dbs (while (pair (shift L)) (inc 'Siz (db...
; # (pair Dbs)
  %94 = and i64 %86, 15
  %95 = icmp eq i64 %94, 0
  br i1 %95, label %$13, label %$14
$13:
  %96 = phi i64 [%86, %$11] ; # Dbs
  %97 = phi i64 [42, %$11] ; # Siz
; # (let L Dbs (while (pair (shift L)) (inc 'Siz (dbFile T))))
; # (while (pair (shift L)) (inc 'Siz (dbFile T)))
  br label %$15
$15:
  %98 = phi i64 [%96, %$13], [%106, %$16] ; # Dbs
  %99 = phi i64 [%97, %$13], [%109, %$16] ; # Siz
  %100 = phi i64 [%96, %$13], [%108, %$16] ; # L
; # (shift L)
  %101 = inttoptr i64 %100 to i64*
  %102 = getelementptr i64, i64* %101, i32 1
  %103 = load i64, i64* %102
; # (pair (shift L))
  %104 = and i64 %103, 15
  %105 = icmp eq i64 %104, 0
  br i1 %105, label %$16, label %$17
$16:
  %106 = phi i64 [%98, %$15] ; # Dbs
  %107 = phi i64 [%99, %$15] ; # Siz
  %108 = phi i64 [%103, %$15] ; # L
; # (inc 'Siz (dbFile T))
  %109 = add i64 %107, 42
  br label %$15
$17:
  %110 = phi i64 [%98, %$15] ; # Dbs
  %111 = phi i64 [%99, %$15] ; # Siz
  %112 = phi i64 [%103, %$15] ; # L
  br label %$14
$14:
  %113 = phi i64 [%86, %$11], [%110, %$17] ; # Dbs
  %114 = phi i64 [42, %$11], [%111, %$17] ; # Siz
; # (let (Db (set $DbFiles (alloc (val $DbFiles) Siz)) P (b8 (+ BLK B...
; # (set $DbFiles (alloc (val $DbFiles) Siz))
; # (val $DbFiles)
  %115 = load i8*, i8** @$DbFiles
; # (alloc (val $DbFiles) Siz)
  %116 = call i8* @alloc(i8* %115, i64 %114)
  store i8* %116, i8** @$DbFiles
; # (+ BLK BLK 1)
; # (b8 (+ BLK BLK 1))
  %117 = alloca i8, i64 13
; # (i32 0)
; # (i32 0)
; # (loop (let Db: (dbFile (set $DbFile Db)) (Db: db Fnr) (if (atom D...
  br label %$18
$18:
  %118 = phi i64 [%113, %$14], [%284, %$36] ; # Dbs
  %119 = phi i64 [%114, %$14], [%285, %$36] ; # Siz
  %120 = phi i8* [%116, %$14], [%289, %$36] ; # Db
  %121 = phi i32 [0, %$14], [%287, %$36] ; # Fnr
  %122 = phi i32 [0, %$14], [%288, %$36] ; # Max
; # (let Db: (dbFile (set $DbFile Db)) (Db: db Fnr) (if (atom Dbs) (D...
; # (set $DbFile Db)
  store i8* %120, i8** @$DbFile
; # (Db: db Fnr)
  %123 = getelementptr i8, i8* %120, i32 4
  %124 = bitcast i8* %123 to i32*
  store i32 %121, i32* %124
; # (if (atom Dbs) (Db: sh 2) (set (bufAo End Fnr) 0) (Db: sh (i32 (i...
; # (atom Dbs)
  %125 = and i64 %118, 15
  %126 = icmp ne i64 %125, 0
  br i1 %126, label %$19, label %$20
$19:
  %127 = phi i64 [%118, %$18] ; # Dbs
  %128 = phi i64 [%119, %$18] ; # Siz
  %129 = phi i8* [%120, %$18] ; # Db
  %130 = phi i32 [%121, %$18] ; # Fnr
  %131 = phi i32 [%122, %$18] ; # Max
; # (Db: sh 2)
  %132 = getelementptr i8, i8* %120, i32 8
  %133 = bitcast i8* %132 to i32*
  store i32 2, i32* %133
  br label %$21
$20:
  %134 = phi i64 [%118, %$18] ; # Dbs
  %135 = phi i64 [%119, %$18] ; # Siz
  %136 = phi i8* [%120, %$18] ; # Db
  %137 = phi i32 [%121, %$18] ; # Fnr
  %138 = phi i32 [%122, %$18] ; # Max
; # (set (bufAo End Fnr) 0)
; # (bufAo End Fnr)
  %139 = call i8* @bufAo(i8* %93, i32 %137)
  store i8 0, i8* %139
; # (Db: sh (i32 (int (++ Dbs))))
  %140 = getelementptr i8, i8* %120, i32 8
  %141 = bitcast i8* %140 to i32*
  %142 = inttoptr i64 %134 to i64*
  %143 = load i64, i64* %142
  %144 = getelementptr i64, i64* %142, i32 1
  %145 = load i64, i64* %144
  %146 = lshr i64 %143, 4
  %147 = trunc i64 %146 to i32
  store i32 %147, i32* %141
  br label %$21
$21:
  %148 = phi i64 [%127, %$19], [%145, %$20] ; # Dbs
  %149 = phi i64 [%128, %$19], [%135, %$20] ; # Siz
  %150 = phi i8* [%129, %$19], [%136, %$20] ; # Db
  %151 = phi i32 [%130, %$19], [%137, %$20] ; # Fnr
  %152 = phi i32 [%131, %$19], [%138, %$20] ; # Max
  %153 = phi i32 [2, %$19], [%147, %$20] ; # ->
; # (cond ((ge0 (Db: fd (openRdWr Buf))) (blkPeek 0 P (+ BLK BLK 1)) ...
; # (Db: fd (openRdWr Buf))
  %154 = bitcast i8* %120 to i32*
  %155 = call i32 @openRdWr(i8* %91)
  store i32 %155, i32* %154
; # (ge0 (Db: fd (openRdWr Buf)))
  %156 = icmp sge i32 %155, 0
  br i1 %156, label %$24, label %$23
$24:
  %157 = phi i64 [%148, %$21] ; # Dbs
  %158 = phi i64 [%149, %$21] ; # Siz
  %159 = phi i8* [%150, %$21] ; # Db
  %160 = phi i32 [%151, %$21] ; # Fnr
  %161 = phi i32 [%152, %$21] ; # Max
; # (+ BLK BLK 1)
; # (blkPeek 0 P (+ BLK BLK 1))
  call void @blkPeek(i64 0, i8* %117, i32 13)
; # (Db: siz (shl (i32 BLKSIZE) (Db: sh (i32 (val (+ BLK BLK 1) P))))...
  %162 = getelementptr i8, i8* %120, i32 12
  %163 = bitcast i8* %162 to i32*
  %164 = getelementptr i8, i8* %120, i32 8
  %165 = bitcast i8* %164 to i32*
  %166 = getelementptr i8, i8* %117, i32 12
  %167 = load i8, i8* %166
  %168 = zext i8 %167 to i32
  store i32 %168, i32* %165
  %169 = shl i32 64, %168
  store i32 %169, i32* %163
  br label %$22
$23:
  %170 = phi i64 [%148, %$21] ; # Dbs
  %171 = phi i64 [%149, %$21] ; # Siz
  %172 = phi i8* [%150, %$21] ; # Db
  %173 = phi i32 [%151, %$21] ; # Fnr
  %174 = phi i32 [%152, %$21] ; # Max
; # (and (== (gErrno) ENOENT) (ge0 (Db: fd (openRdWrExcl Buf))))
; # (gErrno)
  %175 = call i32 @gErrno()
; # (== (gErrno) ENOENT)
  %176 = icmp eq i32 %175, 1
  br i1 %176, label %$26, label %$25
$26:
  %177 = phi i64 [%170, %$23] ; # Dbs
  %178 = phi i64 [%171, %$23] ; # Siz
  %179 = phi i8* [%172, %$23] ; # Db
  %180 = phi i32 [%173, %$23] ; # Fnr
  %181 = phi i32 [%174, %$23] ; # Max
; # (Db: fd (openRdWrExcl Buf))
  %182 = bitcast i8* %120 to i32*
  %183 = call i32 @openRdWrExcl(i8* %91)
  store i32 %183, i32* %182
; # (ge0 (Db: fd (openRdWrExcl Buf)))
  %184 = icmp sge i32 %183, 0
  br label %$25
$25:
  %185 = phi i64 [%170, %$23], [%177, %$26] ; # Dbs
  %186 = phi i64 [%171, %$23], [%178, %$26] ; # Siz
  %187 = phi i8* [%172, %$23], [%179, %$26] ; # Db
  %188 = phi i32 [%173, %$23], [%180, %$26] ; # Fnr
  %189 = phi i32 [%174, %$23], [%181, %$26] ; # Max
  %190 = phi i1 [0, %$23], [%184, %$26] ; # ->
  br i1 %190, label %$28, label %$27
$28:
  %191 = phi i64 [%185, %$25] ; # Dbs
  %192 = phi i64 [%186, %$25] ; # Siz
  %193 = phi i8* [%187, %$25] ; # Db
  %194 = phi i32 [%188, %$25] ; # Fnr
  %195 = phi i32 [%189, %$25] ; # Max
; # (let (N (shl (i32 BLKSIZE) (Db: sh)) Stk (stack) Blk (b8 (Db: siz...
; # (i32 BLKSIZE)
; # (Db: sh)
  %196 = getelementptr i8, i8* %120, i32 8
  %197 = bitcast i8* %196 to i32*
  %198 = load i32, i32* %197
; # (shl (i32 BLKSIZE) (Db: sh))
  %199 = shl i32 64, %198
; # (stack)
  %200 = call i8* @llvm.stacksave()
; # (Db: siz N)
  %201 = getelementptr i8, i8* %120, i32 12
  %202 = bitcast i8* %201 to i32*
  store i32 %199, i32* %202
; # (b8 (Db: siz N))
  %203 = alloca i8, i32 %199
; # (i64 N)
  %204 = sext i32 %199 to i64
; # (memset Blk 0 (i64 N) T)
  call void @llvm.memset.p0i8.i64(i8* align 8 %203, i8 0, i64 %204, i1 0)
; # (if (== (Db:) (val $DbFiles)) (* 2 BLKSIZE) BLKSIZE)
; # (Db:)
; # (val $DbFiles)
  %205 = load i8*, i8** @$DbFiles
; # (== (Db:) (val $DbFiles))
  %206 = icmp eq i8* %120, %205
  br i1 %206, label %$29, label %$30
$29:
  %207 = phi i64 [%191, %$28] ; # Dbs
  %208 = phi i64 [%192, %$28] ; # Siz
  %209 = phi i8* [%193, %$28] ; # Db
  %210 = phi i32 [%194, %$28] ; # Fnr
  %211 = phi i32 [%195, %$28] ; # Max
; # (* 2 BLKSIZE)
  br label %$31
$30:
  %212 = phi i64 [%191, %$28] ; # Dbs
  %213 = phi i64 [%192, %$28] ; # Siz
  %214 = phi i8* [%193, %$28] ; # Db
  %215 = phi i32 [%194, %$28] ; # Fnr
  %216 = phi i32 [%195, %$28] ; # Max
  br label %$31
$31:
  %217 = phi i64 [%207, %$29], [%212, %$30] ; # Dbs
  %218 = phi i64 [%208, %$29], [%213, %$30] ; # Siz
  %219 = phi i8* [%209, %$29], [%214, %$30] ; # Db
  %220 = phi i32 [%210, %$29], [%215, %$30] ; # Fnr
  %221 = phi i32 [%211, %$29], [%216, %$30] ; # Max
  %222 = phi i64 [128, %$29], [64, %$30] ; # ->
; # (ofs Blk BLK)
  %223 = getelementptr i8, i8* %203, i32 6
; # (setAdr (if (== (Db:) (val $DbFiles)) (* 2 BLKSIZE) BLKSIZE) (ofs...
  call void @setAdr(i64 %222, i8* %223)
; # (set (inc (* 2 BLK)) Blk (i8 (Db: sh)))
; # (* 2 BLK)
; # (inc (* 2 BLK))
; # (Db: sh)
  %224 = getelementptr i8, i8* %120, i32 8
  %225 = bitcast i8* %224 to i32*
  %226 = load i32, i32* %225
; # (i8 (Db: sh))
  %227 = trunc i32 %226 to i8
  %228 = getelementptr i8, i8* %203, i32 12
  store i8 %227, i8* %228
; # (blkPoke 0 Blk N)
  call void @blkPoke(i64 0, i8* %203, i32 %199)
; # (when (== (Db:) (val $DbFiles)) (memset Blk 0 16 T) (setAdr 1 Blk...
; # (Db:)
; # (val $DbFiles)
  %229 = load i8*, i8** @$DbFiles
; # (== (Db:) (val $DbFiles))
  %230 = icmp eq i8* %120, %229
  br i1 %230, label %$32, label %$33
$32:
  %231 = phi i64 [%217, %$31] ; # Dbs
  %232 = phi i64 [%218, %$31] ; # Siz
  %233 = phi i8* [%219, %$31] ; # Db
  %234 = phi i32 [%220, %$31] ; # Fnr
  %235 = phi i32 [%221, %$31] ; # Max
; # (memset Blk 0 16 T)
  call void @llvm.memset.p0i8.i64(i8* align 8 %203, i8 0, i64 16, i1 0)
; # (setAdr 1 Blk)
  call void @setAdr(i64 1, i8* %203)
; # (Db: siz)
  %236 = getelementptr i8, i8* %120, i32 12
  %237 = bitcast i8* %236 to i32*
  %238 = load i32, i32* %237
; # (i64 (Db: siz))
  %239 = sext i32 %238 to i64
; # (blkPoke (i64 (Db: siz)) Blk N)
  call void @blkPoke(i64 %239, i8* %203, i32 %199)
  br label %$33
$33:
  %240 = phi i64 [%217, %$31], [%231, %$32] ; # Dbs
  %241 = phi i64 [%218, %$31], [%232, %$32] ; # Siz
  %242 = phi i8* [%219, %$31], [%233, %$32] ; # Db
  %243 = phi i32 [%220, %$31], [%234, %$32] ; # Fnr
  %244 = phi i32 [%221, %$31], [%235, %$32] ; # Max
; # (stack Stk)
  call void @llvm.stackrestore(i8* %200)
  br label %$22
$27:
  %245 = phi i64 [%185, %$25] ; # Dbs
  %246 = phi i64 [%186, %$25] ; # Siz
  %247 = phi i8* [%187, %$25] ; # Db
  %248 = phi i32 [%188, %$25] ; # Fnr
  %249 = phi i32 [%189, %$25] ; # Max
; # (openErr Exe Sym1)
  call void @openErr(i64 %0, i64 %4)
  unreachable
$22:
  %250 = phi i64 [%157, %$24], [%240, %$33] ; # Dbs
  %251 = phi i64 [%158, %$24], [%241, %$33] ; # Siz
  %252 = phi i8* [%159, %$24], [%242, %$33] ; # Db
  %253 = phi i32 [%160, %$24], [%243, %$33] ; # Fnr
  %254 = phi i32 [%161, %$24], [%244, %$33] ; # Max
; # (Db: fd)
  %255 = bitcast i8* %120 to i32*
  %256 = load i32, i32* %255
; # (closeOnExec Exe (Db: fd))
  call void @closeOnExec(i64 %0, i32 %256)
; # (when (> (Db: siz) Max) (setq Max @))
; # (Db: siz)
  %257 = getelementptr i8, i8* %120, i32 12
  %258 = bitcast i8* %257 to i32*
  %259 = load i32, i32* %258
; # (> (Db: siz) Max)
  %260 = icmp sgt i32 %259, %254
  br i1 %260, label %$34, label %$35
$34:
  %261 = phi i64 [%250, %$22] ; # Dbs
  %262 = phi i64 [%251, %$22] ; # Siz
  %263 = phi i8* [%252, %$22] ; # Db
  %264 = phi i32 [%253, %$22] ; # Fnr
  %265 = phi i32 [%254, %$22] ; # Max
  br label %$35
$35:
  %266 = phi i64 [%250, %$22], [%261, %$34] ; # Dbs
  %267 = phi i64 [%251, %$22], [%262, %$34] ; # Siz
  %268 = phi i8* [%252, %$22], [%263, %$34] ; # Db
  %269 = phi i32 [%253, %$22], [%264, %$34] ; # Fnr
  %270 = phi i32 [%254, %$22], [%259, %$34] ; # Max
; # (Db: mark null)
  %271 = getelementptr i8, i8* %120, i32 16
  %272 = bitcast i8* %271 to i8**
  store i8* null, i8** %272
; # (Db: mrks 0)
  %273 = getelementptr i8, i8* %120, i32 24
  %274 = bitcast i8* %273 to i64*
  store i64 0, i64* %274
; # (Db: flu -1)
  %275 = getelementptr i8, i8* %120, i32 32
  %276 = bitcast i8* %275 to i64*
  store i64 -1, i64* %276
; # (Db: lck (Db: drt NO))
  %277 = getelementptr i8, i8* %120, i32 40
  %278 = bitcast i8* %277 to i1*
  %279 = getelementptr i8, i8* %120, i32 41
  %280 = bitcast i8* %279 to i1*
  store i1 0, i1* %280
  store i1 0, i1* %278
; # (inc 'Fnr)
  %281 = add i32 %269, 1
; # (? (atom Dbs))
; # (atom Dbs)
  %282 = and i64 %266, 15
  %283 = icmp ne i64 %282, 0
  br i1 %283, label %$37, label %$36
$36:
  %284 = phi i64 [%266, %$35] ; # Dbs
  %285 = phi i64 [%267, %$35] ; # Siz
  %286 = phi i8* [%268, %$35] ; # Db
  %287 = phi i32 [%281, %$35] ; # Fnr
  %288 = phi i32 [%270, %$35] ; # Max
; # (ofs Db (dbFile T))
  %289 = getelementptr i8, i8* %286, i32 42
  br label %$18
$37:
  %290 = phi i64 [%266, %$35] ; # Dbs
  %291 = phi i64 [%267, %$35] ; # Siz
  %292 = phi i8* [%268, %$35] ; # Db
  %293 = phi i32 [%281, %$35] ; # Fnr
  %294 = phi i32 [%270, %$35] ; # Max
  %295 = phi i64 [0, %$35] ; # ->
; # (set $DBs Fnr $MaxBlkSize Max $DbBlock (alloc (val $DbBlock) (i64...
  store i32 %293, i32* @$DBs
  store i32 %294, i32* @$MaxBlkSize
; # (val $DbBlock)
  %296 = load i8*, i8** @$DbBlock
; # (i64 Max)
  %297 = sext i32 %294 to i64
; # (alloc (val $DbBlock) (i64 Max))
  %298 = call i8* @alloc(i8* %296, i64 %297)
  store i8* %298, i8** @$DbBlock
; # (unless (nil? Sym2) (let Nm (xName Exe Sym2) (unless (fopen (path...
; # (nil? Sym2)
  %299 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %299, label %$39, label %$38
$38:
  %300 = phi i64 [%290, %$37] ; # Dbs
; # (let Nm (xName Exe Sym2) (unless (fopen (pathString Nm (b8 (pathS...
; # (xName Exe Sym2)
  %301 = call i64 @xName(i64 %0, i64 %28)
; # (unless (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a")) (openE...
; # (pathSize Nm)
  %302 = call i64 @pathSize(i64 %301)
; # (b8 (pathSize Nm))
  %303 = alloca i8, i64 %302
; # (pathString Nm (b8 (pathSize Nm)))
  %304 = call i8* @pathString(i64 %301, i8* %303)
; # (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a"))
  %305 = call i8* @fopen(i8* %304, i8* bitcast ([2 x i8]* @$60 to i8*))
  %306 = icmp ne i8* %305, null
  br i1 %306, label %$41, label %$40
$40:
  %307 = phi i64 [%300, %$38] ; # Dbs
; # (openErr Exe Sym2)
  call void @openErr(i64 %0, i64 %28)
  unreachable
$41:
  %308 = phi i64 [%300, %$38] ; # Dbs
; # (set $DbJnl @)
  store i8* %305, i8** @$DbJnl
; # (fileno @)
  %309 = call i32 @fileno(i8* %305)
; # (closeOnExec Exe (fileno @))
  call void @closeOnExec(i64 %0, i32 %309)
  br label %$39
$39:
  %310 = phi i64 [%290, %$37], [%308, %$41] ; # Dbs
; # (unless (nil? Sym3) (let Nm (xName Exe Sym3) (unless (fopen (path...
; # (nil? Sym3)
  %311 = icmp eq i64 %40, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %311, label %$43, label %$42
$42:
  %312 = phi i64 [%310, %$39] ; # Dbs
; # (let Nm (xName Exe Sym3) (unless (fopen (pathString Nm (b8 (pathS...
; # (xName Exe Sym3)
  %313 = call i64 @xName(i64 %0, i64 %40)
; # (unless (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a+")) (open...
; # (pathSize Nm)
  %314 = call i64 @pathSize(i64 %313)
; # (b8 (pathSize Nm))
  %315 = alloca i8, i64 %314
; # (pathString Nm (b8 (pathSize Nm)))
  %316 = call i8* @pathString(i64 %313, i8* %315)
; # (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a+"))
  %317 = call i8* @fopen(i8* %316, i8* bitcast ([3 x i8]* @$61 to i8*))
  %318 = icmp ne i8* %317, null
  br i1 %318, label %$45, label %$44
$44:
  %319 = phi i64 [%312, %$42] ; # Dbs
; # (openErr Exe Sym3)
  call void @openErr(i64 %0, i64 %40)
  unreachable
$45:
  %320 = phi i64 [%312, %$42] ; # Dbs
; # (set $DbLog @)
  store i8* %317, i8** @$DbLog
; # (fileno @)
  %321 = call i32 @fileno(i8* %317)
; # (closeOnExec Exe (fileno @))
  call void @closeOnExec(i64 %0, i32 %321)
; # (when (transaction) (restore Exe))
; # (transaction)
  %322 = call i1 @transaction()
  br i1 %322, label %$46, label %$47
$46:
  %323 = phi i64 [%320, %$45] ; # Dbs
; # (restore Exe)
  call void @restore(i64 %0)
  br label %$47
$47:
  %324 = phi i64 [%320, %$45], [%323, %$46] ; # Dbs
; # (truncLog Exe)
  call void @truncLog(i64 %0)
  br label %$43
$43:
  %325 = phi i64 [%310, %$39], [%324, %$47] ; # Dbs
  br label %$12
$12:
  %326 = phi i64 [%84, %$3], [%325, %$43] ; # Dbs
; # (drop *Safe)
  %327 = inttoptr i64 %8 to i64*
  %328 = getelementptr i64, i64* %327, i32 1
  %329 = load i64, i64* %328
  %330 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %329, i64* %330
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
}

define i64 @_pool2(i64) align 8 {
$1:
; # (let (X (cdr Exe) Sym (evSym X) Nm (xName Exe Sym) Jnl (val $DbJn...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe Sym)
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (val $DbJnl)
  %6 = load i8*, i8** @$DbJnl
; # (val $DbLog)
  %7 = load i8*, i8** @$DbLog
; # (val $DBs)
  %8 = load i32, i32* @$DBs
; # (b32 C)
  %9 = alloca i32, i32 %8
; # (set $DbJnl null $DbLog null)
  store i8* null, i8** @$DbJnl
  store i8* null, i8** @$DbLog
; # (let (Db (val $DbFiles) I (i32 0)) (loop (let Db: (dbFile Db) (se...
; # (val $DbFiles)
  %10 = load i8*, i8** @$DbFiles
; # (i32 0)
; # (loop (let Db: (dbFile Db) (set (ofs FDs I) (Db: fd))) (? (== C (...
  br label %$2
$2:
  %11 = phi i8* [%10, %$1], [%20, %$3] ; # Db
  %12 = phi i32 [0, %$1], [%19, %$3] ; # I
; # (let Db: (dbFile Db) (set (ofs FDs I) (Db: fd)))
; # (set (ofs FDs I) (Db: fd))
; # (ofs FDs I)
  %13 = getelementptr i32, i32* %9, i32 %12
; # (Db: fd)
  %14 = bitcast i8* %11 to i32*
  %15 = load i32, i32* %14
  store i32 %15, i32* %13
; # (? (== C (inc 'I)))
; # (inc 'I)
  %16 = add i32 %12, 1
; # (== C (inc 'I))
  %17 = icmp eq i32 %8, %16
  br i1 %17, label %$4, label %$3
$3:
  %18 = phi i8* [%11, %$2] ; # Db
  %19 = phi i32 [%16, %$2] ; # I
; # (ofs Db (dbFile T))
  %20 = getelementptr i8, i8* %18, i32 42
  br label %$2
$4:
  %21 = phi i8* [%11, %$2] ; # Db
  %22 = phi i32 [%16, %$2] ; # I
  %23 = phi i64 [0, %$2] ; # ->
; # (let (Len (pathSize Nm) Buf (pathString Nm (b8 (+ Len 4))) End (o...
; # (pathSize Nm)
  %24 = call i64 @pathSize(i64 %5)
; # (+ Len 4)
  %25 = add i64 %24, 4
; # (b8 (+ Len 4))
  %26 = alloca i8, i64 %25
; # (pathString Nm (b8 (+ Len 4)))
  %27 = call i8* @pathString(i64 %5, i8* %26)
; # (dec Len)
  %28 = sub i64 %24, 1
; # (ofs Buf (dec Len))
  %29 = getelementptr i8, i8* %27, i64 %28
; # (let (Db (val $DbFiles) I (i32 0)) (loop (let Db: (dbFile Db) (se...
; # (val $DbFiles)
  %30 = load i8*, i8** @$DbFiles
; # (i32 0)
; # (loop (let Db: (dbFile Db) (set (bufAo End (Db: db)) 0) (when (lt...
  br label %$5
$5:
  %31 = phi i8* [%30, %$4], [%48, %$8] ; # Db
  %32 = phi i32 [0, %$4], [%47, %$8] ; # I
; # (let Db: (dbFile Db) (set (bufAo End (Db: db)) 0) (when (lt0 (Db:...
; # (set (bufAo End (Db: db)) 0)
; # (Db: db)
  %33 = getelementptr i8, i8* %31, i32 4
  %34 = bitcast i8* %33 to i32*
  %35 = load i32, i32* %34
; # (bufAo End (Db: db))
  %36 = call i8* @bufAo(i8* %29, i32 %35)
  store i8 0, i8* %36
; # (when (lt0 (Db: fd (openRdWr Buf))) (openErr Exe Sym))
; # (Db: fd (openRdWr Buf))
  %37 = bitcast i8* %31 to i32*
  %38 = call i32 @openRdWr(i8* %27)
  store i32 %38, i32* %37
; # (lt0 (Db: fd (openRdWr Buf)))
  %39 = icmp slt i32 %38, 0
  br i1 %39, label %$6, label %$7
$6:
  %40 = phi i8* [%31, %$5] ; # Db
  %41 = phi i32 [%32, %$5] ; # I
; # (openErr Exe Sym)
  call void @openErr(i64 %0, i64 %4)
  unreachable
$7:
  %42 = phi i8* [%31, %$5] ; # Db
  %43 = phi i32 [%32, %$5] ; # I
; # (closeOnExec Exe @)
  call void @closeOnExec(i64 %0, i32 %38)
; # (? (== C (inc 'I)))
; # (inc 'I)
  %44 = add i32 %43, 1
; # (== C (inc 'I))
  %45 = icmp eq i32 %8, %44
  br i1 %45, label %$9, label %$8
$8:
  %46 = phi i8* [%42, %$7] ; # Db
  %47 = phi i32 [%44, %$7] ; # I
; # (ofs Db (dbFile T))
  %48 = getelementptr i8, i8* %46, i32 42
  br label %$5
$9:
  %49 = phi i8* [%42, %$7] ; # Db
  %50 = phi i32 [%44, %$7] ; # I
  %51 = phi i64 [0, %$7] ; # ->
; # (prog1 (run (cdr X) (let (Db (val $DbFiles) I (i32 0)) (loop (let...
; # (cdr X)
  %52 = inttoptr i64 %3 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (run (cdr X) (let (Db (val $DbFiles) I (i32 0)) (loop (let Db: (d...
  br label %$10
$10:
  %55 = phi i64 [%54, %$9], [%77, %$19] ; # Prg
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
  %58 = getelementptr i64, i64* %56, i32 1
  %59 = load i64, i64* %58
  %60 = and i64 %59, 15
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$13, label %$11
$13:
  %62 = phi i64 [%59, %$10] ; # Prg
  %63 = and i64 %57, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$16, label %$15
$16:
  br label %$14
$15:
  %65 = and i64 %57, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$18, label %$17
$18:
  %67 = inttoptr i64 %57 to i64*
  %68 = load i64, i64* %67
  br label %$14
$17:
  %69 = call i64 @evList(i64 %57)
  br label %$14
$14:
  %70 = phi i64 [%57, %$16], [%68, %$18], [%69, %$17] ; # ->
  br label %$12
$11:
  %71 = phi i64 [%59, %$10] ; # Prg
  %72 = and i64 %57, 15
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %$20, label %$19
$20:
  %74 = phi i64 [%71, %$11] ; # Prg
  %75 = call i64 @evList(i64 %57)
  %76 = icmp ne i64 %75, 0
  br label %$19
$19:
  %77 = phi i64 [%71, %$11], [%74, %$20] ; # Prg
  %78 = phi i1 [0, %$11], [%76, %$20] ; # ->
  br label %$10
$12:
  %79 = phi i64 [%62, %$14] ; # Prg
  %80 = phi i64 [%70, %$14] ; # ->
  ret i64 %80
}

define i64 @_journal(i64) align 8 {
$1:
; # (let (X (cdr Exe) Sym (evSym X) Jnl (val $DbJnl) Log (val $DbLog)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (val $DbJnl)
  %5 = load i8*, i8** @$DbJnl
; # (val $DbLog)
  %6 = load i8*, i8** @$DbLog
; # (val $MaxBlkSize)
  %7 = load i32, i32* @$MaxBlkSize
; # (b8 (val $MaxBlkSize))
  %8 = alloca i8, i32 %7
; # (b8 BLK)
  %9 = alloca i8, i64 6
; # (stkChk Exe)
  %10 = load i8*, i8** @$StkLimit
  %11 = call i8* @llvm.stacksave()
  %12 = icmp ugt i8* %10, %11
  br i1 %12, label %$2, label %$3
$2:
  call void @stkErr(i64 %0)
  unreachable
$3:
; # (when (t? Sym) (set $DbJnl null $DbLog null) (setq Sym (evSym (sh...
; # (t? Sym)
  %13 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %13, label %$4, label %$5
$4:
  %14 = phi i64 [%3, %$3] ; # X
  %15 = phi i64 [%4, %$3] ; # Sym
; # (set $DbJnl null $DbLog null)
  store i8* null, i8** @$DbJnl
  store i8* null, i8** @$DbLog
; # (shift X)
  %16 = inttoptr i64 %14 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (evSym (shift X))
  %19 = call i64 @evSym(i64 %18)
  br label %$5
$5:
  %20 = phi i64 [%3, %$3], [%18, %$4] ; # X
  %21 = phi i64 [%4, %$3], [%19, %$4] ; # Sym
; # (loop (let (Nm (xName Exe Sym) Fp (fopen (pathString Nm (b8 (path...
  br label %$6
$6:
  %22 = phi i64 [%20, %$5], [%111, %$25] ; # X
  %23 = phi i64 [%21, %$5], [%113, %$25] ; # Sym
; # (let (Nm (xName Exe Sym) Fp (fopen (pathString Nm (b8 (pathSize N...
; # (xName Exe Sym)
  %24 = call i64 @xName(i64 %0, i64 %23)
; # (pathSize Nm)
  %25 = call i64 @pathSize(i64 %24)
; # (b8 (pathSize Nm))
  %26 = alloca i8, i64 %25
; # (pathString Nm (b8 (pathSize Nm)))
  %27 = call i8* @pathString(i64 %24, i8* %26)
; # (fopen (pathString Nm (b8 (pathSize Nm))) ($ "r"))
  %28 = call i8* @fopen(i8* %27, i8* bitcast ([2 x i8]* @$62 to i8*))
; # (unless Fp (openErr Exe Sym))
  %29 = icmp ne i8* %28, null
  br i1 %29, label %$8, label %$7
$7:
  %30 = phi i64 [%22, %$6] ; # X
  %31 = phi i64 [%23, %$6] ; # Sym
; # (openErr Exe Sym)
  call void @openErr(i64 %0, i64 %31)
  unreachable
$8:
  %32 = phi i64 [%22, %$6] ; # X
  %33 = phi i64 [%23, %$6] ; # Sym
; # (while (ge0 (getc_unlocked Fp)) (let Siz @ (unless (== (fread Blk...
  br label %$9
$9:
  %34 = phi i64 [%32, %$8], [%100, %$16] ; # X
  %35 = phi i64 [%33, %$8], [%101, %$16] ; # Sym
; # (getc_unlocked Fp)
  %36 = call i32 @getc_unlocked(i8* %28)
; # (ge0 (getc_unlocked Fp))
  %37 = icmp sge i32 %36, 0
  br i1 %37, label %$10, label %$11
$10:
  %38 = phi i64 [%34, %$9] ; # X
  %39 = phi i64 [%35, %$9] ; # Sym
; # (let Siz @ (unless (== (fread Blk 2 1 Fp) 1) (jnlErr Exe)) (if (d...
; # (unless (== (fread Blk 2 1 Fp) 1) (jnlErr Exe))
; # (fread Blk 2 1 Fp)
  %40 = call i32 @fread(i8* %9, i64 2, i64 1, i8* %28)
; # (== (fread Blk 2 1 Fp) 1)
  %41 = icmp eq i32 %40, 1
  br i1 %41, label %$13, label %$12
$12:
  %42 = phi i64 [%38, %$10] ; # X
  %43 = phi i64 [%39, %$10] ; # Sym
  %44 = phi i32 [%36, %$10] ; # Siz
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$13:
  %45 = phi i64 [%38, %$10] ; # X
  %46 = phi i64 [%39, %$10] ; # Sym
  %47 = phi i32 [%36, %$10] ; # Siz
; # (if (dbfBuf Blk) (let Db: (dbFile @) (when (== Siz BLKSIZE) (setq...
; # (dbfBuf Blk)
  %48 = call i8* @dbfBuf(i8* %9)
  %49 = icmp ne i8* %48, null
  br i1 %49, label %$14, label %$15
$14:
  %50 = phi i64 [%45, %$13] ; # X
  %51 = phi i64 [%46, %$13] ; # Sym
  %52 = phi i32 [%47, %$13] ; # Siz
; # (let Db: (dbFile @) (when (== Siz BLKSIZE) (setq Siz (Db: siz))) ...
; # (when (== Siz BLKSIZE) (setq Siz (Db: siz)))
; # (== Siz BLKSIZE)
  %53 = icmp eq i32 %52, 64
  br i1 %53, label %$17, label %$18
$17:
  %54 = phi i64 [%50, %$14] ; # X
  %55 = phi i64 [%51, %$14] ; # Sym
  %56 = phi i32 [%52, %$14] ; # Siz
; # (Db: siz)
  %57 = getelementptr i8, i8* %48, i32 12
  %58 = bitcast i8* %57 to i32*
  %59 = load i32, i32* %58
  br label %$18
$18:
  %60 = phi i64 [%50, %$14], [%54, %$17] ; # X
  %61 = phi i64 [%51, %$14], [%55, %$17] ; # Sym
  %62 = phi i32 [%52, %$14], [%59, %$17] ; # Siz
; # (unless Siz (setq Siz (Db: siz)))
  %63 = icmp ne i32 %62, 0
  br i1 %63, label %$20, label %$19
$19:
  %64 = phi i64 [%60, %$18] ; # X
  %65 = phi i64 [%61, %$18] ; # Sym
  %66 = phi i32 [%62, %$18] ; # Siz
; # (Db: siz)
  %67 = getelementptr i8, i8* %48, i32 12
  %68 = bitcast i8* %67 to i32*
  %69 = load i32, i32* %68
  br label %$20
$20:
  %70 = phi i64 [%60, %$18], [%64, %$19] ; # X
  %71 = phi i64 [%61, %$18], [%65, %$19] ; # Sym
  %72 = phi i32 [%62, %$18], [%69, %$19] ; # Siz
; # (unless (and (== (fread Blk BLK 1 Fp) 1) (== (fread Buf (i64 Siz)...
; # (and (== (fread Blk BLK 1 Fp) 1) (== (fread Buf (i64 Siz) 1 Fp) 1...
; # (fread Blk BLK 1 Fp)
  %73 = call i32 @fread(i8* %9, i64 6, i64 1, i8* %28)
; # (== (fread Blk BLK 1 Fp) 1)
  %74 = icmp eq i32 %73, 1
  br i1 %74, label %$22, label %$21
$22:
  %75 = phi i64 [%70, %$20] ; # X
  %76 = phi i64 [%71, %$20] ; # Sym
  %77 = phi i32 [%72, %$20] ; # Siz
; # (i64 Siz)
  %78 = sext i32 %77 to i64
; # (fread Buf (i64 Siz) 1 Fp)
  %79 = call i32 @fread(i8* %8, i64 %78, i64 1, i8* %28)
; # (== (fread Buf (i64 Siz) 1 Fp) 1)
  %80 = icmp eq i32 %79, 1
  br label %$21
$21:
  %81 = phi i64 [%70, %$20], [%75, %$22] ; # X
  %82 = phi i64 [%71, %$20], [%76, %$22] ; # Sym
  %83 = phi i32 [%72, %$20], [%77, %$22] ; # Siz
  %84 = phi i1 [0, %$20], [%80, %$22] ; # ->
  br i1 %84, label %$24, label %$23
$23:
  %85 = phi i64 [%81, %$21] ; # X
  %86 = phi i64 [%82, %$21] ; # Sym
  %87 = phi i32 [%83, %$21] ; # Siz
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$24:
  %88 = phi i64 [%81, %$21] ; # X
  %89 = phi i64 [%82, %$21] ; # Sym
  %90 = phi i32 [%83, %$21] ; # Siz
; # (getAdr Blk)
  %91 = call i64 @getAdr(i8* %9)
; # (Db: sh)
  %92 = getelementptr i8, i8* %48, i32 8
  %93 = bitcast i8* %92 to i32*
  %94 = load i32, i32* %93
; # (i64 (Db: sh))
  %95 = sext i32 %94 to i64
; # (shl (getAdr Blk) (i64 (Db: sh)))
  %96 = shl i64 %91, %95
; # (blkPoke (shl (getAdr Blk) (i64 (Db: sh))) Buf Siz)
  call void @blkPoke(i64 %96, i8* %8, i32 %90)
  br label %$16
$15:
  %97 = phi i64 [%45, %$13] ; # X
  %98 = phi i64 [%46, %$13] ; # Sym
  %99 = phi i32 [%47, %$13] ; # Siz
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$16:
  %100 = phi i64 [%88, %$24] ; # X
  %101 = phi i64 [%89, %$24] ; # Sym
  %102 = phi i32 [%90, %$24] ; # Siz
  br label %$9
$11:
  %103 = phi i64 [%34, %$9] ; # X
  %104 = phi i64 [%35, %$9] ; # Sym
; # (fclose Fp)
  %105 = call i32 @fclose(i8* %28)
; # (? (atom (shift X)))
; # (shift X)
  %106 = inttoptr i64 %103 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
; # (atom (shift X))
  %109 = and i64 %108, 15
  %110 = icmp ne i64 %109, 0
  br i1 %110, label %$26, label %$25
$25:
  %111 = phi i64 [%108, %$11] ; # X
  %112 = phi i64 [%104, %$11] ; # Sym
; # (evSym X)
  %113 = call i64 @evSym(i64 %111)
  br label %$6
$26:
  %114 = phi i64 [%108, %$11] ; # X
  %115 = phi i64 [%104, %$11] ; # Sym
  %116 = phi i64 [0, %$11] ; # ->
; # (set $DbLog Log $DbJnl Jnl)
  store i8* %6, i8** @$DbLog
  store i8* %5, i8** @$DbJnl
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
}

define i64 @_id(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (if (cnt? Y) (extern (if (nil?...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (if (cnt? Y) (extern (if (nil? (eval (car X))) (extNm 0 (int Y)) ...
; # (cnt? Y)
  %16 = and i64 %15, 2
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
; # (if (nil? (eval (car X))) (extNm 0 (int Y)) (extNm (dec (i32 (int...
; # (car X)
  %18 = inttoptr i64 %7 to i64*
  %19 = load i64, i64* %18
; # (eval (car X))
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$12, label %$11
$12:
  br label %$10
$11:
  %22 = and i64 %19, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = inttoptr i64 %19 to i64*
  %25 = load i64, i64* %24
  br label %$10
$13:
  %26 = call i64 @evList(i64 %19)
  br label %$10
$10:
  %27 = phi i64 [%19, %$12], [%25, %$14], [%26, %$13] ; # ->
; # (nil? (eval (car X)))
  %28 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %28, label %$15, label %$16
$15:
; # (int Y)
  %29 = lshr i64 %15, 4
; # (extNm 0 (int Y))
  %30 = call i64 @extNm(i32 0, i64 %29)
  br label %$17
$16:
; # (int Y)
  %31 = lshr i64 %15, 4
; # (i32 (int Y))
  %32 = trunc i64 %31 to i32
; # (dec (i32 (int Y)))
  %33 = sub i32 %32, 1
; # (xCnt Exe @)
  %34 = call i64 @xCnt(i64 %0, i64 %27)
; # (extNm (dec (i32 (int Y))) (xCnt Exe @))
  %35 = call i64 @extNm(i32 %33, i64 %34)
  br label %$17
$17:
  %36 = phi i64 [%30, %$15], [%35, %$16] ; # ->
; # (extern (if (nil? (eval (car X))) (extNm 0 (int Y)) (extNm (dec (...
  %37 = call i64 @extern(i64 %36)
  br label %$9
$8:
; # (needSymb Exe Y)
  %38 = xor i64 %15, 8
  %39 = and i64 %38, 14
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %$19, label %$18
$18:
  call void @symErr(i64 %0, i64 %15)
  unreachable
$19:
; # (unless (sym? (val (tail (needSymb Exe Y)))) (extErr Exe Y))
; # (needSymb Exe Y)
  %41 = xor i64 %15, 8
  %42 = and i64 %41, 14
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %$21, label %$20
$20:
  call void @symErr(i64 %0, i64 %15)
  unreachable
$21:
; # (tail (needSymb Exe Y))
  %44 = add i64 %15, -8
; # (val (tail (needSymb Exe Y)))
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (sym? (val (tail (needSymb Exe Y))))
  %47 = and i64 %46, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$23, label %$22
$22:
; # (extErr Exe Y)
  call void @extErr(i64 %0, i64 %15)
  unreachable
$23:
; # (let (Nm (name (& (val (tail Y)) -9)) Z (cnt (objId Nm))) (if (ni...
; # (tail Y)
  %49 = add i64 %15, -8
; # (val (tail Y))
  %50 = inttoptr i64 %49 to i64*
  %51 = load i64, i64* %50
; # (& (val (tail Y)) -9)
  %52 = and i64 %51, -9
; # (name (& (val (tail Y)) -9))
  br label %$24
$24:
  %53 = phi i64 [%52, %$23], [%59, %$25] ; # Tail
  %54 = and i64 %53, 6
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$26, label %$25
$25:
  %56 = phi i64 [%53, %$24] ; # Tail
  %57 = inttoptr i64 %56 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  br label %$24
$26:
  %60 = phi i64 [%53, %$24] ; # Tail
; # (objId Nm)
  %61 = call i64 @objId(i64 %60)
; # (cnt (objId Nm))
  %62 = shl i64 %61, 4
  %63 = or i64 %62, 2
; # (if (nil? (eval (car X))) Z (cons (cnt (i64 (inc (objFile Nm)))) ...
; # (car X)
  %64 = inttoptr i64 %7 to i64*
  %65 = load i64, i64* %64
; # (eval (car X))
  %66 = and i64 %65, 6
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$29, label %$28
$29:
  br label %$27
$28:
  %68 = and i64 %65, 8
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$31, label %$30
$31:
  %70 = inttoptr i64 %65 to i64*
  %71 = load i64, i64* %70
  br label %$27
$30:
  %72 = call i64 @evList(i64 %65)
  br label %$27
$27:
  %73 = phi i64 [%65, %$29], [%71, %$31], [%72, %$30] ; # ->
; # (nil? (eval (car X)))
  %74 = icmp eq i64 %73, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %74, label %$32, label %$33
$32:
  br label %$34
$33:
; # (objFile Nm)
  %75 = call i32 @objFile(i64 %60)
; # (inc (objFile Nm))
  %76 = add i32 %75, 1
; # (i64 (inc (objFile Nm)))
  %77 = sext i32 %76 to i64
; # (cnt (i64 (inc (objFile Nm))))
  %78 = shl i64 %77, 4
  %79 = or i64 %78, 2
; # (cons (cnt (i64 (inc (objFile Nm)))) Z)
  %80 = call i64 @cons(i64 %79, i64 %63)
  br label %$34
$34:
  %81 = phi i64 [%63, %$32], [%80, %$33] ; # ->
  br label %$9
$9:
  %82 = phi i64 [%37, %$17], [%81, %$34] ; # ->
  ret i64 %82
}

define i64 @_blk(i64) align 8 {
$1:
; # (let (X (cdr Exe) Db: (dbFile (b8 (dbFile T)))) (Db: fd (i32 (evC...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (b8 (dbFile T))
  %4 = alloca i8, i64 42
; # (Db: fd (i32 (evCnt Exe X)))
  %5 = bitcast i8* %4 to i32*
  %6 = call i64 @evCnt(i64 %0, i64 %3)
  %7 = trunc i64 %6 to i32
  store i32 %7, i32* %5
; # (if (=0 (evCnt Exe (shift X))) (let Buf (b8 BLK) (unless (== (+ B...
; # (shift X)
  %8 = inttoptr i64 %3 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
; # (evCnt Exe (shift X))
  %11 = call i64 @evCnt(i64 %0, i64 %10)
; # (=0 (evCnt Exe (shift X)))
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %$2, label %$3
$2:
  %13 = phi i64 [%10, %$1] ; # X
; # (let Buf (b8 BLK) (unless (== (+ BLK 1) (pread (Db: fd) Buf (+ BL...
; # (b8 BLK)
  %14 = alloca i8, i64 6
; # (unless (== (+ BLK 1) (pread (Db: fd) Buf (+ BLK 1) BLK)) (dbRdEr...
; # (+ BLK 1)
; # (Db: fd)
  %15 = bitcast i8* %4 to i32*
  %16 = load i32, i32* %15
; # (+ BLK 1)
; # (pread (Db: fd) Buf (+ BLK 1) BLK)
  %17 = call i64 @pread(i32 %16, i8* %14, i64 7, i64 6)
; # (== (+ BLK 1) (pread (Db: fd) Buf (+ BLK 1) BLK))
  %18 = icmp eq i64 7, %17
  br i1 %18, label %$6, label %$5
$5:
  %19 = phi i64 [%13, %$2] ; # X
; # (dbRdErr)
  call void @dbRdErr()
  unreachable
$6:
  %20 = phi i64 [%13, %$2] ; # X
; # (getAdr Buf)
  %21 = call i64 @getAdr(i8* %14)
; # (shr (getAdr Buf) 6)
  %22 = lshr i64 %21, 6
; # (cnt (shr (getAdr Buf) 6))
  %23 = shl i64 %22, 4
  %24 = or i64 %23, 2
; # (ofs Buf BLK)
  %25 = getelementptr i8, i8* %14, i32 6
; # (val (ofs Buf BLK))
  %26 = load i8, i8* %25
; # (i64 (val (ofs Buf BLK)))
  %27 = zext i8 %26 to i64
; # (cnt (i64 (val (ofs Buf BLK))))
  %28 = shl i64 %27, 4
  %29 = or i64 %28, 2
; # (cons (cnt (shr (getAdr Buf) 6)) (cnt (i64 (val (ofs Buf BLK)))))...
  %30 = call i64 @cons(i64 %24, i64 %29)
  br label %$4
$3:
  %31 = phi i64 [%10, %$1] ; # X
; # (let (N (shl @ 6) P (val $DbBlock) Siz (shl (i32 BLKSIZE) (Db: sh...
; # (shl @ 6)
  %32 = shl i64 %11, 6
; # (val $DbBlock)
  %33 = load i8*, i8** @$DbBlock
; # (i32 BLKSIZE)
; # (Db: sh (i32 (evCnt Exe (shift X))))
  %34 = getelementptr i8, i8* %4, i32 8
  %35 = bitcast i8* %34 to i32*
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  %39 = call i64 @evCnt(i64 %0, i64 %38)
  %40 = trunc i64 %39 to i32
  store i32 %40, i32* %35
; # (shl (i32 BLKSIZE) (Db: sh (i32 (evCnt Exe (shift X)))))
  %41 = shl i32 64, %40
; # (if (atom (shift X)) -1 (evCnt Exe @))
; # (shift X)
  %42 = inttoptr i64 %38 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
; # (atom (shift X))
  %45 = and i64 %44, 15
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$7, label %$8
$7:
  %47 = phi i64 [%44, %$3] ; # X
  br label %$9
$8:
  %48 = phi i64 [%44, %$3] ; # X
; # (evCnt Exe @)
  %49 = call i64 @evCnt(i64 %0, i64 %44)
  br label %$9
$9:
  %50 = phi i64 [%47, %$7], [%48, %$8] ; # X
  %51 = phi i64 [-1, %$7], [%49, %$8] ; # ->
; # (i32 (if (atom (shift X)) -1 (evCnt Exe @)))
  %52 = trunc i64 %51 to i32
; # (when (> (Db: siz Siz) (val $MaxBlkSize)) (set $MaxBlkSize Siz $D...
; # (Db: siz Siz)
  %53 = getelementptr i8, i8* %4, i32 12
  %54 = bitcast i8* %53 to i32*
  store i32 %41, i32* %54
; # (val $MaxBlkSize)
  %55 = load i32, i32* @$MaxBlkSize
; # (> (Db: siz Siz) (val $MaxBlkSize))
  %56 = icmp sgt i32 %41, %55
  br i1 %56, label %$10, label %$11
$10:
  %57 = phi i64 [%50, %$9] ; # X
; # (set $MaxBlkSize Siz $DbBlock (alloc P (i64 Siz)))
  store i32 %41, i32* @$MaxBlkSize
; # (i64 Siz)
  %58 = sext i32 %41 to i64
; # (alloc P (i64 Siz))
  %59 = call i8* @alloc(i8* %33, i64 %58)
  store i8* %59, i8** @$DbBlock
  br label %$11
$11:
  %60 = phi i64 [%50, %$9], [%57, %$10] ; # X
; # (set $DbFile (Db:))
; # (Db:)
  store i8* %4, i8** @$DbFile
; # (when (ge0 Fd) (rdLockWait Fd 1))
; # (ge0 Fd)
  %61 = icmp sge i32 %52, 0
  br i1 %61, label %$12, label %$13
$12:
  %62 = phi i64 [%60, %$11] ; # X
; # (rdLockWait Fd 1)
  call void @rdLockWait(i32 %52, i64 1)
  br label %$13
$13:
  %63 = phi i64 [%60, %$11], [%62, %$12] ; # X
; # (prog1 (let Blk (rdBlock N) (if (<> 1 (& (val Blk) BLKTAG)) $Nil ...
; # (let Blk (rdBlock N) (if (<> 1 (& (val Blk) BLKTAG)) $Nil (set $G...
; # (rdBlock N)
  %64 = call i8* @rdBlock(i64 %32)
; # (if (<> 1 (& (val Blk) BLKTAG)) $Nil (set $GetBin (fun (i32) getB...
; # (val Blk)
  %65 = load i8, i8* %64
; # (& (val Blk) BLKTAG)
  %66 = and i8 %65, 63
; # (<> 1 (& (val Blk) BLKTAG))
  %67 = icmp ne i8 1, %66
  br i1 %67, label %$14, label %$15
$14:
  %68 = phi i64 [%63, %$13] ; # X
  br label %$16
$15:
  %69 = phi i64 [%63, %$13] ; # X
; # (set $GetBin (fun (i32) getBlock) $Extn (val $ExtN))
; # (fun (i32) getBlock)
  store i32()* @getBlock, i32()** @$GetBin
; # (val $ExtN)
  %70 = load i32, i32* @$ExtN
  store i32 %70, i32* @$Extn
; # (let (L (cons (binRead) $Nil) R (save L)) (until (nil? (binRead))...
; # (binRead)
  %71 = call i64 @binRead()
; # (cons (binRead) $Nil)
  %72 = call i64 @cons(i64 %71, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save L)
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %74 = load i64, i64* %73
  %75 = alloca i64, i64 2, align 16
  %76 = ptrtoint i64* %75 to i64
  %77 = inttoptr i64 %76 to i64*
  store i64 %72, i64* %77
  %78 = add i64 %76, 8
  %79 = inttoptr i64 %78 to i64*
  store i64 %74, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %76, i64* %80
; # (until (nil? (binRead)) (setq L (set 2 L (cons @ $Nil))) (unless ...
  br label %$17
$17:
  %81 = phi i64 [%69, %$15], [%98, %$21] ; # X
  %82 = phi i64 [%72, %$15], [%99, %$21] ; # L
; # (binRead)
  %83 = call i64 @binRead()
; # (nil? (binRead))
  %84 = icmp eq i64 %83, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %84, label %$19, label %$18
$18:
  %85 = phi i64 [%81, %$17] ; # X
  %86 = phi i64 [%82, %$17] ; # L
; # (set 2 L (cons @ $Nil))
; # (cons @ $Nil)
  %87 = call i64 @cons(i64 %83, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %88 = inttoptr i64 %86 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  store i64 %87, i64* %89
; # (unless (t? (binRead)) (set L (cons @ (car L))))
; # (binRead)
  %90 = call i64 @binRead()
; # (t? (binRead))
  %91 = icmp eq i64 %90, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %91, label %$21, label %$20
$20:
  %92 = phi i64 [%85, %$18] ; # X
  %93 = phi i64 [%87, %$18] ; # L
; # (set L (cons @ (car L)))
; # (car L)
  %94 = inttoptr i64 %93 to i64*
  %95 = load i64, i64* %94
; # (cons @ (car L))
  %96 = call i64 @cons(i64 %90, i64 %95)
  %97 = inttoptr i64 %93 to i64*
  store i64 %96, i64* %97
  br label %$21
$21:
  %98 = phi i64 [%85, %$18], [%92, %$20] ; # X
  %99 = phi i64 [%87, %$18], [%93, %$20] ; # L
  br label %$17
$19:
  %100 = phi i64 [%81, %$17] ; # X
  %101 = phi i64 [%82, %$17] ; # L
; # (drop *Safe)
  %102 = inttoptr i64 %76 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %104, i64* %105
  br label %$16
$16:
  %106 = phi i64 [%68, %$14], [%100, %$19] ; # X
  %107 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$14], [%72, %$19] ; # ->
; # (when (ge0 Fd) (unLock @ 0 0))
; # (ge0 Fd)
  %108 = icmp sge i32 %52, 0
  br i1 %108, label %$22, label %$23
$22:
  %109 = phi i64 [%106, %$16] ; # X
; # (unLock @ 0 0)
  %110 = call i32 @unLock(i32 %52, i64 0, i64 0)
  br label %$23
$23:
  %111 = phi i64 [%106, %$16], [%109, %$22] ; # X
  br label %$4
$4:
  %112 = phi i64 [%20, %$6], [%111, %$23] ; # X
  %113 = phi i64 [%30, %$6], [%107, %$23] ; # ->
  ret i64 %113
}

define i64 @_seq(i64) align 8 {
$1:
; # (let (X (eval (cadr Exe)) F (dec (i32 (int X))) N 0 Buf (b8 BLK))...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (int X)
  %14 = lshr i64 %13, 4
; # (i32 (int X))
  %15 = trunc i64 %14 to i32
; # (dec (i32 (int X)))
  %16 = sub i32 %15, 1
; # (b8 BLK)
  %17 = alloca i8, i64 6
; # (unless (cnt? X) (unless (sym? (val (tail (needSymb Exe X)))) (ex...
; # (cnt? X)
  %18 = and i64 %13, 2
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$7:
  %20 = phi i32 [%16, %$2] ; # F
  %21 = phi i64 [0, %$2] ; # N
; # (unless (sym? (val (tail (needSymb Exe X)))) (extErr Exe X))
; # (needSymb Exe X)
  %22 = xor i64 %13, 8
  %23 = and i64 %22, 14
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$10, label %$9
$9:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$10:
; # (tail (needSymb Exe X))
  %25 = add i64 %13, -8
; # (val (tail (needSymb Exe X)))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (sym? (val (tail (needSymb Exe X))))
  %28 = and i64 %27, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$11
$11:
  %30 = phi i32 [%20, %$10] ; # F
  %31 = phi i64 [%21, %$10] ; # N
; # (extErr Exe X)
  call void @extErr(i64 %0, i64 %13)
  unreachable
$12:
  %32 = phi i32 [%20, %$10] ; # F
  %33 = phi i64 [%21, %$10] ; # N
; # (let Nm (name (& (val (tail X)) -9)) (setq F (objFile Nm) N (shl ...
; # (tail X)
  %34 = add i64 %13, -8
; # (val (tail X))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (& (val (tail X)) -9)
  %37 = and i64 %36, -9
; # (name (& (val (tail X)) -9))
  br label %$13
$13:
  %38 = phi i64 [%37, %$12], [%44, %$14] ; # Tail
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$15, label %$14
$14:
  %41 = phi i64 [%38, %$13] ; # Tail
  %42 = inttoptr i64 %41 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
  br label %$13
$15:
  %45 = phi i64 [%38, %$13] ; # Tail
; # (objFile Nm)
  %46 = call i32 @objFile(i64 %45)
; # (objId Nm)
  %47 = call i64 @objId(i64 %45)
; # (shl (objId Nm) 6)
  %48 = shl i64 %47, 6
  br label %$8
$8:
  %49 = phi i32 [%16, %$2], [%46, %$15] ; # F
  %50 = phi i64 [0, %$2], [%48, %$15] ; # N
; # (when (>= F (val $DBs)) (dbfErr Exe))
; # (val $DBs)
  %51 = load i32, i32* @$DBs
; # (>= F (val $DBs))
  %52 = icmp sge i32 %49, %51
  br i1 %52, label %$16, label %$17
$16:
  %53 = phi i32 [%49, %$8] ; # F
  %54 = phi i64 [%50, %$8] ; # N
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$17:
  %55 = phi i32 [%49, %$8] ; # F
  %56 = phi i64 [%50, %$8] ; # N
; # (let Db: (dbFile (set $DbFile (ofs (val $DbFiles) (* F (dbFile T)...
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %57 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %58 = mul i32 %55, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %59 = getelementptr i8, i8* %57, i32 %58
  store i8* %59, i8** @$DbFile
; # (rdLockDb)
  call void @rdLockDb()
; # (blkPeek BLK Buf BLK)
  call void @blkPeek(i64 6, i8* %17, i32 6)
; # (let Next (getAdr Buf) (prog1 (loop (? (>= (inc 'N BLKSIZE) Next)...
; # (getAdr Buf)
  %60 = call i64 @getAdr(i8* %17)
; # (prog1 (loop (? (>= (inc 'N BLKSIZE) Next) $Nil) (blkPeek (shl N ...
; # (loop (? (>= (inc 'N BLKSIZE) Next) $Nil) (blkPeek (shl N (i64 (D...
  br label %$18
$18:
  %61 = phi i32 [%55, %$17], [%82, %$22] ; # F
  %62 = phi i64 [%56, %$17], [%83, %$22] ; # N
; # (? (>= (inc 'N BLKSIZE) Next) $Nil)
; # (inc 'N BLKSIZE)
  %63 = add i64 %62, 64
; # (>= (inc 'N BLKSIZE) Next)
  %64 = icmp uge i64 %63, %60
  br i1 %64, label %$21, label %$19
$21:
  %65 = phi i32 [%61, %$18] ; # F
  %66 = phi i64 [%63, %$18] ; # N
  br label %$20
$19:
  %67 = phi i32 [%61, %$18] ; # F
  %68 = phi i64 [%63, %$18] ; # N
; # (Db: sh)
  %69 = getelementptr i8, i8* %59, i32 8
  %70 = bitcast i8* %69 to i32*
  %71 = load i32, i32* %70
; # (i64 (Db: sh))
  %72 = sext i32 %71 to i64
; # (shl N (i64 (Db: sh)))
  %73 = shl i64 %68, %72
; # (blkPeek (shl N (i64 (Db: sh))) Buf BLK)
  call void @blkPeek(i64 %73, i8* %17, i32 6)
; # (? (== 1 (& (val Buf) BLKTAG)) (extern (extNm F (shr N 6))))
; # (val Buf)
  %74 = load i8, i8* %17
; # (& (val Buf) BLKTAG)
  %75 = and i8 %74, 63
; # (== 1 (& (val Buf) BLKTAG))
  %76 = icmp eq i8 1, %75
  br i1 %76, label %$23, label %$22
$23:
  %77 = phi i32 [%67, %$19] ; # F
  %78 = phi i64 [%68, %$19] ; # N
; # (shr N 6)
  %79 = lshr i64 %78, 6
; # (extNm F (shr N 6))
  %80 = call i64 @extNm(i32 %77, i64 %79)
; # (extern (extNm F (shr N 6)))
  %81 = call i64 @extern(i64 %80)
  br label %$20
$22:
  %82 = phi i32 [%67, %$19] ; # F
  %83 = phi i64 [%68, %$19] ; # N
  br label %$18
$20:
  %84 = phi i32 [%65, %$21], [%77, %$23] ; # F
  %85 = phi i64 [%66, %$21], [%78, %$23] ; # N
  %86 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21], [%81, %$23] ; # ->
; # (unLockDb 1)
  call void @unLockDb(i64 1)
  ret i64 %86
}

define i64 @_lieu(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (nond ((symb? X) $Nil) ((sym? (val (tail...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nond ((symb? X) $Nil) ((sym? (val (tail X))) $Nil) (NIL (let Nm ...
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$9
$9:
  br label %$7
$8:
; # (tail X)
  %17 = add i64 %13, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$11
$11:
  br label %$7
$10:
; # (let Nm (name (& (val (tail X)) -9)) (setq Nm (add Nm Nm)) (cond ...
; # (tail X)
  %22 = add i64 %13, -8
; # (val (tail X))
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (& (val (tail X)) -9)
  %25 = and i64 %24, -9
; # (name (& (val (tail X)) -9))
  br label %$12
$12:
  %26 = phi i64 [%25, %$10], [%32, %$13] ; # Tail
  %27 = and i64 %26, 6
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$14, label %$13
$13:
  %29 = phi i64 [%26, %$12] ; # Tail
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  br label %$12
$14:
  %33 = phi i64 [%26, %$12] ; # Tail
; # (add Nm Nm)
  %34 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %33, i64 %33)
  %35 = extractvalue {i64, i1} %34, 1
  %36 = extractvalue {i64, i1} %34, 0
; # (cond (@@ (setq Nm (add Nm Nm)) (if @@ $Nil X)) (T (setq Nm (add ...
  br i1 %35, label %$17, label %$16
$17:
  %37 = phi i64 [%36, %$14] ; # Nm
; # (add Nm Nm)
  %38 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %37, i64 %37)
  %39 = extractvalue {i64, i1} %38, 1
  %40 = extractvalue {i64, i1} %38, 0
; # (if @@ $Nil X)
  br i1 %39, label %$18, label %$19
$18:
  %41 = phi i64 [%40, %$17] ; # Nm
  br label %$20
$19:
  %42 = phi i64 [%40, %$17] ; # Nm
  br label %$20
$20:
  %43 = phi i64 [%41, %$18], [%42, %$19] ; # Nm
  %44 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$18], [%13, %$19] ; # ->
  br label %$15
$16:
  %45 = phi i64 [%36, %$14] ; # Nm
; # (add Nm Nm)
  %46 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %45, i64 %45)
  %47 = extractvalue {i64, i1} %46, 1
  %48 = extractvalue {i64, i1} %46, 0
; # (if @@ X $Nil)
  br i1 %47, label %$21, label %$22
$21:
  %49 = phi i64 [%48, %$16] ; # Nm
  br label %$23
$22:
  %50 = phi i64 [%48, %$16] ; # Nm
  br label %$23
$23:
  %51 = phi i64 [%49, %$21], [%50, %$22] ; # Nm
  %52 = phi i64 [%13, %$21], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
  br label %$15
$15:
  %53 = phi i64 [%43, %$20], [%51, %$23] ; # Nm
  %54 = phi i64 [%44, %$20], [%52, %$23] ; # ->
  br label %$7
$7:
  %55 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [%54, %$15] ; # ->
  ret i64 %55
}

define i64 @_lock(i64) align 8 {
$1:
; # (if (if (nil? (eval (cadr Exe))) (tryLock (val $DbFiles) 0 0) (le...
; # (if (nil? (eval (cadr Exe))) (tryLock (val $DbFiles) 0 0) (let X ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
; # (val $DbFiles)
  %15 = load i8*, i8** @$DbFiles
; # (tryLock (val $DbFiles) 0 0)
  %16 = call i32 @tryLock(i8* %15, i64 0, i64 0)
  br label %$9
$8:
; # (let X (needSymb Exe @) (unless (sym? (val (tail (needSymb Exe X)...
; # (needSymb Exe @)
  %17 = xor i64 %13, 8
  %18 = and i64 %17, 14
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$11, label %$10
$10:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$11:
; # (unless (sym? (val (tail (needSymb Exe X)))) (extErr Exe X))
; # (needSymb Exe X)
  %20 = xor i64 %13, 8
  %21 = and i64 %20, 14
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$13, label %$12
$12:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$13:
; # (tail (needSymb Exe X))
  %23 = add i64 %13, -8
; # (val (tail (needSymb Exe X)))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
; # (sym? (val (tail (needSymb Exe X))))
  %26 = and i64 %25, 8
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$15, label %$14
$14:
; # (extErr Exe X)
  call void @extErr(i64 %0, i64 %13)
  unreachable
$15:
; # (let (Nm (name (& (val (tail X)) -9)) F (objFile Nm) N (objId Nm)...
; # (tail X)
  %28 = add i64 %13, -8
; # (val (tail X))
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (& (val (tail X)) -9)
  %31 = and i64 %30, -9
; # (name (& (val (tail X)) -9))
  br label %$16
$16:
  %32 = phi i64 [%31, %$15], [%38, %$17] ; # Tail
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$18, label %$17
$17:
  %35 = phi i64 [%32, %$16] ; # Tail
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  br label %$16
$18:
  %39 = phi i64 [%32, %$16] ; # Tail
; # (objFile Nm)
  %40 = call i32 @objFile(i64 %39)
; # (objId Nm)
  %41 = call i64 @objId(i64 %39)
; # (when (>= F (val $DBs)) (dbfErr Exe))
; # (val $DBs)
  %42 = load i32, i32* @$DBs
; # (>= F (val $DBs))
  %43 = icmp sge i32 %40, %42
  br i1 %43, label %$19, label %$20
$19:
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$20:
; # (let Db: (dbFile (ofs (val $DbFiles) (* F (dbFile T)))) (tryLock ...
; # (val $DbFiles)
  %44 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %45 = mul i32 %40, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %46 = getelementptr i8, i8* %44, i32 %45
; # (Db:)
; # (Db: siz)
  %47 = getelementptr i8, i8* %46, i32 12
  %48 = bitcast i8* %47 to i32*
  %49 = load i32, i32* %48
; # (i64 (Db: siz))
  %50 = sext i32 %49 to i64
; # (* N (i64 (Db: siz)))
  %51 = mul i64 %41, %50
; # (tryLock (Db:) (* N (i64 (Db: siz))) 1)
  %52 = call i32 @tryLock(i8* %46, i64 %51, i64 1)
  br label %$9
$9:
  %53 = phi i32 [%16, %$7], [%52, %$20] ; # ->
  %54 = icmp ne i32 %53, 0
  br i1 %54, label %$21, label %$22
$21:
; # (i64 @)
  %55 = sext i32 %53 to i64
; # (cnt (i64 @))
  %56 = shl i64 %55, 4
  %57 = or i64 %56, 2
  br label %$23
$22:
  br label %$23
$23:
  %58 = phi i64 [%57, %$21], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
  ret i64 %58
}

define void @db(i64, i64, i64) align 8 {
$1:
; # (save Sym)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %1, i64* %7
  %8 = add i64 %6, 8
  %9 = inttoptr i64 %8 to i64*
  store i64 %4, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %10
; # (let F (objFile Nm) (if (>= F (val $DBs)) (let Ext (val $Ext) (if...
; # (objFile Nm)
  %11 = call i32 @objFile(i64 %2)
; # (if (>= F (val $DBs)) (let Ext (val $Ext) (if (or (atom Ext) (> (...
; # (val $DBs)
  %12 = load i32, i32* @$DBs
; # (>= F (val $DBs))
  %13 = icmp sge i32 %11, %12
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%2, %$1] ; # Nm
  %15 = phi i32 [%11, %$1] ; # F
; # (let Ext (val $Ext) (if (or (atom Ext) (> (i32 (int (caar @))) (i...
; # (val $Ext)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 536) to i64) to i64*
  %17 = load i64, i64* %16
; # (if (or (atom Ext) (> (i32 (int (caar @))) (inc 'F))) (dbfErr Exe...
; # (or (atom Ext) (> (i32 (int (caar @))) (inc 'F)))
; # (atom Ext)
  %18 = and i64 %17, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$5, label %$6
$6:
  %20 = phi i64 [%14, %$2] ; # Nm
  %21 = phi i32 [%15, %$2] ; # F
  %22 = phi i64 [%17, %$2] ; # Ext
; # (caar @)
  %23 = inttoptr i64 %17 to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (int (caar @))
  %27 = lshr i64 %26, 4
; # (i32 (int (caar @)))
  %28 = trunc i64 %27 to i32
; # (inc 'F)
  %29 = add i32 %21, 1
; # (> (i32 (int (caar @))) (inc 'F))
  %30 = icmp sgt i32 %28, %29
  br label %$5
$5:
  %31 = phi i64 [%14, %$2], [%20, %$6] ; # Nm
  %32 = phi i32 [%15, %$2], [%29, %$6] ; # F
  %33 = phi i64 [%17, %$2], [%22, %$6] ; # Ext
  %34 = phi i1 [1, %$2], [%30, %$6] ; # ->
  br i1 %34, label %$7, label %$8
$7:
  %35 = phi i64 [%31, %$5] ; # Nm
  %36 = phi i32 [%32, %$5] ; # F
  %37 = phi i64 [%33, %$5] ; # Ext
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$8:
  %38 = phi i64 [%31, %$5] ; # Nm
  %39 = phi i32 [%32, %$5] ; # F
  %40 = phi i64 [%33, %$5] ; # Ext
; # (while (and (pair (cdr Ext)) (>= F (i32 (int (caar @))))) (shift ...
  br label %$10
$10:
  %41 = phi i64 [%38, %$8], [%63, %$13] ; # Nm
  %42 = phi i32 [%39, %$8], [%64, %$13] ; # F
  %43 = phi i64 [%40, %$8], [%68, %$13] ; # Ext
; # (and (pair (cdr Ext)) (>= F (i32 (int (caar @)))))
; # (cdr Ext)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (pair (cdr Ext))
  %47 = and i64 %46, 15
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %$12, label %$11
$12:
  %49 = phi i64 [%41, %$10] ; # Nm
  %50 = phi i32 [%42, %$10] ; # F
  %51 = phi i64 [%43, %$10] ; # Ext
; # (caar @)
  %52 = inttoptr i64 %46 to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (int (caar @))
  %56 = lshr i64 %55, 4
; # (i32 (int (caar @)))
  %57 = trunc i64 %56 to i32
; # (>= F (i32 (int (caar @))))
  %58 = icmp sge i32 %50, %57
  br label %$11
$11:
  %59 = phi i64 [%41, %$10], [%49, %$12] ; # Nm
  %60 = phi i32 [%42, %$10], [%50, %$12] ; # F
  %61 = phi i64 [%43, %$10], [%51, %$12] ; # Ext
  %62 = phi i1 [0, %$10], [%58, %$12] ; # ->
  br i1 %62, label %$13, label %$14
$13:
  %63 = phi i64 [%59, %$11] ; # Nm
  %64 = phi i32 [%60, %$11] ; # F
  %65 = phi i64 [%61, %$11] ; # Ext
; # (shift Ext)
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
  br label %$10
$14:
  %69 = phi i64 [%59, %$11] ; # Nm
  %70 = phi i32 [%60, %$11] ; # F
  %71 = phi i64 [%61, %$11] ; # Ext
; # (let (V (push NIL $Nil ZERO Sym) E (push NIL V ZERO (cdar Ext))) ...
; # (push NIL $Nil ZERO Sym)
  %72 = alloca i64, i64 4, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = add i64 %73, 8
  %75 = inttoptr i64 %74 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %75
  %76 = add i64 %73, 16
  %77 = inttoptr i64 %76 to i64*
  store i64 2, i64* %77
  %78 = add i64 %73, 24
  %79 = inttoptr i64 %78 to i64*
  store i64 %1, i64* %79
; # (cdar Ext)
  %80 = inttoptr i64 %71 to i64*
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (push NIL V ZERO (cdar Ext))
  %85 = alloca i64, i64 4, align 16
  %86 = ptrtoint i64* %85 to i64
  %87 = add i64 %86, 8
  %88 = inttoptr i64 %87 to i64*
  store i64 %73, i64* %88
  %89 = add i64 %86, 16
  %90 = inttoptr i64 %89 to i64*
  store i64 2, i64* %90
  %91 = add i64 %86, 24
  %92 = inttoptr i64 %91 to i64*
  store i64 %84, i64* %92
; # (set V (ofs V 3) E (ofs E 3))
; # (ofs V 3)
  %93 = add i64 %73, 24
  %94 = inttoptr i64 %73 to i64*
  store i64 %93, i64* %94
; # (ofs E 3)
  %95 = add i64 %86, 24
  %96 = inttoptr i64 %86 to i64*
  store i64 %95, i64* %96
; # (let X (evList E) (set Sym (++ X)) (if (atom X) (set (tail Sym) N...
; # (evList E)
  %97 = call i64 @evList(i64 %86)
; # (set Sym (++ X))
; # (++ X)
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
  %100 = getelementptr i64, i64* %98, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 %1 to i64*
  store i64 %99, i64* %102
; # (if (atom X) (set (tail Sym) Nm) (set (tail Sym) (sym X)) (while ...
; # (atom X)
  %103 = and i64 %101, 15
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$15, label %$16
$15:
  %105 = phi i64 [%69, %$14] ; # Nm
  %106 = phi i32 [%70, %$14] ; # F
  %107 = phi i64 [%71, %$14] ; # Ext
  %108 = phi i64 [%101, %$14] ; # X
; # (set (tail Sym) Nm)
; # (tail Sym)
  %109 = add i64 %1, -8
  %110 = inttoptr i64 %109 to i64*
  store i64 %105, i64* %110
  br label %$17
$16:
  %111 = phi i64 [%69, %$14] ; # Nm
  %112 = phi i32 [%70, %$14] ; # F
  %113 = phi i64 [%71, %$14] ; # Ext
  %114 = phi i64 [%101, %$14] ; # X
; # (set (tail Sym) (sym X))
; # (tail Sym)
  %115 = add i64 %1, -8
; # (sym X)
  %116 = or i64 %114, 8
  %117 = inttoptr i64 %115 to i64*
  store i64 %116, i64* %117
; # (while (pair (cdr X)) (setq X @))
  br label %$18
$18:
  %118 = phi i64 [%111, %$16], [%127, %$19] ; # Nm
  %119 = phi i32 [%112, %$16], [%128, %$19] ; # F
  %120 = phi i64 [%113, %$16], [%129, %$19] ; # Ext
  %121 = phi i64 [%114, %$16], [%124, %$19] ; # X
; # (cdr X)
  %122 = inttoptr i64 %121 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  %124 = load i64, i64* %123
; # (pair (cdr X))
  %125 = and i64 %124, 15
  %126 = icmp eq i64 %125, 0
  br i1 %126, label %$19, label %$20
$19:
  %127 = phi i64 [%118, %$18] ; # Nm
  %128 = phi i32 [%119, %$18] ; # F
  %129 = phi i64 [%120, %$18] ; # Ext
  %130 = phi i64 [%121, %$18] ; # X
  br label %$18
$20:
  %131 = phi i64 [%118, %$18] ; # Nm
  %132 = phi i32 [%119, %$18] ; # F
  %133 = phi i64 [%120, %$18] ; # Ext
  %134 = phi i64 [%121, %$18] ; # X
; # (set 2 X Nm)
  %135 = inttoptr i64 %134 to i64*
  %136 = getelementptr i64, i64* %135, i32 1
  store i64 %131, i64* %136
  br label %$17
$17:
  %137 = phi i64 [%105, %$15], [%131, %$20] ; # Nm
  %138 = phi i32 [%106, %$15], [%132, %$20] ; # F
  %139 = phi i64 [%107, %$15], [%133, %$20] ; # Ext
  %140 = phi i64 [%108, %$15], [%134, %$20] ; # X
  %141 = phi i64 [%105, %$15], [%131, %$20] ; # ->
  br label %$9
$9:
  %142 = phi i64 [%137, %$17] ; # Nm
  %143 = phi i32 [%138, %$17] ; # F
  %144 = phi i64 [%139, %$17] ; # Ext
  %145 = phi i64 [%141, %$17] ; # ->
  br label %$4
$3:
  %146 = phi i64 [%2, %$1] ; # Nm
  %147 = phi i32 [%11, %$1] ; # F
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %148 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %149 = mul i32 %147, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %150 = getelementptr i8, i8* %148, i32 %149
  store i8* %150, i8** @$DbFile
; # (rdLockDb)
  call void @rdLockDb()
; # (let Blk (rdBlock (shl (objId Nm) 6)) (unless (== 1 (& (val Blk) ...
; # (objId Nm)
  %151 = call i64 @objId(i64 %146)
; # (shl (objId Nm) 6)
  %152 = shl i64 %151, 6
; # (rdBlock (shl (objId Nm) 6))
  %153 = call i8* @rdBlock(i64 %152)
; # (unless (== 1 (& (val Blk) BLKTAG)) (err Exe Sym ($ "Bad ID") nul...
; # (val Blk)
  %154 = load i8, i8* %153
; # (& (val Blk) BLKTAG)
  %155 = and i8 %154, 63
; # (== 1 (& (val Blk) BLKTAG))
  %156 = icmp eq i8 1, %155
  br i1 %156, label %$22, label %$21
$21:
  %157 = phi i64 [%146, %$3] ; # Nm
  %158 = phi i32 [%147, %$3] ; # F
; # (err Exe Sym ($ "Bad ID") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([7 x i8]* @$63 to i8*), i8* null)
  unreachable
$22:
  %159 = phi i64 [%146, %$3] ; # Nm
  %160 = phi i32 [%147, %$3] ; # F
; # (set $GetBin (fun (i32) getBlock) $Extn 0)
; # (fun (i32) getBlock)
  store i32()* @getBlock, i32()** @$GetBin
  store i32 0, i32* @$Extn
; # (set Sym (binRead))
; # (binRead)
  %161 = call i64 @binRead()
  %162 = inttoptr i64 %1 to i64*
  store i64 %161, i64* %162
; # (if (nil? (binRead)) (set (tail Sym) Nm) (set (tail Sym) (sym (se...
; # (binRead)
  %163 = call i64 @binRead()
; # (nil? (binRead))
  %164 = icmp eq i64 %163, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %164, label %$23, label %$24
$23:
  %165 = phi i64 [%159, %$22] ; # Nm
  %166 = phi i32 [%160, %$22] ; # F
; # (set (tail Sym) Nm)
; # (tail Sym)
  %167 = add i64 %1, -8
  %168 = inttoptr i64 %167 to i64*
  store i64 %165, i64* %168
  br label %$25
$24:
  %169 = phi i64 [%159, %$22] ; # Nm
  %170 = phi i32 [%160, %$22] ; # F
; # (set (tail Sym) (sym (setq Nm (cons @ Nm))))
; # (tail Sym)
  %171 = add i64 %1, -8
; # (cons @ Nm)
  %172 = call i64 @cons(i64 %163, i64 %169)
; # (sym (setq Nm (cons @ Nm)))
  %173 = or i64 %172, 8
  %174 = inttoptr i64 %171 to i64*
  store i64 %173, i64* %174
; # (unless (t? (binRead)) (set Nm (cons @ (val Nm))))
; # (binRead)
  %175 = call i64 @binRead()
; # (t? (binRead))
  %176 = icmp eq i64 %175, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %176, label %$27, label %$26
$26:
  %177 = phi i64 [%172, %$24] ; # Nm
  %178 = phi i32 [%170, %$24] ; # F
; # (set Nm (cons @ (val Nm)))
; # (val Nm)
  %179 = inttoptr i64 %177 to i64*
  %180 = load i64, i64* %179
; # (cons @ (val Nm))
  %181 = call i64 @cons(i64 %175, i64 %180)
  %182 = inttoptr i64 %177 to i64*
  store i64 %181, i64* %182
  br label %$27
$27:
  %183 = phi i64 [%172, %$24], [%177, %$26] ; # Nm
  %184 = phi i32 [%170, %$24], [%178, %$26] ; # F
; # (until (nil? (binRead)) (set 2 Nm (cons @ (cdr Nm))) (shift Nm) (...
  br label %$28
$28:
  %185 = phi i64 [%183, %$27], [%208, %$32] ; # Nm
  %186 = phi i32 [%184, %$27], [%209, %$32] ; # F
; # (binRead)
  %187 = call i64 @binRead()
; # (nil? (binRead))
  %188 = icmp eq i64 %187, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %188, label %$30, label %$29
$29:
  %189 = phi i64 [%185, %$28] ; # Nm
  %190 = phi i32 [%186, %$28] ; # F
; # (set 2 Nm (cons @ (cdr Nm)))
; # (cdr Nm)
  %191 = inttoptr i64 %189 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
; # (cons @ (cdr Nm))
  %194 = call i64 @cons(i64 %187, i64 %193)
  %195 = inttoptr i64 %189 to i64*
  %196 = getelementptr i64, i64* %195, i32 1
  store i64 %194, i64* %196
; # (shift Nm)
  %197 = inttoptr i64 %189 to i64*
  %198 = getelementptr i64, i64* %197, i32 1
  %199 = load i64, i64* %198
; # (unless (t? (binRead)) (set Nm (cons @ (val Nm))))
; # (binRead)
  %200 = call i64 @binRead()
; # (t? (binRead))
  %201 = icmp eq i64 %200, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %201, label %$32, label %$31
$31:
  %202 = phi i64 [%199, %$29] ; # Nm
  %203 = phi i32 [%190, %$29] ; # F
; # (set Nm (cons @ (val Nm)))
; # (val Nm)
  %204 = inttoptr i64 %202 to i64*
  %205 = load i64, i64* %204
; # (cons @ (val Nm))
  %206 = call i64 @cons(i64 %200, i64 %205)
  %207 = inttoptr i64 %202 to i64*
  store i64 %206, i64* %207
  br label %$32
$32:
  %208 = phi i64 [%199, %$29], [%202, %$31] ; # Nm
  %209 = phi i32 [%190, %$29], [%203, %$31] ; # F
  br label %$28
$30:
  %210 = phi i64 [%185, %$28] ; # Nm
  %211 = phi i32 [%186, %$28] ; # F
  br label %$25
$25:
  %212 = phi i64 [%165, %$23], [%210, %$30] ; # Nm
  %213 = phi i32 [%166, %$23], [%211, %$30] ; # F
; # (unLockDb 1)
  call void @unLockDb(i64 1)
  br label %$4
$4:
  %214 = phi i64 [%142, %$9], [%212, %$25] ; # Nm
  %215 = phi i32 [%143, %$9], [%213, %$25] ; # F
; # (drop *Safe)
  %216 = inttoptr i64 %6 to i64*
  %217 = getelementptr i64, i64* %216, i32 1
  %218 = load i64, i64* %217
  %219 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %218, i64* %219
  ret void
}

define void @dbFetch(i64, i64) align 8 {
$1:
; # (let Nm (val (tail Sym)) (when (and (num? Nm) (prog (setq Nm (add...
; # (tail Sym)
  %2 = add i64 %1, -8
; # (val (tail Sym))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (when (and (num? Nm) (prog (setq Nm (add Nm Nm)) (not @@)) (prog ...
; # (and (num? Nm) (prog (setq Nm (add Nm Nm)) (not @@)) (prog (setq ...
; # (num? Nm)
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$3:
  %7 = phi i64 [%4, %$1] ; # Nm
; # (add Nm Nm)
  %8 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %7, i64 %7)
  %9 = extractvalue {i64, i1} %8, 1
  %10 = extractvalue {i64, i1} %8, 0
; # (not @@)
  %11 = icmp eq i1 %9, 0
  br i1 %11, label %$4, label %$2
$4:
  %12 = phi i64 [%10, %$3] ; # Nm
; # (add Nm Nm)
  %13 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %12, i64 %12)
  %14 = extractvalue {i64, i1} %13, 1
  %15 = extractvalue {i64, i1} %13, 0
; # (not @@)
  %16 = icmp eq i1 %14, 0
  br label %$2
$2:
  %17 = phi i64 [%4, %$1], [%10, %$3], [%15, %$4] ; # Nm
  %18 = phi i1 [0, %$1], [0, %$3], [%16, %$4] ; # ->
  br i1 %18, label %$5, label %$6
$5:
  %19 = phi i64 [%17, %$2] ; # Nm
; # (set (tail Sym) (setq Nm (shr 1 Nm 2)))
; # (tail Sym)
  %20 = add i64 %1, -8
; # (shr 1 Nm 2)
  %21 = call i64 @llvm.fshr.i64(i64 1, i64 %19, i64 2)
  %22 = inttoptr i64 %20 to i64*
  store i64 %21, i64* %22
; # (db Exe Sym Nm)
  tail call void @db(i64 %0, i64 %1, i64 %21)
  br label %$6
$6:
  %23 = phi i64 [%17, %$2], [%21, %$5] ; # Nm
  ret void
}

define void @dbTouch(i64, i64) align 8 {
$1:
; # (let (Q (tail Sym) Nm (val Q)) (unless (num? Nm) (setq Nm (any (&...
; # (tail Sym)
  %2 = add i64 %1, -8
; # (val Q)
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (unless (num? Nm) (setq Nm (any (& Nm -9))) (loop (setq Q (ofs Nm...
; # (num? Nm)
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%2, %$1] ; # Q
  %8 = phi i64 [%4, %$1] ; # Nm
; # (& Nm -9)
  %9 = and i64 %8, -9
; # (any (& Nm -9))
; # (loop (setq Q (ofs Nm 1)) (? (num? (setq Nm (val Q)))))
  br label %$4
$4:
  %10 = phi i64 [%7, %$2], [%17, %$5] ; # Q
  %11 = phi i64 [%9, %$2], [%18, %$5] ; # Nm
; # (ofs Nm 1)
  %12 = add i64 %11, 8
; # (? (num? (setq Nm (val Q))))
; # (val Q)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (num? (setq Nm (val Q)))
  %15 = and i64 %14, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$6, label %$5
$5:
  %17 = phi i64 [%12, %$4] ; # Q
  %18 = phi i64 [%14, %$4] ; # Nm
  br label %$4
$6:
  %19 = phi i64 [%12, %$4] ; # Q
  %20 = phi i64 [%14, %$4] ; # Nm
  %21 = phi i64 [0, %$4] ; # ->
  br label %$3
$3:
  %22 = phi i64 [%2, %$1], [%19, %$6] ; # Q
  %23 = phi i64 [%4, %$1], [%20, %$6] ; # Nm
; # (add Nm Nm)
  %24 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %23, i64 %23)
  %25 = extractvalue {i64, i1} %24, 1
  %26 = extractvalue {i64, i1} %24, 0
; # (unless @@ (setq Nm (add Nm Nm)) (set Q (setq Nm (shr 2 Nm 2))) (...
  br i1 %25, label %$8, label %$7
$7:
  %27 = phi i64 [%22, %$3] ; # Q
  %28 = phi i64 [%26, %$3] ; # Nm
; # (add Nm Nm)
  %29 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %28, i64 %28)
  %30 = extractvalue {i64, i1} %29, 1
  %31 = extractvalue {i64, i1} %29, 0
; # (set Q (setq Nm (shr 2 Nm 2)))
; # (shr 2 Nm 2)
  %32 = call i64 @llvm.fshr.i64(i64 2, i64 %31, i64 2)
  %33 = inttoptr i64 %27 to i64*
  store i64 %32, i64* %33
; # (unless @@ (tailcall (db Exe Sym Nm)))
  br i1 %30, label %$10, label %$9
$9:
  %34 = phi i64 [%27, %$7] ; # Q
  %35 = phi i64 [%32, %$7] ; # Nm
; # (db Exe Sym Nm)
  tail call void @db(i64 %0, i64 %1, i64 %35)
  br label %$10
$10:
  %36 = phi i64 [%27, %$7], [%34, %$9] ; # Q
  %37 = phi i64 [%32, %$7], [%35, %$9] ; # Nm
  br label %$8
$8:
  %38 = phi i64 [%22, %$3], [%36, %$10] ; # Q
  %39 = phi i64 [%26, %$3], [%37, %$10] ; # Nm
  ret void
}

define i64 @_touch(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (when (and (symb? X) (sym? (val (tail X)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (when (and (symb? X) (sym? (val (tail X)))) (dbTouch Exe X))
; # (and (symb? X) (sym? (val (tail X))))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (tail X)
  %17 = add i64 %13, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br label %$7
$7:
  %22 = phi i1 [0, %$2], [%21, %$8] ; # ->
  br i1 %22, label %$9, label %$10
$9:
; # (dbTouch Exe X)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$10
$10:
  ret i64 %13
}

define void @dbZap(i64) align 8 {
$1:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (setq Tail (& Tail...
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (unless (num? Tail) (setq Tail (& Tail -9)) (loop (? (num? (shift...
; # (num? Tail)
  %4 = and i64 %3, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$3, label %$2
$2:
  %6 = phi i64 [%3, %$1] ; # Tail
; # (& Tail -9)
  %7 = and i64 %6, -9
; # (loop (? (num? (shift Tail))))
  br label %$4
$4:
  %8 = phi i64 [%7, %$2], [%14, %$5] ; # Tail
; # (? (num? (shift Tail)))
; # (shift Tail)
  %9 = inttoptr i64 %8 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (num? (shift Tail))
  %12 = and i64 %11, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$5:
  %14 = phi i64 [%11, %$4] ; # Tail
  br label %$4
$6:
  %15 = phi i64 [%11, %$4] ; # Tail
  %16 = phi i64 [0, %$4] ; # ->
; # (sym Tail)
  %17 = or i64 %15, 8
  br label %$3
$3:
  %18 = phi i64 [%3, %$1], [%17, %$6] ; # Tail
; # (set (tail Sym) (shr 3 (shl Tail 2) 2))
; # (tail Sym)
  %19 = add i64 %0, -8
; # (shl Tail 2)
  %20 = shl i64 %18, 2
; # (shr 3 (shl Tail 2) 2)
  %21 = call i64 @llvm.fshr.i64(i64 3, i64 %20, i64 2)
  %22 = inttoptr i64 %19 to i64*
  store i64 %21, i64* %22
; # (set Sym $Nil)
  %23 = inttoptr i64 %0 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %23
  ret void
}

define i64 @_commit(i64) align 8 {
$1:
; # (let (Args (cdr Exe) Rpc (save (eval (++ Args))) Notify NO) (set ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ Args)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ Args))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ Args)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (set $Protect (inc (val $Protect)))
; # (val $Protect)
  %24 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (inc (val $Protect))
  %25 = add i32 %24, 1
  store i32 %25, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (wrLockDb)
  call void @wrLockDb()
; # (when (val $DbJnl) (lockJnl))
; # (val $DbJnl)
  %26 = load i8*, i8** @$DbJnl
  %27 = icmp ne i8* %26, null
  br i1 %27, label %$7, label %$8
$7:
  %28 = phi i64 [%7, %$2] ; # Args
  %29 = phi i1 [0, %$2] ; # Notify
; # (lockJnl)
  call void @lockJnl()
  br label %$8
$8:
  %30 = phi i64 [%7, %$2], [%28, %$7] ; # Args
  %31 = phi i1 [0, %$2], [%29, %$7] ; # Notify
; # (when (val $DbLog) (let (Db (val $DbFiles) C (val $DBs)) (loop (l...
; # (val $DbLog)
  %32 = load i8*, i8** @$DbLog
  %33 = icmp ne i8* %32, null
  br i1 %33, label %$9, label %$10
$9:
  %34 = phi i64 [%30, %$8] ; # Args
  %35 = phi i1 [%31, %$8] ; # Notify
; # (let (Db (val $DbFiles) C (val $DBs)) (loop (let Db: (dbFile Db) ...
; # (val $DbFiles)
  %36 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %37 = load i32, i32* @$DBs
; # (loop (let Db: (dbFile Db) (Db: drt NO) (Db: flu 0)) (? (=0 (dec ...
  br label %$11
$11:
  %38 = phi i64 [%34, %$9], [%48, %$12] ; # Args
  %39 = phi i1 [%35, %$9], [%49, %$12] ; # Notify
  %40 = phi i8* [%36, %$9], [%52, %$12] ; # Db
  %41 = phi i32 [%37, %$9], [%51, %$12] ; # C
; # (let Db: (dbFile Db) (Db: drt NO) (Db: flu 0))
; # (Db: drt NO)
  %42 = getelementptr i8, i8* %40, i32 41
  %43 = bitcast i8* %42 to i1*
  store i1 0, i1* %43
; # (Db: flu 0)
  %44 = getelementptr i8, i8* %40, i32 32
  %45 = bitcast i8* %44 to i64*
  store i64 0, i64* %45
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %46 = sub i32 %41, 1
; # (=0 (dec 'C))
  %47 = icmp eq i32 %46, 0
  br i1 %47, label %$13, label %$12
$12:
  %48 = phi i64 [%38, %$11] ; # Args
  %49 = phi i1 [%39, %$11] ; # Notify
  %50 = phi i8* [%40, %$11] ; # Db
  %51 = phi i32 [%46, %$11] ; # C
; # (ofs Db (dbFile T))
  %52 = getelementptr i8, i8* %50, i32 42
  br label %$11
$13:
  %53 = phi i64 [%38, %$11] ; # Args
  %54 = phi i1 [%39, %$11] ; # Notify
  %55 = phi i8* [%40, %$11] ; # Db
  %56 = phi i32 [%46, %$11] ; # C
  %57 = phi i64 [0, %$11] ; # ->
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (cdr P) (? (atom ...
; # (val $Extern)
  %58 = load i64, i64* @$Extern
; # (loop (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @)...
  br label %$14
$14:
  %59 = phi i64 [%53, %$13], [%228, %$32] ; # Args
  %60 = phi i1 [%54, %$13], [%229, %$32] ; # Notify
  %61 = phi i64 [0, %$13], [%230, %$32] ; # Tos
  %62 = phi i64 [%58, %$13], [%231, %$32] ; # P
; # (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set ...
  br label %$15
$15:
  %63 = phi i64 [%59, %$14], [%74, %$16] ; # Args
  %64 = phi i1 [%60, %$14], [%75, %$16] ; # Notify
  %65 = phi i64 [%61, %$14], [%77, %$16] ; # Tos
  %66 = phi i64 [%62, %$14], [%71, %$16] ; # P
; # (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set X Tos)...
; # (cdr P)
  %67 = inttoptr i64 %66 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
; # (? (atom (car X)))
; # (car X)
  %70 = inttoptr i64 %69 to i64*
  %71 = load i64, i64* %70
; # (atom (car X))
  %72 = and i64 %71, 15
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$17, label %$16
$16:
  %74 = phi i64 [%63, %$15] ; # Args
  %75 = phi i1 [%64, %$15] ; # Notify
  %76 = phi i64 [%65, %$15] ; # Tos
  %77 = phi i64 [%66, %$15] ; # P
; # (let Y P (setq P @) (set X Tos) (setq Tos Y))
; # (set X Tos)
  %78 = inttoptr i64 %69 to i64*
  store i64 %76, i64* %78
  br label %$15
$17:
  %79 = phi i64 [%63, %$15] ; # Args
  %80 = phi i1 [%64, %$15] ; # Notify
  %81 = phi i64 [%65, %$15] ; # Tos
  %82 = phi i64 [%66, %$15] ; # P
  %83 = phi i64 [0, %$15] ; # ->
; # (loop (let (Nm (name (& (val (tail (val P))) -9)) N (add Nm Nm)) ...
  br label %$18
$18:
  %84 = phi i64 [%79, %$17], [%223, %$38] ; # Args
  %85 = phi i1 [%80, %$17], [%224, %$38] ; # Notify
  %86 = phi i64 [%81, %$17], [%225, %$38] ; # Tos
  %87 = phi i64 [%82, %$17], [%226, %$38] ; # P
; # (let (Nm (name (& (val (tail (val P))) -9)) N (add Nm Nm)) (when ...
; # (val P)
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (tail (val P))
  %90 = add i64 %89, -8
; # (val (tail (val P)))
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (& (val (tail (val P))) -9)
  %93 = and i64 %92, -9
; # (name (& (val (tail (val P))) -9))
  br label %$19
$19:
  %94 = phi i64 [%93, %$18], [%100, %$20] ; # Tail
  %95 = and i64 %94, 6
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$21, label %$20
$20:
  %97 = phi i64 [%94, %$19] ; # Tail
  %98 = inttoptr i64 %97 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
  br label %$19
$21:
  %101 = phi i64 [%94, %$19] ; # Tail
; # (add Nm Nm)
  %102 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %101, i64 %101)
  %103 = extractvalue {i64, i1} %102, 1
  %104 = extractvalue {i64, i1} %102, 0
; # (when @@ (let F (objFile Nm) (when (> (val $DBs) F) (set $DbFile ...
  br i1 %103, label %$22, label %$23
$22:
  %105 = phi i64 [%84, %$21] ; # Args
  %106 = phi i1 [%85, %$21] ; # Notify
  %107 = phi i64 [%86, %$21] ; # Tos
  %108 = phi i64 [%87, %$21] ; # P
; # (let F (objFile Nm) (when (> (val $DBs) F) (set $DbFile (ofs (val...
; # (objFile Nm)
  %109 = call i32 @objFile(i64 %101)
; # (when (> (val $DBs) F) (set $DbFile (ofs (val $DbFiles) (* F (dbF...
; # (val $DBs)
  %110 = load i32, i32* @$DBs
; # (> (val $DBs) F)
  %111 = icmp sgt i32 %110, %109
  br i1 %111, label %$24, label %$25
$24:
  %112 = phi i64 [%105, %$22] ; # Args
  %113 = phi i1 [%106, %$22] ; # Notify
  %114 = phi i64 [%107, %$22] ; # Tos
  %115 = phi i64 [%108, %$22] ; # P
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %116 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %117 = mul i32 %109, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %118 = getelementptr i8, i8* %116, i32 %117
  store i8* %118, i8** @$DbFile
; # (objId Nm)
  %119 = call i64 @objId(i64 %101)
; # (shl (objId Nm) 6)
  %120 = shl i64 %119, 6
; # (rdBlock (shl (objId Nm) 6))
  %121 = call i8* @rdBlock(i64 %120)
; # (loop (logBlock) (? (=0 (val $BlkLink))) (rdBlock @))
  br label %$26
$26:
  %122 = phi i64 [%112, %$24], [%128, %$27] ; # Args
  %123 = phi i1 [%113, %$24], [%129, %$27] ; # Notify
  %124 = phi i64 [%114, %$24], [%130, %$27] ; # Tos
  %125 = phi i64 [%115, %$24], [%131, %$27] ; # P
; # (logBlock)
  call void @logBlock()
; # (? (=0 (val $BlkLink)))
; # (val $BlkLink)
  %126 = load i64, i64* @$BlkLink
; # (=0 (val $BlkLink))
  %127 = icmp eq i64 %126, 0
  br i1 %127, label %$28, label %$27
$27:
  %128 = phi i64 [%122, %$26] ; # Args
  %129 = phi i1 [%123, %$26] ; # Notify
  %130 = phi i64 [%124, %$26] ; # Tos
  %131 = phi i64 [%125, %$26] ; # P
; # (rdBlock @)
  %132 = call i8* @rdBlock(i64 %126)
  br label %$26
$28:
  %133 = phi i64 [%122, %$26] ; # Args
  %134 = phi i1 [%123, %$26] ; # Notify
  %135 = phi i64 [%124, %$26] ; # Tos
  %136 = phi i64 [%125, %$26] ; # P
  %137 = phi i64 [0, %$26] ; # ->
; # (let Db: (dbFile (val $DbFile)) (Db: drt YES) (add N N) (unless @...
; # (val $DbFile)
  %138 = load i8*, i8** @$DbFile
; # (Db: drt YES)
  %139 = getelementptr i8, i8* %138, i32 41
  %140 = bitcast i8* %139 to i1*
  store i1 1, i1* %140
; # (add N N)
  %141 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %104, i64 %104)
  %142 = extractvalue {i64, i1} %141, 1
  %143 = extractvalue {i64, i1} %141, 0
; # (unless @@ (Db: flu (inc (Db: flu))))
  br i1 %142, label %$30, label %$29
$29:
  %144 = phi i64 [%133, %$28] ; # Args
  %145 = phi i1 [%134, %$28] ; # Notify
  %146 = phi i64 [%135, %$28] ; # Tos
  %147 = phi i64 [%136, %$28] ; # P
; # (Db: flu (inc (Db: flu)))
  %148 = getelementptr i8, i8* %138, i32 32
  %149 = bitcast i8* %148 to i64*
  %150 = getelementptr i8, i8* %138, i32 32
  %151 = bitcast i8* %150 to i64*
  %152 = load i64, i64* %151
  %153 = add i64 %152, 1
  store i64 %153, i64* %149
  br label %$30
$30:
  %154 = phi i64 [%133, %$28], [%144, %$29] ; # Args
  %155 = phi i1 [%134, %$28], [%145, %$29] ; # Notify
  %156 = phi i64 [%135, %$28], [%146, %$29] ; # Tos
  %157 = phi i64 [%136, %$28], [%147, %$29] ; # P
  br label %$25
$25:
  %158 = phi i64 [%105, %$22], [%154, %$30] ; # Args
  %159 = phi i1 [%106, %$22], [%155, %$30] ; # Notify
  %160 = phi i64 [%107, %$22], [%156, %$30] ; # Tos
  %161 = phi i64 [%108, %$22], [%157, %$30] ; # P
  br label %$23
$23:
  %162 = phi i64 [%84, %$21], [%158, %$25] ; # Args
  %163 = phi i1 [%85, %$21], [%159, %$25] ; # Notify
  %164 = phi i64 [%86, %$21], [%160, %$25] ; # Tos
  %165 = phi i64 [%87, %$21], [%161, %$25] ; # P
; # (let X (cdr P) (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos...
; # (cdr P)
  %166 = inttoptr i64 %165 to i64*
  %167 = getelementptr i64, i64* %166, i32 1
  %168 = load i64, i64* %167
; # (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos) (setq Tos (| ...
; # (cdr X)
  %169 = inttoptr i64 %168 to i64*
  %170 = getelementptr i64, i64* %169, i32 1
  %171 = load i64, i64* %170
; # (pair (cdr X))
  %172 = and i64 %171, 15
  %173 = icmp eq i64 %172, 0
  br i1 %173, label %$33, label %$31
$33:
  %174 = phi i64 [%162, %$23] ; # Args
  %175 = phi i1 [%163, %$23] ; # Notify
  %176 = phi i64 [%164, %$23] ; # Tos
  %177 = phi i64 [%165, %$23] ; # P
; # (let Y P (setq P @) (set 2 X Tos) (setq Tos (| Y 8)))
; # (set 2 X Tos)
  %178 = inttoptr i64 %168 to i64*
  %179 = getelementptr i64, i64* %178, i32 1
  store i64 %176, i64* %179
; # (| Y 8)
  %180 = or i64 %177, 8
  br label %$32
$31:
  %181 = phi i64 [%162, %$23] ; # Args
  %182 = phi i1 [%163, %$23] ; # Notify
  %183 = phi i64 [%164, %$23] ; # Tos
  %184 = phi i64 [%165, %$23] ; # P
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$34
$34:
  %185 = phi i64 [%181, %$31], [%210, %$37] ; # Args
  %186 = phi i1 [%182, %$31], [%211, %$37] ; # Notify
  %187 = phi i64 [%183, %$31], [%220, %$37] ; # Tos
  %188 = phi i64 [%184, %$31], [%214, %$37] ; # P
; # (unless Tos (goto 1))
  %189 = icmp ne i64 %187, 0
  br i1 %189, label %$36, label %$35
$35:
  %190 = phi i64 [%185, %$34] ; # Args
  %191 = phi i1 [%186, %$34] ; # Notify
  %192 = phi i64 [%187, %$34] ; # Tos
  %193 = phi i64 [%188, %$34] ; # P
; # (goto 1)
  br label %$-1
$36:
  %194 = phi i64 [%185, %$34] ; # Args
  %195 = phi i1 [%186, %$34] ; # Notify
  %196 = phi i64 [%187, %$34] ; # Tos
  %197 = phi i64 [%188, %$34] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set ...
; # (& Tos 8)
  %198 = and i64 %196, 8
; # (=0 (& Tos 8))
  %199 = icmp eq i64 %198, 0
  br i1 %199, label %$39, label %$37
$39:
  %200 = phi i64 [%194, %$36] ; # Args
  %201 = phi i1 [%195, %$36] ; # Notify
  %202 = phi i64 [%196, %$36] ; # Tos
  %203 = phi i64 [%197, %$36] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %204 = inttoptr i64 %202 to i64*
  %205 = getelementptr i64, i64* %204, i32 1
  %206 = load i64, i64* %205
; # (car Y)
  %207 = inttoptr i64 %206 to i64*
  %208 = load i64, i64* %207
; # (set Y P)
  %209 = inttoptr i64 %206 to i64*
  store i64 %203, i64* %209
  br label %$38
$37:
  %210 = phi i64 [%194, %$36] ; # Args
  %211 = phi i1 [%195, %$36] ; # Notify
  %212 = phi i64 [%196, %$36] ; # Tos
  %213 = phi i64 [%197, %$36] ; # P
; # (& Tos -9)
  %214 = and i64 %212, -9
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %215 = inttoptr i64 %214 to i64*
  %216 = getelementptr i64, i64* %215, i32 1
  %217 = load i64, i64* %216
; # (cdr Y)
  %218 = inttoptr i64 %217 to i64*
  %219 = getelementptr i64, i64* %218, i32 1
  %220 = load i64, i64* %219
; # (set 2 Y P)
  %221 = inttoptr i64 %217 to i64*
  %222 = getelementptr i64, i64* %221, i32 1
  store i64 %213, i64* %222
  br label %$34
$38:
  %223 = phi i64 [%200, %$39] ; # Args
  %224 = phi i1 [%201, %$39] ; # Notify
  %225 = phi i64 [%208, %$39] ; # Tos
  %226 = phi i64 [%202, %$39] ; # P
  %227 = phi i64 [%202, %$39] ; # ->
  br label %$18
$32:
  %228 = phi i64 [%174, %$33] ; # Args
  %229 = phi i1 [%175, %$33] ; # Notify
  %230 = phi i64 [%180, %$33] ; # Tos
  %231 = phi i64 [%171, %$33] ; # P
  %232 = phi i64 [%180, %$33] ; # ->
  br label %$14
$40:
; # (: 1 (let (P (val $DbFiles) C (val $DBs)) (loop (when ((dbFile P)...
  br label %$-1
$-1:
  %233 = phi i64 [%190, %$35], [%228, %$40] ; # Args
  %234 = phi i1 [%191, %$35], [%229, %$40] ; # Notify
; # (let (P (val $DbFiles) C (val $DBs)) (loop (when ((dbFile P) flu)...
; # (val $DbFiles)
  %235 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %236 = load i32, i32* @$DBs
; # (loop (when ((dbFile P) flu) (let N @ (set $DbFile P) (rdBlock 0)...
  br label %$41
$41:
  %237 = phi i64 [%233, %$-1], [%282, %$48] ; # Args
  %238 = phi i1 [%234, %$-1], [%283, %$48] ; # Notify
  %239 = phi i8* [%235, %$-1], [%286, %$48] ; # P
  %240 = phi i32 [%236, %$-1], [%285, %$48] ; # C
; # (when ((dbFile P) flu) (let N @ (set $DbFile P) (rdBlock 0) (loop...
; # ((dbFile P) flu)
  %241 = getelementptr i8, i8* %239, i32 32
  %242 = bitcast i8* %241 to i64*
  %243 = load i64, i64* %242
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$42, label %$43
$42:
  %245 = phi i64 [%237, %$41] ; # Args
  %246 = phi i1 [%238, %$41] ; # Notify
  %247 = phi i8* [%239, %$41] ; # P
  %248 = phi i32 [%240, %$41] ; # C
; # (let N @ (set $DbFile P) (rdBlock 0) (loop (logBlock) (? (=0 (dec...
; # (set $DbFile P)
  store i8* %247, i8** @$DbFile
; # (rdBlock 0)
  %249 = call i8* @rdBlock(i64 0)
; # (loop (logBlock) (? (=0 (dec 'N))) (? (=0 (val $BlkLink))) (rdBlo...
  br label %$44
$44:
  %250 = phi i64 [%245, %$42], [%264, %$47] ; # Args
  %251 = phi i1 [%246, %$42], [%265, %$47] ; # Notify
  %252 = phi i8* [%247, %$42], [%266, %$47] ; # P
  %253 = phi i32 [%248, %$42], [%267, %$47] ; # C
  %254 = phi i64 [%243, %$42], [%268, %$47] ; # N
; # (logBlock)
  call void @logBlock()
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %255 = sub i64 %254, 1
; # (=0 (dec 'N))
  %256 = icmp eq i64 %255, 0
  br i1 %256, label %$46, label %$45
$45:
  %257 = phi i64 [%250, %$44] ; # Args
  %258 = phi i1 [%251, %$44] ; # Notify
  %259 = phi i8* [%252, %$44] ; # P
  %260 = phi i32 [%253, %$44] ; # C
  %261 = phi i64 [%255, %$44] ; # N
; # (? (=0 (val $BlkLink)))
; # (val $BlkLink)
  %262 = load i64, i64* @$BlkLink
; # (=0 (val $BlkLink))
  %263 = icmp eq i64 %262, 0
  br i1 %263, label %$46, label %$47
$47:
  %264 = phi i64 [%257, %$45] ; # Args
  %265 = phi i1 [%258, %$45] ; # Notify
  %266 = phi i8* [%259, %$45] ; # P
  %267 = phi i32 [%260, %$45] ; # C
  %268 = phi i64 [%261, %$45] ; # N
; # (rdBlock @)
  %269 = call i8* @rdBlock(i64 %262)
  br label %$44
$46:
  %270 = phi i64 [%250, %$44], [%257, %$45] ; # Args
  %271 = phi i1 [%251, %$44], [%258, %$45] ; # Notify
  %272 = phi i8* [%252, %$44], [%259, %$45] ; # P
  %273 = phi i32 [%253, %$44], [%260, %$45] ; # C
  %274 = phi i64 [%255, %$44], [%261, %$45] ; # N
  %275 = phi i64 [0, %$44], [0, %$45] ; # ->
  br label %$43
$43:
  %276 = phi i64 [%237, %$41], [%270, %$46] ; # Args
  %277 = phi i1 [%238, %$41], [%271, %$46] ; # Notify
  %278 = phi i8* [%239, %$41], [%272, %$46] ; # P
  %279 = phi i32 [%240, %$41], [%273, %$46] ; # C
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %280 = sub i32 %279, 1
; # (=0 (dec 'C))
  %281 = icmp eq i32 %280, 0
  br i1 %281, label %$49, label %$48
$48:
  %282 = phi i64 [%276, %$43] ; # Args
  %283 = phi i1 [%277, %$43] ; # Notify
  %284 = phi i8* [%278, %$43] ; # P
  %285 = phi i32 [%280, %$43] ; # C
; # (ofs P (dbFile T))
  %286 = getelementptr i8, i8* %284, i32 42
  br label %$41
$49:
  %287 = phi i64 [%276, %$43] ; # Args
  %288 = phi i1 [%277, %$43] ; # Notify
  %289 = phi i8* [%278, %$43] ; # P
  %290 = phi i32 [%280, %$43] ; # C
  %291 = phi i64 [0, %$43] ; # ->
; # (let Log (val $DbLog) (putc_unlocked (hex "FF") Log) (putc_unlock...
; # (val $DbLog)
  %292 = load i8*, i8** @$DbLog
; # (putc_unlocked (hex "FF") Log)
  %293 = call i32 @putc_unlocked(i32 255, i8* %292)
; # (putc_unlocked (hex "FF") Log)
  %294 = call i32 @putc_unlocked(i32 255, i8* %292)
; # (fflush Log)
  %295 = call i32 @fflush(i8* %292)
; # (when (lt0 (fsync (fileno Log))) (err Exe 0 ($ "Transaction fsync...
; # (fileno Log)
  %296 = call i32 @fileno(i8* %292)
; # (fsync (fileno Log))
  %297 = call i32 @fsync(i32 %296)
; # (lt0 (fsync (fileno Log)))
  %298 = icmp slt i32 %297, 0
  br i1 %298, label %$50, label %$51
$50:
  %299 = phi i64 [%287, %$49] ; # Args
  %300 = phi i1 [%288, %$49] ; # Notify
; # (strErrno)
  %301 = call i8* @strErrno()
; # (err Exe 0 ($ "Transaction fsync error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([28 x i8]* @$64 to i8*), i8* %301)
  unreachable
$51:
  %302 = phi i64 [%287, %$49] ; # Args
  %303 = phi i1 [%288, %$49] ; # Notify
  br label %$10
$10:
  %304 = phi i64 [%30, %$8], [%302, %$51] ; # Args
  %305 = phi i1 [%31, %$8], [%303, %$51] ; # Notify
; # (++ Args)
  %306 = inttoptr i64 %304 to i64*
  %307 = load i64, i64* %306
  %308 = getelementptr i64, i64* %306, i32 1
  %309 = load i64, i64* %308
; # (eval (++ Args))
  %310 = and i64 %307, 6
  %311 = icmp ne i64 %310, 0
  br i1 %311, label %$54, label %$53
$54:
  br label %$52
$53:
  %312 = and i64 %307, 8
  %313 = icmp ne i64 %312, 0
  br i1 %313, label %$56, label %$55
$56:
  %314 = inttoptr i64 %307 to i64*
  %315 = load i64, i64* %314
  br label %$52
$55:
  %316 = call i64 @evList(i64 %307)
  br label %$52
$52:
  %317 = phi i64 [%307, %$54], [%315, %$56], [%316, %$55] ; # ->
; # (when (and (not (nil? Rpc)) (or (val $Tell) (val $Children))) (se...
; # (and (not (nil? Rpc)) (or (val $Tell) (val $Children)))
; # (nil? Rpc)
  %318 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Rpc))
  %319 = icmp eq i1 %318, 0
  br i1 %319, label %$58, label %$57
$58:
  %320 = phi i64 [%309, %$52] ; # Args
  %321 = phi i1 [%305, %$52] ; # Notify
; # (or (val $Tell) (val $Children))
; # (val $Tell)
  %322 = load i32, i32* @$Tell
  %323 = icmp ne i32 %322, 0
  br i1 %323, label %$59, label %$60
$60:
  %324 = phi i64 [%320, %$58] ; # Args
  %325 = phi i1 [%321, %$58] ; # Notify
; # (val $Children)
  %326 = load i32, i32* @$Children
  %327 = icmp ne i32 %326, 0
  br label %$59
$59:
  %328 = phi i64 [%320, %$58], [%324, %$60] ; # Args
  %329 = phi i1 [%321, %$58], [%325, %$60] ; # Notify
  %330 = phi i1 [1, %$58], [%327, %$60] ; # ->
  br label %$57
$57:
  %331 = phi i64 [%309, %$52], [%328, %$59] ; # Args
  %332 = phi i1 [%305, %$52], [%329, %$59] ; # Notify
  %333 = phi i1 [0, %$52], [%330, %$59] ; # ->
  br i1 %333, label %$61, label %$62
$61:
  %334 = phi i64 [%331, %$57] ; # Args
  %335 = phi i1 [%332, %$57] ; # Notify
; # (set $BufX (val $TellBuf) $PtrX (val $Ptr) $EndX (val $End))
; # (val $TellBuf)
  %336 = load i8*, i8** @$TellBuf
  store i8* %336, i8** @$BufX
; # (val $Ptr)
  %337 = load i8*, i8** @$Ptr
  store i8* %337, i8** @$PtrX
; # (val $End)
  %338 = load i8*, i8** @$End
  store i8* %338, i8** @$EndX
; # (val PipeBufSize)
  %339 = load i32, i32* @PipeBufSize
; # (b8 (val PipeBufSize))
  %340 = alloca i8, i32 %339
; # (tellBeg (b8 (val PipeBufSize)))
  call void @tellBeg(i8* %340)
; # (prTell Rpc)
  call void @prTell(i64 %15)
  br label %$62
$62:
  %341 = phi i64 [%331, %$57], [%334, %$61] ; # Args
  %342 = phi i1 [%332, %$57], [1, %$61] ; # Notify
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (cdr P) (? (atom ...
; # (val $Extern)
  %343 = load i64, i64* @$Extern
; # (loop (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @)...
  br label %$63
$63:
  %344 = phi i64 [%341, %$62], [%763, %$103] ; # Args
  %345 = phi i1 [%342, %$62], [%764, %$103] ; # Notify
  %346 = phi i64 [0, %$62], [%765, %$103] ; # Tos
  %347 = phi i64 [%343, %$62], [%766, %$103] ; # P
; # (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set ...
  br label %$64
$64:
  %348 = phi i64 [%344, %$63], [%359, %$65] ; # Args
  %349 = phi i1 [%345, %$63], [%360, %$65] ; # Notify
  %350 = phi i64 [%346, %$63], [%362, %$65] ; # Tos
  %351 = phi i64 [%347, %$63], [%356, %$65] ; # P
; # (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set X Tos)...
; # (cdr P)
  %352 = inttoptr i64 %351 to i64*
  %353 = getelementptr i64, i64* %352, i32 1
  %354 = load i64, i64* %353
; # (? (atom (car X)))
; # (car X)
  %355 = inttoptr i64 %354 to i64*
  %356 = load i64, i64* %355
; # (atom (car X))
  %357 = and i64 %356, 15
  %358 = icmp ne i64 %357, 0
  br i1 %358, label %$66, label %$65
$65:
  %359 = phi i64 [%348, %$64] ; # Args
  %360 = phi i1 [%349, %$64] ; # Notify
  %361 = phi i64 [%350, %$64] ; # Tos
  %362 = phi i64 [%351, %$64] ; # P
; # (let Y P (setq P @) (set X Tos) (setq Tos Y))
; # (set X Tos)
  %363 = inttoptr i64 %354 to i64*
  store i64 %361, i64* %363
  br label %$64
$66:
  %364 = phi i64 [%348, %$64] ; # Args
  %365 = phi i1 [%349, %$64] ; # Notify
  %366 = phi i64 [%350, %$64] ; # Tos
  %367 = phi i64 [%351, %$64] ; # P
  %368 = phi i64 [0, %$64] ; # ->
; # (loop (let (Sym (val P) Q (tail Sym) Nm (val Q)) (unless (num? Nm...
  br label %$67
$67:
  %369 = phi i64 [%364, %$66], [%758, %$109] ; # Args
  %370 = phi i1 [%365, %$66], [%759, %$109] ; # Notify
  %371 = phi i64 [%366, %$66], [%760, %$109] ; # Tos
  %372 = phi i64 [%367, %$66], [%761, %$109] ; # P
; # (let (Sym (val P) Q (tail Sym) Nm (val Q)) (unless (num? Nm) (set...
; # (val P)
  %373 = inttoptr i64 %372 to i64*
  %374 = load i64, i64* %373
; # (tail Sym)
  %375 = add i64 %374, -8
; # (val Q)
  %376 = inttoptr i64 %375 to i64*
  %377 = load i64, i64* %376
; # (unless (num? Nm) (setq Nm (any (& Nm -9))) (loop (setq Q (ofs Nm...
; # (num? Nm)
  %378 = and i64 %377, 6
  %379 = icmp ne i64 %378, 0
  br i1 %379, label %$69, label %$68
$68:
  %380 = phi i64 [%369, %$67] ; # Args
  %381 = phi i1 [%370, %$67] ; # Notify
  %382 = phi i64 [%371, %$67] ; # Tos
  %383 = phi i64 [%372, %$67] ; # P
  %384 = phi i64 [%375, %$67] ; # Q
  %385 = phi i64 [%377, %$67] ; # Nm
; # (& Nm -9)
  %386 = and i64 %385, -9
; # (any (& Nm -9))
; # (loop (setq Q (ofs Nm 1)) (? (num? (setq Nm (val Q)))))
  br label %$70
$70:
  %387 = phi i64 [%380, %$68], [%398, %$71] ; # Args
  %388 = phi i1 [%381, %$68], [%399, %$71] ; # Notify
  %389 = phi i64 [%382, %$68], [%400, %$71] ; # Tos
  %390 = phi i64 [%383, %$68], [%401, %$71] ; # P
  %391 = phi i64 [%384, %$68], [%402, %$71] ; # Q
  %392 = phi i64 [%386, %$68], [%403, %$71] ; # Nm
; # (ofs Nm 1)
  %393 = add i64 %392, 8
; # (? (num? (setq Nm (val Q))))
; # (val Q)
  %394 = inttoptr i64 %393 to i64*
  %395 = load i64, i64* %394
; # (num? (setq Nm (val Q)))
  %396 = and i64 %395, 6
  %397 = icmp ne i64 %396, 0
  br i1 %397, label %$72, label %$71
$71:
  %398 = phi i64 [%387, %$70] ; # Args
  %399 = phi i1 [%388, %$70] ; # Notify
  %400 = phi i64 [%389, %$70] ; # Tos
  %401 = phi i64 [%390, %$70] ; # P
  %402 = phi i64 [%393, %$70] ; # Q
  %403 = phi i64 [%395, %$70] ; # Nm
  br label %$70
$72:
  %404 = phi i64 [%387, %$70] ; # Args
  %405 = phi i1 [%388, %$70] ; # Notify
  %406 = phi i64 [%389, %$70] ; # Tos
  %407 = phi i64 [%390, %$70] ; # P
  %408 = phi i64 [%393, %$70] ; # Q
  %409 = phi i64 [%395, %$70] ; # Nm
  %410 = phi i64 [0, %$70] ; # ->
  br label %$69
$69:
  %411 = phi i64 [%369, %$67], [%404, %$72] ; # Args
  %412 = phi i1 [%370, %$67], [%405, %$72] ; # Notify
  %413 = phi i64 [%371, %$67], [%406, %$72] ; # Tos
  %414 = phi i64 [%372, %$67], [%407, %$72] ; # P
  %415 = phi i64 [%375, %$67], [%408, %$72] ; # Q
  %416 = phi i64 [%377, %$67], [%409, %$72] ; # Nm
; # (let N (add Nm Nm) (when @@ (let F (objFile Nm) (setq N (add N N)...
; # (add Nm Nm)
  %417 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %416, i64 %416)
  %418 = extractvalue {i64, i1} %417, 1
  %419 = extractvalue {i64, i1} %417, 0
; # (when @@ (let F (objFile Nm) (setq N (add N N)) (cond (@@ (set Q ...
  br i1 %418, label %$73, label %$74
$73:
  %420 = phi i64 [%411, %$69] ; # Args
  %421 = phi i1 [%412, %$69] ; # Notify
  %422 = phi i64 [%413, %$69] ; # Tos
  %423 = phi i64 [%414, %$69] ; # P
  %424 = phi i64 [%415, %$69] ; # Q
  %425 = phi i64 [%416, %$69] ; # Nm
  %426 = phi i64 [%419, %$69] ; # N
; # (let F (objFile Nm) (setq N (add N N)) (cond (@@ (set Q (shr N 2)...
; # (objFile Nm)
  %427 = call i32 @objFile(i64 %425)
; # (add N N)
  %428 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %426, i64 %426)
  %429 = extractvalue {i64, i1} %428, 1
  %430 = extractvalue {i64, i1} %428, 0
; # (cond (@@ (set Q (shr N 2)) (when (> (val $DBs) F) (set $DbFile (...
  br i1 %429, label %$77, label %$76
$77:
  %431 = phi i64 [%420, %$73] ; # Args
  %432 = phi i1 [%421, %$73] ; # Notify
  %433 = phi i64 [%422, %$73] ; # Tos
  %434 = phi i64 [%423, %$73] ; # P
  %435 = phi i64 [%424, %$73] ; # Q
  %436 = phi i64 [%425, %$73] ; # Nm
  %437 = phi i64 [%430, %$73] ; # N
; # (set Q (shr N 2))
; # (shr N 2)
  %438 = lshr i64 %437, 2
  %439 = inttoptr i64 %435 to i64*
  store i64 %438, i64* %439
; # (when (> (val $DBs) F) (set $DbFile (ofs (val $DbFiles) (* F (dbF...
; # (val $DBs)
  %440 = load i32, i32* @$DBs
; # (> (val $DBs) F)
  %441 = icmp sgt i32 %440, %427
  br i1 %441, label %$78, label %$79
$78:
  %442 = phi i64 [%431, %$77] ; # Args
  %443 = phi i1 [%432, %$77] ; # Notify
  %444 = phi i64 [%433, %$77] ; # Tos
  %445 = phi i64 [%434, %$77] ; # P
  %446 = phi i64 [%435, %$77] ; # Q
  %447 = phi i64 [%436, %$77] ; # Nm
  %448 = phi i64 [%437, %$77] ; # N
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %449 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %450 = mul i32 %427, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %451 = getelementptr i8, i8* %449, i32 %450
  store i8* %451, i8** @$DbFile
; # (objId Nm)
  %452 = call i64 @objId(i64 %447)
; # (shl (objId Nm) 6)
  %453 = shl i64 %452, 6
; # (cleanUp (shl (objId Nm) 6))
  call void @cleanUp(i64 %453)
; # (when Notify (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (-...
  br i1 %443, label %$80, label %$81
$80:
  %454 = phi i64 [%442, %$78] ; # Args
  %455 = phi i1 [%443, %$78] ; # Notify
  %456 = phi i64 [%444, %$78] ; # Tos
  %457 = phi i64 [%445, %$78] ; # P
  %458 = phi i64 [%446, %$78] ; # Q
  %459 = phi i64 [%447, %$78] ; # Nm
  %460 = phi i64 [%448, %$78] ; # N
; # (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (- (val PipeBuf...
; # (val $TellBuf)
  %461 = load i8*, i8** @$TellBuf
; # (when (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10))) (tellEnd 0...
; # (val $Ptr)
  %462 = load i8*, i8** @$Ptr
; # (val PipeBufSize)
  %463 = load i32, i32* @PipeBufSize
; # (- (val PipeBufSize) 10)
  %464 = sub i32 %463, 10
; # (ofs P (- (val PipeBufSize) 10))
  %465 = getelementptr i8, i8* %461, i32 %464
; # (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10)))
  %466 = icmp uge i8* %462, %465
  br i1 %466, label %$82, label %$83
$82:
  %467 = phi i64 [%454, %$80] ; # Args
  %468 = phi i1 [%455, %$80] ; # Notify
  %469 = phi i64 [%456, %$80] ; # Tos
  %470 = phi i64 [%458, %$80] ; # Q
  %471 = phi i64 [%459, %$80] ; # Nm
  %472 = phi i64 [%460, %$80] ; # N
  %473 = phi i8* [%461, %$80] ; # P
; # (tellEnd 0)
  call void @tellEnd(i32 0)
; # (set (inc 'P 8) BEG $Ptr (inc P))
; # (inc 'P 8)
  %474 = getelementptr i8, i8* %473, i32 8
  store i8 1, i8* %474
; # (inc P)
  %475 = getelementptr i8, i8* %474, i32 1
  store i8* %475, i8** @$Ptr
; # (prTell Rpc)
  call void @prTell(i64 %15)
  br label %$83
$83:
  %476 = phi i64 [%454, %$80], [%467, %$82] ; # Args
  %477 = phi i1 [%455, %$80], [%468, %$82] ; # Notify
  %478 = phi i64 [%456, %$80], [%469, %$82] ; # Tos
  %479 = phi i64 [%458, %$80], [%470, %$82] ; # Q
  %480 = phi i64 [%459, %$80], [%471, %$82] ; # Nm
  %481 = phi i64 [%460, %$80], [%472, %$82] ; # N
  %482 = phi i8* [%461, %$80], [%474, %$82] ; # P
; # (prTell Sym)
  call void @prTell(i64 %374)
  br label %$81
$81:
  %483 = phi i64 [%442, %$78], [%476, %$83] ; # Args
  %484 = phi i1 [%443, %$78], [%477, %$83] ; # Notify
  %485 = phi i64 [%444, %$78], [%478, %$83] ; # Tos
  %486 = phi i64 [%445, %$78], [%457, %$83] ; # P
  %487 = phi i64 [%446, %$78], [%479, %$83] ; # Q
  %488 = phi i64 [%447, %$78], [%480, %$83] ; # Nm
  %489 = phi i64 [%448, %$78], [%481, %$83] ; # N
  br label %$79
$79:
  %490 = phi i64 [%431, %$77], [%483, %$81] ; # Args
  %491 = phi i1 [%432, %$77], [%484, %$81] ; # Notify
  %492 = phi i64 [%433, %$77], [%485, %$81] ; # Tos
  %493 = phi i64 [%434, %$77], [%486, %$81] ; # P
  %494 = phi i64 [%435, %$77], [%487, %$81] ; # Q
  %495 = phi i64 [%436, %$77], [%488, %$81] ; # Nm
  %496 = phi i64 [%437, %$77], [%489, %$81] ; # N
  br label %$75
$76:
  %497 = phi i64 [%420, %$73] ; # Args
  %498 = phi i1 [%421, %$73] ; # Notify
  %499 = phi i64 [%422, %$73] ; # Tos
  %500 = phi i64 [%423, %$73] ; # P
  %501 = phi i64 [%424, %$73] ; # Q
  %502 = phi i64 [%425, %$73] ; # Nm
  %503 = phi i64 [%430, %$73] ; # N
; # (set Q (shr 1 N 2))
; # (shr 1 N 2)
  %504 = call i64 @llvm.fshr.i64(i64 1, i64 %503, i64 2)
  %505 = inttoptr i64 %501 to i64*
  store i64 %504, i64* %505
; # (when (> (val $DBs) F) (set $DbFile (ofs (val $DbFiles) (* F (dbF...
; # (val $DBs)
  %506 = load i32, i32* @$DBs
; # (> (val $DBs) F)
  %507 = icmp sgt i32 %506, %427
  br i1 %507, label %$84, label %$85
$84:
  %508 = phi i64 [%497, %$76] ; # Args
  %509 = phi i1 [%498, %$76] ; # Notify
  %510 = phi i64 [%499, %$76] ; # Tos
  %511 = phi i64 [%500, %$76] ; # P
  %512 = phi i64 [%501, %$76] ; # Q
  %513 = phi i64 [%502, %$76] ; # Nm
  %514 = phi i64 [%503, %$76] ; # N
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %515 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %516 = mul i32 %427, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %517 = getelementptr i8, i8* %515, i32 %516
  store i8* %517, i8** @$DbFile
; # (let Blk (rdBlock (shl (objId Nm) 6)) (set Blk (| (val Blk) 1) $P...
; # (objId Nm)
  %518 = call i64 @objId(i64 %513)
; # (shl (objId Nm) 6)
  %519 = shl i64 %518, 6
; # (rdBlock (shl (objId Nm) 6))
  %520 = call i8* @rdBlock(i64 %519)
; # (set Blk (| (val Blk) 1) $PutBin (fun (void i8) putBlock) $Extn 0...
; # (val Blk)
  %521 = load i8, i8* %520
; # (| (val Blk) 1)
  %522 = or i8 %521, 1
  store i8 %522, i8* %520
; # (fun (void i8) putBlock)
  store void(i8)* @putBlock, void(i8)** @$PutBin
  store i32 0, i32* @$Extn
; # (val Sym)
  %523 = inttoptr i64 %374 to i64*
  %524 = load i64, i64* %523
; # (binPrint (val Sym))
  call void @binPrint(i64 %524)
; # (let L (& (val (tail Sym)) -9) (until (num? L) (let V (++ L) (non...
; # (tail Sym)
  %525 = add i64 %374, -8
; # (val (tail Sym))
  %526 = inttoptr i64 %525 to i64*
  %527 = load i64, i64* %526
; # (& (val (tail Sym)) -9)
  %528 = and i64 %527, -9
; # (until (num? L) (let V (++ L) (nond ((atom V) (unless (nil? (cdr ...
  br label %$86
$86:
  %529 = phi i64 [%508, %$84], [%608, %$89] ; # Args
  %530 = phi i1 [%509, %$84], [%609, %$89] ; # Notify
  %531 = phi i64 [%510, %$84], [%610, %$89] ; # Tos
  %532 = phi i64 [%511, %$84], [%611, %$89] ; # P
  %533 = phi i64 [%512, %$84], [%612, %$89] ; # Q
  %534 = phi i64 [%513, %$84], [%613, %$89] ; # Nm
  %535 = phi i64 [%514, %$84], [%614, %$89] ; # N
  %536 = phi i64 [%528, %$84], [%615, %$89] ; # L
; # (num? L)
  %537 = and i64 %536, 6
  %538 = icmp ne i64 %537, 0
  br i1 %538, label %$88, label %$87
$87:
  %539 = phi i64 [%529, %$86] ; # Args
  %540 = phi i1 [%530, %$86] ; # Notify
  %541 = phi i64 [%531, %$86] ; # Tos
  %542 = phi i64 [%532, %$86] ; # P
  %543 = phi i64 [%533, %$86] ; # Q
  %544 = phi i64 [%534, %$86] ; # Nm
  %545 = phi i64 [%535, %$86] ; # N
  %546 = phi i64 [%536, %$86] ; # L
; # (let V (++ L) (nond ((atom V) (unless (nil? (cdr V)) (binPrint @)...
; # (++ L)
  %547 = inttoptr i64 %546 to i64*
  %548 = load i64, i64* %547
  %549 = getelementptr i64, i64* %547, i32 1
  %550 = load i64, i64* %549
; # (nond ((atom V) (unless (nil? (cdr V)) (binPrint @) (binPrint (ca...
; # (atom V)
  %551 = and i64 %548, 15
  %552 = icmp ne i64 %551, 0
  br i1 %552, label %$90, label %$91
$91:
  %553 = phi i64 [%539, %$87] ; # Args
  %554 = phi i1 [%540, %$87] ; # Notify
  %555 = phi i64 [%541, %$87] ; # Tos
  %556 = phi i64 [%542, %$87] ; # P
  %557 = phi i64 [%543, %$87] ; # Q
  %558 = phi i64 [%544, %$87] ; # Nm
  %559 = phi i64 [%545, %$87] ; # N
  %560 = phi i64 [%550, %$87] ; # L
; # (unless (nil? (cdr V)) (binPrint @) (binPrint (car V)))
; # (cdr V)
  %561 = inttoptr i64 %548 to i64*
  %562 = getelementptr i64, i64* %561, i32 1
  %563 = load i64, i64* %562
; # (nil? (cdr V))
  %564 = icmp eq i64 %563, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %564, label %$93, label %$92
$92:
  %565 = phi i64 [%553, %$91] ; # Args
  %566 = phi i1 [%554, %$91] ; # Notify
  %567 = phi i64 [%555, %$91] ; # Tos
  %568 = phi i64 [%556, %$91] ; # P
  %569 = phi i64 [%557, %$91] ; # Q
  %570 = phi i64 [%558, %$91] ; # Nm
  %571 = phi i64 [%559, %$91] ; # N
  %572 = phi i64 [%560, %$91] ; # L
; # (binPrint @)
  call void @binPrint(i64 %563)
; # (car V)
  %573 = inttoptr i64 %548 to i64*
  %574 = load i64, i64* %573
; # (binPrint (car V))
  call void @binPrint(i64 %574)
  br label %$93
$93:
  %575 = phi i64 [%553, %$91], [%565, %$92] ; # Args
  %576 = phi i1 [%554, %$91], [%566, %$92] ; # Notify
  %577 = phi i64 [%555, %$91], [%567, %$92] ; # Tos
  %578 = phi i64 [%556, %$91], [%568, %$92] ; # P
  %579 = phi i64 [%557, %$91], [%569, %$92] ; # Q
  %580 = phi i64 [%558, %$91], [%570, %$92] ; # Nm
  %581 = phi i64 [%559, %$91], [%571, %$92] ; # N
  %582 = phi i64 [%560, %$91], [%572, %$92] ; # L
  br label %$89
$90:
  %583 = phi i64 [%539, %$87] ; # Args
  %584 = phi i1 [%540, %$87] ; # Notify
  %585 = phi i64 [%541, %$87] ; # Tos
  %586 = phi i64 [%542, %$87] ; # P
  %587 = phi i64 [%543, %$87] ; # Q
  %588 = phi i64 [%544, %$87] ; # Nm
  %589 = phi i64 [%545, %$87] ; # N
  %590 = phi i64 [%550, %$87] ; # L
; # (nil? V)
  %591 = icmp eq i64 %548, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %591, label %$94, label %$95
$95:
  %592 = phi i64 [%583, %$90] ; # Args
  %593 = phi i1 [%584, %$90] ; # Notify
  %594 = phi i64 [%585, %$90] ; # Tos
  %595 = phi i64 [%586, %$90] ; # P
  %596 = phi i64 [%587, %$90] ; # Q
  %597 = phi i64 [%588, %$90] ; # Nm
  %598 = phi i64 [%589, %$90] ; # N
  %599 = phi i64 [%590, %$90] ; # L
; # (binPrint V)
  call void @binPrint(i64 %548)
; # (binPrint $T)
  call void @binPrint(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64))
  br label %$89
$94:
  %600 = phi i64 [%583, %$90] ; # Args
  %601 = phi i1 [%584, %$90] ; # Notify
  %602 = phi i64 [%585, %$90] ; # Tos
  %603 = phi i64 [%586, %$90] ; # P
  %604 = phi i64 [%587, %$90] ; # Q
  %605 = phi i64 [%588, %$90] ; # Nm
  %606 = phi i64 [%589, %$90] ; # N
  %607 = phi i64 [%590, %$90] ; # L
  br label %$89
$89:
  %608 = phi i64 [%575, %$93], [%592, %$95], [%600, %$94] ; # Args
  %609 = phi i1 [%576, %$93], [%593, %$95], [%601, %$94] ; # Notify
  %610 = phi i64 [%577, %$93], [%594, %$95], [%602, %$94] ; # Tos
  %611 = phi i64 [%578, %$93], [%595, %$95], [%603, %$94] ; # P
  %612 = phi i64 [%579, %$93], [%596, %$95], [%604, %$94] ; # Q
  %613 = phi i64 [%580, %$93], [%597, %$95], [%605, %$94] ; # Nm
  %614 = phi i64 [%581, %$93], [%598, %$95], [%606, %$94] ; # N
  %615 = phi i64 [%582, %$93], [%599, %$95], [%607, %$94] ; # L
  br label %$86
$88:
  %616 = phi i64 [%529, %$86] ; # Args
  %617 = phi i1 [%530, %$86] ; # Notify
  %618 = phi i64 [%531, %$86] ; # Tos
  %619 = phi i64 [%532, %$86] ; # P
  %620 = phi i64 [%533, %$86] ; # Q
  %621 = phi i64 [%534, %$86] ; # Nm
  %622 = phi i64 [%535, %$86] ; # N
  %623 = phi i64 [%536, %$86] ; # L
; # (putBlock NIX)
  call void @putBlock(i8 0)
; # (val $DbBlock)
  %624 = load i8*, i8** @$DbBlock
; # (val (val $DbBlock))
  %625 = load i8, i8* %624
; # (& (val (val $DbBlock)) BLKTAG)
  %626 = and i8 %625, 63
; # (i64 (& (val (val $DbBlock)) BLKTAG))
  %627 = zext i8 %626 to i64
; # (setAdr (i64 (& (val (val $DbBlock)) BLKTAG)) Blk)
  call void @setAdr(i64 %627, i8* %520)
; # (wrBlock)
  call void @wrBlock()
; # (when (val $BlkLink) (cleanUp @))
; # (val $BlkLink)
  %628 = load i64, i64* @$BlkLink
  %629 = icmp ne i64 %628, 0
  br i1 %629, label %$96, label %$97
$96:
  %630 = phi i64 [%616, %$88] ; # Args
  %631 = phi i1 [%617, %$88] ; # Notify
  %632 = phi i64 [%618, %$88] ; # Tos
  %633 = phi i64 [%619, %$88] ; # P
  %634 = phi i64 [%620, %$88] ; # Q
  %635 = phi i64 [%621, %$88] ; # Nm
  %636 = phi i64 [%622, %$88] ; # N
; # (cleanUp @)
  call void @cleanUp(i64 %628)
  br label %$97
$97:
  %637 = phi i64 [%616, %$88], [%630, %$96] ; # Args
  %638 = phi i1 [%617, %$88], [%631, %$96] ; # Notify
  %639 = phi i64 [%618, %$88], [%632, %$96] ; # Tos
  %640 = phi i64 [%619, %$88], [%633, %$96] ; # P
  %641 = phi i64 [%620, %$88], [%634, %$96] ; # Q
  %642 = phi i64 [%621, %$88], [%635, %$96] ; # Nm
  %643 = phi i64 [%622, %$88], [%636, %$96] ; # N
; # (when Notify (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (-...
  br i1 %638, label %$98, label %$99
$98:
  %644 = phi i64 [%637, %$97] ; # Args
  %645 = phi i1 [%638, %$97] ; # Notify
  %646 = phi i64 [%639, %$97] ; # Tos
  %647 = phi i64 [%640, %$97] ; # P
  %648 = phi i64 [%641, %$97] ; # Q
  %649 = phi i64 [%642, %$97] ; # Nm
  %650 = phi i64 [%643, %$97] ; # N
; # (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (- (val PipeBuf...
; # (val $TellBuf)
  %651 = load i8*, i8** @$TellBuf
; # (when (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10))) (tellEnd 0...
; # (val $Ptr)
  %652 = load i8*, i8** @$Ptr
; # (val PipeBufSize)
  %653 = load i32, i32* @PipeBufSize
; # (- (val PipeBufSize) 10)
  %654 = sub i32 %653, 10
; # (ofs P (- (val PipeBufSize) 10))
  %655 = getelementptr i8, i8* %651, i32 %654
; # (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10)))
  %656 = icmp uge i8* %652, %655
  br i1 %656, label %$100, label %$101
$100:
  %657 = phi i64 [%644, %$98] ; # Args
  %658 = phi i1 [%645, %$98] ; # Notify
  %659 = phi i64 [%646, %$98] ; # Tos
  %660 = phi i64 [%648, %$98] ; # Q
  %661 = phi i64 [%649, %$98] ; # Nm
  %662 = phi i64 [%650, %$98] ; # N
  %663 = phi i8* [%651, %$98] ; # P
; # (tellEnd 0)
  call void @tellEnd(i32 0)
; # (set (inc 'P 8) BEG $Ptr (inc P))
; # (inc 'P 8)
  %664 = getelementptr i8, i8* %663, i32 8
  store i8 1, i8* %664
; # (inc P)
  %665 = getelementptr i8, i8* %664, i32 1
  store i8* %665, i8** @$Ptr
; # (prTell Rpc)
  call void @prTell(i64 %15)
  br label %$101
$101:
  %666 = phi i64 [%644, %$98], [%657, %$100] ; # Args
  %667 = phi i1 [%645, %$98], [%658, %$100] ; # Notify
  %668 = phi i64 [%646, %$98], [%659, %$100] ; # Tos
  %669 = phi i64 [%648, %$98], [%660, %$100] ; # Q
  %670 = phi i64 [%649, %$98], [%661, %$100] ; # Nm
  %671 = phi i64 [%650, %$98], [%662, %$100] ; # N
  %672 = phi i8* [%651, %$98], [%664, %$100] ; # P
; # (prTell Sym)
  call void @prTell(i64 %374)
  br label %$99
$99:
  %673 = phi i64 [%637, %$97], [%666, %$101] ; # Args
  %674 = phi i1 [%638, %$97], [%667, %$101] ; # Notify
  %675 = phi i64 [%639, %$97], [%668, %$101] ; # Tos
  %676 = phi i64 [%640, %$97], [%647, %$101] ; # P
  %677 = phi i64 [%641, %$97], [%669, %$101] ; # Q
  %678 = phi i64 [%642, %$97], [%670, %$101] ; # Nm
  %679 = phi i64 [%643, %$97], [%671, %$101] ; # N
  br label %$85
$85:
  %680 = phi i64 [%497, %$76], [%673, %$99] ; # Args
  %681 = phi i1 [%498, %$76], [%674, %$99] ; # Notify
  %682 = phi i64 [%499, %$76], [%675, %$99] ; # Tos
  %683 = phi i64 [%500, %$76], [%676, %$99] ; # P
  %684 = phi i64 [%501, %$76], [%677, %$99] ; # Q
  %685 = phi i64 [%502, %$76], [%678, %$99] ; # Nm
  %686 = phi i64 [%503, %$76], [%679, %$99] ; # N
  br label %$75
$75:
  %687 = phi i64 [%490, %$79], [%680, %$85] ; # Args
  %688 = phi i1 [%491, %$79], [%681, %$85] ; # Notify
  %689 = phi i64 [%492, %$79], [%682, %$85] ; # Tos
  %690 = phi i64 [%493, %$79], [%683, %$85] ; # P
  %691 = phi i64 [%494, %$79], [%684, %$85] ; # Q
  %692 = phi i64 [%495, %$79], [%685, %$85] ; # Nm
  %693 = phi i64 [%496, %$79], [%686, %$85] ; # N
  br label %$74
$74:
  %694 = phi i64 [%411, %$69], [%687, %$75] ; # Args
  %695 = phi i1 [%412, %$69], [%688, %$75] ; # Notify
  %696 = phi i64 [%413, %$69], [%689, %$75] ; # Tos
  %697 = phi i64 [%414, %$69], [%690, %$75] ; # P
  %698 = phi i64 [%415, %$69], [%691, %$75] ; # Q
  %699 = phi i64 [%416, %$69], [%692, %$75] ; # Nm
  %700 = phi i64 [%419, %$69], [%693, %$75] ; # N
; # (let X (cdr P) (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos...
; # (cdr P)
  %701 = inttoptr i64 %697 to i64*
  %702 = getelementptr i64, i64* %701, i32 1
  %703 = load i64, i64* %702
; # (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos) (setq Tos (| ...
; # (cdr X)
  %704 = inttoptr i64 %703 to i64*
  %705 = getelementptr i64, i64* %704, i32 1
  %706 = load i64, i64* %705
; # (pair (cdr X))
  %707 = and i64 %706, 15
  %708 = icmp eq i64 %707, 0
  br i1 %708, label %$104, label %$102
$104:
  %709 = phi i64 [%694, %$74] ; # Args
  %710 = phi i1 [%695, %$74] ; # Notify
  %711 = phi i64 [%696, %$74] ; # Tos
  %712 = phi i64 [%697, %$74] ; # P
; # (let Y P (setq P @) (set 2 X Tos) (setq Tos (| Y 8)))
; # (set 2 X Tos)
  %713 = inttoptr i64 %703 to i64*
  %714 = getelementptr i64, i64* %713, i32 1
  store i64 %711, i64* %714
; # (| Y 8)
  %715 = or i64 %712, 8
  br label %$103
$102:
  %716 = phi i64 [%694, %$74] ; # Args
  %717 = phi i1 [%695, %$74] ; # Notify
  %718 = phi i64 [%696, %$74] ; # Tos
  %719 = phi i64 [%697, %$74] ; # P
; # (loop (unless Tos (goto 2)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$105
$105:
  %720 = phi i64 [%716, %$102], [%745, %$108] ; # Args
  %721 = phi i1 [%717, %$102], [%746, %$108] ; # Notify
  %722 = phi i64 [%718, %$102], [%755, %$108] ; # Tos
  %723 = phi i64 [%719, %$102], [%749, %$108] ; # P
; # (unless Tos (goto 2))
  %724 = icmp ne i64 %722, 0
  br i1 %724, label %$107, label %$106
$106:
  %725 = phi i64 [%720, %$105] ; # Args
  %726 = phi i1 [%721, %$105] ; # Notify
  %727 = phi i64 [%722, %$105] ; # Tos
  %728 = phi i64 [%723, %$105] ; # P
; # (goto 2)
  br label %$-2
$107:
  %729 = phi i64 [%720, %$105] ; # Args
  %730 = phi i1 [%721, %$105] ; # Notify
  %731 = phi i64 [%722, %$105] ; # Tos
  %732 = phi i64 [%723, %$105] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set ...
; # (& Tos 8)
  %733 = and i64 %731, 8
; # (=0 (& Tos 8))
  %734 = icmp eq i64 %733, 0
  br i1 %734, label %$110, label %$108
$110:
  %735 = phi i64 [%729, %$107] ; # Args
  %736 = phi i1 [%730, %$107] ; # Notify
  %737 = phi i64 [%731, %$107] ; # Tos
  %738 = phi i64 [%732, %$107] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %739 = inttoptr i64 %737 to i64*
  %740 = getelementptr i64, i64* %739, i32 1
  %741 = load i64, i64* %740
; # (car Y)
  %742 = inttoptr i64 %741 to i64*
  %743 = load i64, i64* %742
; # (set Y P)
  %744 = inttoptr i64 %741 to i64*
  store i64 %738, i64* %744
  br label %$109
$108:
  %745 = phi i64 [%729, %$107] ; # Args
  %746 = phi i1 [%730, %$107] ; # Notify
  %747 = phi i64 [%731, %$107] ; # Tos
  %748 = phi i64 [%732, %$107] ; # P
; # (& Tos -9)
  %749 = and i64 %747, -9
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %750 = inttoptr i64 %749 to i64*
  %751 = getelementptr i64, i64* %750, i32 1
  %752 = load i64, i64* %751
; # (cdr Y)
  %753 = inttoptr i64 %752 to i64*
  %754 = getelementptr i64, i64* %753, i32 1
  %755 = load i64, i64* %754
; # (set 2 Y P)
  %756 = inttoptr i64 %752 to i64*
  %757 = getelementptr i64, i64* %756, i32 1
  store i64 %748, i64* %757
  br label %$105
$109:
  %758 = phi i64 [%735, %$110] ; # Args
  %759 = phi i1 [%736, %$110] ; # Notify
  %760 = phi i64 [%743, %$110] ; # Tos
  %761 = phi i64 [%737, %$110] ; # P
  %762 = phi i64 [%737, %$110] ; # ->
  br label %$67
$103:
  %763 = phi i64 [%709, %$104] ; # Args
  %764 = phi i1 [%710, %$104] ; # Notify
  %765 = phi i64 [%715, %$104] ; # Tos
  %766 = phi i64 [%706, %$104] ; # P
  %767 = phi i64 [%715, %$104] ; # ->
  br label %$63
$111:
; # (: 2 (when Notify (tellEnd 0) (set $TellBuf (val $BufX) $Ptr (val...
  br label %$-2
$-2:
  %768 = phi i64 [%725, %$106], [%763, %$111] ; # Args
  %769 = phi i1 [%726, %$106], [%764, %$111] ; # Notify
; # (when Notify (tellEnd 0) (set $TellBuf (val $BufX) $Ptr (val $Ptr...
  br i1 %769, label %$112, label %$113
$112:
  %770 = phi i64 [%768, %$-2] ; # Args
  %771 = phi i1 [%769, %$-2] ; # Notify
; # (tellEnd 0)
  call void @tellEnd(i32 0)
; # (set $TellBuf (val $BufX) $Ptr (val $PtrX) $End (val $EndX))
; # (val $BufX)
  %772 = load i8*, i8** @$BufX
  store i8* %772, i8** @$TellBuf
; # (val $PtrX)
  %773 = load i8*, i8** @$PtrX
  store i8* %773, i8** @$Ptr
; # (val $EndX)
  %774 = load i8*, i8** @$EndX
  store i8* %774, i8** @$End
  br label %$113
$113:
  %775 = phi i64 [%768, %$-2], [%770, %$112] ; # Args
  %776 = phi i1 [%769, %$-2], [%771, %$112] ; # Notify
; # (car Args)
  %777 = inttoptr i64 %775 to i64*
  %778 = load i64, i64* %777
; # (eval (car Args))
  %779 = and i64 %778, 6
  %780 = icmp ne i64 %779, 0
  br i1 %780, label %$116, label %$115
$116:
  br label %$114
$115:
  %781 = and i64 %778, 8
  %782 = icmp ne i64 %781, 0
  br i1 %782, label %$118, label %$117
$118:
  %783 = inttoptr i64 %778 to i64*
  %784 = load i64, i64* %783
  br label %$114
$117:
  %785 = call i64 @evList(i64 %778)
  br label %$114
$114:
  %786 = phi i64 [%778, %$116], [%784, %$118], [%785, %$117] ; # ->
; # (when (val $DbJnl) (unLockJnl))
; # (val $DbJnl)
  %787 = load i8*, i8** @$DbJnl
  %788 = icmp ne i8* %787, null
  br i1 %788, label %$119, label %$120
$119:
  %789 = phi i64 [%775, %$114] ; # Args
  %790 = phi i1 [%776, %$114] ; # Notify
; # (unLockJnl)
  call void @unLockJnl()
  br label %$120
$120:
  %791 = phi i64 [%775, %$114], [%789, %$119] ; # Args
  %792 = phi i1 [%776, %$114], [%790, %$119] ; # Notify
; # (when (pair (val $Zap)) (let (Z @ Out (val $OutFile) Nm (xName Ex...
; # (val $Zap)
  %793 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 520) to i64) to i64*
  %794 = load i64, i64* %793
; # (pair (val $Zap))
  %795 = and i64 %794, 15
  %796 = icmp eq i64 %795, 0
  br i1 %796, label %$121, label %$122
$121:
  %797 = phi i64 [%791, %$120] ; # Args
  %798 = phi i1 [%792, %$120] ; # Notify
; # (let (Z @ Out (val $OutFile) Nm (xName Exe (cdr Z)) S (pathString...
; # (val $OutFile)
  %799 = load i8*, i8** @$OutFile
; # (cdr Z)
  %800 = inttoptr i64 %794 to i64*
  %801 = getelementptr i64, i64* %800, i32 1
  %802 = load i64, i64* %801
; # (xName Exe (cdr Z))
  %803 = call i64 @xName(i64 %0, i64 %802)
; # (pathSize Nm)
  %804 = call i64 @pathSize(i64 %803)
; # (b8 (pathSize Nm))
  %805 = alloca i8, i64 %804
; # (pathString Nm (b8 (pathSize Nm)))
  %806 = call i8* @pathString(i64 %803, i8* %805)
; # (b8 (outFile T))
  %807 = alloca i8, i64 4105
; # (when (lt0 (openWrAppend S)) (openErr Exe (cdr Z)))
; # (openWrAppend S)
  %808 = call i32 @openWrAppend(i8* %806)
; # (lt0 (openWrAppend S))
  %809 = icmp slt i32 %808, 0
  br i1 %809, label %$123, label %$124
$123:
  %810 = phi i64 [%797, %$121] ; # Args
  %811 = phi i1 [%798, %$121] ; # Notify
; # (cdr Z)
  %812 = inttoptr i64 %794 to i64*
  %813 = getelementptr i64, i64* %812, i32 1
  %814 = load i64, i64* %813
; # (openErr Exe (cdr Z))
  call void @openErr(i64 %0, i64 %814)
  unreachable
$124:
  %815 = phi i64 [%797, %$121] ; # Args
  %816 = phi i1 [%798, %$121] ; # Notify
; # (Out: fd @)
  %817 = bitcast i8* %807 to i32*
  store i32 %808, i32* %817
; # (Out: ix 0)
  %818 = getelementptr i8, i8* %807, i32 4
  %819 = bitcast i8* %818 to i32*
  store i32 0, i32* %819
; # (Out: tty NO)
  %820 = getelementptr i8, i8* %807, i32 4104
  %821 = bitcast i8* %820 to i1*
  store i1 0, i1* %821
; # (set $OutFile (Out:) $PutBin (fun (void i8) _putStdout) $Extn 0)
; # (Out:)
  store i8* %807, i8** @$OutFile
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$PutBin
  store i32 0, i32* @$Extn
; # (let Y (car Z) (while (pair Y) (binPrint (++ Y))) (flush (Out:)) ...
; # (car Z)
  %822 = inttoptr i64 %794 to i64*
  %823 = load i64, i64* %822
; # (while (pair Y) (binPrint (++ Y)))
  br label %$125
$125:
  %824 = phi i64 [%815, %$124], [%829, %$126] ; # Args
  %825 = phi i1 [%816, %$124], [%830, %$126] ; # Notify
  %826 = phi i64 [%823, %$124], [%835, %$126] ; # Y
; # (pair Y)
  %827 = and i64 %826, 15
  %828 = icmp eq i64 %827, 0
  br i1 %828, label %$126, label %$127
$126:
  %829 = phi i64 [%824, %$125] ; # Args
  %830 = phi i1 [%825, %$125] ; # Notify
  %831 = phi i64 [%826, %$125] ; # Y
; # (++ Y)
  %832 = inttoptr i64 %831 to i64*
  %833 = load i64, i64* %832
  %834 = getelementptr i64, i64* %832, i32 1
  %835 = load i64, i64* %834
; # (binPrint (++ Y))
  call void @binPrint(i64 %833)
  br label %$125
$127:
  %836 = phi i64 [%824, %$125] ; # Args
  %837 = phi i1 [%825, %$125] ; # Notify
  %838 = phi i64 [%826, %$125] ; # Y
; # (Out:)
; # (flush (Out:))
  %839 = call i1 @flush(i8* %807)
; # (Out: fd)
  %840 = bitcast i8* %807 to i32*
  %841 = load i32, i32* %840
; # (close (Out: fd))
  %842 = call i32 @close(i32 %841)
; # (set Z $Nil)
  %843 = inttoptr i64 %794 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %843
; # (set $OutFile Out)
  store i8* %799, i8** @$OutFile
  br label %$122
$122:
  %844 = phi i64 [%791, %$120], [%836, %$127] ; # Args
  %845 = phi i1 [%792, %$120], [%837, %$127] ; # Notify
; # (when (val $DbLog) (fsyncDB Exe) (truncLog Exe))
; # (val $DbLog)
  %846 = load i8*, i8** @$DbLog
  %847 = icmp ne i8* %846, null
  br i1 %847, label %$128, label %$129
$128:
  %848 = phi i64 [%844, %$122] ; # Args
  %849 = phi i1 [%845, %$122] ; # Notify
; # (fsyncDB Exe)
  call void @fsyncDB(i64 %0)
; # (truncLog Exe)
  call void @truncLog(i64 %0)
  br label %$129
$129:
  %850 = phi i64 [%844, %$122], [%848, %$128] ; # Args
  %851 = phi i1 [%845, %$122], [%849, %$128] ; # Notify
; # (unLockDb 0)
  call void @unLockDb(i64 0)
; # (unsync)
  call void @unsync()
; # (set $Protect (dec (val $Protect)))
; # (val $Protect)
  %852 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (dec (val $Protect))
  %853 = sub i32 %852, 1
  store i32 %853, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (let (P (val $DbFiles) C (val $DBs)) (loop ((dbFile P) flu -1) (?...
; # (val $DbFiles)
  %854 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %855 = load i32, i32* @$DBs
; # (loop ((dbFile P) flu -1) (? (=0 (dec 'C))) (setq P (ofs P (dbFil...
  br label %$130
$130:
  %856 = phi i64 [%850, %$129], [%864, %$131] ; # Args
  %857 = phi i1 [%851, %$129], [%865, %$131] ; # Notify
  %858 = phi i8* [%854, %$129], [%868, %$131] ; # P
  %859 = phi i32 [%855, %$129], [%867, %$131] ; # C
; # ((dbFile P) flu -1)
  %860 = getelementptr i8, i8* %858, i32 32
  %861 = bitcast i8* %860 to i64*
  store i64 -1, i64* %861
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %862 = sub i32 %859, 1
; # (=0 (dec 'C))
  %863 = icmp eq i32 %862, 0
  br i1 %863, label %$132, label %$131
$131:
  %864 = phi i64 [%856, %$130] ; # Args
  %865 = phi i1 [%857, %$130] ; # Notify
  %866 = phi i8* [%858, %$130] ; # P
  %867 = phi i32 [%862, %$130] ; # C
; # (ofs P (dbFile T))
  %868 = getelementptr i8, i8* %866, i32 42
  br label %$130
$132:
  %869 = phi i64 [%856, %$130] ; # Args
  %870 = phi i1 [%857, %$130] ; # Notify
  %871 = phi i8* [%858, %$130] ; # P
  %872 = phi i32 [%862, %$130] ; # C
  %873 = phi i64 [0, %$130] ; # ->
; # (drop *Safe)
  %874 = inttoptr i64 %19 to i64*
  %875 = getelementptr i64, i64* %874, i32 1
  %876 = load i64, i64* %875
  %877 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %876, i64* %877
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
}

define i64 @_mark(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (if (== Y ZERO) (let (Db (val ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (if (== Y ZERO) (let (Db (val $DbFiles) C (val $DBs)) (while (ge0...
; # (== Y ZERO)
  %16 = icmp eq i64 %15, 2
  br i1 %16, label %$7, label %$8
$7:
; # (let (Db (val $DbFiles) C (val $DBs)) (while (ge0 (dec 'C)) (let ...
; # (val $DbFiles)
  %17 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %18 = load i32, i32* @$DBs
; # (while (ge0 (dec 'C)) (let Db: (dbFile Db) (Db: mrks 0) (free (Db...
  br label %$10
$10:
  %19 = phi i8* [%17, %$7], [%32, %$11] ; # Db
  %20 = phi i32 [%18, %$7], [%24, %$11] ; # C
; # (dec 'C)
  %21 = sub i32 %20, 1
; # (ge0 (dec 'C))
  %22 = icmp sge i32 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  %23 = phi i8* [%19, %$10] ; # Db
  %24 = phi i32 [%21, %$10] ; # C
; # (let Db: (dbFile Db) (Db: mrks 0) (free (Db: mark)) (Db: mark nul...
; # (Db: mrks 0)
  %25 = getelementptr i8, i8* %23, i32 24
  %26 = bitcast i8* %25 to i64*
  store i64 0, i64* %26
; # (Db: mark)
  %27 = getelementptr i8, i8* %23, i32 16
  %28 = bitcast i8* %27 to i8**
  %29 = load i8*, i8** %28
; # (free (Db: mark))
  call void @free(i8* %29)
; # (Db: mark null)
  %30 = getelementptr i8, i8* %23, i32 16
  %31 = bitcast i8* %30 to i8**
  store i8* null, i8** %31
; # (ofs Db (dbFile T))
  %32 = getelementptr i8, i8* %23, i32 42
  br label %$10
$12:
  %33 = phi i8* [%19, %$10] ; # Db
  %34 = phi i32 [%21, %$10] ; # C
  br label %$9
$8:
; # (unless (sym? (val (tail (needSymb Exe Y)))) (extErr Exe Y))
; # (needSymb Exe Y)
  %35 = xor i64 %15, 8
  %36 = and i64 %35, 14
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %$14, label %$13
$13:
  call void @symErr(i64 %0, i64 %15)
  unreachable
$14:
; # (tail (needSymb Exe Y))
  %38 = add i64 %15, -8
; # (val (tail (needSymb Exe Y)))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (sym? (val (tail (needSymb Exe Y))))
  %41 = and i64 %40, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$16, label %$15
$15:
; # (extErr Exe Y)
  call void @extErr(i64 %0, i64 %15)
  unreachable
$16:
; # (let (Nm (name (& (val (tail Y)) -9)) F (objFile Nm) N (objId Nm)...
; # (tail Y)
  %43 = add i64 %15, -8
; # (val (tail Y))
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
; # (& (val (tail Y)) -9)
  %46 = and i64 %45, -9
; # (name (& (val (tail Y)) -9))
  br label %$17
$17:
  %47 = phi i64 [%46, %$16], [%53, %$18] ; # Tail
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$19, label %$18
$18:
  %50 = phi i64 [%47, %$17] ; # Tail
  %51 = inttoptr i64 %50 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  br label %$17
$19:
  %54 = phi i64 [%47, %$17] ; # Tail
; # (objFile Nm)
  %55 = call i32 @objFile(i64 %54)
; # (objId Nm)
  %56 = call i64 @objId(i64 %54)
; # (if (>= F (val $DBs)) $T (let (Flg (eval (car X)) Db: (dbFile (of...
; # (val $DBs)
  %57 = load i32, i32* @$DBs
; # (>= F (val $DBs))
  %58 = icmp sge i32 %55, %57
  br i1 %58, label %$20, label %$21
$20:
  %59 = phi i64 [%56, %$19] ; # N
  br label %$22
$21:
  %60 = phi i64 [%56, %$19] ; # N
; # (let (Flg (eval (car X)) Db: (dbFile (ofs (val $DbFiles) (* F (db...
; # (car X)
  %61 = inttoptr i64 %7 to i64*
  %62 = load i64, i64* %61
; # (eval (car X))
  %63 = and i64 %62, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$25, label %$24
$25:
  br label %$23
$24:
  %65 = and i64 %62, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$27, label %$26
$27:
  %67 = inttoptr i64 %62 to i64*
  %68 = load i64, i64* %67
  br label %$23
$26:
  %69 = call i64 @evList(i64 %62)
  br label %$23
$23:
  %70 = phi i64 [%62, %$25], [%68, %$27], [%69, %$26] ; # ->
; # (val $DbFiles)
  %71 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %72 = mul i32 %55, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %73 = getelementptr i8, i8* %71, i32 %72
; # (Db: mark)
  %74 = getelementptr i8, i8* %73, i32 16
  %75 = bitcast i8* %74 to i8**
  %76 = load i8*, i8** %75
; # (shr N 3)
  %77 = lshr i64 %60, 3
; # (when (>= I (Db: mrks)) (let J (inc I) (memset (ofs (setq P (Db: ...
; # (Db: mrks)
  %78 = getelementptr i8, i8* %73, i32 24
  %79 = bitcast i8* %78 to i64*
  %80 = load i64, i64* %79
; # (>= I (Db: mrks))
  %81 = icmp uge i64 %77, %80
  br i1 %81, label %$28, label %$29
$28:
  %82 = phi i64 [%60, %$23] ; # N
  %83 = phi i8* [%76, %$23] ; # P
; # (let J (inc I) (memset (ofs (setq P (Db: mark (alloc P J))) (Db: ...
; # (inc I)
  %84 = add i64 %77, 1
; # (Db: mark (alloc P J))
  %85 = getelementptr i8, i8* %73, i32 16
  %86 = bitcast i8* %85 to i8**
  %87 = call i8* @alloc(i8* %83, i64 %84)
  store i8* %87, i8** %86
; # (Db: mrks)
  %88 = getelementptr i8, i8* %73, i32 24
  %89 = bitcast i8* %88 to i64*
  %90 = load i64, i64* %89
; # (ofs (setq P (Db: mark (alloc P J))) (Db: mrks))
  %91 = getelementptr i8, i8* %87, i64 %90
; # (Db: mrks)
  %92 = getelementptr i8, i8* %73, i32 24
  %93 = bitcast i8* %92 to i64*
  %94 = load i64, i64* %93
; # (- J (Db: mrks))
  %95 = sub i64 %84, %94
; # (memset (ofs (setq P (Db: mark (alloc P J))) (Db: mrks)) 0 (- J (...
  call void @llvm.memset.p0i8.i64(i8* %91, i8 0, i64 %95, i1 0)
; # (Db: mrks J)
  %96 = getelementptr i8, i8* %73, i32 24
  %97 = bitcast i8* %96 to i64*
  store i64 %84, i64* %97
  br label %$29
$29:
  %98 = phi i64 [%60, %$23], [%82, %$28] ; # N
  %99 = phi i8* [%76, %$23], [%87, %$28] ; # P
; # (ofs P I)
  %100 = getelementptr i8, i8* %99, i64 %77
; # (& N 7)
  %101 = and i64 %98, 7
; # (shl 1 (& N 7))
  %102 = shl i64 1, %101
; # (i8 (shl 1 (& N 7)))
  %103 = trunc i64 %102 to i8
; # (let B (val P) (cond ((& B N) (when (== ZERO Flg) (set P (& B (x|...
; # (val P)
  %104 = load i8, i8* %100
; # (cond ((& B N) (when (== ZERO Flg) (set P (& B (x| N -1)))) $T) (...
; # (& B N)
  %105 = and i8 %104, %103
  %106 = icmp ne i8 %105, 0
  br i1 %106, label %$32, label %$31
$32:
  %107 = phi i8 [%103, %$29] ; # N
  %108 = phi i8* [%100, %$29] ; # P
; # (when (== ZERO Flg) (set P (& B (x| N -1))))
; # (== ZERO Flg)
  %109 = icmp eq i64 2, %70
  br i1 %109, label %$33, label %$34
$33:
  %110 = phi i8 [%107, %$32] ; # N
  %111 = phi i8* [%108, %$32] ; # P
; # (set P (& B (x| N -1)))
; # (x| N -1)
  %112 = xor i8 %110, -1
; # (& B (x| N -1))
  %113 = and i8 %104, %112
  store i8 %113, i8* %111
  br label %$34
$34:
  %114 = phi i8 [%107, %$32], [%110, %$33] ; # N
  %115 = phi i8* [%108, %$32], [%111, %$33] ; # P
  br label %$30
$31:
  %116 = phi i8 [%103, %$29] ; # N
  %117 = phi i8* [%100, %$29] ; # P
; # (when (== $T Flg) (set P (| B N)))
; # (== $T Flg)
  %118 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %70
  br i1 %118, label %$35, label %$36
$35:
  %119 = phi i8 [%116, %$31] ; # N
  %120 = phi i8* [%117, %$31] ; # P
; # (set P (| B N))
; # (| B N)
  %121 = or i8 %104, %119
  store i8 %121, i8* %120
  br label %$36
$36:
  %122 = phi i8 [%116, %$31], [%119, %$35] ; # N
  %123 = phi i8* [%117, %$31], [%120, %$35] ; # P
  br label %$30
$30:
  %124 = phi i8 [%114, %$34], [%122, %$36] ; # N
  %125 = phi i8* [%115, %$34], [%123, %$36] ; # P
  %126 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$34], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$36] ; # ->
  br label %$22
$22:
  %127 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$20], [%126, %$30] ; # ->
  br label %$9
$9:
  %128 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%127, %$22] ; # ->
  ret i64 %128
}

define i64 @_free(i64) align 8 {
$1:
; # (let (X (cdr Exe) F (dec (i32 (evCnt Exe X))) Buf (b8 (* BLK 2)))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (i32 (evCnt Exe X))
  %5 = trunc i64 %4 to i32
; # (dec (i32 (evCnt Exe X)))
  %6 = sub i32 %5, 1
; # (* BLK 2)
; # (b8 (* BLK 2))
  %7 = alloca i8, i64 12
; # (when (>= F (val $DBs)) (dbfErr Exe))
; # (val $DBs)
  %8 = load i32, i32* @$DBs
; # (>= F (val $DBs))
  %9 = icmp sge i32 %6, %8
  br i1 %9, label %$2, label %$3
$2:
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$3:
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %10 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %11 = mul i32 %6, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %12 = getelementptr i8, i8* %10, i32 %11
  store i8* %12, i8** @$DbFile
; # (rdLockDb)
  call void @rdLockDb()
; # (* 2 BLK)
; # (blkPeek 0 Buf (* 2 BLK))
  call void @blkPeek(i64 0, i8* %7, i32 12)
; # (set $BlkLink (getAdr Buf))
; # (getAdr Buf)
  %13 = call i64 @getAdr(i8* %7)
  store i64 %13, i64* @$BlkLink
; # (let (Y (cons (extern (extNm F (shr (getAdr (ofs Buf BLK)) 6))) $...
; # (ofs Buf BLK)
  %14 = getelementptr i8, i8* %7, i32 6
; # (getAdr (ofs Buf BLK))
  %15 = call i64 @getAdr(i8* %14)
; # (shr (getAdr (ofs Buf BLK)) 6)
  %16 = lshr i64 %15, 6
; # (extNm F (shr (getAdr (ofs Buf BLK)) 6))
  %17 = call i64 @extNm(i32 %6, i64 %16)
; # (extern (extNm F (shr (getAdr (ofs Buf BLK)) 6)))
  %18 = call i64 @extern(i64 %17)
; # (cons (extern (extNm F (shr (getAdr (ofs Buf BLK)) 6))) $Nil)
  %19 = call i64 @cons(i64 %18, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = alloca i64, i64 2, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = add i64 %23, 8
  %26 = inttoptr i64 %25 to i64*
  store i64 %21, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %27
; # (while (val $BlkLink) (setq Y (set 2 Y (cons (extern (extNm F (sh...
  br label %$4
$4:
  %28 = phi i64 [%19, %$3], [%35, %$5] ; # Y
; # (val $BlkLink)
  %29 = load i64, i64* @$BlkLink
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$5, label %$6
$5:
  %31 = phi i64 [%28, %$4] ; # Y
; # (set 2 Y (cons (extern (extNm F (shr @ 6))) $Nil))
; # (shr @ 6)
  %32 = lshr i64 %29, 6
; # (extNm F (shr @ 6))
  %33 = call i64 @extNm(i32 %6, i64 %32)
; # (extern (extNm F (shr @ 6)))
  %34 = call i64 @extern(i64 %33)
; # (cons (extern (extNm F (shr @ 6))) $Nil)
  %35 = call i64 @cons(i64 %34, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
; # (rdBlock @)
  %38 = call i8* @rdBlock(i64 %29)
  br label %$4
$6:
  %39 = phi i64 [%28, %$4] ; # Y
; # (unLockDb 1)
  call void @unLockDb(i64 1)
; # (drop *Safe)
  %40 = inttoptr i64 %23 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %43
  ret i64 %19
}

define i64 @_dbck(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X)) Jnl (val $DbJnl) Buf (b8 (* BL...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (val $DbJnl)
  %14 = load i8*, i8** @$DbJnl
; # (* BLK 2)
; # (b8 (* BLK 2))
  %15 = alloca i8, i64 12
; # (if (cnt? Y) (let F (dec (i32 (int Y))) (when (>= F (val $DBs)) (...
; # (cnt? Y)
  %16 = and i64 %13, 2
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  %18 = phi i64 [%13, %$2] ; # Y
  %19 = phi i64 [64, %$2] ; # Cnt
  %20 = phi i64 [0, %$2] ; # Syms
  %21 = phi i64 [0, %$2] ; # Blks
; # (let F (dec (i32 (int Y))) (when (>= F (val $DBs)) (dbfErr Exe)) ...
; # (int Y)
  %22 = lshr i64 %18, 4
; # (i32 (int Y))
  %23 = trunc i64 %22 to i32
; # (dec (i32 (int Y)))
  %24 = sub i32 %23, 1
; # (when (>= F (val $DBs)) (dbfErr Exe))
; # (val $DBs)
  %25 = load i32, i32* @$DBs
; # (>= F (val $DBs))
  %26 = icmp sge i32 %24, %25
  br i1 %26, label %$10, label %$11
$10:
  %27 = phi i64 [%18, %$7] ; # Y
  %28 = phi i64 [%19, %$7] ; # Cnt
  %29 = phi i64 [%20, %$7] ; # Syms
  %30 = phi i64 [%21, %$7] ; # Blks
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$11:
  %31 = phi i64 [%18, %$7] ; # Y
  %32 = phi i64 [%19, %$7] ; # Cnt
  %33 = phi i64 [%20, %$7] ; # Syms
  %34 = phi i64 [%21, %$7] ; # Blks
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %35 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %36 = mul i32 %24, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %37 = getelementptr i8, i8* %35, i32 %36
  store i8* %37, i8** @$DbFile
; # (cadr X)
  %38 = inttoptr i64 %3 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
; # (eval (cadr X))
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$14, label %$13
$14:
  br label %$12
$13:
  %45 = and i64 %42, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$16, label %$15
$16:
  %47 = inttoptr i64 %42 to i64*
  %48 = load i64, i64* %47
  br label %$12
$15:
  %49 = call i64 @evList(i64 %42)
  br label %$12
$12:
  %50 = phi i64 [%42, %$14], [%48, %$16], [%49, %$15] ; # ->
  br label %$9
$8:
  %51 = phi i64 [%13, %$2] ; # Y
  %52 = phi i64 [64, %$2] ; # Cnt
  %53 = phi i64 [0, %$2] ; # Syms
  %54 = phi i64 [0, %$2] ; # Blks
; # (set $DbFile (val $DbFiles))
; # (val $DbFiles)
  %55 = load i8*, i8** @$DbFiles
  store i8* %55, i8** @$DbFile
  br label %$9
$9:
  %56 = phi i64 [%50, %$12], [%51, %$8] ; # Y
  %57 = phi i64 [%32, %$12], [%52, %$8] ; # Cnt
  %58 = phi i64 [%33, %$12], [%53, %$8] ; # Syms
  %59 = phi i64 [%34, %$12], [%54, %$8] ; # Blks
; # (set $Protect (inc (val $Protect)))
; # (val $Protect)
  %60 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (inc (val $Protect))
  %61 = add i32 %60, 1
  store i32 %61, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (wrLockDb)
  call void @wrLockDb()
; # (when Jnl (lockJnl) (set $DbJnl null))
  %62 = icmp ne i8* %14, null
  br i1 %62, label %$17, label %$18
$17:
  %63 = phi i64 [%56, %$9] ; # Y
  %64 = phi i64 [%57, %$9] ; # Cnt
  %65 = phi i64 [%58, %$9] ; # Syms
  %66 = phi i64 [%59, %$9] ; # Blks
; # (lockJnl)
  call void @lockJnl()
; # (set $DbJnl null)
  store i8* null, i8** @$DbJnl
  br label %$18
$18:
  %67 = phi i64 [%56, %$9], [%63, %$17] ; # Y
  %68 = phi i64 [%57, %$9], [%64, %$17] ; # Cnt
  %69 = phi i64 [%58, %$9], [%65, %$17] ; # Syms
  %70 = phi i64 [%59, %$9], [%66, %$17] ; # Blks
; # (* 2 BLK)
; # (blkPeek 0 Buf (* 2 BLK))
  call void @blkPeek(i64 0, i8* %15, i32 12)
; # (set $BlkLink (getAdr Buf))
; # (getAdr Buf)
  %71 = call i64 @getAdr(i8* %15)
  store i64 %71, i64* @$BlkLink
; # (let Next (getAdr (ofs Buf BLK)) (while (val $BlkLink) (let Blk (...
; # (ofs Buf BLK)
  %72 = getelementptr i8, i8* %15, i32 6
; # (getAdr (ofs Buf BLK))
  %73 = call i64 @getAdr(i8* %72)
; # (while (val $BlkLink) (let Blk (rdBlock @) (set Blk (| (val Blk) ...
  br label %$19
$19:
  %74 = phi i64 [%67, %$18], [%94, %$23] ; # Y
  %75 = phi i64 [%68, %$18], [%95, %$23] ; # Cnt
  %76 = phi i64 [%69, %$18], [%96, %$23] ; # Syms
  %77 = phi i64 [%70, %$18], [%97, %$23] ; # Blks
; # (val $BlkLink)
  %78 = load i64, i64* @$BlkLink
  %79 = icmp ne i64 %78, 0
  br i1 %79, label %$20, label %$21
$20:
  %80 = phi i64 [%74, %$19] ; # Y
  %81 = phi i64 [%75, %$19] ; # Cnt
  %82 = phi i64 [%76, %$19] ; # Syms
  %83 = phi i64 [%77, %$19] ; # Blks
; # (let Blk (rdBlock @) (set Blk (| (val Blk) BLKTAG)))
; # (rdBlock @)
  %84 = call i8* @rdBlock(i64 %78)
; # (set Blk (| (val Blk) BLKTAG))
; # (val Blk)
  %85 = load i8, i8* %84
; # (| (val Blk) BLKTAG)
  %86 = or i8 %85, 63
  store i8 %86, i8* %84
; # (when (> (inc 'Cnt BLKSIZE) Next) (setq Y (mkStr ($ "Circular fre...
; # (inc 'Cnt BLKSIZE)
  %87 = add i64 %81, 64
; # (> (inc 'Cnt BLKSIZE) Next)
  %88 = icmp ugt i64 %87, %73
  br i1 %88, label %$22, label %$23
$22:
  %89 = phi i64 [%80, %$20] ; # Y
  %90 = phi i64 [%87, %$20] ; # Cnt
  %91 = phi i64 [%82, %$20] ; # Syms
  %92 = phi i64 [%83, %$20] ; # Blks
; # (mkStr ($ "Circular free list"))
  %93 = call i64 @mkStr(i8* bitcast ([19 x i8]* @$65 to i8*))
; # (goto 9)
  br label %$-9
$23:
  %94 = phi i64 [%80, %$20] ; # Y
  %95 = phi i64 [%87, %$20] ; # Cnt
  %96 = phi i64 [%82, %$20] ; # Syms
  %97 = phi i64 [%83, %$20] ; # Blks
; # (wrBlock)
  call void @wrBlock()
  br label %$19
$21:
  %98 = phi i64 [%74, %$19] ; # Y
  %99 = phi i64 [%75, %$19] ; # Cnt
  %100 = phi i64 [%76, %$19] ; # Syms
  %101 = phi i64 [%77, %$19] ; # Blks
; # (set $DbJnl Jnl)
  store i8* %14, i8** @$DbJnl
; # (let P BLKSIZE (until (== P Next) (let Blk (rdBlock P) (case (& (...
; # (until (== P Next) (let Blk (rdBlock P) (case (& (val Blk) BLKTAG...
  br label %$24
$24:
  %102 = phi i64 [%98, %$21], [%182, %$27] ; # Y
  %103 = phi i64 [%99, %$21], [%183, %$27] ; # Cnt
  %104 = phi i64 [%100, %$21], [%184, %$27] ; # Syms
  %105 = phi i64 [%101, %$21], [%185, %$27] ; # Blks
  %106 = phi i64 [64, %$21], [%187, %$27] ; # P
; # (== P Next)
  %107 = icmp eq i64 %106, %73
  br i1 %107, label %$26, label %$25
$25:
  %108 = phi i64 [%102, %$24] ; # Y
  %109 = phi i64 [%103, %$24] ; # Cnt
  %110 = phi i64 [%104, %$24] ; # Syms
  %111 = phi i64 [%105, %$24] ; # Blks
  %112 = phi i64 [%106, %$24] ; # P
; # (let Blk (rdBlock P) (case (& (val Blk) BLKTAG) (0 (inc 'Cnt BLKS...
; # (rdBlock P)
  %113 = call i8* @rdBlock(i64 %112)
; # (case (& (val Blk) BLKTAG) (0 (inc 'Cnt BLKSIZE) (memcpy Blk Buf ...
; # (val Blk)
  %114 = load i8, i8* %113
; # (& (val Blk) BLKTAG)
  %115 = and i8 %114, 63
  switch i8 %115, label %$27 [
    i8 0, label %$28
    i8 1, label %$29
  ]
$28:
  %116 = phi i64 [%108, %$25] ; # Y
  %117 = phi i64 [%109, %$25] ; # Cnt
  %118 = phi i64 [%110, %$25] ; # Syms
  %119 = phi i64 [%111, %$25] ; # Blks
  %120 = phi i64 [%112, %$25] ; # P
; # (inc 'Cnt BLKSIZE)
  %121 = add i64 %117, 64
; # (memcpy Blk Buf BLK T)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %113, i8* %15, i64 6, i1 0)
; # (wrBlock)
  call void @wrBlock()
; # (setAdr P Buf)
  call void @setAdr(i64 %120, i8* %15)
; # (blkPoke 0 Buf BLK)
  call void @blkPoke(i64 0, i8* %15, i32 6)
  br label %$27
$29:
  %122 = phi i64 [%108, %$25] ; # Y
  %123 = phi i64 [%109, %$25] ; # Cnt
  %124 = phi i64 [%110, %$25] ; # Syms
  %125 = phi i64 [%111, %$25] ; # Blks
  %126 = phi i64 [%112, %$25] ; # P
; # (inc 'Syms)
  %127 = add i64 %124, 1
; # (let I (i8 2) (loop (inc 'Blks) (inc 'Cnt BLKSIZE) (? (=0 (val $B...
; # (i8 2)
; # (loop (inc 'Blks) (inc 'Cnt BLKSIZE) (? (=0 (val $BlkLink))) (unl...
  br label %$30
$30:
  %128 = phi i64 [%122, %$29], [%169, %$36] ; # Y
  %129 = phi i64 [%123, %$29], [%170, %$36] ; # Cnt
  %130 = phi i64 [%127, %$29], [%171, %$36] ; # Syms
  %131 = phi i64 [%125, %$29], [%172, %$36] ; # Blks
  %132 = phi i64 [%126, %$29], [%173, %$36] ; # P
  %133 = phi i8 [2, %$29], [%174, %$36] ; # I
; # (inc 'Blks)
  %134 = add i64 %131, 1
; # (inc 'Cnt BLKSIZE)
  %135 = add i64 %129, 64
; # (? (=0 (val $BlkLink)))
; # (val $BlkLink)
  %136 = load i64, i64* @$BlkLink
; # (=0 (val $BlkLink))
  %137 = icmp eq i64 %136, 0
  br i1 %137, label %$32, label %$31
$31:
  %138 = phi i64 [%128, %$30] ; # Y
  %139 = phi i64 [%135, %$30] ; # Cnt
  %140 = phi i64 [%130, %$30] ; # Syms
  %141 = phi i64 [%134, %$30] ; # Blks
  %142 = phi i64 [%132, %$30] ; # P
  %143 = phi i8 [%133, %$30] ; # I
; # (unless (== I (& (val (rdBlock @)) BLKTAG)) (setq Y (mkStr ($ "Ba...
; # (rdBlock @)
  %144 = call i8* @rdBlock(i64 %136)
; # (val (rdBlock @))
  %145 = load i8, i8* %144
; # (& (val (rdBlock @)) BLKTAG)
  %146 = and i8 %145, 63
; # (== I (& (val (rdBlock @)) BLKTAG))
  %147 = icmp eq i8 %143, %146
  br i1 %147, label %$34, label %$33
$33:
  %148 = phi i64 [%138, %$31] ; # Y
  %149 = phi i64 [%139, %$31] ; # Cnt
  %150 = phi i64 [%140, %$31] ; # Syms
  %151 = phi i64 [%141, %$31] ; # Blks
  %152 = phi i64 [%142, %$31] ; # P
  %153 = phi i8 [%143, %$31] ; # I
; # (mkStr ($ "Bad chain"))
  %154 = call i64 @mkStr(i8* bitcast ([10 x i8]* @$66 to i8*))
; # (goto 9)
  br label %$-9
$34:
  %155 = phi i64 [%138, %$31] ; # Y
  %156 = phi i64 [%139, %$31] ; # Cnt
  %157 = phi i64 [%140, %$31] ; # Syms
  %158 = phi i64 [%141, %$31] ; # Blks
  %159 = phi i64 [%142, %$31] ; # P
  %160 = phi i8 [%143, %$31] ; # I
; # (when (> BLKTAG I) (inc 'I))
; # (> BLKTAG I)
  %161 = icmp ugt i8 63, %160
  br i1 %161, label %$35, label %$36
$35:
  %162 = phi i64 [%155, %$34] ; # Y
  %163 = phi i64 [%156, %$34] ; # Cnt
  %164 = phi i64 [%157, %$34] ; # Syms
  %165 = phi i64 [%158, %$34] ; # Blks
  %166 = phi i64 [%159, %$34] ; # P
  %167 = phi i8 [%160, %$34] ; # I
; # (inc 'I)
  %168 = add i8 %167, 1
  br label %$36
$36:
  %169 = phi i64 [%155, %$34], [%162, %$35] ; # Y
  %170 = phi i64 [%156, %$34], [%163, %$35] ; # Cnt
  %171 = phi i64 [%157, %$34], [%164, %$35] ; # Syms
  %172 = phi i64 [%158, %$34], [%165, %$35] ; # Blks
  %173 = phi i64 [%159, %$34], [%166, %$35] ; # P
  %174 = phi i8 [%160, %$34], [%168, %$35] ; # I
  br label %$30
$32:
  %175 = phi i64 [%128, %$30] ; # Y
  %176 = phi i64 [%135, %$30] ; # Cnt
  %177 = phi i64 [%130, %$30] ; # Syms
  %178 = phi i64 [%134, %$30] ; # Blks
  %179 = phi i64 [%132, %$30] ; # P
  %180 = phi i8 [%133, %$30] ; # I
  %181 = phi i64 [0, %$30] ; # ->
  br label %$27
$27:
  %182 = phi i64 [%108, %$25], [%116, %$28], [%175, %$32] ; # Y
  %183 = phi i64 [%109, %$25], [%121, %$28], [%176, %$32] ; # Cnt
  %184 = phi i64 [%110, %$25], [%118, %$28], [%177, %$32] ; # Syms
  %185 = phi i64 [%111, %$25], [%119, %$28], [%178, %$32] ; # Blks
  %186 = phi i64 [%112, %$25], [%120, %$28], [%179, %$32] ; # P
; # (inc 'P BLKSIZE)
  %187 = add i64 %186, 64
  br label %$24
$26:
  %188 = phi i64 [%102, %$24] ; # Y
  %189 = phi i64 [%103, %$24] ; # Cnt
  %190 = phi i64 [%104, %$24] ; # Syms
  %191 = phi i64 [%105, %$24] ; # Blks
  %192 = phi i64 [%106, %$24] ; # P
; # (set $BlkLink (getAdr Buf))
; # (getAdr Buf)
  %193 = call i64 @getAdr(i8* %15)
  store i64 %193, i64* @$BlkLink
; # (set $DbJnl null)
  store i8* null, i8** @$DbJnl
; # (while (val $BlkLink) (let Blk (rdBlock @) (when (& (val Blk) BLK...
  br label %$37
$37:
  %194 = phi i64 [%188, %$26], [%214, %$41] ; # Y
  %195 = phi i64 [%189, %$26], [%215, %$41] ; # Cnt
  %196 = phi i64 [%190, %$26], [%216, %$41] ; # Syms
  %197 = phi i64 [%191, %$26], [%217, %$41] ; # Blks
; # (val $BlkLink)
  %198 = load i64, i64* @$BlkLink
  %199 = icmp ne i64 %198, 0
  br i1 %199, label %$38, label %$39
$38:
  %200 = phi i64 [%194, %$37] ; # Y
  %201 = phi i64 [%195, %$37] ; # Cnt
  %202 = phi i64 [%196, %$37] ; # Syms
  %203 = phi i64 [%197, %$37] ; # Blks
; # (let Blk (rdBlock @) (when (& (val Blk) BLKTAG) (set Blk (& (val ...
; # (rdBlock @)
  %204 = call i8* @rdBlock(i64 %198)
; # (when (& (val Blk) BLKTAG) (set Blk (& (val Blk) BLKMASK)) (wrBlo...
; # (val Blk)
  %205 = load i8, i8* %204
; # (& (val Blk) BLKTAG)
  %206 = and i8 %205, 63
  %207 = icmp ne i8 %206, 0
  br i1 %207, label %$40, label %$41
$40:
  %208 = phi i64 [%200, %$38] ; # Y
  %209 = phi i64 [%201, %$38] ; # Cnt
  %210 = phi i64 [%202, %$38] ; # Syms
  %211 = phi i64 [%203, %$38] ; # Blks
; # (set Blk (& (val Blk) BLKMASK))
; # (val Blk)
  %212 = load i8, i8* %204
; # (& (val Blk) BLKMASK)
  %213 = and i8 %212, -64
  store i8 %213, i8* %204
; # (wrBlock)
  call void @wrBlock()
  br label %$41
$41:
  %214 = phi i64 [%200, %$38], [%208, %$40] ; # Y
  %215 = phi i64 [%201, %$38], [%209, %$40] ; # Cnt
  %216 = phi i64 [%202, %$38], [%210, %$40] ; # Syms
  %217 = phi i64 [%203, %$38], [%211, %$40] ; # Blks
  br label %$37
$39:
  %218 = phi i64 [%194, %$37] ; # Y
  %219 = phi i64 [%195, %$37] ; # Cnt
  %220 = phi i64 [%196, %$37] ; # Syms
  %221 = phi i64 [%197, %$37] ; # Blks
; # (nond ((== Cnt Next) (setq Y (mkStr ($ "Bad count")))) ((nil? Y) ...
; # (== Cnt Next)
  %222 = icmp eq i64 %219, %73
  br i1 %222, label %$43, label %$44
$44:
  %223 = phi i64 [%218, %$39] ; # Y
  %224 = phi i64 [%219, %$39] ; # Cnt
  %225 = phi i64 [%220, %$39] ; # Syms
  %226 = phi i64 [%221, %$39] ; # Blks
; # (mkStr ($ "Bad count"))
  %227 = call i64 @mkStr(i8* bitcast ([10 x i8]* @$67 to i8*))
  br label %$42
$43:
  %228 = phi i64 [%218, %$39] ; # Y
  %229 = phi i64 [%219, %$39] ; # Cnt
  %230 = phi i64 [%220, %$39] ; # Syms
  %231 = phi i64 [%221, %$39] ; # Blks
; # (nil? Y)
  %232 = icmp eq i64 %228, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %232, label %$45, label %$46
$46:
  %233 = phi i64 [%228, %$43] ; # Y
  %234 = phi i64 [%229, %$43] ; # Cnt
  %235 = phi i64 [%230, %$43] ; # Syms
  %236 = phi i64 [%231, %$43] ; # Blks
; # (cnt Blks)
  %237 = shl i64 %236, 4
  %238 = or i64 %237, 2
; # (cnt Syms)
  %239 = shl i64 %235, 4
  %240 = or i64 %239, 2
; # (cons (cnt Blks) (cnt Syms))
  %241 = call i64 @cons(i64 %238, i64 %240)
  br label %$42
$45:
  %242 = phi i64 [%228, %$43] ; # Y
  %243 = phi i64 [%229, %$43] ; # Cnt
  %244 = phi i64 [%230, %$43] ; # Syms
  %245 = phi i64 [%231, %$43] ; # Blks
  br label %$42
$42:
  %246 = phi i64 [%227, %$44], [%241, %$46], [%242, %$45] ; # Y
  %247 = phi i64 [%224, %$44], [%234, %$46], [%243, %$45] ; # Cnt
  %248 = phi i64 [%225, %$44], [%235, %$46], [%244, %$45] ; # Syms
  %249 = phi i64 [%226, %$44], [%236, %$46], [%245, %$45] ; # Blks
  %250 = phi i64 [%227, %$44], [%241, %$46], [0, %$45] ; # ->
; # (: 9 (when (set $DbJnl Jnl) (unLockJnl)) (unLockDb 1) (set $Prote...
  br label %$-9
$-9:
  %251 = phi i64 [%93, %$22], [%154, %$33], [%246, %$42] ; # Y
  %252 = phi i64 [%90, %$22], [%149, %$33], [%247, %$42] ; # Cnt
  %253 = phi i64 [%91, %$22], [%150, %$33], [%248, %$42] ; # Syms
  %254 = phi i64 [%92, %$22], [%151, %$33], [%249, %$42] ; # Blks
; # (when (set $DbJnl Jnl) (unLockJnl))
; # (set $DbJnl Jnl)
  store i8* %14, i8** @$DbJnl
  %255 = icmp ne i8* %14, null
  br i1 %255, label %$47, label %$48
$47:
  %256 = phi i64 [%251, %$-9] ; # Y
  %257 = phi i64 [%252, %$-9] ; # Cnt
  %258 = phi i64 [%253, %$-9] ; # Syms
  %259 = phi i64 [%254, %$-9] ; # Blks
; # (unLockJnl)
  call void @unLockJnl()
  br label %$48
$48:
  %260 = phi i64 [%251, %$-9], [%256, %$47] ; # Y
  %261 = phi i64 [%252, %$-9], [%257, %$47] ; # Cnt
  %262 = phi i64 [%253, %$-9], [%258, %$47] ; # Syms
  %263 = phi i64 [%254, %$-9], [%259, %$47] ; # Blks
; # (unLockDb 1)
  call void @unLockDb(i64 1)
; # (set $Protect (dec (val $Protect)))
; # (val $Protect)
  %264 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
; # (dec (val $Protect))
  %265 = sub i32 %264, 1
  store i32 %265, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 128) to i32*)
  ret i64 %260
}

define i64 @_apply(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL)) (set ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %24 = add i64 %17, 24
; # (link (ofs E 3) T)
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
  %30 = inttoptr i64 %17 to i64*
  store i64 %24, i64* %30
; # (let (L (save (eval (car X))) P E) (while (pair (shift X)) (setq ...
; # (car X)
  %31 = inttoptr i64 %7 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$9, label %$8
$9:
  br label %$7
$8:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$11, label %$10
$11:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$7
$10:
  %39 = call i64 @evList(i64 %32)
  br label %$7
$7:
  %40 = phi i64 [%32, %$9], [%38, %$11], [%39, %$10] ; # ->
; # (save (eval (car X)))
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %42 = load i64, i64* %41
  %43 = alloca i64, i64 2, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %40, i64* %45
  %46 = add i64 %44, 8
  %47 = inttoptr i64 %46 to i64*
  store i64 %42, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %48
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$12
$12:
  %49 = phi i64 [%7, %$7], [%57, %$15] ; # X
  %50 = phi i64 [%40, %$7], [%58, %$15] ; # L
  %51 = phi i64 [%17, %$7], [%71, %$15] ; # P
; # (shift X)
  %52 = inttoptr i64 %49 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (pair (shift X))
  %55 = and i64 %54, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%54, %$12] ; # X
  %58 = phi i64 [%50, %$12] ; # L
  %59 = phi i64 [%51, %$12] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %60 = inttoptr i64 %57 to i64*
  %61 = load i64, i64* %60
; # (eval (car X))
  %62 = and i64 %61, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$17, label %$16
$17:
  br label %$15
$16:
  %64 = and i64 %61, 8
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$19, label %$18
$19:
  %66 = inttoptr i64 %61 to i64*
  %67 = load i64, i64* %66
  br label %$15
$18:
  %68 = call i64 @evList(i64 %61)
  br label %$15
$15:
  %69 = phi i64 [%61, %$17], [%67, %$19], [%68, %$18] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %70 = alloca i64, i64 5, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = add i64 %71, 8
  %73 = inttoptr i64 %72 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %73
  %74 = add i64 %71, 16
  %75 = inttoptr i64 %74 to i64*
  store i64 2, i64* %75
  %76 = add i64 %71, 24
  %77 = inttoptr i64 %76 to i64*
  store i64 %69, i64* %77
  %78 = inttoptr i64 %59 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %71, i64* %79
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %80 = add i64 %71, 24
; # (link (ofs P 3))
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %82 = load i64, i64* %81
  %83 = inttoptr i64 %80 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %82, i64* %84
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %85
  %86 = inttoptr i64 %71 to i64*
  store i64 %80, i64* %86
  br label %$12
$14:
  %87 = phi i64 [%54, %$12] ; # X
  %88 = phi i64 [%50, %$12] ; # L
  %89 = phi i64 [%51, %$12] ; # P
; # (while (pair L) (stkChk Exe) (setq P (set 2 P (push NIL $Nil ZERO...
  br label %$20
$20:
  %90 = phi i64 [%87, %$14], [%95, %$24] ; # X
  %91 = phi i64 [%88, %$14], [%104, %$24] ; # L
  %92 = phi i64 [%89, %$14], [%106, %$24] ; # P
; # (pair L)
  %93 = and i64 %91, 15
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %$21, label %$22
$21:
  %95 = phi i64 [%90, %$20] ; # X
  %96 = phi i64 [%91, %$20] ; # L
  %97 = phi i64 [%92, %$20] ; # P
; # (stkChk Exe)
  %98 = load i8*, i8** @$StkLimit
  %99 = call i8* @llvm.stacksave()
  %100 = icmp ugt i8* %98, %99
  br i1 %100, label %$23, label %$24
$23:
  call void @stkErr(i64 %0)
  unreachable
$24:
; # (set 2 P (push NIL $Nil ZERO (++ L) NIL))
; # (++ L)
  %101 = inttoptr i64 %96 to i64*
  %102 = load i64, i64* %101
  %103 = getelementptr i64, i64* %101, i32 1
  %104 = load i64, i64* %103
; # (push NIL $Nil ZERO (++ L) NIL)
  %105 = alloca i64, i64 5, align 16
  %106 = ptrtoint i64* %105 to i64
  %107 = add i64 %106, 8
  %108 = inttoptr i64 %107 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %108
  %109 = add i64 %106, 16
  %110 = inttoptr i64 %109 to i64*
  store i64 2, i64* %110
  %111 = add i64 %106, 24
  %112 = inttoptr i64 %111 to i64*
  store i64 %102, i64* %112
  %113 = inttoptr i64 %97 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  store i64 %106, i64* %114
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %115 = add i64 %106, 24
; # (link (ofs P 3))
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %117 = load i64, i64* %116
  %118 = inttoptr i64 %115 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  store i64 %117, i64* %119
  %120 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %115, i64* %120
  %121 = inttoptr i64 %106 to i64*
  store i64 %115, i64* %121
  br label %$20
$22:
  %122 = phi i64 [%90, %$20] ; # X
  %123 = phi i64 [%91, %$20] ; # L
  %124 = phi i64 [%92, %$20] ; # P
; # (evList E)
  %125 = call i64 @evList(i64 %17)
; # (drop *Safe)
  %126 = inttoptr i64 %24 to i64*
  %127 = getelementptr i64, i64* %126, i32 1
  %128 = load i64, i64* %127
  %129 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %128, i64* %129
  ret i64 %125
}

define i64 @_pass(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL)) (set ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %24 = add i64 %17, 24
; # (link (ofs E 3) T)
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
  %30 = inttoptr i64 %17 to i64*
  store i64 %24, i64* %30
; # (let P E (while (pair X) (setq P (set 2 P (push NIL $Nil ZERO (ev...
; # (while (pair X) (setq P (set 2 P (push NIL $Nil ZERO (eval (++ X)...
  br label %$7
$7:
  %31 = phi i64 [%7, %$2], [%40, %$10] ; # X
  %32 = phi i64 [%17, %$2], [%50, %$10] ; # P
; # (pair X)
  %33 = and i64 %31, 15
  %34 = icmp eq i64 %33, 0
  br i1 %34, label %$8, label %$9
$8:
  %35 = phi i64 [%31, %$7] ; # X
  %36 = phi i64 [%32, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (++ X)) NIL))
; # (++ X)
  %37 = inttoptr i64 %35 to i64*
  %38 = load i64, i64* %37
  %39 = getelementptr i64, i64* %37, i32 1
  %40 = load i64, i64* %39
; # (eval (++ X))
  %41 = and i64 %38, 6
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$12, label %$11
$12:
  br label %$10
$11:
  %43 = and i64 %38, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$14, label %$13
$14:
  %45 = inttoptr i64 %38 to i64*
  %46 = load i64, i64* %45
  br label %$10
$13:
  %47 = call i64 @evList(i64 %38)
  br label %$10
$10:
  %48 = phi i64 [%38, %$12], [%46, %$14], [%47, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %49 = alloca i64, i64 5, align 16
  %50 = ptrtoint i64* %49 to i64
  %51 = add i64 %50, 8
  %52 = inttoptr i64 %51 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %52
  %53 = add i64 %50, 16
  %54 = inttoptr i64 %53 to i64*
  store i64 2, i64* %54
  %55 = add i64 %50, 24
  %56 = inttoptr i64 %55 to i64*
  store i64 %48, i64* %56
  %57 = inttoptr i64 %36 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %50, i64* %58
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %59 = add i64 %50, 24
; # (link (ofs P 3))
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %61 = load i64, i64* %60
  %62 = inttoptr i64 %59 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 %61, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %64
  %65 = inttoptr i64 %50 to i64*
  store i64 %59, i64* %65
  br label %$7
$9:
  %66 = phi i64 [%31, %$7] ; # X
  %67 = phi i64 [%32, %$7] ; # P
; # (let L (val $Next) (while (pair L) (setq P (set 2 P (push NIL $Ni...
; # (val $Next)
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %69 = load i64, i64* %68
; # (while (pair L) (setq P (set 2 P (push NIL $Nil ZERO (cdr L) NIL)...
  br label %$15
$15:
  %70 = phi i64 [%66, %$9], [%75, %$16] ; # X
  %71 = phi i64 [%67, %$9], [%82, %$16] ; # P
  %72 = phi i64 [%69, %$9], [%99, %$16] ; # L
; # (pair L)
  %73 = and i64 %72, 15
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %$16, label %$17
$16:
  %75 = phi i64 [%70, %$15] ; # X
  %76 = phi i64 [%71, %$15] ; # P
  %77 = phi i64 [%72, %$15] ; # L
; # (set 2 P (push NIL $Nil ZERO (cdr L) NIL))
; # (cdr L)
  %78 = inttoptr i64 %77 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  %80 = load i64, i64* %79
; # (push NIL $Nil ZERO (cdr L) NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %76 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (car L)
  %98 = inttoptr i64 %77 to i64*
  %99 = load i64, i64* %98
  br label %$15
$17:
  %100 = phi i64 [%70, %$15] ; # X
  %101 = phi i64 [%71, %$15] ; # P
  %102 = phi i64 [%72, %$15] ; # L
; # (evList E)
  %103 = call i64 @evList(i64 %17)
; # (drop *Safe)
  %104 = inttoptr i64 %24 to i64*
  %105 = getelementptr i64, i64* %104, i32 1
  %106 = load i64, i64* %105
  %107 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %106, i64* %107
  ret i64 %103
}

define i64 @_fun(i64) align 8 {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evList (cdr Exe))
  %4 = call i64 @evList(i64 %3)
  ret i64 %4
}

define i64 @_maps(i64) align 8 {
$1:
; # (let (X (cdr Exe) R $Nil E (push NIL $Nil ZERO (eval (++ X)) NIL)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A Sym (save (needSymb Exe (eval (car X)))) V Sym) (se...
; # (car X)
  %33 = inttoptr i64 %7 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$9, label %$8
$9:
  br label %$7
$8:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$11, label %$10
$11:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$7
$10:
  %41 = call i64 @evList(i64 %34)
  br label %$7
$7:
  %42 = phi i64 [%34, %$9], [%40, %$11], [%41, %$10] ; # ->
; # (needSymb Exe (eval (car X)))
  %43 = xor i64 %42, 8
  %44 = and i64 %43, 14
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$13, label %$12
$12:
  call void @symErr(i64 %0, i64 %42)
  unreachable
$13:
; # (save (needSymb Exe (eval (car X))))
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %47 = load i64, i64* %46
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %42, i64* %50
  %51 = add i64 %49, 8
  %52 = inttoptr i64 %51 to i64*
  store i64 %47, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %53
; # (set Q V)
  %54 = inttoptr i64 %25 to i64*
  store i64 %42, i64* %54
; # (loop (setq P (set 2 P (push NIL $Nil ZERO V NIL))) (set P (link ...
  br label %$14
$14:
  %55 = phi i64 [%7, %$13], [%119, %$23] ; # X
  %56 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%120, %$23] ; # R
  %57 = phi i64 [%17, %$13], [%121, %$23] ; # P
  %58 = phi i64 [%25, %$13], [%122, %$23] ; # Q
  %59 = phi i64 [%42, %$13], [%123, %$23] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %60 = alloca i64, i64 5, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = add i64 %61, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
  %64 = add i64 %61, 16
  %65 = inttoptr i64 %64 to i64*
  store i64 2, i64* %65
  %66 = add i64 %61, 24
  %67 = inttoptr i64 %66 to i64*
  store i64 %59, i64* %67
  %68 = inttoptr i64 %57 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %61, i64* %69
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %70 = add i64 %61, 24
; # (link (ofs P 3))
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %75
  %76 = inttoptr i64 %61 to i64*
  store i64 %70, i64* %76
; # (? (atom (shift X)))
; # (shift X)
  %77 = inttoptr i64 %55 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  %79 = load i64, i64* %78
; # (atom (shift X))
  %80 = and i64 %79, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$16, label %$15
$15:
  %82 = phi i64 [%79, %$14] ; # X
  %83 = phi i64 [%56, %$14] ; # R
  %84 = phi i64 [%61, %$14] ; # P
  %85 = phi i64 [%58, %$14] ; # Q
  %86 = phi i64 [%59, %$14] ; # V
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %87 = alloca i64, i64 2, align 16
  %88 = ptrtoint i64* %87 to i64
  %89 = inttoptr i64 %85 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %88, i64* %90
; # (car X)
  %91 = inttoptr i64 %82 to i64*
  %92 = load i64, i64* %91
; # (eval (car X))
  %93 = and i64 %92, 6
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$19, label %$18
$19:
  br label %$17
$18:
  %95 = and i64 %92, 8
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$21, label %$20
$21:
  %97 = inttoptr i64 %92 to i64*
  %98 = load i64, i64* %97
  br label %$17
$20:
  %99 = call i64 @evList(i64 %92)
  br label %$17
$17:
  %100 = phi i64 [%92, %$19], [%98, %$21], [%99, %$20] ; # ->
; # (save (eval (car X)))
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %102 = load i64, i64* %101
  %103 = alloca i64, i64 2, align 16
  %104 = ptrtoint i64* %103 to i64
  %105 = inttoptr i64 %104 to i64*
  store i64 %100, i64* %105
  %106 = add i64 %104, 8
  %107 = inttoptr i64 %106 to i64*
  store i64 %102, i64* %107
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %104, i64* %108
; # (set Q V)
  %109 = inttoptr i64 %88 to i64*
  store i64 %100, i64* %109
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %110 = and i64 %100, 15
  %111 = icmp eq i64 %110, 0
  br i1 %111, label %$22, label %$23
$22:
  %112 = phi i64 [%82, %$17] ; # X
  %113 = phi i64 [%83, %$17] ; # R
  %114 = phi i64 [%84, %$17] ; # P
  %115 = phi i64 [%88, %$17] ; # Q
  %116 = phi i64 [%100, %$17] ; # V
; # (car V)
  %117 = inttoptr i64 %116 to i64*
  %118 = load i64, i64* %117
  br label %$23
$23:
  %119 = phi i64 [%82, %$17], [%112, %$22] ; # X
  %120 = phi i64 [%83, %$17], [%113, %$22] ; # R
  %121 = phi i64 [%84, %$17], [%114, %$22] ; # P
  %122 = phi i64 [%88, %$17], [%115, %$22] ; # Q
  %123 = phi i64 [%100, %$17], [%118, %$22] ; # V
  br label %$14
$16:
  %124 = phi i64 [%79, %$14] ; # X
  %125 = phi i64 [%56, %$14] ; # R
  %126 = phi i64 [%61, %$14] ; # P
  %127 = phi i64 [%58, %$14] ; # Q
  %128 = phi i64 [%59, %$14] ; # V
  %129 = phi i64 [0, %$14] ; # ->
; # (when (sym? (setq V (val (tail Sym)))) (dbFetch Exe Sym) (setq V ...
; # (tail Sym)
  %130 = add i64 %42, -8
; # (val (tail Sym))
  %131 = inttoptr i64 %130 to i64*
  %132 = load i64, i64* %131
; # (sym? (setq V (val (tail Sym))))
  %133 = and i64 %132, 8
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$24, label %$25
$24:
  %135 = phi i64 [%124, %$16] ; # X
  %136 = phi i64 [%125, %$16] ; # R
  %137 = phi i64 [%126, %$16] ; # P
  %138 = phi i64 [%127, %$16] ; # Q
  %139 = phi i64 [%132, %$16] ; # V
; # (dbFetch Exe Sym)
  call void @dbFetch(i64 %0, i64 %42)
; # (tail Sym)
  %140 = add i64 %42, -8
; # (val (tail Sym))
  %141 = inttoptr i64 %140 to i64*
  %142 = load i64, i64* %141
; # (& (val (tail Sym)) -9)
  %143 = and i64 %142, -9
  br label %$25
$25:
  %144 = phi i64 [%124, %$16], [%135, %$24] ; # X
  %145 = phi i64 [%125, %$16], [%136, %$24] ; # R
  %146 = phi i64 [%126, %$16], [%137, %$24] ; # P
  %147 = phi i64 [%127, %$16], [%138, %$24] ; # Q
  %148 = phi i64 [%132, %$16], [%143, %$24] ; # V
; # (set 4 (cdr E) (if (pair V) (car V) V))
; # (cdr E)
  %149 = inttoptr i64 %17 to i64*
  %150 = getelementptr i64, i64* %149, i32 1
  %151 = load i64, i64* %150
; # (if (pair V) (car V) V)
; # (pair V)
  %152 = and i64 %148, 15
  %153 = icmp eq i64 %152, 0
  br i1 %153, label %$26, label %$27
$26:
  %154 = phi i64 [%144, %$25] ; # X
  %155 = phi i64 [%145, %$25] ; # R
  %156 = phi i64 [%146, %$25] ; # P
  %157 = phi i64 [%147, %$25] ; # Q
  %158 = phi i64 [%148, %$25] ; # V
; # (car V)
  %159 = inttoptr i64 %158 to i64*
  %160 = load i64, i64* %159
  br label %$28
$27:
  %161 = phi i64 [%144, %$25] ; # X
  %162 = phi i64 [%145, %$25] ; # R
  %163 = phi i64 [%146, %$25] ; # P
  %164 = phi i64 [%147, %$25] ; # Q
  %165 = phi i64 [%148, %$25] ; # V
  br label %$28
$28:
  %166 = phi i64 [%154, %$26], [%161, %$27] ; # X
  %167 = phi i64 [%155, %$26], [%162, %$27] ; # R
  %168 = phi i64 [%156, %$26], [%163, %$27] ; # P
  %169 = phi i64 [%157, %$26], [%164, %$27] ; # Q
  %170 = phi i64 [%158, %$26], [%165, %$27] ; # V
  %171 = phi i64 [%160, %$26], [%165, %$27] ; # ->
  %172 = inttoptr i64 %151 to i64*
  %173 = getelementptr i64, i64* %172, i32 3
  store i64 %171, i64* %173
; # (set A V)
  %174 = inttoptr i64 %25 to i64*
  store i64 %170, i64* %174
; # (when (pair (car A)) (loop (setq R (evList E)) (? (atom (set A (c...
; # (car A)
  %175 = inttoptr i64 %25 to i64*
  %176 = load i64, i64* %175
; # (pair (car A))
  %177 = and i64 %176, 15
  %178 = icmp eq i64 %177, 0
  br i1 %178, label %$29, label %$30
$29:
  %179 = phi i64 [%166, %$28] ; # X
  %180 = phi i64 [%167, %$28] ; # R
; # (loop (setq R (evList E)) (? (atom (set A (cdar A)))) (let (P (cd...
  br label %$31
$31:
  %181 = phi i64 [%179, %$29], [%252, %$36] ; # X
  %182 = phi i64 [%180, %$29], [%253, %$36] ; # R
; # (evList E)
  %183 = call i64 @evList(i64 %17)
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %184 = inttoptr i64 %25 to i64*
  %185 = load i64, i64* %184
  %186 = inttoptr i64 %185 to i64*
  %187 = getelementptr i64, i64* %186, i32 1
  %188 = load i64, i64* %187
  %189 = inttoptr i64 %25 to i64*
  store i64 %188, i64* %189
; # (atom (set A (cdar A)))
  %190 = and i64 %188, 15
  %191 = icmp ne i64 %190, 0
  br i1 %191, label %$33, label %$32
$32:
  %192 = phi i64 [%181, %$31] ; # X
  %193 = phi i64 [%183, %$31] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %194 = inttoptr i64 %17 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
; # (set 4 P (car @))
; # (car @)
  %197 = inttoptr i64 %188 to i64*
  %198 = load i64, i64* %197
  %199 = inttoptr i64 %196 to i64*
  %200 = getelementptr i64, i64* %199, i32 3
  store i64 %198, i64* %200
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$34
$34:
  %201 = phi i64 [%192, %$32], [%245, %$37] ; # X
  %202 = phi i64 [%193, %$32], [%246, %$37] ; # R
  %203 = phi i64 [%196, %$32], [%247, %$37] ; # P
  %204 = phi i64 [%25, %$32], [%248, %$37] ; # Q
; # (shift P)
  %205 = inttoptr i64 %203 to i64*
  %206 = getelementptr i64, i64* %205, i32 1
  %207 = load i64, i64* %206
; # (pair (shift P))
  %208 = and i64 %207, 15
  %209 = icmp eq i64 %208, 0
  br i1 %209, label %$35, label %$36
$35:
  %210 = phi i64 [%201, %$34] ; # X
  %211 = phi i64 [%202, %$34] ; # R
  %212 = phi i64 [%207, %$34] ; # P
  %213 = phi i64 [%204, %$34] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %214 = inttoptr i64 %213 to i64*
  %215 = getelementptr i64, i64* %214, i32 1
  %216 = load i64, i64* %215
; # (car (shift Q))
  %217 = inttoptr i64 %216 to i64*
  %218 = load i64, i64* %217
; # (atom (car (shift Q)))
  %219 = and i64 %218, 15
  %220 = icmp ne i64 %219, 0
  br i1 %220, label %$39, label %$38
$39:
  %221 = phi i64 [%210, %$35] ; # X
  %222 = phi i64 [%211, %$35] ; # R
  %223 = phi i64 [%212, %$35] ; # P
  %224 = phi i64 [%216, %$35] ; # Q
  br label %$37
$38:
  %225 = phi i64 [%210, %$35] ; # X
  %226 = phi i64 [%211, %$35] ; # R
  %227 = phi i64 [%212, %$35] ; # P
  %228 = phi i64 [%216, %$35] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %229 = inttoptr i64 %218 to i64*
  %230 = getelementptr i64, i64* %229, i32 1
  %231 = load i64, i64* %230
  %232 = inttoptr i64 %228 to i64*
  store i64 %231, i64* %232
; # (atom (set Q (cdr @)))
  %233 = and i64 %231, 15
  %234 = icmp ne i64 %233, 0
  br i1 %234, label %$41, label %$40
$41:
  %235 = phi i64 [%225, %$38] ; # X
  %236 = phi i64 [%226, %$38] ; # R
  %237 = phi i64 [%227, %$38] ; # P
  %238 = phi i64 [%228, %$38] ; # Q
  br label %$37
$40:
  %239 = phi i64 [%225, %$38] ; # X
  %240 = phi i64 [%226, %$38] ; # R
  %241 = phi i64 [%227, %$38] ; # P
  %242 = phi i64 [%228, %$38] ; # Q
; # (car @)
  %243 = inttoptr i64 %231 to i64*
  %244 = load i64, i64* %243
  br label %$37
$37:
  %245 = phi i64 [%221, %$39], [%235, %$41], [%239, %$40] ; # X
  %246 = phi i64 [%222, %$39], [%236, %$41], [%240, %$40] ; # R
  %247 = phi i64 [%223, %$39], [%237, %$41], [%241, %$40] ; # P
  %248 = phi i64 [%224, %$39], [%238, %$41], [%242, %$40] ; # Q
  %249 = phi i64 [%218, %$39], [%231, %$41], [%244, %$40] ; # ->
  %250 = inttoptr i64 %212 to i64*
  %251 = getelementptr i64, i64* %250, i32 3
  store i64 %249, i64* %251
  br label %$34
$36:
  %252 = phi i64 [%201, %$34] ; # X
  %253 = phi i64 [%202, %$34] ; # R
  %254 = phi i64 [%207, %$34] ; # P
  %255 = phi i64 [%204, %$34] ; # Q
  br label %$31
$33:
  %256 = phi i64 [%181, %$31] ; # X
  %257 = phi i64 [%183, %$31] ; # R
  %258 = phi i64 [0, %$31] ; # ->
  br label %$30
$30:
  %259 = phi i64 [%166, %$28], [%256, %$33] ; # X
  %260 = phi i64 [%167, %$28], [%257, %$33] ; # R
; # (drop *Safe)
  %261 = inttoptr i64 %26 to i64*
  %262 = getelementptr i64, i64* %261, i32 1
  %263 = load i64, i64* %262
  %264 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %263, i64* %264
  ret i64 %260
}

define i64 @_map(i64) align 8 {
$1:
; # (let (X (cdr Exe) R $Nil E (push NIL $Nil ZERO (eval (car X)) NIL...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %14 = alloca i64, i64 5, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = add i64 %15, 8
  %17 = inttoptr i64 %16 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %17
  %18 = add i64 %15, 16
  %19 = inttoptr i64 %18 to i64*
  store i64 2, i64* %19
  %20 = add i64 %15, 24
  %21 = inttoptr i64 %20 to i64*
  store i64 %13, i64* %21
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %22 = add i64 %15, 24
; # (link (ofs E 3) T)
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %22 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 %15 to i64*
  store i64 %22, i64* %28
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %29 = phi i64 [%3, %$2], [%37, %$10] ; # X
  %30 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%38, %$10] ; # R
  %31 = phi i64 [%15, %$2], [%51, %$10] ; # P
; # (shift X)
  %32 = inttoptr i64 %29 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (pair (shift X))
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$8, label %$9
$8:
  %37 = phi i64 [%34, %$7] ; # X
  %38 = phi i64 [%30, %$7] ; # R
  %39 = phi i64 [%31, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %40 = inttoptr i64 %37 to i64*
  %41 = load i64, i64* %40
; # (eval (car X))
  %42 = and i64 %41, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$12, label %$11
$12:
  br label %$10
$11:
  %44 = and i64 %41, 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$14, label %$13
$14:
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
  br label %$10
$13:
  %48 = call i64 @evList(i64 %41)
  br label %$10
$10:
  %49 = phi i64 [%41, %$12], [%47, %$14], [%48, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %50 = alloca i64, i64 5, align 16
  %51 = ptrtoint i64* %50 to i64
  %52 = add i64 %51, 8
  %53 = inttoptr i64 %52 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %53
  %54 = add i64 %51, 16
  %55 = inttoptr i64 %54 to i64*
  store i64 2, i64* %55
  %56 = add i64 %51, 24
  %57 = inttoptr i64 %56 to i64*
  store i64 %49, i64* %57
  %58 = inttoptr i64 %39 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %51, i64* %59
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %60 = add i64 %51, 24
; # (link (ofs P 3))
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %62 = load i64, i64* %61
  %63 = inttoptr i64 %60 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  store i64 %62, i64* %64
  %65 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %65
  %66 = inttoptr i64 %51 to i64*
  store i64 %60, i64* %66
  br label %$7
$9:
  %67 = phi i64 [%34, %$7] ; # X
  %68 = phi i64 [%30, %$7] ; # R
  %69 = phi i64 [%31, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P))) (setq R (evList E)) (lo...
  br label %$15
$15:
  %70 = phi i64 [%67, %$9], [%111, %$22] ; # X
  %71 = phi i64 [%68, %$9], [%112, %$22] ; # R
; # (let P (cdr E) (? (atom (val 4 P))) (setq R (evList E)) (loop (wh...
; # (cdr E)
  %72 = inttoptr i64 %15 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (? (atom (val 4 P)))
; # (val 4 P)
  %75 = inttoptr i64 %74 to i64*
  %76 = getelementptr i64, i64* %75, i32 3
  %77 = load i64, i64* %76
; # (atom (val 4 P))
  %78 = and i64 %77, 15
  %79 = icmp ne i64 %78, 0
  br i1 %79, label %$17, label %$16
$16:
  %80 = phi i64 [%70, %$15] ; # X
  %81 = phi i64 [%71, %$15] ; # R
  %82 = phi i64 [%74, %$15] ; # P
; # (evList E)
  %83 = call i64 @evList(i64 %15)
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$18
$18:
  %84 = phi i64 [%80, %$16], [%108, %$21] ; # X
  %85 = phi i64 [%83, %$16], [%109, %$21] ; # R
  %86 = phi i64 [%82, %$16], [%110, %$21] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 3
  %89 = load i64, i64* %88
; # (pair (val 4 P))
  %90 = and i64 %89, 15
  %91 = icmp eq i64 %90, 0
  br i1 %91, label %$19, label %$20
$19:
  %92 = phi i64 [%84, %$18] ; # X
  %93 = phi i64 [%85, %$18] ; # R
  %94 = phi i64 [%86, %$18] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %95 = inttoptr i64 %89 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
  %98 = inttoptr i64 %94 to i64*
  %99 = getelementptr i64, i64* %98, i32 3
  store i64 %97, i64* %99
  br label %$20
$20:
  %100 = phi i64 [%84, %$18], [%92, %$19] ; # X
  %101 = phi i64 [%85, %$18], [%93, %$19] ; # R
  %102 = phi i64 [%86, %$18], [%94, %$19] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
; # (atom (shift P))
  %106 = and i64 %105, 15
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$22, label %$21
$21:
  %108 = phi i64 [%100, %$20] ; # X
  %109 = phi i64 [%101, %$20] ; # R
  %110 = phi i64 [%105, %$20] ; # P
  br label %$18
$22:
  %111 = phi i64 [%100, %$20] ; # X
  %112 = phi i64 [%101, %$20] ; # R
  %113 = phi i64 [%105, %$20] ; # P
  %114 = phi i64 [0, %$20] ; # ->
  br label %$15
$17:
  %115 = phi i64 [%70, %$15] ; # X
  %116 = phi i64 [%71, %$15] ; # R
  %117 = phi i64 [0, %$15] ; # ->
; # (drop *Safe)
  %118 = inttoptr i64 %22 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %120, i64* %121
  ret i64 %116
}

define i64 @_mapc(i64) align 8 {
$1:
; # (let (X (cdr Exe) R $Nil E (push NIL $Nil ZERO (eval (++ X)) NIL)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%92, %$15] ; # X
  %34 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%93, %$15] ; # R
  %35 = phi i64 [%17, %$2], [%94, %$15] ; # P
  %36 = phi i64 [%25, %$2], [%97, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %37 = inttoptr i64 %33 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$10, label %$9
$10:
  br label %$8
$9:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$12, label %$11
$12:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$8
$11:
  %45 = call i64 @evList(i64 %38)
  br label %$8
$8:
  %46 = phi i64 [%38, %$10], [%44, %$12], [%45, %$11] ; # ->
; # (save (eval (car X)))
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %48 = load i64, i64* %47
  %49 = alloca i64, i64 2, align 16
  %50 = ptrtoint i64* %49 to i64
  %51 = inttoptr i64 %50 to i64*
  store i64 %46, i64* %51
  %52 = add i64 %50, 8
  %53 = inttoptr i64 %52 to i64*
  store i64 %48, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %50, i64* %54
  %55 = inttoptr i64 %36 to i64*
  store i64 %46, i64* %55
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %56 = and i64 %46, 15
  %57 = icmp eq i64 %56, 0
  br i1 %57, label %$13, label %$14
$13:
  %58 = phi i64 [%33, %$8] ; # X
  %59 = phi i64 [%34, %$8] ; # R
  %60 = phi i64 [%35, %$8] ; # P
  %61 = phi i64 [%36, %$8] ; # Q
  %62 = phi i64 [%46, %$8] ; # V
; # (car V)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  br label %$14
$14:
  %65 = phi i64 [%33, %$8], [%58, %$13] ; # X
  %66 = phi i64 [%34, %$8], [%59, %$13] ; # R
  %67 = phi i64 [%35, %$8], [%60, %$13] ; # P
  %68 = phi i64 [%36, %$8], [%61, %$13] ; # Q
  %69 = phi i64 [%46, %$8], [%64, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %70 = alloca i64, i64 5, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = add i64 %71, 8
  %73 = inttoptr i64 %72 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %73
  %74 = add i64 %71, 16
  %75 = inttoptr i64 %74 to i64*
  store i64 2, i64* %75
  %76 = add i64 %71, 24
  %77 = inttoptr i64 %76 to i64*
  store i64 %69, i64* %77
  %78 = inttoptr i64 %67 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %71, i64* %79
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %80 = add i64 %71, 24
; # (link (ofs P 3))
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %82 = load i64, i64* %81
  %83 = inttoptr i64 %80 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %82, i64* %84
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %85
  %86 = inttoptr i64 %71 to i64*
  store i64 %80, i64* %86
; # (? (atom (shift X)))
; # (shift X)
  %87 = inttoptr i64 %65 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
; # (atom (shift X))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$16, label %$15
$15:
  %92 = phi i64 [%89, %$14] ; # X
  %93 = phi i64 [%66, %$14] ; # R
  %94 = phi i64 [%71, %$14] ; # P
  %95 = phi i64 [%68, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %96 = alloca i64, i64 2, align 16
  %97 = ptrtoint i64* %96 to i64
  %98 = inttoptr i64 %95 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  store i64 %97, i64* %99
  br label %$7
$16:
  %100 = phi i64 [%89, %$14] ; # X
  %101 = phi i64 [%66, %$14] ; # R
  %102 = phi i64 [%71, %$14] ; # P
  %103 = phi i64 [%68, %$14] ; # Q
  %104 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (setq R (evList E)) (? (atom (set A (c...
; # (car A)
  %105 = inttoptr i64 %25 to i64*
  %106 = load i64, i64* %105
; # (pair (car A))
  %107 = and i64 %106, 15
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %$17, label %$18
$17:
  %109 = phi i64 [%100, %$16] ; # X
  %110 = phi i64 [%101, %$16] ; # R
; # (loop (setq R (evList E)) (? (atom (set A (cdar A)))) (let (P (cd...
  br label %$19
$19:
  %111 = phi i64 [%109, %$17], [%182, %$24] ; # X
  %112 = phi i64 [%110, %$17], [%183, %$24] ; # R
; # (evList E)
  %113 = call i64 @evList(i64 %17)
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %114 = inttoptr i64 %25 to i64*
  %115 = load i64, i64* %114
  %116 = inttoptr i64 %115 to i64*
  %117 = getelementptr i64, i64* %116, i32 1
  %118 = load i64, i64* %117
  %119 = inttoptr i64 %25 to i64*
  store i64 %118, i64* %119
; # (atom (set A (cdar A)))
  %120 = and i64 %118, 15
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$21, label %$20
$20:
  %122 = phi i64 [%111, %$19] ; # X
  %123 = phi i64 [%113, %$19] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %124 = inttoptr i64 %17 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
; # (set 4 P (car @))
; # (car @)
  %127 = inttoptr i64 %118 to i64*
  %128 = load i64, i64* %127
  %129 = inttoptr i64 %126 to i64*
  %130 = getelementptr i64, i64* %129, i32 3
  store i64 %128, i64* %130
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$22
$22:
  %131 = phi i64 [%122, %$20], [%175, %$25] ; # X
  %132 = phi i64 [%123, %$20], [%176, %$25] ; # R
  %133 = phi i64 [%126, %$20], [%177, %$25] ; # P
  %134 = phi i64 [%25, %$20], [%178, %$25] ; # Q
; # (shift P)
  %135 = inttoptr i64 %133 to i64*
  %136 = getelementptr i64, i64* %135, i32 1
  %137 = load i64, i64* %136
; # (pair (shift P))
  %138 = and i64 %137, 15
  %139 = icmp eq i64 %138, 0
  br i1 %139, label %$23, label %$24
$23:
  %140 = phi i64 [%131, %$22] ; # X
  %141 = phi i64 [%132, %$22] ; # R
  %142 = phi i64 [%137, %$22] ; # P
  %143 = phi i64 [%134, %$22] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (car (shift Q))
  %147 = inttoptr i64 %146 to i64*
  %148 = load i64, i64* %147
; # (atom (car (shift Q)))
  %149 = and i64 %148, 15
  %150 = icmp ne i64 %149, 0
  br i1 %150, label %$27, label %$26
$27:
  %151 = phi i64 [%140, %$23] ; # X
  %152 = phi i64 [%141, %$23] ; # R
  %153 = phi i64 [%142, %$23] ; # P
  %154 = phi i64 [%146, %$23] ; # Q
  br label %$25
$26:
  %155 = phi i64 [%140, %$23] ; # X
  %156 = phi i64 [%141, %$23] ; # R
  %157 = phi i64 [%142, %$23] ; # P
  %158 = phi i64 [%146, %$23] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %159 = inttoptr i64 %148 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  %161 = load i64, i64* %160
  %162 = inttoptr i64 %158 to i64*
  store i64 %161, i64* %162
; # (atom (set Q (cdr @)))
  %163 = and i64 %161, 15
  %164 = icmp ne i64 %163, 0
  br i1 %164, label %$29, label %$28
$29:
  %165 = phi i64 [%155, %$26] ; # X
  %166 = phi i64 [%156, %$26] ; # R
  %167 = phi i64 [%157, %$26] ; # P
  %168 = phi i64 [%158, %$26] ; # Q
  br label %$25
$28:
  %169 = phi i64 [%155, %$26] ; # X
  %170 = phi i64 [%156, %$26] ; # R
  %171 = phi i64 [%157, %$26] ; # P
  %172 = phi i64 [%158, %$26] ; # Q
; # (car @)
  %173 = inttoptr i64 %161 to i64*
  %174 = load i64, i64* %173
  br label %$25
$25:
  %175 = phi i64 [%151, %$27], [%165, %$29], [%169, %$28] ; # X
  %176 = phi i64 [%152, %$27], [%166, %$29], [%170, %$28] ; # R
  %177 = phi i64 [%153, %$27], [%167, %$29], [%171, %$28] ; # P
  %178 = phi i64 [%154, %$27], [%168, %$29], [%172, %$28] ; # Q
  %179 = phi i64 [%148, %$27], [%161, %$29], [%174, %$28] ; # ->
  %180 = inttoptr i64 %142 to i64*
  %181 = getelementptr i64, i64* %180, i32 3
  store i64 %179, i64* %181
  br label %$22
$24:
  %182 = phi i64 [%131, %$22] ; # X
  %183 = phi i64 [%132, %$22] ; # R
  %184 = phi i64 [%137, %$22] ; # P
  %185 = phi i64 [%134, %$22] ; # Q
  br label %$19
$21:
  %186 = phi i64 [%111, %$19] ; # X
  %187 = phi i64 [%113, %$19] ; # R
  %188 = phi i64 [0, %$19] ; # ->
  br label %$18
$18:
  %189 = phi i64 [%100, %$16], [%186, %$21] ; # X
  %190 = phi i64 [%101, %$16], [%187, %$21] ; # R
; # (drop *Safe)
  %191 = inttoptr i64 %26 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
  %194 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %193, i64* %194
  ret i64 %190
}

define i64 @_maplist(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (car X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
; # (eval (car X))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$4, label %$3
$4:
  br label %$2
$3:
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$6, label %$5
$6:
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
  br label %$2
$5:
  %20 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %21 = phi i64 [%13, %$4], [%19, %$6], [%20, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %22 = alloca i64, i64 5, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = add i64 %23, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %25
  %26 = add i64 %23, 16
  %27 = inttoptr i64 %26 to i64*
  store i64 2, i64* %27
  %28 = add i64 %23, 24
  %29 = inttoptr i64 %28 to i64*
  store i64 %21, i64* %29
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %30 = add i64 %23, 24
; # (link (ofs E 3))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %30 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 %23 to i64*
  store i64 %30, i64* %36
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %37 = phi i64 [%3, %$2], [%46, %$10] ; # X
  %38 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%47, %$10] ; # R
  %39 = phi i64 [0, %$2], [%48, %$10] ; # L
  %40 = phi i64 [%23, %$2], [%61, %$10] ; # P
; # (shift X)
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (pair (shift X))
  %44 = and i64 %43, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$8, label %$9
$8:
  %46 = phi i64 [%43, %$7] ; # X
  %47 = phi i64 [%38, %$7] ; # R
  %48 = phi i64 [%39, %$7] ; # L
  %49 = phi i64 [%40, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %50 = inttoptr i64 %46 to i64*
  %51 = load i64, i64* %50
; # (eval (car X))
  %52 = and i64 %51, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$12, label %$11
$12:
  br label %$10
$11:
  %54 = and i64 %51, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$14, label %$13
$14:
  %56 = inttoptr i64 %51 to i64*
  %57 = load i64, i64* %56
  br label %$10
$13:
  %58 = call i64 @evList(i64 %51)
  br label %$10
$10:
  %59 = phi i64 [%51, %$12], [%57, %$14], [%58, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %60 = alloca i64, i64 5, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = add i64 %61, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
  %64 = add i64 %61, 16
  %65 = inttoptr i64 %64 to i64*
  store i64 2, i64* %65
  %66 = add i64 %61, 24
  %67 = inttoptr i64 %66 to i64*
  store i64 %59, i64* %67
  %68 = inttoptr i64 %49 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %61, i64* %69
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %70 = add i64 %61, 24
; # (link (ofs P 3))
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %75
  %76 = inttoptr i64 %61 to i64*
  store i64 %70, i64* %76
  br label %$7
$9:
  %77 = phi i64 [%43, %$7] ; # X
  %78 = phi i64 [%38, %$7] ; # R
  %79 = phi i64 [%39, %$7] ; # L
  %80 = phi i64 [%40, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P))) (let Y (cons (evList E)...
  br label %$15
$15:
  %81 = phi i64 [%77, %$9], [%146, %$25] ; # X
  %82 = phi i64 [%78, %$9], [%147, %$25] ; # R
  %83 = phi i64 [%79, %$9], [%148, %$25] ; # L
; # (let P (cdr E) (? (atom (val 4 P))) (let Y (cons (evList E) $Nil)...
; # (cdr E)
  %84 = inttoptr i64 %23 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (? (atom (val 4 P)))
; # (val 4 P)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 3
  %89 = load i64, i64* %88
; # (atom (val 4 P))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$17, label %$16
$16:
  %92 = phi i64 [%81, %$15] ; # X
  %93 = phi i64 [%82, %$15] ; # R
  %94 = phi i64 [%83, %$15] ; # L
  %95 = phi i64 [%86, %$15] ; # P
; # (let Y (cons (evList E) $Nil) (setq L (if L (set 2 L Y) (setq R (...
; # (evList E)
  %96 = call i64 @evList(i64 %23)
; # (cons (evList E) $Nil)
  %97 = call i64 @cons(i64 %96, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %98 = icmp ne i64 %94, 0
  br i1 %98, label %$18, label %$19
$18:
  %99 = phi i64 [%92, %$16] ; # X
  %100 = phi i64 [%93, %$16] ; # R
  %101 = phi i64 [%94, %$16] ; # L
  %102 = phi i64 [%95, %$16] ; # P
; # (set 2 L Y)
  %103 = inttoptr i64 %101 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  store i64 %97, i64* %104
  br label %$20
$19:
  %105 = phi i64 [%92, %$16] ; # X
  %106 = phi i64 [%93, %$16] ; # R
  %107 = phi i64 [%94, %$16] ; # L
  %108 = phi i64 [%95, %$16] ; # P
; # (safe Y)
  %109 = inttoptr i64 %7 to i64*
  store i64 %97, i64* %109
  br label %$20
$20:
  %110 = phi i64 [%99, %$18], [%105, %$19] ; # X
  %111 = phi i64 [%100, %$18], [%97, %$19] ; # R
  %112 = phi i64 [%101, %$18], [%107, %$19] ; # L
  %113 = phi i64 [%102, %$18], [%108, %$19] ; # P
  %114 = phi i64 [%97, %$18], [%97, %$19] ; # ->
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$21
$21:
  %115 = phi i64 [%110, %$20], [%142, %$24] ; # X
  %116 = phi i64 [%111, %$20], [%143, %$24] ; # R
  %117 = phi i64 [%114, %$20], [%144, %$24] ; # L
  %118 = phi i64 [%113, %$20], [%145, %$24] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %119 = inttoptr i64 %118 to i64*
  %120 = getelementptr i64, i64* %119, i32 3
  %121 = load i64, i64* %120
; # (pair (val 4 P))
  %122 = and i64 %121, 15
  %123 = icmp eq i64 %122, 0
  br i1 %123, label %$22, label %$23
$22:
  %124 = phi i64 [%115, %$21] ; # X
  %125 = phi i64 [%116, %$21] ; # R
  %126 = phi i64 [%117, %$21] ; # L
  %127 = phi i64 [%118, %$21] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %128 = inttoptr i64 %121 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 %127 to i64*
  %132 = getelementptr i64, i64* %131, i32 3
  store i64 %130, i64* %132
  br label %$23
$23:
  %133 = phi i64 [%115, %$21], [%124, %$22] ; # X
  %134 = phi i64 [%116, %$21], [%125, %$22] ; # R
  %135 = phi i64 [%117, %$21], [%126, %$22] ; # L
  %136 = phi i64 [%118, %$21], [%127, %$22] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %137 = inttoptr i64 %136 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
; # (atom (shift P))
  %140 = and i64 %139, 15
  %141 = icmp ne i64 %140, 0
  br i1 %141, label %$25, label %$24
$24:
  %142 = phi i64 [%133, %$23] ; # X
  %143 = phi i64 [%134, %$23] ; # R
  %144 = phi i64 [%135, %$23] ; # L
  %145 = phi i64 [%139, %$23] ; # P
  br label %$21
$25:
  %146 = phi i64 [%133, %$23] ; # X
  %147 = phi i64 [%134, %$23] ; # R
  %148 = phi i64 [%135, %$23] ; # L
  %149 = phi i64 [%139, %$23] ; # P
  %150 = phi i64 [0, %$23] ; # ->
  br label %$15
$17:
  %151 = phi i64 [%81, %$15] ; # X
  %152 = phi i64 [%82, %$15] ; # R
  %153 = phi i64 [%83, %$15] ; # L
  %154 = phi i64 [0, %$15] ; # ->
; # (drop *Safe)
  %155 = inttoptr i64 %7 to i64*
  %156 = getelementptr i64, i64* %155, i32 1
  %157 = load i64, i64* %156
  %158 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %157, i64* %158
  ret i64 %152
}

define i64 @_mapcar(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = alloca i64, i64 2, align 16
  %59 = ptrtoint i64* %58 to i64
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = add i64 %59, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (cons (evList E) $Nil) (setq L ...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (let Y (cons (evList E) $Nil) (setq L (if L (set 2 L Y) (se...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%220, %$27] ; # X
  %126 = phi i64 [%123, %$17], [%221, %$27] ; # R
  %127 = phi i64 [%124, %$17], [%222, %$27] ; # L
; # (let Y (cons (evList E) $Nil) (setq L (if L (set 2 L Y) (setq R (...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (cons (evList E) $Nil)
  %129 = call i64 @cons(i64 %128, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %130 = icmp ne i64 %127, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # L
; # (set 2 L Y)
  %134 = inttoptr i64 %133 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  store i64 %129, i64* %135
  br label %$22
$21:
  %136 = phi i64 [%125, %$19] ; # X
  %137 = phi i64 [%126, %$19] ; # R
  %138 = phi i64 [%127, %$19] ; # L
; # (safe Y)
  %139 = inttoptr i64 %7 to i64*
  store i64 %129, i64* %139
  br label %$22
$22:
  %140 = phi i64 [%131, %$20], [%136, %$21] ; # X
  %141 = phi i64 [%132, %$20], [%129, %$21] ; # R
  %142 = phi i64 [%133, %$20], [%138, %$21] ; # L
  %143 = phi i64 [%129, %$20], [%129, %$21] ; # ->
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %144 = inttoptr i64 %33 to i64*
  %145 = load i64, i64* %144
  %146 = inttoptr i64 %145 to i64*
  %147 = getelementptr i64, i64* %146, i32 1
  %148 = load i64, i64* %147
  %149 = inttoptr i64 %33 to i64*
  store i64 %148, i64* %149
; # (atom (set A (cdar A)))
  %150 = and i64 %148, 15
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$24, label %$23
$23:
  %152 = phi i64 [%140, %$22] ; # X
  %153 = phi i64 [%141, %$22] ; # R
  %154 = phi i64 [%143, %$22] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %155 = inttoptr i64 %25 to i64*
  %156 = getelementptr i64, i64* %155, i32 1
  %157 = load i64, i64* %156
; # (set 4 P (car @))
; # (car @)
  %158 = inttoptr i64 %148 to i64*
  %159 = load i64, i64* %158
  %160 = inttoptr i64 %157 to i64*
  %161 = getelementptr i64, i64* %160, i32 3
  store i64 %159, i64* %161
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$25
$25:
  %162 = phi i64 [%152, %$23], [%212, %$28] ; # X
  %163 = phi i64 [%153, %$23], [%213, %$28] ; # R
  %164 = phi i64 [%154, %$23], [%214, %$28] ; # L
  %165 = phi i64 [%157, %$23], [%215, %$28] ; # P
  %166 = phi i64 [%33, %$23], [%216, %$28] ; # Q
; # (shift P)
  %167 = inttoptr i64 %165 to i64*
  %168 = getelementptr i64, i64* %167, i32 1
  %169 = load i64, i64* %168
; # (pair (shift P))
  %170 = and i64 %169, 15
  %171 = icmp eq i64 %170, 0
  br i1 %171, label %$26, label %$27
$26:
  %172 = phi i64 [%162, %$25] ; # X
  %173 = phi i64 [%163, %$25] ; # R
  %174 = phi i64 [%164, %$25] ; # L
  %175 = phi i64 [%169, %$25] ; # P
  %176 = phi i64 [%166, %$25] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %177 = inttoptr i64 %176 to i64*
  %178 = getelementptr i64, i64* %177, i32 1
  %179 = load i64, i64* %178
; # (car (shift Q))
  %180 = inttoptr i64 %179 to i64*
  %181 = load i64, i64* %180
; # (atom (car (shift Q)))
  %182 = and i64 %181, 15
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$30, label %$29
$30:
  %184 = phi i64 [%172, %$26] ; # X
  %185 = phi i64 [%173, %$26] ; # R
  %186 = phi i64 [%174, %$26] ; # L
  %187 = phi i64 [%175, %$26] ; # P
  %188 = phi i64 [%179, %$26] ; # Q
  br label %$28
$29:
  %189 = phi i64 [%172, %$26] ; # X
  %190 = phi i64 [%173, %$26] ; # R
  %191 = phi i64 [%174, %$26] ; # L
  %192 = phi i64 [%175, %$26] ; # P
  %193 = phi i64 [%179, %$26] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %194 = inttoptr i64 %181 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
  %197 = inttoptr i64 %193 to i64*
  store i64 %196, i64* %197
; # (atom (set Q (cdr @)))
  %198 = and i64 %196, 15
  %199 = icmp ne i64 %198, 0
  br i1 %199, label %$32, label %$31
$32:
  %200 = phi i64 [%189, %$29] ; # X
  %201 = phi i64 [%190, %$29] ; # R
  %202 = phi i64 [%191, %$29] ; # L
  %203 = phi i64 [%192, %$29] ; # P
  %204 = phi i64 [%193, %$29] ; # Q
  br label %$28
$31:
  %205 = phi i64 [%189, %$29] ; # X
  %206 = phi i64 [%190, %$29] ; # R
  %207 = phi i64 [%191, %$29] ; # L
  %208 = phi i64 [%192, %$29] ; # P
  %209 = phi i64 [%193, %$29] ; # Q
; # (car @)
  %210 = inttoptr i64 %196 to i64*
  %211 = load i64, i64* %210
  br label %$28
$28:
  %212 = phi i64 [%184, %$30], [%200, %$32], [%205, %$31] ; # X
  %213 = phi i64 [%185, %$30], [%201, %$32], [%206, %$31] ; # R
  %214 = phi i64 [%186, %$30], [%202, %$32], [%207, %$31] ; # L
  %215 = phi i64 [%187, %$30], [%203, %$32], [%208, %$31] ; # P
  %216 = phi i64 [%188, %$30], [%204, %$32], [%209, %$31] ; # Q
  %217 = phi i64 [%181, %$30], [%196, %$32], [%211, %$31] ; # ->
  %218 = inttoptr i64 %175 to i64*
  %219 = getelementptr i64, i64* %218, i32 3
  store i64 %217, i64* %219
  br label %$25
$27:
  %220 = phi i64 [%162, %$25] ; # X
  %221 = phi i64 [%163, %$25] ; # R
  %222 = phi i64 [%164, %$25] ; # L
  %223 = phi i64 [%169, %$25] ; # P
  %224 = phi i64 [%166, %$25] ; # Q
  br label %$19
$24:
  %225 = phi i64 [%140, %$22] ; # X
  %226 = phi i64 [%141, %$22] ; # R
  %227 = phi i64 [%143, %$22] ; # L
  %228 = phi i64 [0, %$22] ; # ->
  br label %$18
$18:
  %229 = phi i64 [%112, %$16], [%225, %$24] ; # X
  %230 = phi i64 [%113, %$16], [%226, %$24] ; # R
  %231 = phi i64 [%114, %$16], [%227, %$24] ; # L
; # (drop *Safe)
  %232 = inttoptr i64 %7 to i64*
  %233 = getelementptr i64, i64* %232, i32 1
  %234 = load i64, i64* %233
  %235 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %234, i64* %235
  ret i64 %230
}

define i64 @_mapcon(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (car X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
; # (eval (car X))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$4, label %$3
$4:
  br label %$2
$3:
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$6, label %$5
$6:
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
  br label %$2
$5:
  %20 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %21 = phi i64 [%13, %$4], [%19, %$6], [%20, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %22 = alloca i64, i64 5, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = add i64 %23, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %25
  %26 = add i64 %23, 16
  %27 = inttoptr i64 %26 to i64*
  store i64 2, i64* %27
  %28 = add i64 %23, 24
  %29 = inttoptr i64 %28 to i64*
  store i64 %21, i64* %29
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %30 = add i64 %23, 24
; # (link (ofs E 3))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %30 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 %23 to i64*
  store i64 %30, i64* %36
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %37 = phi i64 [%3, %$2], [%46, %$10] ; # X
  %38 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%47, %$10] ; # R
  %39 = phi i64 [0, %$2], [%48, %$10] ; # L
  %40 = phi i64 [%23, %$2], [%61, %$10] ; # P
; # (shift X)
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (pair (shift X))
  %44 = and i64 %43, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$8, label %$9
$8:
  %46 = phi i64 [%43, %$7] ; # X
  %47 = phi i64 [%38, %$7] ; # R
  %48 = phi i64 [%39, %$7] ; # L
  %49 = phi i64 [%40, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %50 = inttoptr i64 %46 to i64*
  %51 = load i64, i64* %50
; # (eval (car X))
  %52 = and i64 %51, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$12, label %$11
$12:
  br label %$10
$11:
  %54 = and i64 %51, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$14, label %$13
$14:
  %56 = inttoptr i64 %51 to i64*
  %57 = load i64, i64* %56
  br label %$10
$13:
  %58 = call i64 @evList(i64 %51)
  br label %$10
$10:
  %59 = phi i64 [%51, %$12], [%57, %$14], [%58, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %60 = alloca i64, i64 5, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = add i64 %61, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
  %64 = add i64 %61, 16
  %65 = inttoptr i64 %64 to i64*
  store i64 2, i64* %65
  %66 = add i64 %61, 24
  %67 = inttoptr i64 %66 to i64*
  store i64 %59, i64* %67
  %68 = inttoptr i64 %49 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %61, i64* %69
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %70 = add i64 %61, 24
; # (link (ofs P 3))
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %75
  %76 = inttoptr i64 %61 to i64*
  store i64 %70, i64* %76
  br label %$7
$9:
  %77 = phi i64 [%43, %$7] ; # X
  %78 = phi i64 [%38, %$7] ; # R
  %79 = phi i64 [%39, %$7] ; # L
  %80 = phi i64 [%40, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P))) (let Y (evList E) (when...
  br label %$15
$15:
  %81 = phi i64 [%77, %$9], [%175, %$30] ; # X
  %82 = phi i64 [%78, %$9], [%176, %$30] ; # R
  %83 = phi i64 [%79, %$9], [%177, %$30] ; # L
; # (let P (cdr E) (? (atom (val 4 P))) (let Y (evList E) (when (pair...
; # (cdr E)
  %84 = inttoptr i64 %23 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (? (atom (val 4 P)))
; # (val 4 P)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 3
  %89 = load i64, i64* %88
; # (atom (val 4 P))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$17, label %$16
$16:
  %92 = phi i64 [%81, %$15] ; # X
  %93 = phi i64 [%82, %$15] ; # R
  %94 = phi i64 [%83, %$15] ; # L
  %95 = phi i64 [%86, %$15] ; # P
; # (let Y (evList E) (when (pair Y) (setq L (if L (let Z L (while (p...
; # (evList E)
  %96 = call i64 @evList(i64 %23)
; # (when (pair Y) (setq L (if L (let Z L (while (pair (cdr Z)) (setq...
; # (pair Y)
  %97 = and i64 %96, 15
  %98 = icmp eq i64 %97, 0
  br i1 %98, label %$18, label %$19
$18:
  %99 = phi i64 [%92, %$16] ; # X
  %100 = phi i64 [%93, %$16] ; # R
  %101 = phi i64 [%94, %$16] ; # L
  %102 = phi i64 [%95, %$16] ; # P
; # (if L (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y)) (se...
  %103 = icmp ne i64 %101, 0
  br i1 %103, label %$20, label %$21
$20:
  %104 = phi i64 [%99, %$18] ; # X
  %105 = phi i64 [%100, %$18] ; # R
  %106 = phi i64 [%101, %$18] ; # L
  %107 = phi i64 [%102, %$18] ; # P
; # (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y))
; # (while (pair (cdr Z)) (setq Z @))
  br label %$23
$23:
  %108 = phi i64 [%104, %$20], [%118, %$24] ; # X
  %109 = phi i64 [%105, %$20], [%119, %$24] ; # R
  %110 = phi i64 [%106, %$20], [%120, %$24] ; # L
  %111 = phi i64 [%107, %$20], [%121, %$24] ; # P
  %112 = phi i64 [%106, %$20], [%115, %$24] ; # Z
; # (cdr Z)
  %113 = inttoptr i64 %112 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  %115 = load i64, i64* %114
; # (pair (cdr Z))
  %116 = and i64 %115, 15
  %117 = icmp eq i64 %116, 0
  br i1 %117, label %$24, label %$25
$24:
  %118 = phi i64 [%108, %$23] ; # X
  %119 = phi i64 [%109, %$23] ; # R
  %120 = phi i64 [%110, %$23] ; # L
  %121 = phi i64 [%111, %$23] ; # P
  %122 = phi i64 [%112, %$23] ; # Z
  br label %$23
$25:
  %123 = phi i64 [%108, %$23] ; # X
  %124 = phi i64 [%109, %$23] ; # R
  %125 = phi i64 [%110, %$23] ; # L
  %126 = phi i64 [%111, %$23] ; # P
  %127 = phi i64 [%112, %$23] ; # Z
; # (set 2 Z Y)
  %128 = inttoptr i64 %127 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  store i64 %96, i64* %129
  br label %$22
$21:
  %130 = phi i64 [%99, %$18] ; # X
  %131 = phi i64 [%100, %$18] ; # R
  %132 = phi i64 [%101, %$18] ; # L
  %133 = phi i64 [%102, %$18] ; # P
; # (safe Y)
  %134 = inttoptr i64 %7 to i64*
  store i64 %96, i64* %134
  br label %$22
$22:
  %135 = phi i64 [%123, %$25], [%130, %$21] ; # X
  %136 = phi i64 [%124, %$25], [%96, %$21] ; # R
  %137 = phi i64 [%125, %$25], [%132, %$21] ; # L
  %138 = phi i64 [%126, %$25], [%133, %$21] ; # P
  %139 = phi i64 [%96, %$25], [%96, %$21] ; # ->
  br label %$19
$19:
  %140 = phi i64 [%92, %$16], [%135, %$22] ; # X
  %141 = phi i64 [%93, %$16], [%136, %$22] ; # R
  %142 = phi i64 [%94, %$16], [%139, %$22] ; # L
  %143 = phi i64 [%95, %$16], [%138, %$22] ; # P
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$26
$26:
  %144 = phi i64 [%140, %$19], [%171, %$29] ; # X
  %145 = phi i64 [%141, %$19], [%172, %$29] ; # R
  %146 = phi i64 [%142, %$19], [%173, %$29] ; # L
  %147 = phi i64 [%143, %$19], [%174, %$29] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %148 = inttoptr i64 %147 to i64*
  %149 = getelementptr i64, i64* %148, i32 3
  %150 = load i64, i64* %149
; # (pair (val 4 P))
  %151 = and i64 %150, 15
  %152 = icmp eq i64 %151, 0
  br i1 %152, label %$27, label %$28
$27:
  %153 = phi i64 [%144, %$26] ; # X
  %154 = phi i64 [%145, %$26] ; # R
  %155 = phi i64 [%146, %$26] ; # L
  %156 = phi i64 [%147, %$26] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %157 = inttoptr i64 %150 to i64*
  %158 = getelementptr i64, i64* %157, i32 1
  %159 = load i64, i64* %158
  %160 = inttoptr i64 %156 to i64*
  %161 = getelementptr i64, i64* %160, i32 3
  store i64 %159, i64* %161
  br label %$28
$28:
  %162 = phi i64 [%144, %$26], [%153, %$27] ; # X
  %163 = phi i64 [%145, %$26], [%154, %$27] ; # R
  %164 = phi i64 [%146, %$26], [%155, %$27] ; # L
  %165 = phi i64 [%147, %$26], [%156, %$27] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %166 = inttoptr i64 %165 to i64*
  %167 = getelementptr i64, i64* %166, i32 1
  %168 = load i64, i64* %167
; # (atom (shift P))
  %169 = and i64 %168, 15
  %170 = icmp ne i64 %169, 0
  br i1 %170, label %$30, label %$29
$29:
  %171 = phi i64 [%162, %$28] ; # X
  %172 = phi i64 [%163, %$28] ; # R
  %173 = phi i64 [%164, %$28] ; # L
  %174 = phi i64 [%168, %$28] ; # P
  br label %$26
$30:
  %175 = phi i64 [%162, %$28] ; # X
  %176 = phi i64 [%163, %$28] ; # R
  %177 = phi i64 [%164, %$28] ; # L
  %178 = phi i64 [%168, %$28] ; # P
  %179 = phi i64 [0, %$28] ; # ->
  br label %$15
$17:
  %180 = phi i64 [%81, %$15] ; # X
  %181 = phi i64 [%82, %$15] ; # R
  %182 = phi i64 [%83, %$15] ; # L
  %183 = phi i64 [0, %$15] ; # ->
; # (drop *Safe)
  %184 = inttoptr i64 %7 to i64*
  %185 = getelementptr i64, i64* %184, i32 1
  %186 = load i64, i64* %185
  %187 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %186, i64* %187
  ret i64 %181
}

define i64 @_mapcan(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = alloca i64, i64 2, align 16
  %59 = ptrtoint i64* %58 to i64
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = add i64 %59, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (evList E) (when (pair Y) (setq...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (let Y (evList E) (when (pair Y) (setq L (if L (let Z L (wh...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%244, %$32] ; # X
  %126 = phi i64 [%123, %$17], [%245, %$32] ; # R
  %127 = phi i64 [%124, %$17], [%246, %$32] ; # L
; # (let Y (evList E) (when (pair Y) (setq L (if L (let Z L (while (p...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (when (pair Y) (setq L (if L (let Z L (while (pair (cdr Z)) (setq...
; # (pair Y)
  %129 = and i64 %128, 15
  %130 = icmp eq i64 %129, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # L
; # (if L (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y)) (se...
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$22, label %$23
$22:
  %135 = phi i64 [%131, %$20] ; # X
  %136 = phi i64 [%132, %$20] ; # R
  %137 = phi i64 [%133, %$20] ; # L
; # (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y))
; # (while (pair (cdr Z)) (setq Z @))
  br label %$25
$25:
  %138 = phi i64 [%135, %$22], [%147, %$26] ; # X
  %139 = phi i64 [%136, %$22], [%148, %$26] ; # R
  %140 = phi i64 [%137, %$22], [%149, %$26] ; # L
  %141 = phi i64 [%137, %$22], [%144, %$26] ; # Z
; # (cdr Z)
  %142 = inttoptr i64 %141 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  %144 = load i64, i64* %143
; # (pair (cdr Z))
  %145 = and i64 %144, 15
  %146 = icmp eq i64 %145, 0
  br i1 %146, label %$26, label %$27
$26:
  %147 = phi i64 [%138, %$25] ; # X
  %148 = phi i64 [%139, %$25] ; # R
  %149 = phi i64 [%140, %$25] ; # L
  %150 = phi i64 [%141, %$25] ; # Z
  br label %$25
$27:
  %151 = phi i64 [%138, %$25] ; # X
  %152 = phi i64 [%139, %$25] ; # R
  %153 = phi i64 [%140, %$25] ; # L
  %154 = phi i64 [%141, %$25] ; # Z
; # (set 2 Z Y)
  %155 = inttoptr i64 %154 to i64*
  %156 = getelementptr i64, i64* %155, i32 1
  store i64 %128, i64* %156
  br label %$24
$23:
  %157 = phi i64 [%131, %$20] ; # X
  %158 = phi i64 [%132, %$20] ; # R
  %159 = phi i64 [%133, %$20] ; # L
; # (safe Y)
  %160 = inttoptr i64 %7 to i64*
  store i64 %128, i64* %160
  br label %$24
$24:
  %161 = phi i64 [%151, %$27], [%157, %$23] ; # X
  %162 = phi i64 [%152, %$27], [%128, %$23] ; # R
  %163 = phi i64 [%153, %$27], [%159, %$23] ; # L
  %164 = phi i64 [%128, %$27], [%128, %$23] ; # ->
  br label %$21
$21:
  %165 = phi i64 [%125, %$19], [%161, %$24] ; # X
  %166 = phi i64 [%126, %$19], [%162, %$24] ; # R
  %167 = phi i64 [%127, %$19], [%164, %$24] ; # L
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %168 = inttoptr i64 %33 to i64*
  %169 = load i64, i64* %168
  %170 = inttoptr i64 %169 to i64*
  %171 = getelementptr i64, i64* %170, i32 1
  %172 = load i64, i64* %171
  %173 = inttoptr i64 %33 to i64*
  store i64 %172, i64* %173
; # (atom (set A (cdar A)))
  %174 = and i64 %172, 15
  %175 = icmp ne i64 %174, 0
  br i1 %175, label %$29, label %$28
$28:
  %176 = phi i64 [%165, %$21] ; # X
  %177 = phi i64 [%166, %$21] ; # R
  %178 = phi i64 [%167, %$21] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %179 = inttoptr i64 %25 to i64*
  %180 = getelementptr i64, i64* %179, i32 1
  %181 = load i64, i64* %180
; # (set 4 P (car @))
; # (car @)
  %182 = inttoptr i64 %172 to i64*
  %183 = load i64, i64* %182
  %184 = inttoptr i64 %181 to i64*
  %185 = getelementptr i64, i64* %184, i32 3
  store i64 %183, i64* %185
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$30
$30:
  %186 = phi i64 [%176, %$28], [%236, %$33] ; # X
  %187 = phi i64 [%177, %$28], [%237, %$33] ; # R
  %188 = phi i64 [%178, %$28], [%238, %$33] ; # L
  %189 = phi i64 [%181, %$28], [%239, %$33] ; # P
  %190 = phi i64 [%33, %$28], [%240, %$33] ; # Q
; # (shift P)
  %191 = inttoptr i64 %189 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
; # (pair (shift P))
  %194 = and i64 %193, 15
  %195 = icmp eq i64 %194, 0
  br i1 %195, label %$31, label %$32
$31:
  %196 = phi i64 [%186, %$30] ; # X
  %197 = phi i64 [%187, %$30] ; # R
  %198 = phi i64 [%188, %$30] ; # L
  %199 = phi i64 [%193, %$30] ; # P
  %200 = phi i64 [%190, %$30] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %201 = inttoptr i64 %200 to i64*
  %202 = getelementptr i64, i64* %201, i32 1
  %203 = load i64, i64* %202
; # (car (shift Q))
  %204 = inttoptr i64 %203 to i64*
  %205 = load i64, i64* %204
; # (atom (car (shift Q)))
  %206 = and i64 %205, 15
  %207 = icmp ne i64 %206, 0
  br i1 %207, label %$35, label %$34
$35:
  %208 = phi i64 [%196, %$31] ; # X
  %209 = phi i64 [%197, %$31] ; # R
  %210 = phi i64 [%198, %$31] ; # L
  %211 = phi i64 [%199, %$31] ; # P
  %212 = phi i64 [%203, %$31] ; # Q
  br label %$33
$34:
  %213 = phi i64 [%196, %$31] ; # X
  %214 = phi i64 [%197, %$31] ; # R
  %215 = phi i64 [%198, %$31] ; # L
  %216 = phi i64 [%199, %$31] ; # P
  %217 = phi i64 [%203, %$31] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %218 = inttoptr i64 %205 to i64*
  %219 = getelementptr i64, i64* %218, i32 1
  %220 = load i64, i64* %219
  %221 = inttoptr i64 %217 to i64*
  store i64 %220, i64* %221
; # (atom (set Q (cdr @)))
  %222 = and i64 %220, 15
  %223 = icmp ne i64 %222, 0
  br i1 %223, label %$37, label %$36
$37:
  %224 = phi i64 [%213, %$34] ; # X
  %225 = phi i64 [%214, %$34] ; # R
  %226 = phi i64 [%215, %$34] ; # L
  %227 = phi i64 [%216, %$34] ; # P
  %228 = phi i64 [%217, %$34] ; # Q
  br label %$33
$36:
  %229 = phi i64 [%213, %$34] ; # X
  %230 = phi i64 [%214, %$34] ; # R
  %231 = phi i64 [%215, %$34] ; # L
  %232 = phi i64 [%216, %$34] ; # P
  %233 = phi i64 [%217, %$34] ; # Q
; # (car @)
  %234 = inttoptr i64 %220 to i64*
  %235 = load i64, i64* %234
  br label %$33
$33:
  %236 = phi i64 [%208, %$35], [%224, %$37], [%229, %$36] ; # X
  %237 = phi i64 [%209, %$35], [%225, %$37], [%230, %$36] ; # R
  %238 = phi i64 [%210, %$35], [%226, %$37], [%231, %$36] ; # L
  %239 = phi i64 [%211, %$35], [%227, %$37], [%232, %$36] ; # P
  %240 = phi i64 [%212, %$35], [%228, %$37], [%233, %$36] ; # Q
  %241 = phi i64 [%205, %$35], [%220, %$37], [%235, %$36] ; # ->
  %242 = inttoptr i64 %199 to i64*
  %243 = getelementptr i64, i64* %242, i32 3
  store i64 %241, i64* %243
  br label %$30
$32:
  %244 = phi i64 [%186, %$30] ; # X
  %245 = phi i64 [%187, %$30] ; # R
  %246 = phi i64 [%188, %$30] ; # L
  %247 = phi i64 [%193, %$30] ; # P
  %248 = phi i64 [%190, %$30] ; # Q
  br label %$19
$29:
  %249 = phi i64 [%165, %$21] ; # X
  %250 = phi i64 [%166, %$21] ; # R
  %251 = phi i64 [%167, %$21] ; # L
  %252 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %253 = phi i64 [%112, %$16], [%249, %$29] ; # X
  %254 = phi i64 [%113, %$16], [%250, %$29] ; # R
  %255 = phi i64 [%114, %$16], [%251, %$29] ; # L
; # (drop *Safe)
  %256 = inttoptr i64 %7 to i64*
  %257 = getelementptr i64, i64* %256, i32 1
  %258 = load i64, i64* %257
  %259 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %258, i64* %259
  ret i64 %254
}

define i64 @_filter(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = alloca i64, i64 2, align 16
  %59 = ptrtoint i64* %58 to i64
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = add i64 %59, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (unless (nil? (evList E)) (let Y (cons...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (unless (nil? (evList E)) (let Y (cons (caar A) $Nil) (setq...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%231, %$29] ; # X
  %126 = phi i64 [%123, %$17], [%232, %$29] ; # R
  %127 = phi i64 [%124, %$17], [%233, %$29] ; # L
; # (unless (nil? (evList E)) (let Y (cons (caar A) $Nil) (setq L (if...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (nil? (evList E))
  %129 = icmp eq i64 %128, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %129, label %$21, label %$20
$20:
  %130 = phi i64 [%125, %$19] ; # X
  %131 = phi i64 [%126, %$19] ; # R
  %132 = phi i64 [%127, %$19] ; # L
; # (let Y (cons (caar A) $Nil) (setq L (if L (set 2 L Y) (setq R (sa...
; # (caar A)
  %133 = inttoptr i64 %33 to i64*
  %134 = load i64, i64* %133
  %135 = inttoptr i64 %134 to i64*
  %136 = load i64, i64* %135
; # (cons (caar A) $Nil)
  %137 = call i64 @cons(i64 %136, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %138 = icmp ne i64 %132, 0
  br i1 %138, label %$22, label %$23
$22:
  %139 = phi i64 [%130, %$20] ; # X
  %140 = phi i64 [%131, %$20] ; # R
  %141 = phi i64 [%132, %$20] ; # L
; # (set 2 L Y)
  %142 = inttoptr i64 %141 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  store i64 %137, i64* %143
  br label %$24
$23:
  %144 = phi i64 [%130, %$20] ; # X
  %145 = phi i64 [%131, %$20] ; # R
  %146 = phi i64 [%132, %$20] ; # L
; # (safe Y)
  %147 = inttoptr i64 %7 to i64*
  store i64 %137, i64* %147
  br label %$24
$24:
  %148 = phi i64 [%139, %$22], [%144, %$23] ; # X
  %149 = phi i64 [%140, %$22], [%137, %$23] ; # R
  %150 = phi i64 [%141, %$22], [%146, %$23] ; # L
  %151 = phi i64 [%137, %$22], [%137, %$23] ; # ->
  br label %$21
$21:
  %152 = phi i64 [%125, %$19], [%148, %$24] ; # X
  %153 = phi i64 [%126, %$19], [%149, %$24] ; # R
  %154 = phi i64 [%127, %$19], [%151, %$24] ; # L
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %155 = inttoptr i64 %33 to i64*
  %156 = load i64, i64* %155
  %157 = inttoptr i64 %156 to i64*
  %158 = getelementptr i64, i64* %157, i32 1
  %159 = load i64, i64* %158
  %160 = inttoptr i64 %33 to i64*
  store i64 %159, i64* %160
; # (atom (set A (cdar A)))
  %161 = and i64 %159, 15
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$26, label %$25
$25:
  %163 = phi i64 [%152, %$21] ; # X
  %164 = phi i64 [%153, %$21] ; # R
  %165 = phi i64 [%154, %$21] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %166 = inttoptr i64 %25 to i64*
  %167 = getelementptr i64, i64* %166, i32 1
  %168 = load i64, i64* %167
; # (set 4 P (car @))
; # (car @)
  %169 = inttoptr i64 %159 to i64*
  %170 = load i64, i64* %169
  %171 = inttoptr i64 %168 to i64*
  %172 = getelementptr i64, i64* %171, i32 3
  store i64 %170, i64* %172
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$27
$27:
  %173 = phi i64 [%163, %$25], [%223, %$30] ; # X
  %174 = phi i64 [%164, %$25], [%224, %$30] ; # R
  %175 = phi i64 [%165, %$25], [%225, %$30] ; # L
  %176 = phi i64 [%168, %$25], [%226, %$30] ; # P
  %177 = phi i64 [%33, %$25], [%227, %$30] ; # Q
; # (shift P)
  %178 = inttoptr i64 %176 to i64*
  %179 = getelementptr i64, i64* %178, i32 1
  %180 = load i64, i64* %179
; # (pair (shift P))
  %181 = and i64 %180, 15
  %182 = icmp eq i64 %181, 0
  br i1 %182, label %$28, label %$29
$28:
  %183 = phi i64 [%173, %$27] ; # X
  %184 = phi i64 [%174, %$27] ; # R
  %185 = phi i64 [%175, %$27] ; # L
  %186 = phi i64 [%180, %$27] ; # P
  %187 = phi i64 [%177, %$27] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %188 = inttoptr i64 %187 to i64*
  %189 = getelementptr i64, i64* %188, i32 1
  %190 = load i64, i64* %189
; # (car (shift Q))
  %191 = inttoptr i64 %190 to i64*
  %192 = load i64, i64* %191
; # (atom (car (shift Q)))
  %193 = and i64 %192, 15
  %194 = icmp ne i64 %193, 0
  br i1 %194, label %$32, label %$31
$32:
  %195 = phi i64 [%183, %$28] ; # X
  %196 = phi i64 [%184, %$28] ; # R
  %197 = phi i64 [%185, %$28] ; # L
  %198 = phi i64 [%186, %$28] ; # P
  %199 = phi i64 [%190, %$28] ; # Q
  br label %$30
$31:
  %200 = phi i64 [%183, %$28] ; # X
  %201 = phi i64 [%184, %$28] ; # R
  %202 = phi i64 [%185, %$28] ; # L
  %203 = phi i64 [%186, %$28] ; # P
  %204 = phi i64 [%190, %$28] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %205 = inttoptr i64 %192 to i64*
  %206 = getelementptr i64, i64* %205, i32 1
  %207 = load i64, i64* %206
  %208 = inttoptr i64 %204 to i64*
  store i64 %207, i64* %208
; # (atom (set Q (cdr @)))
  %209 = and i64 %207, 15
  %210 = icmp ne i64 %209, 0
  br i1 %210, label %$34, label %$33
$34:
  %211 = phi i64 [%200, %$31] ; # X
  %212 = phi i64 [%201, %$31] ; # R
  %213 = phi i64 [%202, %$31] ; # L
  %214 = phi i64 [%203, %$31] ; # P
  %215 = phi i64 [%204, %$31] ; # Q
  br label %$30
$33:
  %216 = phi i64 [%200, %$31] ; # X
  %217 = phi i64 [%201, %$31] ; # R
  %218 = phi i64 [%202, %$31] ; # L
  %219 = phi i64 [%203, %$31] ; # P
  %220 = phi i64 [%204, %$31] ; # Q
; # (car @)
  %221 = inttoptr i64 %207 to i64*
  %222 = load i64, i64* %221
  br label %$30
$30:
  %223 = phi i64 [%195, %$32], [%211, %$34], [%216, %$33] ; # X
  %224 = phi i64 [%196, %$32], [%212, %$34], [%217, %$33] ; # R
  %225 = phi i64 [%197, %$32], [%213, %$34], [%218, %$33] ; # L
  %226 = phi i64 [%198, %$32], [%214, %$34], [%219, %$33] ; # P
  %227 = phi i64 [%199, %$32], [%215, %$34], [%220, %$33] ; # Q
  %228 = phi i64 [%192, %$32], [%207, %$34], [%222, %$33] ; # ->
  %229 = inttoptr i64 %186 to i64*
  %230 = getelementptr i64, i64* %229, i32 3
  store i64 %228, i64* %230
  br label %$27
$29:
  %231 = phi i64 [%173, %$27] ; # X
  %232 = phi i64 [%174, %$27] ; # R
  %233 = phi i64 [%175, %$27] ; # L
  %234 = phi i64 [%180, %$27] ; # P
  %235 = phi i64 [%177, %$27] ; # Q
  br label %$19
$26:
  %236 = phi i64 [%152, %$21] ; # X
  %237 = phi i64 [%153, %$21] ; # R
  %238 = phi i64 [%154, %$21] ; # L
  %239 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %240 = phi i64 [%112, %$16], [%236, %$26] ; # X
  %241 = phi i64 [%113, %$16], [%237, %$26] ; # R
  %242 = phi i64 [%114, %$16], [%238, %$26] ; # L
; # (drop *Safe)
  %243 = inttoptr i64 %7 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  %245 = load i64, i64* %244
  %246 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %245, i64* %246
  ret i64 %241
}

define i64 @_extract(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = alloca i64, i64 2, align 16
  %59 = ptrtoint i64* %58 to i64
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = add i64 %59, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (unless (nil? (evList E)) (let Y (cons...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (unless (nil? (evList E)) (let Y (cons @ $Nil) (setq L (if ...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%227, %$29] ; # X
  %126 = phi i64 [%123, %$17], [%228, %$29] ; # R
  %127 = phi i64 [%124, %$17], [%229, %$29] ; # L
; # (unless (nil? (evList E)) (let Y (cons @ $Nil) (setq L (if L (set...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (nil? (evList E))
  %129 = icmp eq i64 %128, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %129, label %$21, label %$20
$20:
  %130 = phi i64 [%125, %$19] ; # X
  %131 = phi i64 [%126, %$19] ; # R
  %132 = phi i64 [%127, %$19] ; # L
; # (let Y (cons @ $Nil) (setq L (if L (set 2 L Y) (setq R (safe Y)))...
; # (cons @ $Nil)
  %133 = call i64 @cons(i64 %128, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %134 = icmp ne i64 %132, 0
  br i1 %134, label %$22, label %$23
$22:
  %135 = phi i64 [%130, %$20] ; # X
  %136 = phi i64 [%131, %$20] ; # R
  %137 = phi i64 [%132, %$20] ; # L
; # (set 2 L Y)
  %138 = inttoptr i64 %137 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  store i64 %133, i64* %139
  br label %$24
$23:
  %140 = phi i64 [%130, %$20] ; # X
  %141 = phi i64 [%131, %$20] ; # R
  %142 = phi i64 [%132, %$20] ; # L
; # (safe Y)
  %143 = inttoptr i64 %7 to i64*
  store i64 %133, i64* %143
  br label %$24
$24:
  %144 = phi i64 [%135, %$22], [%140, %$23] ; # X
  %145 = phi i64 [%136, %$22], [%133, %$23] ; # R
  %146 = phi i64 [%137, %$22], [%142, %$23] ; # L
  %147 = phi i64 [%133, %$22], [%133, %$23] ; # ->
  br label %$21
$21:
  %148 = phi i64 [%125, %$19], [%144, %$24] ; # X
  %149 = phi i64 [%126, %$19], [%145, %$24] ; # R
  %150 = phi i64 [%127, %$19], [%147, %$24] ; # L
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %151 = inttoptr i64 %33 to i64*
  %152 = load i64, i64* %151
  %153 = inttoptr i64 %152 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
  %156 = inttoptr i64 %33 to i64*
  store i64 %155, i64* %156
; # (atom (set A (cdar A)))
  %157 = and i64 %155, 15
  %158 = icmp ne i64 %157, 0
  br i1 %158, label %$26, label %$25
$25:
  %159 = phi i64 [%148, %$21] ; # X
  %160 = phi i64 [%149, %$21] ; # R
  %161 = phi i64 [%150, %$21] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %162 = inttoptr i64 %25 to i64*
  %163 = getelementptr i64, i64* %162, i32 1
  %164 = load i64, i64* %163
; # (set 4 P (car @))
; # (car @)
  %165 = inttoptr i64 %155 to i64*
  %166 = load i64, i64* %165
  %167 = inttoptr i64 %164 to i64*
  %168 = getelementptr i64, i64* %167, i32 3
  store i64 %166, i64* %168
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$27
$27:
  %169 = phi i64 [%159, %$25], [%219, %$30] ; # X
  %170 = phi i64 [%160, %$25], [%220, %$30] ; # R
  %171 = phi i64 [%161, %$25], [%221, %$30] ; # L
  %172 = phi i64 [%164, %$25], [%222, %$30] ; # P
  %173 = phi i64 [%33, %$25], [%223, %$30] ; # Q
; # (shift P)
  %174 = inttoptr i64 %172 to i64*
  %175 = getelementptr i64, i64* %174, i32 1
  %176 = load i64, i64* %175
; # (pair (shift P))
  %177 = and i64 %176, 15
  %178 = icmp eq i64 %177, 0
  br i1 %178, label %$28, label %$29
$28:
  %179 = phi i64 [%169, %$27] ; # X
  %180 = phi i64 [%170, %$27] ; # R
  %181 = phi i64 [%171, %$27] ; # L
  %182 = phi i64 [%176, %$27] ; # P
  %183 = phi i64 [%173, %$27] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %184 = inttoptr i64 %183 to i64*
  %185 = getelementptr i64, i64* %184, i32 1
  %186 = load i64, i64* %185
; # (car (shift Q))
  %187 = inttoptr i64 %186 to i64*
  %188 = load i64, i64* %187
; # (atom (car (shift Q)))
  %189 = and i64 %188, 15
  %190 = icmp ne i64 %189, 0
  br i1 %190, label %$32, label %$31
$32:
  %191 = phi i64 [%179, %$28] ; # X
  %192 = phi i64 [%180, %$28] ; # R
  %193 = phi i64 [%181, %$28] ; # L
  %194 = phi i64 [%182, %$28] ; # P
  %195 = phi i64 [%186, %$28] ; # Q
  br label %$30
$31:
  %196 = phi i64 [%179, %$28] ; # X
  %197 = phi i64 [%180, %$28] ; # R
  %198 = phi i64 [%181, %$28] ; # L
  %199 = phi i64 [%182, %$28] ; # P
  %200 = phi i64 [%186, %$28] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %201 = inttoptr i64 %188 to i64*
  %202 = getelementptr i64, i64* %201, i32 1
  %203 = load i64, i64* %202
  %204 = inttoptr i64 %200 to i64*
  store i64 %203, i64* %204
; # (atom (set Q (cdr @)))
  %205 = and i64 %203, 15
  %206 = icmp ne i64 %205, 0
  br i1 %206, label %$34, label %$33
$34:
  %207 = phi i64 [%196, %$31] ; # X
  %208 = phi i64 [%197, %$31] ; # R
  %209 = phi i64 [%198, %$31] ; # L
  %210 = phi i64 [%199, %$31] ; # P
  %211 = phi i64 [%200, %$31] ; # Q
  br label %$30
$33:
  %212 = phi i64 [%196, %$31] ; # X
  %213 = phi i64 [%197, %$31] ; # R
  %214 = phi i64 [%198, %$31] ; # L
  %215 = phi i64 [%199, %$31] ; # P
  %216 = phi i64 [%200, %$31] ; # Q
; # (car @)
  %217 = inttoptr i64 %203 to i64*
  %218 = load i64, i64* %217
  br label %$30
$30:
  %219 = phi i64 [%191, %$32], [%207, %$34], [%212, %$33] ; # X
  %220 = phi i64 [%192, %$32], [%208, %$34], [%213, %$33] ; # R
  %221 = phi i64 [%193, %$32], [%209, %$34], [%214, %$33] ; # L
  %222 = phi i64 [%194, %$32], [%210, %$34], [%215, %$33] ; # P
  %223 = phi i64 [%195, %$32], [%211, %$34], [%216, %$33] ; # Q
  %224 = phi i64 [%188, %$32], [%203, %$34], [%218, %$33] ; # ->
  %225 = inttoptr i64 %182 to i64*
  %226 = getelementptr i64, i64* %225, i32 3
  store i64 %224, i64* %226
  br label %$27
$29:
  %227 = phi i64 [%169, %$27] ; # X
  %228 = phi i64 [%170, %$27] ; # R
  %229 = phi i64 [%171, %$27] ; # L
  %230 = phi i64 [%176, %$27] ; # P
  %231 = phi i64 [%173, %$27] ; # Q
  br label %$19
$26:
  %232 = phi i64 [%148, %$21] ; # X
  %233 = phi i64 [%149, %$21] ; # R
  %234 = phi i64 [%150, %$21] ; # L
  %235 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %236 = phi i64 [%112, %$16], [%232, %$26] ; # X
  %237 = phi i64 [%113, %$16], [%233, %$26] ; # R
  %238 = phi i64 [%114, %$16], [%234, %$26] ; # L
; # (drop *Safe)
  %239 = inttoptr i64 %7 to i64*
  %240 = getelementptr i64, i64* %239, i32 1
  %241 = load i64, i64* %240
  %242 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %241, i64* %242
  ret i64 %237
}

define i64 @_seek(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (car X)) NIL)) (set...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %14 = alloca i64, i64 5, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = add i64 %15, 8
  %17 = inttoptr i64 %16 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %17
  %18 = add i64 %15, 16
  %19 = inttoptr i64 %18 to i64*
  store i64 2, i64* %19
  %20 = add i64 %15, 24
  %21 = inttoptr i64 %20 to i64*
  store i64 %13, i64* %21
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %22 = add i64 %15, 24
; # (link (ofs E 3) T)
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %22 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 %15 to i64*
  store i64 %22, i64* %28
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %29 = phi i64 [%3, %$2], [%36, %$10] ; # X
  %30 = phi i64 [%15, %$2], [%49, %$10] ; # P
; # (shift X)
  %31 = inttoptr i64 %29 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
; # (pair (shift X))
  %34 = and i64 %33, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$8, label %$9
$8:
  %36 = phi i64 [%33, %$7] ; # X
  %37 = phi i64 [%30, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %38 = inttoptr i64 %36 to i64*
  %39 = load i64, i64* %38
; # (eval (car X))
  %40 = and i64 %39, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  br label %$10
$11:
  %42 = and i64 %39, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$14, label %$13
$14:
  %44 = inttoptr i64 %39 to i64*
  %45 = load i64, i64* %44
  br label %$10
$13:
  %46 = call i64 @evList(i64 %39)
  br label %$10
$10:
  %47 = phi i64 [%39, %$12], [%45, %$14], [%46, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %48 = alloca i64, i64 5, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = add i64 %49, 8
  %51 = inttoptr i64 %50 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %51
  %52 = add i64 %49, 16
  %53 = inttoptr i64 %52 to i64*
  store i64 2, i64* %53
  %54 = add i64 %49, 24
  %55 = inttoptr i64 %54 to i64*
  store i64 %47, i64* %55
  %56 = inttoptr i64 %37 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  store i64 %49, i64* %57
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %58 = add i64 %49, 24
; # (link (ofs P 3))
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %58 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %63
  %64 = inttoptr i64 %49 to i64*
  store i64 %58, i64* %64
  br label %$7
$9:
  %65 = phi i64 [%33, %$7] ; # X
  %66 = phi i64 [%30, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P)) $Nil) (? (not (nil? (evL...
  br label %$15
$15:
  %67 = phi i64 [%65, %$9], [%114, %$25] ; # X
; # (let P (cdr E) (? (atom (val 4 P)) $Nil) (? (not (nil? (evList E)...
; # (cdr E)
  %68 = inttoptr i64 %15 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
; # (? (atom (val 4 P)) $Nil)
; # (val 4 P)
  %71 = inttoptr i64 %70 to i64*
  %72 = getelementptr i64, i64* %71, i32 3
  %73 = load i64, i64* %72
; # (atom (val 4 P))
  %74 = and i64 %73, 15
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$18, label %$16
$18:
  %76 = phi i64 [%67, %$15] ; # X
  %77 = phi i64 [%70, %$15] ; # P
  br label %$17
$16:
  %78 = phi i64 [%67, %$15] ; # X
  %79 = phi i64 [%70, %$15] ; # P
; # (? (not (nil? (evList E))) (set $At2 @) (val 4 P))
; # (evList E)
  %80 = call i64 @evList(i64 %15)
; # (nil? (evList E))
  %81 = icmp eq i64 %80, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (evList E)))
  %82 = icmp eq i1 %81, 0
  br i1 %82, label %$20, label %$19
$20:
  %83 = phi i64 [%78, %$16] ; # X
  %84 = phi i64 [%79, %$16] ; # P
; # (set $At2 @)
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %80, i64* %85
; # (val 4 P)
  %86 = inttoptr i64 %84 to i64*
  %87 = getelementptr i64, i64* %86, i32 3
  %88 = load i64, i64* %87
  br label %$17
$19:
  %89 = phi i64 [%78, %$16] ; # X
  %90 = phi i64 [%79, %$16] ; # P
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$21
$21:
  %91 = phi i64 [%89, %$19], [%112, %$24] ; # X
  %92 = phi i64 [%90, %$19], [%113, %$24] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %93 = inttoptr i64 %92 to i64*
  %94 = getelementptr i64, i64* %93, i32 3
  %95 = load i64, i64* %94
; # (pair (val 4 P))
  %96 = and i64 %95, 15
  %97 = icmp eq i64 %96, 0
  br i1 %97, label %$22, label %$23
$22:
  %98 = phi i64 [%91, %$21] ; # X
  %99 = phi i64 [%92, %$21] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %100 = inttoptr i64 %95 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
  %103 = inttoptr i64 %99 to i64*
  %104 = getelementptr i64, i64* %103, i32 3
  store i64 %102, i64* %104
  br label %$23
$23:
  %105 = phi i64 [%91, %$21], [%98, %$22] ; # X
  %106 = phi i64 [%92, %$21], [%99, %$22] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %107 = inttoptr i64 %106 to i64*
  %108 = getelementptr i64, i64* %107, i32 1
  %109 = load i64, i64* %108
; # (atom (shift P))
  %110 = and i64 %109, 15
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$25, label %$24
$24:
  %112 = phi i64 [%105, %$23] ; # X
  %113 = phi i64 [%109, %$23] ; # P
  br label %$21
$25:
  %114 = phi i64 [%105, %$23] ; # X
  %115 = phi i64 [%109, %$23] ; # P
  %116 = phi i64 [0, %$23] ; # ->
  br label %$15
$17:
  %117 = phi i64 [%76, %$18], [%83, %$20] ; # X
  %118 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$18], [%88, %$20] ; # ->
; # (drop *Safe)
  %119 = inttoptr i64 %22 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %121, i64* %122
  ret i64 %118
}

define i64 @_find(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL) A (pus...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%89, %$15] ; # X
  %34 = phi i64 [%17, %$2], [%90, %$15] ; # P
  %35 = phi i64 [%25, %$2], [%93, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (eval (car X))
  %38 = and i64 %37, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  br label %$8
$9:
  %40 = and i64 %37, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  %42 = inttoptr i64 %37 to i64*
  %43 = load i64, i64* %42
  br label %$8
$11:
  %44 = call i64 @evList(i64 %37)
  br label %$8
$8:
  %45 = phi i64 [%37, %$10], [%43, %$12], [%44, %$11] ; # ->
; # (save (eval (car X)))
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %47 = load i64, i64* %46
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %45, i64* %50
  %51 = add i64 %49, 8
  %52 = inttoptr i64 %51 to i64*
  store i64 %47, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %53
  %54 = inttoptr i64 %35 to i64*
  store i64 %45, i64* %54
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %55 = and i64 %45, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%33, %$8] ; # X
  %58 = phi i64 [%34, %$8] ; # P
  %59 = phi i64 [%35, %$8] ; # Q
  %60 = phi i64 [%45, %$8] ; # V
; # (car V)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  br label %$14
$14:
  %63 = phi i64 [%33, %$8], [%57, %$13] ; # X
  %64 = phi i64 [%34, %$8], [%58, %$13] ; # P
  %65 = phi i64 [%35, %$8], [%59, %$13] ; # Q
  %66 = phi i64 [%45, %$8], [%62, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %67 = alloca i64, i64 5, align 16
  %68 = ptrtoint i64* %67 to i64
  %69 = add i64 %68, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %70
  %71 = add i64 %68, 16
  %72 = inttoptr i64 %71 to i64*
  store i64 2, i64* %72
  %73 = add i64 %68, 24
  %74 = inttoptr i64 %73 to i64*
  store i64 %66, i64* %74
  %75 = inttoptr i64 %64 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %68, i64* %76
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %77 = add i64 %68, 24
; # (link (ofs P 3))
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
  %83 = inttoptr i64 %68 to i64*
  store i64 %77, i64* %83
; # (? (atom (shift X)))
; # (shift X)
  %84 = inttoptr i64 %63 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (atom (shift X))
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$16, label %$15
$15:
  %89 = phi i64 [%86, %$14] ; # X
  %90 = phi i64 [%68, %$14] ; # P
  %91 = phi i64 [%65, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$7
$16:
  %96 = phi i64 [%86, %$14] ; # X
  %97 = phi i64 [%68, %$14] ; # P
  %98 = phi i64 [%65, %$14] ; # Q
  %99 = phi i64 [0, %$14] ; # ->
; # (if (atom (car A)) $Nil (loop (? (not (nil? (evList E))) (set $At...
; # (car A)
  %100 = inttoptr i64 %25 to i64*
  %101 = load i64, i64* %100
; # (atom (car A))
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$17, label %$18
$17:
  %104 = phi i64 [%96, %$16] ; # X
  br label %$19
$18:
  %105 = phi i64 [%96, %$16] ; # X
; # (loop (? (not (nil? (evList E))) (set $At2 @) (caar A)) (? (atom ...
  br label %$20
$20:
  %106 = phi i64 [%105, %$18], [%178, %$28] ; # X
; # (? (not (nil? (evList E))) (set $At2 @) (caar A))
; # (evList E)
  %107 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %108 = icmp eq i64 %107, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (evList E)))
  %109 = icmp eq i1 %108, 0
  br i1 %109, label %$23, label %$21
$23:
  %110 = phi i64 [%106, %$20] ; # X
; # (set $At2 @)
  %111 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %107, i64* %111
; # (caar A)
  %112 = inttoptr i64 %25 to i64*
  %113 = load i64, i64* %112
  %114 = inttoptr i64 %113 to i64*
  %115 = load i64, i64* %114
  br label %$22
$21:
  %116 = phi i64 [%106, %$20] ; # X
; # (? (atom (set A (cdar A))) $Nil)
; # (set A (cdar A))
; # (cdar A)
  %117 = inttoptr i64 %25 to i64*
  %118 = load i64, i64* %117
  %119 = inttoptr i64 %118 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  %122 = inttoptr i64 %25 to i64*
  store i64 %121, i64* %122
; # (atom (set A (cdar A)))
  %123 = and i64 %121, 15
  %124 = icmp ne i64 %123, 0
  br i1 %124, label %$25, label %$24
$25:
  %125 = phi i64 [%116, %$21] ; # X
  br label %$22
$24:
  %126 = phi i64 [%116, %$21] ; # X
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %127 = inttoptr i64 %17 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  %129 = load i64, i64* %128
; # (set 4 P (car @))
; # (car @)
  %130 = inttoptr i64 %121 to i64*
  %131 = load i64, i64* %130
  %132 = inttoptr i64 %129 to i64*
  %133 = getelementptr i64, i64* %132, i32 3
  store i64 %131, i64* %133
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$26
$26:
  %134 = phi i64 [%126, %$24], [%172, %$29] ; # X
  %135 = phi i64 [%129, %$24], [%173, %$29] ; # P
  %136 = phi i64 [%25, %$24], [%174, %$29] ; # Q
; # (shift P)
  %137 = inttoptr i64 %135 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
; # (pair (shift P))
  %140 = and i64 %139, 15
  %141 = icmp eq i64 %140, 0
  br i1 %141, label %$27, label %$28
$27:
  %142 = phi i64 [%134, %$26] ; # X
  %143 = phi i64 [%139, %$26] ; # P
  %144 = phi i64 [%136, %$26] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %145 = inttoptr i64 %144 to i64*
  %146 = getelementptr i64, i64* %145, i32 1
  %147 = load i64, i64* %146
; # (car (shift Q))
  %148 = inttoptr i64 %147 to i64*
  %149 = load i64, i64* %148
; # (atom (car (shift Q)))
  %150 = and i64 %149, 15
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$31, label %$30
$31:
  %152 = phi i64 [%142, %$27] ; # X
  %153 = phi i64 [%143, %$27] ; # P
  %154 = phi i64 [%147, %$27] ; # Q
  br label %$29
$30:
  %155 = phi i64 [%142, %$27] ; # X
  %156 = phi i64 [%143, %$27] ; # P
  %157 = phi i64 [%147, %$27] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %158 = inttoptr i64 %149 to i64*
  %159 = getelementptr i64, i64* %158, i32 1
  %160 = load i64, i64* %159
  %161 = inttoptr i64 %157 to i64*
  store i64 %160, i64* %161
; # (atom (set Q (cdr @)))
  %162 = and i64 %160, 15
  %163 = icmp ne i64 %162, 0
  br i1 %163, label %$33, label %$32
$33:
  %164 = phi i64 [%155, %$30] ; # X
  %165 = phi i64 [%156, %$30] ; # P
  %166 = phi i64 [%157, %$30] ; # Q
  br label %$29
$32:
  %167 = phi i64 [%155, %$30] ; # X
  %168 = phi i64 [%156, %$30] ; # P
  %169 = phi i64 [%157, %$30] ; # Q
; # (car @)
  %170 = inttoptr i64 %160 to i64*
  %171 = load i64, i64* %170
  br label %$29
$29:
  %172 = phi i64 [%152, %$31], [%164, %$33], [%167, %$32] ; # X
  %173 = phi i64 [%153, %$31], [%165, %$33], [%168, %$32] ; # P
  %174 = phi i64 [%154, %$31], [%166, %$33], [%169, %$32] ; # Q
  %175 = phi i64 [%149, %$31], [%160, %$33], [%171, %$32] ; # ->
  %176 = inttoptr i64 %143 to i64*
  %177 = getelementptr i64, i64* %176, i32 3
  store i64 %175, i64* %177
  br label %$26
$28:
  %178 = phi i64 [%134, %$26] ; # X
  %179 = phi i64 [%139, %$26] ; # P
  %180 = phi i64 [%136, %$26] ; # Q
  br label %$20
$22:
  %181 = phi i64 [%110, %$23], [%125, %$25] ; # X
  %182 = phi i64 [%115, %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$25] ; # ->
  br label %$19
$19:
  %183 = phi i64 [%104, %$17], [%181, %$22] ; # X
  %184 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [%182, %$22] ; # ->
; # (drop *Safe)
  %185 = inttoptr i64 %26 to i64*
  %186 = getelementptr i64, i64* %185, i32 1
  %187 = load i64, i64* %186
  %188 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %187, i64* %188
  ret i64 %184
}

define i64 @_pick(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL) A (pus...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%89, %$15] ; # X
  %34 = phi i64 [%17, %$2], [%90, %$15] ; # P
  %35 = phi i64 [%25, %$2], [%93, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (eval (car X))
  %38 = and i64 %37, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  br label %$8
$9:
  %40 = and i64 %37, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  %42 = inttoptr i64 %37 to i64*
  %43 = load i64, i64* %42
  br label %$8
$11:
  %44 = call i64 @evList(i64 %37)
  br label %$8
$8:
  %45 = phi i64 [%37, %$10], [%43, %$12], [%44, %$11] ; # ->
; # (save (eval (car X)))
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %47 = load i64, i64* %46
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %45, i64* %50
  %51 = add i64 %49, 8
  %52 = inttoptr i64 %51 to i64*
  store i64 %47, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %53
  %54 = inttoptr i64 %35 to i64*
  store i64 %45, i64* %54
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %55 = and i64 %45, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%33, %$8] ; # X
  %58 = phi i64 [%34, %$8] ; # P
  %59 = phi i64 [%35, %$8] ; # Q
  %60 = phi i64 [%45, %$8] ; # V
; # (car V)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  br label %$14
$14:
  %63 = phi i64 [%33, %$8], [%57, %$13] ; # X
  %64 = phi i64 [%34, %$8], [%58, %$13] ; # P
  %65 = phi i64 [%35, %$8], [%59, %$13] ; # Q
  %66 = phi i64 [%45, %$8], [%62, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %67 = alloca i64, i64 5, align 16
  %68 = ptrtoint i64* %67 to i64
  %69 = add i64 %68, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %70
  %71 = add i64 %68, 16
  %72 = inttoptr i64 %71 to i64*
  store i64 2, i64* %72
  %73 = add i64 %68, 24
  %74 = inttoptr i64 %73 to i64*
  store i64 %66, i64* %74
  %75 = inttoptr i64 %64 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %68, i64* %76
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %77 = add i64 %68, 24
; # (link (ofs P 3))
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
  %83 = inttoptr i64 %68 to i64*
  store i64 %77, i64* %83
; # (? (atom (shift X)))
; # (shift X)
  %84 = inttoptr i64 %63 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (atom (shift X))
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$16, label %$15
$15:
  %89 = phi i64 [%86, %$14] ; # X
  %90 = phi i64 [%68, %$14] ; # P
  %91 = phi i64 [%65, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$7
$16:
  %96 = phi i64 [%86, %$14] ; # X
  %97 = phi i64 [%68, %$14] ; # P
  %98 = phi i64 [%65, %$14] ; # Q
  %99 = phi i64 [0, %$14] ; # ->
; # (if (atom (car A)) $Nil (loop (? (not (nil? (evList E))) @) (? (a...
; # (car A)
  %100 = inttoptr i64 %25 to i64*
  %101 = load i64, i64* %100
; # (atom (car A))
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$17, label %$18
$17:
  %104 = phi i64 [%96, %$16] ; # X
  br label %$19
$18:
  %105 = phi i64 [%96, %$16] ; # X
; # (loop (? (not (nil? (evList E))) @) (? (atom (set A (cdar A))) $N...
  br label %$20
$20:
  %106 = phi i64 [%105, %$18], [%173, %$28] ; # X
; # (? (not (nil? (evList E))) @)
; # (evList E)
  %107 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %108 = icmp eq i64 %107, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (evList E)))
  %109 = icmp eq i1 %108, 0
  br i1 %109, label %$23, label %$21
$23:
  %110 = phi i64 [%106, %$20] ; # X
  br label %$22
$21:
  %111 = phi i64 [%106, %$20] ; # X
; # (? (atom (set A (cdar A))) $Nil)
; # (set A (cdar A))
; # (cdar A)
  %112 = inttoptr i64 %25 to i64*
  %113 = load i64, i64* %112
  %114 = inttoptr i64 %113 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
  %117 = inttoptr i64 %25 to i64*
  store i64 %116, i64* %117
; # (atom (set A (cdar A)))
  %118 = and i64 %116, 15
  %119 = icmp ne i64 %118, 0
  br i1 %119, label %$25, label %$24
$25:
  %120 = phi i64 [%111, %$21] ; # X
  br label %$22
$24:
  %121 = phi i64 [%111, %$21] ; # X
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %122 = inttoptr i64 %17 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  %124 = load i64, i64* %123
; # (set 4 P (car @))
; # (car @)
  %125 = inttoptr i64 %116 to i64*
  %126 = load i64, i64* %125
  %127 = inttoptr i64 %124 to i64*
  %128 = getelementptr i64, i64* %127, i32 3
  store i64 %126, i64* %128
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$26
$26:
  %129 = phi i64 [%121, %$24], [%167, %$29] ; # X
  %130 = phi i64 [%124, %$24], [%168, %$29] ; # P
  %131 = phi i64 [%25, %$24], [%169, %$29] ; # Q
; # (shift P)
  %132 = inttoptr i64 %130 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
; # (pair (shift P))
  %135 = and i64 %134, 15
  %136 = icmp eq i64 %135, 0
  br i1 %136, label %$27, label %$28
$27:
  %137 = phi i64 [%129, %$26] ; # X
  %138 = phi i64 [%134, %$26] ; # P
  %139 = phi i64 [%131, %$26] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %140 = inttoptr i64 %139 to i64*
  %141 = getelementptr i64, i64* %140, i32 1
  %142 = load i64, i64* %141
; # (car (shift Q))
  %143 = inttoptr i64 %142 to i64*
  %144 = load i64, i64* %143
; # (atom (car (shift Q)))
  %145 = and i64 %144, 15
  %146 = icmp ne i64 %145, 0
  br i1 %146, label %$31, label %$30
$31:
  %147 = phi i64 [%137, %$27] ; # X
  %148 = phi i64 [%138, %$27] ; # P
  %149 = phi i64 [%142, %$27] ; # Q
  br label %$29
$30:
  %150 = phi i64 [%137, %$27] ; # X
  %151 = phi i64 [%138, %$27] ; # P
  %152 = phi i64 [%142, %$27] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %153 = inttoptr i64 %144 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
  %156 = inttoptr i64 %152 to i64*
  store i64 %155, i64* %156
; # (atom (set Q (cdr @)))
  %157 = and i64 %155, 15
  %158 = icmp ne i64 %157, 0
  br i1 %158, label %$33, label %$32
$33:
  %159 = phi i64 [%150, %$30] ; # X
  %160 = phi i64 [%151, %$30] ; # P
  %161 = phi i64 [%152, %$30] ; # Q
  br label %$29
$32:
  %162 = phi i64 [%150, %$30] ; # X
  %163 = phi i64 [%151, %$30] ; # P
  %164 = phi i64 [%152, %$30] ; # Q
; # (car @)
  %165 = inttoptr i64 %155 to i64*
  %166 = load i64, i64* %165
  br label %$29
$29:
  %167 = phi i64 [%147, %$31], [%159, %$33], [%162, %$32] ; # X
  %168 = phi i64 [%148, %$31], [%160, %$33], [%163, %$32] ; # P
  %169 = phi i64 [%149, %$31], [%161, %$33], [%164, %$32] ; # Q
  %170 = phi i64 [%144, %$31], [%155, %$33], [%166, %$32] ; # ->
  %171 = inttoptr i64 %138 to i64*
  %172 = getelementptr i64, i64* %171, i32 3
  store i64 %170, i64* %172
  br label %$26
$28:
  %173 = phi i64 [%129, %$26] ; # X
  %174 = phi i64 [%134, %$26] ; # P
  %175 = phi i64 [%131, %$26] ; # Q
  br label %$20
$22:
  %176 = phi i64 [%110, %$23], [%120, %$25] ; # X
  %177 = phi i64 [%107, %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$25] ; # ->
  br label %$19
$19:
  %178 = phi i64 [%104, %$17], [%176, %$22] ; # X
  %179 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [%177, %$22] ; # ->
; # (drop *Safe)
  %180 = inttoptr i64 %26 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %182, i64* %183
  ret i64 %179
}

define i64 @_fully(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL) A (pus...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%89, %$15] ; # X
  %34 = phi i64 [%17, %$2], [%90, %$15] ; # P
  %35 = phi i64 [%25, %$2], [%93, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (eval (car X))
  %38 = and i64 %37, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  br label %$8
$9:
  %40 = and i64 %37, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  %42 = inttoptr i64 %37 to i64*
  %43 = load i64, i64* %42
  br label %$8
$11:
  %44 = call i64 @evList(i64 %37)
  br label %$8
$8:
  %45 = phi i64 [%37, %$10], [%43, %$12], [%44, %$11] ; # ->
; # (save (eval (car X)))
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %47 = load i64, i64* %46
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %45, i64* %50
  %51 = add i64 %49, 8
  %52 = inttoptr i64 %51 to i64*
  store i64 %47, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %53
  %54 = inttoptr i64 %35 to i64*
  store i64 %45, i64* %54
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %55 = and i64 %45, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%33, %$8] ; # X
  %58 = phi i64 [%34, %$8] ; # P
  %59 = phi i64 [%35, %$8] ; # Q
  %60 = phi i64 [%45, %$8] ; # V
; # (car V)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  br label %$14
$14:
  %63 = phi i64 [%33, %$8], [%57, %$13] ; # X
  %64 = phi i64 [%34, %$8], [%58, %$13] ; # P
  %65 = phi i64 [%35, %$8], [%59, %$13] ; # Q
  %66 = phi i64 [%45, %$8], [%62, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %67 = alloca i64, i64 5, align 16
  %68 = ptrtoint i64* %67 to i64
  %69 = add i64 %68, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %70
  %71 = add i64 %68, 16
  %72 = inttoptr i64 %71 to i64*
  store i64 2, i64* %72
  %73 = add i64 %68, 24
  %74 = inttoptr i64 %73 to i64*
  store i64 %66, i64* %74
  %75 = inttoptr i64 %64 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %68, i64* %76
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %77 = add i64 %68, 24
; # (link (ofs P 3))
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
  %83 = inttoptr i64 %68 to i64*
  store i64 %77, i64* %83
; # (? (atom (shift X)))
; # (shift X)
  %84 = inttoptr i64 %63 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (atom (shift X))
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$16, label %$15
$15:
  %89 = phi i64 [%86, %$14] ; # X
  %90 = phi i64 [%68, %$14] ; # P
  %91 = phi i64 [%65, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$7
$16:
  %96 = phi i64 [%86, %$14] ; # X
  %97 = phi i64 [%68, %$14] ; # P
  %98 = phi i64 [%65, %$14] ; # Q
  %99 = phi i64 [0, %$14] ; # ->
; # (if (atom (car A)) $T (loop (? (nil? (evList E)) @) (? (atom (set...
; # (car A)
  %100 = inttoptr i64 %25 to i64*
  %101 = load i64, i64* %100
; # (atom (car A))
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$17, label %$18
$17:
  %104 = phi i64 [%96, %$16] ; # X
  br label %$19
$18:
  %105 = phi i64 [%96, %$16] ; # X
; # (loop (? (nil? (evList E)) @) (? (atom (set A (cdar A))) $T) (let...
  br label %$20
$20:
  %106 = phi i64 [%105, %$18], [%172, %$28] ; # X
; # (? (nil? (evList E)) @)
; # (evList E)
  %107 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %108 = icmp eq i64 %107, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %108, label %$23, label %$21
$23:
  %109 = phi i64 [%106, %$20] ; # X
  br label %$22
$21:
  %110 = phi i64 [%106, %$20] ; # X
; # (? (atom (set A (cdar A))) $T)
; # (set A (cdar A))
; # (cdar A)
  %111 = inttoptr i64 %25 to i64*
  %112 = load i64, i64* %111
  %113 = inttoptr i64 %112 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  %115 = load i64, i64* %114
  %116 = inttoptr i64 %25 to i64*
  store i64 %115, i64* %116
; # (atom (set A (cdar A)))
  %117 = and i64 %115, 15
  %118 = icmp ne i64 %117, 0
  br i1 %118, label %$25, label %$24
$25:
  %119 = phi i64 [%110, %$21] ; # X
  br label %$22
$24:
  %120 = phi i64 [%110, %$21] ; # X
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %121 = inttoptr i64 %17 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  %123 = load i64, i64* %122
; # (set 4 P (car @))
; # (car @)
  %124 = inttoptr i64 %115 to i64*
  %125 = load i64, i64* %124
  %126 = inttoptr i64 %123 to i64*
  %127 = getelementptr i64, i64* %126, i32 3
  store i64 %125, i64* %127
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$26
$26:
  %128 = phi i64 [%120, %$24], [%166, %$29] ; # X
  %129 = phi i64 [%123, %$24], [%167, %$29] ; # P
  %130 = phi i64 [%25, %$24], [%168, %$29] ; # Q
; # (shift P)
  %131 = inttoptr i64 %129 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  %133 = load i64, i64* %132
; # (pair (shift P))
  %134 = and i64 %133, 15
  %135 = icmp eq i64 %134, 0
  br i1 %135, label %$27, label %$28
$27:
  %136 = phi i64 [%128, %$26] ; # X
  %137 = phi i64 [%133, %$26] ; # P
  %138 = phi i64 [%130, %$26] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %139 = inttoptr i64 %138 to i64*
  %140 = getelementptr i64, i64* %139, i32 1
  %141 = load i64, i64* %140
; # (car (shift Q))
  %142 = inttoptr i64 %141 to i64*
  %143 = load i64, i64* %142
; # (atom (car (shift Q)))
  %144 = and i64 %143, 15
  %145 = icmp ne i64 %144, 0
  br i1 %145, label %$31, label %$30
$31:
  %146 = phi i64 [%136, %$27] ; # X
  %147 = phi i64 [%137, %$27] ; # P
  %148 = phi i64 [%141, %$27] ; # Q
  br label %$29
$30:
  %149 = phi i64 [%136, %$27] ; # X
  %150 = phi i64 [%137, %$27] ; # P
  %151 = phi i64 [%141, %$27] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %152 = inttoptr i64 %143 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
  %155 = inttoptr i64 %151 to i64*
  store i64 %154, i64* %155
; # (atom (set Q (cdr @)))
  %156 = and i64 %154, 15
  %157 = icmp ne i64 %156, 0
  br i1 %157, label %$33, label %$32
$33:
  %158 = phi i64 [%149, %$30] ; # X
  %159 = phi i64 [%150, %$30] ; # P
  %160 = phi i64 [%151, %$30] ; # Q
  br label %$29
$32:
  %161 = phi i64 [%149, %$30] ; # X
  %162 = phi i64 [%150, %$30] ; # P
  %163 = phi i64 [%151, %$30] ; # Q
; # (car @)
  %164 = inttoptr i64 %154 to i64*
  %165 = load i64, i64* %164
  br label %$29
$29:
  %166 = phi i64 [%146, %$31], [%158, %$33], [%161, %$32] ; # X
  %167 = phi i64 [%147, %$31], [%159, %$33], [%162, %$32] ; # P
  %168 = phi i64 [%148, %$31], [%160, %$33], [%163, %$32] ; # Q
  %169 = phi i64 [%143, %$31], [%154, %$33], [%165, %$32] ; # ->
  %170 = inttoptr i64 %137 to i64*
  %171 = getelementptr i64, i64* %170, i32 3
  store i64 %169, i64* %171
  br label %$26
$28:
  %172 = phi i64 [%128, %$26] ; # X
  %173 = phi i64 [%133, %$26] ; # P
  %174 = phi i64 [%130, %$26] ; # Q
  br label %$20
$22:
  %175 = phi i64 [%109, %$23], [%119, %$25] ; # X
  %176 = phi i64 [%107, %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$25] ; # ->
  br label %$19
$19:
  %177 = phi i64 [%104, %$17], [%175, %$22] ; # X
  %178 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$17], [%176, %$22] ; # ->
; # (drop *Safe)
  %179 = inttoptr i64 %26 to i64*
  %180 = getelementptr i64, i64* %179, i32 1
  %181 = load i64, i64* %180
  %182 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %181, i64* %182
  ret i64 %178
}

define i64 @_cnt(i64) align 8 {
$1:
; # (let (X (cdr Exe) R ZERO E (push NIL $Nil ZERO (eval (++ X)) NIL)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%92, %$15] ; # X
  %34 = phi i64 [2, %$2], [%93, %$15] ; # R
  %35 = phi i64 [%17, %$2], [%94, %$15] ; # P
  %36 = phi i64 [%25, %$2], [%97, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %37 = inttoptr i64 %33 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$10, label %$9
$10:
  br label %$8
$9:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$12, label %$11
$12:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$8
$11:
  %45 = call i64 @evList(i64 %38)
  br label %$8
$8:
  %46 = phi i64 [%38, %$10], [%44, %$12], [%45, %$11] ; # ->
; # (save (eval (car X)))
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %48 = load i64, i64* %47
  %49 = alloca i64, i64 2, align 16
  %50 = ptrtoint i64* %49 to i64
  %51 = inttoptr i64 %50 to i64*
  store i64 %46, i64* %51
  %52 = add i64 %50, 8
  %53 = inttoptr i64 %52 to i64*
  store i64 %48, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %50, i64* %54
  %55 = inttoptr i64 %36 to i64*
  store i64 %46, i64* %55
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %56 = and i64 %46, 15
  %57 = icmp eq i64 %56, 0
  br i1 %57, label %$13, label %$14
$13:
  %58 = phi i64 [%33, %$8] ; # X
  %59 = phi i64 [%34, %$8] ; # R
  %60 = phi i64 [%35, %$8] ; # P
  %61 = phi i64 [%36, %$8] ; # Q
  %62 = phi i64 [%46, %$8] ; # V
; # (car V)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  br label %$14
$14:
  %65 = phi i64 [%33, %$8], [%58, %$13] ; # X
  %66 = phi i64 [%34, %$8], [%59, %$13] ; # R
  %67 = phi i64 [%35, %$8], [%60, %$13] ; # P
  %68 = phi i64 [%36, %$8], [%61, %$13] ; # Q
  %69 = phi i64 [%46, %$8], [%64, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %70 = alloca i64, i64 5, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = add i64 %71, 8
  %73 = inttoptr i64 %72 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %73
  %74 = add i64 %71, 16
  %75 = inttoptr i64 %74 to i64*
  store i64 2, i64* %75
  %76 = add i64 %71, 24
  %77 = inttoptr i64 %76 to i64*
  store i64 %69, i64* %77
  %78 = inttoptr i64 %67 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %71, i64* %79
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %80 = add i64 %71, 24
; # (link (ofs P 3))
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %82 = load i64, i64* %81
  %83 = inttoptr i64 %80 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %82, i64* %84
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %85
  %86 = inttoptr i64 %71 to i64*
  store i64 %80, i64* %86
; # (? (atom (shift X)))
; # (shift X)
  %87 = inttoptr i64 %65 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
; # (atom (shift X))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$16, label %$15
$15:
  %92 = phi i64 [%89, %$14] ; # X
  %93 = phi i64 [%66, %$14] ; # R
  %94 = phi i64 [%71, %$14] ; # P
  %95 = phi i64 [%68, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %96 = alloca i64, i64 2, align 16
  %97 = ptrtoint i64* %96 to i64
  %98 = inttoptr i64 %95 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  store i64 %97, i64* %99
  br label %$7
$16:
  %100 = phi i64 [%89, %$14] ; # X
  %101 = phi i64 [%66, %$14] ; # R
  %102 = phi i64 [%71, %$14] ; # P
  %103 = phi i64 [%68, %$14] ; # Q
  %104 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (unless (nil? (evList E)) (inc 'R (hex...
; # (car A)
  %105 = inttoptr i64 %25 to i64*
  %106 = load i64, i64* %105
; # (pair (car A))
  %107 = and i64 %106, 15
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %$17, label %$18
$17:
  %109 = phi i64 [%100, %$16] ; # X
  %110 = phi i64 [%101, %$16] ; # R
; # (loop (unless (nil? (evList E)) (inc 'R (hex "10"))) (? (atom (se...
  br label %$19
$19:
  %111 = phi i64 [%109, %$17], [%188, %$26] ; # X
  %112 = phi i64 [%110, %$17], [%189, %$26] ; # R
; # (unless (nil? (evList E)) (inc 'R (hex "10")))
; # (evList E)
  %113 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %114 = icmp eq i64 %113, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %114, label %$21, label %$20
$20:
  %115 = phi i64 [%111, %$19] ; # X
  %116 = phi i64 [%112, %$19] ; # R
; # (inc 'R (hex "10"))
  %117 = add i64 %116, 16
  br label %$21
$21:
  %118 = phi i64 [%111, %$19], [%115, %$20] ; # X
  %119 = phi i64 [%112, %$19], [%117, %$20] ; # R
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %120 = inttoptr i64 %25 to i64*
  %121 = load i64, i64* %120
  %122 = inttoptr i64 %121 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  %124 = load i64, i64* %123
  %125 = inttoptr i64 %25 to i64*
  store i64 %124, i64* %125
; # (atom (set A (cdar A)))
  %126 = and i64 %124, 15
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$23, label %$22
$22:
  %128 = phi i64 [%118, %$21] ; # X
  %129 = phi i64 [%119, %$21] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %130 = inttoptr i64 %17 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  %132 = load i64, i64* %131
; # (set 4 P (car @))
; # (car @)
  %133 = inttoptr i64 %124 to i64*
  %134 = load i64, i64* %133
  %135 = inttoptr i64 %132 to i64*
  %136 = getelementptr i64, i64* %135, i32 3
  store i64 %134, i64* %136
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %137 = phi i64 [%128, %$22], [%181, %$27] ; # X
  %138 = phi i64 [%129, %$22], [%182, %$27] ; # R
  %139 = phi i64 [%132, %$22], [%183, %$27] ; # P
  %140 = phi i64 [%25, %$22], [%184, %$27] ; # Q
; # (shift P)
  %141 = inttoptr i64 %139 to i64*
  %142 = getelementptr i64, i64* %141, i32 1
  %143 = load i64, i64* %142
; # (pair (shift P))
  %144 = and i64 %143, 15
  %145 = icmp eq i64 %144, 0
  br i1 %145, label %$25, label %$26
$25:
  %146 = phi i64 [%137, %$24] ; # X
  %147 = phi i64 [%138, %$24] ; # R
  %148 = phi i64 [%143, %$24] ; # P
  %149 = phi i64 [%140, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %150 = inttoptr i64 %149 to i64*
  %151 = getelementptr i64, i64* %150, i32 1
  %152 = load i64, i64* %151
; # (car (shift Q))
  %153 = inttoptr i64 %152 to i64*
  %154 = load i64, i64* %153
; # (atom (car (shift Q)))
  %155 = and i64 %154, 15
  %156 = icmp ne i64 %155, 0
  br i1 %156, label %$29, label %$28
$29:
  %157 = phi i64 [%146, %$25] ; # X
  %158 = phi i64 [%147, %$25] ; # R
  %159 = phi i64 [%148, %$25] ; # P
  %160 = phi i64 [%152, %$25] ; # Q
  br label %$27
$28:
  %161 = phi i64 [%146, %$25] ; # X
  %162 = phi i64 [%147, %$25] ; # R
  %163 = phi i64 [%148, %$25] ; # P
  %164 = phi i64 [%152, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %165 = inttoptr i64 %154 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
  %168 = inttoptr i64 %164 to i64*
  store i64 %167, i64* %168
; # (atom (set Q (cdr @)))
  %169 = and i64 %167, 15
  %170 = icmp ne i64 %169, 0
  br i1 %170, label %$31, label %$30
$31:
  %171 = phi i64 [%161, %$28] ; # X
  %172 = phi i64 [%162, %$28] ; # R
  %173 = phi i64 [%163, %$28] ; # P
  %174 = phi i64 [%164, %$28] ; # Q
  br label %$27
$30:
  %175 = phi i64 [%161, %$28] ; # X
  %176 = phi i64 [%162, %$28] ; # R
  %177 = phi i64 [%163, %$28] ; # P
  %178 = phi i64 [%164, %$28] ; # Q
; # (car @)
  %179 = inttoptr i64 %167 to i64*
  %180 = load i64, i64* %179
  br label %$27
$27:
  %181 = phi i64 [%157, %$29], [%171, %$31], [%175, %$30] ; # X
  %182 = phi i64 [%158, %$29], [%172, %$31], [%176, %$30] ; # R
  %183 = phi i64 [%159, %$29], [%173, %$31], [%177, %$30] ; # P
  %184 = phi i64 [%160, %$29], [%174, %$31], [%178, %$30] ; # Q
  %185 = phi i64 [%154, %$29], [%167, %$31], [%180, %$30] ; # ->
  %186 = inttoptr i64 %148 to i64*
  %187 = getelementptr i64, i64* %186, i32 3
  store i64 %185, i64* %187
  br label %$24
$26:
  %188 = phi i64 [%137, %$24] ; # X
  %189 = phi i64 [%138, %$24] ; # R
  %190 = phi i64 [%143, %$24] ; # P
  %191 = phi i64 [%140, %$24] ; # Q
  br label %$19
$23:
  %192 = phi i64 [%118, %$21] ; # X
  %193 = phi i64 [%119, %$21] ; # R
  %194 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %195 = phi i64 [%100, %$16], [%192, %$23] ; # X
  %196 = phi i64 [%101, %$16], [%193, %$23] ; # R
; # (drop *Safe)
  %197 = inttoptr i64 %26 to i64*
  %198 = getelementptr i64, i64* %197, i32 1
  %199 = load i64, i64* %198
  %200 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %199, i64* %200
  ret i64 %196
}

define i64 @_sum(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save ZERO) E (push NIL $Nil ZERO (eval (++ X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save ZERO)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 2, i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%100, %$15] ; # X
  %42 = phi i64 [2, %$2], [%101, %$15] ; # R
  %43 = phi i64 [%25, %$2], [%102, %$15] ; # P
  %44 = phi i64 [%33, %$2], [%105, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %45 = inttoptr i64 %41 to i64*
  %46 = load i64, i64* %45
; # (eval (car X))
  %47 = and i64 %46, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$10, label %$9
$10:
  br label %$8
$9:
  %49 = and i64 %46, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$12, label %$11
$12:
  %51 = inttoptr i64 %46 to i64*
  %52 = load i64, i64* %51
  br label %$8
$11:
  %53 = call i64 @evList(i64 %46)
  br label %$8
$8:
  %54 = phi i64 [%46, %$10], [%52, %$12], [%53, %$11] ; # ->
; # (save (eval (car X)))
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %56 = load i64, i64* %55
  %57 = alloca i64, i64 2, align 16
  %58 = ptrtoint i64* %57 to i64
  %59 = inttoptr i64 %58 to i64*
  store i64 %54, i64* %59
  %60 = add i64 %58, 8
  %61 = inttoptr i64 %60 to i64*
  store i64 %56, i64* %61
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %62
  %63 = inttoptr i64 %44 to i64*
  store i64 %54, i64* %63
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %64 = and i64 %54, 15
  %65 = icmp eq i64 %64, 0
  br i1 %65, label %$13, label %$14
$13:
  %66 = phi i64 [%41, %$8] ; # X
  %67 = phi i64 [%42, %$8] ; # R
  %68 = phi i64 [%43, %$8] ; # P
  %69 = phi i64 [%44, %$8] ; # Q
  %70 = phi i64 [%54, %$8] ; # V
; # (car V)
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
  br label %$14
$14:
  %73 = phi i64 [%41, %$8], [%66, %$13] ; # X
  %74 = phi i64 [%42, %$8], [%67, %$13] ; # R
  %75 = phi i64 [%43, %$8], [%68, %$13] ; # P
  %76 = phi i64 [%44, %$8], [%69, %$13] ; # Q
  %77 = phi i64 [%54, %$8], [%72, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %78 = alloca i64, i64 5, align 16
  %79 = ptrtoint i64* %78 to i64
  %80 = add i64 %79, 8
  %81 = inttoptr i64 %80 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %81
  %82 = add i64 %79, 16
  %83 = inttoptr i64 %82 to i64*
  store i64 2, i64* %83
  %84 = add i64 %79, 24
  %85 = inttoptr i64 %84 to i64*
  store i64 %77, i64* %85
  %86 = inttoptr i64 %75 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  store i64 %79, i64* %87
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %88 = add i64 %79, 24
; # (link (ofs P 3))
  %89 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %90 = load i64, i64* %89
  %91 = inttoptr i64 %88 to i64*
  %92 = getelementptr i64, i64* %91, i32 1
  store i64 %90, i64* %92
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %88, i64* %93
  %94 = inttoptr i64 %79 to i64*
  store i64 %88, i64* %94
; # (? (atom (shift X)))
; # (shift X)
  %95 = inttoptr i64 %73 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
; # (atom (shift X))
  %98 = and i64 %97, 15
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$16, label %$15
$15:
  %100 = phi i64 [%97, %$14] ; # X
  %101 = phi i64 [%74, %$14] ; # R
  %102 = phi i64 [%79, %$14] ; # P
  %103 = phi i64 [%76, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %104 = alloca i64, i64 2, align 16
  %105 = ptrtoint i64* %104 to i64
  %106 = inttoptr i64 %103 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  store i64 %105, i64* %107
  br label %$7
$16:
  %108 = phi i64 [%97, %$14] ; # X
  %109 = phi i64 [%74, %$14] ; # R
  %110 = phi i64 [%79, %$14] ; # P
  %111 = phi i64 [%76, %$14] ; # Q
  %112 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (when (num? (evList E)) (save @ (setq ...
; # (car A)
  %113 = inttoptr i64 %33 to i64*
  %114 = load i64, i64* %113
; # (pair (car A))
  %115 = and i64 %114, 15
  %116 = icmp eq i64 %115, 0
  br i1 %116, label %$17, label %$18
$17:
  %117 = phi i64 [%108, %$16] ; # X
  %118 = phi i64 [%109, %$16] ; # R
; # (loop (when (num? (evList E)) (save @ (setq R (safe (adds R @))))...
  br label %$19
$19:
  %119 = phi i64 [%117, %$17], [%210, %$26] ; # X
  %120 = phi i64 [%118, %$17], [%211, %$26] ; # R
; # (when (num? (evList E)) (save @ (setq R (safe (adds R @)))))
; # (evList E)
  %121 = call i64 @evList(i64 %25)
; # (num? (evList E))
  %122 = and i64 %121, 6
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$20, label %$21
$20:
  %124 = phi i64 [%119, %$19] ; # X
  %125 = phi i64 [%120, %$19] ; # R
; # (save @ (setq R (safe (adds R @))))
  %126 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %127 = load i64, i64* %126
  %128 = alloca i64, i64 2, align 16
  %129 = ptrtoint i64* %128 to i64
  %130 = inttoptr i64 %129 to i64*
  store i64 %121, i64* %130
  %131 = add i64 %129, 8
  %132 = inttoptr i64 %131 to i64*
  store i64 %127, i64* %132
  %133 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %129, i64* %133
; # (adds R @)
  %134 = call i64 @adds(i64 %125, i64 %121)
; # (safe (adds R @))
  %135 = inttoptr i64 %7 to i64*
  store i64 %134, i64* %135
; # drop
  %136 = inttoptr i64 %129 to i64*
  %137 = getelementptr i64, i64* %136, i32 1
  %138 = load i64, i64* %137
  %139 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %138, i64* %139
  br label %$21
$21:
  %140 = phi i64 [%119, %$19], [%124, %$20] ; # X
  %141 = phi i64 [%120, %$19], [%134, %$20] ; # R
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %142 = inttoptr i64 %33 to i64*
  %143 = load i64, i64* %142
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %33 to i64*
  store i64 %146, i64* %147
; # (atom (set A (cdar A)))
  %148 = and i64 %146, 15
  %149 = icmp ne i64 %148, 0
  br i1 %149, label %$23, label %$22
$22:
  %150 = phi i64 [%140, %$21] ; # X
  %151 = phi i64 [%141, %$21] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %152 = inttoptr i64 %25 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
; # (set 4 P (car @))
; # (car @)
  %155 = inttoptr i64 %146 to i64*
  %156 = load i64, i64* %155
  %157 = inttoptr i64 %154 to i64*
  %158 = getelementptr i64, i64* %157, i32 3
  store i64 %156, i64* %158
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %159 = phi i64 [%150, %$22], [%203, %$27] ; # X
  %160 = phi i64 [%151, %$22], [%204, %$27] ; # R
  %161 = phi i64 [%154, %$22], [%205, %$27] ; # P
  %162 = phi i64 [%33, %$22], [%206, %$27] ; # Q
; # (shift P)
  %163 = inttoptr i64 %161 to i64*
  %164 = getelementptr i64, i64* %163, i32 1
  %165 = load i64, i64* %164
; # (pair (shift P))
  %166 = and i64 %165, 15
  %167 = icmp eq i64 %166, 0
  br i1 %167, label %$25, label %$26
$25:
  %168 = phi i64 [%159, %$24] ; # X
  %169 = phi i64 [%160, %$24] ; # R
  %170 = phi i64 [%165, %$24] ; # P
  %171 = phi i64 [%162, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %172 = inttoptr i64 %171 to i64*
  %173 = getelementptr i64, i64* %172, i32 1
  %174 = load i64, i64* %173
; # (car (shift Q))
  %175 = inttoptr i64 %174 to i64*
  %176 = load i64, i64* %175
; # (atom (car (shift Q)))
  %177 = and i64 %176, 15
  %178 = icmp ne i64 %177, 0
  br i1 %178, label %$29, label %$28
$29:
  %179 = phi i64 [%168, %$25] ; # X
  %180 = phi i64 [%169, %$25] ; # R
  %181 = phi i64 [%170, %$25] ; # P
  %182 = phi i64 [%174, %$25] ; # Q
  br label %$27
$28:
  %183 = phi i64 [%168, %$25] ; # X
  %184 = phi i64 [%169, %$25] ; # R
  %185 = phi i64 [%170, %$25] ; # P
  %186 = phi i64 [%174, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %187 = inttoptr i64 %176 to i64*
  %188 = getelementptr i64, i64* %187, i32 1
  %189 = load i64, i64* %188
  %190 = inttoptr i64 %186 to i64*
  store i64 %189, i64* %190
; # (atom (set Q (cdr @)))
  %191 = and i64 %189, 15
  %192 = icmp ne i64 %191, 0
  br i1 %192, label %$31, label %$30
$31:
  %193 = phi i64 [%183, %$28] ; # X
  %194 = phi i64 [%184, %$28] ; # R
  %195 = phi i64 [%185, %$28] ; # P
  %196 = phi i64 [%186, %$28] ; # Q
  br label %$27
$30:
  %197 = phi i64 [%183, %$28] ; # X
  %198 = phi i64 [%184, %$28] ; # R
  %199 = phi i64 [%185, %$28] ; # P
  %200 = phi i64 [%186, %$28] ; # Q
; # (car @)
  %201 = inttoptr i64 %189 to i64*
  %202 = load i64, i64* %201
  br label %$27
$27:
  %203 = phi i64 [%179, %$29], [%193, %$31], [%197, %$30] ; # X
  %204 = phi i64 [%180, %$29], [%194, %$31], [%198, %$30] ; # R
  %205 = phi i64 [%181, %$29], [%195, %$31], [%199, %$30] ; # P
  %206 = phi i64 [%182, %$29], [%196, %$31], [%200, %$30] ; # Q
  %207 = phi i64 [%176, %$29], [%189, %$31], [%202, %$30] ; # ->
  %208 = inttoptr i64 %170 to i64*
  %209 = getelementptr i64, i64* %208, i32 3
  store i64 %207, i64* %209
  br label %$24
$26:
  %210 = phi i64 [%159, %$24] ; # X
  %211 = phi i64 [%160, %$24] ; # R
  %212 = phi i64 [%165, %$24] ; # P
  %213 = phi i64 [%162, %$24] ; # Q
  br label %$19
$23:
  %214 = phi i64 [%140, %$21] ; # X
  %215 = phi i64 [%141, %$21] ; # R
  %216 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %217 = phi i64 [%108, %$16], [%214, %$23] ; # X
  %218 = phi i64 [%109, %$16], [%215, %$23] ; # R
; # (drop *Safe)
  %219 = inttoptr i64 %7 to i64*
  %220 = getelementptr i64, i64* %219, i32 1
  %221 = load i64, i64* %220
  %222 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %221, i64* %222
  ret i64 %218
}

define i64 @_maxi(i64) align 8 {
$1:
; # (let (X (cdr Exe) R $Nil R2 (save $Nil) E (push NIL $Nil ZERO (ev...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%105, %$15] ; # R2
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = alloca i64, i64 2, align 16
  %59 = ptrtoint i64* %58 to i64
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = add i64 %59, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # R2
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # R2
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # R2
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # R2
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (evList E) (when (gt0 (compare ...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # R2
; # (loop (let Y (evList E) (when (gt0 (compare Y R2)) (setq R (caar ...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%218, %$26] ; # X
  %126 = phi i64 [%123, %$17], [%219, %$26] ; # R
  %127 = phi i64 [%124, %$17], [%220, %$26] ; # R2
; # (let Y (evList E) (when (gt0 (compare Y R2)) (setq R (caar A)) (s...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (when (gt0 (compare Y R2)) (setq R (caar A)) (setq R2 (safe Y)))
; # (compare Y R2)
  %129 = call i64 @compare(i64 %128, i64 %127)
; # (gt0 (compare Y R2))
  %130 = icmp sgt i64 %129, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # R2
; # (caar A)
  %134 = inttoptr i64 %33 to i64*
  %135 = load i64, i64* %134
  %136 = inttoptr i64 %135 to i64*
  %137 = load i64, i64* %136
; # (safe Y)
  %138 = inttoptr i64 %7 to i64*
  store i64 %128, i64* %138
  br label %$21
$21:
  %139 = phi i64 [%125, %$19], [%131, %$20] ; # X
  %140 = phi i64 [%126, %$19], [%137, %$20] ; # R
  %141 = phi i64 [%127, %$19], [%128, %$20] ; # R2
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %142 = inttoptr i64 %33 to i64*
  %143 = load i64, i64* %142
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %33 to i64*
  store i64 %146, i64* %147
; # (atom (set A (cdar A)))
  %148 = and i64 %146, 15
  %149 = icmp ne i64 %148, 0
  br i1 %149, label %$23, label %$22
$22:
  %150 = phi i64 [%139, %$21] ; # X
  %151 = phi i64 [%140, %$21] ; # R
  %152 = phi i64 [%141, %$21] ; # R2
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %153 = inttoptr i64 %25 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
; # (set 4 P (car @))
; # (car @)
  %156 = inttoptr i64 %146 to i64*
  %157 = load i64, i64* %156
  %158 = inttoptr i64 %155 to i64*
  %159 = getelementptr i64, i64* %158, i32 3
  store i64 %157, i64* %159
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %160 = phi i64 [%150, %$22], [%210, %$27] ; # X
  %161 = phi i64 [%151, %$22], [%211, %$27] ; # R
  %162 = phi i64 [%152, %$22], [%212, %$27] ; # R2
  %163 = phi i64 [%155, %$22], [%213, %$27] ; # P
  %164 = phi i64 [%33, %$22], [%214, %$27] ; # Q
; # (shift P)
  %165 = inttoptr i64 %163 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
; # (pair (shift P))
  %168 = and i64 %167, 15
  %169 = icmp eq i64 %168, 0
  br i1 %169, label %$25, label %$26
$25:
  %170 = phi i64 [%160, %$24] ; # X
  %171 = phi i64 [%161, %$24] ; # R
  %172 = phi i64 [%162, %$24] ; # R2
  %173 = phi i64 [%167, %$24] ; # P
  %174 = phi i64 [%164, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %175 = inttoptr i64 %174 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  %177 = load i64, i64* %176
; # (car (shift Q))
  %178 = inttoptr i64 %177 to i64*
  %179 = load i64, i64* %178
; # (atom (car (shift Q)))
  %180 = and i64 %179, 15
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$29, label %$28
$29:
  %182 = phi i64 [%170, %$25] ; # X
  %183 = phi i64 [%171, %$25] ; # R
  %184 = phi i64 [%172, %$25] ; # R2
  %185 = phi i64 [%173, %$25] ; # P
  %186 = phi i64 [%177, %$25] ; # Q
  br label %$27
$28:
  %187 = phi i64 [%170, %$25] ; # X
  %188 = phi i64 [%171, %$25] ; # R
  %189 = phi i64 [%172, %$25] ; # R2
  %190 = phi i64 [%173, %$25] ; # P
  %191 = phi i64 [%177, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %192 = inttoptr i64 %179 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
  %195 = inttoptr i64 %191 to i64*
  store i64 %194, i64* %195
; # (atom (set Q (cdr @)))
  %196 = and i64 %194, 15
  %197 = icmp ne i64 %196, 0
  br i1 %197, label %$31, label %$30
$31:
  %198 = phi i64 [%187, %$28] ; # X
  %199 = phi i64 [%188, %$28] ; # R
  %200 = phi i64 [%189, %$28] ; # R2
  %201 = phi i64 [%190, %$28] ; # P
  %202 = phi i64 [%191, %$28] ; # Q
  br label %$27
$30:
  %203 = phi i64 [%187, %$28] ; # X
  %204 = phi i64 [%188, %$28] ; # R
  %205 = phi i64 [%189, %$28] ; # R2
  %206 = phi i64 [%190, %$28] ; # P
  %207 = phi i64 [%191, %$28] ; # Q
; # (car @)
  %208 = inttoptr i64 %194 to i64*
  %209 = load i64, i64* %208
  br label %$27
$27:
  %210 = phi i64 [%182, %$29], [%198, %$31], [%203, %$30] ; # X
  %211 = phi i64 [%183, %$29], [%199, %$31], [%204, %$30] ; # R
  %212 = phi i64 [%184, %$29], [%200, %$31], [%205, %$30] ; # R2
  %213 = phi i64 [%185, %$29], [%201, %$31], [%206, %$30] ; # P
  %214 = phi i64 [%186, %$29], [%202, %$31], [%207, %$30] ; # Q
  %215 = phi i64 [%179, %$29], [%194, %$31], [%209, %$30] ; # ->
  %216 = inttoptr i64 %173 to i64*
  %217 = getelementptr i64, i64* %216, i32 3
  store i64 %215, i64* %217
  br label %$24
$26:
  %218 = phi i64 [%160, %$24] ; # X
  %219 = phi i64 [%161, %$24] ; # R
  %220 = phi i64 [%162, %$24] ; # R2
  %221 = phi i64 [%167, %$24] ; # P
  %222 = phi i64 [%164, %$24] ; # Q
  br label %$19
$23:
  %223 = phi i64 [%139, %$21] ; # X
  %224 = phi i64 [%140, %$21] ; # R
  %225 = phi i64 [%141, %$21] ; # R2
  %226 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %227 = phi i64 [%112, %$16], [%223, %$23] ; # X
  %228 = phi i64 [%113, %$16], [%224, %$23] ; # R
  %229 = phi i64 [%114, %$16], [%225, %$23] ; # R2
; # (set $At2 R2)
  %230 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %229, i64* %230
; # (drop *Safe)
  %231 = inttoptr i64 %7 to i64*
  %232 = getelementptr i64, i64* %231, i32 1
  %233 = load i64, i64* %232
  %234 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %233, i64* %234
  ret i64 %228
}

define i64 @_mini(i64) align 8 {
$1:
; # (let (X (cdr Exe) R $Nil R2 (save $T) E (push NIL $Nil ZERO (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $T)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$2], [%105, %$15] ; # R2
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = alloca i64, i64 2, align 16
  %59 = ptrtoint i64* %58 to i64
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = add i64 %59, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # R2
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # R2
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # R2
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # R2
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (evList E) (when (lt0 (compare ...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # R2
; # (loop (let Y (evList E) (when (lt0 (compare Y R2)) (setq R (caar ...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%218, %$26] ; # X
  %126 = phi i64 [%123, %$17], [%219, %$26] ; # R
  %127 = phi i64 [%124, %$17], [%220, %$26] ; # R2
; # (let Y (evList E) (when (lt0 (compare Y R2)) (setq R (caar A)) (s...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (when (lt0 (compare Y R2)) (setq R (caar A)) (setq R2 (safe Y)))
; # (compare Y R2)
  %129 = call i64 @compare(i64 %128, i64 %127)
; # (lt0 (compare Y R2))
  %130 = icmp slt i64 %129, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # R2
; # (caar A)
  %134 = inttoptr i64 %33 to i64*
  %135 = load i64, i64* %134
  %136 = inttoptr i64 %135 to i64*
  %137 = load i64, i64* %136
; # (safe Y)
  %138 = inttoptr i64 %7 to i64*
  store i64 %128, i64* %138
  br label %$21
$21:
  %139 = phi i64 [%125, %$19], [%131, %$20] ; # X
  %140 = phi i64 [%126, %$19], [%137, %$20] ; # R
  %141 = phi i64 [%127, %$19], [%128, %$20] ; # R2
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %142 = inttoptr i64 %33 to i64*
  %143 = load i64, i64* %142
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %33 to i64*
  store i64 %146, i64* %147
; # (atom (set A (cdar A)))
  %148 = and i64 %146, 15
  %149 = icmp ne i64 %148, 0
  br i1 %149, label %$23, label %$22
$22:
  %150 = phi i64 [%139, %$21] ; # X
  %151 = phi i64 [%140, %$21] ; # R
  %152 = phi i64 [%141, %$21] ; # R2
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %153 = inttoptr i64 %25 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
; # (set 4 P (car @))
; # (car @)
  %156 = inttoptr i64 %146 to i64*
  %157 = load i64, i64* %156
  %158 = inttoptr i64 %155 to i64*
  %159 = getelementptr i64, i64* %158, i32 3
  store i64 %157, i64* %159
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %160 = phi i64 [%150, %$22], [%210, %$27] ; # X
  %161 = phi i64 [%151, %$22], [%211, %$27] ; # R
  %162 = phi i64 [%152, %$22], [%212, %$27] ; # R2
  %163 = phi i64 [%155, %$22], [%213, %$27] ; # P
  %164 = phi i64 [%33, %$22], [%214, %$27] ; # Q
; # (shift P)
  %165 = inttoptr i64 %163 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
; # (pair (shift P))
  %168 = and i64 %167, 15
  %169 = icmp eq i64 %168, 0
  br i1 %169, label %$25, label %$26
$25:
  %170 = phi i64 [%160, %$24] ; # X
  %171 = phi i64 [%161, %$24] ; # R
  %172 = phi i64 [%162, %$24] ; # R2
  %173 = phi i64 [%167, %$24] ; # P
  %174 = phi i64 [%164, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %175 = inttoptr i64 %174 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  %177 = load i64, i64* %176
; # (car (shift Q))
  %178 = inttoptr i64 %177 to i64*
  %179 = load i64, i64* %178
; # (atom (car (shift Q)))
  %180 = and i64 %179, 15
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$29, label %$28
$29:
  %182 = phi i64 [%170, %$25] ; # X
  %183 = phi i64 [%171, %$25] ; # R
  %184 = phi i64 [%172, %$25] ; # R2
  %185 = phi i64 [%173, %$25] ; # P
  %186 = phi i64 [%177, %$25] ; # Q
  br label %$27
$28:
  %187 = phi i64 [%170, %$25] ; # X
  %188 = phi i64 [%171, %$25] ; # R
  %189 = phi i64 [%172, %$25] ; # R2
  %190 = phi i64 [%173, %$25] ; # P
  %191 = phi i64 [%177, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %192 = inttoptr i64 %179 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
  %195 = inttoptr i64 %191 to i64*
  store i64 %194, i64* %195
; # (atom (set Q (cdr @)))
  %196 = and i64 %194, 15
  %197 = icmp ne i64 %196, 0
  br i1 %197, label %$31, label %$30
$31:
  %198 = phi i64 [%187, %$28] ; # X
  %199 = phi i64 [%188, %$28] ; # R
  %200 = phi i64 [%189, %$28] ; # R2
  %201 = phi i64 [%190, %$28] ; # P
  %202 = phi i64 [%191, %$28] ; # Q
  br label %$27
$30:
  %203 = phi i64 [%187, %$28] ; # X
  %204 = phi i64 [%188, %$28] ; # R
  %205 = phi i64 [%189, %$28] ; # R2
  %206 = phi i64 [%190, %$28] ; # P
  %207 = phi i64 [%191, %$28] ; # Q
; # (car @)
  %208 = inttoptr i64 %194 to i64*
  %209 = load i64, i64* %208
  br label %$27
$27:
  %210 = phi i64 [%182, %$29], [%198, %$31], [%203, %$30] ; # X
  %211 = phi i64 [%183, %$29], [%199, %$31], [%204, %$30] ; # R
  %212 = phi i64 [%184, %$29], [%200, %$31], [%205, %$30] ; # R2
  %213 = phi i64 [%185, %$29], [%201, %$31], [%206, %$30] ; # P
  %214 = phi i64 [%186, %$29], [%202, %$31], [%207, %$30] ; # Q
  %215 = phi i64 [%179, %$29], [%194, %$31], [%209, %$30] ; # ->
  %216 = inttoptr i64 %173 to i64*
  %217 = getelementptr i64, i64* %216, i32 3
  store i64 %215, i64* %217
  br label %$24
$26:
  %218 = phi i64 [%160, %$24] ; # X
  %219 = phi i64 [%161, %$24] ; # R
  %220 = phi i64 [%162, %$24] ; # R2
  %221 = phi i64 [%167, %$24] ; # P
  %222 = phi i64 [%164, %$24] ; # Q
  br label %$19
$23:
  %223 = phi i64 [%139, %$21] ; # X
  %224 = phi i64 [%140, %$21] ; # R
  %225 = phi i64 [%141, %$21] ; # R2
  %226 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %227 = phi i64 [%112, %$16], [%223, %$23] ; # X
  %228 = phi i64 [%113, %$16], [%224, %$23] ; # R
  %229 = phi i64 [%114, %$16], [%225, %$23] ; # R2
; # (set $At2 R2)
  %230 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %229, i64* %230
; # (drop *Safe)
  %231 = inttoptr i64 %7 to i64*
  %232 = getelementptr i64, i64* %231, i32 1
  %233 = load i64, i64* %232
  %234 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %233, i64* %234
  ret i64 %228
}

define void @fish(i64, i64, i64, i64, i64) align 8 {
$1:
; # (set P V)
  %5 = inttoptr i64 %2 to i64*
  store i64 %1, i64* %5
; # (cond ((nil? (evList E)) (when (pair V) (stkChk 0) (unless (nil? ...
; # (evList E)
  %6 = call i64 @evList(i64 %0)
; # (nil? (evList E))
  %7 = icmp eq i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %7, label %$4, label %$3
$4:
; # (when (pair V) (stkChk 0) (unless (nil? (cdr V)) (fish E @ P R S)...
; # (pair V)
  %8 = and i64 %1, 15
  %9 = icmp eq i64 %8, 0
  br i1 %9, label %$5, label %$6
$5:
; # (stkChk 0)
  %10 = load i8*, i8** @$StkLimit
  %11 = call i8* @llvm.stacksave()
  %12 = icmp ugt i8* %10, %11
  br i1 %12, label %$7, label %$8
$7:
  call void @stkErr(i64 0)
  unreachable
$8:
; # (unless (nil? (cdr V)) (fish E @ P R S))
; # (cdr V)
  %13 = inttoptr i64 %1 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (nil? (cdr V))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$10, label %$9
$9:
; # (fish E @ P R S)
  call void @fish(i64 %0, i64 %15, i64 %2, i64 %3, i64 %4)
  br label %$10
$10:
; # (car V)
  %17 = inttoptr i64 %1 to i64*
  %18 = load i64, i64* %17
; # (fish E (car V) P R S)
  call void @fish(i64 %0, i64 %18, i64 %2, i64 %3, i64 %4)
  br label %$6
$6:
  br label %$2
$3:
; # (<> @ S)
  %19 = icmp ne i64 %6, %4
  br i1 %19, label %$12, label %$11
$12:
; # (set R (cons V (val R)))
; # (val R)
  %20 = inttoptr i64 %3 to i64*
  %21 = load i64, i64* %20
; # (cons V (val R))
  %22 = call i64 @cons(i64 %1, i64 %21)
  %23 = inttoptr i64 %3 to i64*
  store i64 %22, i64* %23
  br label %$2
$11:
  br label %$2
$2:
  ret void
}

define i64 @_fish(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (link (push $Nil NIL) T) P (push NIL $Nil ZER...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (push $Nil NIL)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
; # (link (push $Nil NIL) T)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (push NIL $Nil ZERO NIL)
  %12 = alloca i64, i64 4, align 16
  %13 = ptrtoint i64* %12 to i64
  %14 = add i64 %13, 8
  %15 = inttoptr i64 %14 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %15
  %16 = add i64 %13, 16
  %17 = inttoptr i64 %16 to i64*
  store i64 2, i64* %17
; # (++ X)
  %18 = inttoptr i64 %3 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
; # (eval (++ X))
  %22 = and i64 %19, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$4, label %$3
$4:
  br label %$2
$3:
  %24 = and i64 %19, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$6, label %$5
$6:
  %26 = inttoptr i64 %19 to i64*
  %27 = load i64, i64* %26
  br label %$2
$5:
  %28 = call i64 @evList(i64 %19)
  br label %$2
$2:
  %29 = phi i64 [%19, %$4], [%27, %$6], [%28, %$5] ; # ->
; # (push NIL P ZERO (eval (++ X)) NIL)
  %30 = alloca i64, i64 5, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = add i64 %31, 8
  %33 = inttoptr i64 %32 to i64*
  store i64 %13, i64* %33
  %34 = add i64 %31, 16
  %35 = inttoptr i64 %34 to i64*
  store i64 2, i64* %35
  %36 = add i64 %31, 24
  %37 = inttoptr i64 %36 to i64*
  store i64 %29, i64* %37
; # (set P (ofs P 3) E (link (ofs E 3)))
; # (ofs P 3)
  %38 = add i64 %13, 24
  %39 = inttoptr i64 %13 to i64*
  store i64 %38, i64* %39
; # (ofs E 3)
  %40 = add i64 %31, 24
; # (link (ofs E 3))
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %42 = load i64, i64* %41
  %43 = inttoptr i64 %40 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %42, i64* %44
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %45
  %46 = inttoptr i64 %31 to i64*
  store i64 %40, i64* %46
; # (let (V (save (eval (++ X))) S (save (eval (car X))) Q P) (while ...
; # (++ X)
  %47 = inttoptr i64 %21 to i64*
  %48 = load i64, i64* %47
  %49 = getelementptr i64, i64* %47, i32 1
  %50 = load i64, i64* %49
; # (eval (++ X))
  %51 = and i64 %48, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$9, label %$8
$9:
  br label %$7
$8:
  %53 = and i64 %48, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$11, label %$10
$11:
  %55 = inttoptr i64 %48 to i64*
  %56 = load i64, i64* %55
  br label %$7
$10:
  %57 = call i64 @evList(i64 %48)
  br label %$7
$7:
  %58 = phi i64 [%48, %$9], [%56, %$11], [%57, %$10] ; # ->
; # (save (eval (++ X)))
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = alloca i64, i64 2, align 16
  %62 = ptrtoint i64* %61 to i64
  %63 = inttoptr i64 %62 to i64*
  store i64 %58, i64* %63
  %64 = add i64 %62, 8
  %65 = inttoptr i64 %64 to i64*
  store i64 %60, i64* %65
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %62, i64* %66
; # (car X)
  %67 = inttoptr i64 %50 to i64*
  %68 = load i64, i64* %67
; # (eval (car X))
  %69 = and i64 %68, 6
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$14, label %$13
$14:
  br label %$12
$13:
  %71 = and i64 %68, 8
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$16, label %$15
$16:
  %73 = inttoptr i64 %68 to i64*
  %74 = load i64, i64* %73
  br label %$12
$15:
  %75 = call i64 @evList(i64 %68)
  br label %$12
$12:
  %76 = phi i64 [%68, %$14], [%74, %$16], [%75, %$15] ; # ->
; # (save (eval (car X)))
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %78 = load i64, i64* %77
  %79 = alloca i64, i64 2, align 16
  %80 = ptrtoint i64* %79 to i64
  %81 = inttoptr i64 %80 to i64*
  store i64 %76, i64* %81
  %82 = add i64 %80, 8
  %83 = inttoptr i64 %82 to i64*
  store i64 %78, i64* %83
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %84
; # (while (pair (shift X)) (setq Q (set 2 Q (push NIL $Nil ZERO (eva...
  br label %$17
$17:
  %85 = phi i64 [%50, %$12], [%92, %$20] ; # X
  %86 = phi i64 [%13, %$12], [%105, %$20] ; # Q
; # (shift X)
  %87 = inttoptr i64 %85 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
; # (pair (shift X))
  %90 = and i64 %89, 15
  %91 = icmp eq i64 %90, 0
  br i1 %91, label %$18, label %$19
$18:
  %92 = phi i64 [%89, %$17] ; # X
  %93 = phi i64 [%86, %$17] ; # Q
; # (set 2 Q (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %94 = inttoptr i64 %92 to i64*
  %95 = load i64, i64* %94
; # (eval (car X))
  %96 = and i64 %95, 6
  %97 = icmp ne i64 %96, 0
  br i1 %97, label %$22, label %$21
$22:
  br label %$20
$21:
  %98 = and i64 %95, 8
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$24, label %$23
$24:
  %100 = inttoptr i64 %95 to i64*
  %101 = load i64, i64* %100
  br label %$20
$23:
  %102 = call i64 @evList(i64 %95)
  br label %$20
$20:
  %103 = phi i64 [%95, %$22], [%101, %$24], [%102, %$23] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %104 = alloca i64, i64 5, align 16
  %105 = ptrtoint i64* %104 to i64
  %106 = add i64 %105, 8
  %107 = inttoptr i64 %106 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %107
  %108 = add i64 %105, 16
  %109 = inttoptr i64 %108 to i64*
  store i64 2, i64* %109
  %110 = add i64 %105, 24
  %111 = inttoptr i64 %110 to i64*
  store i64 %103, i64* %111
  %112 = inttoptr i64 %93 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  store i64 %105, i64* %113
; # (set Q (link (ofs Q 3)))
; # (ofs Q 3)
  %114 = add i64 %105, 24
; # (link (ofs Q 3))
  %115 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %116 = load i64, i64* %115
  %117 = inttoptr i64 %114 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  store i64 %116, i64* %118
  %119 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %114, i64* %119
  %120 = inttoptr i64 %105 to i64*
  store i64 %114, i64* %120
  br label %$17
$19:
  %121 = phi i64 [%89, %$17] ; # X
  %122 = phi i64 [%86, %$17] ; # Q
; # (ofs P 3)
  %123 = add i64 %13, 24
; # (fish E V (ofs P 3) R S)
  call void @fish(i64 %31, i64 %58, i64 %123, i64 %5, i64 %76)
; # (val R)
  %124 = inttoptr i64 %5 to i64*
  %125 = load i64, i64* %124
; # (drop *Safe)
  %126 = inttoptr i64 %5 to i64*
  %127 = getelementptr i64, i64* %126, i32 1
  %128 = load i64, i64* %127
  %129 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %128, i64* %129
  ret i64 %125
}

define i64 @_by(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (++ X)
  %34 = inttoptr i64 %15 to i64*
  %35 = load i64, i64* %34
  %36 = getelementptr i64, i64* %34, i32 1
  %37 = load i64, i64* %36
; # (eval (++ X))
  %38 = and i64 %35, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$9, label %$8
$9:
  br label %$7
$8:
  %40 = and i64 %35, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$11, label %$10
$11:
  %42 = inttoptr i64 %35 to i64*
  %43 = load i64, i64* %42
  br label %$7
$10:
  %44 = call i64 @evList(i64 %35)
  br label %$7
$7:
  %45 = phi i64 [%35, %$9], [%43, %$11], [%44, %$10] ; # ->
; # (save (eval (++ X)))
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %47 = load i64, i64* %46
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %45, i64* %50
  %51 = add i64 %49, 8
  %52 = inttoptr i64 %51 to i64*
  store i64 %47, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %53
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %54 = add i64 %25, 24
; # (link (ofs E 3))
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %54 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %59
  %60 = inttoptr i64 %25 to i64*
  store i64 %54, i64* %60
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$12
$12:
  %61 = phi i64 [%37, %$7], [%123, %$20] ; # X
  %62 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%124, %$20] ; # R
  %63 = phi i64 [0, %$7], [%125, %$20] ; # L
  %64 = phi i64 [%25, %$7], [%126, %$20] ; # P
  %65 = phi i64 [%33, %$7], [%129, %$20] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %66 = inttoptr i64 %61 to i64*
  %67 = load i64, i64* %66
; # (eval (car X))
  %68 = and i64 %67, 6
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$15, label %$14
$15:
  br label %$13
$14:
  %70 = and i64 %67, 8
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$17, label %$16
$17:
  %72 = inttoptr i64 %67 to i64*
  %73 = load i64, i64* %72
  br label %$13
$16:
  %74 = call i64 @evList(i64 %67)
  br label %$13
$13:
  %75 = phi i64 [%67, %$15], [%73, %$17], [%74, %$16] ; # ->
; # (save (eval (car X)))
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %77 = load i64, i64* %76
  %78 = alloca i64, i64 2, align 16
  %79 = ptrtoint i64* %78 to i64
  %80 = inttoptr i64 %79 to i64*
  store i64 %75, i64* %80
  %81 = add i64 %79, 8
  %82 = inttoptr i64 %81 to i64*
  store i64 %77, i64* %82
  %83 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %79, i64* %83
  %84 = inttoptr i64 %65 to i64*
  store i64 %75, i64* %84
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %85 = and i64 %75, 15
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$18, label %$19
$18:
  %87 = phi i64 [%61, %$13] ; # X
  %88 = phi i64 [%62, %$13] ; # R
  %89 = phi i64 [%63, %$13] ; # L
  %90 = phi i64 [%64, %$13] ; # P
  %91 = phi i64 [%65, %$13] ; # Q
  %92 = phi i64 [%75, %$13] ; # V
; # (car V)
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
  br label %$19
$19:
  %95 = phi i64 [%61, %$13], [%87, %$18] ; # X
  %96 = phi i64 [%62, %$13], [%88, %$18] ; # R
  %97 = phi i64 [%63, %$13], [%89, %$18] ; # L
  %98 = phi i64 [%64, %$13], [%90, %$18] ; # P
  %99 = phi i64 [%65, %$13], [%91, %$18] ; # Q
  %100 = phi i64 [%75, %$13], [%94, %$18] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %101 = alloca i64, i64 5, align 16
  %102 = ptrtoint i64* %101 to i64
  %103 = add i64 %102, 8
  %104 = inttoptr i64 %103 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %104
  %105 = add i64 %102, 16
  %106 = inttoptr i64 %105 to i64*
  store i64 2, i64* %106
  %107 = add i64 %102, 24
  %108 = inttoptr i64 %107 to i64*
  store i64 %100, i64* %108
  %109 = inttoptr i64 %98 to i64*
  %110 = getelementptr i64, i64* %109, i32 1
  store i64 %102, i64* %110
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %111 = add i64 %102, 24
; # (link (ofs P 3))
  %112 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %113 = load i64, i64* %112
  %114 = inttoptr i64 %111 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  store i64 %113, i64* %115
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %111, i64* %116
  %117 = inttoptr i64 %102 to i64*
  store i64 %111, i64* %117
; # (? (atom (shift X)))
; # (shift X)
  %118 = inttoptr i64 %95 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
; # (atom (shift X))
  %121 = and i64 %120, 15
  %122 = icmp ne i64 %121, 0
  br i1 %122, label %$21, label %$20
$20:
  %123 = phi i64 [%120, %$19] ; # X
  %124 = phi i64 [%96, %$19] ; # R
  %125 = phi i64 [%97, %$19] ; # L
  %126 = phi i64 [%102, %$19] ; # P
  %127 = phi i64 [%99, %$19] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %128 = alloca i64, i64 2, align 16
  %129 = ptrtoint i64* %128 to i64
  %130 = inttoptr i64 %127 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  store i64 %129, i64* %131
  br label %$12
$21:
  %132 = phi i64 [%120, %$19] ; # X
  %133 = phi i64 [%96, %$19] ; # R
  %134 = phi i64 [%97, %$19] ; # L
  %135 = phi i64 [%102, %$19] ; # P
  %136 = phi i64 [%99, %$19] ; # Q
  %137 = phi i64 [0, %$19] ; # ->
; # (when (pair (car A)) (loop (let Y (cons (cons (evList E) (caar A)...
; # (car A)
  %138 = inttoptr i64 %33 to i64*
  %139 = load i64, i64* %138
; # (pair (car A))
  %140 = and i64 %139, 15
  %141 = icmp eq i64 %140, 0
  br i1 %141, label %$22, label %$23
$22:
  %142 = phi i64 [%132, %$21] ; # X
  %143 = phi i64 [%133, %$21] ; # R
  %144 = phi i64 [%134, %$21] ; # L
; # (loop (let Y (cons (cons (evList E) (caar A)) $Nil) (setq L (if L...
  br label %$24
$24:
  %145 = phi i64 [%142, %$22], [%245, %$32] ; # X
  %146 = phi i64 [%143, %$22], [%246, %$32] ; # R
  %147 = phi i64 [%144, %$22], [%247, %$32] ; # L
; # (let Y (cons (cons (evList E) (caar A)) $Nil) (setq L (if L (set ...
; # (evList E)
  %148 = call i64 @evList(i64 %25)
; # (caar A)
  %149 = inttoptr i64 %33 to i64*
  %150 = load i64, i64* %149
  %151 = inttoptr i64 %150 to i64*
  %152 = load i64, i64* %151
; # (cons (evList E) (caar A))
  %153 = call i64 @cons(i64 %148, i64 %152)
; # (cons (cons (evList E) (caar A)) $Nil)
  %154 = call i64 @cons(i64 %153, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %155 = icmp ne i64 %147, 0
  br i1 %155, label %$25, label %$26
$25:
  %156 = phi i64 [%145, %$24] ; # X
  %157 = phi i64 [%146, %$24] ; # R
  %158 = phi i64 [%147, %$24] ; # L
; # (set 2 L Y)
  %159 = inttoptr i64 %158 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  store i64 %154, i64* %160
  br label %$27
$26:
  %161 = phi i64 [%145, %$24] ; # X
  %162 = phi i64 [%146, %$24] ; # R
  %163 = phi i64 [%147, %$24] ; # L
; # (safe Y)
  %164 = inttoptr i64 %7 to i64*
  store i64 %154, i64* %164
  br label %$27
$27:
  %165 = phi i64 [%156, %$25], [%161, %$26] ; # X
  %166 = phi i64 [%157, %$25], [%154, %$26] ; # R
  %167 = phi i64 [%158, %$25], [%163, %$26] ; # L
  %168 = phi i64 [%154, %$25], [%154, %$26] ; # ->
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %169 = inttoptr i64 %33 to i64*
  %170 = load i64, i64* %169
  %171 = inttoptr i64 %170 to i64*
  %172 = getelementptr i64, i64* %171, i32 1
  %173 = load i64, i64* %172
  %174 = inttoptr i64 %33 to i64*
  store i64 %173, i64* %174
; # (atom (set A (cdar A)))
  %175 = and i64 %173, 15
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$29, label %$28
$28:
  %177 = phi i64 [%165, %$27] ; # X
  %178 = phi i64 [%166, %$27] ; # R
  %179 = phi i64 [%168, %$27] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %180 = inttoptr i64 %25 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
; # (set 4 P (car @))
; # (car @)
  %183 = inttoptr i64 %173 to i64*
  %184 = load i64, i64* %183
  %185 = inttoptr i64 %182 to i64*
  %186 = getelementptr i64, i64* %185, i32 3
  store i64 %184, i64* %186
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$30
$30:
  %187 = phi i64 [%177, %$28], [%237, %$33] ; # X
  %188 = phi i64 [%178, %$28], [%238, %$33] ; # R
  %189 = phi i64 [%179, %$28], [%239, %$33] ; # L
  %190 = phi i64 [%182, %$28], [%240, %$33] ; # P
  %191 = phi i64 [%33, %$28], [%241, %$33] ; # Q
; # (shift P)
  %192 = inttoptr i64 %190 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
; # (pair (shift P))
  %195 = and i64 %194, 15
  %196 = icmp eq i64 %195, 0
  br i1 %196, label %$31, label %$32
$31:
  %197 = phi i64 [%187, %$30] ; # X
  %198 = phi i64 [%188, %$30] ; # R
  %199 = phi i64 [%189, %$30] ; # L
  %200 = phi i64 [%194, %$30] ; # P
  %201 = phi i64 [%191, %$30] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %202 = inttoptr i64 %201 to i64*
  %203 = getelementptr i64, i64* %202, i32 1
  %204 = load i64, i64* %203
; # (car (shift Q))
  %205 = inttoptr i64 %204 to i64*
  %206 = load i64, i64* %205
; # (atom (car (shift Q)))
  %207 = and i64 %206, 15
  %208 = icmp ne i64 %207, 0
  br i1 %208, label %$35, label %$34
$35:
  %209 = phi i64 [%197, %$31] ; # X
  %210 = phi i64 [%198, %$31] ; # R
  %211 = phi i64 [%199, %$31] ; # L
  %212 = phi i64 [%200, %$31] ; # P
  %213 = phi i64 [%204, %$31] ; # Q
  br label %$33
$34:
  %214 = phi i64 [%197, %$31] ; # X
  %215 = phi i64 [%198, %$31] ; # R
  %216 = phi i64 [%199, %$31] ; # L
  %217 = phi i64 [%200, %$31] ; # P
  %218 = phi i64 [%204, %$31] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %219 = inttoptr i64 %206 to i64*
  %220 = getelementptr i64, i64* %219, i32 1
  %221 = load i64, i64* %220
  %222 = inttoptr i64 %218 to i64*
  store i64 %221, i64* %222
; # (atom (set Q (cdr @)))
  %223 = and i64 %221, 15
  %224 = icmp ne i64 %223, 0
  br i1 %224, label %$37, label %$36
$37:
  %225 = phi i64 [%214, %$34] ; # X
  %226 = phi i64 [%215, %$34] ; # R
  %227 = phi i64 [%216, %$34] ; # L
  %228 = phi i64 [%217, %$34] ; # P
  %229 = phi i64 [%218, %$34] ; # Q
  br label %$33
$36:
  %230 = phi i64 [%214, %$34] ; # X
  %231 = phi i64 [%215, %$34] ; # R
  %232 = phi i64 [%216, %$34] ; # L
  %233 = phi i64 [%217, %$34] ; # P
  %234 = phi i64 [%218, %$34] ; # Q
; # (car @)
  %235 = inttoptr i64 %221 to i64*
  %236 = load i64, i64* %235
  br label %$33
$33:
  %237 = phi i64 [%209, %$35], [%225, %$37], [%230, %$36] ; # X
  %238 = phi i64 [%210, %$35], [%226, %$37], [%231, %$36] ; # R
  %239 = phi i64 [%211, %$35], [%227, %$37], [%232, %$36] ; # L
  %240 = phi i64 [%212, %$35], [%228, %$37], [%233, %$36] ; # P
  %241 = phi i64 [%213, %$35], [%229, %$37], [%234, %$36] ; # Q
  %242 = phi i64 [%206, %$35], [%221, %$37], [%236, %$36] ; # ->
  %243 = inttoptr i64 %200 to i64*
  %244 = getelementptr i64, i64* %243, i32 3
  store i64 %242, i64* %244
  br label %$30
$32:
  %245 = phi i64 [%187, %$30] ; # X
  %246 = phi i64 [%188, %$30] ; # R
  %247 = phi i64 [%189, %$30] ; # L
  %248 = phi i64 [%194, %$30] ; # P
  %249 = phi i64 [%191, %$30] ; # Q
  br label %$24
$29:
  %250 = phi i64 [%165, %$27] ; # X
  %251 = phi i64 [%166, %$27] ; # R
  %252 = phi i64 [%168, %$27] ; # L
  %253 = phi i64 [0, %$27] ; # ->
; # (set 4 E Fun2 4 (cdr E) R)
  %254 = inttoptr i64 %25 to i64*
  %255 = getelementptr i64, i64* %254, i32 3
  store i64 %45, i64* %255
; # (cdr E)
  %256 = inttoptr i64 %25 to i64*
  %257 = getelementptr i64, i64* %256, i32 1
  %258 = load i64, i64* %257
  %259 = inttoptr i64 %258 to i64*
  %260 = getelementptr i64, i64* %259, i32 3
  store i64 %251, i64* %260
; # (let Z (setq R (safe (evList E))) (loop (set Z (cdar Z)) (? (atom...
; # (evList E)
  %261 = call i64 @evList(i64 %25)
; # (safe (evList E))
  %262 = inttoptr i64 %7 to i64*
  store i64 %261, i64* %262
; # (loop (set Z (cdar Z)) (? (atom (shift Z))))
  br label %$38
$38:
  %263 = phi i64 [%250, %$29], [%278, %$39] ; # X
  %264 = phi i64 [%261, %$29], [%279, %$39] ; # R
  %265 = phi i64 [%252, %$29], [%280, %$39] ; # L
  %266 = phi i64 [%261, %$29], [%281, %$39] ; # Z
; # (set Z (cdar Z))
; # (cdar Z)
  %267 = inttoptr i64 %266 to i64*
  %268 = load i64, i64* %267
  %269 = inttoptr i64 %268 to i64*
  %270 = getelementptr i64, i64* %269, i32 1
  %271 = load i64, i64* %270
  %272 = inttoptr i64 %266 to i64*
  store i64 %271, i64* %272
; # (? (atom (shift Z)))
; # (shift Z)
  %273 = inttoptr i64 %266 to i64*
  %274 = getelementptr i64, i64* %273, i32 1
  %275 = load i64, i64* %274
; # (atom (shift Z))
  %276 = and i64 %275, 15
  %277 = icmp ne i64 %276, 0
  br i1 %277, label %$40, label %$39
$39:
  %278 = phi i64 [%263, %$38] ; # X
  %279 = phi i64 [%264, %$38] ; # R
  %280 = phi i64 [%265, %$38] ; # L
  %281 = phi i64 [%275, %$38] ; # Z
  br label %$38
$40:
  %282 = phi i64 [%263, %$38] ; # X
  %283 = phi i64 [%264, %$38] ; # R
  %284 = phi i64 [%265, %$38] ; # L
  %285 = phi i64 [%275, %$38] ; # Z
  %286 = phi i64 [0, %$38] ; # ->
  br label %$23
$23:
  %287 = phi i64 [%132, %$21], [%282, %$40] ; # X
  %288 = phi i64 [%133, %$21], [%283, %$40] ; # R
  %289 = phi i64 [%134, %$21], [%284, %$40] ; # L
; # (drop *Safe)
  %290 = inttoptr i64 %7 to i64*
  %291 = getelementptr i64, i64* %290, i32 1
  %292 = load i64, i64* %291
  %293 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %292, i64* %293
  ret i64 %288
}

define i8* @tabComplete(i8*) align 8 {
$1:
; # (if (nil? (val $Complete)) null (let (V (push NIL $Nil ZERO NIL N...
; # (val $Complete)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 840) to i64) to i64*
  %2 = load i64, i64* %1
; # (nil? (val $Complete))
  %3 = icmp eq i64 %2, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let (V (push NIL $Nil ZERO NIL NIL) E (push NIL V ZERO @ NIL)) (...
; # (push NIL $Nil ZERO NIL NIL)
  %4 = alloca i64, i64 5, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = add i64 %5, 8
  %7 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %7
  %8 = add i64 %5, 16
  %9 = inttoptr i64 %8 to i64*
  store i64 2, i64* %9
; # (push NIL V ZERO @ NIL)
  %10 = alloca i64, i64 5, align 16
  %11 = ptrtoint i64* %10 to i64
  %12 = add i64 %11, 8
  %13 = inttoptr i64 %12 to i64*
  store i64 %5, i64* %13
  %14 = add i64 %11, 16
  %15 = inttoptr i64 %14 to i64*
  store i64 2, i64* %15
  %16 = add i64 %11, 24
  %17 = inttoptr i64 %16 to i64*
  store i64 %2, i64* %17
; # (set 4 V (nond (Text $Nil) ((val Text) $T) (NIL (mkStr Text))))
; # (nond (Text $Nil) ((val Text) $T) (NIL (mkStr Text)))
  %18 = icmp ne i8* %0, null
  br i1 %18, label %$6, label %$7
$7:
  br label %$5
$6:
; # (val Text)
  %19 = load i8, i8* %0
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %$8, label %$9
$9:
  br label %$5
$8:
; # (mkStr Text)
  %21 = call i64 @mkStr(i8* %0)
  br label %$5
$5:
  %22 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$9], [%21, %$8] ; # ->
  %23 = inttoptr i64 %5 to i64*
  %24 = getelementptr i64, i64* %23, i32 3
  store i64 %22, i64* %24
; # (set V (link (ofs V 3) T) E (link (ofs E 3)))
; # (ofs V 3)
  %25 = add i64 %5, 24
; # (link (ofs V 3) T)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %25 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %27, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %30
  %31 = inttoptr i64 %5 to i64*
  store i64 %25, i64* %31
; # (ofs E 3)
  %32 = add i64 %11, 24
; # (link (ofs E 3))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %32 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %37
  %38 = inttoptr i64 %11 to i64*
  store i64 %32, i64* %38
; # (if (nil? (evList E)) null (let Nm (name (val (tail (xSym @)))) (...
; # (evList E)
  %39 = call i64 @evList(i64 %11)
; # (nil? (evList E))
  %40 = icmp eq i64 %39, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %40, label %$10, label %$11
$10:
  br label %$12
$11:
; # (let Nm (name (val (tail (xSym @)))) (strdup (bufString Nm (b8 (b...
; # (xSym @)
  %41 = call i64 @xSym(i64 %39)
; # (tail (xSym @))
  %42 = add i64 %41, -8
; # (val (tail (xSym @)))
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (name (val (tail (xSym @))))
  br label %$13
$13:
  %45 = phi i64 [%44, %$11], [%51, %$14] ; # Tail
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$15, label %$14
$14:
  %48 = phi i64 [%45, %$13] ; # Tail
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  br label %$13
$15:
  %52 = phi i64 [%45, %$13] ; # Tail
; # (bufSize Nm)
  %53 = call i64 @bufSize(i64 %52)
; # (b8 (bufSize Nm))
  %54 = alloca i8, i64 %53
; # (bufString Nm (b8 (bufSize Nm)))
  %55 = call i8* @bufString(i64 %52, i8* %54)
; # (strdup (bufString Nm (b8 (bufSize Nm))))
  %56 = call i8* @strdup(i8* %55)
  br label %$12
$12:
  %57 = phi i8* [null, %$10], [%56, %$15] ; # ->
; # (drop *Safe)
  %58 = inttoptr i64 %25 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %61
  br label %$4
$4:
  %62 = phi i8* [null, %$2], [%57, %$12] ; # ->
  ret i8* %62
}

define void @redefMsg(i64, i64) align 8 {
$1:
; # (let (Out (val $OutFile) Put (val (i8** $Put))) (set $OutFile (va...
; # (val $OutFile)
  %2 = load i8*, i8** @$OutFile
; # (i8** $Put)
  %3 = bitcast void(i8)** @$Put to i8**
; # (val (i8** $Put))
  %4 = load i8*, i8** %3
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %5 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %6 = getelementptr i8*, i8** %5, i32 2
  %7 = load i8*, i8** %6
  store i8* %7, i8** @$OutFile
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$Put
; # (outString ($ "# "))
  call void @outString(i8* bitcast ([3 x i8]* @$68 to i8*))
; # (print Sym)
  call void @print(i64 %0)
; # (when Sym2 (space) (print @))
  %8 = icmp ne i64 %1, 0
  br i1 %8, label %$2, label %$3
$2:
; # (space)
  call void @space()
; # (print @)
  call void @print(i64 %1)
  br label %$3
$3:
; # (outString ($ " redefined^J"))
  call void @outString(i8* bitcast ([12 x i8]* @$69 to i8*))
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %9 = bitcast void(i8)** @$Put to i8**
  store i8* %4, i8** %9
  store i8* %2, i8** @$OutFile
  ret void
}

define void @putSrc(i64, i64) align 8 {
$1:
; # (unless (or (nil? (val $Dbg)) (sym? (val (tail Sym)))) (let In: (...
; # (or (nil? (val $Dbg)) (sym? (val (tail Sym))))
; # (val $Dbg)
  %2 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64) to i64*
  %3 = load i64, i64* %2
; # (nil? (val $Dbg))
  %4 = icmp eq i64 %3, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %4, label %$2, label %$3
$3:
; # (tail Sym)
  %5 = add i64 %0, -8
; # (val (tail Sym))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (sym? (val (tail Sym)))
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
  br label %$2
$2:
  %10 = phi i1 [1, %$1], [%9, %$3] ; # ->
  br i1 %10, label %$5, label %$4
$4:
; # (let In: (inFile (val $InFile)) (when (and (In:) (In: name)) (let...
; # (val $InFile)
  %11 = load i8*, i8** @$InFile
; # (when (and (In:) (In: name)) (let (Dbg (get Sym $Dbg) Src (cons (...
; # (and (In:) (In: name))
; # (In:)
  %12 = icmp ne i8* %11, null
  br i1 %12, label %$7, label %$6
$7:
; # (In: name)
  %13 = bitcast i8* %11 to i8**
  %14 = load i8*, i8** %13
  %15 = icmp ne i8* %14, null
  br label %$6
$6:
  %16 = phi i1 [0, %$4], [%15, %$7] ; # ->
  br i1 %16, label %$8, label %$9
$8:
; # (let (Dbg (get Sym $Dbg) Src (cons (cnt (i64 (In: src))) (cons (m...
; # (get Sym $Dbg)
  %17 = call i64 @get(i64 %0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64))
; # (In: src)
  %18 = getelementptr i8, i8* %11, i32 20
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19
; # (i64 (In: src))
  %21 = sext i32 %20 to i64
; # (cnt (i64 (In: src)))
  %22 = shl i64 %21, 4
  %23 = or i64 %22, 2
; # (In: name)
  %24 = bitcast i8* %11 to i8**
  %25 = load i8*, i8** %24
; # (mkStr (In: name))
  %26 = call i64 @mkStr(i8* %25)
; # (val $Intern)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
; # (cons (mkStr (In: name)) (val $Intern))
  %29 = call i64 @cons(i64 %26, i64 %28)
; # (cons (cnt (i64 (In: src))) (cons (mkStr (In: name)) (val $Intern...
  %30 = call i64 @cons(i64 %23, i64 %29)
; # (cond ((=0 Key) (if (nil? Dbg) (put Sym $Dbg (cons Src $Nil)) (se...
; # (=0 Key)
  %31 = icmp eq i64 %1, 0
  br i1 %31, label %$12, label %$11
$12:
; # (if (nil? Dbg) (put Sym $Dbg (cons Src $Nil)) (set Dbg Src))
; # (nil? Dbg)
  %32 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %32, label %$13, label %$14
$13:
; # (cons Src $Nil)
  %33 = call i64 @cons(i64 %30, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (put Sym $Dbg (cons Src $Nil))
  call void @put(i64 %0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64), i64 %33)
  br label %$15
$14:
; # (set Dbg Src)
  %34 = inttoptr i64 %17 to i64*
  store i64 %30, i64* %34
  br label %$15
$15:
  br label %$10
$11:
; # (nil? Dbg)
  %35 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %35, label %$17, label %$16
$17:
; # (cons Key Src)
  %36 = call i64 @cons(i64 %1, i64 %30)
; # (cons (cons Key Src) $Nil)
  %37 = call i64 @cons(i64 %36, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Nil (cons (cons Key Src) $Nil))
  %38 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %37)
; # (put Sym $Dbg (cons $Nil (cons (cons Key Src) $Nil)))
  call void @put(i64 %0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64), i64 %38)
  br label %$10
$16:
; # (let X Dbg (loop (? (atom (shift X)) (set 2 Dbg (cons (cons Key S...
; # (loop (? (atom (shift X)) (set 2 Dbg (cons (cons Key Src) (cdr Db...
  br label %$18
$18:
  %39 = phi i64 [%17, %$16], [%64, %$22] ; # X
; # (? (atom (shift X)) (set 2 Dbg (cons (cons Key Src) (cdr Dbg))))
; # (shift X)
  %40 = inttoptr i64 %39 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
; # (atom (shift X))
  %43 = and i64 %42, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$21, label %$19
$21:
  %45 = phi i64 [%42, %$18] ; # X
; # (set 2 Dbg (cons (cons Key Src) (cdr Dbg)))
; # (cons Key Src)
  %46 = call i64 @cons(i64 %1, i64 %30)
; # (cdr Dbg)
  %47 = inttoptr i64 %17 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
; # (cons (cons Key Src) (cdr Dbg))
  %50 = call i64 @cons(i64 %46, i64 %49)
  %51 = inttoptr i64 %17 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %50, i64* %52
  br label %$20
$19:
  %53 = phi i64 [%42, %$18] ; # X
; # (? (== (caar X) Key) (set 2 (car X) Src))
; # (caar X)
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
; # (== (caar X) Key)
  %58 = icmp eq i64 %57, %1
  br i1 %58, label %$23, label %$22
$23:
  %59 = phi i64 [%53, %$19] ; # X
; # (set 2 (car X) Src)
; # (car X)
  %60 = inttoptr i64 %59 to i64*
  %61 = load i64, i64* %60
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 %30, i64* %63
  br label %$20
$22:
  %64 = phi i64 [%53, %$19] ; # X
  br label %$18
$20:
  %65 = phi i64 [%45, %$21], [%59, %$23] ; # X
  %66 = phi i64 [%50, %$21], [%30, %$23] ; # ->
  br label %$10
$10:
  br label %$9
$9:
  br label %$5
$5:
  ret void
}

define void @redefine(i64, i64, i64) align 8 {
$1:
; # (needChkVar Exe Sym)
  %3 = and i64 %1, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  call void @varErr(i64 %0, i64 %1)
  unreachable
$3:
  %5 = icmp uge i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$5, label %$4
$5:
  %6 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %1
  br label %$4
$4:
  %7 = phi i1 [0, %$3], [%6, %$5] ; # ->
  br i1 %7, label %$6, label %$7
$6:
  call void @protErr(i64 %0, i64 %1)
  unreachable
$7:
; # (let V (val Sym) (unless (or (nil? V) (== V Sym) (equal V Val)) (...
; # (val Sym)
  %8 = inttoptr i64 %1 to i64*
  %9 = load i64, i64* %8
; # (unless (or (nil? V) (== V Sym) (equal V Val)) (redefMsg Sym 0))
; # (or (nil? V) (== V Sym) (equal V Val))
; # (nil? V)
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$8, label %$9
$9:
; # (== V Sym)
  %11 = icmp eq i64 %9, %1
  br i1 %11, label %$8, label %$10
$10:
; # (equal V Val)
  %12 = call i1 @equal(i64 %9, i64 %2)
  br label %$8
$8:
  %13 = phi i1 [1, %$7], [1, %$9], [%12, %$10] ; # ->
  br i1 %13, label %$12, label %$11
$11:
; # (redefMsg Sym 0)
  call void @redefMsg(i64 %1, i64 0)
  br label %$12
$12:
; # (set Sym Val)
  %14 = inttoptr i64 %1 to i64*
  store i64 %2, i64* %14
; # (putSrc Sym 0)
  call void @putSrc(i64 %1, i64 0)
  ret void
}

define i64 @_quote(i64) align 8 {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  ret i64 %3
}

define i64 @_as(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (cdr X)))
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (cdr X))
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (cdr X)
  %15 = inttoptr i64 %3 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  br label %$9
$9:
  %18 = phi i64 [%13, %$7], [%17, %$8] ; # ->
  ret i64 %18
}

define i64 @_lit(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (or (num? X) (nil? X) (t? X) (and (p...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (num? X) (nil? X) (t? X) (and (pair X) (num? (car X)))) X...
; # (or (num? X) (nil? X) (t? X) (and (pair X) (num? (car X))))
; # (num? X)
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
; # (nil? X)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$9
$9:
; # (t? X)
  %17 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %17, label %$7, label %$10
$10:
; # (and (pair X) (num? (car X)))
; # (pair X)
  %18 = and i64 %13, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$12, label %$11
$12:
; # (car X)
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
; # (num? (car X))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br label %$11
$11:
  %24 = phi i1 [0, %$10], [%23, %$12] ; # ->
  br label %$7
$7:
  %25 = phi i1 [1, %$2], [1, %$8], [1, %$9], [%24, %$11] ; # ->
  br i1 %25, label %$13, label %$14
$13:
  br label %$15
$14:
; # (cons $Quote X)
  %26 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 264) to i64), i64 %13)
  br label %$15
$15:
  %27 = phi i64 [%13, %$13], [%26, %$14] ; # ->
  ret i64 %27
}

define i64 @_eval(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (save (eval (car X)))) (when (pair (cdr X)) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (when (pair (cdr X)) (let N (needCnt Exe (eval (car @))) (when (s...
; # (cdr X)
  %22 = inttoptr i64 %3 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (pair (cdr X))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$7, label %$8
$7:
; # (let N (needCnt Exe (eval (car @))) (when (setq N (int N)) (let B...
; # (car @)
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (eval (car @))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$11, label %$10
$11:
  br label %$9
$10:
  %31 = and i64 %28, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$13, label %$12
$13:
  %33 = inttoptr i64 %28 to i64*
  %34 = load i64, i64* %33
  br label %$9
$12:
  %35 = call i64 @evList(i64 %28)
  br label %$9
$9:
  %36 = phi i64 [%28, %$11], [%34, %$13], [%35, %$12] ; # ->
; # (needCnt Exe (eval (car @)))
  %37 = and i64 %36, 2
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$14:
  call void @cntErr(i64 %0, i64 %36)
  unreachable
$15:
; # (when (setq N (int N)) (let Bnd (val $Bind) (loop (? (=0 Bnd)) (?...
; # (int N)
  %39 = lshr i64 %36, 4
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$16, label %$17
$16:
  %41 = phi i64 [%39, %$15] ; # N
; # (let Bnd (val $Bind) (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bn...
; # (val $Bind)
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %43 = load i64, i64* %42
; # (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bnd)) (prog (set $At (v...
  br label %$18
$18:
  %44 = phi i64 [%41, %$16], [%63, %$23] ; # N
  %45 = phi i64 [%43, %$16], [%67, %$23] ; # Bnd
; # (? (=0 Bnd))
; # (=0 Bnd)
  %46 = icmp eq i64 %45, 0
  br i1 %46, label %$20, label %$19
$19:
  %47 = phi i64 [%44, %$18] ; # N
  %48 = phi i64 [%45, %$18] ; # Bnd
; # (? (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec '...
; # (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec 'N))...
; # (val 2 Bnd)
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (== $At (val 2 Bnd))
  %52 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %51
  br i1 %52, label %$22, label %$21
$22:
  %53 = phi i64 [%47, %$19] ; # N
  %54 = phi i64 [%48, %$19] ; # Bnd
; # (set $At (val Bnd))
; # (val Bnd)
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %56, i64* %57
; # (dec 'N)
  %58 = sub i64 %53, 1
; # (=0 (dec 'N))
  %59 = icmp eq i64 %58, 0
  br label %$21
$21:
  %60 = phi i64 [%47, %$19], [%58, %$22] ; # N
  %61 = phi i64 [%48, %$19], [%54, %$22] ; # Bnd
  %62 = phi i1 [0, %$19], [%59, %$22] ; # ->
  br i1 %62, label %$20, label %$23
$23:
  %63 = phi i64 [%60, %$21] ; # N
  %64 = phi i64 [%61, %$21] ; # Bnd
; # (val 3 Bnd)
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr i64, i64* %65, i32 2
  %67 = load i64, i64* %66
  br label %$18
$20:
  %68 = phi i64 [%44, %$18], [%60, %$21] ; # N
  %69 = phi i64 [%45, %$18], [%61, %$21] ; # Bnd
  %70 = phi i64 [0, %$18], [0, %$21] ; # ->
  br label %$17
$17:
  %71 = phi i64 [%39, %$15], [%68, %$20] ; # N
  br label %$8
$8:
; # (eval E)
  %72 = and i64 %13, 6
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$26, label %$25
$26:
  br label %$24
$25:
  %74 = and i64 %13, 8
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$28, label %$27
$28:
  %76 = inttoptr i64 %13 to i64*
  %77 = load i64, i64* %76
  br label %$24
$27:
  %78 = call i64 @evList(i64 %13)
  br label %$24
$24:
  %79 = phi i64 [%13, %$26], [%77, %$28], [%78, %$27] ; # ->
; # (drop *Safe)
  %80 = inttoptr i64 %17 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
  %83 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %82, i64* %83
  ret i64 %79
}

define i64 @_run(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (eval (car X))) (cond ((num? E) E) ((sym? E) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((num? E) E) ((sym? E) (val E)) (T (save E (when (pair (cdr...
; # (num? E)
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  br label %$7
$8:
; # (sym? E)
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$11, label %$10
$11:
; # (val E)
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
  br label %$7
$10:
; # (save E (when (pair (cdr X)) (let N (needCnt Exe (eval (car @))) ...
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = alloca i64, i64 2, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = inttoptr i64 %23 to i64*
  store i64 %13, i64* %24
  %25 = add i64 %23, 8
  %26 = inttoptr i64 %25 to i64*
  store i64 %21, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %27
; # (when (pair (cdr X)) (let N (needCnt Exe (eval (car @))) (when (s...
; # (cdr X)
  %28 = inttoptr i64 %3 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (pair (cdr X))
  %31 = and i64 %30, 15
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %$12, label %$13
$12:
; # (let N (needCnt Exe (eval (car @))) (when (setq N (int N)) (let B...
; # (car @)
  %33 = inttoptr i64 %30 to i64*
  %34 = load i64, i64* %33
; # (eval (car @))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$16, label %$15
$16:
  br label %$14
$15:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$18, label %$17
$18:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$14
$17:
  %41 = call i64 @evList(i64 %34)
  br label %$14
$14:
  %42 = phi i64 [%34, %$16], [%40, %$18], [%41, %$17] ; # ->
; # (needCnt Exe (eval (car @)))
  %43 = and i64 %42, 2
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$20, label %$19
$19:
  call void @cntErr(i64 %0, i64 %42)
  unreachable
$20:
; # (when (setq N (int N)) (let Bnd (val $Bind) (loop (? (=0 Bnd)) (?...
; # (int N)
  %45 = lshr i64 %42, 4
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$21, label %$22
$21:
  %47 = phi i64 [%45, %$20] ; # N
; # (let Bnd (val $Bind) (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bn...
; # (val $Bind)
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %49 = load i64, i64* %48
; # (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bnd)) (prog (set $At (v...
  br label %$23
$23:
  %50 = phi i64 [%47, %$21], [%69, %$28] ; # N
  %51 = phi i64 [%49, %$21], [%73, %$28] ; # Bnd
; # (? (=0 Bnd))
; # (=0 Bnd)
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %$25, label %$24
$24:
  %53 = phi i64 [%50, %$23] ; # N
  %54 = phi i64 [%51, %$23] ; # Bnd
; # (? (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec '...
; # (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec 'N))...
; # (val 2 Bnd)
  %55 = inttoptr i64 %54 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
; # (== $At (val 2 Bnd))
  %58 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %57
  br i1 %58, label %$27, label %$26
$27:
  %59 = phi i64 [%53, %$24] ; # N
  %60 = phi i64 [%54, %$24] ; # Bnd
; # (set $At (val Bnd))
; # (val Bnd)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %62, i64* %63
; # (dec 'N)
  %64 = sub i64 %59, 1
; # (=0 (dec 'N))
  %65 = icmp eq i64 %64, 0
  br label %$26
$26:
  %66 = phi i64 [%53, %$24], [%64, %$27] ; # N
  %67 = phi i64 [%54, %$24], [%60, %$27] ; # Bnd
  %68 = phi i1 [0, %$24], [%65, %$27] ; # ->
  br i1 %68, label %$25, label %$28
$28:
  %69 = phi i64 [%66, %$26] ; # N
  %70 = phi i64 [%67, %$26] ; # Bnd
; # (val 3 Bnd)
  %71 = inttoptr i64 %70 to i64*
  %72 = getelementptr i64, i64* %71, i32 2
  %73 = load i64, i64* %72
  br label %$23
$25:
  %74 = phi i64 [%50, %$23], [%66, %$26] ; # N
  %75 = phi i64 [%51, %$23], [%67, %$26] ; # Bnd
  %76 = phi i64 [0, %$23], [0, %$26] ; # ->
  br label %$22
$22:
  %77 = phi i64 [%45, %$20], [%74, %$25] ; # N
  br label %$13
$13:
; # (runAt E)
  %78 = call i64 @runAt(i64 %13)
; # drop
  %79 = inttoptr i64 %23 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %81, i64* %82
  br label %$7
$7:
  %83 = phi i64 [%13, %$9], [%19, %$11], [%78, %$13] ; # ->
  ret i64 %83
}

define i64 @_def(i64) align 8 {
$1:
; # (let (X (cdr Exe) Sym (save (needSymb Exe (eval (++ X)))) Y (save...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needSymb Exe (eval (++ X)))
  %16 = xor i64 %15, 8
  %17 = and i64 %16, 14
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %15)
  unreachable
$8:
; # (save (needSymb Exe (eval (++ X))))
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (++ X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
  %29 = getelementptr i64, i64* %27, i32 1
  %30 = load i64, i64* %29
; # (eval (++ X))
  %31 = and i64 %28, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$10
$11:
  br label %$9
$10:
  %33 = and i64 %28, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$12
$13:
  %35 = inttoptr i64 %28 to i64*
  %36 = load i64, i64* %35
  br label %$9
$12:
  %37 = call i64 @evList(i64 %28)
  br label %$9
$9:
  %38 = phi i64 [%28, %$11], [%36, %$13], [%37, %$12] ; # ->
; # (save (eval (++ X)))
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = add i64 %42, 8
  %45 = inttoptr i64 %44 to i64*
  store i64 %40, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %46
; # (if (pair X) (let Val (save (eval (car X))) (when (sym? (val (tai...
; # (pair X)
  %47 = and i64 %30, 15
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %$14, label %$15
$14:
; # (let Val (save (eval (car X))) (when (sym? (val (tail Sym))) (if ...
; # (car X)
  %49 = inttoptr i64 %30 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$19, label %$18
$19:
  br label %$17
$18:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$21, label %$20
$21:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$17
$20:
  %57 = call i64 @evList(i64 %50)
  br label %$17
$17:
  %58 = phi i64 [%50, %$19], [%56, %$21], [%57, %$20] ; # ->
; # (save (eval (car X)))
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = alloca i64, i64 2, align 16
  %62 = ptrtoint i64* %61 to i64
  %63 = inttoptr i64 %62 to i64*
  store i64 %58, i64* %63
  %64 = add i64 %62, 8
  %65 = inttoptr i64 %64 to i64*
  store i64 %60, i64* %65
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %62, i64* %66
; # (when (sym? (val (tail Sym))) (if (nil? Y) (dbFetch Exe Sym) (dbT...
; # (tail Sym)
  %67 = add i64 %15, -8
; # (val (tail Sym))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (sym? (val (tail Sym)))
  %70 = and i64 %69, 8
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$22, label %$23
$22:
; # (if (nil? Y) (dbFetch Exe Sym) (dbTouch Exe Sym))
; # (nil? Y)
  %72 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %72, label %$24, label %$25
$24:
; # (dbFetch Exe Sym)
  call void @dbFetch(i64 %0, i64 %15)
  br label %$26
$25:
; # (dbTouch Exe Sym)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$26
$26:
  br label %$23
$23:
; # (let V (get Sym Y) (unless (or (nil? V) (equal V Val)) (redefMsg ...
; # (get Sym Y)
  %73 = call i64 @get(i64 %15, i64 %38)
; # (unless (or (nil? V) (equal V Val)) (redefMsg Sym Y))
; # (or (nil? V) (equal V Val))
; # (nil? V)
  %74 = icmp eq i64 %73, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %74, label %$27, label %$28
$28:
; # (equal V Val)
  %75 = call i1 @equal(i64 %73, i64 %58)
  br label %$27
$27:
  %76 = phi i1 [1, %$23], [%75, %$28] ; # ->
  br i1 %76, label %$30, label %$29
$29:
; # (redefMsg Sym Y)
  call void @redefMsg(i64 %15, i64 %38)
  br label %$30
$30:
; # (put Sym Y Val)
  call void @put(i64 %15, i64 %38, i64 %58)
; # (putSrc Sym Y)
  call void @putSrc(i64 %15, i64 %38)
  br label %$16
$15:
; # (chkVar Exe Sym)
  %77 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %77, label %$32, label %$31
$32:
  %78 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %15
  br label %$31
$31:
  %79 = phi i1 [0, %$15], [%78, %$32] ; # ->
  br i1 %79, label %$33, label %$34
$33:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$34:
; # (when (sym? (val (tail Sym))) (dbTouch Exe Sym))
; # (tail Sym)
  %80 = add i64 %15, -8
; # (val (tail Sym))
  %81 = inttoptr i64 %80 to i64*
  %82 = load i64, i64* %81
; # (sym? (val (tail Sym)))
  %83 = and i64 %82, 8
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$35, label %$36
$35:
; # (dbTouch Exe Sym)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$36
$36:
; # (let V (val Sym) (unless (or (nil? V) (== V Sym) (equal V Y)) (re...
; # (val Sym)
  %85 = inttoptr i64 %15 to i64*
  %86 = load i64, i64* %85
; # (unless (or (nil? V) (== V Sym) (equal V Y)) (redefMsg Sym 0))
; # (or (nil? V) (== V Sym) (equal V Y))
; # (nil? V)
  %87 = icmp eq i64 %86, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %87, label %$37, label %$38
$38:
; # (== V Sym)
  %88 = icmp eq i64 %86, %15
  br i1 %88, label %$37, label %$39
$39:
; # (equal V Y)
  %89 = call i1 @equal(i64 %86, i64 %38)
  br label %$37
$37:
  %90 = phi i1 [1, %$36], [1, %$38], [%89, %$39] ; # ->
  br i1 %90, label %$41, label %$40
$40:
; # (redefMsg Sym 0)
  call void @redefMsg(i64 %15, i64 0)
  br label %$41
$41:
; # (set Sym Y)
  %91 = inttoptr i64 %15 to i64*
  store i64 %38, i64* %91
; # (putSrc Sym 0)
  call void @putSrc(i64 %15, i64 0)
  br label %$16
$16:
; # (drop *Safe)
  %92 = inttoptr i64 %22 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
  %95 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %94, i64* %95
  ret i64 %15
}

define i64 @_de(i64) align 8 {
$1:
; # (let S (cadr Exe) (redefine Exe S (cddr Exe)) S)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (cddr Exe)
  %6 = inttoptr i64 %0 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %8 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (redefine Exe S (cddr Exe))
  call void @redefine(i64 %0, i64 %5, i64 %11)
  ret i64 %5
}

define i64 @_dm(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (car X) Fun (cdr X) Msg (if (atom Y) Y (car Y...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (cdr X)
  %6 = inttoptr i64 %3 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
; # (if (atom Y) Y (car Y))
; # (atom Y)
  %9 = and i64 %5, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$2, label %$3
$2:
  %11 = phi i64 [%3, %$1] ; # X
  %12 = phi i64 [%8, %$1] ; # Fun
  br label %$4
$3:
  %13 = phi i64 [%3, %$1] ; # X
  %14 = phi i64 [%8, %$1] ; # Fun
; # (car Y)
  %15 = inttoptr i64 %5 to i64*
  %16 = load i64, i64* %15
  br label %$4
$4:
  %17 = phi i64 [%11, %$2], [%13, %$3] ; # X
  %18 = phi i64 [%12, %$2], [%14, %$3] ; # Fun
  %19 = phi i64 [%5, %$2], [%16, %$3] ; # ->
; # (cond ((atom Y) (val $Class)) ((atom (cdr Y)) @) (T (let Z @ (get...
; # (atom Y)
  %20 = and i64 %5, 15
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$7, label %$6
$7:
  %22 = phi i64 [%17, %$4] ; # X
  %23 = phi i64 [%18, %$4] ; # Fun
; # (val $Class)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 584) to i64) to i64*
  %25 = load i64, i64* %24
  br label %$5
$6:
  %26 = phi i64 [%17, %$4] ; # X
  %27 = phi i64 [%18, %$4] ; # Fun
; # (cdr Y)
  %28 = inttoptr i64 %5 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (atom (cdr Y))
  %31 = and i64 %30, 15
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  %33 = phi i64 [%26, %$6] ; # X
  %34 = phi i64 [%27, %$6] ; # Fun
  br label %$5
$8:
  %35 = phi i64 [%26, %$6] ; # X
  %36 = phi i64 [%27, %$6] ; # Fun
; # (let Z @ (get (if (nil? (cdr Z)) (val $Class) @) (car Z)))
; # (if (nil? (cdr Z)) (val $Class) @)
; # (cdr Z)
  %37 = inttoptr i64 %30 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (nil? (cdr Z))
  %40 = icmp eq i64 %39, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %40, label %$10, label %$11
$10:
  %41 = phi i64 [%35, %$8] ; # X
  %42 = phi i64 [%36, %$8] ; # Fun
; # (val $Class)
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 584) to i64) to i64*
  %44 = load i64, i64* %43
  br label %$12
$11:
  %45 = phi i64 [%35, %$8] ; # X
  %46 = phi i64 [%36, %$8] ; # Fun
  br label %$12
$12:
  %47 = phi i64 [%41, %$10], [%45, %$11] ; # X
  %48 = phi i64 [%42, %$10], [%46, %$11] ; # Fun
  %49 = phi i64 [%44, %$10], [%39, %$11] ; # ->
; # (car Z)
  %50 = inttoptr i64 %30 to i64*
  %51 = load i64, i64* %50
; # (get (if (nil? (cdr Z)) (val $Class) @) (car Z))
  %52 = call i64 @get(i64 %49, i64 %51)
  br label %$5
$5:
  %53 = phi i64 [%22, %$7], [%33, %$9], [%47, %$12] ; # X
  %54 = phi i64 [%23, %$7], [%34, %$9], [%48, %$12] ; # Fun
  %55 = phi i64 [%25, %$7], [%30, %$9], [%52, %$12] ; # ->
; # (unless (t? Msg) (redefine Exe Msg (val $Meth)))
; # (t? Msg)
  %56 = icmp eq i64 %19, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %56, label %$14, label %$13
$13:
  %57 = phi i64 [%53, %$5] ; # X
  %58 = phi i64 [%54, %$5] ; # Fun
; # (val $Meth)
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 248) to i64) to i64*
  %60 = load i64, i64* %59
; # (redefine Exe Msg (val $Meth))
  call void @redefine(i64 %0, i64 %19, i64 %60)
  br label %$14
$14:
  %61 = phi i64 [%53, %$5], [%57, %$13] ; # X
  %62 = phi i64 [%54, %$5], [%58, %$13] ; # Fun
; # (when (symb? Fun) (let L (val Fun) (loop (when (or (atom L) (atom...
; # (symb? Fun)
  %63 = xor i64 %62, 8
  %64 = and i64 %63, 14
  %65 = icmp eq i64 %64, 0
  br i1 %65, label %$15, label %$16
$15:
  %66 = phi i64 [%61, %$14] ; # X
  %67 = phi i64 [%62, %$14] ; # Fun
; # (let L (val Fun) (loop (when (or (atom L) (atom (car L))) (err Ex...
; # (val Fun)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (loop (when (or (atom L) (atom (car L))) (err Exe Msg ($ "Bad mes...
  br label %$17
$17:
  %70 = phi i64 [%66, %$15], [%105, %$22] ; # X
  %71 = phi i64 [%67, %$15], [%106, %$22] ; # Fun
  %72 = phi i64 [%69, %$15], [%110, %$22] ; # L
; # (when (or (atom L) (atom (car L))) (err Exe Msg ($ "Bad message")...
; # (or (atom L) (atom (car L)))
; # (atom L)
  %73 = and i64 %72, 15
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$18, label %$19
$19:
  %75 = phi i64 [%70, %$17] ; # X
  %76 = phi i64 [%71, %$17] ; # Fun
  %77 = phi i64 [%72, %$17] ; # L
; # (car L)
  %78 = inttoptr i64 %77 to i64*
  %79 = load i64, i64* %78
; # (atom (car L))
  %80 = and i64 %79, 15
  %81 = icmp ne i64 %80, 0
  br label %$18
$18:
  %82 = phi i64 [%70, %$17], [%75, %$19] ; # X
  %83 = phi i64 [%71, %$17], [%76, %$19] ; # Fun
  %84 = phi i64 [%72, %$17], [%77, %$19] ; # L
  %85 = phi i1 [1, %$17], [%81, %$19] ; # ->
  br i1 %85, label %$20, label %$21
$20:
  %86 = phi i64 [%82, %$18] ; # X
  %87 = phi i64 [%83, %$18] ; # Fun
  %88 = phi i64 [%84, %$18] ; # L
; # (err Exe Msg ($ "Bad message") null)
  call void @err(i64 %0, i64 %19, i8* bitcast ([12 x i8]* @$70 to i8*), i8* null)
  unreachable
$21:
  %89 = phi i64 [%82, %$18] ; # X
  %90 = phi i64 [%83, %$18] ; # Fun
  %91 = phi i64 [%84, %$18] ; # L
; # (? (== Msg (caar L)) (setq X (car L) Fun (cdr X)))
; # (caar L)
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %93 to i64*
  %95 = load i64, i64* %94
; # (== Msg (caar L))
  %96 = icmp eq i64 %19, %95
  br i1 %96, label %$24, label %$22
$24:
  %97 = phi i64 [%89, %$21] ; # X
  %98 = phi i64 [%90, %$21] ; # Fun
  %99 = phi i64 [%91, %$21] ; # L
; # (car L)
  %100 = inttoptr i64 %99 to i64*
  %101 = load i64, i64* %100
; # (cdr X)
  %102 = inttoptr i64 %101 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  br label %$23
$22:
  %105 = phi i64 [%89, %$21] ; # X
  %106 = phi i64 [%90, %$21] ; # Fun
  %107 = phi i64 [%91, %$21] ; # L
; # (shift L)
  %108 = inttoptr i64 %107 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  %110 = load i64, i64* %109
  br label %$17
$23:
  %111 = phi i64 [%101, %$24] ; # X
  %112 = phi i64 [%104, %$24] ; # Fun
  %113 = phi i64 [%99, %$24] ; # L
  %114 = phi i64 [%104, %$24] ; # ->
  br label %$16
$16:
  %115 = phi i64 [%61, %$14], [%111, %$23] ; # X
  %116 = phi i64 [%62, %$14], [%112, %$23] ; # Fun
; # (let (V (val Cls) L V) (loop (? (or (atom L) (atom (car L))) (set...
; # (val Cls)
  %117 = inttoptr i64 %55 to i64*
  %118 = load i64, i64* %117
; # (loop (? (or (atom L) (atom (car L))) (set Cls (cons (if (atom (c...
  br label %$25
$25:
  %119 = phi i64 [%115, %$16], [%180, %$34] ; # X
  %120 = phi i64 [%116, %$16], [%181, %$34] ; # Fun
  %121 = phi i64 [%118, %$16], [%185, %$34] ; # L
; # (? (or (atom L) (atom (car L))) (set Cls (cons (if (atom (car X))...
; # (or (atom L) (atom (car L)))
; # (atom L)
  %122 = and i64 %121, 15
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$26, label %$27
$27:
  %124 = phi i64 [%119, %$25] ; # X
  %125 = phi i64 [%120, %$25] ; # Fun
  %126 = phi i64 [%121, %$25] ; # L
; # (car L)
  %127 = inttoptr i64 %126 to i64*
  %128 = load i64, i64* %127
; # (atom (car L))
  %129 = and i64 %128, 15
  %130 = icmp ne i64 %129, 0
  br label %$26
$26:
  %131 = phi i64 [%119, %$25], [%124, %$27] ; # X
  %132 = phi i64 [%120, %$25], [%125, %$27] ; # Fun
  %133 = phi i64 [%121, %$25], [%126, %$27] ; # L
  %134 = phi i1 [1, %$25], [%130, %$27] ; # ->
  br i1 %134, label %$30, label %$28
$30:
  %135 = phi i64 [%131, %$26] ; # X
  %136 = phi i64 [%132, %$26] ; # Fun
  %137 = phi i64 [%133, %$26] ; # L
; # (set Cls (cons (if (atom (car X)) X (cons Msg Fun)) V))
; # (if (atom (car X)) X (cons Msg Fun))
; # (car X)
  %138 = inttoptr i64 %135 to i64*
  %139 = load i64, i64* %138
; # (atom (car X))
  %140 = and i64 %139, 15
  %141 = icmp ne i64 %140, 0
  br i1 %141, label %$31, label %$32
$31:
  %142 = phi i64 [%135, %$30] ; # X
  %143 = phi i64 [%136, %$30] ; # Fun
  %144 = phi i64 [%137, %$30] ; # L
  br label %$33
$32:
  %145 = phi i64 [%135, %$30] ; # X
  %146 = phi i64 [%136, %$30] ; # Fun
  %147 = phi i64 [%137, %$30] ; # L
; # (cons Msg Fun)
  %148 = call i64 @cons(i64 %19, i64 %146)
  br label %$33
$33:
  %149 = phi i64 [%142, %$31], [%145, %$32] ; # X
  %150 = phi i64 [%143, %$31], [%146, %$32] ; # Fun
  %151 = phi i64 [%144, %$31], [%147, %$32] ; # L
  %152 = phi i64 [%142, %$31], [%148, %$32] ; # ->
; # (cons (if (atom (car X)) X (cons Msg Fun)) V)
  %153 = call i64 @cons(i64 %152, i64 %118)
  %154 = inttoptr i64 %55 to i64*
  store i64 %153, i64* %154
  br label %$29
$28:
  %155 = phi i64 [%131, %$26] ; # X
  %156 = phi i64 [%132, %$26] ; # Fun
  %157 = phi i64 [%133, %$26] ; # L
; # (? (== Msg (caar L)) (let Z (car L) (unless (equal Fun (cdr Z)) (...
; # (caar L)
  %158 = inttoptr i64 %157 to i64*
  %159 = load i64, i64* %158
  %160 = inttoptr i64 %159 to i64*
  %161 = load i64, i64* %160
; # (== Msg (caar L))
  %162 = icmp eq i64 %19, %161
  br i1 %162, label %$35, label %$34
$35:
  %163 = phi i64 [%155, %$28] ; # X
  %164 = phi i64 [%156, %$28] ; # Fun
  %165 = phi i64 [%157, %$28] ; # L
; # (let Z (car L) (unless (equal Fun (cdr Z)) (redefMsg Msg Cls)) (s...
; # (car L)
  %166 = inttoptr i64 %165 to i64*
  %167 = load i64, i64* %166
; # (unless (equal Fun (cdr Z)) (redefMsg Msg Cls))
; # (cdr Z)
  %168 = inttoptr i64 %167 to i64*
  %169 = getelementptr i64, i64* %168, i32 1
  %170 = load i64, i64* %169
; # (equal Fun (cdr Z))
  %171 = call i1 @equal(i64 %164, i64 %170)
  br i1 %171, label %$37, label %$36
$36:
  %172 = phi i64 [%163, %$35] ; # X
  %173 = phi i64 [%164, %$35] ; # Fun
  %174 = phi i64 [%165, %$35] ; # L
; # (redefMsg Msg Cls)
  call void @redefMsg(i64 %19, i64 %55)
  br label %$37
$37:
  %175 = phi i64 [%163, %$35], [%172, %$36] ; # X
  %176 = phi i64 [%164, %$35], [%173, %$36] ; # Fun
  %177 = phi i64 [%165, %$35], [%174, %$36] ; # L
; # (set 2 Z Fun)
  %178 = inttoptr i64 %167 to i64*
  %179 = getelementptr i64, i64* %178, i32 1
  store i64 %176, i64* %179
  br label %$29
$34:
  %180 = phi i64 [%155, %$28] ; # X
  %181 = phi i64 [%156, %$28] ; # Fun
  %182 = phi i64 [%157, %$28] ; # L
; # (shift L)
  %183 = inttoptr i64 %182 to i64*
  %184 = getelementptr i64, i64* %183, i32 1
  %185 = load i64, i64* %184
  br label %$25
$29:
  %186 = phi i64 [%149, %$33], [%175, %$37] ; # X
  %187 = phi i64 [%150, %$33], [%176, %$37] ; # Fun
  %188 = phi i64 [%151, %$33], [%177, %$37] ; # L
  %189 = phi i64 [%153, %$33], [%176, %$37] ; # ->
; # (putSrc Cls Msg)
  call void @putSrc(i64 %55, i64 %19)
  ret i64 %19
}

define i64 @evMethod(i64, i64, i64, i64, i64) align 8 {
$1:
; # (let (Y (car Exe) P (set $Bind (push (val $At) $At (val $Bind) Ex...
; # (car Exe)
  %5 = inttoptr i64 %3 to i64*
  %6 = load i64, i64* %5
; # (set $Bind (push (val $At) $At (val $Bind) Exe))
; # (val $At)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %8 = load i64, i64* %7
; # (val $Bind)
  %9 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %10 = load i64, i64* %9
; # (push (val $At) $At (val $Bind) Exe)
  %11 = alloca i64, i64 4, align 16
  %12 = ptrtoint i64* %11 to i64
  %13 = inttoptr i64 %12 to i64*
  store i64 %8, i64* %13
  %14 = add i64 %12, 8
  %15 = inttoptr i64 %14 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), i64* %15
  %16 = add i64 %12, 16
  %17 = inttoptr i64 %16 to i64*
  store i64 %10, i64* %17
  %18 = add i64 %12, 24
  %19 = inttoptr i64 %18 to i64*
  store i64 %3, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %12, i64* %20
; # (set $Bind (setq P (push Obj $This P)))
; # (push Obj $This P)
  %21 = alloca i64, i64 3, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %0, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64), i64* %25
  %26 = add i64 %22, 16
  %27 = inttoptr i64 %26 to i64*
  store i64 %12, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %22, i64* %28
; # (while (pair Y) (let (V (eval (++ X)) Z (++ Y)) (if (atom Z) (set...
  br label %$2
$2:
  %29 = phi i64 [%4, %$1], [%159, %$12] ; # X
  %30 = phi i64 [%6, %$1], [%160, %$12] ; # Y
  %31 = phi i64 [%22, %$1], [%161, %$12] ; # P
; # (pair Y)
  %32 = and i64 %30, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$3, label %$4
$3:
  %34 = phi i64 [%29, %$2] ; # X
  %35 = phi i64 [%30, %$2] ; # Y
  %36 = phi i64 [%31, %$2] ; # P
; # (let (V (eval (++ X)) Z (++ Y)) (if (atom Z) (set $Bind (setq P (...
; # (++ X)
  %37 = inttoptr i64 %34 to i64*
  %38 = load i64, i64* %37
  %39 = getelementptr i64, i64* %37, i32 1
  %40 = load i64, i64* %39
; # (eval (++ X))
  %41 = and i64 %38, 6
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$7, label %$6
$7:
  br label %$5
$6:
  %43 = and i64 %38, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$9, label %$8
$9:
  %45 = inttoptr i64 %38 to i64*
  %46 = load i64, i64* %45
  br label %$5
$8:
  %47 = call i64 @evList(i64 %38)
  br label %$5
$5:
  %48 = phi i64 [%38, %$7], [%46, %$9], [%47, %$8] ; # ->
; # (++ Y)
  %49 = inttoptr i64 %35 to i64*
  %50 = load i64, i64* %49
  %51 = getelementptr i64, i64* %49, i32 1
  %52 = load i64, i64* %51
; # (if (atom Z) (set $Bind (setq P (push V (needChkVar Exe Z) P))) (...
; # (atom Z)
  %53 = and i64 %50, 15
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$10, label %$11
$10:
  %55 = phi i64 [%40, %$5] ; # X
  %56 = phi i64 [%52, %$5] ; # Y
  %57 = phi i64 [%36, %$5] ; # P
  %58 = phi i64 [%48, %$5] ; # V
  %59 = phi i64 [%50, %$5] ; # Z
; # (set $Bind (setq P (push V (needChkVar Exe Z) P)))
; # (needChkVar Exe Z)
  %60 = and i64 %59, 6
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$13, label %$14
$13:
  call void @varErr(i64 %3, i64 %59)
  unreachable
$14:
  %62 = icmp uge i64 %59, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %62, label %$16, label %$15
$16:
  %63 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %59
  br label %$15
$15:
  %64 = phi i1 [0, %$14], [%63, %$16] ; # ->
  br i1 %64, label %$17, label %$18
$17:
  call void @protErr(i64 %3, i64 %59)
  unreachable
$18:
; # (push V (needChkVar Exe Z) P)
  %65 = alloca i64, i64 3, align 16
  %66 = ptrtoint i64* %65 to i64
  %67 = inttoptr i64 %66 to i64*
  store i64 %58, i64* %67
  %68 = add i64 %66, 8
  %69 = inttoptr i64 %68 to i64*
  store i64 %59, i64* %69
  %70 = add i64 %66, 16
  %71 = inttoptr i64 %70 to i64*
  store i64 %57, i64* %71
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %66, i64* %72
  br label %$12
$11:
  %73 = phi i64 [%40, %$5] ; # X
  %74 = phi i64 [%52, %$5] ; # Y
  %75 = phi i64 [%36, %$5] ; # P
  %76 = phi i64 [%48, %$5] ; # V
  %77 = phi i64 [%50, %$5] ; # Z
; # (loop (set $Bind (setq P (push (if (pair V) (++ V) $Nil) (needChk...
  br label %$19
$19:
  %78 = phi i64 [%73, %$11], [%124, %$29] ; # X
  %79 = phi i64 [%74, %$11], [%125, %$29] ; # Y
  %80 = phi i64 [%75, %$11], [%126, %$29] ; # P
  %81 = phi i64 [%76, %$11], [%127, %$29] ; # V
  %82 = phi i64 [%77, %$11], [%128, %$29] ; # Z
; # (set $Bind (setq P (push (if (pair V) (++ V) $Nil) (needChkVar Ex...
; # (if (pair V) (++ V) $Nil)
; # (pair V)
  %83 = and i64 %81, 15
  %84 = icmp eq i64 %83, 0
  br i1 %84, label %$20, label %$21
$20:
  %85 = phi i64 [%78, %$19] ; # X
  %86 = phi i64 [%79, %$19] ; # Y
  %87 = phi i64 [%80, %$19] ; # P
  %88 = phi i64 [%81, %$19] ; # V
  %89 = phi i64 [%82, %$19] ; # Z
; # (++ V)
  %90 = inttoptr i64 %88 to i64*
  %91 = load i64, i64* %90
  %92 = getelementptr i64, i64* %90, i32 1
  %93 = load i64, i64* %92
  br label %$22
$21:
  %94 = phi i64 [%78, %$19] ; # X
  %95 = phi i64 [%79, %$19] ; # Y
  %96 = phi i64 [%80, %$19] ; # P
  %97 = phi i64 [%81, %$19] ; # V
  %98 = phi i64 [%82, %$19] ; # Z
  br label %$22
$22:
  %99 = phi i64 [%85, %$20], [%94, %$21] ; # X
  %100 = phi i64 [%86, %$20], [%95, %$21] ; # Y
  %101 = phi i64 [%87, %$20], [%96, %$21] ; # P
  %102 = phi i64 [%93, %$20], [%97, %$21] ; # V
  %103 = phi i64 [%89, %$20], [%98, %$21] ; # Z
  %104 = phi i64 [%91, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
; # (++ Z)
  %105 = inttoptr i64 %103 to i64*
  %106 = load i64, i64* %105
  %107 = getelementptr i64, i64* %105, i32 1
  %108 = load i64, i64* %107
; # (needChkVar Exe (++ Z))
  %109 = and i64 %106, 6
  %110 = icmp ne i64 %109, 0
  br i1 %110, label %$23, label %$24
$23:
  call void @varErr(i64 %3, i64 %106)
  unreachable
$24:
  %111 = icmp uge i64 %106, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %111, label %$26, label %$25
$26:
  %112 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %106
  br label %$25
$25:
  %113 = phi i1 [0, %$24], [%112, %$26] ; # ->
  br i1 %113, label %$27, label %$28
$27:
  call void @protErr(i64 %3, i64 %106)
  unreachable
$28:
; # (push (if (pair V) (++ V) $Nil) (needChkVar Exe (++ Z)) P)
  %114 = alloca i64, i64 3, align 16
  %115 = ptrtoint i64* %114 to i64
  %116 = inttoptr i64 %115 to i64*
  store i64 %104, i64* %116
  %117 = add i64 %115, 8
  %118 = inttoptr i64 %117 to i64*
  store i64 %106, i64* %118
  %119 = add i64 %115, 16
  %120 = inttoptr i64 %119 to i64*
  store i64 %101, i64* %120
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %115, i64* %121
; # (? (atom Z))
; # (atom Z)
  %122 = and i64 %108, 15
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$30, label %$29
$29:
  %124 = phi i64 [%99, %$28] ; # X
  %125 = phi i64 [%100, %$28] ; # Y
  %126 = phi i64 [%115, %$28] ; # P
  %127 = phi i64 [%102, %$28] ; # V
  %128 = phi i64 [%108, %$28] ; # Z
  br label %$19
$30:
  %129 = phi i64 [%99, %$28] ; # X
  %130 = phi i64 [%100, %$28] ; # Y
  %131 = phi i64 [%115, %$28] ; # P
  %132 = phi i64 [%102, %$28] ; # V
  %133 = phi i64 [%108, %$28] ; # Z
  %134 = phi i64 [0, %$28] ; # ->
; # (unless (nil? Z) (set $Bind (setq P (push V (needChkVar Exe Z) P)...
; # (nil? Z)
  %135 = icmp eq i64 %133, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %135, label %$32, label %$31
$31:
  %136 = phi i64 [%129, %$30] ; # X
  %137 = phi i64 [%130, %$30] ; # Y
  %138 = phi i64 [%131, %$30] ; # P
  %139 = phi i64 [%132, %$30] ; # V
  %140 = phi i64 [%133, %$30] ; # Z
; # (set $Bind (setq P (push V (needChkVar Exe Z) P)))
; # (needChkVar Exe Z)
  %141 = and i64 %140, 6
  %142 = icmp ne i64 %141, 0
  br i1 %142, label %$33, label %$34
$33:
  call void @varErr(i64 %3, i64 %140)
  unreachable
$34:
  %143 = icmp uge i64 %140, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %143, label %$36, label %$35
$36:
  %144 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %140
  br label %$35
$35:
  %145 = phi i1 [0, %$34], [%144, %$36] ; # ->
  br i1 %145, label %$37, label %$38
$37:
  call void @protErr(i64 %3, i64 %140)
  unreachable
$38:
; # (push V (needChkVar Exe Z) P)
  %146 = alloca i64, i64 3, align 16
  %147 = ptrtoint i64* %146 to i64
  %148 = inttoptr i64 %147 to i64*
  store i64 %139, i64* %148
  %149 = add i64 %147, 8
  %150 = inttoptr i64 %149 to i64*
  store i64 %140, i64* %150
  %151 = add i64 %147, 16
  %152 = inttoptr i64 %151 to i64*
  store i64 %138, i64* %152
  %153 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %147, i64* %153
  br label %$32
$32:
  %154 = phi i64 [%129, %$30], [%136, %$38] ; # X
  %155 = phi i64 [%130, %$30], [%137, %$38] ; # Y
  %156 = phi i64 [%131, %$30], [%147, %$38] ; # P
  %157 = phi i64 [%132, %$30], [%139, %$38] ; # V
  %158 = phi i64 [%133, %$30], [%140, %$38] ; # Z
  br label %$12
$12:
  %159 = phi i64 [%55, %$18], [%154, %$32] ; # X
  %160 = phi i64 [%56, %$18], [%155, %$32] ; # Y
  %161 = phi i64 [%66, %$18], [%156, %$32] ; # P
  %162 = phi i64 [%58, %$18], [%157, %$32] ; # V
  %163 = phi i64 [%59, %$18], [%158, %$32] ; # Z
  br label %$2
$4:
  %164 = phi i64 [%29, %$2] ; # X
  %165 = phi i64 [%30, %$2] ; # Y
  %166 = phi i64 [%31, %$2] ; # P
; # (prog1 (if (== Y $At) (if (pair X) (let (L (push NIL (eval (car X...
; # (if (== Y $At) (if (pair X) (let (L (push NIL (eval (car X)) NIL)...
; # (== Y $At)
  %167 = icmp eq i64 %165, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64)
  br i1 %167, label %$39, label %$40
$39:
  %168 = phi i64 [%164, %$4] ; # X
  %169 = phi i64 [%165, %$4] ; # Y
  %170 = phi i64 [%166, %$4] ; # P
; # (if (pair X) (let (L (push NIL (eval (car X)) NIL) Q L) (link (of...
; # (pair X)
  %171 = and i64 %168, 15
  %172 = icmp eq i64 %171, 0
  br i1 %172, label %$42, label %$43
$42:
  %173 = phi i64 [%168, %$39] ; # X
  %174 = phi i64 [%169, %$39] ; # Y
  %175 = phi i64 [%170, %$39] ; # P
; # (let (L (push NIL (eval (car X)) NIL) Q L) (link (ofs L 1)) (whil...
; # (car X)
  %176 = inttoptr i64 %173 to i64*
  %177 = load i64, i64* %176
; # (eval (car X))
  %178 = and i64 %177, 6
  %179 = icmp ne i64 %178, 0
  br i1 %179, label %$47, label %$46
$47:
  br label %$45
$46:
  %180 = and i64 %177, 8
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$49, label %$48
$49:
  %182 = inttoptr i64 %177 to i64*
  %183 = load i64, i64* %182
  br label %$45
$48:
  %184 = call i64 @evList(i64 %177)
  br label %$45
$45:
  %185 = phi i64 [%177, %$47], [%183, %$49], [%184, %$48] ; # ->
; # (push NIL (eval (car X)) NIL)
  %186 = alloca i64, i64 3, align 16
  %187 = ptrtoint i64* %186 to i64
  %188 = add i64 %187, 8
  %189 = inttoptr i64 %188 to i64*
  store i64 %185, i64* %189
; # (ofs L 1)
  %190 = add i64 %187, 8
; # (link (ofs L 1))
  %191 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %192 = load i64, i64* %191
  %193 = inttoptr i64 %190 to i64*
  %194 = getelementptr i64, i64* %193, i32 1
  store i64 %192, i64* %194
  %195 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %190, i64* %195
; # (while (pair (shift X)) (setq L (set L (push NIL (eval (car X)) N...
  br label %$50
$50:
  %196 = phi i64 [%173, %$45], [%205, %$53] ; # X
  %197 = phi i64 [%174, %$45], [%206, %$53] ; # Y
  %198 = phi i64 [%175, %$45], [%207, %$53] ; # P
  %199 = phi i64 [%187, %$45], [%220, %$53] ; # L
; # (shift X)
  %200 = inttoptr i64 %196 to i64*
  %201 = getelementptr i64, i64* %200, i32 1
  %202 = load i64, i64* %201
; # (pair (shift X))
  %203 = and i64 %202, 15
  %204 = icmp eq i64 %203, 0
  br i1 %204, label %$51, label %$52
$51:
  %205 = phi i64 [%202, %$50] ; # X
  %206 = phi i64 [%197, %$50] ; # Y
  %207 = phi i64 [%198, %$50] ; # P
  %208 = phi i64 [%199, %$50] ; # L
; # (set L (push NIL (eval (car X)) NIL))
; # (car X)
  %209 = inttoptr i64 %205 to i64*
  %210 = load i64, i64* %209
; # (eval (car X))
  %211 = and i64 %210, 6
  %212 = icmp ne i64 %211, 0
  br i1 %212, label %$55, label %$54
$55:
  br label %$53
$54:
  %213 = and i64 %210, 8
  %214 = icmp ne i64 %213, 0
  br i1 %214, label %$57, label %$56
$57:
  %215 = inttoptr i64 %210 to i64*
  %216 = load i64, i64* %215
  br label %$53
$56:
  %217 = call i64 @evList(i64 %210)
  br label %$53
$53:
  %218 = phi i64 [%210, %$55], [%216, %$57], [%217, %$56] ; # ->
; # (push NIL (eval (car X)) NIL)
  %219 = alloca i64, i64 3, align 16
  %220 = ptrtoint i64* %219 to i64
  %221 = add i64 %220, 8
  %222 = inttoptr i64 %221 to i64*
  store i64 %218, i64* %222
  %223 = inttoptr i64 %208 to i64*
  store i64 %220, i64* %223
; # (ofs L 1)
  %224 = add i64 %220, 8
; # (link (ofs L 1))
  %225 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %226 = load i64, i64* %225
  %227 = inttoptr i64 %224 to i64*
  %228 = getelementptr i64, i64* %227, i32 1
  store i64 %226, i64* %228
  %229 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %224, i64* %229
  br label %$50
$52:
  %230 = phi i64 [%202, %$50] ; # X
  %231 = phi i64 [%197, %$50] ; # Y
  %232 = phi i64 [%198, %$50] ; # P
  %233 = phi i64 [%199, %$50] ; # L
; # (let Next (val $Next) (set L $Nil $Next Q) (loop (let Sym (val 2 ...
; # (val $Next)
  %234 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %235 = load i64, i64* %234
; # (set L $Nil $Next Q)
  %236 = inttoptr i64 %233 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %236
  %237 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 %187, i64* %237
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$58
$58:
  %238 = phi i64 [%230, %$52], [%250, %$59] ; # X
  %239 = phi i64 [%231, %$52], [%251, %$59] ; # Y
  %240 = phi i64 [%232, %$52], [%256, %$59] ; # P
  %241 = phi i64 [%233, %$52], [%253, %$59] ; # L
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %242 = inttoptr i64 %240 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
; # (xchg Sym P)
  %245 = inttoptr i64 %244 to i64*
  %246 = load i64, i64* %245
  %247 = inttoptr i64 %240 to i64*
  %248 = load i64, i64* %247
  store i64 %248, i64* %245
  store i64 %246, i64* %247
; # (? (== $At Sym))
; # (== $At Sym)
  %249 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %244
  br i1 %249, label %$60, label %$59
$59:
  %250 = phi i64 [%238, %$58] ; # X
  %251 = phi i64 [%239, %$58] ; # Y
  %252 = phi i64 [%240, %$58] ; # P
  %253 = phi i64 [%241, %$58] ; # L
; # (val 3 P)
  %254 = inttoptr i64 %252 to i64*
  %255 = getelementptr i64, i64* %254, i32 2
  %256 = load i64, i64* %255
  br label %$58
$60:
  %257 = phi i64 [%238, %$58] ; # X
  %258 = phi i64 [%239, %$58] ; # Y
  %259 = phi i64 [%240, %$58] ; # P
  %260 = phi i64 [%241, %$58] ; # L
  %261 = phi i64 [0, %$58] ; # ->
; # (let (TypS (val $Typ) KeyS (val $Key)) (prog2 (set $Typ Typ $Key ...
; # (val $Typ)
  %262 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  %263 = load i64, i64* %262
; # (val $Key)
  %264 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  %265 = load i64, i64* %264
; # (prog2 (set $Typ Typ $Key Key) (run (cdr Exe)) (set $Key KeyS $Ty...
; # (set $Typ Typ $Key Key)
  %266 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %1, i64* %266
  %267 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %2, i64* %267
; # (cdr Exe)
  %268 = inttoptr i64 %3 to i64*
  %269 = getelementptr i64, i64* %268, i32 1
  %270 = load i64, i64* %269
; # (run (cdr Exe))
  br label %$61
$61:
  %271 = phi i64 [%270, %$60], [%293, %$70] ; # Prg
  %272 = inttoptr i64 %271 to i64*
  %273 = load i64, i64* %272
  %274 = getelementptr i64, i64* %272, i32 1
  %275 = load i64, i64* %274
  %276 = and i64 %275, 15
  %277 = icmp ne i64 %276, 0
  br i1 %277, label %$64, label %$62
$64:
  %278 = phi i64 [%275, %$61] ; # Prg
  %279 = and i64 %273, 6
  %280 = icmp ne i64 %279, 0
  br i1 %280, label %$67, label %$66
$67:
  br label %$65
$66:
  %281 = and i64 %273, 8
  %282 = icmp ne i64 %281, 0
  br i1 %282, label %$69, label %$68
$69:
  %283 = inttoptr i64 %273 to i64*
  %284 = load i64, i64* %283
  br label %$65
$68:
  %285 = call i64 @evList(i64 %273)
  br label %$65
$65:
  %286 = phi i64 [%273, %$67], [%284, %$69], [%285, %$68] ; # ->
  br label %$63
$62:
  %287 = phi i64 [%275, %$61] ; # Prg
  %288 = and i64 %273, 15
  %289 = icmp eq i64 %288, 0
  br i1 %289, label %$71, label %$70
$71:
  %290 = phi i64 [%287, %$62] ; # Prg
  %291 = call i64 @evList(i64 %273)
  %292 = icmp ne i64 %291, 0
  br label %$70
$70:
  %293 = phi i64 [%287, %$62], [%290, %$71] ; # Prg
  %294 = phi i1 [0, %$62], [%292, %$71] ; # ->
  br label %$61
$63:
  %295 = phi i64 [%278, %$65] ; # Prg
  %296 = phi i64 [%286, %$65] ; # ->
; # (set $Key KeyS $Typ TypS $Next Next)
  %297 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %265, i64* %297
  %298 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %263, i64* %298
  %299 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 %235, i64* %299
; # (ofs Q 1)
  %300 = add i64 %187, 8
; # (drop (ofs Q 1))
  %301 = inttoptr i64 %300 to i64*
  %302 = getelementptr i64, i64* %301, i32 1
  %303 = load i64, i64* %302
  %304 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %303, i64* %304
  br label %$44
$43:
  %305 = phi i64 [%168, %$39] ; # X
  %306 = phi i64 [%169, %$39] ; # Y
  %307 = phi i64 [%170, %$39] ; # P
; # (let Next (val $Next) (set $Next $Nil) (loop (let Sym (val 2 P) (...
; # (val $Next)
  %308 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %309 = load i64, i64* %308
; # (set $Next $Nil)
  %310 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %310
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$72
$72:
  %311 = phi i64 [%305, %$43], [%322, %$73] ; # X
  %312 = phi i64 [%306, %$43], [%323, %$73] ; # Y
  %313 = phi i64 [%307, %$43], [%327, %$73] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %314 = inttoptr i64 %313 to i64*
  %315 = getelementptr i64, i64* %314, i32 1
  %316 = load i64, i64* %315
; # (xchg Sym P)
  %317 = inttoptr i64 %316 to i64*
  %318 = load i64, i64* %317
  %319 = inttoptr i64 %313 to i64*
  %320 = load i64, i64* %319
  store i64 %320, i64* %317
  store i64 %318, i64* %319
; # (? (== $At Sym))
; # (== $At Sym)
  %321 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %316
  br i1 %321, label %$74, label %$73
$73:
  %322 = phi i64 [%311, %$72] ; # X
  %323 = phi i64 [%312, %$72] ; # Y
  %324 = phi i64 [%313, %$72] ; # P
; # (val 3 P)
  %325 = inttoptr i64 %324 to i64*
  %326 = getelementptr i64, i64* %325, i32 2
  %327 = load i64, i64* %326
  br label %$72
$74:
  %328 = phi i64 [%311, %$72] ; # X
  %329 = phi i64 [%312, %$72] ; # Y
  %330 = phi i64 [%313, %$72] ; # P
  %331 = phi i64 [0, %$72] ; # ->
; # (let (TypS (val $Typ) KeyS (val $Key)) (prog2 (set $Typ Typ $Key ...
; # (val $Typ)
  %332 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  %333 = load i64, i64* %332
; # (val $Key)
  %334 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  %335 = load i64, i64* %334
; # (prog2 (set $Typ Typ $Key Key) (run (cdr Exe)) (set $Key KeyS $Ty...
; # (set $Typ Typ $Key Key)
  %336 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %1, i64* %336
  %337 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %2, i64* %337
; # (cdr Exe)
  %338 = inttoptr i64 %3 to i64*
  %339 = getelementptr i64, i64* %338, i32 1
  %340 = load i64, i64* %339
; # (run (cdr Exe))
  br label %$75
$75:
  %341 = phi i64 [%340, %$74], [%363, %$84] ; # Prg
  %342 = inttoptr i64 %341 to i64*
  %343 = load i64, i64* %342
  %344 = getelementptr i64, i64* %342, i32 1
  %345 = load i64, i64* %344
  %346 = and i64 %345, 15
  %347 = icmp ne i64 %346, 0
  br i1 %347, label %$78, label %$76
$78:
  %348 = phi i64 [%345, %$75] ; # Prg
  %349 = and i64 %343, 6
  %350 = icmp ne i64 %349, 0
  br i1 %350, label %$81, label %$80
$81:
  br label %$79
$80:
  %351 = and i64 %343, 8
  %352 = icmp ne i64 %351, 0
  br i1 %352, label %$83, label %$82
$83:
  %353 = inttoptr i64 %343 to i64*
  %354 = load i64, i64* %353
  br label %$79
$82:
  %355 = call i64 @evList(i64 %343)
  br label %$79
$79:
  %356 = phi i64 [%343, %$81], [%354, %$83], [%355, %$82] ; # ->
  br label %$77
$76:
  %357 = phi i64 [%345, %$75] ; # Prg
  %358 = and i64 %343, 15
  %359 = icmp eq i64 %358, 0
  br i1 %359, label %$85, label %$84
$85:
  %360 = phi i64 [%357, %$76] ; # Prg
  %361 = call i64 @evList(i64 %343)
  %362 = icmp ne i64 %361, 0
  br label %$84
$84:
  %363 = phi i64 [%357, %$76], [%360, %$85] ; # Prg
  %364 = phi i1 [0, %$76], [%362, %$85] ; # ->
  br label %$75
$77:
  %365 = phi i64 [%348, %$79] ; # Prg
  %366 = phi i64 [%356, %$79] ; # ->
; # (set $Key KeyS $Typ TypS $Next Next)
  %367 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %335, i64* %367
  %368 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %333, i64* %368
  %369 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 %309, i64* %369
  br label %$44
$44:
  %370 = phi i64 [%257, %$63], [%328, %$77] ; # X
  %371 = phi i64 [%258, %$63], [%329, %$77] ; # Y
  %372 = phi i64 [%259, %$63], [%330, %$77] ; # P
  %373 = phi i64 [%296, %$63], [%366, %$77] ; # ->
  br label %$41
$40:
  %374 = phi i64 [%164, %$4] ; # X
  %375 = phi i64 [%165, %$4] ; # Y
  %376 = phi i64 [%166, %$4] ; # P
; # (unless (nil? Y) (needChkVar Exe Y) (set $Bind (push (val Y) Y P)...
; # (nil? Y)
  %377 = icmp eq i64 %375, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %377, label %$87, label %$86
$86:
  %378 = phi i64 [%374, %$40] ; # X
  %379 = phi i64 [%375, %$40] ; # Y
  %380 = phi i64 [%376, %$40] ; # P
; # (needChkVar Exe Y)
  %381 = and i64 %379, 6
  %382 = icmp ne i64 %381, 0
  br i1 %382, label %$88, label %$89
$88:
  call void @varErr(i64 %3, i64 %379)
  unreachable
$89:
  %383 = icmp uge i64 %379, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %383, label %$91, label %$90
$91:
  %384 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %379
  br label %$90
$90:
  %385 = phi i1 [0, %$89], [%384, %$91] ; # ->
  br i1 %385, label %$92, label %$93
$92:
  call void @protErr(i64 %3, i64 %379)
  unreachable
$93:
; # (set $Bind (push (val Y) Y P) Y X)
; # (val Y)
  %386 = inttoptr i64 %379 to i64*
  %387 = load i64, i64* %386
; # (push (val Y) Y P)
  %388 = alloca i64, i64 3, align 16
  %389 = ptrtoint i64* %388 to i64
  %390 = inttoptr i64 %389 to i64*
  store i64 %387, i64* %390
  %391 = add i64 %389, 8
  %392 = inttoptr i64 %391 to i64*
  store i64 %379, i64* %392
  %393 = add i64 %389, 16
  %394 = inttoptr i64 %393 to i64*
  store i64 %380, i64* %394
  %395 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %389, i64* %395
  %396 = inttoptr i64 %379 to i64*
  store i64 %378, i64* %396
  br label %$87
$87:
  %397 = phi i64 [%374, %$40], [%378, %$93] ; # X
  %398 = phi i64 [%375, %$40], [%379, %$93] ; # Y
  %399 = phi i64 [%376, %$40], [%380, %$93] ; # P
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$94
$94:
  %400 = phi i64 [%397, %$87], [%411, %$95] ; # X
  %401 = phi i64 [%398, %$87], [%412, %$95] ; # Y
  %402 = phi i64 [%399, %$87], [%416, %$95] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %403 = inttoptr i64 %402 to i64*
  %404 = getelementptr i64, i64* %403, i32 1
  %405 = load i64, i64* %404
; # (xchg Sym P)
  %406 = inttoptr i64 %405 to i64*
  %407 = load i64, i64* %406
  %408 = inttoptr i64 %402 to i64*
  %409 = load i64, i64* %408
  store i64 %409, i64* %406
  store i64 %407, i64* %408
; # (? (== $At Sym))
; # (== $At Sym)
  %410 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %405
  br i1 %410, label %$96, label %$95
$95:
  %411 = phi i64 [%400, %$94] ; # X
  %412 = phi i64 [%401, %$94] ; # Y
  %413 = phi i64 [%402, %$94] ; # P
; # (val 3 P)
  %414 = inttoptr i64 %413 to i64*
  %415 = getelementptr i64, i64* %414, i32 2
  %416 = load i64, i64* %415
  br label %$94
$96:
  %417 = phi i64 [%400, %$94] ; # X
  %418 = phi i64 [%401, %$94] ; # Y
  %419 = phi i64 [%402, %$94] ; # P
  %420 = phi i64 [0, %$94] ; # ->
; # (let (TypS (val $Typ) KeyS (val $Key)) (prog2 (set $Typ Typ $Key ...
; # (val $Typ)
  %421 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  %422 = load i64, i64* %421
; # (val $Key)
  %423 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  %424 = load i64, i64* %423
; # (prog2 (set $Typ Typ $Key Key) (run (cdr Exe)) (set $Key KeyS $Ty...
; # (set $Typ Typ $Key Key)
  %425 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %1, i64* %425
  %426 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %2, i64* %426
; # (cdr Exe)
  %427 = inttoptr i64 %3 to i64*
  %428 = getelementptr i64, i64* %427, i32 1
  %429 = load i64, i64* %428
; # (run (cdr Exe))
  br label %$97
$97:
  %430 = phi i64 [%429, %$96], [%452, %$106] ; # Prg
  %431 = inttoptr i64 %430 to i64*
  %432 = load i64, i64* %431
  %433 = getelementptr i64, i64* %431, i32 1
  %434 = load i64, i64* %433
  %435 = and i64 %434, 15
  %436 = icmp ne i64 %435, 0
  br i1 %436, label %$100, label %$98
$100:
  %437 = phi i64 [%434, %$97] ; # Prg
  %438 = and i64 %432, 6
  %439 = icmp ne i64 %438, 0
  br i1 %439, label %$103, label %$102
$103:
  br label %$101
$102:
  %440 = and i64 %432, 8
  %441 = icmp ne i64 %440, 0
  br i1 %441, label %$105, label %$104
$105:
  %442 = inttoptr i64 %432 to i64*
  %443 = load i64, i64* %442
  br label %$101
$104:
  %444 = call i64 @evList(i64 %432)
  br label %$101
$101:
  %445 = phi i64 [%432, %$103], [%443, %$105], [%444, %$104] ; # ->
  br label %$99
$98:
  %446 = phi i64 [%434, %$97] ; # Prg
  %447 = and i64 %432, 15
  %448 = icmp eq i64 %447, 0
  br i1 %448, label %$107, label %$106
$107:
  %449 = phi i64 [%446, %$98] ; # Prg
  %450 = call i64 @evList(i64 %432)
  %451 = icmp ne i64 %450, 0
  br label %$106
$106:
  %452 = phi i64 [%446, %$98], [%449, %$107] ; # Prg
  %453 = phi i1 [0, %$98], [%451, %$107] ; # ->
  br label %$97
$99:
  %454 = phi i64 [%437, %$101] ; # Prg
  %455 = phi i64 [%445, %$101] ; # ->
; # (set $Key KeyS $Typ TypS)
  %456 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %424, i64* %456
  %457 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %422, i64* %457
  br label %$41
$41:
  %458 = phi i64 [%370, %$44], [%417, %$99] ; # X
  %459 = phi i64 [%371, %$44], [%418, %$99] ; # Y
  %460 = phi i64 [%372, %$44], [%419, %$99] ; # P
  %461 = phi i64 [%373, %$44], [%455, %$99] ; # ->
; # (val $Bind)
  %462 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %463 = load i64, i64* %462
; # (loop (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq...
  br label %$108
$108:
  %464 = phi i64 [%458, %$41], [%474, %$109] ; # X
  %465 = phi i64 [%459, %$41], [%475, %$109] ; # Y
  %466 = phi i64 [%463, %$41], [%479, %$109] ; # P
; # (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq P (va...
; # (val 2 P)
  %467 = inttoptr i64 %466 to i64*
  %468 = getelementptr i64, i64* %467, i32 1
  %469 = load i64, i64* %468
; # (set Sym (val P))
; # (val P)
  %470 = inttoptr i64 %466 to i64*
  %471 = load i64, i64* %470
  %472 = inttoptr i64 %469 to i64*
  store i64 %471, i64* %472
; # (? (== $At Sym))
; # (== $At Sym)
  %473 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %469
  br i1 %473, label %$110, label %$109
$109:
  %474 = phi i64 [%464, %$108] ; # X
  %475 = phi i64 [%465, %$108] ; # Y
  %476 = phi i64 [%466, %$108] ; # P
; # (val 3 P)
  %477 = inttoptr i64 %476 to i64*
  %478 = getelementptr i64, i64* %477, i32 2
  %479 = load i64, i64* %478
  br label %$108
$110:
  %480 = phi i64 [%464, %$108] ; # X
  %481 = phi i64 [%465, %$108] ; # Y
  %482 = phi i64 [%466, %$108] ; # P
  %483 = phi i64 [0, %$108] ; # ->
; # (set $Bind (val 3 P))
; # (val 3 P)
  %484 = inttoptr i64 %482 to i64*
  %485 = getelementptr i64, i64* %484, i32 2
  %486 = load i64, i64* %485
  %487 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %486, i64* %487
  ret i64 %461
}

define i64 @method(i64, i64) align 8 {
$1:
; # (when (pair (val Obj)) (let L @ (while (pair (car L)) (let Y @ (w...
; # (val Obj)
  %2 = inttoptr i64 %0 to i64*
  %3 = load i64, i64* %2
; # (pair (val Obj))
  %4 = and i64 %3, 15
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
; # (let L @ (while (pair (car L)) (let Y @ (when (== Key (car Y)) (r...
; # (while (pair (car L)) (let Y @ (when (== Key (car Y)) (ret (cdr Y...
  br label %$4
$4:
  %6 = phi i64 [%3, %$2], [%26, %$10] ; # L
; # (car L)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (pair (car L))
  %9 = and i64 %8, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$5, label %$6
$5:
  %11 = phi i64 [%6, %$4] ; # L
; # (let Y @ (when (== Key (car Y)) (ret (cdr Y))))
; # (when (== Key (car Y)) (ret (cdr Y)))
; # (car Y)
  %12 = inttoptr i64 %8 to i64*
  %13 = load i64, i64* %12
; # (== Key (car Y))
  %14 = icmp eq i64 %1, %13
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%11, %$5] ; # L
; # (cdr Y)
  %16 = inttoptr i64 %8 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (ret (cdr Y))
  ret i64 %18
$8:
  %19 = phi i64 [%11, %$5] ; # L
; # (when (atom (shift L)) (ret 0))
; # (shift L)
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (atom (shift L))
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$9, label %$10
$9:
  %25 = phi i64 [%22, %$8] ; # L
; # (ret 0)
  ret i64 0
$10:
  %26 = phi i64 [%22, %$8] ; # L
  br label %$4
$6:
  %27 = phi i64 [%6, %$4] ; # L
; # (stkChk 0)
  %28 = load i8*, i8** @$StkLimit
  %29 = call i8* @llvm.stacksave()
  %30 = icmp ugt i8* %28, %29
  br i1 %30, label %$11, label %$12
$11:
  call void @stkErr(i64 0)
  unreachable
$12:
; # (loop (when (method (car (set $Ret L)) Key) (ret @)) (? (atom (sh...
  br label %$13
$13:
  %31 = phi i64 [%27, %$12], [%43, %$16] ; # L
; # (when (method (car (set $Ret L)) Key) (ret @))
; # (set $Ret L)
  store i64 %31, i64* @$Ret
; # (car (set $Ret L))
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (method (car (set $Ret L)) Key)
  %34 = call i64 @method(i64 %33, i64 %1)
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$14, label %$15
$14:
  %36 = phi i64 [%31, %$13] ; # L
; # (ret @)
  ret i64 %34
$15:
  %37 = phi i64 [%31, %$13] ; # L
; # (? (atom (shift L)))
; # (shift L)
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (atom (shift L))
  %41 = and i64 %40, 15
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$17, label %$16
$16:
  %43 = phi i64 [%40, %$15] ; # L
  br label %$13
$17:
  %44 = phi i64 [%40, %$15] ; # L
  %45 = phi i64 [0, %$15] ; # ->
  br label %$3
$3:
  ret i64 0
}

define i64 @__meth(i64, i64) align 8 {
$1:
; # (let (X (cdr Exe) Obj (save (eval (car X)))) (when (sym? (val (ta...
; # (cdr Exe)
  %2 = inttoptr i64 %0 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$4, label %$3
$4:
  br label %$2
$3:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$6, label %$5
$6:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$2
$5:
  %13 = call i64 @evList(i64 %6)
  br label %$2
$2:
  %14 = phi i64 [%6, %$4], [%12, %$6], [%13, %$5] ; # ->
; # (save (eval (car X)))
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %22
; # (when (sym? (val (tail (needSymb Exe Obj)))) (dbFetch Exe Obj))
; # (needSymb Exe Obj)
  %23 = xor i64 %14, 8
  %24 = and i64 %23, 14
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %14)
  unreachable
$8:
; # (tail (needSymb Exe Obj))
  %26 = add i64 %14, -8
; # (val (tail (needSymb Exe Obj)))
  %27 = inttoptr i64 %26 to i64*
  %28 = load i64, i64* %27
; # (sym? (val (tail (needSymb Exe Obj))))
  %29 = and i64 %28, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$9, label %$10
$9:
; # (dbFetch Exe Obj)
  call void @dbFetch(i64 %0, i64 %14)
  br label %$10
$10:
; # (set $Ret 0)
  store i64 0, i64* @$Ret
; # (if (method Obj Key) (evMethod Obj (val $Ret) Key @ (cdr X)) (err...
; # (method Obj Key)
  %31 = call i64 @method(i64 %14, i64 %1)
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$12
$11:
; # (val $Ret)
  %33 = load i64, i64* @$Ret
; # (cdr X)
  %34 = inttoptr i64 %4 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  %36 = load i64, i64* %35
; # (evMethod Obj (val $Ret) Key @ (cdr X))
  %37 = call i64 @evMethod(i64 %14, i64 %33, i64 %1, i64 %31, i64 %36)
  br label %$13
$12:
; # (err Exe Key ($ "Bad message") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([12 x i8]* @$70 to i8*), i8* null)
  unreachable
$13:
  %38 = phi i64 [%37, %$11] ; # ->
; # (drop *Safe)
  %39 = inttoptr i64 %18 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  %41 = load i64, i64* %40
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %41, i64* %42
  ret i64 %38
}

define i64 @_box(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (consSym ZERO (eval (cadr Exe)))
  %14 = call i64 @consSym(i64 2, i64 %13)
  ret i64 %14
}

define i64 @_new(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X)) Obj (save (cond ((pair Y) (cons...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((pair Y) (consSym ZERO Y)) ((nil? Y) (consSym ZERO ZERO)) ...
; # (pair Y)
  %16 = and i64 %15, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = phi i64 [%7, %$2] ; # X
; # (consSym ZERO Y)
  %19 = call i64 @consSym(i64 2, i64 %15)
  br label %$7
$8:
  %20 = phi i64 [%7, %$2] ; # X
; # (nil? Y)
  %21 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$11, label %$10
$11:
  %22 = phi i64 [%20, %$8] ; # X
; # (consSym ZERO ZERO)
  %23 = call i64 @consSym(i64 2, i64 2)
  br label %$7
$10:
  %24 = phi i64 [%20, %$8] ; # X
; # (let Nm (newId Exe (if (cnt? Y) (i32 (int @)) 1)) (prog1 (extern ...
; # (if (cnt? Y) (i32 (int @)) 1)
; # (cnt? Y)
  %25 = and i64 %15, 2
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$12, label %$13
$12:
  %27 = phi i64 [%24, %$10] ; # X
; # (int @)
  %28 = lshr i64 %15, 4
; # (i32 (int @))
  %29 = trunc i64 %28 to i32
  br label %$14
$13:
  %30 = phi i64 [%24, %$10] ; # X
  br label %$14
$14:
  %31 = phi i64 [%27, %$12], [%30, %$13] ; # X
  %32 = phi i32 [%29, %$12], [1, %$13] ; # ->
; # (newId Exe (if (cnt? Y) (i32 (int @)) 1))
  %33 = call i64 @newId(i64 %0, i32 %32)
; # (prog1 (extern Nm) (set (tail @) (sign (shr 1 (add Nm Nm) 1))))
; # (extern Nm)
  %34 = call i64 @extern(i64 %33)
; # (set (tail @) (sign (shr 1 (add Nm Nm) 1)))
; # (tail @)
  %35 = add i64 %34, -8
; # (add Nm Nm)
  %36 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %33, i64 %33)
  %37 = extractvalue {i64, i1} %36, 1
  %38 = extractvalue {i64, i1} %36, 0
; # (shr 1 (add Nm Nm) 1)
  %39 = call i64 @llvm.fshr.i64(i64 1, i64 %38, i64 1)
; # (sign (shr 1 (add Nm Nm) 1))
  %40 = or i64 %39, 8
  %41 = inttoptr i64 %35 to i64*
  store i64 %40, i64* %41
  br label %$7
$7:
  %42 = phi i64 [%18, %$9], [%22, %$11], [%31, %$14] ; # X
  %43 = phi i64 [%19, %$9], [%23, %$11], [%34, %$14] ; # ->
; # (save (cond ((pair Y) (consSym ZERO Y)) ((nil? Y) (consSym ZERO Z...
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %45 = load i64, i64* %44
  %46 = alloca i64, i64 2, align 16
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 %43, i64* %48
  %49 = add i64 %47, 8
  %50 = inttoptr i64 %49 to i64*
  store i64 %45, i64* %50
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %51
; # (unless (pair Y) (set Obj (eval (++ X))))
; # (pair Y)
  %52 = and i64 %15, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$16, label %$15
$15:
  %54 = phi i64 [%42, %$7] ; # X
; # (set Obj (eval (++ X)))
; # (++ X)
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
  %57 = getelementptr i64, i64* %55, i32 1
  %58 = load i64, i64* %57
; # (eval (++ X))
  %59 = and i64 %56, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$19, label %$18
$19:
  br label %$17
$18:
  %61 = and i64 %56, 8
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$21, label %$20
$21:
  %63 = inttoptr i64 %56 to i64*
  %64 = load i64, i64* %63
  br label %$17
$20:
  %65 = call i64 @evList(i64 %56)
  br label %$17
$17:
  %66 = phi i64 [%56, %$19], [%64, %$21], [%65, %$20] ; # ->
  %67 = inttoptr i64 %43 to i64*
  store i64 %66, i64* %67
  br label %$16
$16:
  %68 = phi i64 [%42, %$7], [%58, %$17] ; # X
; # (set $Ret 0)
  store i64 0, i64* @$Ret
; # (cond ((method Obj $T) (evMethod Obj (val $Ret) $T @ X)) ((pair X...
; # (method Obj $T)
  %69 = call i64 @method(i64 %43, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64))
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$24, label %$23
$24:
  %71 = phi i64 [%68, %$16] ; # X
; # (val $Ret)
  %72 = load i64, i64* @$Ret
; # (evMethod Obj (val $Ret) $T @ X)
  %73 = call i64 @evMethod(i64 %43, i64 %72, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), i64 %69, i64 %71)
  br label %$22
$23:
  %74 = phi i64 [%68, %$16] ; # X
; # (pair X)
  %75 = and i64 %74, 15
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %$26, label %$25
$26:
  %77 = phi i64 [%74, %$23] ; # X
; # (let K (link (push NIL NIL)) (loop (put Obj (set K (eval (++ X)))...
; # (push NIL NIL)
  %78 = alloca i64, i64 2, align 16
  %79 = ptrtoint i64* %78 to i64
; # (link (push NIL NIL))
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %79 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  store i64 %81, i64* %83
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %79, i64* %84
; # (loop (put Obj (set K (eval (++ X))) (eval (++ X))) (? (atom X)))...
  br label %$27
$27:
  %85 = phi i64 [%77, %$26], [%113, %$38] ; # X
; # (set K (eval (++ X)))
; # (++ X)
  %86 = inttoptr i64 %85 to i64*
  %87 = load i64, i64* %86
  %88 = getelementptr i64, i64* %86, i32 1
  %89 = load i64, i64* %88
; # (eval (++ X))
  %90 = and i64 %87, 6
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$30, label %$29
$30:
  br label %$28
$29:
  %92 = and i64 %87, 8
  %93 = icmp ne i64 %92, 0
  br i1 %93, label %$32, label %$31
$32:
  %94 = inttoptr i64 %87 to i64*
  %95 = load i64, i64* %94
  br label %$28
$31:
  %96 = call i64 @evList(i64 %87)
  br label %$28
$28:
  %97 = phi i64 [%87, %$30], [%95, %$32], [%96, %$31] ; # ->
  %98 = inttoptr i64 %79 to i64*
  store i64 %97, i64* %98
; # (++ X)
  %99 = inttoptr i64 %89 to i64*
  %100 = load i64, i64* %99
  %101 = getelementptr i64, i64* %99, i32 1
  %102 = load i64, i64* %101
; # (eval (++ X))
  %103 = and i64 %100, 6
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$35, label %$34
$35:
  br label %$33
$34:
  %105 = and i64 %100, 8
  %106 = icmp ne i64 %105, 0
  br i1 %106, label %$37, label %$36
$37:
  %107 = inttoptr i64 %100 to i64*
  %108 = load i64, i64* %107
  br label %$33
$36:
  %109 = call i64 @evList(i64 %100)
  br label %$33
$33:
  %110 = phi i64 [%100, %$35], [%108, %$37], [%109, %$36] ; # ->
; # (put Obj (set K (eval (++ X))) (eval (++ X)))
  call void @put(i64 %43, i64 %97, i64 %110)
; # (? (atom X))
; # (atom X)
  %111 = and i64 %102, 15
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$39, label %$38
$38:
  %113 = phi i64 [%102, %$33] ; # X
  br label %$27
$39:
  %114 = phi i64 [%102, %$33] ; # X
  %115 = phi i64 [0, %$33] ; # ->
  br label %$22
$25:
  %116 = phi i64 [%74, %$23] ; # X
  br label %$22
$22:
  %117 = phi i64 [%71, %$24], [%114, %$39], [%116, %$25] ; # X
  %118 = phi i64 [%73, %$24], [%115, %$39], [0, %$25] ; # ->
; # (drop *Safe)
  %119 = inttoptr i64 %47 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %121, i64* %122
  ret i64 %43
}

define i64 @_type(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (ifn (symb? Y) $Nil (when (sy...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (ifn (symb? Y) $Nil (when (sym? (val (tail Y))) (dbFetch Exe Y)) ...
; # (symb? Y)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  br label %$9
$8:
; # (when (sym? (val (tail Y))) (dbFetch Exe Y))
; # (tail Y)
  %17 = add i64 %13, -8
; # (val (tail Y))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail Y)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$11
$10:
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %13)
  br label %$11
$11:
; # (let (V (val Y) Z V) (loop (? (atom V) $Nil) (? (atom (car V)) (l...
; # (val Y)
  %22 = inttoptr i64 %13 to i64*
  %23 = load i64, i64* %22
; # (loop (? (atom V) $Nil) (? (atom (car V)) (let R V (loop (? (not ...
  br label %$12
$12:
  %24 = phi i64 [%23, %$11], [%66, %$29] ; # V
; # (? (atom V) $Nil)
; # (atom V)
  %25 = and i64 %24, 15
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$15, label %$13
$15:
  %27 = phi i64 [%24, %$12] ; # V
  br label %$14
$13:
  %28 = phi i64 [%24, %$12] ; # V
; # (? (atom (car V)) (let R V (loop (? (not (symb? (car V))) $Nil) (...
; # (car V)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (atom (car V))
  %31 = and i64 %30, 15
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$17, label %$16
$17:
  %33 = phi i64 [%28, %$13] ; # V
; # (let R V (loop (? (not (symb? (car V))) $Nil) (? (atom (shift V))...
; # (loop (? (not (symb? (car V))) $Nil) (? (atom (shift V)) (if (nil...
  br label %$18
$18:
  %34 = phi i64 [%33, %$17], [%57, %$27] ; # V
; # (? (not (symb? (car V))) $Nil)
; # (car V)
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (symb? (car V))
  %37 = xor i64 %36, 8
  %38 = and i64 %37, 14
  %39 = icmp eq i64 %38, 0
; # (not (symb? (car V)))
  %40 = icmp eq i1 %39, 0
  br i1 %40, label %$21, label %$19
$21:
  %41 = phi i64 [%34, %$18] ; # V
  br label %$20
$19:
  %42 = phi i64 [%34, %$18] ; # V
; # (? (atom (shift V)) (if (nil? V) R $Nil))
; # (shift V)
  %43 = inttoptr i64 %42 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
; # (atom (shift V))
  %46 = and i64 %45, 15
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$23, label %$22
$23:
  %48 = phi i64 [%45, %$19] ; # V
; # (if (nil? V) R $Nil)
; # (nil? V)
  %49 = icmp eq i64 %48, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %49, label %$24, label %$25
$24:
  %50 = phi i64 [%48, %$23] ; # V
  br label %$26
$25:
  %51 = phi i64 [%48, %$23] ; # V
  br label %$26
$26:
  %52 = phi i64 [%50, %$24], [%51, %$25] ; # V
  %53 = phi i64 [%33, %$24], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$25] ; # ->
  br label %$20
$22:
  %54 = phi i64 [%45, %$19] ; # V
; # (? (== Z V) $Nil)
; # (== Z V)
  %55 = icmp eq i64 %23, %54
  br i1 %55, label %$28, label %$27
$28:
  %56 = phi i64 [%54, %$22] ; # V
  br label %$20
$27:
  %57 = phi i64 [%54, %$22] ; # V
  br label %$18
$20:
  %58 = phi i64 [%41, %$21], [%52, %$26], [%56, %$28] ; # V
  %59 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21], [%53, %$26], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$28] ; # ->
  br label %$14
$16:
  %60 = phi i64 [%28, %$13] ; # V
; # (? (== Z (shift V)) $Nil)
; # (shift V)
  %61 = inttoptr i64 %60 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
; # (== Z (shift V))
  %64 = icmp eq i64 %23, %63
  br i1 %64, label %$30, label %$29
$30:
  %65 = phi i64 [%63, %$16] ; # V
  br label %$14
$29:
  %66 = phi i64 [%63, %$16] ; # V
  br label %$12
$14:
  %67 = phi i64 [%27, %$15], [%58, %$20], [%65, %$30] ; # V
  %68 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%59, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$30] ; # ->
  br label %$9
$9:
  %69 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%68, %$14] ; # ->
  ret i64 %69
}

define i1 @isa(i64, i64) align 8 {
$1:
; # (let (V (val Obj) Z V) (loop (? (atom V) NO) (? (atom (car V)) (s...
; # (val Obj)
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (loop (? (atom V) NO) (? (atom (car V)) (stkChk 0) (loop (? (not ...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%50, %$22] ; # V
; # (? (atom V) NO)
; # (atom V)
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%4, %$2] ; # V
  br label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # V
; # (? (atom (car V)) (stkChk 0) (loop (? (not (symb? (car V))) NO) (...
; # (car V)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (atom (car V))
  %11 = and i64 %10, 15
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = phi i64 [%8, %$3] ; # V
; # (stkChk 0)
  %14 = load i8*, i8** @$StkLimit
  %15 = call i8* @llvm.stacksave()
  %16 = icmp ugt i8* %14, %15
  br i1 %16, label %$8, label %$9
$8:
  call void @stkErr(i64 0)
  unreachable
$9:
; # (loop (? (not (symb? (car V))) NO) (? (== @ Cls) YES) (? (isa Cls...
  br label %$10
$10:
  %17 = phi i64 [%13, %$9], [%41, %$20] ; # V
; # (? (not (symb? (car V))) NO)
; # (car V)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (symb? (car V))
  %20 = xor i64 %19, 8
  %21 = and i64 %20, 14
  %22 = icmp eq i64 %21, 0
; # (not (symb? (car V)))
  %23 = icmp eq i1 %22, 0
  br i1 %23, label %$13, label %$11
$13:
  %24 = phi i64 [%17, %$10] ; # V
  br label %$12
$11:
  %25 = phi i64 [%17, %$10] ; # V
; # (? (== @ Cls) YES)
; # (== @ Cls)
  %26 = icmp eq i64 %19, %0
  br i1 %26, label %$15, label %$14
$15:
  %27 = phi i64 [%25, %$11] ; # V
  br label %$12
$14:
  %28 = phi i64 [%25, %$11] ; # V
; # (? (isa Cls @) YES)
; # (isa Cls @)
  %29 = call i1 @isa(i64 %0, i64 %19)
  br i1 %29, label %$17, label %$16
$17:
  %30 = phi i64 [%28, %$14] ; # V
  br label %$12
$16:
  %31 = phi i64 [%28, %$14] ; # V
; # (? (atom (shift V)) NO)
; # (shift V)
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (atom (shift V))
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$19, label %$18
$19:
  %37 = phi i64 [%34, %$16] ; # V
  br label %$12
$18:
  %38 = phi i64 [%34, %$16] ; # V
; # (? (== Z V) NO)
; # (== Z V)
  %39 = icmp eq i64 %3, %38
  br i1 %39, label %$21, label %$20
$21:
  %40 = phi i64 [%38, %$18] ; # V
  br label %$12
$20:
  %41 = phi i64 [%38, %$18] ; # V
  br label %$10
$12:
  %42 = phi i64 [%24, %$13], [%27, %$15], [%30, %$17], [%37, %$19], [%40, %$21] ; # V
  %43 = phi i1 [0, %$13], [1, %$15], [1, %$17], [0, %$19], [0, %$21] ; # ->
  br label %$4
$6:
  %44 = phi i64 [%8, %$3] ; # V
; # (? (== Z (shift V)) NO)
; # (shift V)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (== Z (shift V))
  %48 = icmp eq i64 %3, %47
  br i1 %48, label %$23, label %$22
$23:
  %49 = phi i64 [%47, %$6] ; # V
  br label %$4
$22:
  %50 = phi i64 [%47, %$6] ; # V
  br label %$2
$4:
  %51 = phi i64 [%7, %$5], [%42, %$12], [%49, %$23] ; # V
  %52 = phi i1 [0, %$5], [%43, %$12], [0, %$23] ; # ->
  ret i1 %52
}

define i64 @_isa(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (ifn (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (ifn (symb? Z) $Nil (when (sym? (val (tail Z))) (dbFetch Exe Z)) ...
; # (symb? Z)
  %34 = xor i64 %33, 8
  %35 = and i64 %34, 14
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$13, label %$12
$12:
  %37 = phi i64 [%15, %$7] ; # Y
  br label %$14
$13:
  %38 = phi i64 [%15, %$7] ; # Y
; # (when (sym? (val (tail Z))) (dbFetch Exe Z))
; # (tail Z)
  %39 = add i64 %33, -8
; # (val (tail Z))
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
; # (sym? (val (tail Z)))
  %42 = and i64 %41, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$15, label %$16
$15:
  %44 = phi i64 [%38, %$13] ; # Y
; # (dbFetch Exe Z)
  call void @dbFetch(i64 %0, i64 %33)
  br label %$16
$16:
  %45 = phi i64 [%38, %$13], [%44, %$15] ; # Y
; # (cond ((pair Y) (loop (? (not (isa (car Y) Z)) $Nil) (? (atom (sh...
; # (pair Y)
  %46 = and i64 %45, 15
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %$19, label %$18
$19:
  %48 = phi i64 [%45, %$16] ; # Y
; # (loop (? (not (isa (car Y) Z)) $Nil) (? (atom (shift Y)) Z))
  br label %$20
$20:
  %49 = phi i64 [%48, %$19], [%62, %$24] ; # Y
; # (? (not (isa (car Y) Z)) $Nil)
; # (car Y)
  %50 = inttoptr i64 %49 to i64*
  %51 = load i64, i64* %50
; # (isa (car Y) Z)
  %52 = call i1 @isa(i64 %51, i64 %33)
; # (not (isa (car Y) Z))
  %53 = icmp eq i1 %52, 0
  br i1 %53, label %$23, label %$21
$23:
  %54 = phi i64 [%49, %$20] ; # Y
  br label %$22
$21:
  %55 = phi i64 [%49, %$20] ; # Y
; # (? (atom (shift Y)) Z)
; # (shift Y)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (atom (shift Y))
  %59 = and i64 %58, 15
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$25, label %$24
$25:
  %61 = phi i64 [%58, %$21] ; # Y
  br label %$22
$24:
  %62 = phi i64 [%58, %$21] ; # Y
  br label %$20
$22:
  %63 = phi i64 [%54, %$23], [%61, %$25] ; # Y
  %64 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$23], [%33, %$25] ; # ->
  br label %$17
$18:
  %65 = phi i64 [%45, %$16] ; # Y
; # (isa Y Z)
  %66 = call i1 @isa(i64 %65, i64 %33)
  br i1 %66, label %$27, label %$26
$27:
  %67 = phi i64 [%65, %$18] ; # Y
  br label %$17
$26:
  %68 = phi i64 [%65, %$18] ; # Y
  br label %$17
$17:
  %69 = phi i64 [%63, %$22], [%67, %$27], [%68, %$26] ; # Y
  %70 = phi i64 [%64, %$22], [%33, %$27], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$26] ; # ->
  br label %$14
$14:
  %71 = phi i64 [%37, %$12], [%69, %$17] ; # Y
  %72 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%70, %$17] ; # ->
; # (drop *Safe)
  %73 = inttoptr i64 %19 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %76
  ret i64 %72
}

define i64 @_method(i64) align 8 {
$1:
; # (let (X (cdr Exe) Msg (save (eval (++ X))) Obj (needSymb Exe (eva...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (needSymb Exe (eval (car X)))
  %34 = xor i64 %33, 8
  %35 = and i64 %34, 14
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$13, label %$12
$12:
  call void @symErr(i64 %0, i64 %33)
  unreachable
$13:
; # (when (sym? (val (tail Obj))) (dbFetch Exe Obj))
; # (tail Obj)
  %37 = add i64 %33, -8
; # (val (tail Obj))
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
; # (sym? (val (tail Obj)))
  %40 = and i64 %39, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$14, label %$15
$14:
; # (dbFetch Exe Obj)
  call void @dbFetch(i64 %0, i64 %33)
  br label %$15
$15:
; # (if (method Obj Msg) @ $Nil)
; # (method Obj Msg)
  %42 = call i64 @method(i64 %33, i64 %15)
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$16, label %$17
$16:
  br label %$18
$17:
  br label %$18
$18:
  %44 = phi i64 [%42, %$16], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %45 = inttoptr i64 %19 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret i64 %44
}

define i64 @_send(i64) align 8 {
$1:
; # (let (X (cdr Exe) Msg (save (eval (++ X))) Obj (save (needSymb Ex...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (needSymb Exe (eval (car X)))
  %34 = xor i64 %33, 8
  %35 = and i64 %34, 14
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$13, label %$12
$12:
  call void @symErr(i64 %0, i64 %33)
  unreachable
$13:
; # (save (needSymb Exe (eval (car X))))
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %38 = load i64, i64* %37
  %39 = alloca i64, i64 2, align 16
  %40 = ptrtoint i64* %39 to i64
  %41 = inttoptr i64 %40 to i64*
  store i64 %33, i64* %41
  %42 = add i64 %40, 8
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %44
; # (when (sym? (val (tail Obj))) (dbFetch Exe Obj))
; # (tail Obj)
  %45 = add i64 %33, -8
; # (val (tail Obj))
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (sym? (val (tail Obj)))
  %48 = and i64 %47, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$14, label %$15
$14:
; # (dbFetch Exe Obj)
  call void @dbFetch(i64 %0, i64 %33)
  br label %$15
$15:
; # (set $Ret 0)
  store i64 0, i64* @$Ret
; # (if (method Obj Msg) (evMethod Obj (val $Ret) Msg @ (cdr X)) (err...
; # (method Obj Msg)
  %50 = call i64 @method(i64 %33, i64 %15)
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$16, label %$17
$16:
; # (val $Ret)
  %52 = load i64, i64* @$Ret
; # (cdr X)
  %53 = inttoptr i64 %7 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
; # (evMethod Obj (val $Ret) Msg @ (cdr X))
  %56 = call i64 @evMethod(i64 %33, i64 %52, i64 %15, i64 %50, i64 %55)
  br label %$18
$17:
; # (err Exe Msg ($ "Bad message") null)
  call void @err(i64 %0, i64 %15, i8* bitcast ([12 x i8]* @$70 to i8*), i8* null)
  unreachable
$18:
  %57 = phi i64 [%56, %$16] ; # ->
; # (drop *Safe)
  %58 = inttoptr i64 %19 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %61
  ret i64 %57
}

define i64 @_try(i64) align 8 {
$1:
; # (let (X (cdr Exe) Msg (save (eval (++ X))) Obj (save (eval (car X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %33, i64* %38
  %39 = add i64 %37, 8
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %41
; # (ifn (symb? Obj) $Nil (when (sym? (val (tail Obj))) (unless (isLi...
; # (symb? Obj)
  %42 = xor i64 %33, 8
  %43 = and i64 %42, 14
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$13, label %$12
$12:
  br label %$14
$13:
; # (when (sym? (val (tail Obj))) (unless (isLife Obj) (goto 1)) (dbF...
; # (tail Obj)
  %45 = add i64 %33, -8
; # (val (tail Obj))
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (sym? (val (tail Obj)))
  %48 = and i64 %47, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$15, label %$16
$15:
; # (unless (isLife Obj) (goto 1))
; # (isLife Obj)
  %50 = call i1 @isLife(i64 %33)
  br i1 %50, label %$18, label %$17
$17:
; # (goto 1)
  br label %$-1
$18:
; # (dbFetch Exe Obj)
  call void @dbFetch(i64 %0, i64 %33)
  br label %$16
$16:
; # (set $Ret 0)
  store i64 0, i64* @$Ret
; # (if (method Obj Msg) (evMethod Obj (val $Ret) Msg @ (cdr X)) (: 1...
; # (method Obj Msg)
  %51 = call i64 @method(i64 %33, i64 %15)
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$19, label %$20
$19:
; # (val $Ret)
  %53 = load i64, i64* @$Ret
; # (cdr X)
  %54 = inttoptr i64 %7 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
; # (evMethod Obj (val $Ret) Msg @ (cdr X))
  %57 = call i64 @evMethod(i64 %33, i64 %53, i64 %15, i64 %51, i64 %56)
  br label %$21
$20:
; # (: 1 $Nil)
  br label %$-1
$-1:
  br label %$21
$21:
  %58 = phi i64 [%57, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$-1] ; # ->
  br label %$14
$14:
  %59 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%58, %$21] ; # ->
; # (drop *Safe)
  %60 = inttoptr i64 %19 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %62, i64* %63
  ret i64 %59
}

define i64 @_super(i64) align 8 {
$1:
; # (let (Lst (val (if (val $Typ) (car @) (val $This))) Key (val $Key...
; # (if (val $Typ) (car @) (val $This))
; # (val $Typ)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  %2 = load i64, i64* %1
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (car @)
  %4 = inttoptr i64 %2 to i64*
  %5 = load i64, i64* %4
  br label %$4
$3:
; # (val $This)
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %7 = load i64, i64* %6
  br label %$4
$4:
  %8 = phi i64 [%5, %$2], [%7, %$3] ; # ->
; # (val (if (val $Typ) (car @) (val $This)))
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (val $Key)
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  %12 = load i64, i64* %11
; # (while (pair (car Lst)) (shift Lst))
  br label %$5
$5:
  %13 = phi i64 [%10, %$4], [%21, %$6] ; # Lst
; # (car Lst)
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
; # (pair (car Lst))
  %16 = and i64 %15, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$6, label %$7
$6:
  %18 = phi i64 [%13, %$5] ; # Lst
; # (shift Lst)
  %19 = inttoptr i64 %18 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
  br label %$5
$7:
  %22 = phi i64 [%13, %$5] ; # Lst
; # (loop (when (atom Lst) (err Exe Key ($ "Bad super") null)) (? (me...
  br label %$8
$8:
  %23 = phi i64 [%22, %$7], [%46, %$11] ; # Lst
; # (when (atom Lst) (err Exe Key ($ "Bad super") null))
; # (atom Lst)
  %24 = and i64 %23, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$9, label %$10
$9:
  %26 = phi i64 [%23, %$8] ; # Lst
; # (err Exe Key ($ "Bad super") null)
  call void @err(i64 %0, i64 %12, i8* bitcast ([10 x i8]* @$71 to i8*), i8* null)
  unreachable
$10:
  %27 = phi i64 [%23, %$8] ; # Lst
; # (? (method (car (set $Ret Lst)) Key) (let (TypS (val $Typ) KeyS (...
; # (set $Ret Lst)
  store i64 %27, i64* @$Ret
; # (car (set $Ret Lst))
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (method (car (set $Ret Lst)) Key)
  %30 = call i64 @method(i64 %29, i64 %12)
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$13, label %$11
$13:
  %32 = phi i64 [%27, %$10] ; # Lst
; # (let (TypS (val $Typ) KeyS (val $Key)) (set $Typ (val $Ret) $Key ...
; # (val $Typ)
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  %34 = load i64, i64* %33
; # (val $Key)
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  %36 = load i64, i64* %35
; # (set $Typ (val $Ret) $Key Key)
; # (val $Ret)
  %37 = load i64, i64* @$Ret
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %37, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %12, i64* %39
; # (prog1 (evExpr @ Exe) (set $Key KeyS $Typ TypS))
; # (evExpr @ Exe)
  %40 = call i64 @evExpr(i64 %30, i64 %0)
; # (set $Key KeyS $Typ TypS)
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %36, i64* %41
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %34, i64* %42
  br label %$12
$11:
  %43 = phi i64 [%27, %$10] ; # Lst
; # (shift Lst)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
  br label %$8
$12:
  %47 = phi i64 [%32, %$13] ; # Lst
  %48 = phi i64 [%40, %$13] ; # ->
  ret i64 %48
}

define i64 @extra(i64, i64) align 8 {
$1:
; # (let Lst (val Obj) (while (pair (car Lst)) (shift Lst)) (loop (? ...
; # (val Obj)
  %2 = inttoptr i64 %0 to i64*
  %3 = load i64, i64* %2
; # (while (pair (car Lst)) (shift Lst))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%12, %$3] ; # Lst
; # (car Lst)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (pair (car Lst))
  %7 = and i64 %6, 15
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %$3, label %$4
$3:
  %9 = phi i64 [%4, %$2] ; # Lst
; # (shift Lst)
  %10 = inttoptr i64 %9 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
  br label %$2
$4:
  %13 = phi i64 [%4, %$2] ; # Lst
; # (loop (? (atom Lst) -1) (? (== Lst (val $Typ)) (loop (? (atom (sh...
  br label %$5
$5:
  %14 = phi i64 [%13, %$4], [%70, %$21] ; # Lst
; # (? (atom Lst) -1)
; # (atom Lst)
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$8, label %$6
$8:
  %17 = phi i64 [%14, %$5] ; # Lst
  br label %$7
$6:
  %18 = phi i64 [%14, %$5] ; # Lst
; # (? (== Lst (val $Typ)) (loop (? (atom (shift Lst)) 0) (? (method ...
; # (val $Typ)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  %20 = load i64, i64* %19
; # (== Lst (val $Typ))
  %21 = icmp eq i64 %18, %20
  br i1 %21, label %$10, label %$9
$10:
  %22 = phi i64 [%18, %$6] ; # Lst
; # (loop (? (atom (shift Lst)) 0) (? (method (car (set $Ret Lst)) Ke...
  br label %$11
$11:
  %23 = phi i64 [%22, %$10], [%36, %$15] ; # Lst
; # (? (atom (shift Lst)) 0)
; # (shift Lst)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift Lst))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$14, label %$12
$14:
  %29 = phi i64 [%26, %$11] ; # Lst
  br label %$13
$12:
  %30 = phi i64 [%26, %$11] ; # Lst
; # (? (method (car (set $Ret Lst)) Key) @)
; # (set $Ret Lst)
  store i64 %30, i64* @$Ret
; # (car (set $Ret Lst))
  %31 = inttoptr i64 %30 to i64*
  %32 = load i64, i64* %31
; # (method (car (set $Ret Lst)) Key)
  %33 = call i64 @method(i64 %32, i64 %1)
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$16, label %$15
$16:
  %35 = phi i64 [%30, %$12] ; # Lst
  br label %$13
$15:
  %36 = phi i64 [%30, %$12] ; # Lst
  br label %$11
$13:
  %37 = phi i64 [%29, %$14], [%35, %$16] ; # Lst
  %38 = phi i64 [0, %$14], [%33, %$16] ; # ->
  br label %$7
$9:
  %39 = phi i64 [%18, %$6] ; # Lst
; # (stkChk 0)
  %40 = load i8*, i8** @$StkLimit
  %41 = call i8* @llvm.stacksave()
  %42 = icmp ugt i8* %40, %41
  br i1 %42, label %$17, label %$18
$17:
  call void @stkErr(i64 0)
  unreachable
$18:
; # (? (gt0 (extra (car Lst) Key)) @)
; # (car Lst)
  %43 = inttoptr i64 %39 to i64*
  %44 = load i64, i64* %43
; # (extra (car Lst) Key)
  %45 = call i64 @extra(i64 %44, i64 %1)
; # (gt0 (extra (car Lst) Key))
  %46 = icmp sgt i64 %45, 0
  br i1 %46, label %$20, label %$19
$20:
  %47 = phi i64 [%39, %$18] ; # Lst
  br label %$7
$19:
  %48 = phi i64 [%39, %$18] ; # Lst
; # (? (=0 @) (loop (? (atom (shift Lst)) 0) (? (method (car (set $Re...
; # (=0 @)
  %49 = icmp eq i64 %45, 0
  br i1 %49, label %$22, label %$21
$22:
  %50 = phi i64 [%48, %$19] ; # Lst
; # (loop (? (atom (shift Lst)) 0) (? (method (car (set $Ret Lst)) Ke...
  br label %$23
$23:
  %51 = phi i64 [%50, %$22], [%64, %$27] ; # Lst
; # (? (atom (shift Lst)) 0)
; # (shift Lst)
  %52 = inttoptr i64 %51 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (atom (shift Lst))
  %55 = and i64 %54, 15
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$26, label %$24
$26:
  %57 = phi i64 [%54, %$23] ; # Lst
  br label %$25
$24:
  %58 = phi i64 [%54, %$23] ; # Lst
; # (? (method (car (set $Ret Lst)) Key) @)
; # (set $Ret Lst)
  store i64 %58, i64* @$Ret
; # (car (set $Ret Lst))
  %59 = inttoptr i64 %58 to i64*
  %60 = load i64, i64* %59
; # (method (car (set $Ret Lst)) Key)
  %61 = call i64 @method(i64 %60, i64 %1)
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$28, label %$27
$28:
  %63 = phi i64 [%58, %$24] ; # Lst
  br label %$25
$27:
  %64 = phi i64 [%58, %$24] ; # Lst
  br label %$23
$25:
  %65 = phi i64 [%57, %$26], [%63, %$28] ; # Lst
  %66 = phi i64 [0, %$26], [%61, %$28] ; # ->
  br label %$7
$21:
  %67 = phi i64 [%48, %$19] ; # Lst
; # (shift Lst)
  %68 = inttoptr i64 %67 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
  br label %$5
$7:
  %71 = phi i64 [%17, %$8], [%37, %$13], [%47, %$20], [%65, %$25] ; # Lst
  %72 = phi i64 [-1, %$8], [%38, %$13], [%45, %$20], [%66, %$25] ; # ->
  ret i64 %72
}

define i64 @_extra(i64) align 8 {
$1:
; # (let Key (val $Key) (when (le0 (extra (val $This) Key)) (err Exe ...
; # (val $Key)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  %2 = load i64, i64* %1
; # (when (le0 (extra (val $This) Key)) (err Exe Key ($ "Bad extra") ...
; # (val $This)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %4 = load i64, i64* %3
; # (extra (val $This) Key)
  %5 = call i64 @extra(i64 %4, i64 %2)
; # (le0 (extra (val $This) Key))
  %6 = icmp sle i64 %5, 0
  br i1 %6, label %$2, label %$3
$2:
; # (err Exe Key ($ "Bad extra") null)
  call void @err(i64 %0, i64 %2, i8* bitcast ([10 x i8]* @$72 to i8*), i8* null)
  unreachable
$3:
; # (let (TypS (val $Typ) KeyS (val $Key)) (set $Typ (val $Ret) $Key ...
; # (val $Typ)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  %8 = load i64, i64* %7
; # (val $Key)
  %9 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  %10 = load i64, i64* %9
; # (set $Typ (val $Ret) $Key Key)
; # (val $Ret)
  %11 = load i64, i64* @$Ret
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %11, i64* %12
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %2, i64* %13
; # (prog1 (evExpr @ Exe) (set $Key KeyS $Typ TypS))
; # (evExpr @ Exe)
  %14 = call i64 @evExpr(i64 %5, i64 %0)
; # (set $Key KeyS $Typ TypS)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 104) to i64) to i64*
  store i64 %10, i64* %15
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 96) to i64) to i64*
  store i64 %8, i64* %16
  ret i64 %14
}

define i64 @_and(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (nil? Y) Y) (set ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (nil? Y) Y) (set $At Y) (? (atom (...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%25, %$11] ; # X
; # (let Y (eval (car X)) (? (nil? Y) Y) (set $At Y) (? (atom (shift ...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (nil? Y) Y)
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$10, label %$8
$10:
  %16 = phi i64 [%4, %$3] ; # X
  br label %$9
$8:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %14, i64* %18
; # (? (atom (shift X)) Y)
; # (shift X)
  %19 = inttoptr i64 %17 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
; # (atom (shift X))
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$11
$12:
  %24 = phi i64 [%21, %$8] ; # X
  br label %$9
$11:
  %25 = phi i64 [%21, %$8] ; # X
  br label %$2
$9:
  %26 = phi i64 [%16, %$10], [%24, %$12] ; # X
  %27 = phi i64 [%14, %$10], [%14, %$12] ; # ->
  ret i64 %27
}

define i64 @_or(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (not (nil? Y)) (s...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y)) (? (at...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%26, %$11] ; # X
; # (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y)) (? (atom (sh...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (not (nil? Y)) (set $At Y))
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %16 = icmp eq i1 %15, 0
  br i1 %16, label %$10, label %$8
$10:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %14, i64* %18
  br label %$9
$8:
  %19 = phi i64 [%4, %$3] ; # X
; # (? (atom (shift X)) Y)
; # (shift X)
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (atom (shift X))
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%22, %$8] ; # X
  br label %$9
$11:
  %26 = phi i64 [%22, %$8] ; # X
  br label %$2
$9:
  %27 = phi i64 [%17, %$10], [%25, %$12] ; # X
  %28 = phi i64 [%14, %$10], [%14, %$12] ; # ->
  ret i64 %28
}

define i64 @_nand(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (nil? Y) $T) (set...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (nil? Y) $T) (set $At Y) (? (atom ...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%25, %$11] ; # X
; # (let Y (eval (car X)) (? (nil? Y) $T) (set $At Y) (? (atom (shift...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (nil? Y) $T)
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$10, label %$8
$10:
  %16 = phi i64 [%4, %$3] ; # X
  br label %$9
$8:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %14, i64* %18
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %19 = inttoptr i64 %17 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
; # (atom (shift X))
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$11
$12:
  %24 = phi i64 [%21, %$8] ; # X
  br label %$9
$11:
  %25 = phi i64 [%21, %$8] ; # X
  br label %$2
$9:
  %26 = phi i64 [%16, %$10], [%24, %$12] ; # X
  %27 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %27
}

define i64 @_nor(i64) align 8 {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (not (nil? Y)) (s...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y) $Nil) (...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%26, %$11] ; # X
; # (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y) $Nil) (? (ato...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (not (nil? Y)) (set $At Y) $Nil)
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %16 = icmp eq i1 %15, 0
  br i1 %16, label %$10, label %$8
$10:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %14, i64* %18
  br label %$9
$8:
  %19 = phi i64 [%4, %$3] ; # X
; # (? (atom (shift X)) $T)
; # (shift X)
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (atom (shift X))
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%22, %$8] ; # X
  br label %$9
$11:
  %26 = phi i64 [%22, %$8] ; # X
  br label %$2
$9:
  %27 = phi i64 [%17, %$10], [%25, %$12] ; # X
  %28 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$12] ; # ->
  ret i64 %28
}

define i64 @_xor(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (if (nil? (eval (car X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (if (nil? (eval (car X))) @ $T) (if (nil...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (if (nil? (eval (car X))) @ $T)
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (eval (car X))
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$12, label %$11
$12:
  br label %$10
$11:
  %22 = and i64 %19, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = inttoptr i64 %19 to i64*
  %25 = load i64, i64* %24
  br label %$10
$13:
  %26 = call i64 @evList(i64 %19)
  br label %$10
$10:
  %27 = phi i64 [%19, %$12], [%25, %$14], [%26, %$13] ; # ->
; # (nil? (eval (car X)))
  %28 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %28, label %$15, label %$16
$15:
  %29 = phi i64 [%17, %$10] ; # X
  br label %$17
$16:
  %30 = phi i64 [%17, %$10] ; # X
  br label %$17
$17:
  %31 = phi i64 [%29, %$15], [%30, %$16] ; # X
  %32 = phi i64 [%27, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$16] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%7, %$2] ; # X
; # (if (nil? (eval (car X))) $T $Nil)
; # (car X)
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (eval (car X))
  %36 = and i64 %35, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$20, label %$19
$20:
  br label %$18
$19:
  %38 = and i64 %35, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$22, label %$21
$22:
  %40 = inttoptr i64 %35 to i64*
  %41 = load i64, i64* %40
  br label %$18
$21:
  %42 = call i64 @evList(i64 %35)
  br label %$18
$18:
  %43 = phi i64 [%35, %$20], [%41, %$22], [%42, %$21] ; # ->
; # (nil? (eval (car X)))
  %44 = icmp eq i64 %43, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %44, label %$23, label %$24
$23:
  %45 = phi i64 [%33, %$18] ; # X
  br label %$25
$24:
  %46 = phi i64 [%33, %$18] ; # X
  br label %$25
$25:
  %47 = phi i64 [%45, %$23], [%46, %$24] ; # X
  %48 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$24] ; # ->
  br label %$9
$9:
  %49 = phi i64 [%31, %$17], [%47, %$25] ; # X
  %50 = phi i64 [%32, %$17], [%48, %$25] ; # ->
  ret i64 %50
}

define i64 @_bool(i64) align 8 {
$1:
; # (if (nil? (eval (cadr Exe))) @ $T)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_not(i64) align 8 {
$1:
; # (if (nil? (eval (cadr Exe))) $T (set $At @) $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (set $At @)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %13, i64* %15
  br label %$9
$9:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_nil(i64) align 8 {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (exec (cdr Exe))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%16, %$5] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %6, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  %11 = phi i64 [%8, %$2] ; # Prg
  %12 = call i64 @evList(i64 %6)
  br label %$4
$4:
  %13 = phi i64 [%8, %$2], [%11, %$3] ; # Prg
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$6, label %$5
$5:
  %16 = phi i64 [%13, %$4] ; # Prg
  br label %$2
$6:
  %17 = phi i64 [%13, %$4] ; # Prg
  %18 = phi i64 [0, %$4] ; # ->
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_t(i64) align 8 {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (exec (cdr Exe))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%16, %$5] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %6, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  %11 = phi i64 [%8, %$2] ; # Prg
  %12 = call i64 @evList(i64 %6)
  br label %$4
$4:
  %13 = phi i64 [%8, %$2], [%11, %$3] ; # Prg
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$6, label %$5
$5:
  %16 = phi i64 [%13, %$4] ; # Prg
  br label %$2
$6:
  %17 = phi i64 [%13, %$4] ; # Prg
  %18 = phi i64 [0, %$4] ; # ->
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
}

define i64 @_prog(i64) align 8 {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (run (cdr Exe))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%26, %$11] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$3
$5:
  %11 = phi i64 [%8, %$2] ; # Prg
  %12 = and i64 %6, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$8, label %$7
$8:
  br label %$6
$7:
  %14 = and i64 %6, 8
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$10, label %$9
$10:
  %16 = inttoptr i64 %6 to i64*
  %17 = load i64, i64* %16
  br label %$6
$9:
  %18 = call i64 @evList(i64 %6)
  br label %$6
$6:
  %19 = phi i64 [%6, %$8], [%17, %$10], [%18, %$9] ; # ->
  br label %$4
$3:
  %20 = phi i64 [%8, %$2] ; # Prg
  %21 = and i64 %6, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$12, label %$11
$12:
  %23 = phi i64 [%20, %$3] ; # Prg
  %24 = call i64 @evList(i64 %6)
  %25 = icmp ne i64 %24, 0
  br label %$11
$11:
  %26 = phi i64 [%20, %$3], [%23, %$12] ; # Prg
  %27 = phi i1 [0, %$3], [%25, %$12] ; # ->
  br label %$2
$4:
  %28 = phi i64 [%11, %$6] ; # Prg
  %29 = phi i64 [%19, %$6] ; # ->
  ret i64 %29
}

define i64 @_prog1(i64) align 8 {
$1:
; # (let X (cdr Exe) (prog1 (set $At (save (eval (++ X)))) (exec X)))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog1 (set $At (save (eval (++ X)))) (exec X))
; # (set $At (save (eval (++ X))))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %24
; # (exec X)
  br label %$7
$7:
  %25 = phi i64 [%7, %$2], [%37, %$10] ; # Prg
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
  %30 = and i64 %27, 15
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$8, label %$9
$8:
  %32 = phi i64 [%29, %$7] ; # Prg
  %33 = call i64 @evList(i64 %27)
  br label %$9
$9:
  %34 = phi i64 [%29, %$7], [%32, %$8] ; # Prg
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$11, label %$10
$10:
  %37 = phi i64 [%34, %$9] ; # Prg
  br label %$7
$11:
  %38 = phi i64 [%34, %$9] ; # Prg
  %39 = phi i64 [0, %$9] ; # ->
; # (drop *Safe)
  %40 = inttoptr i64 %19 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %43
  ret i64 %15
}

define i64 @_prog2(i64) align 8 {
$1:
; # (let X (cdr Exe) (prog2 (eval (++ X)) (set $At (save (eval (++ X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog2 (eval (++ X)) (set $At (save (eval (++ X)))) (exec X))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (set $At (save (eval (++ X))))
; # (++ X)
  %16 = inttoptr i64 %7 to i64*
  %17 = load i64, i64* %16
  %18 = getelementptr i64, i64* %16, i32 1
  %19 = load i64, i64* %18
; # (eval (++ X))
  %20 = and i64 %17, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$8
$9:
  br label %$7
$8:
  %22 = and i64 %17, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$11:
  %24 = inttoptr i64 %17 to i64*
  %25 = load i64, i64* %24
  br label %$7
$10:
  %26 = call i64 @evList(i64 %17)
  br label %$7
$7:
  %27 = phi i64 [%17, %$9], [%25, %$11], [%26, %$10] ; # ->
; # (save (eval (++ X)))
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %27, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %29, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %27, i64* %36
; # (exec X)
  br label %$12
$12:
  %37 = phi i64 [%19, %$7], [%49, %$15] ; # Prg
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
  %40 = getelementptr i64, i64* %38, i32 1
  %41 = load i64, i64* %40
  %42 = and i64 %39, 15
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %$13, label %$14
$13:
  %44 = phi i64 [%41, %$12] ; # Prg
  %45 = call i64 @evList(i64 %39)
  br label %$14
$14:
  %46 = phi i64 [%41, %$12], [%44, %$13] ; # Prg
  %47 = and i64 %46, 15
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$16, label %$15
$15:
  %49 = phi i64 [%46, %$14] ; # Prg
  br label %$12
$16:
  %50 = phi i64 [%46, %$14] ; # Prg
  %51 = phi i64 [0, %$14] ; # ->
; # (drop *Safe)
  %52 = inttoptr i64 %31 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %55
  ret i64 %27
}

define i64 @_if(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (run (cdr X)) (set $At ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (run (cdr X)) (set $At @) (eval (car X))...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (cdr X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (run (cdr X))
  br label %$10
$10:
  %21 = phi i64 [%20, %$7], [%43, %$19] ; # Prg
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  %24 = getelementptr i64, i64* %22, i32 1
  %25 = load i64, i64* %24
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$13, label %$11
$13:
  %28 = phi i64 [%25, %$10] ; # Prg
  %29 = and i64 %23, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$16, label %$15
$16:
  br label %$14
$15:
  %31 = and i64 %23, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$18, label %$17
$18:
  %33 = inttoptr i64 %23 to i64*
  %34 = load i64, i64* %33
  br label %$14
$17:
  %35 = call i64 @evList(i64 %23)
  br label %$14
$14:
  %36 = phi i64 [%23, %$16], [%34, %$18], [%35, %$17] ; # ->
  br label %$12
$11:
  %37 = phi i64 [%25, %$10] ; # Prg
  %38 = and i64 %23, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$20, label %$19
$20:
  %40 = phi i64 [%37, %$11] ; # Prg
  %41 = call i64 @evList(i64 %23)
  %42 = icmp ne i64 %41, 0
  br label %$19
$19:
  %43 = phi i64 [%37, %$11], [%40, %$20] ; # Prg
  %44 = phi i1 [0, %$11], [%42, %$20] ; # ->
  br label %$10
$12:
  %45 = phi i64 [%28, %$14] ; # Prg
  %46 = phi i64 [%36, %$14] ; # ->
  br label %$9
$8:
  %47 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %48
; # (car X)
  %49 = inttoptr i64 %47 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$23, label %$22
$23:
  br label %$21
$22:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$25, label %$24
$25:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$21
$24:
  %57 = call i64 @evList(i64 %50)
  br label %$21
$21:
  %58 = phi i64 [%50, %$23], [%56, %$25], [%57, %$24] ; # ->
  br label %$9
$9:
  %59 = phi i64 [%17, %$12], [%47, %$21] ; # X
  %60 = phi i64 [%46, %$12], [%58, %$21] ; # ->
  ret i64 %60
}

define i64 @_ifn(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (eval (car X)) (set $At...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (eval (car X)) (set $At @) (run (cdr X))...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (eval (car X))
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$12, label %$11
$12:
  br label %$10
$11:
  %22 = and i64 %19, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = inttoptr i64 %19 to i64*
  %25 = load i64, i64* %24
  br label %$10
$13:
  %26 = call i64 @evList(i64 %19)
  br label %$10
$10:
  %27 = phi i64 [%19, %$12], [%25, %$14], [%26, %$13] ; # ->
  br label %$9
$8:
  %28 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %29
; # (cdr X)
  %30 = inttoptr i64 %28 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (run (cdr X))
  br label %$15
$15:
  %33 = phi i64 [%32, %$8], [%55, %$24] ; # Prg
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
  %36 = getelementptr i64, i64* %34, i32 1
  %37 = load i64, i64* %36
  %38 = and i64 %37, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$18, label %$16
$18:
  %40 = phi i64 [%37, %$15] ; # Prg
  %41 = and i64 %35, 6
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$21, label %$20
$21:
  br label %$19
$20:
  %43 = and i64 %35, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$23, label %$22
$23:
  %45 = inttoptr i64 %35 to i64*
  %46 = load i64, i64* %45
  br label %$19
$22:
  %47 = call i64 @evList(i64 %35)
  br label %$19
$19:
  %48 = phi i64 [%35, %$21], [%46, %$23], [%47, %$22] ; # ->
  br label %$17
$16:
  %49 = phi i64 [%37, %$15] ; # Prg
  %50 = and i64 %35, 15
  %51 = icmp eq i64 %50, 0
  br i1 %51, label %$25, label %$24
$25:
  %52 = phi i64 [%49, %$16] ; # Prg
  %53 = call i64 @evList(i64 %35)
  %54 = icmp ne i64 %53, 0
  br label %$24
$24:
  %55 = phi i64 [%49, %$16], [%52, %$25] ; # Prg
  %56 = phi i1 [0, %$16], [%54, %$25] ; # ->
  br label %$15
$17:
  %57 = phi i64 [%40, %$19] ; # Prg
  %58 = phi i64 [%48, %$19] ; # ->
  br label %$9
$9:
  %59 = phi i64 [%17, %$10], [%28, %$17] ; # X
  %60 = phi i64 [%27, %$10], [%58, %$17] ; # ->
  ret i64 %60
}

define i64 @_if2(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (if (nil? (eval (++ X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (if (nil? (eval (++ X))) (run (cdr (cddr...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (if (nil? (eval (++ X))) (run (cdr (cddr X))) (set $At @) (eval (...
; # (++ X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
; # (eval (++ X))
  %22 = and i64 %19, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$11
$12:
  br label %$10
$11:
  %24 = and i64 %19, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$14, label %$13
$14:
  %26 = inttoptr i64 %19 to i64*
  %27 = load i64, i64* %26
  br label %$10
$13:
  %28 = call i64 @evList(i64 %19)
  br label %$10
$10:
  %29 = phi i64 [%19, %$12], [%27, %$14], [%28, %$13] ; # ->
; # (nil? (eval (++ X)))
  %30 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %30, label %$15, label %$16
$15:
  %31 = phi i64 [%21, %$10] ; # X
; # (cddr X)
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %34 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
; # (cdr (cddr X))
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (run (cdr (cddr X)))
  br label %$18
$18:
  %41 = phi i64 [%40, %$15], [%63, %$27] ; # Prg
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
  %46 = and i64 %45, 15
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$21, label %$19
$21:
  %48 = phi i64 [%45, %$18] ; # Prg
  %49 = and i64 %43, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$24, label %$23
$24:
  br label %$22
$23:
  %51 = and i64 %43, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$26, label %$25
$26:
  %53 = inttoptr i64 %43 to i64*
  %54 = load i64, i64* %53
  br label %$22
$25:
  %55 = call i64 @evList(i64 %43)
  br label %$22
$22:
  %56 = phi i64 [%43, %$24], [%54, %$26], [%55, %$25] ; # ->
  br label %$20
$19:
  %57 = phi i64 [%45, %$18] ; # Prg
  %58 = and i64 %43, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$28, label %$27
$28:
  %60 = phi i64 [%57, %$19] ; # Prg
  %61 = call i64 @evList(i64 %43)
  %62 = icmp ne i64 %61, 0
  br label %$27
$27:
  %63 = phi i64 [%57, %$19], [%60, %$28] ; # Prg
  %64 = phi i1 [0, %$19], [%62, %$28] ; # ->
  br label %$18
$20:
  %65 = phi i64 [%48, %$22] ; # Prg
  %66 = phi i64 [%56, %$22] ; # ->
  br label %$17
$16:
  %67 = phi i64 [%21, %$10] ; # X
; # (set $At @)
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %29, i64* %68
; # (cddr X)
  %69 = inttoptr i64 %67 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 %71 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (car (cddr X))
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
; # (eval (car (cddr X)))
  %77 = and i64 %76, 6
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %$31, label %$30
$31:
  br label %$29
$30:
  %79 = and i64 %76, 8
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$33, label %$32
$33:
  %81 = inttoptr i64 %76 to i64*
  %82 = load i64, i64* %81
  br label %$29
$32:
  %83 = call i64 @evList(i64 %76)
  br label %$29
$29:
  %84 = phi i64 [%76, %$31], [%82, %$33], [%83, %$32] ; # ->
  br label %$17
$17:
  %85 = phi i64 [%31, %$20], [%67, %$29] ; # X
  %86 = phi i64 [%66, %$20], [%84, %$29] ; # ->
  br label %$9
$8:
  %87 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %88 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %88
; # (if (nil? (eval (++ X))) (eval (cadr X)) (set $At @) (eval (car X...
; # (++ X)
  %89 = inttoptr i64 %87 to i64*
  %90 = load i64, i64* %89
  %91 = getelementptr i64, i64* %89, i32 1
  %92 = load i64, i64* %91
; # (eval (++ X))
  %93 = and i64 %90, 6
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$36, label %$35
$36:
  br label %$34
$35:
  %95 = and i64 %90, 8
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$38, label %$37
$38:
  %97 = inttoptr i64 %90 to i64*
  %98 = load i64, i64* %97
  br label %$34
$37:
  %99 = call i64 @evList(i64 %90)
  br label %$34
$34:
  %100 = phi i64 [%90, %$36], [%98, %$38], [%99, %$37] ; # ->
; # (nil? (eval (++ X)))
  %101 = icmp eq i64 %100, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %101, label %$39, label %$40
$39:
  %102 = phi i64 [%92, %$34] ; # X
; # (cadr X)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
  %106 = inttoptr i64 %105 to i64*
  %107 = load i64, i64* %106
; # (eval (cadr X))
  %108 = and i64 %107, 6
  %109 = icmp ne i64 %108, 0
  br i1 %109, label %$44, label %$43
$44:
  br label %$42
$43:
  %110 = and i64 %107, 8
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$46, label %$45
$46:
  %112 = inttoptr i64 %107 to i64*
  %113 = load i64, i64* %112
  br label %$42
$45:
  %114 = call i64 @evList(i64 %107)
  br label %$42
$42:
  %115 = phi i64 [%107, %$44], [%113, %$46], [%114, %$45] ; # ->
  br label %$41
$40:
  %116 = phi i64 [%92, %$34] ; # X
; # (set $At @)
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %100, i64* %117
; # (car X)
  %118 = inttoptr i64 %116 to i64*
  %119 = load i64, i64* %118
; # (eval (car X))
  %120 = and i64 %119, 6
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$49, label %$48
$49:
  br label %$47
$48:
  %122 = and i64 %119, 8
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$51, label %$50
$51:
  %124 = inttoptr i64 %119 to i64*
  %125 = load i64, i64* %124
  br label %$47
$50:
  %126 = call i64 @evList(i64 %119)
  br label %$47
$47:
  %127 = phi i64 [%119, %$49], [%125, %$51], [%126, %$50] ; # ->
  br label %$41
$41:
  %128 = phi i64 [%102, %$42], [%116, %$47] ; # X
  %129 = phi i64 [%115, %$42], [%127, %$47] ; # ->
  br label %$9
$9:
  %130 = phi i64 [%85, %$17], [%128, %$41] ; # X
  %131 = phi i64 [%86, %$17], [%129, %$41] ; # ->
  ret i64 %131
}

define i64 @_when(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) @ (set $At @) (run X)))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) @ (set $At @) (run X))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
  br label %$9
$8:
  %18 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %19
; # (run X)
  br label %$10
$10:
  %20 = phi i64 [%18, %$8], [%42, %$19] ; # Prg
  %21 = inttoptr i64 %20 to i64*
  %22 = load i64, i64* %21
  %23 = getelementptr i64, i64* %21, i32 1
  %24 = load i64, i64* %23
  %25 = and i64 %24, 15
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$11
$13:
  %27 = phi i64 [%24, %$10] ; # Prg
  %28 = and i64 %22, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$16, label %$15
$16:
  br label %$14
$15:
  %30 = and i64 %22, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$18, label %$17
$18:
  %32 = inttoptr i64 %22 to i64*
  %33 = load i64, i64* %32
  br label %$14
$17:
  %34 = call i64 @evList(i64 %22)
  br label %$14
$14:
  %35 = phi i64 [%22, %$16], [%33, %$18], [%34, %$17] ; # ->
  br label %$12
$11:
  %36 = phi i64 [%24, %$10] ; # Prg
  %37 = and i64 %22, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$20, label %$19
$20:
  %39 = phi i64 [%36, %$11] ; # Prg
  %40 = call i64 @evList(i64 %22)
  %41 = icmp ne i64 %40, 0
  br label %$19
$19:
  %42 = phi i64 [%36, %$11], [%39, %$20] ; # Prg
  %43 = phi i1 [0, %$11], [%41, %$20] ; # ->
  br label %$10
$12:
  %44 = phi i64 [%27, %$14] ; # Prg
  %45 = phi i64 [%35, %$14] ; # ->
  br label %$9
$9:
  %46 = phi i64 [%17, %$7], [%18, %$12] ; # X
  %47 = phi i64 [%15, %$7], [%45, %$12] ; # ->
  ret i64 %47
}

define i64 @_unless(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (run X) (set $At @) $Ni...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (run X) (set $At @) $Nil)
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (run X)
  br label %$10
$10:
  %18 = phi i64 [%17, %$7], [%40, %$19] ; # Prg
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = getelementptr i64, i64* %19, i32 1
  %22 = load i64, i64* %21
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$13, label %$11
$13:
  %25 = phi i64 [%22, %$10] ; # Prg
  %26 = and i64 %20, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$16, label %$15
$16:
  br label %$14
$15:
  %28 = and i64 %20, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$18, label %$17
$18:
  %30 = inttoptr i64 %20 to i64*
  %31 = load i64, i64* %30
  br label %$14
$17:
  %32 = call i64 @evList(i64 %20)
  br label %$14
$14:
  %33 = phi i64 [%20, %$16], [%31, %$18], [%32, %$17] ; # ->
  br label %$12
$11:
  %34 = phi i64 [%22, %$10] ; # Prg
  %35 = and i64 %20, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$20, label %$19
$20:
  %37 = phi i64 [%34, %$11] ; # Prg
  %38 = call i64 @evList(i64 %20)
  %39 = icmp ne i64 %38, 0
  br label %$19
$19:
  %40 = phi i64 [%34, %$11], [%37, %$20] ; # Prg
  %41 = phi i1 [0, %$11], [%39, %$20] ; # ->
  br label %$10
$12:
  %42 = phi i64 [%25, %$14] ; # Prg
  %43 = phi i64 [%33, %$14] ; # ->
  br label %$9
$8:
  %44 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %45
  br label %$9
$9:
  %46 = phi i64 [%17, %$12], [%44, %$8] ; # X
  %47 = phi i64 [%43, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %47
}

define i64 @_cond(i64) align 8 {
$1:
; # (let X Exe (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (not...
; # (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (not (nil? (eva...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%54, %$11] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %2 = inttoptr i64 %1 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (atom (shift X))
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%4, %$2] ; # X
  br label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
; # (let Y (car X) (? (not (nil? (eval (car Y)))) (set $At @) (run (c...
; # (car X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (? (not (nil? (eval (car Y)))) (set $At @) (run (cdr Y)))
; # (car Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car Y))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  br label %$6
$7:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$9
$10:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$6
$9:
  %19 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %20 = phi i64 [%12, %$8], [%18, %$10], [%19, %$9] ; # ->
; # (nil? (eval (car Y)))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (car Y))))
  %22 = icmp eq i1 %21, 0
  br i1 %22, label %$12, label %$11
$12:
  %23 = phi i64 [%8, %$6] ; # X
; # (set $At @)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %20, i64* %24
; # (cdr Y)
  %25 = inttoptr i64 %10 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (run (cdr Y))
  br label %$13
$13:
  %28 = phi i64 [%27, %$12], [%50, %$22] ; # Prg
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  %31 = getelementptr i64, i64* %29, i32 1
  %32 = load i64, i64* %31
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$16, label %$14
$16:
  %35 = phi i64 [%32, %$13] ; # Prg
  %36 = and i64 %30, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$19, label %$18
$19:
  br label %$17
$18:
  %38 = and i64 %30, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$21, label %$20
$21:
  %40 = inttoptr i64 %30 to i64*
  %41 = load i64, i64* %40
  br label %$17
$20:
  %42 = call i64 @evList(i64 %30)
  br label %$17
$17:
  %43 = phi i64 [%30, %$19], [%41, %$21], [%42, %$20] ; # ->
  br label %$15
$14:
  %44 = phi i64 [%32, %$13] ; # Prg
  %45 = and i64 %30, 15
  %46 = icmp eq i64 %45, 0
  br i1 %46, label %$23, label %$22
$23:
  %47 = phi i64 [%44, %$14] ; # Prg
  %48 = call i64 @evList(i64 %30)
  %49 = icmp ne i64 %48, 0
  br label %$22
$22:
  %50 = phi i64 [%44, %$14], [%47, %$23] ; # Prg
  %51 = phi i1 [0, %$14], [%49, %$23] ; # ->
  br label %$13
$15:
  %52 = phi i64 [%35, %$17] ; # Prg
  %53 = phi i64 [%43, %$17] ; # ->
  br label %$4
$11:
  %54 = phi i64 [%8, %$6] ; # X
  br label %$2
$4:
  %55 = phi i64 [%7, %$5], [%23, %$15] ; # X
  %56 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%53, %$15] ; # ->
  ret i64 %56
}

define i64 @_nond(i64) align 8 {
$1:
; # (let X Exe (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (nil...
; # (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (nil? (eval (ca...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%52, %$11] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %2 = inttoptr i64 %1 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (atom (shift X))
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%4, %$2] ; # X
  br label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
; # (let Y (car X) (? (nil? (eval (car Y))) (run (cdr Y))))
; # (car X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (? (nil? (eval (car Y))) (run (cdr Y)))
; # (car Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car Y))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  br label %$6
$7:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$9
$10:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$6
$9:
  %19 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %20 = phi i64 [%12, %$8], [%18, %$10], [%19, %$9] ; # ->
; # (nil? (eval (car Y)))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$12, label %$11
$12:
  %22 = phi i64 [%8, %$6] ; # X
; # (cdr Y)
  %23 = inttoptr i64 %10 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (run (cdr Y))
  br label %$13
$13:
  %26 = phi i64 [%25, %$12], [%48, %$22] ; # Prg
  %27 = inttoptr i64 %26 to i64*
  %28 = load i64, i64* %27
  %29 = getelementptr i64, i64* %27, i32 1
  %30 = load i64, i64* %29
  %31 = and i64 %30, 15
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$14
$16:
  %33 = phi i64 [%30, %$13] ; # Prg
  %34 = and i64 %28, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$19, label %$18
$19:
  br label %$17
$18:
  %36 = and i64 %28, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$21, label %$20
$21:
  %38 = inttoptr i64 %28 to i64*
  %39 = load i64, i64* %38
  br label %$17
$20:
  %40 = call i64 @evList(i64 %28)
  br label %$17
$17:
  %41 = phi i64 [%28, %$19], [%39, %$21], [%40, %$20] ; # ->
  br label %$15
$14:
  %42 = phi i64 [%30, %$13] ; # Prg
  %43 = and i64 %28, 15
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$23, label %$22
$23:
  %45 = phi i64 [%42, %$14] ; # Prg
  %46 = call i64 @evList(i64 %28)
  %47 = icmp ne i64 %46, 0
  br label %$22
$22:
  %48 = phi i64 [%42, %$14], [%45, %$23] ; # Prg
  %49 = phi i1 [0, %$14], [%47, %$23] ; # ->
  br label %$13
$15:
  %50 = phi i64 [%33, %$17] ; # Prg
  %51 = phi i64 [%41, %$17] ; # ->
  br label %$4
$11:
  %52 = phi i64 [%8, %$6] ; # X
; # (set $At @)
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %20, i64* %53
  br label %$2
$4:
  %54 = phi i64 [%7, %$5], [%22, %$15] ; # X
  %55 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%51, %$15] ; # ->
  ret i64 %55
}

define i64 @_case(i64) align 8 {
$1:
; # (let (X (cdr Exe) A (set $At (eval (car X)))) (loop (? (atom (shi...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set $At (eval (car X)))
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %13, i64* %14
; # (loop (? (atom (shift X)) $Nil) (let (Y (car X) Z (car Y)) (? (or...
  br label %$7
$7:
  %15 = phi i64 [%3, %$2], [%83, %$22] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %16 = inttoptr i64 %15 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (atom (shift X))
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$8
$10:
  %21 = phi i64 [%18, %$7] ; # X
  br label %$9
$8:
  %22 = phi i64 [%18, %$7] ; # X
; # (let (Y (car X) Z (car Y)) (? (or (t? Z) (if (atom Z) (equal Z A)...
; # (car X)
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (car Y)
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (? (or (t? Z) (if (atom Z) (equal Z A) (member A Z))) (run (cdr Y...
; # (or (t? Z) (if (atom Z) (equal Z A) (member A Z)))
; # (t? Z)
  %27 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %27, label %$11, label %$12
$12:
  %28 = phi i64 [%22, %$8] ; # X
; # (if (atom Z) (equal Z A) (member A Z))
; # (atom Z)
  %29 = and i64 %26, 15
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$13, label %$14
$13:
  %31 = phi i64 [%28, %$12] ; # X
; # (equal Z A)
  %32 = call i1 @equal(i64 %26, i64 %13)
  br label %$15
$14:
  %33 = phi i64 [%28, %$12] ; # X
; # (member A Z)
  br label %$16
$16:
  %34 = phi i64 [%26, %$14], [%46, %$20] ; # L
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$19, label %$17
$19:
  %37 = phi i64 [%34, %$16] ; # L
  br label %$18
$17:
  %38 = phi i64 [%34, %$16] ; # L
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  %41 = call i1 @equal(i64 %13, i64 %40)
  br i1 %41, label %$21, label %$20
$21:
  %42 = phi i64 [%38, %$17] ; # L
  br label %$18
$20:
  %43 = phi i64 [%38, %$17] ; # L
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
  br label %$16
$18:
  %47 = phi i64 [%37, %$19], [%42, %$21] ; # L
  %48 = phi i1 [0, %$19], [1, %$21] ; # ->
  br label %$15
$15:
  %49 = phi i64 [%31, %$13], [%33, %$18] ; # X
  %50 = phi i1 [%32, %$13], [%48, %$18] ; # ->
  br label %$11
$11:
  %51 = phi i64 [%22, %$8], [%49, %$15] ; # X
  %52 = phi i1 [1, %$8], [%50, %$15] ; # ->
  br i1 %52, label %$23, label %$22
$23:
  %53 = phi i64 [%51, %$11] ; # X
; # (cdr Y)
  %54 = inttoptr i64 %24 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
; # (run (cdr Y))
  br label %$24
$24:
  %57 = phi i64 [%56, %$23], [%79, %$33] ; # Prg
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
  %60 = getelementptr i64, i64* %58, i32 1
  %61 = load i64, i64* %60
  %62 = and i64 %61, 15
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$27, label %$25
$27:
  %64 = phi i64 [%61, %$24] ; # Prg
  %65 = and i64 %59, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$30, label %$29
$30:
  br label %$28
$29:
  %67 = and i64 %59, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$32, label %$31
$32:
  %69 = inttoptr i64 %59 to i64*
  %70 = load i64, i64* %69
  br label %$28
$31:
  %71 = call i64 @evList(i64 %59)
  br label %$28
$28:
  %72 = phi i64 [%59, %$30], [%70, %$32], [%71, %$31] ; # ->
  br label %$26
$25:
  %73 = phi i64 [%61, %$24] ; # Prg
  %74 = and i64 %59, 15
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$34, label %$33
$34:
  %76 = phi i64 [%73, %$25] ; # Prg
  %77 = call i64 @evList(i64 %59)
  %78 = icmp ne i64 %77, 0
  br label %$33
$33:
  %79 = phi i64 [%73, %$25], [%76, %$34] ; # Prg
  %80 = phi i1 [0, %$25], [%78, %$34] ; # ->
  br label %$24
$26:
  %81 = phi i64 [%64, %$28] ; # Prg
  %82 = phi i64 [%72, %$28] ; # ->
  br label %$9
$22:
  %83 = phi i64 [%51, %$11] ; # X
  br label %$7
$9:
  %84 = phi i64 [%21, %$10], [%53, %$26] ; # X
  %85 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [%82, %$26] ; # ->
  ret i64 %85
}

define i64 @_casq(i64) align 8 {
$1:
; # (let (X (cdr Exe) A (set $At (eval (car X)))) (loop (? (atom (shi...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set $At (eval (car X)))
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %13, i64* %14
; # (loop (? (atom (shift X)) $Nil) (let (Y (car X) Z (car Y)) (? (or...
  br label %$7
$7:
  %15 = phi i64 [%3, %$2], [%78, %$20] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %16 = inttoptr i64 %15 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (atom (shift X))
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$8
$10:
  %21 = phi i64 [%18, %$7] ; # X
  br label %$9
$8:
  %22 = phi i64 [%18, %$7] ; # X
; # (let (Y (car X) Z (car Y)) (? (or (t? Z) (== Z A) (memq A Z)) (ru...
; # (car X)
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (car Y)
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (? (or (t? Z) (== Z A) (memq A Z)) (run (cdr Y)))
; # (or (t? Z) (== Z A) (memq A Z))
; # (t? Z)
  %27 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %27, label %$11, label %$12
$12:
  %28 = phi i64 [%22, %$8] ; # X
; # (== Z A)
  %29 = icmp eq i64 %26, %13
  br i1 %29, label %$11, label %$13
$13:
  %30 = phi i64 [%28, %$12] ; # X
; # (memq A Z)
  br label %$14
$14:
  %31 = phi i64 [%26, %$13], [%43, %$18] ; # L
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$15
$17:
  %34 = phi i64 [%31, %$14] ; # L
  br label %$16
$15:
  %35 = phi i64 [%31, %$14] ; # L
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
  %38 = icmp eq i64 %13, %37
  br i1 %38, label %$19, label %$18
$19:
  %39 = phi i64 [%35, %$15] ; # L
  br label %$16
$18:
  %40 = phi i64 [%35, %$15] ; # L
  %41 = inttoptr i64 %40 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
  br label %$14
$16:
  %44 = phi i64 [%34, %$17], [%39, %$19] ; # L
  %45 = phi i1 [0, %$17], [1, %$19] ; # ->
  br label %$11
$11:
  %46 = phi i64 [%22, %$8], [%28, %$12], [%30, %$16] ; # X
  %47 = phi i1 [1, %$8], [1, %$12], [%45, %$16] ; # ->
  br i1 %47, label %$21, label %$20
$21:
  %48 = phi i64 [%46, %$11] ; # X
; # (cdr Y)
  %49 = inttoptr i64 %24 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (run (cdr Y))
  br label %$22
$22:
  %52 = phi i64 [%51, %$21], [%74, %$31] ; # Prg
  %53 = inttoptr i64 %52 to i64*
  %54 = load i64, i64* %53
  %55 = getelementptr i64, i64* %53, i32 1
  %56 = load i64, i64* %55
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$25, label %$23
$25:
  %59 = phi i64 [%56, %$22] ; # Prg
  %60 = and i64 %54, 6
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$28, label %$27
$28:
  br label %$26
$27:
  %62 = and i64 %54, 8
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$30, label %$29
$30:
  %64 = inttoptr i64 %54 to i64*
  %65 = load i64, i64* %64
  br label %$26
$29:
  %66 = call i64 @evList(i64 %54)
  br label %$26
$26:
  %67 = phi i64 [%54, %$28], [%65, %$30], [%66, %$29] ; # ->
  br label %$24
$23:
  %68 = phi i64 [%56, %$22] ; # Prg
  %69 = and i64 %54, 15
  %70 = icmp eq i64 %69, 0
  br i1 %70, label %$32, label %$31
$32:
  %71 = phi i64 [%68, %$23] ; # Prg
  %72 = call i64 @evList(i64 %54)
  %73 = icmp ne i64 %72, 0
  br label %$31
$31:
  %74 = phi i64 [%68, %$23], [%71, %$32] ; # Prg
  %75 = phi i1 [0, %$23], [%73, %$32] ; # ->
  br label %$22
$24:
  %76 = phi i64 [%59, %$26] ; # Prg
  %77 = phi i64 [%67, %$26] ; # ->
  br label %$9
$20:
  %78 = phi i64 [%46, %$11] ; # X
  br label %$7
$9:
  %79 = phi i64 [%21, %$10], [%48, %$24] ; # X
  %80 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [%77, %$24] ; # ->
  ret i64 %80
}

define i64 @_state(i64) align 8 {
$1:
; # (let (X (cdr Exe) Var (save (needChkVar Exe (eval (car X))))) (lo...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needChkVar Exe (eval (car X)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$10, label %$9
$10:
  %17 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %13
  br label %$9
$9:
  %18 = phi i1 [0, %$8], [%17, %$10] ; # ->
  br i1 %18, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$12:
; # (save (needChkVar Exe (eval (car X))))
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %13, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (loop (? (atom (shift X)) $Nil) (let (Y (car X) Z (car Y)) (when ...
  br label %$13
$13:
  %27 = phi i64 [%3, %$12], [%120, %$28] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %28 = inttoptr i64 %27 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (atom (shift X))
  %31 = and i64 %30, 15
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$14
$16:
  %33 = phi i64 [%30, %$13] ; # X
  br label %$15
$14:
  %34 = phi i64 [%30, %$13] ; # X
; # (let (Y (car X) Z (car Y)) (when (or (t? Z) (let V (val Var) (or ...
; # (car X)
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (car Y)
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (when (or (t? Z) (let V (val Var) (or (== Z V) (memq V Z)))) (? (...
; # (or (t? Z) (let V (val Var) (or (== Z V) (memq V Z))))
; # (t? Z)
  %39 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %39, label %$17, label %$18
$18:
  %40 = phi i64 [%34, %$14] ; # X
  %41 = phi i64 [%36, %$14] ; # Y
; # (let V (val Var) (or (== Z V) (memq V Z)))
; # (val Var)
  %42 = inttoptr i64 %13 to i64*
  %43 = load i64, i64* %42
; # (or (== Z V) (memq V Z))
; # (== Z V)
  %44 = icmp eq i64 %38, %43
  br i1 %44, label %$19, label %$20
$20:
  %45 = phi i64 [%40, %$18] ; # X
  %46 = phi i64 [%41, %$18] ; # Y
; # (memq V Z)
  br label %$21
$21:
  %47 = phi i64 [%38, %$20], [%59, %$25] ; # L
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$24, label %$22
$24:
  %50 = phi i64 [%47, %$21] ; # L
  br label %$23
$22:
  %51 = phi i64 [%47, %$21] ; # L
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
  %54 = icmp eq i64 %43, %53
  br i1 %54, label %$26, label %$25
$26:
  %55 = phi i64 [%51, %$22] ; # L
  br label %$23
$25:
  %56 = phi i64 [%51, %$22] ; # L
  %57 = inttoptr i64 %56 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  br label %$21
$23:
  %60 = phi i64 [%50, %$24], [%55, %$26] ; # L
  %61 = phi i1 [0, %$24], [1, %$26] ; # ->
  br label %$19
$19:
  %62 = phi i64 [%40, %$18], [%45, %$23] ; # X
  %63 = phi i64 [%41, %$18], [%46, %$23] ; # Y
  %64 = phi i1 [1, %$18], [%61, %$23] ; # ->
  br label %$17
$17:
  %65 = phi i64 [%34, %$14], [%62, %$19] ; # X
  %66 = phi i64 [%36, %$14], [%63, %$19] ; # Y
  %67 = phi i1 [1, %$14], [%64, %$19] ; # ->
  br i1 %67, label %$27, label %$28
$27:
  %68 = phi i64 [%65, %$17] ; # X
  %69 = phi i64 [%66, %$17] ; # Y
; # (? (not (nil? (eval (car (shift Y))))) (set Var (set $At @)) (run...
; # (shift Y)
  %70 = inttoptr i64 %69 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
; # (car (shift Y))
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
; # (eval (car (shift Y)))
  %75 = and i64 %74, 6
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$31, label %$30
$31:
  br label %$29
$30:
  %77 = and i64 %74, 8
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %$33, label %$32
$33:
  %79 = inttoptr i64 %74 to i64*
  %80 = load i64, i64* %79
  br label %$29
$32:
  %81 = call i64 @evList(i64 %74)
  br label %$29
$29:
  %82 = phi i64 [%74, %$31], [%80, %$33], [%81, %$32] ; # ->
; # (nil? (eval (car (shift Y))))
  %83 = icmp eq i64 %82, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (car (shift Y)))))
  %84 = icmp eq i1 %83, 0
  br i1 %84, label %$35, label %$34
$35:
  %85 = phi i64 [%68, %$29] ; # X
  %86 = phi i64 [%72, %$29] ; # Y
; # (set Var (set $At @))
; # (set $At @)
  %87 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %82, i64* %87
  %88 = inttoptr i64 %13 to i64*
  store i64 %82, i64* %88
; # (cdr Y)
  %89 = inttoptr i64 %86 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  %91 = load i64, i64* %90
; # (run (cdr Y))
  br label %$36
$36:
  %92 = phi i64 [%91, %$35], [%114, %$45] ; # Prg
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
  %95 = getelementptr i64, i64* %93, i32 1
  %96 = load i64, i64* %95
  %97 = and i64 %96, 15
  %98 = icmp ne i64 %97, 0
  br i1 %98, label %$39, label %$37
$39:
  %99 = phi i64 [%96, %$36] ; # Prg
  %100 = and i64 %94, 6
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$42, label %$41
$42:
  br label %$40
$41:
  %102 = and i64 %94, 8
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$44, label %$43
$44:
  %104 = inttoptr i64 %94 to i64*
  %105 = load i64, i64* %104
  br label %$40
$43:
  %106 = call i64 @evList(i64 %94)
  br label %$40
$40:
  %107 = phi i64 [%94, %$42], [%105, %$44], [%106, %$43] ; # ->
  br label %$38
$37:
  %108 = phi i64 [%96, %$36] ; # Prg
  %109 = and i64 %94, 15
  %110 = icmp eq i64 %109, 0
  br i1 %110, label %$46, label %$45
$46:
  %111 = phi i64 [%108, %$37] ; # Prg
  %112 = call i64 @evList(i64 %94)
  %113 = icmp ne i64 %112, 0
  br label %$45
$45:
  %114 = phi i64 [%108, %$37], [%111, %$46] ; # Prg
  %115 = phi i1 [0, %$37], [%113, %$46] ; # ->
  br label %$36
$38:
  %116 = phi i64 [%99, %$40] ; # Prg
  %117 = phi i64 [%107, %$40] ; # ->
  br label %$15
$34:
  %118 = phi i64 [%68, %$29] ; # X
  %119 = phi i64 [%72, %$29] ; # Y
  br label %$28
$28:
  %120 = phi i64 [%65, %$17], [%118, %$34] ; # X
  %121 = phi i64 [%66, %$17], [%119, %$34] ; # Y
  br label %$13
$15:
  %122 = phi i64 [%33, %$16], [%85, %$38] ; # X
  %123 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%117, %$38] ; # ->
; # (drop *Safe)
  %124 = inttoptr i64 %22 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
  %127 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %126, i64* %127
  ret i64 %123
}

define i64 @_while(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (++ X) R (save $Nil)) (until (nil? (eval E)) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (save $Nil)
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = alloca i64, i64 2, align 16
  %11 = ptrtoint i64* %10 to i64
  %12 = inttoptr i64 %11 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %12
  %13 = add i64 %11, 8
  %14 = inttoptr i64 %13 to i64*
  store i64 %9, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %11, i64* %15
; # (until (nil? (eval E)) (set $At @) (setq R (safe (run X))))
  br label %$2
$2:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%53, %$12] ; # R
; # (eval E)
  %17 = and i64 %5, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %5, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %5 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %24 = phi i64 [%5, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (nil? (eval E))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %25, label %$9, label %$8
$8:
  %26 = phi i64 [%16, %$3] ; # R
; # (set $At @)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %24, i64* %27
; # (run X)
  br label %$10
$10:
  %28 = phi i64 [%7, %$8], [%50, %$19] ; # Prg
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  %31 = getelementptr i64, i64* %29, i32 1
  %32 = load i64, i64* %31
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$11
$13:
  %35 = phi i64 [%32, %$10] ; # Prg
  %36 = and i64 %30, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$16, label %$15
$16:
  br label %$14
$15:
  %38 = and i64 %30, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$18, label %$17
$18:
  %40 = inttoptr i64 %30 to i64*
  %41 = load i64, i64* %40
  br label %$14
$17:
  %42 = call i64 @evList(i64 %30)
  br label %$14
$14:
  %43 = phi i64 [%30, %$16], [%41, %$18], [%42, %$17] ; # ->
  br label %$12
$11:
  %44 = phi i64 [%32, %$10] ; # Prg
  %45 = and i64 %30, 15
  %46 = icmp eq i64 %45, 0
  br i1 %46, label %$20, label %$19
$20:
  %47 = phi i64 [%44, %$11] ; # Prg
  %48 = call i64 @evList(i64 %30)
  %49 = icmp ne i64 %48, 0
  br label %$19
$19:
  %50 = phi i64 [%44, %$11], [%47, %$20] ; # Prg
  %51 = phi i1 [0, %$11], [%49, %$20] ; # ->
  br label %$10
$12:
  %52 = phi i64 [%35, %$14] ; # Prg
  %53 = phi i64 [%43, %$14] ; # ->
; # (safe (run X))
  %54 = inttoptr i64 %11 to i64*
  store i64 %53, i64* %54
  br label %$2
$9:
  %55 = phi i64 [%16, %$3] ; # R
; # (drop *Safe)
  %56 = inttoptr i64 %11 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %55
}

define i64 @_until(i64) align 8 {
$1:
; # (let (X (cdr Exe) E (++ X) R (save $Nil)) (while (nil? (eval E)) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (save $Nil)
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = alloca i64, i64 2, align 16
  %11 = ptrtoint i64* %10 to i64
  %12 = inttoptr i64 %11 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %12
  %13 = add i64 %11, 8
  %14 = inttoptr i64 %13 to i64*
  store i64 %9, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %11, i64* %15
; # (while (nil? (eval E)) (setq R (safe (run X))))
  br label %$2
$2:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%52, %$12] ; # R
; # (eval E)
  %17 = and i64 %5, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %5, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %5 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %24 = phi i64 [%5, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (nil? (eval E))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %25, label %$8, label %$9
$8:
  %26 = phi i64 [%16, %$3] ; # R
; # (run X)
  br label %$10
$10:
  %27 = phi i64 [%7, %$8], [%49, %$19] ; # Prg
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
  %30 = getelementptr i64, i64* %28, i32 1
  %31 = load i64, i64* %30
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$11
$13:
  %34 = phi i64 [%31, %$10] ; # Prg
  %35 = and i64 %29, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$16, label %$15
$16:
  br label %$14
$15:
  %37 = and i64 %29, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$18, label %$17
$18:
  %39 = inttoptr i64 %29 to i64*
  %40 = load i64, i64* %39
  br label %$14
$17:
  %41 = call i64 @evList(i64 %29)
  br label %$14
$14:
  %42 = phi i64 [%29, %$16], [%40, %$18], [%41, %$17] ; # ->
  br label %$12
$11:
  %43 = phi i64 [%31, %$10] ; # Prg
  %44 = and i64 %29, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$20, label %$19
$20:
  %46 = phi i64 [%43, %$11] ; # Prg
  %47 = call i64 @evList(i64 %29)
  %48 = icmp ne i64 %47, 0
  br label %$19
$19:
  %49 = phi i64 [%43, %$11], [%46, %$20] ; # Prg
  %50 = phi i1 [0, %$11], [%48, %$20] ; # ->
  br label %$10
$12:
  %51 = phi i64 [%34, %$14] ; # Prg
  %52 = phi i64 [%42, %$14] ; # ->
; # (safe (run X))
  %53 = inttoptr i64 %11 to i64*
  store i64 %52, i64* %53
  br label %$2
$9:
  %54 = phi i64 [%16, %$3] ; # R
; # (set $At @)
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %24, i64* %55
; # (drop *Safe)
  %56 = inttoptr i64 %11 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %54
}

define i64 @_at(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (needPair Exe (eval (car X))) Z (cdr Y)) (con...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needPair Exe (eval (car X)))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @pairErr(i64 %0, i64 %13)
  unreachable
$8:
; # (cdr Y)
  %16 = inttoptr i64 %13 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (cond ((nil? Z) @) ((< (+ (car Y) (hex "10")) Z) (set Y @) $Nil) ...
; # (nil? Z)
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %19, label %$11, label %$10
$11:
  br label %$9
$10:
; # (car Y)
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
; # (+ (car Y) (hex "10"))
  %22 = add i64 %21, 16
; # (< (+ (car Y) (hex "10")) Z)
  %23 = icmp ult i64 %22, %18
  br i1 %23, label %$13, label %$12
$13:
; # (set Y @)
  %24 = inttoptr i64 %13 to i64*
  store i64 %22, i64* %24
  br label %$9
$12:
; # (set Y ZERO)
  %25 = inttoptr i64 %13 to i64*
  store i64 2, i64* %25
; # (cdr X)
  %26 = inttoptr i64 %3 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (run (cdr X))
  br label %$14
$14:
  %29 = phi i64 [%28, %$12], [%51, %$23] ; # Prg
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
  %34 = and i64 %33, 15
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$17, label %$15
$17:
  %36 = phi i64 [%33, %$14] ; # Prg
  %37 = and i64 %31, 6
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$20, label %$19
$20:
  br label %$18
$19:
  %39 = and i64 %31, 8
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$22, label %$21
$22:
  %41 = inttoptr i64 %31 to i64*
  %42 = load i64, i64* %41
  br label %$18
$21:
  %43 = call i64 @evList(i64 %31)
  br label %$18
$18:
  %44 = phi i64 [%31, %$20], [%42, %$22], [%43, %$21] ; # ->
  br label %$16
$15:
  %45 = phi i64 [%33, %$14] ; # Prg
  %46 = and i64 %31, 15
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %$24, label %$23
$24:
  %48 = phi i64 [%45, %$15] ; # Prg
  %49 = call i64 @evList(i64 %31)
  %50 = icmp ne i64 %49, 0
  br label %$23
$23:
  %51 = phi i64 [%45, %$15], [%48, %$24] ; # Prg
  %52 = phi i1 [0, %$15], [%50, %$24] ; # ->
  br label %$14
$16:
  %53 = phi i64 [%36, %$18] ; # Prg
  %54 = phi i64 [%44, %$18] ; # ->
  br label %$9
$9:
  %55 = phi i64 [%18, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%54, %$16] ; # ->
  ret i64 %55
}

define i64 @loop1(i64) align 8 {
$1:
; # (loop (let E (car X) (unless (num? E) (setq E (cond ((sym? E) (va...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%141, %$49] ; # X
; # (let E (car X) (unless (num? E) (setq E (cond ((sym? E) (val E)) ...
; # (car X)
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (unless (num? E) (setq E (cond ((sym? E) (val E)) ((nil? (car E))...
; # (num? E)
  %4 = and i64 %3, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$3:
  %6 = phi i64 [%1, %$2] ; # X
  %7 = phi i64 [%3, %$2] ; # E
; # (cond ((sym? E) (val E)) ((nil? (car E)) (? (nil? (eval (car (shi...
; # (sym? E)
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = phi i64 [%6, %$3] ; # X
  %11 = phi i64 [%7, %$3] ; # E
; # (val E)
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
  br label %$5
$6:
  %14 = phi i64 [%6, %$3] ; # X
  %15 = phi i64 [%7, %$3] ; # E
; # (car E)
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (nil? (car E))
  %18 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$9, label %$8
$9:
  %19 = phi i64 [%14, %$6] ; # X
  %20 = phi i64 [%15, %$6] ; # E
; # (? (nil? (eval (car (shift E)))) (run (cdr E)))
; # (shift E)
  %21 = inttoptr i64 %20 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (car (shift E))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
; # (eval (car (shift E)))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$12, label %$11
$12:
  br label %$10
$11:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$14, label %$13
$14:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$10
$13:
  %32 = call i64 @evList(i64 %25)
  br label %$10
$10:
  %33 = phi i64 [%25, %$12], [%31, %$14], [%32, %$13] ; # ->
; # (nil? (eval (car (shift E))))
  %34 = icmp eq i64 %33, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %34, label %$17, label %$15
$17:
  %35 = phi i64 [%19, %$10] ; # X
  %36 = phi i64 [%23, %$10] ; # E
; # (cdr E)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (run (cdr E))
  br label %$18
$18:
  %40 = phi i64 [%39, %$17], [%62, %$27] ; # Prg
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = getelementptr i64, i64* %41, i32 1
  %44 = load i64, i64* %43
  %45 = and i64 %44, 15
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$21, label %$19
$21:
  %47 = phi i64 [%44, %$18] ; # Prg
  %48 = and i64 %42, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$24, label %$23
$24:
  br label %$22
$23:
  %50 = and i64 %42, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$26, label %$25
$26:
  %52 = inttoptr i64 %42 to i64*
  %53 = load i64, i64* %52
  br label %$22
$25:
  %54 = call i64 @evList(i64 %42)
  br label %$22
$22:
  %55 = phi i64 [%42, %$24], [%53, %$26], [%54, %$25] ; # ->
  br label %$20
$19:
  %56 = phi i64 [%44, %$18] ; # Prg
  %57 = and i64 %42, 15
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %$28, label %$27
$28:
  %59 = phi i64 [%56, %$19] ; # Prg
  %60 = call i64 @evList(i64 %42)
  %61 = icmp ne i64 %60, 0
  br label %$27
$27:
  %62 = phi i64 [%56, %$19], [%59, %$28] ; # Prg
  %63 = phi i1 [0, %$19], [%61, %$28] ; # ->
  br label %$18
$20:
  %64 = phi i64 [%47, %$22] ; # Prg
  %65 = phi i64 [%55, %$22] ; # ->
  br label %$16
$15:
  %66 = phi i64 [%19, %$10] ; # X
  %67 = phi i64 [%23, %$10] ; # E
; # (set $At @)
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %33, i64* %68
  br label %$5
$8:
  %69 = phi i64 [%14, %$6] ; # X
  %70 = phi i64 [%15, %$6] ; # E
; # (car E)
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
; # (t? (car E))
  %73 = icmp eq i64 %72, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %73, label %$30, label %$29
$30:
  %74 = phi i64 [%69, %$8] ; # X
  %75 = phi i64 [%70, %$8] ; # E
; # (? (not (nil? (eval (car (shift E))))) (set $At @) (run (cdr E)))...
; # (shift E)
  %76 = inttoptr i64 %75 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (car (shift E))
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
; # (eval (car (shift E)))
  %81 = and i64 %80, 6
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$33, label %$32
$33:
  br label %$31
$32:
  %83 = and i64 %80, 8
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$35, label %$34
$35:
  %85 = inttoptr i64 %80 to i64*
  %86 = load i64, i64* %85
  br label %$31
$34:
  %87 = call i64 @evList(i64 %80)
  br label %$31
$31:
  %88 = phi i64 [%80, %$33], [%86, %$35], [%87, %$34] ; # ->
; # (nil? (eval (car (shift E))))
  %89 = icmp eq i64 %88, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (car (shift E)))))
  %90 = icmp eq i1 %89, 0
  br i1 %90, label %$37, label %$36
$37:
  %91 = phi i64 [%74, %$31] ; # X
  %92 = phi i64 [%78, %$31] ; # E
; # (set $At @)
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %88, i64* %93
; # (cdr E)
  %94 = inttoptr i64 %92 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
; # (run (cdr E))
  br label %$38
$38:
  %97 = phi i64 [%96, %$37], [%119, %$47] ; # Prg
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
  %100 = getelementptr i64, i64* %98, i32 1
  %101 = load i64, i64* %100
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$41, label %$39
$41:
  %104 = phi i64 [%101, %$38] ; # Prg
  %105 = and i64 %99, 6
  %106 = icmp ne i64 %105, 0
  br i1 %106, label %$44, label %$43
$44:
  br label %$42
$43:
  %107 = and i64 %99, 8
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$46, label %$45
$46:
  %109 = inttoptr i64 %99 to i64*
  %110 = load i64, i64* %109
  br label %$42
$45:
  %111 = call i64 @evList(i64 %99)
  br label %$42
$42:
  %112 = phi i64 [%99, %$44], [%110, %$46], [%111, %$45] ; # ->
  br label %$40
$39:
  %113 = phi i64 [%101, %$38] ; # Prg
  %114 = and i64 %99, 15
  %115 = icmp eq i64 %114, 0
  br i1 %115, label %$48, label %$47
$48:
  %116 = phi i64 [%113, %$39] ; # Prg
  %117 = call i64 @evList(i64 %99)
  %118 = icmp ne i64 %117, 0
  br label %$47
$47:
  %119 = phi i64 [%113, %$39], [%116, %$48] ; # Prg
  %120 = phi i1 [0, %$39], [%118, %$48] ; # ->
  br label %$38
$40:
  %121 = phi i64 [%104, %$42] ; # Prg
  %122 = phi i64 [%112, %$42] ; # ->
  br label %$16
$36:
  %123 = phi i64 [%74, %$31] ; # X
  %124 = phi i64 [%78, %$31] ; # E
  br label %$5
$29:
  %125 = phi i64 [%69, %$8] ; # X
  %126 = phi i64 [%70, %$8] ; # E
; # (evList E)
  %127 = call i64 @evList(i64 %126)
  br label %$5
$5:
  %128 = phi i64 [%10, %$7], [%66, %$15], [%123, %$36], [%125, %$29] ; # X
  %129 = phi i64 [%11, %$7], [%67, %$15], [%124, %$36], [%126, %$29] ; # E
  %130 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%88, %$36], [%127, %$29] ; # ->
  br label %$4
$4:
  %131 = phi i64 [%1, %$2], [%128, %$5] ; # X
  %132 = phi i64 [%3, %$2], [%130, %$5] ; # E
; # (? (atom (shift X)) (| E 1))
; # (shift X)
  %133 = inttoptr i64 %131 to i64*
  %134 = getelementptr i64, i64* %133, i32 1
  %135 = load i64, i64* %134
; # (atom (shift X))
  %136 = and i64 %135, 15
  %137 = icmp ne i64 %136, 0
  br i1 %137, label %$50, label %$49
$50:
  %138 = phi i64 [%135, %$4] ; # X
  %139 = phi i64 [%132, %$4] ; # E
; # (| E 1)
  %140 = or i64 %139, 1
  br label %$16
$49:
  %141 = phi i64 [%135, %$4] ; # X
  %142 = phi i64 [%132, %$4] ; # E
  br label %$2
$16:
  %143 = phi i64 [%35, %$20], [%91, %$40], [%138, %$50] ; # X
  %144 = phi i64 [%65, %$20], [%122, %$40], [%140, %$50] ; # ->
  ret i64 %144
}

define i64 @loop2(i64) align 8 {
$1:
; # (loop (let X Y (loop (let E (car X) (when (pair E) (cond ((nil? (...
  br label %$2
$2:
; # (let X Y (loop (let E (car X) (when (pair E) (cond ((nil? (car E)...
; # (loop (let E (car X) (when (pair E) (cond ((nil? (car E)) (when (...
  br label %$3
$3:
  %1 = phi i64 [%0, %$2], [%128, %$47] ; # X
; # (let E (car X) (when (pair E) (cond ((nil? (car E)) (when (nil? (...
; # (car X)
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (when (pair E) (cond ((nil? (car E)) (when (nil? (eval (car (shif...
; # (pair E)
  %4 = and i64 %3, 15
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$4, label %$5
$4:
  %6 = phi i64 [%1, %$3] ; # X
  %7 = phi i64 [%3, %$3] ; # E
; # (cond ((nil? (car E)) (when (nil? (eval (car (shift E)))) (ret (r...
; # (car E)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (nil? (car E))
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$8, label %$7
$8:
  %11 = phi i64 [%6, %$4] ; # X
  %12 = phi i64 [%7, %$4] ; # E
; # (when (nil? (eval (car (shift E)))) (ret (run (cdr E))))
; # (shift E)
  %13 = inttoptr i64 %12 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (car (shift E))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (eval (car (shift E)))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
  br label %$9
$10:
  %20 = and i64 %17, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  %22 = inttoptr i64 %17 to i64*
  %23 = load i64, i64* %22
  br label %$9
$12:
  %24 = call i64 @evList(i64 %17)
  br label %$9
$9:
  %25 = phi i64 [%17, %$11], [%23, %$13], [%24, %$12] ; # ->
; # (nil? (eval (car (shift E))))
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %26, label %$14, label %$15
$14:
  %27 = phi i64 [%11, %$9] ; # X
  %28 = phi i64 [%15, %$9] ; # E
; # (cdr E)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (run (cdr E))
  br label %$16
$16:
  %32 = phi i64 [%31, %$14], [%54, %$25] ; # Prg
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = getelementptr i64, i64* %33, i32 1
  %36 = load i64, i64* %35
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$19, label %$17
$19:
  %39 = phi i64 [%36, %$16] ; # Prg
  %40 = and i64 %34, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$22, label %$21
$22:
  br label %$20
$21:
  %42 = and i64 %34, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$24, label %$23
$24:
  %44 = inttoptr i64 %34 to i64*
  %45 = load i64, i64* %44
  br label %$20
$23:
  %46 = call i64 @evList(i64 %34)
  br label %$20
$20:
  %47 = phi i64 [%34, %$22], [%45, %$24], [%46, %$23] ; # ->
  br label %$18
$17:
  %48 = phi i64 [%36, %$16] ; # Prg
  %49 = and i64 %34, 15
  %50 = icmp eq i64 %49, 0
  br i1 %50, label %$26, label %$25
$26:
  %51 = phi i64 [%48, %$17] ; # Prg
  %52 = call i64 @evList(i64 %34)
  %53 = icmp ne i64 %52, 0
  br label %$25
$25:
  %54 = phi i64 [%48, %$17], [%51, %$26] ; # Prg
  %55 = phi i1 [0, %$17], [%53, %$26] ; # ->
  br label %$16
$18:
  %56 = phi i64 [%39, %$20] ; # Prg
  %57 = phi i64 [%47, %$20] ; # ->
; # (ret (run (cdr E)))
  ret i64 %57
$15:
  %58 = phi i64 [%11, %$9] ; # X
  %59 = phi i64 [%15, %$9] ; # E
; # (set $At @)
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %25, i64* %60
  br label %$6
$7:
  %61 = phi i64 [%6, %$4] ; # X
  %62 = phi i64 [%7, %$4] ; # E
; # (car E)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (t? (car E))
  %65 = icmp eq i64 %64, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %65, label %$28, label %$27
$28:
  %66 = phi i64 [%61, %$7] ; # X
  %67 = phi i64 [%62, %$7] ; # E
; # (unless (nil? (eval (car (shift E)))) (set $At @) (ret (run (cdr ...
; # (shift E)
  %68 = inttoptr i64 %67 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
; # (car (shift E))
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
; # (eval (car (shift E)))
  %73 = and i64 %72, 6
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$31, label %$30
$31:
  br label %$29
$30:
  %75 = and i64 %72, 8
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$33, label %$32
$33:
  %77 = inttoptr i64 %72 to i64*
  %78 = load i64, i64* %77
  br label %$29
$32:
  %79 = call i64 @evList(i64 %72)
  br label %$29
$29:
  %80 = phi i64 [%72, %$31], [%78, %$33], [%79, %$32] ; # ->
; # (nil? (eval (car (shift E))))
  %81 = icmp eq i64 %80, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %81, label %$35, label %$34
$34:
  %82 = phi i64 [%66, %$29] ; # X
  %83 = phi i64 [%70, %$29] ; # E
; # (set $At @)
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %80, i64* %84
; # (cdr E)
  %85 = inttoptr i64 %83 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  %87 = load i64, i64* %86
; # (run (cdr E))
  br label %$36
$36:
  %88 = phi i64 [%87, %$34], [%110, %$45] ; # Prg
  %89 = inttoptr i64 %88 to i64*
  %90 = load i64, i64* %89
  %91 = getelementptr i64, i64* %89, i32 1
  %92 = load i64, i64* %91
  %93 = and i64 %92, 15
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$39, label %$37
$39:
  %95 = phi i64 [%92, %$36] ; # Prg
  %96 = and i64 %90, 6
  %97 = icmp ne i64 %96, 0
  br i1 %97, label %$42, label %$41
$42:
  br label %$40
$41:
  %98 = and i64 %90, 8
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$44, label %$43
$44:
  %100 = inttoptr i64 %90 to i64*
  %101 = load i64, i64* %100
  br label %$40
$43:
  %102 = call i64 @evList(i64 %90)
  br label %$40
$40:
  %103 = phi i64 [%90, %$42], [%101, %$44], [%102, %$43] ; # ->
  br label %$38
$37:
  %104 = phi i64 [%92, %$36] ; # Prg
  %105 = and i64 %90, 15
  %106 = icmp eq i64 %105, 0
  br i1 %106, label %$46, label %$45
$46:
  %107 = phi i64 [%104, %$37] ; # Prg
  %108 = call i64 @evList(i64 %90)
  %109 = icmp ne i64 %108, 0
  br label %$45
$45:
  %110 = phi i64 [%104, %$37], [%107, %$46] ; # Prg
  %111 = phi i1 [0, %$37], [%109, %$46] ; # ->
  br label %$36
$38:
  %112 = phi i64 [%95, %$40] ; # Prg
  %113 = phi i64 [%103, %$40] ; # ->
; # (ret (run (cdr E)))
  ret i64 %113
$35:
  %114 = phi i64 [%66, %$29] ; # X
  %115 = phi i64 [%70, %$29] ; # E
  br label %$6
$27:
  %116 = phi i64 [%61, %$7] ; # X
  %117 = phi i64 [%62, %$7] ; # E
; # (evList E)
  %118 = call i64 @evList(i64 %117)
  br label %$6
$6:
  %119 = phi i64 [%58, %$15], [%114, %$35], [%116, %$27] ; # X
  %120 = phi i64 [%59, %$15], [%115, %$35], [%117, %$27] ; # E
  br label %$5
$5:
  %121 = phi i64 [%1, %$3], [%119, %$6] ; # X
  %122 = phi i64 [%3, %$3], [%120, %$6] ; # E
; # (? (atom (shift X)))
; # (shift X)
  %123 = inttoptr i64 %121 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
; # (atom (shift X))
  %126 = and i64 %125, 15
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$48, label %$47
$47:
  %128 = phi i64 [%125, %$5] ; # X
  br label %$3
$48:
  %129 = phi i64 [%125, %$5] ; # X
  %130 = phi i64 [0, %$5] ; # ->
  br label %$2
}

define i64 @_do(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((nil? Y) Y) ((cnt? Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((nil? Y) Y) ((cnt? Y) (let N (int Y) (if (or (sign? Y) (=0...
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  br label %$7
$8:
; # (cnt? Y)
  %17 = and i64 %15, 2
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (let N (int Y) (if (or (sign? Y) (=0 N)) $Nil (loop (let R (loop1...
; # (int Y)
  %19 = lshr i64 %15, 4
; # (if (or (sign? Y) (=0 N)) $Nil (loop (let R (loop1 X) (? (=0 (& R...
; # (or (sign? Y) (=0 N))
; # (sign? Y)
  %20 = and i64 %15, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$12, label %$13
$13:
  %22 = phi i64 [%19, %$11] ; # N
; # (=0 N)
  %23 = icmp eq i64 %22, 0
  br label %$12
$12:
  %24 = phi i64 [%19, %$11], [%22, %$13] ; # N
  %25 = phi i1 [1, %$11], [%23, %$13] ; # ->
  br i1 %25, label %$14, label %$15
$14:
  %26 = phi i64 [%24, %$12] ; # N
  br label %$16
$15:
  %27 = phi i64 [%24, %$12] ; # N
; # (loop (let R (loop1 X) (? (=0 (& R 1)) R) (? (=0 (dec 'N)) (& R -...
  br label %$17
$17:
  %28 = phi i64 [%27, %$15], [%38, %$21] ; # N
; # (let R (loop1 X) (? (=0 (& R 1)) R) (? (=0 (dec 'N)) (& R -2)))
; # (loop1 X)
  %29 = call i64 @loop1(i64 %7)
; # (? (=0 (& R 1)) R)
; # (& R 1)
  %30 = and i64 %29, 1
; # (=0 (& R 1))
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$20, label %$18
$20:
  %32 = phi i64 [%28, %$17] ; # N
  br label %$19
$18:
  %33 = phi i64 [%28, %$17] ; # N
; # (? (=0 (dec 'N)) (& R -2))
; # (dec 'N)
  %34 = sub i64 %33, 1
; # (=0 (dec 'N))
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$22, label %$21
$22:
  %36 = phi i64 [%34, %$18] ; # N
; # (& R -2)
  %37 = and i64 %29, -2
  br label %$19
$21:
  %38 = phi i64 [%34, %$18] ; # N
  br label %$17
$19:
  %39 = phi i64 [%32, %$20], [%36, %$22] ; # N
  %40 = phi i64 [%29, %$20], [%37, %$22] ; # ->
  br label %$16
$16:
  %41 = phi i64 [%26, %$14], [%39, %$19] ; # N
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$14], [%40, %$19] ; # ->
  br label %$7
$10:
; # (loop2 X)
  %43 = call i64 @loop2(i64 %7)
  br label %$7
$7:
  %44 = phi i64 [%15, %$9], [%42, %$16], [%43, %$10] ; # ->
  ret i64 %44
}

define i64 @_loop(i64) align 8 {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop2 (cdr Exe))
  %4 = tail call i64 @loop2(i64 %3)
  ret i64 %4
}

define i64 @_for(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (++ X) R $Nil) (cond ((atom Y) (needChkVar Ex...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (cond ((atom Y) (needChkVar Exe Y) (let P (set $Bind (push NIL NI...
; # (atom Y)
  %8 = and i64 %5, 15
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  %10 = phi i64 [%7, %$1] ; # X
  %11 = phi i64 [%5, %$1] ; # Y
  %12 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (needChkVar Exe Y)
  %13 = and i64 %11, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$5, label %$6
$5:
  call void @varErr(i64 %0, i64 %11)
  unreachable
$6:
  %15 = icmp uge i64 %11, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$8, label %$7
$8:
  %16 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %11
  br label %$7
$7:
  %17 = phi i1 [0, %$6], [%16, %$8] ; # ->
  br i1 %17, label %$9, label %$10
$9:
  call void @protErr(i64 %0, i64 %11)
  unreachable
$10:
; # (let P (set $Bind (push NIL NIL (val $Bind))) (set P (val Y) 2 P ...
; # (set $Bind (push NIL NIL (val $Bind)))
; # (val $Bind)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %19 = load i64, i64* %18
; # (push NIL NIL (val $Bind))
  %20 = alloca i64, i64 3, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = add i64 %21, 16
  %23 = inttoptr i64 %22 to i64*
  store i64 %19, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %21, i64* %24
; # (set P (val Y) 2 P Y)
; # (val Y)
  %25 = inttoptr i64 %11 to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %21 to i64*
  store i64 %26, i64* %27
  %28 = inttoptr i64 %21 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %11, i64* %29
; # (let V (eval (++ X)) (if (num? V) (unless (sign? V) (set Y ZERO) ...
; # (++ X)
  %30 = inttoptr i64 %10 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
; # (eval (++ X))
  %34 = and i64 %31, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$13, label %$12
$13:
  br label %$11
$12:
  %36 = and i64 %31, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$15, label %$14
$15:
  %38 = inttoptr i64 %31 to i64*
  %39 = load i64, i64* %38
  br label %$11
$14:
  %40 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %41 = phi i64 [%31, %$13], [%39, %$15], [%40, %$14] ; # ->
; # (if (num? V) (unless (sign? V) (set Y ZERO) (loop (? (> (+ (val Y...
; # (num? V)
  %42 = and i64 %41, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$16, label %$17
$16:
  %44 = phi i64 [%33, %$11] ; # X
  %45 = phi i64 [%11, %$11] ; # Y
  %46 = phi i64 [%12, %$11] ; # R
  %47 = phi i64 [%41, %$11] ; # V
; # (unless (sign? V) (set Y ZERO) (loop (? (> (+ (val Y) (hex "10"))...
; # (sign? V)
  %48 = and i64 %47, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$20, label %$19
$19:
  %50 = phi i64 [%44, %$16] ; # X
  %51 = phi i64 [%45, %$16] ; # Y
  %52 = phi i64 [%46, %$16] ; # R
  %53 = phi i64 [%47, %$16] ; # V
; # (set Y ZERO)
  %54 = inttoptr i64 %51 to i64*
  store i64 2, i64* %54
; # (loop (? (> (+ (val Y) (hex "10")) V) (setq R (& R -2))) (set Y @...
  br label %$21
$21:
  %55 = phi i64 [%50, %$19], [%76, %$25] ; # X
  %56 = phi i64 [%51, %$19], [%77, %$25] ; # Y
  %57 = phi i64 [%52, %$19], [%78, %$25] ; # R
  %58 = phi i64 [%53, %$19], [%79, %$25] ; # V
; # (? (> (+ (val Y) (hex "10")) V) (setq R (& R -2)))
; # (val Y)
  %59 = inttoptr i64 %56 to i64*
  %60 = load i64, i64* %59
; # (+ (val Y) (hex "10"))
  %61 = add i64 %60, 16
; # (> (+ (val Y) (hex "10")) V)
  %62 = icmp ugt i64 %61, %58
  br i1 %62, label %$24, label %$22
$24:
  %63 = phi i64 [%55, %$21] ; # X
  %64 = phi i64 [%56, %$21] ; # Y
  %65 = phi i64 [%57, %$21] ; # R
  %66 = phi i64 [%58, %$21] ; # V
; # (& R -2)
  %67 = and i64 %65, -2
  br label %$23
$22:
  %68 = phi i64 [%55, %$21] ; # X
  %69 = phi i64 [%56, %$21] ; # Y
  %70 = phi i64 [%57, %$21] ; # R
  %71 = phi i64 [%58, %$21] ; # V
; # (set Y @)
  %72 = inttoptr i64 %69 to i64*
  store i64 %61, i64* %72
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %73 = call i64 @loop1(i64 %68)
; # (& (setq R (loop1 X)) 1)
  %74 = and i64 %73, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$23, label %$25
$25:
  %76 = phi i64 [%68, %$22] ; # X
  %77 = phi i64 [%69, %$22] ; # Y
  %78 = phi i64 [%73, %$22] ; # R
  %79 = phi i64 [%71, %$22] ; # V
  br label %$21
$23:
  %80 = phi i64 [%63, %$24], [%68, %$22] ; # X
  %81 = phi i64 [%64, %$24], [%69, %$22] ; # Y
  %82 = phi i64 [%67, %$24], [%73, %$22] ; # R
  %83 = phi i64 [%66, %$24], [%71, %$22] ; # V
  %84 = phi i64 [%67, %$24], [0, %$22] ; # ->
  br label %$20
$20:
  %85 = phi i64 [%44, %$16], [%80, %$23] ; # X
  %86 = phi i64 [%45, %$16], [%81, %$23] ; # Y
  %87 = phi i64 [%46, %$16], [%82, %$23] ; # R
  %88 = phi i64 [%47, %$16], [%83, %$23] ; # V
  br label %$18
$17:
  %89 = phi i64 [%33, %$11] ; # X
  %90 = phi i64 [%11, %$11] ; # Y
  %91 = phi i64 [%12, %$11] ; # R
  %92 = phi i64 [%41, %$11] ; # V
; # (save V (loop (? (atom V) (setq R (& R -2))) (set Y (++ V)) (? (=...
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %94 = load i64, i64* %93
  %95 = alloca i64, i64 2, align 16
  %96 = ptrtoint i64* %95 to i64
  %97 = inttoptr i64 %96 to i64*
  store i64 %92, i64* %97
  %98 = add i64 %96, 8
  %99 = inttoptr i64 %98 to i64*
  store i64 %94, i64* %99
  %100 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %96, i64* %100
; # (loop (? (atom V) (setq R (& R -2))) (set Y (++ V)) (? (=0 (& (se...
  br label %$26
$26:
  %101 = phi i64 [%89, %$17], [%124, %$30] ; # X
  %102 = phi i64 [%90, %$17], [%125, %$30] ; # Y
  %103 = phi i64 [%91, %$17], [%126, %$30] ; # R
  %104 = phi i64 [%92, %$17], [%127, %$30] ; # V
; # (? (atom V) (setq R (& R -2)))
; # (atom V)
  %105 = and i64 %104, 15
  %106 = icmp ne i64 %105, 0
  br i1 %106, label %$29, label %$27
$29:
  %107 = phi i64 [%101, %$26] ; # X
  %108 = phi i64 [%102, %$26] ; # Y
  %109 = phi i64 [%103, %$26] ; # R
  %110 = phi i64 [%104, %$26] ; # V
; # (& R -2)
  %111 = and i64 %109, -2
  br label %$28
$27:
  %112 = phi i64 [%101, %$26] ; # X
  %113 = phi i64 [%102, %$26] ; # Y
  %114 = phi i64 [%103, %$26] ; # R
  %115 = phi i64 [%104, %$26] ; # V
; # (set Y (++ V))
; # (++ V)
  %116 = inttoptr i64 %115 to i64*
  %117 = load i64, i64* %116
  %118 = getelementptr i64, i64* %116, i32 1
  %119 = load i64, i64* %118
  %120 = inttoptr i64 %113 to i64*
  store i64 %117, i64* %120
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %121 = call i64 @loop1(i64 %112)
; # (& (setq R (loop1 X)) 1)
  %122 = and i64 %121, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %123 = icmp eq i64 %122, 0
  br i1 %123, label %$28, label %$30
$30:
  %124 = phi i64 [%112, %$27] ; # X
  %125 = phi i64 [%113, %$27] ; # Y
  %126 = phi i64 [%121, %$27] ; # R
  %127 = phi i64 [%119, %$27] ; # V
  br label %$26
$28:
  %128 = phi i64 [%107, %$29], [%112, %$27] ; # X
  %129 = phi i64 [%108, %$29], [%113, %$27] ; # Y
  %130 = phi i64 [%111, %$29], [%121, %$27] ; # R
  %131 = phi i64 [%110, %$29], [%119, %$27] ; # V
  %132 = phi i64 [%111, %$29], [0, %$27] ; # ->
; # drop
  %133 = inttoptr i64 %96 to i64*
  %134 = getelementptr i64, i64* %133, i32 1
  %135 = load i64, i64* %134
  %136 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %135, i64* %136
  br label %$18
$18:
  %137 = phi i64 [%85, %$20], [%128, %$28] ; # X
  %138 = phi i64 [%86, %$20], [%129, %$28] ; # Y
  %139 = phi i64 [%87, %$20], [%130, %$28] ; # R
  %140 = phi i64 [%88, %$20], [%131, %$28] ; # V
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %141 = inttoptr i64 %21 to i64*
  %142 = load i64, i64* %141
  %143 = inttoptr i64 %138 to i64*
  store i64 %142, i64* %143
; # (val 3 P)
  %144 = inttoptr i64 %21 to i64*
  %145 = getelementptr i64, i64* %144, i32 2
  %146 = load i64, i64* %145
  %147 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %146, i64* %147
  br label %$2
$3:
  %148 = phi i64 [%7, %$1] ; # X
  %149 = phi i64 [%5, %$1] ; # Y
  %150 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (cdr Y)
  %151 = inttoptr i64 %149 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
; # (atom (cdr Y))
  %154 = and i64 %153, 15
  %155 = icmp ne i64 %154, 0
  br i1 %155, label %$32, label %$31
$32:
  %156 = phi i64 [%148, %$3] ; # X
  %157 = phi i64 [%149, %$3] ; # Y
  %158 = phi i64 [%150, %$3] ; # R
; # (let Sym2 (needChkVar Exe @) (needChkVar Exe (setq Y (car Y))) (l...
; # (needChkVar Exe @)
  %159 = and i64 %153, 6
  %160 = icmp ne i64 %159, 0
  br i1 %160, label %$33, label %$34
$33:
  call void @varErr(i64 %0, i64 %153)
  unreachable
$34:
  %161 = icmp uge i64 %153, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %161, label %$36, label %$35
$36:
  %162 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %153
  br label %$35
$35:
  %163 = phi i1 [0, %$34], [%162, %$36] ; # ->
  br i1 %163, label %$37, label %$38
$37:
  call void @protErr(i64 %0, i64 %153)
  unreachable
$38:
; # (car Y)
  %164 = inttoptr i64 %157 to i64*
  %165 = load i64, i64* %164
; # (needChkVar Exe (setq Y (car Y)))
  %166 = and i64 %165, 6
  %167 = icmp ne i64 %166, 0
  br i1 %167, label %$39, label %$40
$39:
  call void @varErr(i64 %0, i64 %165)
  unreachable
$40:
  %168 = icmp uge i64 %165, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %168, label %$42, label %$41
$42:
  %169 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %165
  br label %$41
$41:
  %170 = phi i1 [0, %$40], [%169, %$42] ; # ->
  br i1 %170, label %$43, label %$44
$43:
  call void @protErr(i64 %0, i64 %165)
  unreachable
$44:
; # (let P (set $Bind (push NIL NIL (val $Bind))) (set P (val Y) 2 P ...
; # (set $Bind (push NIL NIL (val $Bind)))
; # (val $Bind)
  %171 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %172 = load i64, i64* %171
; # (push NIL NIL (val $Bind))
  %173 = alloca i64, i64 3, align 16
  %174 = ptrtoint i64* %173 to i64
  %175 = add i64 %174, 16
  %176 = inttoptr i64 %175 to i64*
  store i64 %172, i64* %176
  %177 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %174, i64* %177
; # (set P (val Y) 2 P Y)
; # (val Y)
  %178 = inttoptr i64 %165 to i64*
  %179 = load i64, i64* %178
  %180 = inttoptr i64 %174 to i64*
  store i64 %179, i64* %180
  %181 = inttoptr i64 %174 to i64*
  %182 = getelementptr i64, i64* %181, i32 1
  store i64 %165, i64* %182
; # (let (Q (set $Bind (push (val Sym2) Sym2 (val $Bind))) V (save (e...
; # (set $Bind (push (val Sym2) Sym2 (val $Bind)))
; # (val Sym2)
  %183 = inttoptr i64 %153 to i64*
  %184 = load i64, i64* %183
; # (val $Bind)
  %185 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %186 = load i64, i64* %185
; # (push (val Sym2) Sym2 (val $Bind))
  %187 = alloca i64, i64 3, align 16
  %188 = ptrtoint i64* %187 to i64
  %189 = inttoptr i64 %188 to i64*
  store i64 %184, i64* %189
  %190 = add i64 %188, 8
  %191 = inttoptr i64 %190 to i64*
  store i64 %153, i64* %191
  %192 = add i64 %188, 16
  %193 = inttoptr i64 %192 to i64*
  store i64 %186, i64* %193
  %194 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %188, i64* %194
; # (++ X)
  %195 = inttoptr i64 %156 to i64*
  %196 = load i64, i64* %195
  %197 = getelementptr i64, i64* %195, i32 1
  %198 = load i64, i64* %197
; # (eval (++ X))
  %199 = and i64 %196, 6
  %200 = icmp ne i64 %199, 0
  br i1 %200, label %$47, label %$46
$47:
  br label %$45
$46:
  %201 = and i64 %196, 8
  %202 = icmp ne i64 %201, 0
  br i1 %202, label %$49, label %$48
$49:
  %203 = inttoptr i64 %196 to i64*
  %204 = load i64, i64* %203
  br label %$45
$48:
  %205 = call i64 @evList(i64 %196)
  br label %$45
$45:
  %206 = phi i64 [%196, %$47], [%204, %$49], [%205, %$48] ; # ->
; # (save (eval (++ X)))
  %207 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %208 = load i64, i64* %207
  %209 = alloca i64, i64 2, align 16
  %210 = ptrtoint i64* %209 to i64
  %211 = inttoptr i64 %210 to i64*
  store i64 %206, i64* %211
  %212 = add i64 %210, 8
  %213 = inttoptr i64 %212 to i64*
  store i64 %208, i64* %213
  %214 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %210, i64* %214
; # (set Y ONE)
  %215 = inttoptr i64 %165 to i64*
  store i64 18, i64* %215
; # (loop (? (atom V) (setq R (& R -2))) (set Sym2 (++ V)) (? (=0 (& ...
  br label %$50
$50:
  %216 = phi i64 [%198, %$45], [%239, %$54] ; # X
  %217 = phi i64 [%165, %$45], [%240, %$54] ; # Y
  %218 = phi i64 [%158, %$45], [%241, %$54] ; # R
  %219 = phi i64 [%206, %$45], [%242, %$54] ; # V
; # (? (atom V) (setq R (& R -2)))
; # (atom V)
  %220 = and i64 %219, 15
  %221 = icmp ne i64 %220, 0
  br i1 %221, label %$53, label %$51
$53:
  %222 = phi i64 [%216, %$50] ; # X
  %223 = phi i64 [%217, %$50] ; # Y
  %224 = phi i64 [%218, %$50] ; # R
  %225 = phi i64 [%219, %$50] ; # V
; # (& R -2)
  %226 = and i64 %224, -2
  br label %$52
$51:
  %227 = phi i64 [%216, %$50] ; # X
  %228 = phi i64 [%217, %$50] ; # Y
  %229 = phi i64 [%218, %$50] ; # R
  %230 = phi i64 [%219, %$50] ; # V
; # (set Sym2 (++ V))
; # (++ V)
  %231 = inttoptr i64 %230 to i64*
  %232 = load i64, i64* %231
  %233 = getelementptr i64, i64* %231, i32 1
  %234 = load i64, i64* %233
  %235 = inttoptr i64 %153 to i64*
  store i64 %232, i64* %235
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %236 = call i64 @loop1(i64 %227)
; # (& (setq R (loop1 X)) 1)
  %237 = and i64 %236, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %238 = icmp eq i64 %237, 0
  br i1 %238, label %$52, label %$54
$54:
  %239 = phi i64 [%227, %$51] ; # X
  %240 = phi i64 [%228, %$51] ; # Y
  %241 = phi i64 [%236, %$51] ; # R
  %242 = phi i64 [%234, %$51] ; # V
; # (set Y (+ (val Y) (hex "10")))
; # (val Y)
  %243 = inttoptr i64 %240 to i64*
  %244 = load i64, i64* %243
; # (+ (val Y) (hex "10"))
  %245 = add i64 %244, 16
  %246 = inttoptr i64 %240 to i64*
  store i64 %245, i64* %246
  br label %$50
$52:
  %247 = phi i64 [%222, %$53], [%227, %$51] ; # X
  %248 = phi i64 [%223, %$53], [%228, %$51] ; # Y
  %249 = phi i64 [%226, %$53], [%236, %$51] ; # R
  %250 = phi i64 [%225, %$53], [%234, %$51] ; # V
  %251 = phi i64 [%226, %$53], [0, %$51] ; # ->
; # (set Sym2 (val Q))
; # (val Q)
  %252 = inttoptr i64 %188 to i64*
  %253 = load i64, i64* %252
  %254 = inttoptr i64 %153 to i64*
  store i64 %253, i64* %254
; # (drop *Safe)
  %255 = inttoptr i64 %210 to i64*
  %256 = getelementptr i64, i64* %255, i32 1
  %257 = load i64, i64* %256
  %258 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %257, i64* %258
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %259 = inttoptr i64 %174 to i64*
  %260 = load i64, i64* %259
  %261 = inttoptr i64 %248 to i64*
  store i64 %260, i64* %261
; # (val 3 P)
  %262 = inttoptr i64 %174 to i64*
  %263 = getelementptr i64, i64* %262, i32 2
  %264 = load i64, i64* %263
  %265 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %264, i64* %265
  br label %$2
$31:
  %266 = phi i64 [%148, %$3] ; # X
  %267 = phi i64 [%149, %$3] ; # Y
  %268 = phi i64 [%150, %$3] ; # R
; # (car Y)
  %269 = inttoptr i64 %267 to i64*
  %270 = load i64, i64* %269
; # (atom (car Y))
  %271 = and i64 %270, 15
  %272 = icmp ne i64 %271, 0
  br i1 %272, label %$56, label %$55
$56:
  %273 = phi i64 [%266, %$31] ; # X
  %274 = phi i64 [%267, %$31] ; # Y
  %275 = phi i64 [%268, %$31] ; # R
; # (let Z (cdr Y) (needChkVar Exe (setq Y @)) (let P (set $Bind (pus...
; # (cdr Y)
  %276 = inttoptr i64 %274 to i64*
  %277 = getelementptr i64, i64* %276, i32 1
  %278 = load i64, i64* %277
; # (needChkVar Exe (setq Y @))
  %279 = and i64 %270, 6
  %280 = icmp ne i64 %279, 0
  br i1 %280, label %$57, label %$58
$57:
  call void @varErr(i64 %0, i64 %270)
  unreachable
$58:
  %281 = icmp uge i64 %270, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %281, label %$60, label %$59
$60:
  %282 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %270
  br label %$59
$59:
  %283 = phi i1 [0, %$58], [%282, %$60] ; # ->
  br i1 %283, label %$61, label %$62
$61:
  call void @protErr(i64 %0, i64 %270)
  unreachable
$62:
; # (let P (set $Bind (push NIL NIL (val $Bind))) (set P (val Y) 2 P ...
; # (set $Bind (push NIL NIL (val $Bind)))
; # (val $Bind)
  %284 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %285 = load i64, i64* %284
; # (push NIL NIL (val $Bind))
  %286 = alloca i64, i64 3, align 16
  %287 = ptrtoint i64* %286 to i64
  %288 = add i64 %287, 16
  %289 = inttoptr i64 %288 to i64*
  store i64 %285, i64* %289
  %290 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %287, i64* %290
; # (set P (val Y) 2 P Y Y (eval (++ Z)))
; # (val Y)
  %291 = inttoptr i64 %270 to i64*
  %292 = load i64, i64* %291
  %293 = inttoptr i64 %287 to i64*
  store i64 %292, i64* %293
  %294 = inttoptr i64 %287 to i64*
  %295 = getelementptr i64, i64* %294, i32 1
  store i64 %270, i64* %295
; # (++ Z)
  %296 = inttoptr i64 %278 to i64*
  %297 = load i64, i64* %296
  %298 = getelementptr i64, i64* %296, i32 1
  %299 = load i64, i64* %298
; # (eval (++ Z))
  %300 = and i64 %297, 6
  %301 = icmp ne i64 %300, 0
  br i1 %301, label %$65, label %$64
$65:
  br label %$63
$64:
  %302 = and i64 %297, 8
  %303 = icmp ne i64 %302, 0
  br i1 %303, label %$67, label %$66
$67:
  %304 = inttoptr i64 %297 to i64*
  %305 = load i64, i64* %304
  br label %$63
$66:
  %306 = call i64 @evList(i64 %297)
  br label %$63
$63:
  %307 = phi i64 [%297, %$65], [%305, %$67], [%306, %$66] ; # ->
  %308 = inttoptr i64 %270 to i64*
  store i64 %307, i64* %308
; # (save R (loop (? (nil? (eval (car Z)))) (set $At @) (? (=0 (& (se...
  %309 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %310 = load i64, i64* %309
  %311 = alloca i64, i64 2, align 16
  %312 = ptrtoint i64* %311 to i64
  %313 = inttoptr i64 %312 to i64*
  store i64 %275, i64* %313
  %314 = add i64 %312, 8
  %315 = inttoptr i64 %314 to i64*
  store i64 %310, i64* %315
  %316 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %312, i64* %316
; # (loop (? (nil? (eval (car Z)))) (set $At @) (? (=0 (& (setq R (lo...
  br label %$68
$68:
  %317 = phi i64 [%273, %$63], [%382, %$78] ; # X
  %318 = phi i64 [%270, %$63], [%383, %$78] ; # Y
  %319 = phi i64 [%275, %$63], [%384, %$78] ; # R
  %320 = phi i64 [%299, %$63], [%385, %$78] ; # Z
; # (? (nil? (eval (car Z))))
; # (car Z)
  %321 = inttoptr i64 %320 to i64*
  %322 = load i64, i64* %321
; # (eval (car Z))
  %323 = and i64 %322, 6
  %324 = icmp ne i64 %323, 0
  br i1 %324, label %$71, label %$70
$71:
  br label %$69
$70:
  %325 = and i64 %322, 8
  %326 = icmp ne i64 %325, 0
  br i1 %326, label %$73, label %$72
$73:
  %327 = inttoptr i64 %322 to i64*
  %328 = load i64, i64* %327
  br label %$69
$72:
  %329 = call i64 @evList(i64 %322)
  br label %$69
$69:
  %330 = phi i64 [%322, %$71], [%328, %$73], [%329, %$72] ; # ->
; # (nil? (eval (car Z)))
  %331 = icmp eq i64 %330, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %331, label %$75, label %$74
$74:
  %332 = phi i64 [%317, %$69] ; # X
  %333 = phi i64 [%318, %$69] ; # Y
  %334 = phi i64 [%319, %$69] ; # R
  %335 = phi i64 [%320, %$69] ; # Z
; # (set $At @)
  %336 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %330, i64* %336
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %337 = call i64 @loop1(i64 %332)
; # (& (setq R (loop1 X)) 1)
  %338 = and i64 %337, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %339 = icmp eq i64 %338, 0
  br i1 %339, label %$75, label %$76
$76:
  %340 = phi i64 [%332, %$74] ; # X
  %341 = phi i64 [%333, %$74] ; # Y
  %342 = phi i64 [%337, %$74] ; # R
  %343 = phi i64 [%335, %$74] ; # Z
; # (& R -2)
  %344 = and i64 %342, -2
; # (safe (setq R (& R -2)))
  %345 = inttoptr i64 %312 to i64*
  store i64 %344, i64* %345
; # (when (pair (cdr Z)) (set Y (run @)))
; # (cdr Z)
  %346 = inttoptr i64 %343 to i64*
  %347 = getelementptr i64, i64* %346, i32 1
  %348 = load i64, i64* %347
; # (pair (cdr Z))
  %349 = and i64 %348, 15
  %350 = icmp eq i64 %349, 0
  br i1 %350, label %$77, label %$78
$77:
  %351 = phi i64 [%340, %$76] ; # X
  %352 = phi i64 [%341, %$76] ; # Y
  %353 = phi i64 [%344, %$76] ; # R
  %354 = phi i64 [%343, %$76] ; # Z
; # (set Y (run @))
; # (run @)
  br label %$79
$79:
  %355 = phi i64 [%348, %$77], [%377, %$88] ; # Prg
  %356 = inttoptr i64 %355 to i64*
  %357 = load i64, i64* %356
  %358 = getelementptr i64, i64* %356, i32 1
  %359 = load i64, i64* %358
  %360 = and i64 %359, 15
  %361 = icmp ne i64 %360, 0
  br i1 %361, label %$82, label %$80
$82:
  %362 = phi i64 [%359, %$79] ; # Prg
  %363 = and i64 %357, 6
  %364 = icmp ne i64 %363, 0
  br i1 %364, label %$85, label %$84
$85:
  br label %$83
$84:
  %365 = and i64 %357, 8
  %366 = icmp ne i64 %365, 0
  br i1 %366, label %$87, label %$86
$87:
  %367 = inttoptr i64 %357 to i64*
  %368 = load i64, i64* %367
  br label %$83
$86:
  %369 = call i64 @evList(i64 %357)
  br label %$83
$83:
  %370 = phi i64 [%357, %$85], [%368, %$87], [%369, %$86] ; # ->
  br label %$81
$80:
  %371 = phi i64 [%359, %$79] ; # Prg
  %372 = and i64 %357, 15
  %373 = icmp eq i64 %372, 0
  br i1 %373, label %$89, label %$88
$89:
  %374 = phi i64 [%371, %$80] ; # Prg
  %375 = call i64 @evList(i64 %357)
  %376 = icmp ne i64 %375, 0
  br label %$88
$88:
  %377 = phi i64 [%371, %$80], [%374, %$89] ; # Prg
  %378 = phi i1 [0, %$80], [%376, %$89] ; # ->
  br label %$79
$81:
  %379 = phi i64 [%362, %$83] ; # Prg
  %380 = phi i64 [%370, %$83] ; # ->
  %381 = inttoptr i64 %352 to i64*
  store i64 %380, i64* %381
  br label %$78
$78:
  %382 = phi i64 [%340, %$76], [%351, %$81] ; # X
  %383 = phi i64 [%341, %$76], [%352, %$81] ; # Y
  %384 = phi i64 [%344, %$76], [%353, %$81] ; # R
  %385 = phi i64 [%343, %$76], [%354, %$81] ; # Z
  br label %$68
$75:
  %386 = phi i64 [%317, %$69], [%332, %$74] ; # X
  %387 = phi i64 [%318, %$69], [%333, %$74] ; # Y
  %388 = phi i64 [%319, %$69], [%337, %$74] ; # R
  %389 = phi i64 [%320, %$69], [%335, %$74] ; # Z
  %390 = phi i64 [0, %$69], [0, %$74] ; # ->
; # drop
  %391 = inttoptr i64 %312 to i64*
  %392 = getelementptr i64, i64* %391, i32 1
  %393 = load i64, i64* %392
  %394 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %393, i64* %394
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %395 = inttoptr i64 %287 to i64*
  %396 = load i64, i64* %395
  %397 = inttoptr i64 %387 to i64*
  store i64 %396, i64* %397
; # (val 3 P)
  %398 = inttoptr i64 %287 to i64*
  %399 = getelementptr i64, i64* %398, i32 2
  %400 = load i64, i64* %399
  %401 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %400, i64* %401
  br label %$2
$55:
  %402 = phi i64 [%266, %$31] ; # X
  %403 = phi i64 [%267, %$31] ; # Y
  %404 = phi i64 [%268, %$31] ; # R
; # (let (Sym2 (cdr @) Z (cdr Y)) (setq Y (car @)) (needChkVar Exe Y)...
; # (cdr @)
  %405 = inttoptr i64 %270 to i64*
  %406 = getelementptr i64, i64* %405, i32 1
  %407 = load i64, i64* %406
; # (cdr Y)
  %408 = inttoptr i64 %403 to i64*
  %409 = getelementptr i64, i64* %408, i32 1
  %410 = load i64, i64* %409
; # (car @)
  %411 = inttoptr i64 %270 to i64*
  %412 = load i64, i64* %411
; # (needChkVar Exe Y)
  %413 = and i64 %412, 6
  %414 = icmp ne i64 %413, 0
  br i1 %414, label %$90, label %$91
$90:
  call void @varErr(i64 %0, i64 %412)
  unreachable
$91:
  %415 = icmp uge i64 %412, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %415, label %$93, label %$92
$93:
  %416 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %412
  br label %$92
$92:
  %417 = phi i1 [0, %$91], [%416, %$93] ; # ->
  br i1 %417, label %$94, label %$95
$94:
  call void @protErr(i64 %0, i64 %412)
  unreachable
$95:
; # (needChkVar Exe Sym2)
  %418 = and i64 %407, 6
  %419 = icmp ne i64 %418, 0
  br i1 %419, label %$96, label %$97
$96:
  call void @varErr(i64 %0, i64 %407)
  unreachable
$97:
  %420 = icmp uge i64 %407, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %420, label %$99, label %$98
$99:
  %421 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %407
  br label %$98
$98:
  %422 = phi i1 [0, %$97], [%421, %$99] ; # ->
  br i1 %422, label %$100, label %$101
$100:
  call void @protErr(i64 %0, i64 %407)
  unreachable
$101:
; # (let P (set $Bind (push NIL NIL (val $Bind))) (set P (val Y) 2 P ...
; # (set $Bind (push NIL NIL (val $Bind)))
; # (val $Bind)
  %423 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %424 = load i64, i64* %423
; # (push NIL NIL (val $Bind))
  %425 = alloca i64, i64 3, align 16
  %426 = ptrtoint i64* %425 to i64
  %427 = add i64 %426, 16
  %428 = inttoptr i64 %427 to i64*
  store i64 %424, i64* %428
  %429 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %426, i64* %429
; # (set P (val Y) 2 P Y)
; # (val Y)
  %430 = inttoptr i64 %412 to i64*
  %431 = load i64, i64* %430
  %432 = inttoptr i64 %426 to i64*
  store i64 %431, i64* %432
  %433 = inttoptr i64 %426 to i64*
  %434 = getelementptr i64, i64* %433, i32 1
  store i64 %412, i64* %434
; # (save R (let Q (set $Bind (push (val Sym2) Sym2 (val $Bind))) (se...
  %435 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %436 = load i64, i64* %435
  %437 = alloca i64, i64 2, align 16
  %438 = ptrtoint i64* %437 to i64
  %439 = inttoptr i64 %438 to i64*
  store i64 %404, i64* %439
  %440 = add i64 %438, 8
  %441 = inttoptr i64 %440 to i64*
  store i64 %436, i64* %441
  %442 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %438, i64* %442
; # (let Q (set $Bind (push (val Sym2) Sym2 (val $Bind))) (set Sym2 (...
; # (set $Bind (push (val Sym2) Sym2 (val $Bind)))
; # (val Sym2)
  %443 = inttoptr i64 %407 to i64*
  %444 = load i64, i64* %443
; # (val $Bind)
  %445 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %446 = load i64, i64* %445
; # (push (val Sym2) Sym2 (val $Bind))
  %447 = alloca i64, i64 3, align 16
  %448 = ptrtoint i64* %447 to i64
  %449 = inttoptr i64 %448 to i64*
  store i64 %444, i64* %449
  %450 = add i64 %448, 8
  %451 = inttoptr i64 %450 to i64*
  store i64 %407, i64* %451
  %452 = add i64 %448, 16
  %453 = inttoptr i64 %452 to i64*
  store i64 %446, i64* %453
  %454 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %448, i64* %454
; # (set Sym2 (save (eval (++ Z))) Y ONE)
; # (++ Z)
  %455 = inttoptr i64 %410 to i64*
  %456 = load i64, i64* %455
  %457 = getelementptr i64, i64* %455, i32 1
  %458 = load i64, i64* %457
; # (eval (++ Z))
  %459 = and i64 %456, 6
  %460 = icmp ne i64 %459, 0
  br i1 %460, label %$104, label %$103
$104:
  br label %$102
$103:
  %461 = and i64 %456, 8
  %462 = icmp ne i64 %461, 0
  br i1 %462, label %$106, label %$105
$106:
  %463 = inttoptr i64 %456 to i64*
  %464 = load i64, i64* %463
  br label %$102
$105:
  %465 = call i64 @evList(i64 %456)
  br label %$102
$102:
  %466 = phi i64 [%456, %$104], [%464, %$106], [%465, %$105] ; # ->
; # (save (eval (++ Z)))
  %467 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %468 = load i64, i64* %467
  %469 = alloca i64, i64 2, align 16
  %470 = ptrtoint i64* %469 to i64
  %471 = inttoptr i64 %470 to i64*
  store i64 %466, i64* %471
  %472 = add i64 %470, 8
  %473 = inttoptr i64 %472 to i64*
  store i64 %468, i64* %473
  %474 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %470, i64* %474
  %475 = inttoptr i64 %407 to i64*
  store i64 %466, i64* %475
  %476 = inttoptr i64 %412 to i64*
  store i64 18, i64* %476
; # (loop (? (nil? (eval (car Z)))) (set $At @) (? (=0 (& (setq R (lo...
  br label %$107
$107:
  %477 = phi i64 [%402, %$102], [%542, %$117] ; # X
  %478 = phi i64 [%412, %$102], [%543, %$117] ; # Y
  %479 = phi i64 [%404, %$102], [%544, %$117] ; # R
  %480 = phi i64 [%458, %$102], [%545, %$117] ; # Z
; # (? (nil? (eval (car Z))))
; # (car Z)
  %481 = inttoptr i64 %480 to i64*
  %482 = load i64, i64* %481
; # (eval (car Z))
  %483 = and i64 %482, 6
  %484 = icmp ne i64 %483, 0
  br i1 %484, label %$110, label %$109
$110:
  br label %$108
$109:
  %485 = and i64 %482, 8
  %486 = icmp ne i64 %485, 0
  br i1 %486, label %$112, label %$111
$112:
  %487 = inttoptr i64 %482 to i64*
  %488 = load i64, i64* %487
  br label %$108
$111:
  %489 = call i64 @evList(i64 %482)
  br label %$108
$108:
  %490 = phi i64 [%482, %$110], [%488, %$112], [%489, %$111] ; # ->
; # (nil? (eval (car Z)))
  %491 = icmp eq i64 %490, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %491, label %$114, label %$113
$113:
  %492 = phi i64 [%477, %$108] ; # X
  %493 = phi i64 [%478, %$108] ; # Y
  %494 = phi i64 [%479, %$108] ; # R
  %495 = phi i64 [%480, %$108] ; # Z
; # (set $At @)
  %496 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %490, i64* %496
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %497 = call i64 @loop1(i64 %492)
; # (& (setq R (loop1 X)) 1)
  %498 = and i64 %497, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %499 = icmp eq i64 %498, 0
  br i1 %499, label %$114, label %$115
$115:
  %500 = phi i64 [%492, %$113] ; # X
  %501 = phi i64 [%493, %$113] ; # Y
  %502 = phi i64 [%497, %$113] ; # R
  %503 = phi i64 [%495, %$113] ; # Z
; # (& R -2)
  %504 = and i64 %502, -2
; # (safe (setq R (& R -2)))
  %505 = inttoptr i64 %438 to i64*
  store i64 %504, i64* %505
; # (when (pair (cdr Z)) (set Sym2 (run @)))
; # (cdr Z)
  %506 = inttoptr i64 %503 to i64*
  %507 = getelementptr i64, i64* %506, i32 1
  %508 = load i64, i64* %507
; # (pair (cdr Z))
  %509 = and i64 %508, 15
  %510 = icmp eq i64 %509, 0
  br i1 %510, label %$116, label %$117
$116:
  %511 = phi i64 [%500, %$115] ; # X
  %512 = phi i64 [%501, %$115] ; # Y
  %513 = phi i64 [%504, %$115] ; # R
  %514 = phi i64 [%503, %$115] ; # Z
; # (set Sym2 (run @))
; # (run @)
  br label %$118
$118:
  %515 = phi i64 [%508, %$116], [%537, %$127] ; # Prg
  %516 = inttoptr i64 %515 to i64*
  %517 = load i64, i64* %516
  %518 = getelementptr i64, i64* %516, i32 1
  %519 = load i64, i64* %518
  %520 = and i64 %519, 15
  %521 = icmp ne i64 %520, 0
  br i1 %521, label %$121, label %$119
$121:
  %522 = phi i64 [%519, %$118] ; # Prg
  %523 = and i64 %517, 6
  %524 = icmp ne i64 %523, 0
  br i1 %524, label %$124, label %$123
$124:
  br label %$122
$123:
  %525 = and i64 %517, 8
  %526 = icmp ne i64 %525, 0
  br i1 %526, label %$126, label %$125
$126:
  %527 = inttoptr i64 %517 to i64*
  %528 = load i64, i64* %527
  br label %$122
$125:
  %529 = call i64 @evList(i64 %517)
  br label %$122
$122:
  %530 = phi i64 [%517, %$124], [%528, %$126], [%529, %$125] ; # ->
  br label %$120
$119:
  %531 = phi i64 [%519, %$118] ; # Prg
  %532 = and i64 %517, 15
  %533 = icmp eq i64 %532, 0
  br i1 %533, label %$128, label %$127
$128:
  %534 = phi i64 [%531, %$119] ; # Prg
  %535 = call i64 @evList(i64 %517)
  %536 = icmp ne i64 %535, 0
  br label %$127
$127:
  %537 = phi i64 [%531, %$119], [%534, %$128] ; # Prg
  %538 = phi i1 [0, %$119], [%536, %$128] ; # ->
  br label %$118
$120:
  %539 = phi i64 [%522, %$122] ; # Prg
  %540 = phi i64 [%530, %$122] ; # ->
  %541 = inttoptr i64 %407 to i64*
  store i64 %540, i64* %541
  br label %$117
$117:
  %542 = phi i64 [%500, %$115], [%511, %$120] ; # X
  %543 = phi i64 [%501, %$115], [%512, %$120] ; # Y
  %544 = phi i64 [%504, %$115], [%513, %$120] ; # R
  %545 = phi i64 [%503, %$115], [%514, %$120] ; # Z
; # (set Y (+ (val Y) (hex "10")))
; # (val Y)
  %546 = inttoptr i64 %543 to i64*
  %547 = load i64, i64* %546
; # (+ (val Y) (hex "10"))
  %548 = add i64 %547, 16
  %549 = inttoptr i64 %543 to i64*
  store i64 %548, i64* %549
  br label %$107
$114:
  %550 = phi i64 [%477, %$108], [%492, %$113] ; # X
  %551 = phi i64 [%478, %$108], [%493, %$113] ; # Y
  %552 = phi i64 [%479, %$108], [%497, %$113] ; # R
  %553 = phi i64 [%480, %$108], [%495, %$113] ; # Z
  %554 = phi i64 [0, %$108], [0, %$113] ; # ->
; # (set Sym2 (val Q))
; # (val Q)
  %555 = inttoptr i64 %448 to i64*
  %556 = load i64, i64* %555
  %557 = inttoptr i64 %407 to i64*
  store i64 %556, i64* %557
; # drop
  %558 = inttoptr i64 %438 to i64*
  %559 = getelementptr i64, i64* %558, i32 1
  %560 = load i64, i64* %559
  %561 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %560, i64* %561
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %562 = inttoptr i64 %426 to i64*
  %563 = load i64, i64* %562
  %564 = inttoptr i64 %551 to i64*
  store i64 %563, i64* %564
; # (val 3 P)
  %565 = inttoptr i64 %426 to i64*
  %566 = getelementptr i64, i64* %565, i32 2
  %567 = load i64, i64* %566
  %568 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %567, i64* %568
  br label %$2
$2:
  %569 = phi i64 [%137, %$18], [%247, %$52], [%386, %$75], [%550, %$114] ; # X
  %570 = phi i64 [%138, %$18], [%248, %$52], [%387, %$75], [%551, %$114] ; # Y
  %571 = phi i64 [%139, %$18], [%249, %$52], [%388, %$75], [%552, %$114] ; # R
  %572 = phi i64 [%146, %$18], [%264, %$52], [%400, %$75], [%567, %$114] ; # ->
  ret i64 %571
}

define i64 @_with(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (needVar Exe (eval (++ X)))) (if (nil? Y) Y (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
; # (if (nil? Y) Y (let P (set $Bind (push (val $This) $This (val $Bi...
; # (nil? Y)
  %18 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let P (set $Bind (push (val $This) $This (val $Bind))) (set $Thi...
; # (set $Bind (push (val $This) $This (val $Bind)))
; # (val $This)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %20 = load i64, i64* %19
; # (val $Bind)
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %22 = load i64, i64* %21
; # (push (val $This) $This (val $Bind))
  %23 = alloca i64, i64 3, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64), i64* %27
  %28 = add i64 %24, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 %22, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %24, i64* %30
; # (set $This Y)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  store i64 %15, i64* %31
; # (prog1 (run X) (set $This (val P) $Bind (val 3 P)))
; # (run X)
  br label %$12
$12:
  %32 = phi i64 [%7, %$10], [%54, %$21] ; # Prg
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = getelementptr i64, i64* %33, i32 1
  %36 = load i64, i64* %35
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$13
$15:
  %39 = phi i64 [%36, %$12] ; # Prg
  %40 = and i64 %34, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$18, label %$17
$18:
  br label %$16
$17:
  %42 = and i64 %34, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$20, label %$19
$20:
  %44 = inttoptr i64 %34 to i64*
  %45 = load i64, i64* %44
  br label %$16
$19:
  %46 = call i64 @evList(i64 %34)
  br label %$16
$16:
  %47 = phi i64 [%34, %$18], [%45, %$20], [%46, %$19] ; # ->
  br label %$14
$13:
  %48 = phi i64 [%36, %$12] ; # Prg
  %49 = and i64 %34, 15
  %50 = icmp eq i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  %51 = phi i64 [%48, %$13] ; # Prg
  %52 = call i64 @evList(i64 %34)
  %53 = icmp ne i64 %52, 0
  br label %$21
$21:
  %54 = phi i64 [%48, %$13], [%51, %$22] ; # Prg
  %55 = phi i1 [0, %$13], [%53, %$22] ; # ->
  br label %$12
$14:
  %56 = phi i64 [%39, %$16] ; # Prg
  %57 = phi i64 [%47, %$16] ; # ->
; # (set $This (val P) $Bind (val 3 P))
; # (val P)
  %58 = inttoptr i64 %24 to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  store i64 %59, i64* %60
; # (val 3 P)
  %61 = inttoptr i64 %24 to i64*
  %62 = getelementptr i64, i64* %61, i32 2
  %63 = load i64, i64* %62
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %63, i64* %64
  br label %$11
$11:
  %65 = phi i64 [%15, %$9], [%57, %$14] ; # ->
  ret i64 %65
}

define i64 @_bind(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((num? Y) (argErr Exe Y)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((num? Y) (argErr Exe Y)) ((nil? Y) (run X)) ((sym? Y) (chk...
; # (num? Y)
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = phi i64 [%15, %$2] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %18)
  unreachable
$8:
  %19 = phi i64 [%15, %$2] ; # Y
; # (nil? Y)
  %20 = icmp eq i64 %19, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %20, label %$11, label %$10
$11:
  %21 = phi i64 [%19, %$8] ; # Y
; # (run X)
  br label %$12
$12:
  %22 = phi i64 [%7, %$11], [%44, %$21] ; # Prg
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
  %25 = getelementptr i64, i64* %23, i32 1
  %26 = load i64, i64* %25
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$13
$15:
  %29 = phi i64 [%26, %$12] ; # Prg
  %30 = and i64 %24, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$18, label %$17
$18:
  br label %$16
$17:
  %32 = and i64 %24, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$20, label %$19
$20:
  %34 = inttoptr i64 %24 to i64*
  %35 = load i64, i64* %34
  br label %$16
$19:
  %36 = call i64 @evList(i64 %24)
  br label %$16
$16:
  %37 = phi i64 [%24, %$18], [%35, %$20], [%36, %$19] ; # ->
  br label %$14
$13:
  %38 = phi i64 [%26, %$12] ; # Prg
  %39 = and i64 %24, 15
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %$22, label %$21
$22:
  %41 = phi i64 [%38, %$13] ; # Prg
  %42 = call i64 @evList(i64 %24)
  %43 = icmp ne i64 %42, 0
  br label %$21
$21:
  %44 = phi i64 [%38, %$13], [%41, %$22] ; # Prg
  %45 = phi i1 [0, %$13], [%43, %$22] ; # ->
  br label %$12
$14:
  %46 = phi i64 [%29, %$16] ; # Prg
  %47 = phi i64 [%37, %$16] ; # ->
  br label %$7
$10:
  %48 = phi i64 [%19, %$8] ; # Y
; # (sym? Y)
  %49 = and i64 %48, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$24, label %$23
$24:
  %51 = phi i64 [%48, %$10] ; # Y
; # (chkVar Exe Y)
  %52 = icmp uge i64 %51, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %52, label %$26, label %$25
$26:
  %53 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %51
  br label %$25
$25:
  %54 = phi i1 [0, %$24], [%53, %$26] ; # ->
  br i1 %54, label %$27, label %$28
$27:
  call void @protErr(i64 %0, i64 %51)
  unreachable
$28:
; # (let P (set $Bind (push (val Y) Y (val $Bind))) (prog1 (run X) (s...
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %55 = inttoptr i64 %51 to i64*
  %56 = load i64, i64* %55
; # (val $Bind)
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %58 = load i64, i64* %57
; # (push (val Y) Y (val $Bind))
  %59 = alloca i64, i64 3, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = inttoptr i64 %60 to i64*
  store i64 %56, i64* %61
  %62 = add i64 %60, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 %51, i64* %63
  %64 = add i64 %60, 16
  %65 = inttoptr i64 %64 to i64*
  store i64 %58, i64* %65
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %60, i64* %66
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$29
$29:
  %67 = phi i64 [%7, %$28], [%89, %$38] ; # Prg
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
  %70 = getelementptr i64, i64* %68, i32 1
  %71 = load i64, i64* %70
  %72 = and i64 %71, 15
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$32, label %$30
$32:
  %74 = phi i64 [%71, %$29] ; # Prg
  %75 = and i64 %69, 6
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$35, label %$34
$35:
  br label %$33
$34:
  %77 = and i64 %69, 8
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %$37, label %$36
$37:
  %79 = inttoptr i64 %69 to i64*
  %80 = load i64, i64* %79
  br label %$33
$36:
  %81 = call i64 @evList(i64 %69)
  br label %$33
$33:
  %82 = phi i64 [%69, %$35], [%80, %$37], [%81, %$36] ; # ->
  br label %$31
$30:
  %83 = phi i64 [%71, %$29] ; # Prg
  %84 = and i64 %69, 15
  %85 = icmp eq i64 %84, 0
  br i1 %85, label %$39, label %$38
$39:
  %86 = phi i64 [%83, %$30] ; # Prg
  %87 = call i64 @evList(i64 %69)
  %88 = icmp ne i64 %87, 0
  br label %$38
$38:
  %89 = phi i64 [%83, %$30], [%86, %$39] ; # Prg
  %90 = phi i1 [0, %$30], [%88, %$39] ; # ->
  br label %$29
$31:
  %91 = phi i64 [%74, %$33] ; # Prg
  %92 = phi i64 [%82, %$33] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %93 = inttoptr i64 %60 to i64*
  %94 = load i64, i64* %93
  %95 = inttoptr i64 %51 to i64*
  store i64 %94, i64* %95
; # (val 3 P)
  %96 = inttoptr i64 %60 to i64*
  %97 = getelementptr i64, i64* %96, i32 2
  %98 = load i64, i64* %97
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %98, i64* %99
  br label %$7
$23:
  %100 = phi i64 [%48, %$10] ; # Y
; # (let (P (val $Bind) Q P) (loop (let Z (++ Y) (when (num? Z) (argE...
; # (val $Bind)
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %102 = load i64, i64* %101
; # (loop (let Z (++ Y) (when (num? Z) (argErr Exe Y)) (if (sym? Z) (...
  br label %$40
$40:
  %103 = phi i64 [%100, %$23], [%160, %$56] ; # Y
  %104 = phi i64 [%102, %$23], [%161, %$56] ; # P
; # (let Z (++ Y) (when (num? Z) (argErr Exe Y)) (if (sym? Z) (set $B...
; # (++ Y)
  %105 = inttoptr i64 %103 to i64*
  %106 = load i64, i64* %105
  %107 = getelementptr i64, i64* %105, i32 1
  %108 = load i64, i64* %107
; # (when (num? Z) (argErr Exe Y))
; # (num? Z)
  %109 = and i64 %106, 6
  %110 = icmp ne i64 %109, 0
  br i1 %110, label %$41, label %$42
$41:
  %111 = phi i64 [%108, %$40] ; # Y
  %112 = phi i64 [%104, %$40] ; # P
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %111)
  unreachable
$42:
  %113 = phi i64 [%108, %$40] ; # Y
  %114 = phi i64 [%104, %$40] ; # P
; # (if (sym? Z) (set $Bind (setq P (push (val Z) (chkVar Exe Z) P)))...
; # (sym? Z)
  %115 = and i64 %106, 8
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$43, label %$44
$43:
  %117 = phi i64 [%113, %$42] ; # Y
  %118 = phi i64 [%114, %$42] ; # P
; # (set $Bind (setq P (push (val Z) (chkVar Exe Z) P)))
; # (val Z)
  %119 = inttoptr i64 %106 to i64*
  %120 = load i64, i64* %119
; # (chkVar Exe Z)
  %121 = icmp uge i64 %106, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %121, label %$47, label %$46
$47:
  %122 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %106
  br label %$46
$46:
  %123 = phi i1 [0, %$43], [%122, %$47] ; # ->
  br i1 %123, label %$48, label %$49
$48:
  call void @protErr(i64 %0, i64 %106)
  unreachable
$49:
; # (push (val Z) (chkVar Exe Z) P)
  %124 = alloca i64, i64 3, align 16
  %125 = ptrtoint i64* %124 to i64
  %126 = inttoptr i64 %125 to i64*
  store i64 %120, i64* %126
  %127 = add i64 %125, 8
  %128 = inttoptr i64 %127 to i64*
  store i64 %106, i64* %128
  %129 = add i64 %125, 16
  %130 = inttoptr i64 %129 to i64*
  store i64 %118, i64* %130
  %131 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %125, i64* %131
  br label %$45
$44:
  %132 = phi i64 [%113, %$42] ; # Y
  %133 = phi i64 [%114, %$42] ; # P
; # (let S (car Z) (needChkVar Exe S) (set $Bind (setq P (push (val S...
; # (car Z)
  %134 = inttoptr i64 %106 to i64*
  %135 = load i64, i64* %134
; # (needChkVar Exe S)
  %136 = and i64 %135, 6
  %137 = icmp ne i64 %136, 0
  br i1 %137, label %$50, label %$51
$50:
  call void @varErr(i64 %0, i64 %135)
  unreachable
$51:
  %138 = icmp uge i64 %135, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %138, label %$53, label %$52
$53:
  %139 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %135
  br label %$52
$52:
  %140 = phi i1 [0, %$51], [%139, %$53] ; # ->
  br i1 %140, label %$54, label %$55
$54:
  call void @protErr(i64 %0, i64 %135)
  unreachable
$55:
; # (set $Bind (setq P (push (val S) S P)) S (cdr Z))
; # (val S)
  %141 = inttoptr i64 %135 to i64*
  %142 = load i64, i64* %141
; # (push (val S) S P)
  %143 = alloca i64, i64 3, align 16
  %144 = ptrtoint i64* %143 to i64
  %145 = inttoptr i64 %144 to i64*
  store i64 %142, i64* %145
  %146 = add i64 %144, 8
  %147 = inttoptr i64 %146 to i64*
  store i64 %135, i64* %147
  %148 = add i64 %144, 16
  %149 = inttoptr i64 %148 to i64*
  store i64 %133, i64* %149
  %150 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %144, i64* %150
; # (cdr Z)
  %151 = inttoptr i64 %106 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  %154 = inttoptr i64 %135 to i64*
  store i64 %153, i64* %154
  br label %$45
$45:
  %155 = phi i64 [%117, %$49], [%132, %$55] ; # Y
  %156 = phi i64 [%125, %$49], [%144, %$55] ; # P
  %157 = phi i64 [%125, %$49], [%153, %$55] ; # ->
; # (? (atom Y))
; # (atom Y)
  %158 = and i64 %155, 15
  %159 = icmp ne i64 %158, 0
  br i1 %159, label %$57, label %$56
$56:
  %160 = phi i64 [%155, %$45] ; # Y
  %161 = phi i64 [%156, %$45] ; # P
  br label %$40
$57:
  %162 = phi i64 [%155, %$45] ; # Y
  %163 = phi i64 [%156, %$45] ; # P
  %164 = phi i64 [0, %$45] ; # ->
; # (prog1 (run X) (loop (set (val 2 P) (val P)) (? (== Q (setq P (va...
; # (run X)
  br label %$58
$58:
  %165 = phi i64 [%7, %$57], [%187, %$67] ; # Prg
  %166 = inttoptr i64 %165 to i64*
  %167 = load i64, i64* %166
  %168 = getelementptr i64, i64* %166, i32 1
  %169 = load i64, i64* %168
  %170 = and i64 %169, 15
  %171 = icmp ne i64 %170, 0
  br i1 %171, label %$61, label %$59
$61:
  %172 = phi i64 [%169, %$58] ; # Prg
  %173 = and i64 %167, 6
  %174 = icmp ne i64 %173, 0
  br i1 %174, label %$64, label %$63
$64:
  br label %$62
$63:
  %175 = and i64 %167, 8
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$66, label %$65
$66:
  %177 = inttoptr i64 %167 to i64*
  %178 = load i64, i64* %177
  br label %$62
$65:
  %179 = call i64 @evList(i64 %167)
  br label %$62
$62:
  %180 = phi i64 [%167, %$64], [%178, %$66], [%179, %$65] ; # ->
  br label %$60
$59:
  %181 = phi i64 [%169, %$58] ; # Prg
  %182 = and i64 %167, 15
  %183 = icmp eq i64 %182, 0
  br i1 %183, label %$68, label %$67
$68:
  %184 = phi i64 [%181, %$59] ; # Prg
  %185 = call i64 @evList(i64 %167)
  %186 = icmp ne i64 %185, 0
  br label %$67
$67:
  %187 = phi i64 [%181, %$59], [%184, %$68] ; # Prg
  %188 = phi i1 [0, %$59], [%186, %$68] ; # ->
  br label %$58
$60:
  %189 = phi i64 [%172, %$62] ; # Prg
  %190 = phi i64 [%180, %$62] ; # ->
; # (loop (set (val 2 P) (val P)) (? (== Q (setq P (val 3 P)))))
  br label %$69
$69:
  %191 = phi i64 [%162, %$60], [%203, %$70] ; # Y
  %192 = phi i64 [%163, %$60], [%204, %$70] ; # P
; # (set (val 2 P) (val P))
; # (val 2 P)
  %193 = inttoptr i64 %192 to i64*
  %194 = getelementptr i64, i64* %193, i32 1
  %195 = load i64, i64* %194
; # (val P)
  %196 = inttoptr i64 %192 to i64*
  %197 = load i64, i64* %196
  %198 = inttoptr i64 %195 to i64*
  store i64 %197, i64* %198
; # (? (== Q (setq P (val 3 P))))
; # (val 3 P)
  %199 = inttoptr i64 %192 to i64*
  %200 = getelementptr i64, i64* %199, i32 2
  %201 = load i64, i64* %200
; # (== Q (setq P (val 3 P)))
  %202 = icmp eq i64 %102, %201
  br i1 %202, label %$71, label %$70
$70:
  %203 = phi i64 [%191, %$69] ; # Y
  %204 = phi i64 [%201, %$69] ; # P
  br label %$69
$71:
  %205 = phi i64 [%191, %$69] ; # Y
  %206 = phi i64 [%201, %$69] ; # P
  %207 = phi i64 [0, %$69] ; # ->
; # (set $Bind P)
  %208 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %206, i64* %208
  br label %$7
$7:
  %209 = phi i64 [%21, %$14], [%51, %$31], [%205, %$71] ; # Y
  %210 = phi i64 [%47, %$14], [%92, %$31], [%190, %$71] ; # ->
  ret i64 %210
}

define i64 @_job(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) P (val $Bind) Q P) (whil...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (val $Bind)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %25 = load i64, i64* %24
; # (while (pair Y) (let (Z (++ Y) S (car Z)) (needChkVar Exe S) (set...
  br label %$7
$7:
  %26 = phi i64 [%15, %$2], [%35, %$15] ; # Y
  %27 = phi i64 [%25, %$2], [%46, %$15] ; # P
; # (pair Y)
  %28 = and i64 %26, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%26, %$7] ; # Y
  %31 = phi i64 [%27, %$7] ; # P
; # (let (Z (++ Y) S (car Z)) (needChkVar Exe S) (set $Bind (setq P (...
; # (++ Y)
  %32 = inttoptr i64 %30 to i64*
  %33 = load i64, i64* %32
  %34 = getelementptr i64, i64* %32, i32 1
  %35 = load i64, i64* %34
; # (car Z)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (needChkVar Exe S)
  %38 = and i64 %37, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$10, label %$11
$10:
  call void @varErr(i64 %0, i64 %37)
  unreachable
$11:
  %40 = icmp uge i64 %37, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %40, label %$13, label %$12
$13:
  %41 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %37
  br label %$12
$12:
  %42 = phi i1 [0, %$11], [%41, %$13] ; # ->
  br i1 %42, label %$14, label %$15
$14:
  call void @protErr(i64 %0, i64 %37)
  unreachable
$15:
; # (set $Bind (setq P (push (val S) S P Z)) S (cdr Z))
; # (val S)
  %43 = inttoptr i64 %37 to i64*
  %44 = load i64, i64* %43
; # (push (val S) S P Z)
  %45 = alloca i64, i64 4, align 16
  %46 = ptrtoint i64* %45 to i64
  %47 = inttoptr i64 %46 to i64*
  store i64 %44, i64* %47
  %48 = add i64 %46, 8
  %49 = inttoptr i64 %48 to i64*
  store i64 %37, i64* %49
  %50 = add i64 %46, 16
  %51 = inttoptr i64 %50 to i64*
  store i64 %31, i64* %51
  %52 = add i64 %46, 24
  %53 = inttoptr i64 %52 to i64*
  store i64 %33, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %46, i64* %54
; # (cdr Z)
  %55 = inttoptr i64 %33 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
  %58 = inttoptr i64 %37 to i64*
  store i64 %57, i64* %58
  br label %$7
$9:
  %59 = phi i64 [%26, %$7] ; # Y
  %60 = phi i64 [%27, %$7] ; # P
; # (prog1 (run X) (until (== Q P) (let S (val 2 P) (set 2 (val 4 P) ...
; # (run X)
  br label %$16
$16:
  %61 = phi i64 [%7, %$9], [%83, %$25] ; # Prg
  %62 = inttoptr i64 %61 to i64*
  %63 = load i64, i64* %62
  %64 = getelementptr i64, i64* %62, i32 1
  %65 = load i64, i64* %64
  %66 = and i64 %65, 15
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$19, label %$17
$19:
  %68 = phi i64 [%65, %$16] ; # Prg
  %69 = and i64 %63, 6
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$22, label %$21
$22:
  br label %$20
$21:
  %71 = and i64 %63, 8
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$24, label %$23
$24:
  %73 = inttoptr i64 %63 to i64*
  %74 = load i64, i64* %73
  br label %$20
$23:
  %75 = call i64 @evList(i64 %63)
  br label %$20
$20:
  %76 = phi i64 [%63, %$22], [%74, %$24], [%75, %$23] ; # ->
  br label %$18
$17:
  %77 = phi i64 [%65, %$16] ; # Prg
  %78 = and i64 %63, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$26, label %$25
$26:
  %80 = phi i64 [%77, %$17] ; # Prg
  %81 = call i64 @evList(i64 %63)
  %82 = icmp ne i64 %81, 0
  br label %$25
$25:
  %83 = phi i64 [%77, %$17], [%80, %$26] ; # Prg
  %84 = phi i1 [0, %$17], [%82, %$26] ; # ->
  br label %$16
$18:
  %85 = phi i64 [%68, %$20] ; # Prg
  %86 = phi i64 [%76, %$20] ; # ->
; # (until (== Q P) (let S (val 2 P) (set 2 (val 4 P) (val S)) (set S...
  br label %$27
$27:
  %87 = phi i64 [%59, %$18], [%90, %$28] ; # Y
  %88 = phi i64 [%60, %$18], [%107, %$28] ; # P
; # (== Q P)
  %89 = icmp eq i64 %25, %88
  br i1 %89, label %$29, label %$28
$28:
  %90 = phi i64 [%87, %$27] ; # Y
  %91 = phi i64 [%88, %$27] ; # P
; # (let S (val 2 P) (set 2 (val 4 P) (val S)) (set S (val P)))
; # (val 2 P)
  %92 = inttoptr i64 %91 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
; # (set 2 (val 4 P) (val S))
; # (val 4 P)
  %95 = inttoptr i64 %91 to i64*
  %96 = getelementptr i64, i64* %95, i32 3
  %97 = load i64, i64* %96
; # (val S)
  %98 = inttoptr i64 %94 to i64*
  %99 = load i64, i64* %98
  %100 = inttoptr i64 %97 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  store i64 %99, i64* %101
; # (set S (val P))
; # (val P)
  %102 = inttoptr i64 %91 to i64*
  %103 = load i64, i64* %102
  %104 = inttoptr i64 %94 to i64*
  store i64 %103, i64* %104
; # (val 3 P)
  %105 = inttoptr i64 %91 to i64*
  %106 = getelementptr i64, i64* %105, i32 2
  %107 = load i64, i64* %106
  br label %$27
$29:
  %108 = phi i64 [%87, %$27] ; # Y
  %109 = phi i64 [%88, %$27] ; # P
; # (set $Bind P)
  %110 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %109, i64* %110
; # (drop *Safe)
  %111 = inttoptr i64 %19 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  %113 = load i64, i64* %112
  %114 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %113, i64* %114
  ret i64 %86
}

define void @setDestruct(i64, i64) align 8 {
$1:
; # (loop (when (atom Val) (setq Val $Nil)) (let (P (++ Pat) V (++ Va...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%42, %$10] ; # Pat
  %3 = phi i64 [%1, %$1], [%43, %$10] ; # Val
; # (when (atom Val) (setq Val $Nil))
; # (atom Val)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$3, label %$4
$3:
  %6 = phi i64 [%2, %$2] ; # Pat
  %7 = phi i64 [%3, %$2] ; # Val
  br label %$4
$4:
  %8 = phi i64 [%2, %$2], [%6, %$3] ; # Pat
  %9 = phi i64 [%3, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # Val
; # (let (P (++ Pat) V (++ Val)) (if (atom P) (unless (nil? P) (set P...
; # (++ Pat)
  %10 = inttoptr i64 %8 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (++ Val)
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
; # (if (atom P) (unless (nil? P) (set P V)) (setDestruct P V))
; # (atom P)
  %18 = and i64 %11, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$5, label %$6
$5:
  %20 = phi i64 [%13, %$4] ; # Pat
  %21 = phi i64 [%17, %$4] ; # Val
; # (unless (nil? P) (set P V))
; # (nil? P)
  %22 = icmp eq i64 %11, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %22, label %$9, label %$8
$8:
  %23 = phi i64 [%20, %$5] ; # Pat
  %24 = phi i64 [%21, %$5] ; # Val
; # (set P V)
  %25 = inttoptr i64 %11 to i64*
  store i64 %15, i64* %25
  br label %$9
$9:
  %26 = phi i64 [%20, %$5], [%23, %$8] ; # Pat
  %27 = phi i64 [%21, %$5], [%24, %$8] ; # Val
  br label %$7
$6:
  %28 = phi i64 [%13, %$4] ; # Pat
  %29 = phi i64 [%17, %$4] ; # Val
; # (setDestruct P V)
  call void @setDestruct(i64 %11, i64 %15)
  br label %$7
$7:
  %30 = phi i64 [%26, %$9], [%28, %$6] ; # Pat
  %31 = phi i64 [%27, %$9], [%29, %$6] ; # Val
; # (? (atom Pat) (unless (nil? Pat) (set Pat Val)))
; # (atom Pat)
  %32 = and i64 %30, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$10
$12:
  %34 = phi i64 [%30, %$7] ; # Pat
  %35 = phi i64 [%31, %$7] ; # Val
; # (unless (nil? Pat) (set Pat Val))
; # (nil? Pat)
  %36 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %36, label %$14, label %$13
$13:
  %37 = phi i64 [%34, %$12] ; # Pat
  %38 = phi i64 [%35, %$12] ; # Val
; # (set Pat Val)
  %39 = inttoptr i64 %37 to i64*
  store i64 %38, i64* %39
  br label %$14
$14:
  %40 = phi i64 [%34, %$12], [%37, %$13] ; # Pat
  %41 = phi i64 [%35, %$12], [%38, %$13] ; # Val
  br label %$11
$10:
  %42 = phi i64 [%30, %$7] ; # Pat
  %43 = phi i64 [%31, %$7] ; # Val
  br label %$2
$11:
  %44 = phi i64 [%40, %$14] ; # Pat
  %45 = phi i64 [%41, %$14] ; # Val
  ret void
}

define i64 @_let(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (++ X)) (if (atom Y) (let P (set $Bind (push ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (if (atom Y) (let P (set $Bind (push (val (needChkVar Exe Y)) Y (...
; # (atom Y)
  %8 = and i64 %5, 15
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  %10 = phi i64 [%7, %$1] ; # X
  %11 = phi i64 [%5, %$1] ; # Y
; # (let P (set $Bind (push (val (needChkVar Exe Y)) Y (val $Bind))) ...
; # (set $Bind (push (val (needChkVar Exe Y)) Y (val $Bind)))
; # (needChkVar Exe Y)
  %12 = and i64 %11, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$5, label %$6
$5:
  call void @varErr(i64 %0, i64 %11)
  unreachable
$6:
  %14 = icmp uge i64 %11, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$8, label %$7
$8:
  %15 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %11
  br label %$7
$7:
  %16 = phi i1 [0, %$6], [%15, %$8] ; # ->
  br i1 %16, label %$9, label %$10
$9:
  call void @protErr(i64 %0, i64 %11)
  unreachable
$10:
; # (val (needChkVar Exe Y))
  %17 = inttoptr i64 %11 to i64*
  %18 = load i64, i64* %17
; # (val $Bind)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %20 = load i64, i64* %19
; # (push (val (needChkVar Exe Y)) Y (val $Bind))
  %21 = alloca i64, i64 3, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %11, i64* %25
  %26 = add i64 %22, 16
  %27 = inttoptr i64 %26 to i64*
  store i64 %20, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %22, i64* %28
; # (set Y (eval (++ X)))
; # (++ X)
  %29 = inttoptr i64 %10 to i64*
  %30 = load i64, i64* %29
  %31 = getelementptr i64, i64* %29, i32 1
  %32 = load i64, i64* %31
; # (eval (++ X))
  %33 = and i64 %30, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$12
$13:
  br label %$11
$12:
  %35 = and i64 %30, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$14
$15:
  %37 = inttoptr i64 %30 to i64*
  %38 = load i64, i64* %37
  br label %$11
$14:
  %39 = call i64 @evList(i64 %30)
  br label %$11
$11:
  %40 = phi i64 [%30, %$13], [%38, %$15], [%39, %$14] ; # ->
  %41 = inttoptr i64 %11 to i64*
  store i64 %40, i64* %41
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$16
$16:
  %42 = phi i64 [%32, %$11], [%64, %$25] ; # Prg
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
  %47 = and i64 %46, 15
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$19, label %$17
$19:
  %49 = phi i64 [%46, %$16] ; # Prg
  %50 = and i64 %44, 6
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$22, label %$21
$22:
  br label %$20
$21:
  %52 = and i64 %44, 8
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$24, label %$23
$24:
  %54 = inttoptr i64 %44 to i64*
  %55 = load i64, i64* %54
  br label %$20
$23:
  %56 = call i64 @evList(i64 %44)
  br label %$20
$20:
  %57 = phi i64 [%44, %$22], [%55, %$24], [%56, %$23] ; # ->
  br label %$18
$17:
  %58 = phi i64 [%46, %$16] ; # Prg
  %59 = and i64 %44, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$26, label %$25
$26:
  %61 = phi i64 [%58, %$17] ; # Prg
  %62 = call i64 @evList(i64 %44)
  %63 = icmp ne i64 %62, 0
  br label %$25
$25:
  %64 = phi i64 [%58, %$17], [%61, %$26] ; # Prg
  %65 = phi i1 [0, %$17], [%63, %$26] ; # ->
  br label %$16
$18:
  %66 = phi i64 [%49, %$20] ; # Prg
  %67 = phi i64 [%57, %$20] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %68 = inttoptr i64 %22 to i64*
  %69 = load i64, i64* %68
  %70 = inttoptr i64 %11 to i64*
  store i64 %69, i64* %70
; # (val 3 P)
  %71 = inttoptr i64 %22 to i64*
  %72 = getelementptr i64, i64* %71, i32 2
  %73 = load i64, i64* %72
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %73, i64* %74
  br label %$4
$3:
  %75 = phi i64 [%7, %$1] ; # X
  %76 = phi i64 [%5, %$1] ; # Y
; # (let (P (val $Bind) Q P) (loop (let Z (++ Y) (if (atom Z) (set $B...
; # (val $Bind)
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %78 = load i64, i64* %77
; # (loop (let Z (++ Y) (if (atom Z) (set $Bind (setq P (push (val (n...
  br label %$27
$27:
  %79 = phi i64 [%75, %$3], [%296, %$78] ; # X
  %80 = phi i64 [%76, %$3], [%297, %$78] ; # Y
  %81 = phi i64 [%78, %$3], [%298, %$78] ; # P
; # (let Z (++ Y) (if (atom Z) (set $Bind (setq P (push (val (needChk...
; # (++ Y)
  %82 = inttoptr i64 %80 to i64*
  %83 = load i64, i64* %82
  %84 = getelementptr i64, i64* %82, i32 1
  %85 = load i64, i64* %84
; # (if (atom Z) (set $Bind (setq P (push (val (needChkVar Exe Z)) Z ...
; # (atom Z)
  %86 = and i64 %83, 15
  %87 = icmp ne i64 %86, 0
  br i1 %87, label %$28, label %$29
$28:
  %88 = phi i64 [%79, %$27] ; # X
  %89 = phi i64 [%85, %$27] ; # Y
  %90 = phi i64 [%81, %$27] ; # P
  %91 = phi i64 [%83, %$27] ; # Z
; # (set $Bind (setq P (push (val (needChkVar Exe Z)) Z P)) Z (eval (...
; # (needChkVar Exe Z)
  %92 = and i64 %91, 6
  %93 = icmp ne i64 %92, 0
  br i1 %93, label %$31, label %$32
$31:
  call void @varErr(i64 %0, i64 %91)
  unreachable
$32:
  %94 = icmp uge i64 %91, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %94, label %$34, label %$33
$34:
  %95 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %91
  br label %$33
$33:
  %96 = phi i1 [0, %$32], [%95, %$34] ; # ->
  br i1 %96, label %$35, label %$36
$35:
  call void @protErr(i64 %0, i64 %91)
  unreachable
$36:
; # (val (needChkVar Exe Z))
  %97 = inttoptr i64 %91 to i64*
  %98 = load i64, i64* %97
; # (push (val (needChkVar Exe Z)) Z P)
  %99 = alloca i64, i64 3, align 16
  %100 = ptrtoint i64* %99 to i64
  %101 = inttoptr i64 %100 to i64*
  store i64 %98, i64* %101
  %102 = add i64 %100, 8
  %103 = inttoptr i64 %102 to i64*
  store i64 %91, i64* %103
  %104 = add i64 %100, 16
  %105 = inttoptr i64 %104 to i64*
  store i64 %90, i64* %105
  %106 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %100, i64* %106
; # (car Y)
  %107 = inttoptr i64 %89 to i64*
  %108 = load i64, i64* %107
; # (eval (car Y))
  %109 = and i64 %108, 6
  %110 = icmp ne i64 %109, 0
  br i1 %110, label %$39, label %$38
$39:
  br label %$37
$38:
  %111 = and i64 %108, 8
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$41, label %$40
$41:
  %113 = inttoptr i64 %108 to i64*
  %114 = load i64, i64* %113
  br label %$37
$40:
  %115 = call i64 @evList(i64 %108)
  br label %$37
$37:
  %116 = phi i64 [%108, %$39], [%114, %$41], [%115, %$40] ; # ->
  %117 = inttoptr i64 %91 to i64*
  store i64 %116, i64* %117
  br label %$30
$29:
  %118 = phi i64 [%79, %$27] ; # X
  %119 = phi i64 [%85, %$27] ; # Y
  %120 = phi i64 [%81, %$27] ; # P
  %121 = phi i64 [%83, %$27] ; # Z
; # (let Tos 0 (loop (until (atom (car Z)) (let U Z (setq Z @) (set U...
; # (loop (until (atom (car Z)) (let U Z (setq Z @) (set U Tos) (setq...
  br label %$42
$42:
  %122 = phi i64 [%118, %$29], [%267, %$56] ; # X
  %123 = phi i64 [%119, %$29], [%268, %$56] ; # Y
  %124 = phi i64 [%120, %$29], [%269, %$56] ; # P
  %125 = phi i64 [%121, %$29], [%270, %$56] ; # Z
  %126 = phi i64 [0, %$29], [%271, %$56] ; # Tos
; # (until (atom (car Z)) (let U Z (setq Z @) (set U Tos) (setq Tos U...
  br label %$43
$43:
  %127 = phi i64 [%122, %$42], [%136, %$44] ; # X
  %128 = phi i64 [%123, %$42], [%137, %$44] ; # Y
  %129 = phi i64 [%124, %$42], [%138, %$44] ; # P
  %130 = phi i64 [%125, %$42], [%133, %$44] ; # Z
  %131 = phi i64 [%126, %$42], [%139, %$44] ; # Tos
; # (car Z)
  %132 = inttoptr i64 %130 to i64*
  %133 = load i64, i64* %132
; # (atom (car Z))
  %134 = and i64 %133, 15
  %135 = icmp ne i64 %134, 0
  br i1 %135, label %$45, label %$44
$44:
  %136 = phi i64 [%127, %$43] ; # X
  %137 = phi i64 [%128, %$43] ; # Y
  %138 = phi i64 [%129, %$43] ; # P
  %139 = phi i64 [%130, %$43] ; # Z
  %140 = phi i64 [%131, %$43] ; # Tos
; # (let U Z (setq Z @) (set U Tos) (setq Tos U))
; # (set U Tos)
  %141 = inttoptr i64 %139 to i64*
  store i64 %140, i64* %141
  br label %$43
$45:
  %142 = phi i64 [%127, %$43] ; # X
  %143 = phi i64 [%128, %$43] ; # Y
  %144 = phi i64 [%129, %$43] ; # P
  %145 = phi i64 [%130, %$43] ; # Z
  %146 = phi i64 [%131, %$43] ; # Tos
; # (unless (nil? (car Z)) (let S (needChkVar Exe @) (set $Bind (setq...
; # (car Z)
  %147 = inttoptr i64 %145 to i64*
  %148 = load i64, i64* %147
; # (nil? (car Z))
  %149 = icmp eq i64 %148, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %149, label %$47, label %$46
$46:
  %150 = phi i64 [%142, %$45] ; # X
  %151 = phi i64 [%143, %$45] ; # Y
  %152 = phi i64 [%144, %$45] ; # P
  %153 = phi i64 [%145, %$45] ; # Z
  %154 = phi i64 [%146, %$45] ; # Tos
; # (let S (needChkVar Exe @) (set $Bind (setq P (push (val S) S P)))...
; # (needChkVar Exe @)
  %155 = and i64 %148, 6
  %156 = icmp ne i64 %155, 0
  br i1 %156, label %$48, label %$49
$48:
  call void @varErr(i64 %0, i64 %148)
  unreachable
$49:
  %157 = icmp uge i64 %148, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %157, label %$51, label %$50
$51:
  %158 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %148
  br label %$50
$50:
  %159 = phi i1 [0, %$49], [%158, %$51] ; # ->
  br i1 %159, label %$52, label %$53
$52:
  call void @protErr(i64 %0, i64 %148)
  unreachable
$53:
; # (set $Bind (setq P (push (val S) S P)))
; # (val S)
  %160 = inttoptr i64 %148 to i64*
  %161 = load i64, i64* %160
; # (push (val S) S P)
  %162 = alloca i64, i64 3, align 16
  %163 = ptrtoint i64* %162 to i64
  %164 = inttoptr i64 %163 to i64*
  store i64 %161, i64* %164
  %165 = add i64 %163, 8
  %166 = inttoptr i64 %165 to i64*
  store i64 %148, i64* %166
  %167 = add i64 %163, 16
  %168 = inttoptr i64 %167 to i64*
  store i64 %152, i64* %168
  %169 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %163, i64* %169
  br label %$47
$47:
  %170 = phi i64 [%142, %$45], [%150, %$53] ; # X
  %171 = phi i64 [%143, %$45], [%151, %$53] ; # Y
  %172 = phi i64 [%144, %$45], [%163, %$53] ; # P
  %173 = phi i64 [%145, %$45], [%153, %$53] ; # Z
  %174 = phi i64 [%146, %$45], [%154, %$53] ; # Tos
; # (loop (? (pair (cdr Z)) (let U Z (setq Z @) (set 2 U Tos) (setq T...
  br label %$54
$54:
  %175 = phi i64 [%170, %$47], [%261, %$70] ; # X
  %176 = phi i64 [%171, %$47], [%262, %$70] ; # Y
  %177 = phi i64 [%172, %$47], [%263, %$70] ; # P
  %178 = phi i64 [%173, %$47], [%264, %$70] ; # Z
  %179 = phi i64 [%174, %$47], [%265, %$70] ; # Tos
; # (? (pair (cdr Z)) (let U Z (setq Z @) (set 2 U Tos) (setq Tos (| ...
; # (cdr Z)
  %180 = inttoptr i64 %178 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
; # (pair (cdr Z))
  %183 = and i64 %182, 15
  %184 = icmp eq i64 %183, 0
  br i1 %184, label %$57, label %$55
$57:
  %185 = phi i64 [%175, %$54] ; # X
  %186 = phi i64 [%176, %$54] ; # Y
  %187 = phi i64 [%177, %$54] ; # P
  %188 = phi i64 [%178, %$54] ; # Z
  %189 = phi i64 [%179, %$54] ; # Tos
; # (let U Z (setq Z @) (set 2 U Tos) (setq Tos (| U 8)))
; # (set 2 U Tos)
  %190 = inttoptr i64 %188 to i64*
  %191 = getelementptr i64, i64* %190, i32 1
  store i64 %189, i64* %191
; # (| U 8)
  %192 = or i64 %188, 8
  br label %$56
$55:
  %193 = phi i64 [%175, %$54] ; # X
  %194 = phi i64 [%176, %$54] ; # Y
  %195 = phi i64 [%177, %$54] ; # P
  %196 = phi i64 [%178, %$54] ; # Z
  %197 = phi i64 [%179, %$54] ; # Tos
; # (unless (nil? @) (let S (needChkVar Exe @) (set $Bind (setq P (pu...
; # (nil? @)
  %198 = icmp eq i64 %182, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %198, label %$59, label %$58
$58:
  %199 = phi i64 [%193, %$55] ; # X
  %200 = phi i64 [%194, %$55] ; # Y
  %201 = phi i64 [%195, %$55] ; # P
  %202 = phi i64 [%196, %$55] ; # Z
  %203 = phi i64 [%197, %$55] ; # Tos
; # (let S (needChkVar Exe @) (set $Bind (setq P (push (val S) S P)))...
; # (needChkVar Exe @)
  %204 = and i64 %182, 6
  %205 = icmp ne i64 %204, 0
  br i1 %205, label %$60, label %$61
$60:
  call void @varErr(i64 %0, i64 %182)
  unreachable
$61:
  %206 = icmp uge i64 %182, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %206, label %$63, label %$62
$63:
  %207 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %182
  br label %$62
$62:
  %208 = phi i1 [0, %$61], [%207, %$63] ; # ->
  br i1 %208, label %$64, label %$65
$64:
  call void @protErr(i64 %0, i64 %182)
  unreachable
$65:
; # (set $Bind (setq P (push (val S) S P)))
; # (val S)
  %209 = inttoptr i64 %182 to i64*
  %210 = load i64, i64* %209
; # (push (val S) S P)
  %211 = alloca i64, i64 3, align 16
  %212 = ptrtoint i64* %211 to i64
  %213 = inttoptr i64 %212 to i64*
  store i64 %210, i64* %213
  %214 = add i64 %212, 8
  %215 = inttoptr i64 %214 to i64*
  store i64 %182, i64* %215
  %216 = add i64 %212, 16
  %217 = inttoptr i64 %216 to i64*
  store i64 %201, i64* %217
  %218 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %212, i64* %218
  br label %$59
$59:
  %219 = phi i64 [%193, %$55], [%199, %$65] ; # X
  %220 = phi i64 [%194, %$55], [%200, %$65] ; # Y
  %221 = phi i64 [%195, %$55], [%212, %$65] ; # P
  %222 = phi i64 [%196, %$55], [%202, %$65] ; # Z
  %223 = phi i64 [%197, %$55], [%203, %$65] ; # Tos
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let U Tos (setq To...
  br label %$66
$66:
  %224 = phi i64 [%219, %$59], [%250, %$69] ; # X
  %225 = phi i64 [%220, %$59], [%251, %$69] ; # Y
  %226 = phi i64 [%221, %$59], [%252, %$69] ; # P
  %227 = phi i64 [%222, %$59], [%255, %$69] ; # Z
  %228 = phi i64 [%223, %$59], [%258, %$69] ; # Tos
; # (unless Tos (goto 1))
  %229 = icmp ne i64 %228, 0
  br i1 %229, label %$68, label %$67
$67:
  %230 = phi i64 [%224, %$66] ; # X
  %231 = phi i64 [%225, %$66] ; # Y
  %232 = phi i64 [%226, %$66] ; # P
  %233 = phi i64 [%227, %$66] ; # Z
  %234 = phi i64 [%228, %$66] ; # Tos
; # (goto 1)
  br label %$-1
$68:
  %235 = phi i64 [%224, %$66] ; # X
  %236 = phi i64 [%225, %$66] ; # Y
  %237 = phi i64 [%226, %$66] ; # P
  %238 = phi i64 [%227, %$66] ; # Z
  %239 = phi i64 [%228, %$66] ; # Tos
; # (? (=0 (& Tos 8)) (let U Tos (setq Tos (car U)) (set U Z) (setq Z...
; # (& Tos 8)
  %240 = and i64 %239, 8
; # (=0 (& Tos 8))
  %241 = icmp eq i64 %240, 0
  br i1 %241, label %$71, label %$69
$71:
  %242 = phi i64 [%235, %$68] ; # X
  %243 = phi i64 [%236, %$68] ; # Y
  %244 = phi i64 [%237, %$68] ; # P
  %245 = phi i64 [%238, %$68] ; # Z
  %246 = phi i64 [%239, %$68] ; # Tos
; # (let U Tos (setq Tos (car U)) (set U Z) (setq Z U))
; # (car U)
  %247 = inttoptr i64 %246 to i64*
  %248 = load i64, i64* %247
; # (set U Z)
  %249 = inttoptr i64 %246 to i64*
  store i64 %245, i64* %249
  br label %$70
$69:
  %250 = phi i64 [%235, %$68] ; # X
  %251 = phi i64 [%236, %$68] ; # Y
  %252 = phi i64 [%237, %$68] ; # P
  %253 = phi i64 [%238, %$68] ; # Z
  %254 = phi i64 [%239, %$68] ; # Tos
; # (let U (& Tos -9) (setq Tos (cdr U)) (set 2 U Z) (setq Z U))
; # (& Tos -9)
  %255 = and i64 %254, -9
; # (cdr U)
  %256 = inttoptr i64 %255 to i64*
  %257 = getelementptr i64, i64* %256, i32 1
  %258 = load i64, i64* %257
; # (set 2 U Z)
  %259 = inttoptr i64 %255 to i64*
  %260 = getelementptr i64, i64* %259, i32 1
  store i64 %253, i64* %260
  br label %$66
$70:
  %261 = phi i64 [%242, %$71] ; # X
  %262 = phi i64 [%243, %$71] ; # Y
  %263 = phi i64 [%244, %$71] ; # P
  %264 = phi i64 [%246, %$71] ; # Z
  %265 = phi i64 [%248, %$71] ; # Tos
  %266 = phi i64 [%246, %$71] ; # ->
  br label %$54
$56:
  %267 = phi i64 [%185, %$57] ; # X
  %268 = phi i64 [%186, %$57] ; # Y
  %269 = phi i64 [%187, %$57] ; # P
  %270 = phi i64 [%182, %$57] ; # Z
  %271 = phi i64 [%192, %$57] ; # Tos
  %272 = phi i64 [%192, %$57] ; # ->
  br label %$42
$72:
; # (: 1 (setDestruct Z (eval (car Y))))
  br label %$-1
$-1:
  %273 = phi i64 [%230, %$67], [%267, %$72] ; # X
  %274 = phi i64 [%231, %$67], [%268, %$72] ; # Y
  %275 = phi i64 [%232, %$67], [%269, %$72] ; # P
  %276 = phi i64 [%233, %$67], [%270, %$72] ; # Z
; # (car Y)
  %277 = inttoptr i64 %274 to i64*
  %278 = load i64, i64* %277
; # (eval (car Y))
  %279 = and i64 %278, 6
  %280 = icmp ne i64 %279, 0
  br i1 %280, label %$75, label %$74
$75:
  br label %$73
$74:
  %281 = and i64 %278, 8
  %282 = icmp ne i64 %281, 0
  br i1 %282, label %$77, label %$76
$77:
  %283 = inttoptr i64 %278 to i64*
  %284 = load i64, i64* %283
  br label %$73
$76:
  %285 = call i64 @evList(i64 %278)
  br label %$73
$73:
  %286 = phi i64 [%278, %$75], [%284, %$77], [%285, %$76] ; # ->
; # (setDestruct Z (eval (car Y)))
  call void @setDestruct(i64 %276, i64 %286)
  br label %$30
$30:
  %287 = phi i64 [%88, %$37], [%273, %$73] ; # X
  %288 = phi i64 [%89, %$37], [%274, %$73] ; # Y
  %289 = phi i64 [%100, %$37], [%275, %$73] ; # P
  %290 = phi i64 [%91, %$37], [%276, %$73] ; # Z
; # (? (atom (shift Y)))
; # (shift Y)
  %291 = inttoptr i64 %288 to i64*
  %292 = getelementptr i64, i64* %291, i32 1
  %293 = load i64, i64* %292
; # (atom (shift Y))
  %294 = and i64 %293, 15
  %295 = icmp ne i64 %294, 0
  br i1 %295, label %$79, label %$78
$78:
  %296 = phi i64 [%287, %$30] ; # X
  %297 = phi i64 [%293, %$30] ; # Y
  %298 = phi i64 [%289, %$30] ; # P
  br label %$27
$79:
  %299 = phi i64 [%287, %$30] ; # X
  %300 = phi i64 [%293, %$30] ; # Y
  %301 = phi i64 [%289, %$30] ; # P
  %302 = phi i64 [0, %$30] ; # ->
; # (prog1 (run X) (loop (set (val 2 P) (val P)) (? (== Q (setq P (va...
; # (run X)
  br label %$80
$80:
  %303 = phi i64 [%299, %$79], [%325, %$89] ; # Prg
  %304 = inttoptr i64 %303 to i64*
  %305 = load i64, i64* %304
  %306 = getelementptr i64, i64* %304, i32 1
  %307 = load i64, i64* %306
  %308 = and i64 %307, 15
  %309 = icmp ne i64 %308, 0
  br i1 %309, label %$83, label %$81
$83:
  %310 = phi i64 [%307, %$80] ; # Prg
  %311 = and i64 %305, 6
  %312 = icmp ne i64 %311, 0
  br i1 %312, label %$86, label %$85
$86:
  br label %$84
$85:
  %313 = and i64 %305, 8
  %314 = icmp ne i64 %313, 0
  br i1 %314, label %$88, label %$87
$88:
  %315 = inttoptr i64 %305 to i64*
  %316 = load i64, i64* %315
  br label %$84
$87:
  %317 = call i64 @evList(i64 %305)
  br label %$84
$84:
  %318 = phi i64 [%305, %$86], [%316, %$88], [%317, %$87] ; # ->
  br label %$82
$81:
  %319 = phi i64 [%307, %$80] ; # Prg
  %320 = and i64 %305, 15
  %321 = icmp eq i64 %320, 0
  br i1 %321, label %$90, label %$89
$90:
  %322 = phi i64 [%319, %$81] ; # Prg
  %323 = call i64 @evList(i64 %305)
  %324 = icmp ne i64 %323, 0
  br label %$89
$89:
  %325 = phi i64 [%319, %$81], [%322, %$90] ; # Prg
  %326 = phi i1 [0, %$81], [%324, %$90] ; # ->
  br label %$80
$82:
  %327 = phi i64 [%310, %$84] ; # Prg
  %328 = phi i64 [%318, %$84] ; # ->
; # (loop (set (val 2 P) (val P)) (? (== Q (setq P (val 3 P)))))
  br label %$91
$91:
  %329 = phi i64 [%299, %$82], [%342, %$92] ; # X
  %330 = phi i64 [%300, %$82], [%343, %$92] ; # Y
  %331 = phi i64 [%301, %$82], [%344, %$92] ; # P
; # (set (val 2 P) (val P))
; # (val 2 P)
  %332 = inttoptr i64 %331 to i64*
  %333 = getelementptr i64, i64* %332, i32 1
  %334 = load i64, i64* %333
; # (val P)
  %335 = inttoptr i64 %331 to i64*
  %336 = load i64, i64* %335
  %337 = inttoptr i64 %334 to i64*
  store i64 %336, i64* %337
; # (? (== Q (setq P (val 3 P))))
; # (val 3 P)
  %338 = inttoptr i64 %331 to i64*
  %339 = getelementptr i64, i64* %338, i32 2
  %340 = load i64, i64* %339
; # (== Q (setq P (val 3 P)))
  %341 = icmp eq i64 %78, %340
  br i1 %341, label %$93, label %$92
$92:
  %342 = phi i64 [%329, %$91] ; # X
  %343 = phi i64 [%330, %$91] ; # Y
  %344 = phi i64 [%340, %$91] ; # P
  br label %$91
$93:
  %345 = phi i64 [%329, %$91] ; # X
  %346 = phi i64 [%330, %$91] ; # Y
  %347 = phi i64 [%340, %$91] ; # P
  %348 = phi i64 [0, %$91] ; # ->
; # (set $Bind P)
  %349 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %347, i64* %349
  br label %$4
$4:
  %350 = phi i64 [%32, %$18], [%345, %$93] ; # X
  %351 = phi i64 [%11, %$18], [%346, %$93] ; # Y
  %352 = phi i64 [%67, %$18], [%328, %$93] ; # ->
  ret i64 %352
}

define i64 @_letQ(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (needChkVar Exe (++ X))) (if (nil? (eval (car...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (needChkVar Exe (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  call void @varErr(i64 %0, i64 %5)
  unreachable
$3:
  %10 = icmp uge i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$5, label %$4
$5:
  %11 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %5
  br label %$4
$4:
  %12 = phi i1 [0, %$3], [%11, %$5] ; # ->
  br i1 %12, label %$6, label %$7
$6:
  call void @protErr(i64 %0, i64 %5)
  unreachable
$7:
; # (if (nil? (eval (car X))) @ (let P (set $Bind (push (val Y) Y (va...
; # (car X)
  %13 = inttoptr i64 %7 to i64*
  %14 = load i64, i64* %13
; # (eval (car X))
  %15 = and i64 %14, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$9
$10:
  br label %$8
$9:
  %17 = and i64 %14, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$12, label %$11
$12:
  %19 = inttoptr i64 %14 to i64*
  %20 = load i64, i64* %19
  br label %$8
$11:
  %21 = call i64 @evList(i64 %14)
  br label %$8
$8:
  %22 = phi i64 [%14, %$10], [%20, %$12], [%21, %$11] ; # ->
; # (nil? (eval (car X)))
  %23 = icmp eq i64 %22, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %23, label %$13, label %$14
$13:
  br label %$15
$14:
; # (let P (set $Bind (push (val Y) Y (val $Bind))) (set Y @) (prog1 ...
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %24 = inttoptr i64 %5 to i64*
  %25 = load i64, i64* %24
; # (val $Bind)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %27 = load i64, i64* %26
; # (push (val Y) Y (val $Bind))
  %28 = alloca i64, i64 3, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %25, i64* %30
  %31 = add i64 %29, 8
  %32 = inttoptr i64 %31 to i64*
  store i64 %5, i64* %32
  %33 = add i64 %29, 16
  %34 = inttoptr i64 %33 to i64*
  store i64 %27, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %29, i64* %35
; # (set Y @)
  %36 = inttoptr i64 %5 to i64*
  store i64 %22, i64* %36
; # (prog1 (run (cdr X)) (set Y (val P) $Bind (val 3 P)))
; # (cdr X)
  %37 = inttoptr i64 %7 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (run (cdr X))
  br label %$16
$16:
  %40 = phi i64 [%39, %$14], [%62, %$25] ; # Prg
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = getelementptr i64, i64* %41, i32 1
  %44 = load i64, i64* %43
  %45 = and i64 %44, 15
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$19, label %$17
$19:
  %47 = phi i64 [%44, %$16] ; # Prg
  %48 = and i64 %42, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$22, label %$21
$22:
  br label %$20
$21:
  %50 = and i64 %42, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$24, label %$23
$24:
  %52 = inttoptr i64 %42 to i64*
  %53 = load i64, i64* %52
  br label %$20
$23:
  %54 = call i64 @evList(i64 %42)
  br label %$20
$20:
  %55 = phi i64 [%42, %$22], [%53, %$24], [%54, %$23] ; # ->
  br label %$18
$17:
  %56 = phi i64 [%44, %$16] ; # Prg
  %57 = and i64 %42, 15
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %$26, label %$25
$26:
  %59 = phi i64 [%56, %$17] ; # Prg
  %60 = call i64 @evList(i64 %42)
  %61 = icmp ne i64 %60, 0
  br label %$25
$25:
  %62 = phi i64 [%56, %$17], [%59, %$26] ; # Prg
  %63 = phi i1 [0, %$17], [%61, %$26] ; # ->
  br label %$16
$18:
  %64 = phi i64 [%47, %$20] ; # Prg
  %65 = phi i64 [%55, %$20] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %66 = inttoptr i64 %29 to i64*
  %67 = load i64, i64* %66
  %68 = inttoptr i64 %5 to i64*
  store i64 %67, i64* %68
; # (val 3 P)
  %69 = inttoptr i64 %29 to i64*
  %70 = getelementptr i64, i64* %69, i32 2
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %71, i64* %72
  br label %$15
$15:
  %73 = phi i64 [%22, %$13], [%65, %$18] ; # ->
  ret i64 %73
}

define i64 @_use(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (++ X)) (if (atom Y) (let P (set $Bind (push ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (if (atom Y) (let P (set $Bind (push (val Y) Y (val $Bind))) (pro...
; # (atom Y)
  %8 = and i64 %5, 15
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  %10 = phi i64 [%5, %$1] ; # Y
; # (let P (set $Bind (push (val Y) Y (val $Bind))) (prog1 (run X) (s...
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (val $Bind)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %14 = load i64, i64* %13
; # (push (val Y) Y (val $Bind))
  %15 = alloca i64, i64 3, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %12, i64* %17
  %18 = add i64 %16, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 %10, i64* %19
  %20 = add i64 %16, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 %14, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %16, i64* %22
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$5
$5:
  %23 = phi i64 [%7, %$2], [%45, %$14] ; # Prg
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
  %28 = and i64 %27, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$8, label %$6
$8:
  %30 = phi i64 [%27, %$5] ; # Prg
  %31 = and i64 %25, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$10
$11:
  br label %$9
$10:
  %33 = and i64 %25, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$12
$13:
  %35 = inttoptr i64 %25 to i64*
  %36 = load i64, i64* %35
  br label %$9
$12:
  %37 = call i64 @evList(i64 %25)
  br label %$9
$9:
  %38 = phi i64 [%25, %$11], [%36, %$13], [%37, %$12] ; # ->
  br label %$7
$6:
  %39 = phi i64 [%27, %$5] ; # Prg
  %40 = and i64 %25, 15
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %$15, label %$14
$15:
  %42 = phi i64 [%39, %$6] ; # Prg
  %43 = call i64 @evList(i64 %25)
  %44 = icmp ne i64 %43, 0
  br label %$14
$14:
  %45 = phi i64 [%39, %$6], [%42, %$15] ; # Prg
  %46 = phi i1 [0, %$6], [%44, %$15] ; # ->
  br label %$5
$7:
  %47 = phi i64 [%30, %$9] ; # Prg
  %48 = phi i64 [%38, %$9] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %49 = inttoptr i64 %16 to i64*
  %50 = load i64, i64* %49
  %51 = inttoptr i64 %10 to i64*
  store i64 %50, i64* %51
; # (val 3 P)
  %52 = inttoptr i64 %16 to i64*
  %53 = getelementptr i64, i64* %52, i32 2
  %54 = load i64, i64* %53
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %54, i64* %55
  br label %$4
$3:
  %56 = phi i64 [%5, %$1] ; # Y
; # (let (P (val $Bind) Q P) (loop (let Z (car Y) (set $Bind (setq P ...
; # (val $Bind)
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %58 = load i64, i64* %57
; # (loop (let Z (car Y) (set $Bind (setq P (push (val Z) Z P)))) (? ...
  br label %$16
$16:
  %59 = phi i64 [%56, %$3], [%78, %$17] ; # Y
  %60 = phi i64 [%58, %$3], [%79, %$17] ; # P
; # (let Z (car Y) (set $Bind (setq P (push (val Z) Z P))))
; # (car Y)
  %61 = inttoptr i64 %59 to i64*
  %62 = load i64, i64* %61
; # (set $Bind (setq P (push (val Z) Z P)))
; # (val Z)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (push (val Z) Z P)
  %65 = alloca i64, i64 3, align 16
  %66 = ptrtoint i64* %65 to i64
  %67 = inttoptr i64 %66 to i64*
  store i64 %64, i64* %67
  %68 = add i64 %66, 8
  %69 = inttoptr i64 %68 to i64*
  store i64 %62, i64* %69
  %70 = add i64 %66, 16
  %71 = inttoptr i64 %70 to i64*
  store i64 %60, i64* %71
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %66, i64* %72
; # (? (atom (shift Y)))
; # (shift Y)
  %73 = inttoptr i64 %59 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
; # (atom (shift Y))
  %76 = and i64 %75, 15
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$18, label %$17
$17:
  %78 = phi i64 [%75, %$16] ; # Y
  %79 = phi i64 [%66, %$16] ; # P
  br label %$16
$18:
  %80 = phi i64 [%75, %$16] ; # Y
  %81 = phi i64 [%66, %$16] ; # P
  %82 = phi i64 [0, %$16] ; # ->
; # (prog1 (run X) (loop (set (val 2 P) (val P)) (? (== Q (setq P (va...
; # (run X)
  br label %$19
$19:
  %83 = phi i64 [%7, %$18], [%105, %$28] ; # Prg
  %84 = inttoptr i64 %83 to i64*
  %85 = load i64, i64* %84
  %86 = getelementptr i64, i64* %84, i32 1
  %87 = load i64, i64* %86
  %88 = and i64 %87, 15
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$22, label %$20
$22:
  %90 = phi i64 [%87, %$19] ; # Prg
  %91 = and i64 %85, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$25, label %$24
$25:
  br label %$23
$24:
  %93 = and i64 %85, 8
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$27, label %$26
$27:
  %95 = inttoptr i64 %85 to i64*
  %96 = load i64, i64* %95
  br label %$23
$26:
  %97 = call i64 @evList(i64 %85)
  br label %$23
$23:
  %98 = phi i64 [%85, %$25], [%96, %$27], [%97, %$26] ; # ->
  br label %$21
$20:
  %99 = phi i64 [%87, %$19] ; # Prg
  %100 = and i64 %85, 15
  %101 = icmp eq i64 %100, 0
  br i1 %101, label %$29, label %$28
$29:
  %102 = phi i64 [%99, %$20] ; # Prg
  %103 = call i64 @evList(i64 %85)
  %104 = icmp ne i64 %103, 0
  br label %$28
$28:
  %105 = phi i64 [%99, %$20], [%102, %$29] ; # Prg
  %106 = phi i1 [0, %$20], [%104, %$29] ; # ->
  br label %$19
$21:
  %107 = phi i64 [%90, %$23] ; # Prg
  %108 = phi i64 [%98, %$23] ; # ->
; # (loop (set (val 2 P) (val P)) (? (== Q (setq P (val 3 P)))))
  br label %$30
$30:
  %109 = phi i64 [%80, %$21], [%121, %$31] ; # Y
  %110 = phi i64 [%81, %$21], [%122, %$31] ; # P
; # (set (val 2 P) (val P))
; # (val 2 P)
  %111 = inttoptr i64 %110 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  %113 = load i64, i64* %112
; # (val P)
  %114 = inttoptr i64 %110 to i64*
  %115 = load i64, i64* %114
  %116 = inttoptr i64 %113 to i64*
  store i64 %115, i64* %116
; # (? (== Q (setq P (val 3 P))))
; # (val 3 P)
  %117 = inttoptr i64 %110 to i64*
  %118 = getelementptr i64, i64* %117, i32 2
  %119 = load i64, i64* %118
; # (== Q (setq P (val 3 P)))
  %120 = icmp eq i64 %58, %119
  br i1 %120, label %$32, label %$31
$31:
  %121 = phi i64 [%109, %$30] ; # Y
  %122 = phi i64 [%119, %$30] ; # P
  br label %$30
$32:
  %123 = phi i64 [%109, %$30] ; # Y
  %124 = phi i64 [%119, %$30] ; # P
  %125 = phi i64 [0, %$30] ; # ->
; # (set $Bind P)
  %126 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %124, i64* %126
  br label %$4
$4:
  %127 = phi i64 [%10, %$7], [%123, %$32] ; # Y
  %128 = phi i64 [%48, %$7], [%108, %$32] ; # ->
  ret i64 %128
}

define i64 @_buf(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (needChkVar Exe (++ X)) Z (needCnt Exe (eval ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (needChkVar Exe (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  call void @varErr(i64 %0, i64 %5)
  unreachable
$3:
  %10 = icmp uge i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$5, label %$4
$5:
  %11 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %5
  br label %$4
$4:
  %12 = phi i1 [0, %$3], [%11, %$5] ; # ->
  br i1 %12, label %$6, label %$7
$6:
  call void @protErr(i64 %0, i64 %5)
  unreachable
$7:
; # (++ X)
  %13 = inttoptr i64 %7 to i64*
  %14 = load i64, i64* %13
  %15 = getelementptr i64, i64* %13, i32 1
  %16 = load i64, i64* %15
; # (eval (++ X))
  %17 = and i64 %14, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$9
$10:
  br label %$8
$9:
  %19 = and i64 %14, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$12, label %$11
$12:
  %21 = inttoptr i64 %14 to i64*
  %22 = load i64, i64* %21
  br label %$8
$11:
  %23 = call i64 @evList(i64 %14)
  br label %$8
$8:
  %24 = phi i64 [%14, %$10], [%22, %$12], [%23, %$11] ; # ->
; # (needCnt Exe (eval (++ X)))
  %25 = and i64 %24, 2
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$14, label %$13
$13:
  call void @cntErr(i64 %0, i64 %24)
  unreachable
$14:
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %27 = inttoptr i64 %5 to i64*
  %28 = load i64, i64* %27
; # (val $Bind)
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %30 = load i64, i64* %29
; # (push (val Y) Y (val $Bind))
  %31 = alloca i64, i64 3, align 16
  %32 = ptrtoint i64* %31 to i64
  %33 = inttoptr i64 %32 to i64*
  store i64 %28, i64* %33
  %34 = add i64 %32, 8
  %35 = inttoptr i64 %34 to i64*
  store i64 %5, i64* %35
  %36 = add i64 %32, 16
  %37 = inttoptr i64 %36 to i64*
  store i64 %30, i64* %37
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %32, i64* %38
; # (set Y (box64 (i64 (b8 (int Z)))))
; # (int Z)
  %39 = lshr i64 %24, 4
; # (b8 (int Z))
  %40 = alloca i8, i64 %39
; # (i64 (b8 (int Z)))
  %41 = ptrtoint i8* %40 to i64
; # (box64 (i64 (b8 (int Z))))
  %42 = and i64 %41, 17293822569102704640
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$15, label %$16
$15:
  %44 = call i64 @boxNum(i64 %41)
  br label %$17
$16:
  %45 = shl i64 %41, 4
  %46 = or i64 %45, 2
  br label %$17
$17:
  %47 = phi i64 [%44, %$15], [%46, %$16] ; # ->
  %48 = inttoptr i64 %5 to i64*
  store i64 %47, i64* %48
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$18
$18:
  %49 = phi i64 [%16, %$17], [%71, %$27] ; # Prg
  %50 = inttoptr i64 %49 to i64*
  %51 = load i64, i64* %50
  %52 = getelementptr i64, i64* %50, i32 1
  %53 = load i64, i64* %52
  %54 = and i64 %53, 15
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$21, label %$19
$21:
  %56 = phi i64 [%53, %$18] ; # Prg
  %57 = and i64 %51, 6
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$24, label %$23
$24:
  br label %$22
$23:
  %59 = and i64 %51, 8
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$26, label %$25
$26:
  %61 = inttoptr i64 %51 to i64*
  %62 = load i64, i64* %61
  br label %$22
$25:
  %63 = call i64 @evList(i64 %51)
  br label %$22
$22:
  %64 = phi i64 [%51, %$24], [%62, %$26], [%63, %$25] ; # ->
  br label %$20
$19:
  %65 = phi i64 [%53, %$18] ; # Prg
  %66 = and i64 %51, 15
  %67 = icmp eq i64 %66, 0
  br i1 %67, label %$28, label %$27
$28:
  %68 = phi i64 [%65, %$19] ; # Prg
  %69 = call i64 @evList(i64 %51)
  %70 = icmp ne i64 %69, 0
  br label %$27
$27:
  %71 = phi i64 [%65, %$19], [%68, %$28] ; # Prg
  %72 = phi i1 [0, %$19], [%70, %$28] ; # ->
  br label %$18
$20:
  %73 = phi i64 [%56, %$22] ; # Prg
  %74 = phi i64 [%64, %$22] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %75 = inttoptr i64 %32 to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %5 to i64*
  store i64 %76, i64* %77
; # (val 3 P)
  %78 = inttoptr i64 %32 to i64*
  %79 = getelementptr i64, i64* %78, i32 2
  %80 = load i64, i64* %79
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %80, i64* %81
  ret i64 %74
}

define i64 @_catch(i64) align 8 {
$1:
; # (let (X (cdr Exe) Ca: (caFrame (b8 (+ (val JmpBufSize) (caFrame T...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val JmpBufSize)
  %4 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (caFrame T))
  %5 = add i64 %4, 216
; # (b8 (+ (val JmpBufSize) (caFrame T)))
  %6 = alloca i8, i64 %5
; # (Ca: tag (eval (++ X)))
  %7 = getelementptr i8, i8* %6, i32 8
  %8 = ptrtoint i8* %7 to i64
  %9 = inttoptr i64 %3 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
  %13 = and i64 %10, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$4, label %$3
$4:
  br label %$2
$3:
  %15 = and i64 %10, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$6, label %$5
$6:
  %17 = inttoptr i64 %10 to i64*
  %18 = load i64, i64* %17
  br label %$2
$5:
  %19 = call i64 @evList(i64 %10)
  br label %$2
$2:
  %20 = phi i64 [%10, %$4], [%18, %$6], [%19, %$5] ; # ->
  %21 = inttoptr i64 %8 to i64*
  store i64 %20, i64* %21
; # (Ca: link (val $Catch))
  %22 = bitcast i8* %6 to i8**
  %23 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
  store i8* %23, i8** %22
; # (set $Catch (Ca:))
; # (Ca:)
  store i8* %6, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (Ca: fin ZERO)
  %24 = getelementptr i8, i8* %6, i32 16
  %25 = ptrtoint i8* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 2, i64* %26
; # (Ca: co (val $Current))
  %27 = getelementptr i8, i8* %6, i32 24
  %28 = bitcast i8* %27 to i8**
  %29 = load i8*, i8** @$Current
  store i8* %29, i8** %28
; # (Ca:)
; # (putCaEnv (Ca:))
  %30 = getelementptr i8, i8* %6, i32 32
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %30, i8* %31, i64 144, i1 0)
  %32 = getelementptr i8, i8* %6, i32 176
  %33 = ptrtoint i8* %32 to i64
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %33 to i64*
  store i64 %35, i64* %36
  %37 = getelementptr i8, i8* %6, i32 184
  %38 = ptrtoint i8* %37 to i64
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %38 to i64*
  store i64 %40, i64* %41
  %42 = getelementptr i8, i8* %6, i32 192
  %43 = ptrtoint i8* %42 to i64
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %43 to i64*
  store i64 %46, i64* %47
  %48 = getelementptr i8, i8* %6, i32 200
  %49 = ptrtoint i8* %48 to i64
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %49 to i64*
  store i64 %51, i64* %52
  %53 = getelementptr i8, i8* %6, i32 208
  %54 = ptrtoint i8* %53 to i64
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
  %58 = inttoptr i64 %54 to i64*
  store i64 %57, i64* %58
; # (prog1 (if (setjmp (Ca: (rst))) (val $Ret) (run X)) (set $Catch (...
; # (if (setjmp (Ca: (rst))) (val $Ret) (run X))
; # (Ca: (rst))
  %59 = getelementptr i8, i8* %6, i32 216
; # (setjmp (Ca: (rst)))
  %60 = call i32 @setjmp(i8* %59)
  %61 = icmp ne i32 %60, 0
  br i1 %61, label %$7, label %$8
$7:
  %62 = phi i64 [%12, %$2] ; # X
; # (val $Ret)
  %63 = load i64, i64* @$Ret
  br label %$9
$8:
  %64 = phi i64 [%12, %$2] ; # X
; # (run X)
  br label %$10
$10:
  %65 = phi i64 [%64, %$8], [%87, %$19] ; # Prg
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
  %68 = getelementptr i64, i64* %66, i32 1
  %69 = load i64, i64* %68
  %70 = and i64 %69, 15
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$13, label %$11
$13:
  %72 = phi i64 [%69, %$10] ; # Prg
  %73 = and i64 %67, 6
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$16, label %$15
$16:
  br label %$14
$15:
  %75 = and i64 %67, 8
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$18, label %$17
$18:
  %77 = inttoptr i64 %67 to i64*
  %78 = load i64, i64* %77
  br label %$14
$17:
  %79 = call i64 @evList(i64 %67)
  br label %$14
$14:
  %80 = phi i64 [%67, %$16], [%78, %$18], [%79, %$17] ; # ->
  br label %$12
$11:
  %81 = phi i64 [%69, %$10] ; # Prg
  %82 = and i64 %67, 15
  %83 = icmp eq i64 %82, 0
  br i1 %83, label %$20, label %$19
$20:
  %84 = phi i64 [%81, %$11] ; # Prg
  %85 = call i64 @evList(i64 %67)
  %86 = icmp ne i64 %85, 0
  br label %$19
$19:
  %87 = phi i64 [%81, %$11], [%84, %$20] ; # Prg
  %88 = phi i1 [0, %$11], [%86, %$20] ; # ->
  br label %$10
$12:
  %89 = phi i64 [%72, %$14] ; # Prg
  %90 = phi i64 [%80, %$14] ; # ->
  br label %$9
$9:
  %91 = phi i64 [%62, %$7], [%64, %$12] ; # X
  %92 = phi i64 [%63, %$7], [%90, %$12] ; # ->
; # (set $Catch (Ca: link))
; # (Ca: link)
  %93 = bitcast i8* %6 to i8**
  %94 = load i8*, i8** %93
  store i8* %94, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
  ret i64 %92
}

define i64 @_throw(i64) align 8 {
$1:
; # (let (X (cdr Exe) Tag (save (eval (++ X))) R (save (eval (car X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %33, i64* %38
  %39 = add i64 %37, 8
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %41
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (when (or (t...
; # (val $Catch)
  %42 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (when (or (t? (Ca: tag)) (== Tag ...
  br label %$12
$12:
  %43 = phi i8* [%42, %$7], [%63, %$18] ; # Ca
  %44 = icmp ne i8* %43, null
  br i1 %44, label %$13, label %$14
$13:
  %45 = phi i8* [%43, %$12] ; # Ca
; # (let Ca: (caFrame Ca) (when (or (t? (Ca: tag)) (== Tag (Ca: tag))...
; # (when (or (t? (Ca: tag)) (== Tag (Ca: tag))) (unwind Ca) (set $Re...
; # (or (t? (Ca: tag)) (== Tag (Ca: tag)))
; # (Ca: tag)
  %46 = getelementptr i8, i8* %45, i32 8
  %47 = ptrtoint i8* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (t? (Ca: tag))
  %50 = icmp eq i64 %49, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %50, label %$15, label %$16
$16:
  %51 = phi i8* [%45, %$13] ; # Ca
; # (Ca: tag)
  %52 = getelementptr i8, i8* %45, i32 8
  %53 = ptrtoint i8* %52 to i64
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (== Tag (Ca: tag))
  %56 = icmp eq i64 %15, %55
  br label %$15
$15:
  %57 = phi i8* [%45, %$13], [%51, %$16] ; # Ca
  %58 = phi i1 [1, %$13], [%56, %$16] ; # ->
  br i1 %58, label %$17, label %$18
$17:
  %59 = phi i8* [%57, %$15] ; # Ca
; # (unwind Ca)
  call void @unwind(i8* %59)
; # (set $Ret R)
  store i64 %33, i64* @$Ret
; # (Ca: (rst))
  %60 = getelementptr i8, i8* %45, i32 216
; # (longjmp (Ca: (rst)) 1)
  call void @longjmp(i8* %60, i32 1)
  unreachable
$18:
  %61 = phi i8* [%57, %$15] ; # Ca
; # (Ca: link)
  %62 = bitcast i8* %45 to i8**
  %63 = load i8*, i8** %62
  br label %$12
$14:
  %64 = phi i8* [%43, %$12] ; # Ca
; # (err Exe Tag ($ "Tag not found") null)
  call void @err(i64 %0, i64 %15, i8* bitcast ([14 x i8]* @$73 to i8*), i8* null)
  unreachable
}

define i64 @_finally(i64) align 8 {
$1:
; # (let (X (cdr Exe) Ca: (caFrame (b8 (+ (val JmpBufSize) (caFrame T...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val JmpBufSize)
  %4 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (caFrame T))
  %5 = add i64 %4, 216
; # (b8 (+ (val JmpBufSize) (caFrame T)))
  %6 = alloca i8, i64 %5
; # (Ca: tag 0)
  %7 = getelementptr i8, i8* %6, i32 8
  %8 = ptrtoint i8* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 0, i64* %9
; # (Ca: link (val $Catch))
  %10 = bitcast i8* %6 to i8**
  %11 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
  store i8* %11, i8** %10
; # (set $Catch (Ca:))
; # (Ca:)
  store i8* %6, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (Ca: fin (++ X))
  %12 = getelementptr i8, i8* %6, i32 16
  %13 = ptrtoint i8* %12 to i64
  %14 = inttoptr i64 %3 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %13 to i64*
  store i64 %15, i64* %18
; # (Ca: co (val $Current))
  %19 = getelementptr i8, i8* %6, i32 24
  %20 = bitcast i8* %19 to i8**
  %21 = load i8*, i8** @$Current
  store i8* %21, i8** %20
; # (Ca:)
; # (putCaEnv (Ca:))
  %22 = getelementptr i8, i8* %6, i32 32
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %22, i8* %23, i64 144, i1 0)
  %24 = getelementptr i8, i8* %6, i32 176
  %25 = ptrtoint i8* %24 to i64
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %25 to i64*
  store i64 %27, i64* %28
  %29 = getelementptr i8, i8* %6, i32 184
  %30 = ptrtoint i8* %29 to i64
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %30 to i64*
  store i64 %32, i64* %33
  %34 = getelementptr i8, i8* %6, i32 192
  %35 = ptrtoint i8* %34 to i64
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %35 to i64*
  store i64 %38, i64* %39
  %40 = getelementptr i8, i8* %6, i32 200
  %41 = ptrtoint i8* %40 to i64
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %43 = load i64, i64* %42
  %44 = inttoptr i64 %41 to i64*
  store i64 %43, i64* %44
  %45 = getelementptr i8, i8* %6, i32 208
  %46 = ptrtoint i8* %45 to i64
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 %46 to i64*
  store i64 %49, i64* %50
; # (prog1 (save (run X)) (eval (Ca: fin)) (set $Catch (Ca: link)))
; # (run X)
  br label %$2
$2:
  %51 = phi i64 [%17, %$1], [%73, %$11] ; # Prg
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
  %54 = getelementptr i64, i64* %52, i32 1
  %55 = load i64, i64* %54
  %56 = and i64 %55, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$5, label %$3
$5:
  %58 = phi i64 [%55, %$2] ; # Prg
  %59 = and i64 %53, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$8, label %$7
$8:
  br label %$6
$7:
  %61 = and i64 %53, 8
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$10, label %$9
$10:
  %63 = inttoptr i64 %53 to i64*
  %64 = load i64, i64* %63
  br label %$6
$9:
  %65 = call i64 @evList(i64 %53)
  br label %$6
$6:
  %66 = phi i64 [%53, %$8], [%64, %$10], [%65, %$9] ; # ->
  br label %$4
$3:
  %67 = phi i64 [%55, %$2] ; # Prg
  %68 = and i64 %53, 15
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %$12, label %$11
$12:
  %70 = phi i64 [%67, %$3] ; # Prg
  %71 = call i64 @evList(i64 %53)
  %72 = icmp ne i64 %71, 0
  br label %$11
$11:
  %73 = phi i64 [%67, %$3], [%70, %$12] ; # Prg
  %74 = phi i1 [0, %$3], [%72, %$12] ; # ->
  br label %$2
$4:
  %75 = phi i64 [%58, %$6] ; # Prg
  %76 = phi i64 [%66, %$6] ; # ->
; # (save (run X))
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %78 = load i64, i64* %77
  %79 = alloca i64, i64 2, align 16
  %80 = ptrtoint i64* %79 to i64
  %81 = inttoptr i64 %80 to i64*
  store i64 %76, i64* %81
  %82 = add i64 %80, 8
  %83 = inttoptr i64 %82 to i64*
  store i64 %78, i64* %83
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %84
; # (Ca: fin)
  %85 = getelementptr i8, i8* %6, i32 16
  %86 = ptrtoint i8* %85 to i64
  %87 = inttoptr i64 %86 to i64*
  %88 = load i64, i64* %87
; # (eval (Ca: fin))
  %89 = and i64 %88, 6
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$15, label %$14
$15:
  br label %$13
$14:
  %91 = and i64 %88, 8
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$17, label %$16
$17:
  %93 = inttoptr i64 %88 to i64*
  %94 = load i64, i64* %93
  br label %$13
$16:
  %95 = call i64 @evList(i64 %88)
  br label %$13
$13:
  %96 = phi i64 [%88, %$15], [%94, %$17], [%95, %$16] ; # ->
; # (set $Catch (Ca: link))
; # (Ca: link)
  %97 = bitcast i8* %6 to i8**
  %98 = load i8*, i8** %97
  store i8* %98, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (drop *Safe)
  %99 = inttoptr i64 %80 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %101, i64* %102
  ret i64 %76
}

define void @reentErr(i64, i64) align 8 {
$1:
; # (err Exe Tag ($ "Reentrant coroutine") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([20 x i8]* @$74 to i8*), i8* null)
  unreachable
}

define void @saveCoIO() align 8 {
$1:
; # (val $OutFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # ((ioFrame (val $OutFrames)) fun (val (i8** $Put)))
  %1 = getelementptr i8, i8* %0, i32 16
  %2 = bitcast i8* %1 to i8**
  %3 = bitcast void(i8)** @$Put to i8**
  %4 = load i8*, i8** %3
  store i8* %4, i8** %2
; # (let Io: (ioFrame (val $InFrames)) (Io: fun (val (i8** $Get))) ((...
; # (val $InFrames)
  %5 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (Io: fun (val (i8** $Get)))
  %6 = getelementptr i8, i8* %5, i32 16
  %7 = bitcast i8* %6 to i8**
  %8 = bitcast i32()** @$Get to i8**
  %9 = load i8*, i8** %8
  store i8* %9, i8** %7
; # (Io: file)
  %10 = getelementptr i8, i8* %5, i32 8
  %11 = bitcast i8* %10 to i8**
  %12 = load i8*, i8** %11
; # ((inFile (Io: file)) chr (val $Chr))
  %13 = getelementptr i8, i8* %12, i32 12
  %14 = bitcast i8* %13 to i32*
  %15 = load i32, i32* @$Chr
  store i32 %15, i32* %14
  ret void
}

define void @saveCoEnv(i8*) align 8 {
$1:
; # (let Crt: (coroutine Crt) (Crt: at (val $At)) (putCrtEnv (Crt:)))...
; # (Crt: at (val $At))
  %1 = getelementptr i8, i8* %0, i32 48
  %2 = ptrtoint i8* %1 to i64
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = inttoptr i64 %2 to i64*
  store i64 %4, i64* %5
; # (Crt:)
; # (putCrtEnv (Crt:))
  %6 = getelementptr i8, i8* %0, i32 96
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* %7, i64 144, i1 0)
  %8 = getelementptr i8, i8* %0, i32 240
  %9 = ptrtoint i8* %8 to i64
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %11 = load i64, i64* %10
  %12 = inttoptr i64 %9 to i64*
  store i64 %11, i64* %12
  %13 = getelementptr i8, i8* %0, i32 248
  %14 = ptrtoint i8* %13 to i64
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = inttoptr i64 %14 to i64*
  store i64 %16, i64* %17
  %18 = getelementptr i8, i8* %0, i32 256
  %19 = ptrtoint i8* %18 to i64
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  store i64 %22, i64* %23
  %24 = getelementptr i8, i8* %0, i32 264
  %25 = ptrtoint i8* %24 to i64
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %25 to i64*
  store i64 %27, i64* %28
  %29 = getelementptr i8, i8* %0, i32 272
  %30 = ptrtoint i8* %29 to i64
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %30 to i64*
  store i64 %33, i64* %34
  ret void
}

define i64 @loadCoEnv(i8*) align 8 {
$1:
; # (let Crt: (coroutine (set $Current Crt)) (set $StkLimit (+ (Crt: ...
; # (set $Current Crt)
  store i8* %0, i8** @$Current
; # (set $StkLimit (+ (Crt: lim) 4096))
; # (Crt: lim)
  %1 = getelementptr i8, i8* %0, i32 40
  %2 = bitcast i8* %1 to i8**
  %3 = load i8*, i8** %2
; # (+ (Crt: lim) 4096)
  %4 = getelementptr i8, i8* %3, i32 4096
  store i8* %4, i8** @$StkLimit
; # (Crt:)
; # (getCrtEnv (Crt:))
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i8*
  %6 = getelementptr i8, i8* %0, i32 96
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %5, i8* %6, i64 144, i1 0)
  %7 = getelementptr i8, i8* %0, i32 240
  %8 = ptrtoint i8* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 %10, i64* %11
  %12 = getelementptr i8, i8* %0, i32 248
  %13 = ptrtoint i8* %12 to i64
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  store i64 %15, i64* %16
  %17 = getelementptr i8, i8* %0, i32 256
  %18 = ptrtoint i8* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = getelementptr i8, i8* %0, i32 264
  %24 = ptrtoint i8* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  store i64 %26, i64* %27
  %28 = getelementptr i8, i8* %0, i32 272
  %29 = ptrtoint i8* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %31, i64* %33
; # (tosInFile)
  call void @tosInFile()
; # (tosOutFile)
  call void @tosOutFile()
; # (set $At (Crt: at))
; # (Crt: at)
  %34 = getelementptr i8, i8* %0, i32 48
  %35 = ptrtoint i8* %34 to i64
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %37, i64* %38
; # (Crt: at 0)
  %39 = getelementptr i8, i8* %0, i32 48
  %40 = ptrtoint i8* %39 to i64
  %41 = inttoptr i64 %40 to i64*
  store i64 0, i64* %41
; # (val $Ret)
  %42 = load i64, i64* @$Ret
  ret i64 %42
}

define i64 @_co(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (atom X) (if (val $Current) ((coroutine @) t...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom X) (if (val $Current) ((coroutine @) tag) $Nil) (let Ta...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
; # (if (val $Current) ((coroutine @) tag) $Nil)
; # (val $Current)
  %7 = load i8*, i8** @$Current
  %8 = icmp ne i8* %7, null
  br i1 %8, label %$5, label %$6
$5:
  %9 = phi i64 [%6, %$2] ; # X
; # ((coroutine @) tag)
  %10 = ptrtoint i8* %7 to i64
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
  br label %$7
$6:
  %13 = phi i64 [%6, %$2] ; # X
  br label %$7
$7:
  %14 = phi i64 [%9, %$5], [%13, %$6] ; # X
  %15 = phi i64 [%12, %$5], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$6] ; # ->
  br label %$4
$3:
  %16 = phi i64 [%3, %$1] ; # X
; # (let Tag (eval (++ X)) (cond ((pair X) (unless (val $Coroutines) ...
; # (++ X)
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
  %19 = getelementptr i64, i64* %17, i32 1
  %20 = load i64, i64* %19
; # (eval (++ X))
  %21 = and i64 %18, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$10, label %$9
$10:
  br label %$8
$9:
  %23 = and i64 %18, 8
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = inttoptr i64 %18 to i64*
  %26 = load i64, i64* %25
  br label %$8
$11:
  %27 = call i64 @evList(i64 %18)
  br label %$8
$8:
  %28 = phi i64 [%18, %$10], [%26, %$12], [%27, %$11] ; # ->
; # (cond ((pair X) (unless (val $Coroutines) (let Main: (coroutine (...
; # (pair X)
  %29 = and i64 %20, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$15, label %$14
$15:
  %31 = phi i64 [%20, %$8] ; # X
; # (unless (val $Coroutines) (let Main: (coroutine (alloc null (+ (v...
; # (val $Coroutines)
  %32 = load i8*, i8** @$Coroutines
  %33 = icmp ne i8* %32, null
  br i1 %33, label %$17, label %$16
$16:
  %34 = phi i64 [%31, %$15] ; # X
; # (let Main: (coroutine (alloc null (+ (val JmpBufSize) (coroutine ...
; # (val JmpBufSize)
  %35 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (coroutine T))
  %36 = add i64 %35, 280
; # (alloc null (+ (val JmpBufSize) (coroutine T)))
  %37 = call i8* @alloc(i8* null, i64 %36)
; # (Main: tag $T)
  %38 = ptrtoint i8* %37 to i64
  %39 = inttoptr i64 %38 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), i64* %39
; # (Main: prv null)
  %40 = getelementptr i8, i8* %37, i32 8
  %41 = bitcast i8* %40 to i8**
  store i8* null, i8** %41
; # (Main: nxt null)
  %42 = getelementptr i8, i8* %37, i32 16
  %43 = bitcast i8* %42 to i8**
  store i8* null, i8** %43
; # (Main: org null)
  %44 = getelementptr i8, i8* %37, i32 24
  %45 = bitcast i8* %44 to i8**
  store i8* null, i8** %45
; # (Main: prg $Nil)
  %46 = getelementptr i8, i8* %37, i32 32
  %47 = ptrtoint i8* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %48
; # (let (Siz (val $StkSizeT) Stk (stack)) (memset (Main: lim (stack ...
; # (val $StkSizeT)
  %49 = load i64, i64* @$StkSizeT
; # (stack)
  %50 = call i8* @llvm.stacksave()
; # (Main: lim (stack (ofs Stk (- Siz))))
  %51 = getelementptr i8, i8* %37, i32 40
  %52 = bitcast i8* %51 to i8**
  %53 = sub i64 0, %49
  %54 = getelementptr i8, i8* %50, i64 %53
  call void @llvm.stackrestore(i8* %54)
  store i8* %54, i8** %52
; # (- Siz 256)
  %55 = sub i64 %49, 256
; # (memset (Main: lim (stack (ofs Stk (- Siz)))) 7 (- Siz 256) T)
  call void @llvm.memset.p0i8.i64(i8* align 8 %54, i8 7, i64 %55, i1 0)
; # (stack Stk)
  call void @llvm.stackrestore(i8* %50)
; # (Main: at 0)
  %56 = getelementptr i8, i8* %37, i32 48
  %57 = ptrtoint i8* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 0, i64* %58
; # (set $Coroutines (set $Current (Main:)))
; # (set $Current (Main:))
; # (Main:)
  store i8* %37, i8** @$Current
  store i8* %37, i8** @$Coroutines
  br label %$17
$17:
  %59 = phi i64 [%31, %$15], [%34, %$16] ; # X
; # (let (Src: (coroutine (val $Current)) Crt (val $Coroutines) P (i8...
; # (val $Current)
  %60 = load i8*, i8** @$Current
; # (val $Coroutines)
  %61 = load i8*, i8** @$Coroutines
; # (i8* null)
  %62 = inttoptr i64 0 to i8*
; # (saveCoIO)
  call void @saveCoIO()
; # (Src:)
; # (saveCoEnv (Src:))
  call void @saveCoEnv(i8* %60)
; # (loop (let Crt: (coroutine Crt) (when (== Tag (Crt: tag)) (unless...
  br label %$18
$18:
  %63 = phi i64 [%59, %$17], [%118, %$28] ; # X
  %64 = phi i8* [%61, %$17], [%116, %$28] ; # Crt
  %65 = phi i8* [%62, %$17], [%120, %$28] ; # P
; # (let Crt: (coroutine Crt) (when (== Tag (Crt: tag)) (unless (Crt:...
; # (when (== Tag (Crt: tag)) (unless (Crt: at) (reentErr Exe Tag)) (...
; # (Crt: tag)
  %66 = ptrtoint i8* %64 to i64
  %67 = inttoptr i64 %66 to i64*
  %68 = load i64, i64* %67
; # (== Tag (Crt: tag))
  %69 = icmp eq i64 %28, %68
  br i1 %69, label %$19, label %$20
$19:
  %70 = phi i64 [%63, %$18] ; # X
  %71 = phi i8* [%64, %$18] ; # Crt
  %72 = phi i8* [%65, %$18] ; # P
; # (unless (Crt: at) (reentErr Exe Tag))
; # (Crt: at)
  %73 = getelementptr i8, i8* %64, i32 48
  %74 = ptrtoint i8* %73 to i64
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$22, label %$21
$21:
  %78 = phi i64 [%70, %$19] ; # X
  %79 = phi i8* [%71, %$19] ; # Crt
  %80 = phi i8* [%72, %$19] ; # P
; # (reentErr Exe Tag)
  call void @reentErr(i64 %0, i64 %28)
  unreachable
$22:
  %81 = phi i64 [%70, %$19] ; # X
  %82 = phi i8* [%71, %$19] ; # Crt
  %83 = phi i8* [%72, %$19] ; # P
; # (when (setjmp (Src: (rst))) (ret (loadCoEnv (Src:))))
; # (Src: (rst))
  %84 = getelementptr i8, i8* %60, i32 280
; # (setjmp (Src: (rst)))
  %85 = call i32 @setjmp(i8* %84)
  %86 = icmp ne i32 %85, 0
  br i1 %86, label %$23, label %$24
$23:
  %87 = phi i64 [%81, %$22] ; # X
  %88 = phi i8* [%82, %$22] ; # Crt
  %89 = phi i8* [%83, %$22] ; # P
; # (Src:)
; # (loadCoEnv (Src:))
  %90 = call i64 @loadCoEnv(i8* %60)
; # (ret (loadCoEnv (Src:)))
  ret i64 %90
$24:
  %91 = phi i64 [%81, %$22] ; # X
  %92 = phi i8* [%82, %$22] ; # Crt
  %93 = phi i8* [%83, %$22] ; # P
; # (set $Ret $Nil)
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* @$Ret
; # (Crt: (rst))
  %94 = getelementptr i8, i8* %64, i32 280
; # (longjmp (Crt: (rst)) 1)
  call void @longjmp(i8* %94, i32 1)
  unreachable
$20:
  %95 = phi i64 [%63, %$18] ; # X
  %96 = phi i8* [%64, %$18] ; # Crt
  %97 = phi i8* [%65, %$18] ; # P
; # (or P (Crt: tag) (setq P Crt))
  %98 = icmp ne i8* %97, null
  br i1 %98, label %$25, label %$26
$26:
  %99 = phi i64 [%95, %$20] ; # X
  %100 = phi i8* [%96, %$20] ; # Crt
  %101 = phi i8* [%97, %$20] ; # P
; # (Crt: tag)
  %102 = ptrtoint i8* %64 to i64
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
  %105 = icmp ne i64 %104, 0
  br i1 %105, label %$25, label %$27
$27:
  %106 = phi i64 [%99, %$26] ; # X
  %107 = phi i8* [%100, %$26] ; # Crt
  %108 = phi i8* [%101, %$26] ; # P
  %109 = icmp ne i8* %107, null
  br label %$25
$25:
  %110 = phi i64 [%95, %$20], [%99, %$26], [%106, %$27] ; # X
  %111 = phi i8* [%96, %$20], [%100, %$26], [%107, %$27] ; # Crt
  %112 = phi i8* [%97, %$20], [%101, %$26], [%107, %$27] ; # P
  %113 = phi i1 [1, %$20], [1, %$26], [%109, %$27] ; # ->
; # (? (=0 (Crt: nxt)))
; # (Crt: nxt)
  %114 = getelementptr i8, i8* %64, i32 16
  %115 = bitcast i8* %114 to i8**
  %116 = load i8*, i8** %115
; # (=0 (Crt: nxt))
  %117 = icmp eq i8* %116, null
  br i1 %117, label %$29, label %$28
$28:
  %118 = phi i64 [%110, %$25] ; # X
  %119 = phi i8* [%111, %$25] ; # Crt
  %120 = phi i8* [%112, %$25] ; # P
  br label %$18
$29:
  %121 = phi i64 [%110, %$25] ; # X
  %122 = phi i8* [%111, %$25] ; # Crt
  %123 = phi i8* [%112, %$25] ; # P
  %124 = phi i64 [0, %$25] ; # ->
; # (when (setjmp (Src: (rst))) (ret (loadCoEnv (Src:))))
; # (Src: (rst))
  %125 = getelementptr i8, i8* %60, i32 280
; # (setjmp (Src: (rst)))
  %126 = call i32 @setjmp(i8* %125)
  %127 = icmp ne i32 %126, 0
  br i1 %127, label %$30, label %$31
$30:
  %128 = phi i64 [%121, %$29] ; # X
  %129 = phi i8* [%122, %$29] ; # Crt
  %130 = phi i8* [%123, %$29] ; # P
; # (Src:)
; # (loadCoEnv (Src:))
  %131 = call i64 @loadCoEnv(i8* %60)
; # (ret (loadCoEnv (Src:)))
  ret i64 %131
$31:
  %132 = phi i64 [%121, %$29] ; # X
  %133 = phi i8* [%122, %$29] ; # Crt
  %134 = phi i8* [%123, %$29] ; # P
; # (if P (stack P) (stack ((coroutine Crt) lim)) (setq P (b8 (+ (val...
  %135 = icmp ne i8* %134, null
  br i1 %135, label %$32, label %$33
$32:
  %136 = phi i64 [%132, %$31] ; # X
  %137 = phi i8* [%133, %$31] ; # Crt
  %138 = phi i8* [%134, %$31] ; # P
; # (stack P)
  call void @llvm.stackrestore(i8* %138)
  br label %$34
$33:
  %139 = phi i64 [%132, %$31] ; # X
  %140 = phi i8* [%133, %$31] ; # Crt
  %141 = phi i8* [%134, %$31] ; # P
; # ((coroutine Crt) lim)
  %142 = getelementptr i8, i8* %140, i32 40
  %143 = bitcast i8* %142 to i8**
  %144 = load i8*, i8** %143
; # (stack ((coroutine Crt) lim))
  call void @llvm.stackrestore(i8* %144)
; # (val JmpBufSize)
  %145 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (coroutine T))
  %146 = add i64 %145, 280
; # (b8 (+ (val JmpBufSize) (coroutine T)))
  %147 = alloca i8, i64 %146
; # ((coroutine Crt) nxt P)
  %148 = getelementptr i8, i8* %140, i32 16
  %149 = bitcast i8* %148 to i8**
  store i8* %147, i8** %149
; # ((coroutine P) prv Crt)
  %150 = getelementptr i8, i8* %147, i32 8
  %151 = bitcast i8* %150 to i8**
  store i8* %140, i8** %151
; # ((coroutine P) nxt null)
  %152 = getelementptr i8, i8* %147, i32 16
  %153 = bitcast i8* %152 to i8**
  store i8* null, i8** %153
  br label %$34
$34:
  %154 = phi i64 [%136, %$32], [%139, %$33] ; # X
  %155 = phi i8* [%137, %$32], [%140, %$33] ; # Crt
  %156 = phi i8* [%138, %$32], [%147, %$33] ; # P
  %157 = phi i8* [%138, %$32], [null, %$33] ; # ->
; # (let Dst: (coroutine P) (Dst: tag Tag) (Dst: org (val $Current)) ...
; # (Dst: tag Tag)
  %158 = ptrtoint i8* %156 to i64
  %159 = inttoptr i64 %158 to i64*
  store i64 %28, i64* %159
; # (Dst: org (val $Current))
  %160 = getelementptr i8, i8* %156, i32 24
  %161 = bitcast i8* %160 to i8**
  %162 = load i8*, i8** @$Current
  store i8* %162, i8** %161
; # (Dst: prg X)
  %163 = getelementptr i8, i8* %156, i32 32
  %164 = ptrtoint i8* %163 to i64
  %165 = inttoptr i64 %164 to i64*
  store i64 %154, i64* %165
; # (let (Siz (val $StkSize) Stk (stack)) (memset (Dst: lim (stack (o...
; # (val $StkSize)
  %166 = load i64, i64* @$StkSize
; # (stack)
  %167 = call i8* @llvm.stacksave()
; # (Dst: lim (stack (ofs P (- Siz))))
  %168 = getelementptr i8, i8* %156, i32 40
  %169 = bitcast i8* %168 to i8**
  %170 = sub i64 0, %166
  %171 = getelementptr i8, i8* %156, i64 %170
  call void @llvm.stackrestore(i8* %171)
  store i8* %171, i8** %169
; # (- Siz 256)
  %172 = sub i64 %166, 256
; # (memset (Dst: lim (stack (ofs P (- Siz)))) 7 (- Siz 256) T)
  call void @llvm.memset.p0i8.i64(i8* align 8 %171, i8 7, i64 %172, i1 0)
; # (stack Stk)
  call void @llvm.stackrestore(i8* %167)
; # (Dst: at 0)
  %173 = getelementptr i8, i8* %156, i32 48
  %174 = ptrtoint i8* %173 to i64
  %175 = inttoptr i64 %174 to i64*
  store i64 0, i64* %175
; # (Dst: lnk (val $Link))
  %176 = getelementptr i8, i8* %156, i32 56
  %177 = ptrtoint i8* %176 to i64
  %178 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %179 = load i64, i64* %178
  %180 = inttoptr i64 %177 to i64*
  store i64 %179, i64* %180
; # (Dst: bnd (set $Bind (push ZERO $At (val $Bind) Exe)))
  %181 = getelementptr i8, i8* %156, i32 64
  %182 = ptrtoint i8* %181 to i64
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %184 = load i64, i64* %183
  %185 = alloca i64, i64 4, align 16
  %186 = ptrtoint i64* %185 to i64
  %187 = inttoptr i64 %186 to i64*
  store i64 2, i64* %187
  %188 = add i64 %186, 8
  %189 = inttoptr i64 %188 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), i64* %189
  %190 = add i64 %186, 16
  %191 = inttoptr i64 %190 to i64*
  store i64 %184, i64* %191
  %192 = add i64 %186, 24
  %193 = inttoptr i64 %192 to i64*
  store i64 %0, i64* %193
  %194 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %186, i64* %194
  %195 = inttoptr i64 %182 to i64*
  store i64 %186, i64* %195
; # (Dst: ca (val $Catch))
  %196 = getelementptr i8, i8* %156, i32 72
  %197 = bitcast i8* %196 to i8**
  %198 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
  store i8* %198, i8** %197
; # (Dst: in (val $InFrames))
  %199 = getelementptr i8, i8* %156, i32 80
  %200 = bitcast i8* %199 to i8**
  %201 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
  store i8* %201, i8** %200
; # (Dst: out (val $OutFrames))
  %202 = getelementptr i8, i8* %156, i32 88
  %203 = bitcast i8* %202 to i8**
  %204 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
  store i8* %204, i8** %203
; # (Dst:)
; # (putCrtEnv (Dst:))
  %205 = getelementptr i8, i8* %156, i32 96
  %206 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %205, i8* %206, i64 144, i1 0)
  %207 = getelementptr i8, i8* %156, i32 240
  %208 = ptrtoint i8* %207 to i64
  %209 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %210 = load i64, i64* %209
  %211 = inttoptr i64 %208 to i64*
  store i64 %210, i64* %211
  %212 = getelementptr i8, i8* %156, i32 248
  %213 = ptrtoint i8* %212 to i64
  %214 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %215 = load i64, i64* %214
  %216 = inttoptr i64 %213 to i64*
  store i64 %215, i64* %216
  %217 = getelementptr i8, i8* %156, i32 256
  %218 = ptrtoint i8* %217 to i64
  %219 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 8) to i64) to i64*
  %220 = getelementptr i64, i64* %219, i32 1
  %221 = load i64, i64* %220
  %222 = inttoptr i64 %218 to i64*
  store i64 %221, i64* %222
  %223 = getelementptr i8, i8* %156, i32 264
  %224 = ptrtoint i8* %223 to i64
  %225 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %226 = load i64, i64* %225
  %227 = inttoptr i64 %224 to i64*
  store i64 %226, i64* %227
  %228 = getelementptr i8, i8* %156, i32 272
  %229 = ptrtoint i8* %228 to i64
  %230 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 112) to i64) to i64*
  %231 = getelementptr i64, i64* %230, i32 1
  %232 = load i64, i64* %231
  %233 = inttoptr i64 %229 to i64*
  store i64 %232, i64* %233
; # (set $Next $Nil $Make 0 $Yoke 0 $Current (Dst:) $StkLimit (+ (Dst...
  %234 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %234
  %235 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 0, i64* %235
  %236 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 0, i64* %236
; # (Dst:)
  store i8* %156, i8** @$Current
; # (Dst: lim)
  %237 = getelementptr i8, i8* %156, i32 40
  %238 = bitcast i8* %237 to i8**
  %239 = load i8*, i8** %238
; # (+ (Dst: lim) 4096)
  %240 = getelementptr i8, i8* %239, i32 4096
  store i8* %240, i8** @$StkLimit
; # (set $Ret (run X))
; # (run X)
  br label %$35
$35:
  %241 = phi i64 [%154, %$34], [%263, %$44] ; # Prg
  %242 = inttoptr i64 %241 to i64*
  %243 = load i64, i64* %242
  %244 = getelementptr i64, i64* %242, i32 1
  %245 = load i64, i64* %244
  %246 = and i64 %245, 15
  %247 = icmp ne i64 %246, 0
  br i1 %247, label %$38, label %$36
$38:
  %248 = phi i64 [%245, %$35] ; # Prg
  %249 = and i64 %243, 6
  %250 = icmp ne i64 %249, 0
  br i1 %250, label %$41, label %$40
$41:
  br label %$39
$40:
  %251 = and i64 %243, 8
  %252 = icmp ne i64 %251, 0
  br i1 %252, label %$43, label %$42
$43:
  %253 = inttoptr i64 %243 to i64*
  %254 = load i64, i64* %253
  br label %$39
$42:
  %255 = call i64 @evList(i64 %243)
  br label %$39
$39:
  %256 = phi i64 [%243, %$41], [%254, %$43], [%255, %$42] ; # ->
  br label %$37
$36:
  %257 = phi i64 [%245, %$35] ; # Prg
  %258 = and i64 %243, 15
  %259 = icmp eq i64 %258, 0
  br i1 %259, label %$45, label %$44
$45:
  %260 = phi i64 [%257, %$36] ; # Prg
  %261 = call i64 @evList(i64 %243)
  %262 = icmp ne i64 %261, 0
  br label %$44
$44:
  %263 = phi i64 [%257, %$36], [%260, %$45] ; # Prg
  %264 = phi i1 [0, %$36], [%262, %$45] ; # ->
  br label %$35
$37:
  %265 = phi i64 [%248, %$39] ; # Prg
  %266 = phi i64 [%256, %$39] ; # ->
  store i64 %266, i64* @$Ret
; # (Dst:)
; # (stop (Dst:))
  call void @stop(i8* %156)
; # (Dst: org)
  %267 = getelementptr i8, i8* %156, i32 24
  %268 = bitcast i8* %267 to i8**
  %269 = load i8*, i8** %268
; # ((coroutine (Dst: org)) (rst))
  %270 = getelementptr i8, i8* %269, i32 280
; # (longjmp ((coroutine (Dst: org)) (rst)) 1)
  call void @longjmp(i8* %270, i32 1)
  unreachable
$14:
  %271 = phi i64 [%20, %$8] ; # X
; # (t? Tag)
  %272 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %272, label %$47, label %$46
$47:
  %273 = phi i64 [%271, %$14] ; # X
; # (err Exe 0 ($ "Can't stop main routine") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([24 x i8]* @$75 to i8*), i8* null)
  unreachable
$46:
  %274 = phi i64 [%271, %$14] ; # X
; # (val $Coroutines)
  %275 = load i8*, i8** @$Coroutines
  %276 = icmp ne i8* %275, null
  br i1 %276, label %$49, label %$48
$49:
  %277 = phi i64 [%274, %$46] ; # X
; # (let Crt @ (loop (let Crt: (coroutine Crt) (? (== Tag (Crt: tag))...
; # (loop (let Crt: (coroutine Crt) (? (== Tag (Crt: tag)) (let P (Cr...
  br label %$50
$50:
  %278 = phi i64 [%277, %$49], [%403, %$72] ; # X
  %279 = phi i8* [%275, %$49], [%404, %$72] ; # Crt
; # (let Crt: (coroutine Crt) (? (== Tag (Crt: tag)) (let P (Crt: out...
; # (? (== Tag (Crt: tag)) (let P (Crt: out) (until (== P (val $Stdou...
; # (Crt: tag)
  %280 = ptrtoint i8* %279 to i64
  %281 = inttoptr i64 %280 to i64*
  %282 = load i64, i64* %281
; # (== Tag (Crt: tag))
  %283 = icmp eq i64 %28, %282
  br i1 %283, label %$53, label %$51
$53:
  %284 = phi i64 [%278, %$50] ; # X
  %285 = phi i8* [%279, %$50] ; # Crt
; # (let P (Crt: out) (until (== P (val $Stdout)) (let (Io: (ioFrame ...
; # (Crt: out)
  %286 = getelementptr i8, i8* %279, i32 88
  %287 = bitcast i8* %286 to i8**
  %288 = load i8*, i8** %287
; # (until (== P (val $Stdout)) (let (Io: (ioFrame P) Out: (outFile (...
  br label %$54
$54:
  %289 = phi i64 [%284, %$53], [%334, %$60] ; # X
  %290 = phi i8* [%285, %$53], [%335, %$60] ; # Crt
  %291 = phi i8* [%288, %$53], [%336, %$60] ; # P
; # (val $Stdout)
  %292 = load i8*, i8** @$Stdout
; # (== P (val $Stdout))
  %293 = icmp eq i8* %291, %292
  br i1 %293, label %$56, label %$55
$55:
  %294 = phi i64 [%289, %$54] ; # X
  %295 = phi i8* [%290, %$54] ; # Crt
  %296 = phi i8* [%291, %$54] ; # P
; # (let (Io: (ioFrame P) Out: (outFile (Io: file))) (when (and (ge0 ...
; # (Io: file)
  %297 = getelementptr i8, i8* %296, i32 8
  %298 = bitcast i8* %297 to i8**
  %299 = load i8*, i8** %298
; # (when (and (ge0 (Out: fd)) (Io: pid)) (close (Out: fd)) (closeOut...
; # (and (ge0 (Out: fd)) (Io: pid))
; # (Out: fd)
  %300 = bitcast i8* %299 to i32*
  %301 = load i32, i32* %300
; # (ge0 (Out: fd))
  %302 = icmp sge i32 %301, 0
  br i1 %302, label %$58, label %$57
$58:
  %303 = phi i64 [%294, %$55] ; # X
  %304 = phi i8* [%295, %$55] ; # Crt
  %305 = phi i8* [%296, %$55] ; # P
; # (Io: pid)
  %306 = getelementptr i8, i8* %296, i32 24
  %307 = bitcast i8* %306 to i32*
  %308 = load i32, i32* %307
  %309 = icmp ne i32 %308, 0
  br label %$57
$57:
  %310 = phi i64 [%294, %$55], [%303, %$58] ; # X
  %311 = phi i8* [%295, %$55], [%304, %$58] ; # Crt
  %312 = phi i8* [%296, %$55], [%305, %$58] ; # P
  %313 = phi i1 [0, %$55], [%309, %$58] ; # ->
  br i1 %313, label %$59, label %$60
$59:
  %314 = phi i64 [%310, %$57] ; # X
  %315 = phi i8* [%311, %$57] ; # Crt
  %316 = phi i8* [%312, %$57] ; # P
; # (Out: fd)
  %317 = bitcast i8* %299 to i32*
  %318 = load i32, i32* %317
; # (close (Out: fd))
  %319 = call i32 @close(i32 %318)
; # (Out: fd)
  %320 = bitcast i8* %299 to i32*
  %321 = load i32, i32* %320
; # (closeOutFile (Out: fd))
  call void @closeOutFile(i32 %321)
; # (when (> (Io: pid) 1) (waitFile @))
; # (Io: pid)
  %322 = getelementptr i8, i8* %296, i32 24
  %323 = bitcast i8* %322 to i32*
  %324 = load i32, i32* %323
; # (> (Io: pid) 1)
  %325 = icmp sgt i32 %324, 1
  br i1 %325, label %$61, label %$62
$61:
  %326 = phi i64 [%314, %$59] ; # X
  %327 = phi i8* [%315, %$59] ; # Crt
  %328 = phi i8* [%316, %$59] ; # P
; # (waitFile @)
  call void @waitFile(i32 %324)
  br label %$62
$62:
  %329 = phi i64 [%314, %$59], [%326, %$61] ; # X
  %330 = phi i8* [%315, %$59], [%327, %$61] ; # Crt
  %331 = phi i8* [%316, %$59], [%328, %$61] ; # P
; # (Io: link)
  %332 = bitcast i8* %296 to i8**
  %333 = load i8*, i8** %332
  br label %$60
$60:
  %334 = phi i64 [%310, %$57], [%329, %$62] ; # X
  %335 = phi i8* [%311, %$57], [%330, %$62] ; # Crt
  %336 = phi i8* [%312, %$57], [%333, %$62] ; # P
  br label %$54
$56:
  %337 = phi i64 [%289, %$54] ; # X
  %338 = phi i8* [%290, %$54] ; # Crt
  %339 = phi i8* [%291, %$54] ; # P
; # (let P (Crt: in) (until (== P (val $Stdin)) (let (Io: (ioFrame P)...
; # (Crt: in)
  %340 = getelementptr i8, i8* %279, i32 80
  %341 = bitcast i8* %340 to i8**
  %342 = load i8*, i8** %341
; # (until (== P (val $Stdin)) (let (Io: (ioFrame P) In: (inFile (Io:...
  br label %$63
$63:
  %343 = phi i64 [%337, %$56], [%391, %$69] ; # X
  %344 = phi i8* [%338, %$56], [%392, %$69] ; # Crt
  %345 = phi i8* [%342, %$56], [%393, %$69] ; # P
; # (val $Stdin)
  %346 = load i8*, i8** @$Stdin
; # (== P (val $Stdin))
  %347 = icmp eq i8* %345, %346
  br i1 %347, label %$65, label %$64
$64:
  %348 = phi i64 [%343, %$63] ; # X
  %349 = phi i8* [%344, %$63] ; # Crt
  %350 = phi i8* [%345, %$63] ; # P
; # (let (Io: (ioFrame P) In: (inFile (Io: file))) (when (and (ge0 (I...
; # (Io: file)
  %351 = getelementptr i8, i8* %350, i32 8
  %352 = bitcast i8* %351 to i8**
  %353 = load i8*, i8** %352
; # (when (and (ge0 (In: fd)) (Io: pid)) (close (In: fd)) (closeInFil...
; # (and (ge0 (In: fd)) (Io: pid))
; # (In: fd)
  %354 = getelementptr i8, i8* %353, i32 8
  %355 = bitcast i8* %354 to i32*
  %356 = load i32, i32* %355
; # (ge0 (In: fd))
  %357 = icmp sge i32 %356, 0
  br i1 %357, label %$67, label %$66
$67:
  %358 = phi i64 [%348, %$64] ; # X
  %359 = phi i8* [%349, %$64] ; # Crt
  %360 = phi i8* [%350, %$64] ; # P
; # (Io: pid)
  %361 = getelementptr i8, i8* %350, i32 24
  %362 = bitcast i8* %361 to i32*
  %363 = load i32, i32* %362
  %364 = icmp ne i32 %363, 0
  br label %$66
$66:
  %365 = phi i64 [%348, %$64], [%358, %$67] ; # X
  %366 = phi i8* [%349, %$64], [%359, %$67] ; # Crt
  %367 = phi i8* [%350, %$64], [%360, %$67] ; # P
  %368 = phi i1 [0, %$64], [%364, %$67] ; # ->
  br i1 %368, label %$68, label %$69
$68:
  %369 = phi i64 [%365, %$66] ; # X
  %370 = phi i8* [%366, %$66] ; # Crt
  %371 = phi i8* [%367, %$66] ; # P
; # (In: fd)
  %372 = getelementptr i8, i8* %353, i32 8
  %373 = bitcast i8* %372 to i32*
  %374 = load i32, i32* %373
; # (close (In: fd))
  %375 = call i32 @close(i32 %374)
; # (In: fd)
  %376 = getelementptr i8, i8* %353, i32 8
  %377 = bitcast i8* %376 to i32*
  %378 = load i32, i32* %377
; # (closeInFile (In: fd))
  call void @closeInFile(i32 %378)
; # (when (> (Io: pid) 1) (waitFile @))
; # (Io: pid)
  %379 = getelementptr i8, i8* %350, i32 24
  %380 = bitcast i8* %379 to i32*
  %381 = load i32, i32* %380
; # (> (Io: pid) 1)
  %382 = icmp sgt i32 %381, 1
  br i1 %382, label %$70, label %$71
$70:
  %383 = phi i64 [%369, %$68] ; # X
  %384 = phi i8* [%370, %$68] ; # Crt
  %385 = phi i8* [%371, %$68] ; # P
; # (waitFile @)
  call void @waitFile(i32 %381)
  br label %$71
$71:
  %386 = phi i64 [%369, %$68], [%383, %$70] ; # X
  %387 = phi i8* [%370, %$68], [%384, %$70] ; # Crt
  %388 = phi i8* [%371, %$68], [%385, %$70] ; # P
; # (Io: link)
  %389 = bitcast i8* %350 to i8**
  %390 = load i8*, i8** %389
  br label %$69
$69:
  %391 = phi i64 [%365, %$66], [%386, %$71] ; # X
  %392 = phi i8* [%366, %$66], [%387, %$71] ; # Crt
  %393 = phi i8* [%367, %$66], [%390, %$71] ; # P
  br label %$63
$65:
  %394 = phi i64 [%343, %$63] ; # X
  %395 = phi i8* [%344, %$63] ; # Crt
  %396 = phi i8* [%345, %$63] ; # P
; # (Crt:)
; # (stop (Crt:))
  call void @stop(i8* %279)
  br label %$52
$51:
  %397 = phi i64 [%278, %$50] ; # X
  %398 = phi i8* [%279, %$50] ; # Crt
; # (? (=0 (setq Crt (Crt: nxt))))
; # (Crt: nxt)
  %399 = getelementptr i8, i8* %279, i32 16
  %400 = bitcast i8* %399 to i8**
  %401 = load i8*, i8** %400
; # (=0 (setq Crt (Crt: nxt)))
  %402 = icmp eq i8* %401, null
  br i1 %402, label %$52, label %$72
$72:
  %403 = phi i64 [%397, %$51] ; # X
  %404 = phi i8* [%401, %$51] ; # Crt
  br label %$50
$52:
  %405 = phi i64 [%394, %$65], [%397, %$51] ; # X
  %406 = phi i8* [%395, %$65], [%401, %$51] ; # Crt
  br label %$13
$48:
  %407 = phi i64 [%274, %$46] ; # X
  br label %$13
$13:
  %408 = phi i64 [%405, %$52], [%407, %$48] ; # X
  %409 = phi i64 [%28, %$52], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$48] ; # ->
  br label %$4
$4:
  %410 = phi i64 [%14, %$7], [%408, %$13] ; # X
  %411 = phi i64 [%15, %$7], [%409, %$13] ; # ->
  ret i64 %411
}

define i64 @_yield(i64) align 8 {
$1:
; # (let (X (cdr Exe) Val (save (eval (++ X))) Tag (eval (++ X)) Crt ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (val $Coroutines)
  %36 = load i8*, i8** @$Coroutines
; # (unless Crt (err Exe 0 ($ "No coroutines") null))
  %37 = icmp ne i8* %36, null
  br i1 %37, label %$13, label %$12
$12:
  %38 = phi i8* [%36, %$7] ; # Crt
; # (err Exe 0 ($ "No coroutines") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([14 x i8]* @$76 to i8*), i8* null)
  unreachable
$13:
  %39 = phi i8* [%36, %$7] ; # Crt
; # (let (Src: (coroutine (val $Current)) Dst: (coroutine (cond ((not...
; # (val $Current)
  %40 = load i8*, i8** @$Current
; # (cond ((not (nil? Tag)) (loop (let Crt: (coroutine Crt) (? (== Ta...
; # (nil? Tag)
  %41 = icmp eq i64 %35, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Tag))
  %42 = icmp eq i1 %41, 0
  br i1 %42, label %$16, label %$15
$16:
  %43 = phi i8* [%39, %$13] ; # Crt
; # (loop (let Crt: (coroutine Crt) (? (== Tag (Crt: tag)) (unless (C...
  br label %$17
$17:
  %44 = phi i8* [%43, %$16], [%63, %$24] ; # Crt
; # (let Crt: (coroutine Crt) (? (== Tag (Crt: tag)) (unless (Crt: at...
; # (? (== Tag (Crt: tag)) (unless (Crt: at) (reentErr Exe Tag)) Crt)...
; # (Crt: tag)
  %45 = ptrtoint i8* %44 to i64
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (== Tag (Crt: tag))
  %48 = icmp eq i64 %35, %47
  br i1 %48, label %$20, label %$18
$20:
  %49 = phi i8* [%44, %$17] ; # Crt
; # (unless (Crt: at) (reentErr Exe Tag))
; # (Crt: at)
  %50 = getelementptr i8, i8* %44, i32 48
  %51 = ptrtoint i8* %50 to i64
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$22, label %$21
$21:
  %55 = phi i8* [%49, %$20] ; # Crt
; # (reentErr Exe Tag)
  call void @reentErr(i64 %0, i64 %35)
  unreachable
$22:
  %56 = phi i8* [%49, %$20] ; # Crt
  br label %$19
$18:
  %57 = phi i8* [%44, %$17] ; # Crt
; # (unless (setq Crt (Crt: nxt)) (err Exe Tag ($ "Coroutine not foun...
; # (Crt: nxt)
  %58 = getelementptr i8, i8* %44, i32 16
  %59 = bitcast i8* %58 to i8**
  %60 = load i8*, i8** %59
  %61 = icmp ne i8* %60, null
  br i1 %61, label %$24, label %$23
$23:
  %62 = phi i8* [%60, %$18] ; # Crt
; # (err Exe Tag ($ "Coroutine not found") null)
  call void @err(i64 %0, i64 %35, i8* bitcast ([20 x i8]* @$77 to i8*), i8* null)
  unreachable
$24:
  %63 = phi i8* [%60, %$18] ; # Crt
  br label %$17
$19:
  %64 = phi i8* [%56, %$22] ; # Crt
  %65 = phi i8* [%56, %$22] ; # ->
  br label %$14
$15:
  %66 = phi i8* [%39, %$13] ; # Crt
; # (Src: org)
  %67 = getelementptr i8, i8* %40, i32 24
  %68 = bitcast i8* %67 to i8**
  %69 = load i8*, i8** %68
  %70 = icmp ne i8* %69, null
  br i1 %70, label %$26, label %$25
$26:
  %71 = phi i8* [%66, %$15] ; # Crt
  br label %$14
$25:
  %72 = phi i8* [%66, %$15] ; # Crt
; # (err Exe 0 ($ "Tag expected") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([13 x i8]* @$78 to i8*), i8* null)
  unreachable
$14:
  %73 = phi i8* [%64, %$19], [%71, %$26] ; # Crt
  %74 = phi i8* [%65, %$19], [%69, %$26] ; # ->
; # (any 0)
; # (any 0)
; # (i8* null)
  %75 = inttoptr i64 0 to i8*
; # (val $Stdin)
  %76 = load i8*, i8** @$Stdin
; # (val $Stdout)
  %77 = load i8*, i8** @$Stdout
; # (saveCoIO)
  call void @saveCoIO()
; # (unless (t? (Src: tag)) (let P (val $Link) (until (== P (Src: lnk...
; # (Src: tag)
  %78 = ptrtoint i8* %40 to i64
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
; # (t? (Src: tag))
  %81 = icmp eq i64 %80, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %81, label %$28, label %$27
$27:
  %82 = phi i8* [%73, %$14] ; # Crt
  %83 = phi i64 [0, %$14] ; # Lnk
  %84 = phi i64 [0, %$14] ; # Bnd
  %85 = phi i8* [%75, %$14] ; # Ca
  %86 = phi i8* [%76, %$14] ; # In
  %87 = phi i8* [%77, %$14] ; # Out
; # (let P (val $Link) (until (== P (Src: lnk)) (let Q P (setq P (val...
; # (val $Link)
  %88 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %89 = load i64, i64* %88
; # (until (== P (Src: lnk)) (let Q P (setq P (val 2 Q)) (set 2 Q Lnk...
  br label %$29
$29:
  %90 = phi i8* [%82, %$27], [%102, %$30] ; # Crt
  %91 = phi i64 [%83, %$27], [%108, %$30] ; # Lnk
  %92 = phi i64 [%84, %$27], [%104, %$30] ; # Bnd
  %93 = phi i8* [%85, %$27], [%105, %$30] ; # Ca
  %94 = phi i8* [%86, %$27], [%106, %$30] ; # In
  %95 = phi i8* [%87, %$27], [%107, %$30] ; # Out
  %96 = phi i64 [%89, %$27], [%111, %$30] ; # P
; # (Src: lnk)
  %97 = getelementptr i8, i8* %40, i32 56
  %98 = ptrtoint i8* %97 to i64
  %99 = inttoptr i64 %98 to i64*
  %100 = load i64, i64* %99
; # (== P (Src: lnk))
  %101 = icmp eq i64 %96, %100
  br i1 %101, label %$31, label %$30
$30:
  %102 = phi i8* [%90, %$29] ; # Crt
  %103 = phi i64 [%91, %$29] ; # Lnk
  %104 = phi i64 [%92, %$29] ; # Bnd
  %105 = phi i8* [%93, %$29] ; # Ca
  %106 = phi i8* [%94, %$29] ; # In
  %107 = phi i8* [%95, %$29] ; # Out
  %108 = phi i64 [%96, %$29] ; # P
; # (let Q P (setq P (val 2 Q)) (set 2 Q Lnk) (setq Lnk Q))
; # (val 2 Q)
  %109 = inttoptr i64 %108 to i64*
  %110 = getelementptr i64, i64* %109, i32 1
  %111 = load i64, i64* %110
; # (set 2 Q Lnk)
  %112 = inttoptr i64 %108 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  store i64 %103, i64* %113
  br label %$29
$31:
  %114 = phi i8* [%90, %$29] ; # Crt
  %115 = phi i64 [%91, %$29] ; # Lnk
  %116 = phi i64 [%92, %$29] ; # Bnd
  %117 = phi i8* [%93, %$29] ; # Ca
  %118 = phi i8* [%94, %$29] ; # In
  %119 = phi i8* [%95, %$29] ; # Out
  %120 = phi i64 [%96, %$29] ; # P
; # (let P (val $Bind) (until (== P (Src: bnd)) (let Q P (xchg (val 2...
; # (val $Bind)
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %122 = load i64, i64* %121
; # (until (== P (Src: bnd)) (let Q P (xchg (val 2 Q) Q) (setq P (val...
  br label %$32
$32:
  %123 = phi i8* [%114, %$31], [%135, %$33] ; # Crt
  %124 = phi i64 [%115, %$31], [%136, %$33] ; # Lnk
  %125 = phi i64 [%116, %$31], [%141, %$33] ; # Bnd
  %126 = phi i8* [%117, %$31], [%138, %$33] ; # Ca
  %127 = phi i8* [%118, %$31], [%139, %$33] ; # In
  %128 = phi i8* [%119, %$31], [%140, %$33] ; # Out
  %129 = phi i64 [%122, %$31], [%151, %$33] ; # P
; # (Src: bnd)
  %130 = getelementptr i8, i8* %40, i32 64
  %131 = ptrtoint i8* %130 to i64
  %132 = inttoptr i64 %131 to i64*
  %133 = load i64, i64* %132
; # (== P (Src: bnd))
  %134 = icmp eq i64 %129, %133
  br i1 %134, label %$34, label %$33
$33:
  %135 = phi i8* [%123, %$32] ; # Crt
  %136 = phi i64 [%124, %$32] ; # Lnk
  %137 = phi i64 [%125, %$32] ; # Bnd
  %138 = phi i8* [%126, %$32] ; # Ca
  %139 = phi i8* [%127, %$32] ; # In
  %140 = phi i8* [%128, %$32] ; # Out
  %141 = phi i64 [%129, %$32] ; # P
; # (let Q P (xchg (val 2 Q) Q) (setq P (val 3 Q)) (set 3 Q Bnd) (set...
; # (val 2 Q)
  %142 = inttoptr i64 %141 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  %144 = load i64, i64* %143
; # (xchg (val 2 Q) Q)
  %145 = inttoptr i64 %144 to i64*
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %141 to i64*
  %148 = load i64, i64* %147
  store i64 %148, i64* %145
  store i64 %146, i64* %147
; # (val 3 Q)
  %149 = inttoptr i64 %141 to i64*
  %150 = getelementptr i64, i64* %149, i32 2
  %151 = load i64, i64* %150
; # (set 3 Q Bnd)
  %152 = inttoptr i64 %141 to i64*
  %153 = getelementptr i64, i64* %152, i32 2
  store i64 %137, i64* %153
  br label %$32
$34:
  %154 = phi i8* [%123, %$32] ; # Crt
  %155 = phi i64 [%124, %$32] ; # Lnk
  %156 = phi i64 [%125, %$32] ; # Bnd
  %157 = phi i8* [%126, %$32] ; # Ca
  %158 = phi i8* [%127, %$32] ; # In
  %159 = phi i8* [%128, %$32] ; # Out
  %160 = phi i64 [%129, %$32] ; # P
; # (set 3 (Src: bnd) Bnd)
; # (Src: bnd)
  %161 = getelementptr i8, i8* %40, i32 64
  %162 = ptrtoint i8* %161 to i64
  %163 = inttoptr i64 %162 to i64*
  %164 = load i64, i64* %163
  %165 = inttoptr i64 %164 to i64*
  %166 = getelementptr i64, i64* %165, i32 2
  store i64 %156, i64* %166
; # (let P (val $Catch) (until (== P (Src: ca)) (let Ca: (caFrame P) ...
; # (val $Catch)
  %167 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (until (== P (Src: ca)) (let Ca: (caFrame P) (setq P (Ca: link)) ...
  br label %$35
$35:
  %168 = phi i8* [%154, %$34], [%179, %$36] ; # Crt
  %169 = phi i64 [%155, %$34], [%180, %$36] ; # Lnk
  %170 = phi i64 [%156, %$34], [%181, %$36] ; # Bnd
  %171 = phi i8* [%157, %$34], [%185, %$36] ; # Ca
  %172 = phi i8* [%158, %$34], [%183, %$36] ; # In
  %173 = phi i8* [%159, %$34], [%184, %$36] ; # Out
  %174 = phi i8* [%167, %$34], [%187, %$36] ; # P
; # (Src: ca)
  %175 = getelementptr i8, i8* %40, i32 72
  %176 = bitcast i8* %175 to i8**
  %177 = load i8*, i8** %176
; # (== P (Src: ca))
  %178 = icmp eq i8* %174, %177
  br i1 %178, label %$37, label %$36
$36:
  %179 = phi i8* [%168, %$35] ; # Crt
  %180 = phi i64 [%169, %$35] ; # Lnk
  %181 = phi i64 [%170, %$35] ; # Bnd
  %182 = phi i8* [%171, %$35] ; # Ca
  %183 = phi i8* [%172, %$35] ; # In
  %184 = phi i8* [%173, %$35] ; # Out
  %185 = phi i8* [%174, %$35] ; # P
; # (let Ca: (caFrame P) (setq P (Ca: link)) (Ca: link Ca) (setq Ca (...
; # (Ca: link)
  %186 = bitcast i8* %185 to i8**
  %187 = load i8*, i8** %186
; # (Ca: link Ca)
  %188 = bitcast i8* %185 to i8**
  store i8* %182, i8** %188
; # (Ca:)
  br label %$35
$37:
  %189 = phi i8* [%168, %$35] ; # Crt
  %190 = phi i64 [%169, %$35] ; # Lnk
  %191 = phi i64 [%170, %$35] ; # Bnd
  %192 = phi i8* [%171, %$35] ; # Ca
  %193 = phi i8* [%172, %$35] ; # In
  %194 = phi i8* [%173, %$35] ; # Out
  %195 = phi i8* [%174, %$35] ; # P
; # (let P (val $InFrames) (until (== P (Src: in)) (let In: (ioFrame ...
; # (val $InFrames)
  %196 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (until (== P (Src: in)) (let In: (ioFrame P) (setq P (In: link)) ...
  br label %$38
$38:
  %197 = phi i8* [%189, %$37], [%208, %$39] ; # Crt
  %198 = phi i64 [%190, %$37], [%209, %$39] ; # Lnk
  %199 = phi i64 [%191, %$37], [%210, %$39] ; # Bnd
  %200 = phi i8* [%192, %$37], [%211, %$39] ; # Ca
  %201 = phi i8* [%193, %$37], [%214, %$39] ; # In
  %202 = phi i8* [%194, %$37], [%213, %$39] ; # Out
  %203 = phi i8* [%196, %$37], [%216, %$39] ; # P
; # (Src: in)
  %204 = getelementptr i8, i8* %40, i32 80
  %205 = bitcast i8* %204 to i8**
  %206 = load i8*, i8** %205
; # (== P (Src: in))
  %207 = icmp eq i8* %203, %206
  br i1 %207, label %$40, label %$39
$39:
  %208 = phi i8* [%197, %$38] ; # Crt
  %209 = phi i64 [%198, %$38] ; # Lnk
  %210 = phi i64 [%199, %$38] ; # Bnd
  %211 = phi i8* [%200, %$38] ; # Ca
  %212 = phi i8* [%201, %$38] ; # In
  %213 = phi i8* [%202, %$38] ; # Out
  %214 = phi i8* [%203, %$38] ; # P
; # (let In: (ioFrame P) (setq P (In: link)) (In: link In) (setq In (...
; # (In: link)
  %215 = bitcast i8* %214 to i8**
  %216 = load i8*, i8** %215
; # (In: link In)
  %217 = bitcast i8* %214 to i8**
  store i8* %212, i8** %217
; # (In:)
  br label %$38
$40:
  %218 = phi i8* [%197, %$38] ; # Crt
  %219 = phi i64 [%198, %$38] ; # Lnk
  %220 = phi i64 [%199, %$38] ; # Bnd
  %221 = phi i8* [%200, %$38] ; # Ca
  %222 = phi i8* [%201, %$38] ; # In
  %223 = phi i8* [%202, %$38] ; # Out
  %224 = phi i8* [%203, %$38] ; # P
; # (Src: in In)
  %225 = getelementptr i8, i8* %40, i32 80
  %226 = bitcast i8* %225 to i8**
  store i8* %222, i8** %226
; # (let P (val $OutFrames) (until (== P (Src: out)) (let Out: (ioFra...
; # (val $OutFrames)
  %227 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (until (== P (Src: out)) (let Out: (ioFrame P) (setq P (Out: link...
  br label %$41
$41:
  %228 = phi i8* [%218, %$40], [%239, %$42] ; # Crt
  %229 = phi i64 [%219, %$40], [%240, %$42] ; # Lnk
  %230 = phi i64 [%220, %$40], [%241, %$42] ; # Bnd
  %231 = phi i8* [%221, %$40], [%242, %$42] ; # Ca
  %232 = phi i8* [%222, %$40], [%243, %$42] ; # In
  %233 = phi i8* [%223, %$40], [%245, %$42] ; # Out
  %234 = phi i8* [%227, %$40], [%247, %$42] ; # P
; # (Src: out)
  %235 = getelementptr i8, i8* %40, i32 88
  %236 = bitcast i8* %235 to i8**
  %237 = load i8*, i8** %236
; # (== P (Src: out))
  %238 = icmp eq i8* %234, %237
  br i1 %238, label %$43, label %$42
$42:
  %239 = phi i8* [%228, %$41] ; # Crt
  %240 = phi i64 [%229, %$41] ; # Lnk
  %241 = phi i64 [%230, %$41] ; # Bnd
  %242 = phi i8* [%231, %$41] ; # Ca
  %243 = phi i8* [%232, %$41] ; # In
  %244 = phi i8* [%233, %$41] ; # Out
  %245 = phi i8* [%234, %$41] ; # P
; # (let Out: (ioFrame P) (setq P (Out: link)) (Out: link Out) (setq ...
; # (Out: link)
  %246 = bitcast i8* %245 to i8**
  %247 = load i8*, i8** %246
; # (Out: link Out)
  %248 = bitcast i8* %245 to i8**
  store i8* %244, i8** %248
; # (Out:)
  br label %$41
$43:
  %249 = phi i8* [%228, %$41] ; # Crt
  %250 = phi i64 [%229, %$41] ; # Lnk
  %251 = phi i64 [%230, %$41] ; # Bnd
  %252 = phi i8* [%231, %$41] ; # Ca
  %253 = phi i8* [%232, %$41] ; # In
  %254 = phi i8* [%233, %$41] ; # Out
  %255 = phi i8* [%234, %$41] ; # P
; # (Src: out Out)
  %256 = getelementptr i8, i8* %40, i32 88
  %257 = bitcast i8* %256 to i8**
  store i8* %254, i8** %257
  br label %$28
$28:
  %258 = phi i8* [%73, %$14], [%249, %$43] ; # Crt
  %259 = phi i64 [0, %$14], [%250, %$43] ; # Lnk
  %260 = phi i64 [0, %$14], [%251, %$43] ; # Bnd
  %261 = phi i8* [%75, %$14], [%252, %$43] ; # Ca
  %262 = phi i8* [%76, %$14], [%253, %$43] ; # In
  %263 = phi i8* [%77, %$14], [%254, %$43] ; # Out
; # (Src:)
; # (saveCoEnv (Src:))
  call void @saveCoEnv(i8* %40)
; # (unless (setjmp (Src: (rst))) (set $Ret Val) (longjmp (Dst: (rst)...
; # (Src: (rst))
  %264 = getelementptr i8, i8* %40, i32 280
; # (setjmp (Src: (rst)))
  %265 = call i32 @setjmp(i8* %264)
  %266 = icmp ne i32 %265, 0
  br i1 %266, label %$45, label %$44
$44:
  %267 = phi i8* [%258, %$28] ; # Crt
  %268 = phi i64 [%259, %$28] ; # Lnk
  %269 = phi i64 [%260, %$28] ; # Bnd
  %270 = phi i8* [%261, %$28] ; # Ca
  %271 = phi i8* [%262, %$28] ; # In
  %272 = phi i8* [%263, %$28] ; # Out
; # (set $Ret Val)
  store i64 %15, i64* @$Ret
; # (Dst: (rst))
  %273 = getelementptr i8, i8* %74, i32 280
; # (longjmp (Dst: (rst)) 1)
  call void @longjmp(i8* %273, i32 1)
  unreachable
$45:
  %274 = phi i8* [%258, %$28] ; # Crt
  %275 = phi i64 [%259, %$28] ; # Lnk
  %276 = phi i64 [%260, %$28] ; # Bnd
  %277 = phi i8* [%261, %$28] ; # Ca
  %278 = phi i8* [%262, %$28] ; # In
  %279 = phi i8* [%263, %$28] ; # Out
; # (unless (t? (Src: tag)) (let P (val $OutFrames) (Src: out P) (unt...
; # (Src: tag)
  %280 = ptrtoint i8* %40 to i64
  %281 = inttoptr i64 %280 to i64*
  %282 = load i64, i64* %281
; # (t? (Src: tag))
  %283 = icmp eq i64 %282, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %283, label %$47, label %$46
$46:
  %284 = phi i8* [%274, %$45] ; # Crt
  %285 = phi i64 [%275, %$45] ; # Lnk
  %286 = phi i64 [%276, %$45] ; # Bnd
  %287 = phi i8* [%277, %$45] ; # Ca
  %288 = phi i8* [%278, %$45] ; # In
  %289 = phi i8* [%279, %$45] ; # Out
; # (let P (val $OutFrames) (Src: out P) (until (== Out (val $Stdout)...
; # (val $OutFrames)
  %290 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (Src: out P)
  %291 = getelementptr i8, i8* %40, i32 88
  %292 = bitcast i8* %291 to i8**
  store i8* %290, i8** %292
; # (until (== Out (val $Stdout)) (let Out: (ioFrame Out) (setq Out (...
  br label %$48
$48:
  %293 = phi i8* [%284, %$46], [%302, %$49] ; # Crt
  %294 = phi i64 [%285, %$46], [%303, %$49] ; # Lnk
  %295 = phi i64 [%286, %$46], [%304, %$49] ; # Bnd
  %296 = phi i8* [%287, %$46], [%305, %$49] ; # Ca
  %297 = phi i8* [%288, %$46], [%306, %$49] ; # In
  %298 = phi i8* [%289, %$46], [%310, %$49] ; # Out
  %299 = phi i8* [%290, %$46], [%307, %$49] ; # P
; # (val $Stdout)
  %300 = load i8*, i8** @$Stdout
; # (== Out (val $Stdout))
  %301 = icmp eq i8* %298, %300
  br i1 %301, label %$50, label %$49
$49:
  %302 = phi i8* [%293, %$48] ; # Crt
  %303 = phi i64 [%294, %$48] ; # Lnk
  %304 = phi i64 [%295, %$48] ; # Bnd
  %305 = phi i8* [%296, %$48] ; # Ca
  %306 = phi i8* [%297, %$48] ; # In
  %307 = phi i8* [%298, %$48] ; # Out
  %308 = phi i8* [%299, %$48] ; # P
; # (let Out: (ioFrame Out) (setq Out (Out: link)) (Out: link P) (set...
; # (Out: link)
  %309 = bitcast i8* %307 to i8**
  %310 = load i8*, i8** %309
; # (Out: link P)
  %311 = bitcast i8* %307 to i8**
  store i8* %308, i8** %311
; # (Out:)
  br label %$48
$50:
  %312 = phi i8* [%293, %$48] ; # Crt
  %313 = phi i64 [%294, %$48] ; # Lnk
  %314 = phi i64 [%295, %$48] ; # Bnd
  %315 = phi i8* [%296, %$48] ; # Ca
  %316 = phi i8* [%297, %$48] ; # In
  %317 = phi i8* [%298, %$48] ; # Out
  %318 = phi i8* [%299, %$48] ; # P
; # (Src: (env $OutFrames i8*) P)
  %319 = getelementptr i8, i8* %40, i32 96
  %320 = getelementptr i8, i8* %319, i32 40
  %321 = bitcast i8* %320 to i8**
  store i8* %318, i8** %321
; # (let P (val $InFrames) (Src: in P) (until (== In (val $Stdin)) (l...
; # (val $InFrames)
  %322 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (Src: in P)
  %323 = getelementptr i8, i8* %40, i32 80
  %324 = bitcast i8* %323 to i8**
  store i8* %322, i8** %324
; # (until (== In (val $Stdin)) (let In: (ioFrame In) (setq In (In: l...
  br label %$51
$51:
  %325 = phi i8* [%312, %$50], [%334, %$52] ; # Crt
  %326 = phi i64 [%313, %$50], [%335, %$52] ; # Lnk
  %327 = phi i64 [%314, %$50], [%336, %$52] ; # Bnd
  %328 = phi i8* [%315, %$50], [%337, %$52] ; # Ca
  %329 = phi i8* [%316, %$50], [%342, %$52] ; # In
  %330 = phi i8* [%317, %$50], [%339, %$52] ; # Out
  %331 = phi i8* [%322, %$50], [%338, %$52] ; # P
; # (val $Stdin)
  %332 = load i8*, i8** @$Stdin
; # (== In (val $Stdin))
  %333 = icmp eq i8* %329, %332
  br i1 %333, label %$53, label %$52
$52:
  %334 = phi i8* [%325, %$51] ; # Crt
  %335 = phi i64 [%326, %$51] ; # Lnk
  %336 = phi i64 [%327, %$51] ; # Bnd
  %337 = phi i8* [%328, %$51] ; # Ca
  %338 = phi i8* [%329, %$51] ; # In
  %339 = phi i8* [%330, %$51] ; # Out
  %340 = phi i8* [%331, %$51] ; # P
; # (let In: (ioFrame In) (setq In (In: link)) (In: link P) (setq P (...
; # (In: link)
  %341 = bitcast i8* %338 to i8**
  %342 = load i8*, i8** %341
; # (In: link P)
  %343 = bitcast i8* %338 to i8**
  store i8* %340, i8** %343
; # (In:)
  br label %$51
$53:
  %344 = phi i8* [%325, %$51] ; # Crt
  %345 = phi i64 [%326, %$51] ; # Lnk
  %346 = phi i64 [%327, %$51] ; # Bnd
  %347 = phi i8* [%328, %$51] ; # Ca
  %348 = phi i8* [%329, %$51] ; # In
  %349 = phi i8* [%330, %$51] ; # Out
  %350 = phi i8* [%331, %$51] ; # P
; # (Src: (env $InFrames i8*) P)
  %351 = getelementptr i8, i8* %40, i32 96
  %352 = getelementptr i8, i8* %351, i32 32
  %353 = bitcast i8* %352 to i8**
  store i8* %350, i8** %353
; # (let P (val $Catch) (Src: ca P) (while Ca (let Ca: (caFrame Ca) (...
; # (val $Catch)
  %354 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 24) to i8**)
; # (Src: ca P)
  %355 = getelementptr i8, i8* %40, i32 72
  %356 = bitcast i8* %355 to i8**
  store i8* %354, i8** %356
; # (while Ca (let Ca: (caFrame Ca) (setq Ca (Ca: link)) (Ca: link P)...
  br label %$54
$54:
  %357 = phi i8* [%344, %$53], [%365, %$55] ; # Crt
  %358 = phi i64 [%345, %$53], [%366, %$55] ; # Lnk
  %359 = phi i64 [%346, %$53], [%367, %$55] ; # Bnd
  %360 = phi i8* [%347, %$53], [%373, %$55] ; # Ca
  %361 = phi i8* [%348, %$53], [%369, %$55] ; # In
  %362 = phi i8* [%349, %$53], [%370, %$55] ; # Out
  %363 = phi i8* [%354, %$53], [%368, %$55] ; # P
  %364 = icmp ne i8* %360, null
  br i1 %364, label %$55, label %$56
$55:
  %365 = phi i8* [%357, %$54] ; # Crt
  %366 = phi i64 [%358, %$54] ; # Lnk
  %367 = phi i64 [%359, %$54] ; # Bnd
  %368 = phi i8* [%360, %$54] ; # Ca
  %369 = phi i8* [%361, %$54] ; # In
  %370 = phi i8* [%362, %$54] ; # Out
  %371 = phi i8* [%363, %$54] ; # P
; # (let Ca: (caFrame Ca) (setq Ca (Ca: link)) (Ca: link P) (setq P (...
; # (Ca: link)
  %372 = bitcast i8* %368 to i8**
  %373 = load i8*, i8** %372
; # (Ca: link P)
  %374 = bitcast i8* %368 to i8**
  store i8* %371, i8** %374
; # (Ca:)
  br label %$54
$56:
  %375 = phi i8* [%357, %$54] ; # Crt
  %376 = phi i64 [%358, %$54] ; # Lnk
  %377 = phi i64 [%359, %$54] ; # Bnd
  %378 = phi i8* [%360, %$54] ; # Ca
  %379 = phi i8* [%361, %$54] ; # In
  %380 = phi i8* [%362, %$54] ; # Out
  %381 = phi i8* [%363, %$54] ; # P
; # (Src: (env $Catch i8*) P)
  %382 = getelementptr i8, i8* %40, i32 96
  %383 = getelementptr i8, i8* %382, i32 24
  %384 = bitcast i8* %383 to i8**
  store i8* %381, i8** %384
; # (let P (val $Bind) (set 3 (Src: bnd) P) (setq P (Src: bnd)) (Src:...
; # (val $Bind)
  %385 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %386 = load i64, i64* %385
; # (set 3 (Src: bnd) P)
; # (Src: bnd)
  %387 = getelementptr i8, i8* %40, i32 64
  %388 = ptrtoint i8* %387 to i64
  %389 = inttoptr i64 %388 to i64*
  %390 = load i64, i64* %389
  %391 = inttoptr i64 %390 to i64*
  %392 = getelementptr i64, i64* %391, i32 2
  store i64 %386, i64* %392
; # (Src: bnd)
  %393 = getelementptr i8, i8* %40, i32 64
  %394 = ptrtoint i8* %393 to i64
  %395 = inttoptr i64 %394 to i64*
  %396 = load i64, i64* %395
; # (Src: bnd P)
  %397 = getelementptr i8, i8* %40, i32 64
  %398 = ptrtoint i8* %397 to i64
  %399 = inttoptr i64 %398 to i64*
  store i64 %396, i64* %399
; # (while Bnd (let Q Bnd (xchg (val 2 Q) Q) (setq Bnd (val 3 Q)) (se...
  br label %$57
$57:
  %400 = phi i8* [%375, %$56], [%408, %$58] ; # Crt
  %401 = phi i64 [%376, %$56], [%409, %$58] ; # Lnk
  %402 = phi i64 [%377, %$56], [%424, %$58] ; # Bnd
  %403 = phi i8* [%378, %$56], [%411, %$58] ; # Ca
  %404 = phi i8* [%379, %$56], [%412, %$58] ; # In
  %405 = phi i8* [%380, %$56], [%413, %$58] ; # Out
  %406 = phi i64 [%396, %$56], [%410, %$58] ; # P
  %407 = icmp ne i64 %402, 0
  br i1 %407, label %$58, label %$59
$58:
  %408 = phi i8* [%400, %$57] ; # Crt
  %409 = phi i64 [%401, %$57] ; # Lnk
  %410 = phi i64 [%402, %$57] ; # Bnd
  %411 = phi i8* [%403, %$57] ; # Ca
  %412 = phi i8* [%404, %$57] ; # In
  %413 = phi i8* [%405, %$57] ; # Out
  %414 = phi i64 [%406, %$57] ; # P
; # (let Q Bnd (xchg (val 2 Q) Q) (setq Bnd (val 3 Q)) (set 3 Q P) (s...
; # (val 2 Q)
  %415 = inttoptr i64 %410 to i64*
  %416 = getelementptr i64, i64* %415, i32 1
  %417 = load i64, i64* %416
; # (xchg (val 2 Q) Q)
  %418 = inttoptr i64 %417 to i64*
  %419 = load i64, i64* %418
  %420 = inttoptr i64 %410 to i64*
  %421 = load i64, i64* %420
  store i64 %421, i64* %418
  store i64 %419, i64* %420
; # (val 3 Q)
  %422 = inttoptr i64 %410 to i64*
  %423 = getelementptr i64, i64* %422, i32 2
  %424 = load i64, i64* %423
; # (set 3 Q P)
  %425 = inttoptr i64 %410 to i64*
  %426 = getelementptr i64, i64* %425, i32 2
  store i64 %414, i64* %426
  br label %$57
$59:
  %427 = phi i8* [%400, %$57] ; # Crt
  %428 = phi i64 [%401, %$57] ; # Lnk
  %429 = phi i64 [%402, %$57] ; # Bnd
  %430 = phi i8* [%403, %$57] ; # Ca
  %431 = phi i8* [%404, %$57] ; # In
  %432 = phi i8* [%405, %$57] ; # Out
  %433 = phi i64 [%406, %$57] ; # P
; # (Src: (env $Bind any) P)
  %434 = getelementptr i8, i8* %40, i32 96
  %435 = getelementptr i8, i8* %434, i32 8
  %436 = ptrtoint i8* %435 to i64
  %437 = inttoptr i64 %436 to i64*
  store i64 %433, i64* %437
; # (let P (val $Link) (Src: lnk P) (while Lnk (let Q Lnk (setq Lnk (...
; # (val $Link)
  %438 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %439 = load i64, i64* %438
; # (Src: lnk P)
  %440 = getelementptr i8, i8* %40, i32 56
  %441 = ptrtoint i8* %440 to i64
  %442 = inttoptr i64 %441 to i64*
  store i64 %439, i64* %442
; # (while Lnk (let Q Lnk (setq Lnk (val 2 Q)) (set 2 Q P) (setq P Q)...
  br label %$60
$60:
  %443 = phi i8* [%427, %$59], [%451, %$61] ; # Crt
  %444 = phi i64 [%428, %$59], [%460, %$61] ; # Lnk
  %445 = phi i64 [%429, %$59], [%453, %$61] ; # Bnd
  %446 = phi i8* [%430, %$59], [%454, %$61] ; # Ca
  %447 = phi i8* [%431, %$59], [%455, %$61] ; # In
  %448 = phi i8* [%432, %$59], [%456, %$61] ; # Out
  %449 = phi i64 [%439, %$59], [%452, %$61] ; # P
  %450 = icmp ne i64 %444, 0
  br i1 %450, label %$61, label %$62
$61:
  %451 = phi i8* [%443, %$60] ; # Crt
  %452 = phi i64 [%444, %$60] ; # Lnk
  %453 = phi i64 [%445, %$60] ; # Bnd
  %454 = phi i8* [%446, %$60] ; # Ca
  %455 = phi i8* [%447, %$60] ; # In
  %456 = phi i8* [%448, %$60] ; # Out
  %457 = phi i64 [%449, %$60] ; # P
; # (let Q Lnk (setq Lnk (val 2 Q)) (set 2 Q P) (setq P Q))
; # (val 2 Q)
  %458 = inttoptr i64 %452 to i64*
  %459 = getelementptr i64, i64* %458, i32 1
  %460 = load i64, i64* %459
; # (set 2 Q P)
  %461 = inttoptr i64 %452 to i64*
  %462 = getelementptr i64, i64* %461, i32 1
  store i64 %457, i64* %462
  br label %$60
$62:
  %463 = phi i8* [%443, %$60] ; # Crt
  %464 = phi i64 [%444, %$60] ; # Lnk
  %465 = phi i64 [%445, %$60] ; # Bnd
  %466 = phi i8* [%446, %$60] ; # Ca
  %467 = phi i8* [%447, %$60] ; # In
  %468 = phi i8* [%448, %$60] ; # Out
  %469 = phi i64 [%449, %$60] ; # P
; # (Src: (env $Link any) P)
  %470 = getelementptr i8, i8* %40, i32 96
  %471 = ptrtoint i8* %470 to i64
  %472 = inttoptr i64 %471 to i64*
  store i64 %469, i64* %472
  br label %$47
$47:
  %473 = phi i8* [%274, %$45], [%463, %$62] ; # Crt
  %474 = phi i64 [%275, %$45], [%464, %$62] ; # Lnk
  %475 = phi i64 [%276, %$45], [%465, %$62] ; # Bnd
  %476 = phi i8* [%277, %$45], [%466, %$62] ; # Ca
  %477 = phi i8* [%278, %$45], [%467, %$62] ; # In
  %478 = phi i8* [%279, %$45], [%468, %$62] ; # Out
; # (Src:)
; # (loadCoEnv (Src:))
  %479 = call i64 @loadCoEnv(i8* %40)
; # (drop *Safe)
  %480 = inttoptr i64 %19 to i64*
  %481 = getelementptr i64, i64* %480, i32 1
  %482 = load i64, i64* %481
  %483 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %482, i64* %483
  ret i64 %479
}

define i64 @brkLoad(i64) align 8 {
$1:
; # (when (and ((inFile (val (val $InFiles))) tty) ((outFile (val 2 (...
; # (and ((inFile (val (val $InFiles))) tty) ((outFile (val 2 (val $O...
; # (val $InFiles)
  %1 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %2 = load i8*, i8** %1
; # ((inFile (val (val $InFiles))) tty)
  %3 = getelementptr i8, i8* %2, i32 4128
  %4 = bitcast i8* %3 to i1*
  %5 = load i1, i1* %4
  br i1 %5, label %$3, label %$2
$3:
  %6 = phi i64 [%0, %$1] ; # Exe
; # (val $OutFiles)
  %7 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %8 = getelementptr i8*, i8** %7, i32 1
  %9 = load i8*, i8** %8
; # ((outFile (val 2 (val $OutFiles))) tty)
  %10 = getelementptr i8, i8* %9, i32 4104
  %11 = bitcast i8* %10 to i1*
  %12 = load i1, i1* %11
  br i1 %12, label %$4, label %$2
$4:
  %13 = phi i64 [%6, %$3] ; # Exe
; # (val $Break)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 16) to i64) to i64*
  %15 = load i64, i64* %14
; # (=0 (val $Break))
  %16 = icmp eq i64 %15, 0
  br label %$2
$2:
  %17 = phi i64 [%0, %$1], [%6, %$3], [%13, %$4] ; # Exe
  %18 = phi i1 [0, %$1], [0, %$3], [%16, %$4] ; # ->
  br i1 %18, label %$5, label %$6
$5:
  %19 = phi i64 [%17, %$2] ; # Exe
; # (let P (val $Bind) (setq P (push (val $At) $At P 0)) (setq P (pus...
; # (val $Bind)
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %21 = load i64, i64* %20
; # (val $At)
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %23 = load i64, i64* %22
; # (push (val $At) $At P 0)
  %24 = alloca i64, i64 4, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 %23, i64* %26
  %27 = add i64 %25, 8
  %28 = inttoptr i64 %27 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), i64* %28
  %29 = add i64 %25, 16
  %30 = inttoptr i64 %29 to i64*
  store i64 %21, i64* %30
  %31 = add i64 %25, 24
  %32 = inttoptr i64 %31 to i64*
  store i64 0, i64* %32
; # (val $Up)
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64) to i64*
  %34 = load i64, i64* %33
; # (push (val $Up) $Up P)
  %35 = alloca i64, i64 3, align 16
  %36 = ptrtoint i64* %35 to i64
  %37 = inttoptr i64 %36 to i64*
  store i64 %34, i64* %37
  %38 = add i64 %36, 8
  %39 = inttoptr i64 %38 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64), i64* %39
  %40 = add i64 %36, 16
  %41 = inttoptr i64 %40 to i64*
  store i64 %25, i64* %41
; # (set $Up Exe)
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64) to i64*
  store i64 %19, i64* %42
; # (set $Break (set $Bind (push (val $Run) $Run P)))
; # (set $Bind (push (val $Run) $Run P))
; # (val $Run)
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  %44 = load i64, i64* %43
; # (push (val $Run) $Run P)
  %45 = alloca i64, i64 3, align 16
  %46 = ptrtoint i64* %45 to i64
  %47 = inttoptr i64 %46 to i64*
  store i64 %44, i64* %47
  %48 = add i64 %46, 8
  %49 = inttoptr i64 %48 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64), i64* %49
  %50 = add i64 %46, 16
  %51 = inttoptr i64 %50 to i64*
  store i64 %36, i64* %51
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %46, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 16) to i64) to i64*
  store i64 %46, i64* %53
; # (set $Run $Nil)
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %54
; # (let Raw (val Termio) (setCooked) (pushOutFile (b8 (ioFrame T)) (...
; # (val Termio)
  %55 = load i8*, i8** @Termio
; # (setCooked)
  call void @setCooked()
; # (b8 (ioFrame T))
  %56 = alloca i8, i64 28
; # (val $OutFiles)
  %57 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %58 = getelementptr i8*, i8** %57, i32 1
  %59 = load i8*, i8** %58
; # (pushOutFile (b8 (ioFrame T)) (val 2 (val $OutFiles)) 0)
  call void @pushOutFile(i8* %56, i8* %59, i32 0)
; # (print Exe)
  call void @print(i64 %19)
; # (newline)
  call void @newline()
; # (repl 0 ($ "! ") $Nil)
  %60 = call i64 @repl(i64 0, i8* bitcast ([3 x i8]* @$79 to i8*), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (popOutFiles)
  call void @popOutFiles()
; # (tosOutFile)
  call void @tosOutFile()
; # (when Raw (setRaw))
  %61 = icmp ne i8* %55, null
  br i1 %61, label %$7, label %$8
$7:
  %62 = phi i64 [%19, %$5] ; # Exe
; # (setRaw)
  call void @setRaw()
  br label %$8
$8:
  %63 = phi i64 [%19, %$5], [%62, %$7] ; # Exe
; # (val $Up)
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64) to i64*
  %65 = load i64, i64* %64
; # (let P (val $Bind) (set $Run (val P)) (setq P (val 3 P)) (set $Up...
; # (val $Bind)
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %67 = load i64, i64* %66
; # (set $Run (val P))
; # (val P)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  store i64 %69, i64* %70
; # (val 3 P)
  %71 = inttoptr i64 %67 to i64*
  %72 = getelementptr i64, i64* %71, i32 2
  %73 = load i64, i64* %72
; # (set $Up (val P))
; # (val P)
  %74 = inttoptr i64 %73 to i64*
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64) to i64*
  store i64 %75, i64* %76
; # (val 3 P)
  %77 = inttoptr i64 %73 to i64*
  %78 = getelementptr i64, i64* %77, i32 2
  %79 = load i64, i64* %78
; # (set $At (val P))
; # (val P)
  %80 = inttoptr i64 %79 to i64*
  %81 = load i64, i64* %80
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %81, i64* %82
; # (set $Bind (val 3 P))
; # (val 3 P)
  %83 = inttoptr i64 %79 to i64*
  %84 = getelementptr i64, i64* %83, i32 2
  %85 = load i64, i64* %84
  %86 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %85, i64* %86
; # (set $Break 0)
  %87 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 16) to i64) to i64*
  store i64 0, i64* %87
  br label %$6
$6:
  %88 = phi i64 [%17, %$2], [%65, %$8] ; # Exe
  ret i64 %88
}

define i64 @_break(i64) align 8 {
$1:
; # (let X (cdr Exe) (unless (nil? (val $Dbg)) (setq X (brkLoad X))) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (nil? (val $Dbg)) (setq X (brkLoad X)))
; # (val $Dbg)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64) to i64*
  %5 = load i64, i64* %4
; # (nil? (val $Dbg))
  %6 = icmp eq i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (brkLoad X)
  %8 = call i64 @brkLoad(i64 %7)
  br label %$3
$3:
  %9 = phi i64 [%3, %$1], [%8, %$2] ; # X
; # (eval X)
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  br label %$4
$5:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$8, label %$7
$8:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$4
$7:
  %16 = call i64 @evList(i64 %9)
  br label %$4
$4:
  %17 = phi i64 [%9, %$6], [%15, %$8], [%16, %$7] ; # ->
  ret i64 %17
}

define i64 @_e(i64) align 8 {
$1:
; # (let P (val $Break) (unless P (err Exe 0 ($ "No Break") null)) (l...
; # (val $Break)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 16) to i64) to i64*
  %2 = load i64, i64* %1
; # (unless P (err Exe 0 ($ "No Break") null))
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (err Exe 0 ($ "No Break") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([9 x i8]* @$80 to i8*), i8* null)
  unreachable
$3:
; # (let (Dbg (save (val $Dbg)) At (save (val $At)) Run (save (val $R...
; # (val $Dbg)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64) to i64*
  %5 = load i64, i64* %4
; # (save (val $Dbg))
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = alloca i64, i64 2, align 16
  %9 = ptrtoint i64* %8 to i64
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = add i64 %9, 8
  %12 = inttoptr i64 %11 to i64*
  store i64 %7, i64* %12
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %9, i64* %13
; # (val $At)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %15 = load i64, i64* %14
; # (save (val $At))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (val $Run)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  %25 = load i64, i64* %24
; # (save (val $Run))
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %25, i64* %30
  %31 = add i64 %29, 8
  %32 = inttoptr i64 %31 to i64*
  store i64 %27, i64* %32
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %33
; # (set $Dbg $Nil $Run (val P) $At (val (val 3 (val 3 P))))
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %34
; # (val P)
  %35 = inttoptr i64 %2 to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  store i64 %36, i64* %37
; # (val 3 P)
  %38 = inttoptr i64 %2 to i64*
  %39 = getelementptr i64, i64* %38, i32 2
  %40 = load i64, i64* %39
; # (val 3 (val 3 P))
  %41 = inttoptr i64 %40 to i64*
  %42 = getelementptr i64, i64* %41, i32 2
  %43 = load i64, i64* %42
; # (val (val 3 (val 3 P)))
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %45, i64* %46
; # (let (In: (ioFrame (val $InFrames)) Out: (ioFrame (val $OutFrames...
; # (val $InFrames)
  %47 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (val $OutFrames)
  %48 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (popInFiles)
  call void @popInFiles()
; # (tosInFile)
  call void @tosInFile()
; # (popOutFiles)
  call void @popOutFiles()
; # (tosOutFile)
  call void @tosOutFile()
; # (prog1 (if (pair (cdr Exe)) (run @) (eval (val $Up))) (pushOutFil...
; # (if (pair (cdr Exe)) (run @) (eval (val $Up)))
; # (cdr Exe)
  %49 = inttoptr i64 %0 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (pair (cdr Exe))
  %52 = and i64 %51, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$4, label %$5
$4:
; # (run @)
  br label %$7
$7:
  %54 = phi i64 [%51, %$4], [%76, %$16] ; # Prg
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
  %57 = getelementptr i64, i64* %55, i32 1
  %58 = load i64, i64* %57
  %59 = and i64 %58, 15
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$10, label %$8
$10:
  %61 = phi i64 [%58, %$7] ; # Prg
  %62 = and i64 %56, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$13, label %$12
$13:
  br label %$11
$12:
  %64 = and i64 %56, 8
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$15, label %$14
$15:
  %66 = inttoptr i64 %56 to i64*
  %67 = load i64, i64* %66
  br label %$11
$14:
  %68 = call i64 @evList(i64 %56)
  br label %$11
$11:
  %69 = phi i64 [%56, %$13], [%67, %$15], [%68, %$14] ; # ->
  br label %$9
$8:
  %70 = phi i64 [%58, %$7] ; # Prg
  %71 = and i64 %56, 15
  %72 = icmp eq i64 %71, 0
  br i1 %72, label %$17, label %$16
$17:
  %73 = phi i64 [%70, %$8] ; # Prg
  %74 = call i64 @evList(i64 %56)
  %75 = icmp ne i64 %74, 0
  br label %$16
$16:
  %76 = phi i64 [%70, %$8], [%73, %$17] ; # Prg
  %77 = phi i1 [0, %$8], [%75, %$17] ; # ->
  br label %$7
$9:
  %78 = phi i64 [%61, %$11] ; # Prg
  %79 = phi i64 [%69, %$11] ; # ->
  br label %$6
$5:
; # (val $Up)
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64) to i64*
  %81 = load i64, i64* %80
; # (eval (val $Up))
  %82 = and i64 %81, 6
  %83 = icmp ne i64 %82, 0
  br i1 %83, label %$20, label %$19
$20:
  br label %$18
$19:
  %84 = and i64 %81, 8
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$22, label %$21
$22:
  %86 = inttoptr i64 %81 to i64*
  %87 = load i64, i64* %86
  br label %$18
$21:
  %88 = call i64 @evList(i64 %81)
  br label %$18
$18:
  %89 = phi i64 [%81, %$20], [%87, %$22], [%88, %$21] ; # ->
  br label %$6
$6:
  %90 = phi i64 [%79, %$9], [%89, %$18] ; # ->
; # (Out:)
; # (Out: file)
  %91 = getelementptr i8, i8* %48, i32 8
  %92 = bitcast i8* %91 to i8**
  %93 = load i8*, i8** %92
; # (Out: pid)
  %94 = getelementptr i8, i8* %48, i32 24
  %95 = bitcast i8* %94 to i32*
  %96 = load i32, i32* %95
; # (pushOutFile (Out:) (Out: file) (Out: pid))
  call void @pushOutFile(i8* %48, i8* %93, i32 %96)
; # (In:)
; # (In: file)
  %97 = getelementptr i8, i8* %47, i32 8
  %98 = bitcast i8* %97 to i8**
  %99 = load i8*, i8** %98
; # (In: pid)
  %100 = getelementptr i8, i8* %47, i32 24
  %101 = bitcast i8* %100 to i32*
  %102 = load i32, i32* %101
; # (pushInFile (In:) (In: file) (In: pid))
  call void @pushInFile(i8* %47, i8* %99, i32 %102)
; # (set $Run Run $At At $Dbg Dbg)
  %103 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  store i64 %25, i64* %103
  %104 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %104
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64) to i64*
  store i64 %5, i64* %105
; # (drop *Safe)
  %106 = inttoptr i64 %9 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
  %109 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %108, i64* %109
  ret i64 %90
}

define void @trace(i32, i64) align 8 {
$1:
; # (when (> C 64) (setq C 64))
; # (> C 64)
  %2 = icmp sgt i32 %0, 64
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i32 [%0, %$1] ; # C
  br label %$3
$3:
  %4 = phi i32 [%0, %$1], [64, %$2] ; # C
; # (while (ge0 (dec 'C)) (space))
  br label %$4
$4:
  %5 = phi i32 [%4, %$3], [%8, %$5] ; # C
; # (dec 'C)
  %6 = sub i32 %5, 1
; # (ge0 (dec 'C))
  %7 = icmp sge i32 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i32 [%6, %$4] ; # C
; # (space)
  call void @space()
  br label %$4
$6:
  %9 = phi i32 [%6, %$4] ; # C
; # (if (atom X) (print @) (print (car X)) (space) (print (cdr X)) (s...
; # (atom X)
  %10 = and i64 %1, 15
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$7, label %$8
$7:
  %12 = phi i32 [%9, %$6] ; # C
; # (print @)
  call void @print(i64 %1)
  br label %$9
$8:
  %13 = phi i32 [%9, %$6] ; # C
; # (car X)
  %14 = inttoptr i64 %1 to i64*
  %15 = load i64, i64* %14
; # (print (car X))
  call void @print(i64 %15)
; # (space)
  call void @space()
; # (cdr X)
  %16 = inttoptr i64 %1 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (print (cdr X))
  call void @print(i64 %18)
; # (space)
  call void @space()
; # (val $This)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %20 = load i64, i64* %19
; # (print (val $This))
  call void @print(i64 %20)
  br label %$9
$9:
  %21 = phi i32 [%12, %$7], [%13, %$8] ; # C
  ret void
}

define i64 @_trace(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (nil? (val $Dbg)) (run (cddr X)) (let (Out (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (val $Dbg)) (run (cddr X)) (let (Out (val $OutFile) Put...
; # (val $Dbg)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64) to i64*
  %5 = load i64, i64* %4
; # (nil? (val $Dbg))
  %6 = icmp eq i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %6, label %$2, label %$3
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (cddr X)
  %8 = inttoptr i64 %7 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
; # (run (cddr X))
  br label %$5
$5:
  %14 = phi i64 [%13, %$2], [%36, %$14] ; # Prg
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
  %17 = getelementptr i64, i64* %15, i32 1
  %18 = load i64, i64* %17
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$8, label %$6
$8:
  %21 = phi i64 [%18, %$5] ; # Prg
  %22 = and i64 %16, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$11:
  br label %$9
$10:
  %24 = and i64 %16, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$13, label %$12
$13:
  %26 = inttoptr i64 %16 to i64*
  %27 = load i64, i64* %26
  br label %$9
$12:
  %28 = call i64 @evList(i64 %16)
  br label %$9
$9:
  %29 = phi i64 [%16, %$11], [%27, %$13], [%28, %$12] ; # ->
  br label %$7
$6:
  %30 = phi i64 [%18, %$5] ; # Prg
  %31 = and i64 %16, 15
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = phi i64 [%30, %$6] ; # Prg
  %34 = call i64 @evList(i64 %16)
  %35 = icmp ne i64 %34, 0
  br label %$14
$14:
  %36 = phi i64 [%30, %$6], [%33, %$15] ; # Prg
  %37 = phi i1 [0, %$6], [%35, %$15] ; # ->
  br label %$5
$7:
  %38 = phi i64 [%21, %$9] ; # Prg
  %39 = phi i64 [%29, %$9] ; # ->
  br label %$4
$3:
  %40 = phi i64 [%3, %$1] ; # X
; # (let (Out (val $OutFile) Put (val (i8** $Put))) (set $OutFile (va...
; # (val $OutFile)
  %41 = load i8*, i8** @$OutFile
; # (i8** $Put)
  %42 = bitcast void(i8)** @$Put to i8**
; # (val (i8** $Put))
  %43 = load i8*, i8** %42
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %44 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %45 = getelementptr i8*, i8** %44, i32 2
  %46 = load i8*, i8** %45
  store i8* %46, i8** @$OutFile
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$Put
; # (let (Y (++ X) Z (++ X)) (trace (set $Trace (inc (val $Trace))) Y...
; # (++ X)
  %47 = inttoptr i64 %40 to i64*
  %48 = load i64, i64* %47
  %49 = getelementptr i64, i64* %47, i32 1
  %50 = load i64, i64* %49
; # (++ X)
  %51 = inttoptr i64 %50 to i64*
  %52 = load i64, i64* %51
  %53 = getelementptr i64, i64* %51, i32 1
  %54 = load i64, i64* %53
; # (set $Trace (inc (val $Trace)))
; # (val $Trace)
  %55 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 136) to i32*)
; # (inc (val $Trace))
  %56 = add i32 %55, 1
  store i32 %56, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 136) to i32*)
; # (trace (set $Trace (inc (val $Trace))) Y)
  call void @trace(i32 %56, i64 %48)
; # (outString ($ " :"))
  call void @outString(i8* bitcast ([3 x i8]* @$81 to i8*))
; # (while (pair Z) (space) (print (val (++ Z))))
  br label %$16
$16:
  %57 = phi i64 [%54, %$3], [%61, %$17] ; # X
  %58 = phi i64 [%52, %$3], [%66, %$17] ; # Z
; # (pair Z)
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$17, label %$18
$17:
  %61 = phi i64 [%57, %$16] ; # X
  %62 = phi i64 [%58, %$16] ; # Z
; # (space)
  call void @space()
; # (++ Z)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  %65 = getelementptr i64, i64* %63, i32 1
  %66 = load i64, i64* %65
; # (val (++ Z))
  %67 = inttoptr i64 %64 to i64*
  %68 = load i64, i64* %67
; # (print (val (++ Z)))
  call void @print(i64 %68)
  br label %$16
$18:
  %69 = phi i64 [%57, %$16] ; # X
  %70 = phi i64 [%58, %$16] ; # Z
; # (cond ((== Z $At) (setq Z (val $Next)) (while (pair Z) (space) (p...
; # (== Z $At)
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64)
  br i1 %71, label %$21, label %$20
$21:
  %72 = phi i64 [%69, %$18] ; # X
  %73 = phi i64 [%70, %$18] ; # Z
; # (val $Next)
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %75 = load i64, i64* %74
; # (while (pair Z) (space) (print (cdr Z)) (setq Z (car Z)))
  br label %$22
$22:
  %76 = phi i64 [%72, %$21], [%80, %$23] ; # X
  %77 = phi i64 [%75, %$21], [%86, %$23] ; # Z
; # (pair Z)
  %78 = and i64 %77, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$23, label %$24
$23:
  %80 = phi i64 [%76, %$22] ; # X
  %81 = phi i64 [%77, %$22] ; # Z
; # (space)
  call void @space()
; # (cdr Z)
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (print (cdr Z))
  call void @print(i64 %84)
; # (car Z)
  %85 = inttoptr i64 %81 to i64*
  %86 = load i64, i64* %85
  br label %$22
$24:
  %87 = phi i64 [%76, %$22] ; # X
  %88 = phi i64 [%77, %$22] ; # Z
  br label %$19
$20:
  %89 = phi i64 [%69, %$18] ; # X
  %90 = phi i64 [%70, %$18] ; # Z
; # (nil? Z)
  %91 = icmp eq i64 %90, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Z))
  %92 = icmp eq i1 %91, 0
  br i1 %92, label %$26, label %$25
$26:
  %93 = phi i64 [%89, %$20] ; # X
  %94 = phi i64 [%90, %$20] ; # Z
; # (space)
  call void @space()
; # (val Z)
  %95 = inttoptr i64 %94 to i64*
  %96 = load i64, i64* %95
; # (print (val Z))
  call void @print(i64 %96)
  br label %$19
$25:
  %97 = phi i64 [%89, %$20] ; # X
  %98 = phi i64 [%90, %$20] ; # Z
  br label %$19
$19:
  %99 = phi i64 [%87, %$24], [%93, %$26], [%97, %$25] ; # X
  %100 = phi i64 [%88, %$24], [%94, %$26], [%98, %$25] ; # Z
; # (newline)
  call void @newline()
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %101 = bitcast void(i8)** @$Put to i8**
  store i8* %43, i8** %101
  store i8* %41, i8** @$OutFile
; # (prog1 (run X) (set $OutFile (val 3 (val $OutFiles)) $Put (fun (v...
; # (run X)
  br label %$27
$27:
  %102 = phi i64 [%99, %$19], [%124, %$36] ; # Prg
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
  %105 = getelementptr i64, i64* %103, i32 1
  %106 = load i64, i64* %105
  %107 = and i64 %106, 15
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$30, label %$28
$30:
  %109 = phi i64 [%106, %$27] ; # Prg
  %110 = and i64 %104, 6
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$33, label %$32
$33:
  br label %$31
$32:
  %112 = and i64 %104, 8
  %113 = icmp ne i64 %112, 0
  br i1 %113, label %$35, label %$34
$35:
  %114 = inttoptr i64 %104 to i64*
  %115 = load i64, i64* %114
  br label %$31
$34:
  %116 = call i64 @evList(i64 %104)
  br label %$31
$31:
  %117 = phi i64 [%104, %$33], [%115, %$35], [%116, %$34] ; # ->
  br label %$29
$28:
  %118 = phi i64 [%106, %$27] ; # Prg
  %119 = and i64 %104, 15
  %120 = icmp eq i64 %119, 0
  br i1 %120, label %$37, label %$36
$37:
  %121 = phi i64 [%118, %$28] ; # Prg
  %122 = call i64 @evList(i64 %104)
  %123 = icmp ne i64 %122, 0
  br label %$36
$36:
  %124 = phi i64 [%118, %$28], [%121, %$37] ; # Prg
  %125 = phi i1 [0, %$28], [%123, %$37] ; # ->
  br label %$27
$29:
  %126 = phi i64 [%109, %$31] ; # Prg
  %127 = phi i64 [%117, %$31] ; # ->
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %128 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %129 = getelementptr i8*, i8** %128, i32 2
  %130 = load i8*, i8** %129
  store i8* %130, i8** @$OutFile
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$Put
; # (let I (val $Trace) (trace I Y) (set $Trace (dec I)))
; # (val $Trace)
  %131 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 136) to i32*)
; # (trace I Y)
  call void @trace(i32 %131, i64 %48)
; # (set $Trace (dec I))
; # (dec I)
  %132 = sub i32 %131, 1
  store i32 %132, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 136) to i32*)
; # (outString ($ " = "))
  call void @outString(i8* bitcast ([4 x i8]* @$82 to i8*))
; # (print @)
  call void @print(i64 %127)
; # (newline)
  call void @newline()
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %133 = bitcast void(i8)** @$Put to i8**
  store i8* %43, i8** %133
  store i8* %41, i8** @$OutFile
  br label %$4
$4:
  %134 = phi i64 [%7, %$7], [%99, %$29] ; # X
  %135 = phi i64 [%39, %$7], [%127, %$29] ; # ->
  ret i64 %135
}

define i64 @_exec(i64) align 8 {
$1:
; # (let (X (cdr Exe) Av (b8* (inc (length X))) Cmd (xName Exe (evSym...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (length X)
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%13, %$3] ; # X
  %5 = phi i64 [0, %$1], [%10, %$3] ; # N
  %6 = and i64 %4, 15
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %$3, label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
  %9 = phi i64 [%5, %$2] ; # N
  %10 = add i64 %9, 1
  %11 = inttoptr i64 %8 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  br label %$2
$4:
  %14 = phi i64 [%4, %$2] ; # X
  %15 = phi i64 [%5, %$2] ; # N
; # (inc (length X))
  %16 = add i64 %15, 1
; # (b8* (inc (length X)))
  %17 = alloca i8*, i64 %16
; # (evSym X)
  %18 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %19 = call i64 @xName(i64 %0, i64 %18)
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %20 = call i64 @pathSize(i64 %19)
; # (b8 (pathSize Cmd))
  %21 = alloca i8, i64 %20
; # (pathString Cmd (b8 (pathSize Cmd)))
  %22 = call i8* @pathString(i64 %19, i8* %21)
  store i8* %22, i8** %17
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (...
; # (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (set (inc '...
  br label %$5
$5:
  %23 = phi i64 [%3, %$4], [%30, %$6] ; # X
  %24 = phi i8** [%17, %$4], [%34, %$6] ; # A
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$6, label %$7
$6:
  %30 = phi i64 [%27, %$5] ; # X
  %31 = phi i8** [%24, %$5] ; # A
; # (let Nm (xName Exe (evSym X)) (set (inc 'A) (bufString Nm (b8 (bu...
; # (evSym X)
  %32 = call i64 @evSym(i64 %30)
; # (xName Exe (evSym X))
  %33 = call i64 @xName(i64 %0, i64 %32)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %34 = getelementptr i8*, i8** %31, i32 1
; # (bufSize Nm)
  %35 = call i64 @bufSize(i64 %33)
; # (b8 (bufSize Nm))
  %36 = alloca i8, i64 %35
; # (bufString Nm (b8 (bufSize Nm)))
  %37 = call i8* @bufString(i64 %33, i8* %36)
  store i8* %37, i8** %34
  br label %$5
$7:
  %38 = phi i64 [%27, %$5] ; # X
  %39 = phi i8** [%24, %$5] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %40 = getelementptr i8*, i8** %39, i32 1
  store i8* null, i8** %40
; # (flushAll)
  call void @flushAll()
; # (val Av)
  %41 = load i8*, i8** %17
; # (execvp (val Av) Av)
  %42 = call i32 @execvp(i8* %41, i8** %17)
; # (val Av)
  %43 = load i8*, i8** %17
; # (execErr (val Av))
  call void @execErr(i8* %43)
  unreachable
}

define i64 @_call(i64) align 8 {
$1:
; # (let (X (cdr Exe) Av (b8* (inc (length X))) Cmd (xName Exe (evSym...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (length X)
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%13, %$3] ; # X
  %5 = phi i64 [0, %$1], [%10, %$3] ; # N
  %6 = and i64 %4, 15
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %$3, label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
  %9 = phi i64 [%5, %$2] ; # N
  %10 = add i64 %9, 1
  %11 = inttoptr i64 %8 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  br label %$2
$4:
  %14 = phi i64 [%4, %$2] ; # X
  %15 = phi i64 [%5, %$2] ; # N
; # (inc (length X))
  %16 = add i64 %15, 1
; # (b8* (inc (length X)))
  %17 = alloca i8*, i64 %16
; # (evSym X)
  %18 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %19 = call i64 @xName(i64 %0, i64 %18)
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %20 = call i64 @pathSize(i64 %19)
; # (b8 (pathSize Cmd))
  %21 = alloca i8, i64 %20
; # (pathString Cmd (b8 (pathSize Cmd)))
  %22 = call i8* @pathString(i64 %19, i8* %21)
  store i8* %22, i8** %17
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (...
; # (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (set (inc '...
  br label %$5
$5:
  %23 = phi i64 [%3, %$4], [%30, %$6] ; # X
  %24 = phi i8** [%17, %$4], [%34, %$6] ; # A
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$6, label %$7
$6:
  %30 = phi i64 [%27, %$5] ; # X
  %31 = phi i8** [%24, %$5] ; # A
; # (let Nm (xName Exe (evSym X)) (set (inc 'A) (bufString Nm (b8 (bu...
; # (evSym X)
  %32 = call i64 @evSym(i64 %30)
; # (xName Exe (evSym X))
  %33 = call i64 @xName(i64 %0, i64 %32)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %34 = getelementptr i8*, i8** %31, i32 1
; # (bufSize Nm)
  %35 = call i64 @bufSize(i64 %33)
; # (b8 (bufSize Nm))
  %36 = alloca i8, i64 %35
; # (bufString Nm (b8 (bufSize Nm)))
  %37 = call i8* @bufString(i64 %33, i8* %36)
  store i8* %37, i8** %34
  br label %$5
$7:
  %38 = phi i64 [%27, %$5] ; # X
  %39 = phi i8** [%24, %$5] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %40 = getelementptr i8*, i8** %39, i32 1
  store i8* null, i8** %40
; # (flushAll)
  call void @flushAll()
; # (let (Tc (tcgetpgrp 0) Fg (and (val Tio) (== Tc (getpgrp)))) (con...
; # (tcgetpgrp 0)
  %41 = call i32 @tcgetpgrp(i32 0)
; # (and (val Tio) (== Tc (getpgrp)))
; # (val Tio)
  %42 = load i1, i1* @Tio
  br i1 %42, label %$9, label %$8
$9:
  %43 = phi i64 [%38, %$7] ; # X
; # (getpgrp)
  %44 = call i32 @getpgrp()
; # (== Tc (getpgrp))
  %45 = icmp eq i32 %41, %44
  br label %$8
$8:
  %46 = phi i64 [%38, %$7], [%43, %$9] ; # X
  %47 = phi i1 [0, %$7], [%45, %$9] ; # ->
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (setpgid 0 0) (when Fg...
; # (fork)
  %48 = call i32 @fork()
; # (lt0 (fork))
  %49 = icmp slt i32 %48, 0
  br i1 %49, label %$12, label %$11
$12:
  %50 = phi i64 [%46, %$8] ; # X
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$11:
  %51 = phi i64 [%46, %$8] ; # X
; # (=0 @)
  %52 = icmp eq i32 %48, 0
  br i1 %52, label %$14, label %$13
$14:
  %53 = phi i64 [%51, %$11] ; # X
; # (setpgid 0 0)
  %54 = call i32 @setpgid(i32 0, i32 0)
; # (when Fg (tcsetpgrp 0 (getpid)))
  br i1 %47, label %$15, label %$16
$15:
  %55 = phi i64 [%53, %$14] ; # X
; # (getpid)
  %56 = call i32 @getpid()
; # (tcsetpgrp 0 (getpid))
  %57 = call i32 @tcsetpgrp(i32 0, i32 %56)
  br label %$16
$16:
  %58 = phi i64 [%53, %$14], [%55, %$15] ; # X
; # (val Av)
  %59 = load i8*, i8** %17
; # (execvp (val Av) Av)
  %60 = call i32 @execvp(i8* %59, i8** %17)
; # (val Av)
  %61 = load i8*, i8** %17
; # (execErr (val Av))
  call void @execErr(i8* %61)
  unreachable
$13:
  %62 = phi i64 [%51, %$11] ; # X
  br label %$10
$10:
  %63 = phi i64 [%62, %$13] ; # X
  %64 = phi i64 [0, %$13] ; # ->
; # (let (Pid @ Res (b32 1)) (setpgid Pid 0) (when Fg (tcsetpgrp 0 Pi...
; # (b32 1)
  %65 = alloca i32, i64 1
; # (setpgid Pid 0)
  %66 = call i32 @setpgid(i32 %48, i32 0)
; # (when Fg (tcsetpgrp 0 Pid))
  br i1 %47, label %$17, label %$18
$17:
  %67 = phi i64 [%63, %$10] ; # X
; # (tcsetpgrp 0 Pid)
  %68 = call i32 @tcsetpgrp(i32 0, i32 %48)
  br label %$18
$18:
  %69 = phi i64 [%63, %$10], [%67, %$17] ; # X
; # (loop (while (lt0 (waitWuntraced Pid Res)) (unless (== (gErrno) E...
  br label %$19
$19:
  %70 = phi i64 [%69, %$18], [%103, %$36] ; # X
; # (while (lt0 (waitWuntraced Pid Res)) (unless (== (gErrno) EINTR) ...
  br label %$20
$20:
  %71 = phi i64 [%70, %$19], [%78, %$26] ; # X
; # (waitWuntraced Pid Res)
  %72 = call i32 @waitWuntraced(i32 %48, i32* %65)
; # (lt0 (waitWuntraced Pid Res))
  %73 = icmp slt i32 %72, 0
  br i1 %73, label %$21, label %$22
$21:
  %74 = phi i64 [%71, %$20] ; # X
; # (unless (== (gErrno) EINTR) (err Exe 0 ($ "wait pid") null))
; # (gErrno)
  %75 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %76 = icmp eq i32 %75, 2
  br i1 %76, label %$24, label %$23
$23:
  %77 = phi i64 [%74, %$21] ; # X
; # (err Exe 0 ($ "wait pid") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([9 x i8]* @$83 to i8*), i8* null)
  unreachable
$24:
  %78 = phi i64 [%74, %$21] ; # X
; # (sigChk Exe)
  %79 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %80 = icmp ne i32 %79, 0
  br i1 %80, label %$25, label %$26
$25:
  call void @sighandler(i64 %0)
  br label %$26
$26:
  br label %$20
$22:
  %81 = phi i64 [%71, %$20] ; # X
; # (when Fg (tcsetpgrp 0 Tc))
  br i1 %47, label %$27, label %$28
$27:
  %82 = phi i64 [%81, %$22] ; # X
; # (tcsetpgrp 0 Tc)
  %83 = call i32 @tcsetpgrp(i32 0, i32 %41)
  br label %$28
$28:
  %84 = phi i64 [%81, %$22], [%82, %$27] ; # X
; # (? (=0 (wifStopped Res)) (set $At2 (cnt (i64 (val Res)))) (if (va...
; # (wifStopped Res)
  %85 = call i32 @wifStopped(i32* %65)
; # (=0 (wifStopped Res))
  %86 = icmp eq i32 %85, 0
  br i1 %86, label %$31, label %$29
$31:
  %87 = phi i64 [%84, %$28] ; # X
; # (set $At2 (cnt (i64 (val Res))))
; # (val Res)
  %88 = load i32, i32* %65
; # (i64 (val Res))
  %89 = sext i32 %88 to i64
; # (cnt (i64 (val Res)))
  %90 = shl i64 %89, 4
  %91 = or i64 %90, 2
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %91, i64* %92
; # (if (val Res) $Nil $T)
; # (val Res)
  %93 = load i32, i32* %65
  %94 = icmp ne i32 %93, 0
  br i1 %94, label %$32, label %$33
$32:
  %95 = phi i64 [%87, %$31] ; # X
  br label %$34
$33:
  %96 = phi i64 [%87, %$31] ; # X
  br label %$34
$34:
  %97 = phi i64 [%95, %$32], [%96, %$33] ; # X
  %98 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$32], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$33] ; # ->
  br label %$30
$29:
  %99 = phi i64 [%84, %$28] ; # X
; # (repl 0 ($ "+ ") $Nil)
  %100 = call i64 @repl(i64 0, i8* bitcast ([3 x i8]* @$84 to i8*), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (when Fg (tcsetpgrp 0 Pid))
  br i1 %47, label %$35, label %$36
$35:
  %101 = phi i64 [%99, %$29] ; # X
; # (tcsetpgrp 0 Pid)
  %102 = call i32 @tcsetpgrp(i32 0, i32 %48)
  br label %$36
$36:
  %103 = phi i64 [%99, %$29], [%101, %$35] ; # X
; # (val SIGCONT Sig)
  %104 = getelementptr i32, i32* @Sig, i32 8
  %105 = load i32, i32* %104
; # (kill Pid (val SIGCONT Sig))
  %106 = call i32 @kill(i32 %48, i32 %105)
  br label %$19
$30:
  %107 = phi i64 [%97, %$34] ; # X
  %108 = phi i64 [%98, %$34] ; # ->
  ret i64 %108
}

define i64 @_ipid(i64) align 8 {
$1:
; # (let Io: (ioFrame (val $InFrames)) (if (and (Io:) (> (Io: pid) 1)...
; # (val $InFrames)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 32) to i8**)
; # (if (and (Io:) (> (Io: pid) 1)) (cnt (i64 (Io: pid))) $Nil)
; # (and (Io:) (> (Io: pid) 1))
; # (Io:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (Io: pid)
  %3 = getelementptr i8, i8* %1, i32 24
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (> (Io: pid) 1)
  %6 = icmp sgt i32 %5, 1
  br label %$2
$2:
  %7 = phi i1 [0, %$1], [%6, %$3] ; # ->
  br i1 %7, label %$4, label %$5
$4:
; # (Io: pid)
  %8 = getelementptr i8, i8* %1, i32 24
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (i64 (Io: pid))
  %11 = sext i32 %10 to i64
; # (cnt (i64 (Io: pid)))
  %12 = shl i64 %11, 4
  %13 = or i64 %12, 2
  br label %$6
$5:
  br label %$6
$6:
  %14 = phi i64 [%13, %$4], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5] ; # ->
  ret i64 %14
}

define i64 @_opid(i64) align 8 {
$1:
; # (let Io: (ioFrame (val $OutFrames)) (if (and (Io:) (> (Io: pid) 1...
; # (val $OutFrames)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 40) to i8**)
; # (if (and (Io:) (> (Io: pid) 1)) (cnt (i64 (Io: pid))) $Nil)
; # (and (Io:) (> (Io: pid) 1))
; # (Io:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (Io: pid)
  %3 = getelementptr i8, i8* %1, i32 24
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (> (Io: pid) 1)
  %6 = icmp sgt i32 %5, 1
  br label %$2
$2:
  %7 = phi i1 [0, %$1], [%6, %$3] ; # ->
  br i1 %7, label %$4, label %$5
$4:
; # (Io: pid)
  %8 = getelementptr i8, i8* %1, i32 24
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (i64 (Io: pid))
  %11 = sext i32 %10 to i64
; # (cnt (i64 (Io: pid)))
  %12 = shl i64 %11, 4
  %13 = or i64 %12, 2
  br label %$6
$5:
  br label %$6
$6:
  %14 = phi i64 [%13, %$4], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5] ; # ->
  ret i64 %14
}

define i64 @_kill(i64) align 8 {
$1:
; # (let (X (cdr Exe) Pid (i32 (evCnt Exe X))) (if (kill Pid (if (ato...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (i32 (evCnt Exe X))
  %5 = trunc i64 %4 to i32
; # (if (kill Pid (if (atom (shift X)) (val SIGTERM Sig) (i32 (evCnt ...
; # (if (atom (shift X)) (val SIGTERM Sig) (i32 (evCnt Exe X)))
; # (shift X)
  %6 = inttoptr i64 %3 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
; # (atom (shift X))
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$2, label %$3
$2:
  %11 = phi i64 [%8, %$1] ; # X
; # (val SIGTERM Sig)
  %12 = getelementptr i32, i32* @Sig, i32 6
  %13 = load i32, i32* %12
  br label %$4
$3:
  %14 = phi i64 [%8, %$1] ; # X
; # (evCnt Exe X)
  %15 = call i64 @evCnt(i64 %0, i64 %14)
; # (i32 (evCnt Exe X))
  %16 = trunc i64 %15 to i32
  br label %$4
$4:
  %17 = phi i64 [%11, %$2], [%14, %$3] ; # X
  %18 = phi i32 [%13, %$2], [%16, %$3] ; # ->
; # (kill Pid (if (atom (shift X)) (val SIGTERM Sig) (i32 (evCnt Exe ...
  %19 = call i32 @kill(i32 %5, i32 %18)
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %$5, label %$6
$5:
  %21 = phi i64 [%17, %$4] ; # X
  br label %$7
$6:
  %22 = phi i64 [%17, %$4] ; # X
  br label %$7
$7:
  %23 = phi i64 [%21, %$5], [%22, %$6] ; # X
  %24 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$6] ; # ->
  ret i64 %24
}

define i64 @_fork(i64) align 8 {
$1:
; # (if (forkLisp Exe) (cnt (i64 @)) $Nil)
; # (forkLisp Exe)
  %1 = call i32 @forkLisp(i64 %0)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (i64 @)
  %3 = sext i32 %1 to i64
; # (cnt (i64 @))
  %4 = shl i64 %3, 4
  %5 = or i64 %4, 2
  br label %$4
$3:
  br label %$4
$4:
  %6 = phi i64 [%5, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %6
}

define i64 @_detach(i64) align 8 {
$1:
; # (prog1 (val $PPid) (unless (nil? @) (set $PPid $Nil) (close (val ...
; # (val $PPid)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 216) to i64) to i64*
  %2 = load i64, i64* %1
; # (unless (nil? @) (set $PPid $Nil) (close (val $Tell)) (set $Tell ...
; # (nil? @)
  %3 = icmp eq i64 %2, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$3, label %$2
$2:
; # (set $PPid $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 216) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %4
; # (val $Tell)
  %5 = load i32, i32* @$Tell
; # (close (val $Tell))
  %6 = call i32 @close(i32 %5)
; # (set $Tell 0)
  store i32 0, i32* @$Tell
; # (let H (val $Hear) (close H) (closeInFile H) (closeOutFile H))
; # (val $Hear)
  %7 = load i32, i32* @$Hear
; # (close H)
  %8 = call i32 @close(i32 %7)
; # (closeInFile H)
  call void @closeInFile(i32 %7)
; # (closeOutFile H)
  call void @closeOutFile(i32 %7)
; # (set $Hear 0)
  store i32 0, i32* @$Hear
; # (val $Mic)
  %9 = load i32, i32* @$Mic
; # (close (val $Mic))
  %10 = call i32 @close(i32 %9)
; # (set $Mic 0)
  store i32 0, i32* @$Mic
; # (set $Slot 0)
  store i32 0, i32* @$Slot
; # (setsid)
  %11 = call i32 @setsid()
  br label %$3
$3:
  ret i64 %2
}

define i64 @_bye(i64) align 8 {
$1:
; # (if (nil? (eval (cadr Exe))) 0 (i32 (xCnt Exe @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (xCnt Exe @)
  %15 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe @))
  %16 = trunc i64 %15 to i32
  br label %$9
$9:
  %17 = phi i32 [0, %$7], [%16, %$8] ; # ->
; # (bye (if (nil? (eval (cadr Exe))) 0 (i32 (xCnt Exe @))))
  call void @bye(i32 %17)
  unreachable
}

define void @makeErr(i64) align 8 {
$1:
; # (err Exe 0 ($ "Not making") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([11 x i8]* @$85 to i8*), i8* null)
  unreachable
}

define i64 @_car(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
  ret i64 %17
}

define i64 @_cdr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  ret i64 %20
}

define i64 @_caar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
  ret i64 %21
}

define i64 @_cadr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
  ret i64 %24
}

define i64 @_cdar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  ret i64 %24
}

define i64 @_cddr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
  ret i64 %27
}

define i64 @_caaar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkA (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %21)
  unreachable
$12:
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
  ret i64 %25
}

define i64 @_caadr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkA (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
  ret i64 %28
}

define i64 @_cadar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkA (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
  ret i64 %28
}

define i64 @_caddr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkA (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %27)
  unreachable
$16:
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
  ret i64 %31
}

define i64 @_cdaar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkD (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$12:
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %25 = phi i1 [1, %$10], [%24, %$12] ; # ->
  br i1 %25, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %21)
  unreachable
$14:
  %26 = inttoptr i64 %21 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  ret i64 %28
}

define i64 @_cdadr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkD (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  ret i64 %31
}

define i64 @_cddar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkD (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  ret i64 %31
}

define i64 @_cdddr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkD (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$15, label %$16
$16:
  %30 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %31 = phi i1 [1, %$14], [%30, %$16] ; # ->
  br i1 %31, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %27)
  unreachable
$18:
  %32 = inttoptr i64 %27 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
  ret i64 %34
}

define i64 @_caaaar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkA (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %21)
  unreachable
$12:
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
; # (chkA (chkA (chkA (chkA (eval (cadr Exe))))))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %25)
  unreachable
$14:
  %28 = inttoptr i64 %25 to i64*
  %29 = load i64, i64* %28
  ret i64 %29
}

define i64 @_caaadr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkA (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkA (chkA (chkA (chkD (eval (cadr Exe))))))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %28)
  unreachable
$16:
  %31 = inttoptr i64 %28 to i64*
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_caadar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkA (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkA (chkA (chkD (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %28)
  unreachable
$16:
  %31 = inttoptr i64 %28 to i64*
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_caaddr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkA (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %27)
  unreachable
$16:
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
; # (chkA (chkA (chkD (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$18
$17:
  call void @varErr(i64 %0, i64 %31)
  unreachable
$18:
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cadaar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkD (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$12:
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %25 = phi i1 [1, %$10], [%24, %$12] ; # ->
  br i1 %25, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %21)
  unreachable
$14:
  %26 = inttoptr i64 %21 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (chkA (chkD (chkA (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %28)
  unreachable
$16:
  %31 = inttoptr i64 %28 to i64*
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_cadadr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkD (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkA (chkD (chkA (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$18
$17:
  call void @varErr(i64 %0, i64 %31)
  unreachable
$18:
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_caddar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkD (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkA (chkD (chkD (chkA (eval (cadr Exe))))))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$18
$17:
  call void @varErr(i64 %0, i64 %31)
  unreachable
$18:
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cadddr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkD (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$15, label %$16
$16:
  %30 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %31 = phi i1 [1, %$14], [%30, %$16] ; # ->
  br i1 %31, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %27)
  unreachable
$18:
  %32 = inttoptr i64 %27 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (chkA (chkD (chkD (chkD (eval (cadr Exe))))))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$19, label %$20
$19:
  call void @varErr(i64 %0, i64 %34)
  unreachable
$20:
  %37 = inttoptr i64 %34 to i64*
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cdaaar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkA (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %21)
  unreachable
$12:
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
; # (chkD (chkA (chkA (chkA (eval (cadr Exe))))))
  %26 = and i64 %25, 15
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %$13, label %$14
$14:
  %28 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %29 = phi i1 [1, %$12], [%28, %$14] ; # ->
  br i1 %29, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %25)
  unreachable
$16:
  %30 = inttoptr i64 %25 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_cdaadr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkA (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkD (chkA (chkA (chkD (eval (cadr Exe))))))
  %29 = and i64 %28, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$15, label %$16
$16:
  %31 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %32 = phi i1 [1, %$14], [%31, %$16] ; # ->
  br i1 %32, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %28)
  unreachable
$18:
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cdadar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkA (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkD (chkA (chkD (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$15, label %$16
$16:
  %31 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %32 = phi i1 [1, %$14], [%31, %$16] ; # ->
  br i1 %32, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %28)
  unreachable
$18:
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cdaddr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkA (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %27)
  unreachable
$16:
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
; # (chkD (chkA (chkD (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$18
$18:
  %34 = icmp eq i64 %31, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$17
$17:
  %35 = phi i1 [1, %$16], [%34, %$18] ; # ->
  br i1 %35, label %$20, label %$19
$19:
  call void @lstErr(i64 %0, i64 %31)
  unreachable
$20:
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cddaar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkD (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$12:
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %25 = phi i1 [1, %$10], [%24, %$12] ; # ->
  br i1 %25, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %21)
  unreachable
$14:
  %26 = inttoptr i64 %21 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (chkD (chkD (chkA (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$15, label %$16
$16:
  %31 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %32 = phi i1 [1, %$14], [%31, %$16] ; # ->
  br i1 %32, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %28)
  unreachable
$18:
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cddadr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkD (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkD (chkD (chkA (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$18
$18:
  %34 = icmp eq i64 %31, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$17
$17:
  %35 = phi i1 [1, %$16], [%34, %$18] ; # ->
  br i1 %35, label %$20, label %$19
$19:
  call void @lstErr(i64 %0, i64 %31)
  unreachable
$20:
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cdddar(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkD (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkD (chkD (chkD (chkA (eval (cadr Exe))))))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$18
$18:
  %34 = icmp eq i64 %31, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$17
$17:
  %35 = phi i1 [1, %$16], [%34, %$18] ; # ->
  br i1 %35, label %$20, label %$19
$19:
  call void @lstErr(i64 %0, i64 %31)
  unreachable
$20:
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cddddr(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkD (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$15, label %$16
$16:
  %30 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %31 = phi i1 [1, %$14], [%30, %$16] ; # ->
  br i1 %31, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %27)
  unreachable
$18:
  %32 = inttoptr i64 %27 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (chkD (chkD (chkD (chkD (eval (cadr Exe))))))
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$19, label %$20
$20:
  %37 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$19
$19:
  %38 = phi i1 [1, %$18], [%37, %$20] ; # ->
  br i1 %38, label %$22, label %$21
$21:
  call void @lstErr(i64 %0, i64 %34)
  unreachable
$22:
  %39 = inttoptr i64 %34 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  %41 = load i64, i64* %40
  ret i64 %41
}

define i64 @_nth(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X)))) (loop (? (atom Y) Y) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (loop (? (atom Y) Y) (let C (evCnt Exe X) (? (lt0 (dec 'C)) $Nil)...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%62, %$16] ; # X
  %25 = phi i64 [%15, %$2], [%65, %$16] ; # Y
; # (? (atom Y) Y)
; # (atom Y)
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%24, %$7] ; # X
  %29 = phi i64 [%25, %$7] ; # Y
  br label %$9
$8:
  %30 = phi i64 [%24, %$7] ; # X
  %31 = phi i64 [%25, %$7] ; # Y
; # (let C (evCnt Exe X) (? (lt0 (dec 'C)) $Nil) (while (ge0 (dec 'C)...
; # (evCnt Exe X)
  %32 = call i64 @evCnt(i64 %0, i64 %30)
; # (? (lt0 (dec 'C)) $Nil)
; # (dec 'C)
  %33 = sub i64 %32, 1
; # (lt0 (dec 'C))
  %34 = icmp slt i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  %35 = phi i64 [%30, %$8] ; # X
  %36 = phi i64 [%31, %$8] ; # Y
  %37 = phi i64 [%33, %$8] ; # C
  br label %$9
$11:
  %38 = phi i64 [%30, %$8] ; # X
  %39 = phi i64 [%31, %$8] ; # Y
  %40 = phi i64 [%33, %$8] ; # C
; # (while (ge0 (dec 'C)) (shift Y))
  br label %$13
$13:
  %41 = phi i64 [%38, %$11], [%46, %$14] ; # X
  %42 = phi i64 [%39, %$11], [%51, %$14] ; # Y
  %43 = phi i64 [%40, %$11], [%48, %$14] ; # C
; # (dec 'C)
  %44 = sub i64 %43, 1
; # (ge0 (dec 'C))
  %45 = icmp sge i64 %44, 0
  br i1 %45, label %$14, label %$15
$14:
  %46 = phi i64 [%41, %$13] ; # X
  %47 = phi i64 [%42, %$13] ; # Y
  %48 = phi i64 [%44, %$13] ; # C
; # (shift Y)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  br label %$13
$15:
  %52 = phi i64 [%41, %$13] ; # X
  %53 = phi i64 [%42, %$13] ; # Y
  %54 = phi i64 [%44, %$13] ; # C
; # (? (atom (shift X)) Y)
; # (shift X)
  %55 = inttoptr i64 %52 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
; # (atom (shift X))
  %58 = and i64 %57, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$17, label %$16
$17:
  %60 = phi i64 [%57, %$15] ; # X
  %61 = phi i64 [%53, %$15] ; # Y
  br label %$9
$16:
  %62 = phi i64 [%57, %$15] ; # X
  %63 = phi i64 [%53, %$15] ; # Y
; # (car Y)
  %64 = inttoptr i64 %63 to i64*
  %65 = load i64, i64* %64
  br label %$7
$9:
  %66 = phi i64 [%28, %$10], [%35, %$12], [%60, %$17] ; # X
  %67 = phi i64 [%29, %$10], [%36, %$12], [%61, %$17] ; # Y
  %68 = phi i64 [%29, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%61, %$17] ; # ->
; # (drop *Safe)
  %69 = inttoptr i64 %19 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  ret i64 %68
}

define i64 @_con(i64) align 8 {
$1:
; # (let X (cdr Exe) (set 2 (save (needPair Exe (eval (++ X)))) (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set 2 (save (needPair Exe (eval (++ X)))) (eval (car X)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needPair Exe (eval (++ X)))
  %16 = and i64 %15, 15
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @pairErr(i64 %0, i64 %15)
  unreachable
$8:
; # (save (needPair Exe (eval (++ X))))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %15, i64* %22
  %23 = add i64 %21, 8
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %25
; # (car X)
  %26 = inttoptr i64 %7 to i64*
  %27 = load i64, i64* %26
; # (eval (car X))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  br label %$9
$10:
  %30 = and i64 %27, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$13, label %$12
$13:
  %32 = inttoptr i64 %27 to i64*
  %33 = load i64, i64* %32
  br label %$9
$12:
  %34 = call i64 @evList(i64 %27)
  br label %$9
$9:
  %35 = phi i64 [%27, %$11], [%33, %$13], [%34, %$12] ; # ->
  %36 = inttoptr i64 %15 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
; # (drop *Safe)
  %38 = inttoptr i64 %21 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  ret i64 %35
}

define i64 @_cons(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (cons (eval (car X)) $Nil) R (save Y)) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cons (eval (car X)) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %22
; # (while (pair (cdr (shift X))) (setq Y (set 2 Y (cons (eval (car X...
  br label %$7
$7:
  %23 = phi i64 [%3, %$2], [%33, %$10] ; # X
  %24 = phi i64 [%14, %$2], [%45, %$10] ; # Y
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (cdr (shift X))
  %28 = inttoptr i64 %27 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (pair (cdr (shift X)))
  %31 = and i64 %30, 15
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %$8, label %$9
$8:
  %33 = phi i64 [%27, %$7] ; # X
  %34 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (cons (eval (car X)) $Nil))
; # (car X)
  %35 = inttoptr i64 %33 to i64*
  %36 = load i64, i64* %35
; # (eval (car X))
  %37 = and i64 %36, 6
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$12, label %$11
$12:
  br label %$10
$11:
  %39 = and i64 %36, 8
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$14, label %$13
$14:
  %41 = inttoptr i64 %36 to i64*
  %42 = load i64, i64* %41
  br label %$10
$13:
  %43 = call i64 @evList(i64 %36)
  br label %$10
$10:
  %44 = phi i64 [%36, %$12], [%42, %$14], [%43, %$13] ; # ->
; # (cons (eval (car X)) $Nil)
  %45 = call i64 @cons(i64 %44, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %46 = inttoptr i64 %34 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  br label %$7
$9:
  %48 = phi i64 [%27, %$7] ; # X
  %49 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (eval (car X)))
; # (car X)
  %50 = inttoptr i64 %48 to i64*
  %51 = load i64, i64* %50
; # (eval (car X))
  %52 = and i64 %51, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$17, label %$16
$17:
  br label %$15
$16:
  %54 = and i64 %51, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$19, label %$18
$19:
  %56 = inttoptr i64 %51 to i64*
  %57 = load i64, i64* %56
  br label %$15
$18:
  %58 = call i64 @evList(i64 %51)
  br label %$15
$15:
  %59 = phi i64 [%51, %$17], [%57, %$19], [%58, %$18] ; # ->
  %60 = inttoptr i64 %49 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %59, i64* %61
; # (drop *Safe)
  %62 = inttoptr i64 %18 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  %65 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %64, i64* %65
  ret i64 %14
}

define i64 @_conc(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X)) R (save Y)) (while (pair (shif...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save Y)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (while (pair (shift X)) (let Z (eval (car X)) (if (atom Y) (setq ...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%68, %$17] ; # X
  %23 = phi i64 [%13, %$2], [%69, %$17] ; # Y
  %24 = phi i64 [%13, %$2], [%70, %$17] ; # R
; # (shift X)
  %25 = inttoptr i64 %22 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%27, %$7] ; # X
  %31 = phi i64 [%23, %$7] ; # Y
  %32 = phi i64 [%24, %$7] ; # R
; # (let Z (eval (car X)) (if (atom Y) (setq Y (setq R (safe Z))) (wh...
; # (car X)
  %33 = inttoptr i64 %30 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$12, label %$11
$12:
  br label %$10
$11:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$14, label %$13
$14:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$10
$13:
  %41 = call i64 @evList(i64 %34)
  br label %$10
$10:
  %42 = phi i64 [%34, %$12], [%40, %$14], [%41, %$13] ; # ->
; # (if (atom Y) (setq Y (setq R (safe Z))) (while (pair (cdr Y)) (se...
; # (atom Y)
  %43 = and i64 %31, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$16
$15:
  %45 = phi i64 [%30, %$10] ; # X
  %46 = phi i64 [%31, %$10] ; # Y
  %47 = phi i64 [%32, %$10] ; # R
; # (safe Z)
  %48 = inttoptr i64 %17 to i64*
  store i64 %42, i64* %48
  br label %$17
$16:
  %49 = phi i64 [%30, %$10] ; # X
  %50 = phi i64 [%31, %$10] ; # Y
  %51 = phi i64 [%32, %$10] ; # R
; # (while (pair (cdr Y)) (setq Y @))
  br label %$18
$18:
  %52 = phi i64 [%49, %$16], [%60, %$19] ; # X
  %53 = phi i64 [%50, %$16], [%57, %$19] ; # Y
  %54 = phi i64 [%51, %$16], [%62, %$19] ; # R
; # (cdr Y)
  %55 = inttoptr i64 %53 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
; # (pair (cdr Y))
  %58 = and i64 %57, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$19, label %$20
$19:
  %60 = phi i64 [%52, %$18] ; # X
  %61 = phi i64 [%53, %$18] ; # Y
  %62 = phi i64 [%54, %$18] ; # R
  br label %$18
$20:
  %63 = phi i64 [%52, %$18] ; # X
  %64 = phi i64 [%53, %$18] ; # Y
  %65 = phi i64 [%54, %$18] ; # R
; # (set 2 Y Z)
  %66 = inttoptr i64 %64 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %42, i64* %67
  br label %$17
$17:
  %68 = phi i64 [%45, %$15], [%63, %$20] ; # X
  %69 = phi i64 [%42, %$15], [%64, %$20] ; # Y
  %70 = phi i64 [%42, %$15], [%65, %$20] ; # R
  %71 = phi i64 [%42, %$15], [%42, %$20] ; # ->
  br label %$7
$9:
  %72 = phi i64 [%27, %$7] ; # X
  %73 = phi i64 [%23, %$7] ; # Y
  %74 = phi i64 [%24, %$7] ; # R
; # (drop *Safe)
  %75 = inttoptr i64 %17 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %78
  ret i64 %74
}

define i64 @_circ(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (cons (eval (car X)) $Nil) R (save Y)) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cons (eval (car X)) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %22
; # (while (pair (shift X)) (setq Y (set 2 Y (cons (eval (car X)) $Ni...
  br label %$7
$7:
  %23 = phi i64 [%3, %$2], [%30, %$10] ; # X
  %24 = phi i64 [%14, %$2], [%42, %$10] ; # Y
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%27, %$7] ; # X
  %31 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (cons (eval (car X)) $Nil))
; # (car X)
  %32 = inttoptr i64 %30 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %33)
  br label %$10
$10:
  %41 = phi i64 [%33, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (cons (eval (car X)) $Nil)
  %42 = call i64 @cons(i64 %41, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %43 = inttoptr i64 %31 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %42, i64* %44
  br label %$7
$9:
  %45 = phi i64 [%27, %$7] ; # X
  %46 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y R)
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %14, i64* %48
; # (drop *Safe)
  %49 = inttoptr i64 %18 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %52
  ret i64 %14
}

define i64 @_rot(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (eval (car X))) (when (pair R) (let (Y R A (+...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (when (pair R) (let (Y R A (++ Y)) (if (pair (shift X)) (let N (s...
; # (pair R)
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%3, %$2] ; # X
; # (let (Y R A (++ Y)) (if (pair (shift X)) (let N (save R (evCnt Ex...
; # (++ Y)
  %17 = inttoptr i64 %13 to i64*
  %18 = load i64, i64* %17
  %19 = getelementptr i64, i64* %17, i32 1
  %20 = load i64, i64* %19
; # (if (pair (shift X)) (let N (save R (evCnt Exe X)) (while (and (p...
; # (shift X)
  %21 = inttoptr i64 %16 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (pair (shift X))
  %24 = and i64 %23, 15
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %$9, label %$10
$9:
  %26 = phi i64 [%23, %$7] ; # X
  %27 = phi i64 [%20, %$7] ; # Y
  %28 = phi i64 [%18, %$7] ; # A
; # (let N (save R (evCnt Exe X)) (while (and (pair Y) (gt0 (dec 'N))...
; # (save R (evCnt Exe X))
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %30 = load i64, i64* %29
  %31 = alloca i64, i64 2, align 16
  %32 = ptrtoint i64* %31 to i64
  %33 = inttoptr i64 %32 to i64*
  store i64 %13, i64* %33
  %34 = add i64 %32, 8
  %35 = inttoptr i64 %34 to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %36
; # (evCnt Exe X)
  %37 = call i64 @evCnt(i64 %0, i64 %26)
; # drop
  %38 = inttoptr i64 %32 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
; # (while (and (pair Y) (gt0 (dec 'N))) (let B (car Y) (set Y A) (se...
  br label %$12
$12:
  %42 = phi i64 [%26, %$9], [%70, %$17] ; # X
  %43 = phi i64 [%27, %$9], [%71, %$17] ; # Y
  %44 = phi i64 [%28, %$9], [%72, %$17] ; # A
  %45 = phi i64 [%37, %$9], [%73, %$17] ; # N
; # (and (pair Y) (gt0 (dec 'N)))
; # (pair Y)
  %46 = and i64 %43, 15
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  %48 = phi i64 [%42, %$12] ; # X
  %49 = phi i64 [%43, %$12] ; # Y
  %50 = phi i64 [%44, %$12] ; # A
  %51 = phi i64 [%45, %$12] ; # N
; # (dec 'N)
  %52 = sub i64 %51, 1
; # (gt0 (dec 'N))
  %53 = icmp sgt i64 %52, 0
  br label %$13
$13:
  %54 = phi i64 [%42, %$12], [%48, %$14] ; # X
  %55 = phi i64 [%43, %$12], [%49, %$14] ; # Y
  %56 = phi i64 [%44, %$12], [%50, %$14] ; # A
  %57 = phi i64 [%45, %$12], [%52, %$14] ; # N
  %58 = phi i1 [0, %$12], [%53, %$14] ; # ->
  br i1 %58, label %$15, label %$16
$15:
  %59 = phi i64 [%54, %$13] ; # X
  %60 = phi i64 [%55, %$13] ; # Y
  %61 = phi i64 [%56, %$13] ; # A
  %62 = phi i64 [%57, %$13] ; # N
; # (let B (car Y) (set Y A) (setq A B))
; # (car Y)
  %63 = inttoptr i64 %60 to i64*
  %64 = load i64, i64* %63
; # (set Y A)
  %65 = inttoptr i64 %60 to i64*
  store i64 %61, i64* %65
; # (? (== R (shift Y)))
; # (shift Y)
  %66 = inttoptr i64 %60 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
; # (== R (shift Y))
  %69 = icmp eq i64 %13, %68
  br i1 %69, label %$16, label %$17
$17:
  %70 = phi i64 [%59, %$15] ; # X
  %71 = phi i64 [%68, %$15] ; # Y
  %72 = phi i64 [%64, %$15] ; # A
  %73 = phi i64 [%62, %$15] ; # N
  br label %$12
$16:
  %74 = phi i64 [%54, %$13], [%59, %$15] ; # X
  %75 = phi i64 [%55, %$13], [%68, %$15] ; # Y
  %76 = phi i64 [%56, %$13], [%64, %$15] ; # A
  %77 = phi i64 [%57, %$13], [%62, %$15] ; # N
; # (set R A)
  %78 = inttoptr i64 %13 to i64*
  store i64 %76, i64* %78
  br label %$11
$10:
  %79 = phi i64 [%23, %$7] ; # X
  %80 = phi i64 [%20, %$7] ; # Y
  %81 = phi i64 [%18, %$7] ; # A
; # (while (pair Y) (let B (car Y) (set Y A) (setq A B)) (? (== R (sh...
  br label %$18
$18:
  %82 = phi i64 [%79, %$10], [%97, %$21] ; # X
  %83 = phi i64 [%80, %$10], [%98, %$21] ; # Y
  %84 = phi i64 [%81, %$10], [%99, %$21] ; # A
; # (pair Y)
  %85 = and i64 %83, 15
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$19, label %$20
$19:
  %87 = phi i64 [%82, %$18] ; # X
  %88 = phi i64 [%83, %$18] ; # Y
  %89 = phi i64 [%84, %$18] ; # A
; # (let B (car Y) (set Y A) (setq A B))
; # (car Y)
  %90 = inttoptr i64 %88 to i64*
  %91 = load i64, i64* %90
; # (set Y A)
  %92 = inttoptr i64 %88 to i64*
  store i64 %89, i64* %92
; # (? (== R (shift Y)))
; # (shift Y)
  %93 = inttoptr i64 %88 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  %95 = load i64, i64* %94
; # (== R (shift Y))
  %96 = icmp eq i64 %13, %95
  br i1 %96, label %$20, label %$21
$21:
  %97 = phi i64 [%87, %$19] ; # X
  %98 = phi i64 [%95, %$19] ; # Y
  %99 = phi i64 [%91, %$19] ; # A
  br label %$18
$20:
  %100 = phi i64 [%82, %$18], [%87, %$19] ; # X
  %101 = phi i64 [%83, %$18], [%95, %$19] ; # Y
  %102 = phi i64 [%84, %$18], [%91, %$19] ; # A
; # (set R A)
  %103 = inttoptr i64 %13 to i64*
  store i64 %102, i64* %103
  br label %$11
$11:
  %104 = phi i64 [%74, %$16], [%100, %$20] ; # X
  %105 = phi i64 [%75, %$16], [%101, %$20] ; # Y
  %106 = phi i64 [%76, %$16], [%102, %$20] ; # A
  %107 = phi i64 [%76, %$16], [%102, %$20] ; # ->
  br label %$8
$8:
  %108 = phi i64 [%3, %$2], [%104, %$11] ; # X
  ret i64 %13
}

define i64 @_list(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (cons (eval (car X)) $Nil) R (save Y)) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cons (eval (car X)) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %22
; # (while (pair (shift X)) (setq Y (set 2 Y (cons (eval (car X)) $Ni...
  br label %$7
$7:
  %23 = phi i64 [%3, %$2], [%30, %$10] ; # X
  %24 = phi i64 [%14, %$2], [%42, %$10] ; # Y
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%27, %$7] ; # X
  %31 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (cons (eval (car X)) $Nil))
; # (car X)
  %32 = inttoptr i64 %30 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %33)
  br label %$10
$10:
  %41 = phi i64 [%33, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (cons (eval (car X)) $Nil)
  %42 = call i64 @cons(i64 %41, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %43 = inttoptr i64 %31 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %42, i64* %44
  br label %$7
$9:
  %45 = phi i64 [%27, %$7] ; # X
  %46 = phi i64 [%24, %$7] ; # Y
; # (drop *Safe)
  %47 = inttoptr i64 %18 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %50
  ret i64 %14
}

define i64 @_need(i64) align 8 {
$1:
; # (let (X (cdr Exe) C (evCnt Exe X) R (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = add i64 %21, 8
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %25
; # (if (or (pair R) (nil? R)) (eval (cadr X)) (prog1 R (setq R $Nil)...
; # (or (pair R) (nil? R))
; # (pair R)
  %26 = and i64 %17, 15
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %$7, label %$8
$8:
  %28 = phi i64 [%4, %$2] ; # C
  %29 = phi i64 [%17, %$2] ; # R
; # (nil? R)
  %30 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %31 = phi i64 [%4, %$2], [%28, %$8] ; # C
  %32 = phi i64 [%17, %$2], [%29, %$8] ; # R
  %33 = phi i1 [1, %$2], [%30, %$8] ; # ->
  br i1 %33, label %$9, label %$10
$9:
  %34 = phi i64 [%31, %$7] ; # C
  %35 = phi i64 [%32, %$7] ; # R
; # (cadr X)
  %36 = inttoptr i64 %7 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (eval (cadr X))
  %41 = and i64 %40, 6
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$14, label %$13
$14:
  br label %$12
$13:
  %43 = and i64 %40, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$16, label %$15
$16:
  %45 = inttoptr i64 %40 to i64*
  %46 = load i64, i64* %45
  br label %$12
$15:
  %47 = call i64 @evList(i64 %40)
  br label %$12
$12:
  %48 = phi i64 [%40, %$14], [%46, %$16], [%47, %$15] ; # ->
  br label %$11
$10:
  %49 = phi i64 [%31, %$7] ; # C
  %50 = phi i64 [%32, %$7] ; # R
; # (prog1 R (setq R $Nil))
  br label %$11
$11:
  %51 = phi i64 [%34, %$12], [%49, %$10] ; # C
  %52 = phi i64 [%35, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # R
  %53 = phi i64 [%48, %$12], [%50, %$10] ; # ->
; # (save (if (or (pair R) (nil? R)) (eval (cadr X)) (prog1 R (setq R...
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %53, i64* %58
  %59 = add i64 %57, 8
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %61
; # (when C (cond ((gt0 C) (while (pair Z) (dec 'C) (shift Z)) (while...
  %62 = icmp ne i64 %51, 0
  br i1 %62, label %$17, label %$18
$17:
  %63 = phi i64 [%51, %$11] ; # C
  %64 = phi i64 [%52, %$11] ; # R
  %65 = phi i64 [%52, %$11] ; # Z
; # (cond ((gt0 C) (while (pair Z) (dec 'C) (shift Z)) (while (ge0 (d...
; # (gt0 C)
  %66 = icmp sgt i64 %63, 0
  br i1 %66, label %$21, label %$20
$21:
  %67 = phi i64 [%63, %$17] ; # C
  %68 = phi i64 [%64, %$17] ; # R
  %69 = phi i64 [%65, %$17] ; # Z
; # (while (pair Z) (dec 'C) (shift Z))
  br label %$22
$22:
  %70 = phi i64 [%67, %$21], [%78, %$23] ; # C
  %71 = phi i64 [%68, %$21], [%76, %$23] ; # R
  %72 = phi i64 [%69, %$21], [%81, %$23] ; # Z
; # (pair Z)
  %73 = and i64 %72, 15
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %$23, label %$24
$23:
  %75 = phi i64 [%70, %$22] ; # C
  %76 = phi i64 [%71, %$22] ; # R
  %77 = phi i64 [%72, %$22] ; # Z
; # (dec 'C)
  %78 = sub i64 %75, 1
; # (shift Z)
  %79 = inttoptr i64 %77 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  br label %$22
$24:
  %82 = phi i64 [%70, %$22] ; # C
  %83 = phi i64 [%71, %$22] ; # R
  %84 = phi i64 [%72, %$22] ; # Z
; # (while (ge0 (dec 'C)) (setq R (safe (cons Y R))))
  br label %$25
$25:
  %85 = phi i64 [%82, %$24], [%90, %$26] ; # C
  %86 = phi i64 [%83, %$24], [%93, %$26] ; # R
  %87 = phi i64 [%84, %$24], [%92, %$26] ; # Z
; # (dec 'C)
  %88 = sub i64 %85, 1
; # (ge0 (dec 'C))
  %89 = icmp sge i64 %88, 0
  br i1 %89, label %$26, label %$27
$26:
  %90 = phi i64 [%88, %$25] ; # C
  %91 = phi i64 [%86, %$25] ; # R
  %92 = phi i64 [%87, %$25] ; # Z
; # (cons Y R)
  %93 = call i64 @cons(i64 %53, i64 %91)
; # (safe (cons Y R))
  %94 = inttoptr i64 %21 to i64*
  store i64 %93, i64* %94
  br label %$25
$27:
  %95 = phi i64 [%88, %$25] ; # C
  %96 = phi i64 [%86, %$25] ; # R
  %97 = phi i64 [%87, %$25] ; # Z
  br label %$19
$20:
  %98 = phi i64 [%63, %$17] ; # C
  %99 = phi i64 [%64, %$17] ; # R
  %100 = phi i64 [%65, %$17] ; # Z
; # (if (atom R) (setq Z (setq R (safe (cons Y $Nil)))) (while (pair ...
; # (atom R)
  %101 = and i64 %99, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$28, label %$29
$28:
  %103 = phi i64 [%98, %$20] ; # C
  %104 = phi i64 [%99, %$20] ; # R
  %105 = phi i64 [%100, %$20] ; # Z
; # (cons Y $Nil)
  %106 = call i64 @cons(i64 %53, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (safe (cons Y $Nil))
  %107 = inttoptr i64 %21 to i64*
  store i64 %106, i64* %107
  br label %$30
$29:
  %108 = phi i64 [%98, %$20] ; # C
  %109 = phi i64 [%99, %$20] ; # R
  %110 = phi i64 [%100, %$20] ; # Z
; # (while (pair (cdr Z)) (inc 'C) (shift Z))
  br label %$31
$31:
  %111 = phi i64 [%108, %$29], [%122, %$32] ; # C
  %112 = phi i64 [%109, %$29], [%120, %$32] ; # R
  %113 = phi i64 [%110, %$29], [%125, %$32] ; # Z
; # (cdr Z)
  %114 = inttoptr i64 %113 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
; # (pair (cdr Z))
  %117 = and i64 %116, 15
  %118 = icmp eq i64 %117, 0
  br i1 %118, label %$32, label %$33
$32:
  %119 = phi i64 [%111, %$31] ; # C
  %120 = phi i64 [%112, %$31] ; # R
  %121 = phi i64 [%113, %$31] ; # Z
; # (inc 'C)
  %122 = add i64 %119, 1
; # (shift Z)
  %123 = inttoptr i64 %121 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  br label %$31
$33:
  %126 = phi i64 [%111, %$31] ; # C
  %127 = phi i64 [%112, %$31] ; # R
  %128 = phi i64 [%113, %$31] ; # Z
  br label %$30
$30:
  %129 = phi i64 [%103, %$28], [%126, %$33] ; # C
  %130 = phi i64 [%106, %$28], [%127, %$33] ; # R
  %131 = phi i64 [%106, %$28], [%128, %$33] ; # Z
; # (while (lt0 (inc 'C)) (setq Z (set 2 Z (cons Y $Nil))))
  br label %$34
$34:
  %132 = phi i64 [%129, %$30], [%137, %$35] ; # C
  %133 = phi i64 [%130, %$30], [%138, %$35] ; # R
  %134 = phi i64 [%131, %$30], [%140, %$35] ; # Z
; # (inc 'C)
  %135 = add i64 %132, 1
; # (lt0 (inc 'C))
  %136 = icmp slt i64 %135, 0
  br i1 %136, label %$35, label %$36
$35:
  %137 = phi i64 [%135, %$34] ; # C
  %138 = phi i64 [%133, %$34] ; # R
  %139 = phi i64 [%134, %$34] ; # Z
; # (set 2 Z (cons Y $Nil))
; # (cons Y $Nil)
  %140 = call i64 @cons(i64 %53, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %141 = inttoptr i64 %139 to i64*
  %142 = getelementptr i64, i64* %141, i32 1
  store i64 %140, i64* %142
  br label %$34
$36:
  %143 = phi i64 [%135, %$34] ; # C
  %144 = phi i64 [%133, %$34] ; # R
  %145 = phi i64 [%134, %$34] ; # Z
  br label %$19
$19:
  %146 = phi i64 [%95, %$27], [%143, %$36] ; # C
  %147 = phi i64 [%96, %$27], [%144, %$36] ; # R
  %148 = phi i64 [%97, %$27], [%145, %$36] ; # Z
  br label %$18
$18:
  %149 = phi i64 [%51, %$11], [%146, %$19] ; # C
  %150 = phi i64 [%52, %$11], [%147, %$19] ; # R
  %151 = phi i64 [%52, %$11], [%148, %$19] ; # Z
; # (drop *Safe)
  %152 = inttoptr i64 %21 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
  %155 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %154, i64* %155
  ret i64 %150
}

define i64 @_range(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (needNum Exe (eval (++ X))) R (save (cons N $...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cons N $Nil)
  %18 = call i64 @cons(i64 %15, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons N $Nil))
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (++ X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
  %29 = getelementptr i64, i64* %27, i32 1
  %30 = load i64, i64* %29
; # (eval (++ X))
  %31 = and i64 %28, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$10
$11:
  br label %$9
$10:
  %33 = and i64 %28, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$12
$13:
  %35 = inttoptr i64 %28 to i64*
  %36 = load i64, i64* %35
  br label %$9
$12:
  %37 = call i64 @evList(i64 %28)
  br label %$9
$9:
  %38 = phi i64 [%28, %$11], [%36, %$13], [%37, %$12] ; # ->
; # (needNum Exe (eval (++ X)))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$15, label %$14
$14:
  call void @numErr(i64 %0, i64 %38)
  unreachable
$15:
; # (save (needNum Exe (eval (++ X))))
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %42 = load i64, i64* %41
  %43 = alloca i64, i64 2, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %38, i64* %45
  %46 = add i64 %44, 8
  %47 = inttoptr i64 %46 to i64*
  store i64 %42, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %48
; # (if (nil? (eval (car X))) ONE (save (needNum Exe @)))
; # (car X)
  %49 = inttoptr i64 %30 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$18, label %$17
$18:
  br label %$16
$17:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$20, label %$19
$20:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$16
$19:
  %57 = call i64 @evList(i64 %50)
  br label %$16
$16:
  %58 = phi i64 [%50, %$18], [%56, %$20], [%57, %$19] ; # ->
; # (nil? (eval (car X)))
  %59 = icmp eq i64 %58, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %59, label %$21, label %$22
$21:
  %60 = phi i64 [%15, %$16] ; # N
  br label %$23
$22:
  %61 = phi i64 [%15, %$16] ; # N
; # (needNum Exe @)
  %62 = and i64 %58, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$25, label %$24
$24:
  call void @numErr(i64 %0, i64 %58)
  unreachable
$25:
; # (save (needNum Exe @))
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %65 = load i64, i64* %64
  %66 = alloca i64, i64 2, align 16
  %67 = ptrtoint i64* %66 to i64
  %68 = inttoptr i64 %67 to i64*
  store i64 %58, i64* %68
  %69 = add i64 %67, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 %65, i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %71
  br label %$23
$23:
  %72 = phi i64 [%60, %$21], [%61, %$25] ; # N
  %73 = phi i64 [18, %$21], [%58, %$25] ; # ->
; # (when (or (== Inc ZERO) (sign? Inc)) (argErr Exe Inc))
; # (or (== Inc ZERO) (sign? Inc))
; # (== Inc ZERO)
  %74 = icmp eq i64 %73, 2
  br i1 %74, label %$26, label %$27
$27:
  %75 = phi i64 [%72, %$23] ; # N
; # (sign? Inc)
  %76 = and i64 %73, 8
  %77 = icmp ne i64 %76, 0
  br label %$26
$26:
  %78 = phi i64 [%72, %$23], [%75, %$27] ; # N
  %79 = phi i1 [1, %$23], [%77, %$27] ; # ->
  br i1 %79, label %$28, label %$29
$28:
  %80 = phi i64 [%78, %$26] ; # N
; # (argErr Exe Inc)
  call void @argErr(i64 %0, i64 %73)
  unreachable
$29:
  %81 = phi i64 [%78, %$26] ; # N
; # (let P R (if (le0 (cmpNum N Lim)) (while (le0 (cmpNum (setq N (ad...
; # (if (le0 (cmpNum N Lim)) (while (le0 (cmpNum (setq N (adds N Inc)...
; # (cmpNum N Lim)
  %82 = call i64 @cmpNum(i64 %81, i64 %38)
; # (le0 (cmpNum N Lim))
  %83 = icmp sle i64 %82, 0
  br i1 %83, label %$30, label %$31
$30:
  %84 = phi i64 [%81, %$29] ; # N
  %85 = phi i64 [%18, %$29] ; # P
; # (while (le0 (cmpNum (setq N (adds N Inc)) Lim)) (setq P (set 2 P ...
  br label %$33
$33:
  %86 = phi i64 [%84, %$30], [%91, %$34] ; # N
  %87 = phi i64 [%85, %$30], [%93, %$34] ; # P
; # (adds N Inc)
  %88 = call i64 @adds(i64 %86, i64 %73)
; # (cmpNum (setq N (adds N Inc)) Lim)
  %89 = call i64 @cmpNum(i64 %88, i64 %38)
; # (le0 (cmpNum (setq N (adds N Inc)) Lim))
  %90 = icmp sle i64 %89, 0
  br i1 %90, label %$34, label %$35
$34:
  %91 = phi i64 [%88, %$33] ; # N
  %92 = phi i64 [%87, %$33] ; # P
; # (set 2 P (cons N $Nil))
; # (cons N $Nil)
  %93 = call i64 @cons(i64 %91, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %94 = inttoptr i64 %92 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$33
$35:
  %96 = phi i64 [%88, %$33] ; # N
  %97 = phi i64 [%87, %$33] ; # P
  br label %$32
$31:
  %98 = phi i64 [%81, %$29] ; # N
  %99 = phi i64 [%18, %$29] ; # P
; # (while (ge0 (cmpNum (setq N (subs N Inc)) Lim)) (setq P (set 2 P ...
  br label %$36
$36:
  %100 = phi i64 [%98, %$31], [%105, %$37] ; # N
  %101 = phi i64 [%99, %$31], [%107, %$37] ; # P
; # (subs N Inc)
  %102 = call i64 @subs(i64 %100, i64 %73)
; # (cmpNum (setq N (subs N Inc)) Lim)
  %103 = call i64 @cmpNum(i64 %102, i64 %38)
; # (ge0 (cmpNum (setq N (subs N Inc)) Lim))
  %104 = icmp sge i64 %103, 0
  br i1 %104, label %$37, label %$38
$37:
  %105 = phi i64 [%102, %$36] ; # N
  %106 = phi i64 [%101, %$36] ; # P
; # (set 2 P (cons N $Nil))
; # (cons N $Nil)
  %107 = call i64 @cons(i64 %105, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %108 = inttoptr i64 %106 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  store i64 %107, i64* %109
  br label %$36
$38:
  %110 = phi i64 [%102, %$36] ; # N
  %111 = phi i64 [%101, %$36] ; # P
  br label %$32
$32:
  %112 = phi i64 [%96, %$35], [%110, %$38] ; # N
  %113 = phi i64 [%97, %$35], [%111, %$38] ; # P
; # (drop *Safe)
  %114 = inttoptr i64 %22 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %116, i64* %117
  ret i64 %18
}

define i64 @_full(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (loop (? (atom X) $T) (? (nil? (car X)) ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (loop (? (atom X) $T) (? (nil? (car X)) $Nil) (shift X))
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%26, %$11] ; # X
; # (? (atom X) $T)
; # (atom X)
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$8
$10:
  %17 = phi i64 [%14, %$7] ; # X
  br label %$9
$8:
  %18 = phi i64 [%14, %$7] ; # X
; # (? (nil? (car X)) $Nil)
; # (car X)
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (nil? (car X))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$12, label %$11
$12:
  %22 = phi i64 [%18, %$8] ; # X
  br label %$9
$11:
  %23 = phi i64 [%18, %$8] ; # X
; # (shift X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
  br label %$7
$9:
  %27 = phi i64 [%17, %$10], [%22, %$12] ; # X
  %28 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %28
}

define i64 @_make(i64) align 8 {
$1:
; # (let (Make (val $Make) Yoke (val $Yoke) R (link (push $Nil NIL)))...
; # (val $Make)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %2 = load i64, i64* %1
; # (val $Yoke)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  %4 = load i64, i64* %3
; # (push $Nil NIL)
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %7
; # (link (push $Nil NIL))
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %12
; # (set $Make (set $Yoke R))
; # (set $Yoke R)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %6, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 %6, i64* %14
; # (cdr Exe)
  %15 = inttoptr i64 %0 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
; # (exec (cdr Exe))
  br label %$2
$2:
  %18 = phi i64 [%17, %$1], [%30, %$5] ; # Prg
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = getelementptr i64, i64* %19, i32 1
  %22 = load i64, i64* %21
  %23 = and i64 %20, 15
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$3, label %$4
$3:
  %25 = phi i64 [%22, %$2] ; # Prg
  %26 = call i64 @evList(i64 %20)
  br label %$4
$4:
  %27 = phi i64 [%22, %$2], [%25, %$3] ; # Prg
  %28 = and i64 %27, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$6, label %$5
$5:
  %30 = phi i64 [%27, %$4] ; # Prg
  br label %$2
$6:
  %31 = phi i64 [%27, %$4] ; # Prg
  %32 = phi i64 [0, %$4] ; # ->
; # (set $Make Make $Yoke Yoke)
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 %2, i64* %33
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %4, i64* %34
; # (pop R)
  %35 = inttoptr i64 %6 to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %6 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %40
  ret i64 %36
}

define i64 @_made(i64) align 8 {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (when (pair X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (when (pair X) (set (val $Yoke) (eval (++ X))) (let Y (eval (car ...
; # (pair X)
  %9 = and i64 %8, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$4, label %$5
$4:
  %11 = phi i64 [%8, %$3] ; # X
; # (set (val $Yoke) (eval (++ X)))
; # (val $Yoke)
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  %13 = load i64, i64* %12
; # (++ X)
  %14 = inttoptr i64 %11 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
; # (eval (++ X))
  %18 = and i64 %15, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$8:
  br label %$6
$7:
  %20 = and i64 %15, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$9
$10:
  %22 = inttoptr i64 %15 to i64*
  %23 = load i64, i64* %22
  br label %$6
$9:
  %24 = call i64 @evList(i64 %15)
  br label %$6
$6:
  %25 = phi i64 [%15, %$8], [%23, %$10], [%24, %$9] ; # ->
  %26 = inttoptr i64 %13 to i64*
  store i64 %25, i64* %26
; # (let Y (eval (car X)) (when (atom Y) (setq Y (val (val $Yoke))) (...
; # (car X)
  %27 = inttoptr i64 %17 to i64*
  %28 = load i64, i64* %27
; # (eval (car X))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$13, label %$12
$13:
  br label %$11
$12:
  %31 = and i64 %28, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = inttoptr i64 %28 to i64*
  %34 = load i64, i64* %33
  br label %$11
$14:
  %35 = call i64 @evList(i64 %28)
  br label %$11
$11:
  %36 = phi i64 [%28, %$13], [%34, %$15], [%35, %$14] ; # ->
; # (when (atom Y) (setq Y (val (val $Yoke))) (while (pair (cdr Y)) (...
; # (atom Y)
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%17, %$11] ; # X
  %40 = phi i64 [%36, %$11] ; # Y
; # (val $Yoke)
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  %42 = load i64, i64* %41
; # (val (val $Yoke))
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (while (pair (cdr Y)) (setq Y @))
  br label %$18
$18:
  %45 = phi i64 [%39, %$16], [%52, %$19] ; # X
  %46 = phi i64 [%44, %$16], [%49, %$19] ; # Y
; # (cdr Y)
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
; # (pair (cdr Y))
  %50 = and i64 %49, 15
  %51 = icmp eq i64 %50, 0
  br i1 %51, label %$19, label %$20
$19:
  %52 = phi i64 [%45, %$18] ; # X
  %53 = phi i64 [%46, %$18] ; # Y
  br label %$18
$20:
  %54 = phi i64 [%45, %$18] ; # X
  %55 = phi i64 [%46, %$18] ; # Y
  br label %$17
$17:
  %56 = phi i64 [%17, %$11], [%54, %$20] ; # X
  %57 = phi i64 [%36, %$11], [%55, %$20] ; # Y
; # (set $Make (ofs Y 1))
; # (ofs Y 1)
  %58 = add i64 %57, 8
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 %58, i64* %59
  br label %$5
$5:
  %60 = phi i64 [%8, %$3], [%56, %$17] ; # X
; # (val $Yoke)
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  %62 = load i64, i64* %61
; # (val (val $Yoke))
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  ret i64 %64
}

define i64 @_chain(i64) align 8 {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (loop (let Y ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (loop (let Y (set (val $Make) (eval (++ X))) (when (pair Y) (let ...
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%45, %$15] ; # X
; # (let Y (set (val $Make) (eval (++ X))) (when (pair Y) (let Z Y (w...
; # (set (val $Make) (eval (++ X)))
; # (val $Make)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %11 = load i64, i64* %10
; # (++ X)
  %12 = inttoptr i64 %9 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$6
$7:
  br label %$5
$6:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$8
$9:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$5
$8:
  %22 = call i64 @evList(i64 %13)
  br label %$5
$5:
  %23 = phi i64 [%13, %$7], [%21, %$9], [%22, %$8] ; # ->
  %24 = inttoptr i64 %11 to i64*
  store i64 %23, i64* %24
; # (when (pair Y) (let Z Y (while (pair (cdr Z)) (setq Z @)) (set $M...
; # (pair Y)
  %25 = and i64 %23, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$10, label %$11
$10:
  %27 = phi i64 [%15, %$5] ; # X
; # (let Z Y (while (pair (cdr Z)) (setq Z @)) (set $Make (ofs Z 1)))...
; # (while (pair (cdr Z)) (setq Z @))
  br label %$12
$12:
  %28 = phi i64 [%27, %$10], [%35, %$13] ; # X
  %29 = phi i64 [%23, %$10], [%32, %$13] ; # Z
; # (cdr Z)
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (pair (cdr Z))
  %33 = and i64 %32, 15
  %34 = icmp eq i64 %33, 0
  br i1 %34, label %$13, label %$14
$13:
  %35 = phi i64 [%28, %$12] ; # X
  %36 = phi i64 [%29, %$12] ; # Z
  br label %$12
$14:
  %37 = phi i64 [%28, %$12] ; # X
  %38 = phi i64 [%29, %$12] ; # Z
; # (set $Make (ofs Z 1))
; # (ofs Z 1)
  %39 = add i64 %38, 8
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 %39, i64* %40
  br label %$11
$11:
  %41 = phi i64 [%15, %$5], [%37, %$14] ; # X
; # (? (atom X) Y)
; # (atom X)
  %42 = and i64 %41, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$17, label %$15
$17:
  %44 = phi i64 [%41, %$11] ; # X
  br label %$16
$15:
  %45 = phi i64 [%41, %$11] ; # X
  br label %$4
$16:
  %46 = phi i64 [%44, %$17] ; # X
  %47 = phi i64 [%23, %$17] ; # ->
  ret i64 %47
}

define i64 @_link(i64) align 8 {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (loop (let Y ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (loop (let Y (eval (++ X)) (set $Make (ofs (set (val $Make) (cons...
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%31, %$10] ; # X
; # (let Y (eval (++ X)) (set $Make (ofs (set (val $Make) (cons Y $Ni...
; # (++ X)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (eval (++ X))
  %14 = and i64 %11, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  br label %$5
$6:
  %16 = and i64 %11, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = inttoptr i64 %11 to i64*
  %19 = load i64, i64* %18
  br label %$5
$8:
  %20 = call i64 @evList(i64 %11)
  br label %$5
$5:
  %21 = phi i64 [%11, %$7], [%19, %$9], [%20, %$8] ; # ->
; # (set $Make (ofs (set (val $Make) (cons Y $Nil)) 1))
; # (set (val $Make) (cons Y $Nil))
; # (val $Make)
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %23 = load i64, i64* %22
; # (cons Y $Nil)
  %24 = call i64 @cons(i64 %21, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %25 = inttoptr i64 %23 to i64*
  store i64 %24, i64* %25
; # (ofs (set (val $Make) (cons Y $Nil)) 1)
  %26 = add i64 %24, 8
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 %26, i64* %27
; # (? (atom X) Y)
; # (atom X)
  %28 = and i64 %13, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$10
$12:
  %30 = phi i64 [%13, %$5] ; # X
  br label %$11
$10:
  %31 = phi i64 [%13, %$5] ; # X
  br label %$4
$11:
  %32 = phi i64 [%30, %$12] ; # X
  %33 = phi i64 [%21, %$12] ; # ->
  ret i64 %33
}

define i64 @_yoke(i64) align 8 {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (loop (let Y ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (loop (let Y (eval (++ X)) (let P (val $Yoke) (set P (cons Y (val...
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%45, %$10] ; # X
; # (let Y (eval (++ X)) (let P (val $Yoke) (set P (cons Y (val P))))...
; # (++ X)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (eval (++ X))
  %14 = and i64 %11, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  br label %$5
$6:
  %16 = and i64 %11, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = inttoptr i64 %11 to i64*
  %19 = load i64, i64* %18
  br label %$5
$8:
  %20 = call i64 @evList(i64 %11)
  br label %$5
$5:
  %21 = phi i64 [%11, %$7], [%19, %$9], [%20, %$8] ; # ->
; # (let P (val $Yoke) (set P (cons Y (val P))))
; # (val $Yoke)
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 120) to i64) to i64*
  %23 = load i64, i64* %22
; # (set P (cons Y (val P)))
; # (val P)
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
; # (cons Y (val P))
  %26 = call i64 @cons(i64 %21, i64 %25)
  %27 = inttoptr i64 %23 to i64*
  store i64 %26, i64* %27
; # (? (atom X) (let Z (val $Make) (while (pair (val Z)) (setq Z (ofs...
; # (atom X)
  %28 = and i64 %13, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$10
$12:
  %30 = phi i64 [%13, %$5] ; # X
; # (let Z (val $Make) (while (pair (val Z)) (setq Z (ofs @ 1))) (set...
; # (val $Make)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  %32 = load i64, i64* %31
; # (while (pair (val Z)) (setq Z (ofs @ 1)))
  br label %$13
$13:
  %33 = phi i64 [%30, %$12], [%39, %$14] ; # X
  %34 = phi i64 [%32, %$12], [%41, %$14] ; # Z
; # (val Z)
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (pair (val Z))
  %37 = and i64 %36, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$14, label %$15
$14:
  %39 = phi i64 [%33, %$13] ; # X
  %40 = phi i64 [%34, %$13] ; # Z
; # (ofs @ 1)
  %41 = add i64 %36, 8
  br label %$13
$15:
  %42 = phi i64 [%33, %$13] ; # X
  %43 = phi i64 [%34, %$13] ; # Z
; # (set $Make Z)
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 112) to i64) to i64*
  store i64 %43, i64* %44
  br label %$11
$10:
  %45 = phi i64 [%13, %$5] ; # X
  br label %$4
$11:
  %46 = phi i64 [%42, %$15] ; # X
  %47 = phi i64 [%21, %$15] ; # ->
  ret i64 %47
}

define i64 @_copy(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (atom (setq X (eval (car X)))) X (let (Y (co...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom (setq X (eval (car X)))) X (let (Y (cons (car X) (cdr X...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (atom (setq X (eval (car X))))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%13, %$2] ; # X
  br label %$9
$8:
  %17 = phi i64 [%13, %$2] ; # X
; # (let (Y (cons (car X) (cdr X)) R (save Y) Z X) (while (pair (setq...
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (cdr X)
  %20 = inttoptr i64 %17 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (cons (car X) (cdr X))
  %23 = call i64 @cons(i64 %19, i64 %22)
; # (save Y)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = alloca i64, i64 2, align 16
  %27 = ptrtoint i64* %26 to i64
  %28 = inttoptr i64 %27 to i64*
  store i64 %23, i64* %28
  %29 = add i64 %27, 8
  %30 = inttoptr i64 %29 to i64*
  store i64 %25, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %27, i64* %31
; # (while (pair (setq X (cdr Y))) (? (== X Z) (set 2 Y R)) (setq Y (...
  br label %$10
$10:
  %32 = phi i64 [%17, %$8], [%46, %$13] ; # X
  %33 = phi i64 [%23, %$8], [%53, %$13] ; # Y
; # (cdr Y)
  %34 = inttoptr i64 %33 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  %36 = load i64, i64* %35
; # (pair (setq X (cdr Y)))
  %37 = and i64 %36, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$11, label %$12
$11:
  %39 = phi i64 [%36, %$10] ; # X
  %40 = phi i64 [%33, %$10] ; # Y
; # (? (== X Z) (set 2 Y R))
; # (== X Z)
  %41 = icmp eq i64 %39, %17
  br i1 %41, label %$14, label %$13
$14:
  %42 = phi i64 [%39, %$11] ; # X
  %43 = phi i64 [%40, %$11] ; # Y
; # (set 2 Y R)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  store i64 %23, i64* %45
  br label %$12
$13:
  %46 = phi i64 [%39, %$11] ; # X
  %47 = phi i64 [%40, %$11] ; # Y
; # (set 2 Y (cons (car X) (cdr X)))
; # (car X)
  %48 = inttoptr i64 %46 to i64*
  %49 = load i64, i64* %48
; # (cdr X)
  %50 = inttoptr i64 %46 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
; # (cons (car X) (cdr X))
  %53 = call i64 @cons(i64 %49, i64 %52)
  %54 = inttoptr i64 %47 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %53, i64* %55
  br label %$10
$12:
  %56 = phi i64 [%36, %$10], [%42, %$14] ; # X
  %57 = phi i64 [%33, %$10], [%43, %$14] ; # Y
; # (drop *Safe)
  %58 = inttoptr i64 %27 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %61
  br label %$9
$9:
  %62 = phi i64 [%16, %$7], [%56, %$12] ; # X
  %63 = phi i64 [%16, %$7], [%23, %$12] ; # ->
  ret i64 %63
}

define i64 @_mix(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (nond ((or (pair Y) (nil? Y))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nond ((or (pair Y) (nil? Y)) Y) ((pair (shift X)) $Nil) (NIL (sa...
; # (or (pair Y) (nil? Y))
; # (pair Y)
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$8, label %$9
$9:
  %16 = phi i64 [%3, %$2] ; # X
; # (nil? Y)
  %17 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$8
$8:
  %18 = phi i64 [%3, %$2], [%16, %$9] ; # X
  %19 = phi i1 [1, %$2], [%17, %$9] ; # ->
  br i1 %19, label %$10, label %$11
$11:
  %20 = phi i64 [%18, %$8] ; # X
  br label %$7
$10:
  %21 = phi i64 [%18, %$8] ; # X
; # (shift X)
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (pair (shift X))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$12, label %$13
$13:
  %27 = phi i64 [%24, %$10] ; # X
  br label %$7
$12:
  %28 = phi i64 [%24, %$10] ; # X
; # (save Y (let (Z (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil...
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %30 = load i64, i64* %29
  %31 = alloca i64, i64 2, align 16
  %32 = ptrtoint i64* %31 to i64
  %33 = inttoptr i64 %32 to i64*
  store i64 %13, i64* %33
  %34 = add i64 %32, 8
  %35 = inttoptr i64 %34 to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %36
; # (let (Z (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil) R (sav...
; # (if (cnt? (car X)) (nth @ Y) (eval @))
; # (car X)
  %37 = inttoptr i64 %28 to i64*
  %38 = load i64, i64* %37
; # (cnt? (car X))
  %39 = and i64 %38, 2
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$14, label %$15
$14:
  %41 = phi i64 [%28, %$12] ; # X
; # (nth @ Y)
  %42 = lshr i64 %38, 4
  br label %$17
$17:
  %43 = phi i64 [%13, %$14], [%51, %$18] ; # X
  %44 = phi i64 [%42, %$14], [%48, %$18] ; # C
  %45 = sub i64 %44, 1
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$18, label %$19
$18:
  %47 = phi i64 [%43, %$17] ; # X
  %48 = phi i64 [%45, %$17] ; # C
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  br label %$17
$19:
  %52 = phi i64 [%43, %$17] ; # X
  %53 = phi i64 [%45, %$17] ; # C
  %54 = and i64 %38, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$20, label %$21
$20:
  %56 = phi i64 [%52, %$19] ; # X
  %57 = phi i64 [%53, %$19] ; # C
  %58 = inttoptr i64 %56 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  br label %$22
$21:
  %61 = phi i64 [%52, %$19] ; # X
  %62 = phi i64 [%53, %$19] ; # C
  %63 = inttoptr i64 %61 to i64*
  %64 = load i64, i64* %63
  br label %$22
$22:
  %65 = phi i64 [%56, %$20], [%61, %$21] ; # X
  %66 = phi i64 [%57, %$20], [%62, %$21] ; # C
  %67 = phi i64 [%60, %$20], [%64, %$21] ; # ->
  br label %$16
$15:
  %68 = phi i64 [%28, %$12] ; # X
; # (eval @)
  %69 = and i64 %38, 6
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$25, label %$24
$25:
  br label %$23
$24:
  %71 = and i64 %38, 8
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$27, label %$26
$27:
  %73 = inttoptr i64 %38 to i64*
  %74 = load i64, i64* %73
  br label %$23
$26:
  %75 = call i64 @evList(i64 %38)
  br label %$23
$23:
  %76 = phi i64 [%38, %$25], [%74, %$27], [%75, %$26] ; # ->
  br label %$16
$16:
  %77 = phi i64 [%41, %$22], [%68, %$23] ; # X
  %78 = phi i64 [%67, %$22], [%76, %$23] ; # ->
; # (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil)
  %79 = call i64 @cons(i64 %78, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Z)
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %81 = load i64, i64* %80
  %82 = alloca i64, i64 2, align 16
  %83 = ptrtoint i64* %82 to i64
  %84 = inttoptr i64 %83 to i64*
  store i64 %79, i64* %84
  %85 = add i64 %83, 8
  %86 = inttoptr i64 %85 to i64*
  store i64 %81, i64* %86
  %87 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %87
; # (while (pair (shift X)) (setq Z (set 2 Z (cons (if (cnt? (car X))...
  br label %$28
$28:
  %88 = phi i64 [%77, %$16], [%139, %$33] ; # X
  %89 = phi i64 [%79, %$16], [%142, %$33] ; # Z
; # (shift X)
  %90 = inttoptr i64 %88 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  %92 = load i64, i64* %91
; # (pair (shift X))
  %93 = and i64 %92, 15
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %$29, label %$30
$29:
  %95 = phi i64 [%92, %$28] ; # X
  %96 = phi i64 [%89, %$28] ; # Z
; # (set 2 Z (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil))
; # (if (cnt? (car X)) (nth @ Y) (eval @))
; # (car X)
  %97 = inttoptr i64 %95 to i64*
  %98 = load i64, i64* %97
; # (cnt? (car X))
  %99 = and i64 %98, 2
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$31, label %$32
$31:
  %101 = phi i64 [%95, %$29] ; # X
  %102 = phi i64 [%96, %$29] ; # Z
; # (nth @ Y)
  %103 = lshr i64 %98, 4
  br label %$34
$34:
  %104 = phi i64 [%13, %$31], [%112, %$35] ; # X
  %105 = phi i64 [%103, %$31], [%109, %$35] ; # C
  %106 = sub i64 %105, 1
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$35, label %$36
$35:
  %108 = phi i64 [%104, %$34] ; # X
  %109 = phi i64 [%106, %$34] ; # C
  %110 = inttoptr i64 %108 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  %112 = load i64, i64* %111
  br label %$34
$36:
  %113 = phi i64 [%104, %$34] ; # X
  %114 = phi i64 [%106, %$34] ; # C
  %115 = and i64 %98, 8
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$37, label %$38
$37:
  %117 = phi i64 [%113, %$36] ; # X
  %118 = phi i64 [%114, %$36] ; # C
  %119 = inttoptr i64 %117 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  br label %$39
$38:
  %122 = phi i64 [%113, %$36] ; # X
  %123 = phi i64 [%114, %$36] ; # C
  %124 = inttoptr i64 %122 to i64*
  %125 = load i64, i64* %124
  br label %$39
$39:
  %126 = phi i64 [%117, %$37], [%122, %$38] ; # X
  %127 = phi i64 [%118, %$37], [%123, %$38] ; # C
  %128 = phi i64 [%121, %$37], [%125, %$38] ; # ->
  br label %$33
$32:
  %129 = phi i64 [%95, %$29] ; # X
  %130 = phi i64 [%96, %$29] ; # Z
; # (eval @)
  %131 = and i64 %98, 6
  %132 = icmp ne i64 %131, 0
  br i1 %132, label %$42, label %$41
$42:
  br label %$40
$41:
  %133 = and i64 %98, 8
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$44, label %$43
$44:
  %135 = inttoptr i64 %98 to i64*
  %136 = load i64, i64* %135
  br label %$40
$43:
  %137 = call i64 @evList(i64 %98)
  br label %$40
$40:
  %138 = phi i64 [%98, %$42], [%136, %$44], [%137, %$43] ; # ->
  br label %$33
$33:
  %139 = phi i64 [%101, %$39], [%129, %$40] ; # X
  %140 = phi i64 [%102, %$39], [%130, %$40] ; # Z
  %141 = phi i64 [%128, %$39], [%138, %$40] ; # ->
; # (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil)
  %142 = call i64 @cons(i64 %141, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %143 = inttoptr i64 %96 to i64*
  %144 = getelementptr i64, i64* %143, i32 1
  store i64 %142, i64* %144
  br label %$28
$30:
  %145 = phi i64 [%92, %$28] ; # X
  %146 = phi i64 [%89, %$28] ; # Z
; # drop
  %147 = inttoptr i64 %32 to i64*
  %148 = getelementptr i64, i64* %147, i32 1
  %149 = load i64, i64* %148
  %150 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %149, i64* %150
  br label %$7
$7:
  %151 = phi i64 [%20, %$11], [%27, %$13], [%145, %$30] ; # X
  %152 = phi i64 [%13, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%79, %$30] ; # ->
  ret i64 %152
}

define i64 @_append(i64) align 8 {
$1:
; # (let X Exe (loop (? (atom (cdr (shift X))) (eval (car X))) (? (pa...
; # (loop (? (atom (cdr (shift X))) (eval (car X))) (? (pair (eval (c...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%140, %$16] ; # X
; # (? (atom (cdr (shift X))) (eval (car X)))
; # (shift X)
  %2 = inttoptr i64 %1 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (cdr (shift X))
  %5 = inttoptr i64 %4 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (atom (cdr (shift X)))
  %8 = and i64 %7, 15
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$5, label %$3
$5:
  %10 = phi i64 [%4, %$2] ; # X
; # (car X)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  br label %$6
$7:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$9
$10:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$6
$9:
  %19 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %20 = phi i64 [%12, %$8], [%18, %$10], [%19, %$9] ; # ->
  br label %$4
$3:
  %21 = phi i64 [%4, %$2] ; # X
; # (? (pair (eval (car X))) (let (Y (save @) R (safe (cons (++ Y) Y)...
; # (car X)
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
; # (eval (car X))
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$13, label %$12
$13:
  br label %$11
$12:
  %26 = and i64 %23, 8
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$15, label %$14
$15:
  %28 = inttoptr i64 %23 to i64*
  %29 = load i64, i64* %28
  br label %$11
$14:
  %30 = call i64 @evList(i64 %23)
  br label %$11
$11:
  %31 = phi i64 [%23, %$13], [%29, %$15], [%30, %$14] ; # ->
; # (pair (eval (car X)))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$16
$17:
  %34 = phi i64 [%21, %$11] ; # X
; # (let (Y (save @) R (safe (cons (++ Y) Y)) Z R) (while (pair Y) (s...
; # (save @)
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = alloca i64, i64 2, align 16
  %38 = ptrtoint i64* %37 to i64
  %39 = inttoptr i64 %38 to i64*
  store i64 %31, i64* %39
  %40 = add i64 %38, 8
  %41 = inttoptr i64 %40 to i64*
  store i64 %36, i64* %41
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %38, i64* %42
; # (++ Y)
  %43 = inttoptr i64 %31 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (cons (++ Y) Y)
  %47 = call i64 @cons(i64 %44, i64 %46)
; # (safe (cons (++ Y) Y))
  %48 = inttoptr i64 %38 to i64*
  store i64 %47, i64* %48
; # (while (pair Y) (setq Z (set 2 Z (cons (++ Y) Y))))
  br label %$18
$18:
  %49 = phi i64 [%34, %$17], [%54, %$19] ; # X
  %50 = phi i64 [%46, %$17], [%60, %$19] ; # Y
  %51 = phi i64 [%47, %$17], [%61, %$19] ; # Z
; # (pair Y)
  %52 = and i64 %50, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$19, label %$20
$19:
  %54 = phi i64 [%49, %$18] ; # X
  %55 = phi i64 [%50, %$18] ; # Y
  %56 = phi i64 [%51, %$18] ; # Z
; # (set 2 Z (cons (++ Y) Y))
; # (++ Y)
  %57 = inttoptr i64 %55 to i64*
  %58 = load i64, i64* %57
  %59 = getelementptr i64, i64* %57, i32 1
  %60 = load i64, i64* %59
; # (cons (++ Y) Y)
  %61 = call i64 @cons(i64 %58, i64 %60)
  %62 = inttoptr i64 %56 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 %61, i64* %63
  br label %$18
$20:
  %64 = phi i64 [%49, %$18] ; # X
  %65 = phi i64 [%50, %$18] ; # Y
  %66 = phi i64 [%51, %$18] ; # Z
; # (while (pair (cdr (shift X))) (save (setq Y (eval (car X))) (whil...
  br label %$21
$21:
  %67 = phi i64 [%64, %$20], [%114, %$31] ; # X
  %68 = phi i64 [%65, %$20], [%115, %$31] ; # Y
  %69 = phi i64 [%66, %$20], [%116, %$31] ; # Z
; # (shift X)
  %70 = inttoptr i64 %67 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
; # (cdr (shift X))
  %73 = inttoptr i64 %72 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
; # (pair (cdr (shift X)))
  %76 = and i64 %75, 15
  %77 = icmp eq i64 %76, 0
  br i1 %77, label %$22, label %$23
$22:
  %78 = phi i64 [%72, %$21] ; # X
  %79 = phi i64 [%68, %$21] ; # Y
  %80 = phi i64 [%69, %$21] ; # Z
; # (car X)
  %81 = inttoptr i64 %78 to i64*
  %82 = load i64, i64* %81
; # (eval (car X))
  %83 = and i64 %82, 6
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$26, label %$25
$26:
  br label %$24
$25:
  %85 = and i64 %82, 8
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$28, label %$27
$28:
  %87 = inttoptr i64 %82 to i64*
  %88 = load i64, i64* %87
  br label %$24
$27:
  %89 = call i64 @evList(i64 %82)
  br label %$24
$24:
  %90 = phi i64 [%82, %$26], [%88, %$28], [%89, %$27] ; # ->
; # (save (setq Y (eval (car X))) (while (pair Y) (setq Z (set 2 Z (c...
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %92 = load i64, i64* %91
  %93 = alloca i64, i64 2, align 16
  %94 = ptrtoint i64* %93 to i64
  %95 = inttoptr i64 %94 to i64*
  store i64 %90, i64* %95
  %96 = add i64 %94, 8
  %97 = inttoptr i64 %96 to i64*
  store i64 %92, i64* %97
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %94, i64* %98
; # (while (pair Y) (setq Z (set 2 Z (cons (++ Y) Y))))
  br label %$29
$29:
  %99 = phi i64 [%78, %$24], [%104, %$30] ; # X
  %100 = phi i64 [%90, %$24], [%110, %$30] ; # Y
  %101 = phi i64 [%80, %$24], [%111, %$30] ; # Z
; # (pair Y)
  %102 = and i64 %100, 15
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %$30, label %$31
$30:
  %104 = phi i64 [%99, %$29] ; # X
  %105 = phi i64 [%100, %$29] ; # Y
  %106 = phi i64 [%101, %$29] ; # Z
; # (set 2 Z (cons (++ Y) Y))
; # (++ Y)
  %107 = inttoptr i64 %105 to i64*
  %108 = load i64, i64* %107
  %109 = getelementptr i64, i64* %107, i32 1
  %110 = load i64, i64* %109
; # (cons (++ Y) Y)
  %111 = call i64 @cons(i64 %108, i64 %110)
  %112 = inttoptr i64 %106 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  store i64 %111, i64* %113
  br label %$29
$31:
  %114 = phi i64 [%99, %$29] ; # X
  %115 = phi i64 [%100, %$29] ; # Y
  %116 = phi i64 [%101, %$29] ; # Z
; # drop
  %117 = inttoptr i64 %94 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  %119 = load i64, i64* %118
  %120 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %119, i64* %120
  br label %$21
$23:
  %121 = phi i64 [%72, %$21] ; # X
  %122 = phi i64 [%68, %$21] ; # Y
  %123 = phi i64 [%69, %$21] ; # Z
; # (set 2 Z (eval (car X)))
; # (car X)
  %124 = inttoptr i64 %121 to i64*
  %125 = load i64, i64* %124
; # (eval (car X))
  %126 = and i64 %125, 6
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$34, label %$33
$34:
  br label %$32
$33:
  %128 = and i64 %125, 8
  %129 = icmp ne i64 %128, 0
  br i1 %129, label %$36, label %$35
$36:
  %130 = inttoptr i64 %125 to i64*
  %131 = load i64, i64* %130
  br label %$32
$35:
  %132 = call i64 @evList(i64 %125)
  br label %$32
$32:
  %133 = phi i64 [%125, %$34], [%131, %$36], [%132, %$35] ; # ->
  %134 = inttoptr i64 %123 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  store i64 %133, i64* %135
; # (drop *Safe)
  %136 = inttoptr i64 %38 to i64*
  %137 = getelementptr i64, i64* %136, i32 1
  %138 = load i64, i64* %137
  %139 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %138, i64* %139
  br label %$4
$16:
  %140 = phi i64 [%21, %$11] ; # X
  br label %$2
$4:
  %141 = phi i64 [%10, %$6], [%121, %$32] ; # X
  %142 = phi i64 [%20, %$6], [%47, %$32] ; # ->
  ret i64 %142
}

define i64 @_delete(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) L (save (eval (++ X))) F...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %37 = load i64, i64* %36
  %38 = alloca i64, i64 2, align 16
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = add i64 %39, 8
  %42 = inttoptr i64 %41 to i64*
  store i64 %37, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %43
; # (car X)
  %44 = inttoptr i64 %27 to i64*
  %45 = load i64, i64* %44
; # (eval (car X))
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  br label %$12
$13:
  %48 = and i64 %45, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$16, label %$15
$16:
  %50 = inttoptr i64 %45 to i64*
  %51 = load i64, i64* %50
  br label %$12
$15:
  %52 = call i64 @evList(i64 %45)
  br label %$12
$12:
  %53 = phi i64 [%45, %$14], [%51, %$16], [%52, %$15] ; # ->
; # (nil? (eval (car X)))
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (loop (? (atom L) L) (? (not (equal Y (car L))) (let R (save (set...
  br label %$17
$17:
  %55 = phi i64 [%27, %$12], [%126, %$32] ; # X
  %56 = phi i64 [%35, %$12], [%127, %$32] ; # L
; # (? (atom L) L)
; # (atom L)
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$20, label %$18
$20:
  %59 = phi i64 [%55, %$17] ; # X
  %60 = phi i64 [%56, %$17] ; # L
  br label %$19
$18:
  %61 = phi i64 [%55, %$17] ; # X
  %62 = phi i64 [%56, %$17] ; # L
; # (? (not (equal Y (car L))) (let R (save (setq X (cons (car L) $Ni...
; # (car L)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (equal Y (car L))
  %65 = call i1 @equal(i64 %15, i64 %64)
; # (not (equal Y (car L)))
  %66 = icmp eq i1 %65, 0
  br i1 %66, label %$22, label %$21
$22:
  %67 = phi i64 [%61, %$18] ; # X
  %68 = phi i64 [%62, %$18] ; # L
; # (let R (save (setq X (cons (car L) $Nil))) (loop (? (atom (shift ...
; # (car L)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (cons (car L) $Nil)
  %71 = call i64 @cons(i64 %70, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (setq X (cons (car L) $Nil)))
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %73 = load i64, i64* %72
  %74 = alloca i64, i64 2, align 16
  %75 = ptrtoint i64* %74 to i64
  %76 = inttoptr i64 %75 to i64*
  store i64 %71, i64* %76
  %77 = add i64 %75, 8
  %78 = inttoptr i64 %77 to i64*
  store i64 %73, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %79
; # (loop (? (atom (shift L)) (set 2 X L)) (ifn (equal Y (car L)) (se...
  br label %$23
$23:
  %80 = phi i64 [%71, %$22], [%114, %$29] ; # X
  %81 = phi i64 [%68, %$22], [%115, %$29] ; # L
; # (? (atom (shift L)) (set 2 X L))
; # (shift L)
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (atom (shift L))
  %85 = and i64 %84, 15
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$26, label %$24
$26:
  %87 = phi i64 [%80, %$23] ; # X
  %88 = phi i64 [%84, %$23] ; # L
; # (set 2 X L)
  %89 = inttoptr i64 %87 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %88, i64* %90
  br label %$25
$24:
  %91 = phi i64 [%80, %$23] ; # X
  %92 = phi i64 [%84, %$23] ; # L
; # (ifn (equal Y (car L)) (setq X (set 2 X (cons (car L) $Nil))) (? ...
; # (car L)
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
; # (equal Y (car L))
  %95 = call i1 @equal(i64 %15, i64 %94)
  br i1 %95, label %$28, label %$27
$27:
  %96 = phi i64 [%91, %$24] ; # X
  %97 = phi i64 [%92, %$24] ; # L
; # (set 2 X (cons (car L) $Nil))
; # (car L)
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
; # (cons (car L) $Nil)
  %100 = call i64 @cons(i64 %99, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %101 = inttoptr i64 %96 to i64*
  %102 = getelementptr i64, i64* %101, i32 1
  store i64 %100, i64* %102
  br label %$29
$28:
  %103 = phi i64 [%91, %$24] ; # X
  %104 = phi i64 [%92, %$24] ; # L
; # (? F (set 2 X (cdr L)))
  br i1 %54, label %$31, label %$30
$31:
  %105 = phi i64 [%103, %$28] ; # X
  %106 = phi i64 [%104, %$28] ; # L
; # (set 2 X (cdr L))
; # (cdr L)
  %107 = inttoptr i64 %106 to i64*
  %108 = getelementptr i64, i64* %107, i32 1
  %109 = load i64, i64* %108
  %110 = inttoptr i64 %105 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$25
$30:
  %112 = phi i64 [%103, %$28] ; # X
  %113 = phi i64 [%104, %$28] ; # L
  br label %$29
$29:
  %114 = phi i64 [%100, %$27], [%112, %$30] ; # X
  %115 = phi i64 [%97, %$27], [%113, %$30] ; # L
  br label %$23
$25:
  %116 = phi i64 [%87, %$26], [%105, %$31] ; # X
  %117 = phi i64 [%88, %$26], [%106, %$31] ; # L
  %118 = phi i64 [%88, %$26], [%109, %$31] ; # ->
  br label %$19
$21:
  %119 = phi i64 [%61, %$18] ; # X
  %120 = phi i64 [%62, %$18] ; # L
; # (shift L)
  %121 = inttoptr i64 %120 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  %123 = load i64, i64* %122
; # (? F L)
  br i1 %54, label %$33, label %$32
$33:
  %124 = phi i64 [%119, %$21] ; # X
  %125 = phi i64 [%123, %$21] ; # L
  br label %$19
$32:
  %126 = phi i64 [%119, %$21] ; # X
  %127 = phi i64 [%123, %$21] ; # L
  br label %$17
$19:
  %128 = phi i64 [%59, %$20], [%116, %$25], [%124, %$33] ; # X
  %129 = phi i64 [%60, %$20], [%117, %$25], [%125, %$33] ; # L
  %130 = phi i64 [%60, %$20], [%71, %$25], [%125, %$33] ; # ->
; # (drop *Safe)
  %131 = inttoptr i64 %19 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  %133 = load i64, i64* %132
  %134 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %133, i64* %134
  ret i64 %130
}

define i64 @_delq(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) L (save (eval (++ X))) F...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %37 = load i64, i64* %36
  %38 = alloca i64, i64 2, align 16
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = add i64 %39, 8
  %42 = inttoptr i64 %41 to i64*
  store i64 %37, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %43
; # (car X)
  %44 = inttoptr i64 %27 to i64*
  %45 = load i64, i64* %44
; # (eval (car X))
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  br label %$12
$13:
  %48 = and i64 %45, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$16, label %$15
$16:
  %50 = inttoptr i64 %45 to i64*
  %51 = load i64, i64* %50
  br label %$12
$15:
  %52 = call i64 @evList(i64 %45)
  br label %$12
$12:
  %53 = phi i64 [%45, %$14], [%51, %$16], [%52, %$15] ; # ->
; # (nil? (eval (car X)))
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (loop (? (atom L) L) (? (<> Y (car L)) (let R (save (setq X (cons...
  br label %$17
$17:
  %55 = phi i64 [%27, %$12], [%125, %$32] ; # X
  %56 = phi i64 [%35, %$12], [%126, %$32] ; # L
; # (? (atom L) L)
; # (atom L)
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$20, label %$18
$20:
  %59 = phi i64 [%55, %$17] ; # X
  %60 = phi i64 [%56, %$17] ; # L
  br label %$19
$18:
  %61 = phi i64 [%55, %$17] ; # X
  %62 = phi i64 [%56, %$17] ; # L
; # (? (<> Y (car L)) (let R (save (setq X (cons (car L) $Nil))) (loo...
; # (car L)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (<> Y (car L))
  %65 = icmp ne i64 %15, %64
  br i1 %65, label %$22, label %$21
$22:
  %66 = phi i64 [%61, %$18] ; # X
  %67 = phi i64 [%62, %$18] ; # L
; # (let R (save (setq X (cons (car L) $Nil))) (loop (? (atom (shift ...
; # (car L)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (cons (car L) $Nil)
  %70 = call i64 @cons(i64 %69, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (setq X (cons (car L) $Nil)))
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
  %73 = alloca i64, i64 2, align 16
  %74 = ptrtoint i64* %73 to i64
  %75 = inttoptr i64 %74 to i64*
  store i64 %70, i64* %75
  %76 = add i64 %74, 8
  %77 = inttoptr i64 %76 to i64*
  store i64 %72, i64* %77
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %74, i64* %78
; # (loop (? (atom (shift L)) (set 2 X L)) (if (<> Y (car L)) (setq X...
  br label %$23
$23:
  %79 = phi i64 [%70, %$22], [%113, %$29] ; # X
  %80 = phi i64 [%67, %$22], [%114, %$29] ; # L
; # (? (atom (shift L)) (set 2 X L))
; # (shift L)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (atom (shift L))
  %84 = and i64 %83, 15
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$26, label %$24
$26:
  %86 = phi i64 [%79, %$23] ; # X
  %87 = phi i64 [%83, %$23] ; # L
; # (set 2 X L)
  %88 = inttoptr i64 %86 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  store i64 %87, i64* %89
  br label %$25
$24:
  %90 = phi i64 [%79, %$23] ; # X
  %91 = phi i64 [%83, %$23] ; # L
; # (if (<> Y (car L)) (setq X (set 2 X (cons (car L) $Nil))) (? F (s...
; # (car L)
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
; # (<> Y (car L))
  %94 = icmp ne i64 %15, %93
  br i1 %94, label %$27, label %$28
$27:
  %95 = phi i64 [%90, %$24] ; # X
  %96 = phi i64 [%91, %$24] ; # L
; # (set 2 X (cons (car L) $Nil))
; # (car L)
  %97 = inttoptr i64 %96 to i64*
  %98 = load i64, i64* %97
; # (cons (car L) $Nil)
  %99 = call i64 @cons(i64 %98, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %100 = inttoptr i64 %95 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  store i64 %99, i64* %101
  br label %$29
$28:
  %102 = phi i64 [%90, %$24] ; # X
  %103 = phi i64 [%91, %$24] ; # L
; # (? F (set 2 X (cdr L)))
  br i1 %54, label %$31, label %$30
$31:
  %104 = phi i64 [%102, %$28] ; # X
  %105 = phi i64 [%103, %$28] ; # L
; # (set 2 X (cdr L))
; # (cdr L)
  %106 = inttoptr i64 %105 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
  %109 = inttoptr i64 %104 to i64*
  %110 = getelementptr i64, i64* %109, i32 1
  store i64 %108, i64* %110
  br label %$25
$30:
  %111 = phi i64 [%102, %$28] ; # X
  %112 = phi i64 [%103, %$28] ; # L
  br label %$29
$29:
  %113 = phi i64 [%99, %$27], [%111, %$30] ; # X
  %114 = phi i64 [%96, %$27], [%112, %$30] ; # L
  br label %$23
$25:
  %115 = phi i64 [%86, %$26], [%104, %$31] ; # X
  %116 = phi i64 [%87, %$26], [%105, %$31] ; # L
  %117 = phi i64 [%87, %$26], [%108, %$31] ; # ->
  br label %$19
$21:
  %118 = phi i64 [%61, %$18] ; # X
  %119 = phi i64 [%62, %$18] ; # L
; # (shift L)
  %120 = inttoptr i64 %119 to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  %122 = load i64, i64* %121
; # (? F L)
  br i1 %54, label %$33, label %$32
$33:
  %123 = phi i64 [%118, %$21] ; # X
  %124 = phi i64 [%122, %$21] ; # L
  br label %$19
$32:
  %125 = phi i64 [%118, %$21] ; # X
  %126 = phi i64 [%122, %$21] ; # L
  br label %$17
$19:
  %127 = phi i64 [%59, %$20], [%115, %$25], [%123, %$33] ; # X
  %128 = phi i64 [%60, %$20], [%116, %$25], [%124, %$33] ; # L
  %129 = phi i64 [%60, %$20], [%70, %$25], [%124, %$33] ; # ->
; # (drop *Safe)
  %130 = inttoptr i64 %19 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  %132 = load i64, i64* %131
  %133 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %132, i64* %133
  ret i64 %129
}

define i64 @_replace(i64) align 8 {
$1:
; # (let (X (cdr Exe) L (save (eval (car X)))) (if (atom L) @ (let (A...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (if (atom L) @ (let (A $Nil N 0 R (push NIL NIL)) (while (pair (s...
; # (atom L)
  %22 = and i64 %13, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$7, label %$8
$7:
  %24 = phi i64 [%3, %$2] ; # X
  %25 = phi i64 [%13, %$2] ; # L
  br label %$9
$8:
  %26 = phi i64 [%3, %$2] ; # X
  %27 = phi i64 [%13, %$2] ; # L
; # (let (A $Nil N 0 R (push NIL NIL)) (while (pair (shift X)) (link ...
; # (push NIL NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
; # (while (pair (shift X)) (link (push (eval (++ X)) NIL)) (setq A (...
  br label %$10
$10:
  %30 = phi i64 [%26, %$8], [%46, %$18] ; # X
  %31 = phi i64 [%27, %$8], [%40, %$18] ; # L
  %32 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8], [%74, %$18] ; # A
  %33 = phi i64 [0, %$8], [%81, %$18] ; # N
; # (shift X)
  %34 = inttoptr i64 %30 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  %36 = load i64, i64* %35
; # (pair (shift X))
  %37 = and i64 %36, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$11, label %$12
$11:
  %39 = phi i64 [%36, %$10] ; # X
  %40 = phi i64 [%31, %$10] ; # L
  %41 = phi i64 [%32, %$10] ; # A
  %42 = phi i64 [%33, %$10] ; # N
; # (++ X)
  %43 = inttoptr i64 %39 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (eval (++ X))
  %47 = and i64 %44, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$15, label %$14
$15:
  br label %$13
$14:
  %49 = and i64 %44, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$17, label %$16
$17:
  %51 = inttoptr i64 %44 to i64*
  %52 = load i64, i64* %51
  br label %$13
$16:
  %53 = call i64 @evList(i64 %44)
  br label %$13
$13:
  %54 = phi i64 [%44, %$15], [%52, %$17], [%53, %$16] ; # ->
; # (push (eval (++ X)) NIL)
  %55 = alloca i64, i64 2, align 16
  %56 = ptrtoint i64* %55 to i64
  %57 = inttoptr i64 %56 to i64*
  store i64 %54, i64* %57
; # (link (push (eval (++ X)) NIL))
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 %56 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %59, i64* %61
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %56, i64* %62
; # (car X)
  %63 = inttoptr i64 %46 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$20, label %$19
$20:
  br label %$18
$19:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$22, label %$21
$22:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$18
$21:
  %71 = call i64 @evList(i64 %64)
  br label %$18
$18:
  %72 = phi i64 [%64, %$20], [%70, %$22], [%71, %$21] ; # ->
; # (push (eval (car X)) NIL)
  %73 = alloca i64, i64 2, align 16
  %74 = ptrtoint i64* %73 to i64
  %75 = inttoptr i64 %74 to i64*
  store i64 %72, i64* %75
; # (link (push (eval (car X)) NIL))
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %74 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %77, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %74, i64* %80
; # (inc 'N)
  %81 = add i64 %42, 1
  br label %$10
$12:
  %82 = phi i64 [%36, %$10] ; # X
  %83 = phi i64 [%31, %$10] ; # L
  %84 = phi i64 [%32, %$10] ; # A
  %85 = phi i64 [%33, %$10] ; # N
; # (let (Y (++ L) Z A I N) (until (lt0 (dec 'I)) (let (V (++ Z) K (+...
; # (++ L)
  %86 = inttoptr i64 %83 to i64*
  %87 = load i64, i64* %86
  %88 = getelementptr i64, i64* %86, i32 1
  %89 = load i64, i64* %88
; # (until (lt0 (dec 'I)) (let (V (++ Z) K (++ Z)) (? (equal Y K) (se...
  br label %$23
$23:
  %90 = phi i64 [%82, %$12], [%122, %$26] ; # X
  %91 = phi i64 [%89, %$12], [%123, %$26] ; # L
  %92 = phi i64 [%84, %$12], [%124, %$26] ; # A
  %93 = phi i64 [%85, %$12], [%125, %$26] ; # N
  %94 = phi i64 [%87, %$12], [%126, %$26] ; # Y
  %95 = phi i64 [%84, %$12], [%127, %$26] ; # Z
  %96 = phi i64 [%85, %$12], [%128, %$26] ; # I
; # (dec 'I)
  %97 = sub i64 %96, 1
; # (lt0 (dec 'I))
  %98 = icmp slt i64 %97, 0
  br i1 %98, label %$25, label %$24
$24:
  %99 = phi i64 [%90, %$23] ; # X
  %100 = phi i64 [%91, %$23] ; # L
  %101 = phi i64 [%92, %$23] ; # A
  %102 = phi i64 [%93, %$23] ; # N
  %103 = phi i64 [%94, %$23] ; # Y
  %104 = phi i64 [%95, %$23] ; # Z
  %105 = phi i64 [%97, %$23] ; # I
; # (let (V (++ Z) K (++ Z)) (? (equal Y K) (setq Y V)))
; # (++ Z)
  %106 = inttoptr i64 %104 to i64*
  %107 = load i64, i64* %106
  %108 = getelementptr i64, i64* %106, i32 1
  %109 = load i64, i64* %108
; # (++ Z)
  %110 = inttoptr i64 %109 to i64*
  %111 = load i64, i64* %110
  %112 = getelementptr i64, i64* %110, i32 1
  %113 = load i64, i64* %112
; # (? (equal Y K) (setq Y V))
; # (equal Y K)
  %114 = call i1 @equal(i64 %103, i64 %111)
  br i1 %114, label %$27, label %$26
$27:
  %115 = phi i64 [%99, %$24] ; # X
  %116 = phi i64 [%100, %$24] ; # L
  %117 = phi i64 [%101, %$24] ; # A
  %118 = phi i64 [%102, %$24] ; # N
  %119 = phi i64 [%103, %$24] ; # Y
  %120 = phi i64 [%113, %$24] ; # Z
  %121 = phi i64 [%105, %$24] ; # I
  br label %$25
$26:
  %122 = phi i64 [%99, %$24] ; # X
  %123 = phi i64 [%100, %$24] ; # L
  %124 = phi i64 [%101, %$24] ; # A
  %125 = phi i64 [%102, %$24] ; # N
  %126 = phi i64 [%103, %$24] ; # Y
  %127 = phi i64 [%113, %$24] ; # Z
  %128 = phi i64 [%105, %$24] ; # I
  br label %$23
$25:
  %129 = phi i64 [%90, %$23], [%115, %$27] ; # X
  %130 = phi i64 [%91, %$23], [%116, %$27] ; # L
  %131 = phi i64 [%92, %$23], [%117, %$27] ; # A
  %132 = phi i64 [%93, %$23], [%118, %$27] ; # N
  %133 = phi i64 [%94, %$23], [%107, %$27] ; # Y
  %134 = phi i64 [%95, %$23], [%120, %$27] ; # Z
  %135 = phi i64 [%97, %$23], [%121, %$27] ; # I
; # (let P (set (link R) (cons Y $Nil)) (while (pair L) (setq Y (++ L...
; # (set (link R) (cons Y $Nil))
; # (link R)
  %136 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %137 = load i64, i64* %136
  %138 = inttoptr i64 %29 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  store i64 %137, i64* %139
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %140
; # (cons Y $Nil)
  %141 = call i64 @cons(i64 %133, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %142 = inttoptr i64 %29 to i64*
  store i64 %141, i64* %142
; # (while (pair L) (setq Y (++ L) Z A I N) (until (lt0 (dec 'I)) (le...
  br label %$28
$28:
  %143 = phi i64 [%129, %$25], [%208, %$33] ; # X
  %144 = phi i64 [%130, %$25], [%209, %$33] ; # L
  %145 = phi i64 [%131, %$25], [%210, %$33] ; # A
  %146 = phi i64 [%132, %$25], [%211, %$33] ; # N
  %147 = phi i64 [%133, %$25], [%212, %$33] ; # Y
  %148 = phi i64 [%134, %$25], [%213, %$33] ; # Z
  %149 = phi i64 [%135, %$25], [%214, %$33] ; # I
  %150 = phi i64 [%141, %$25], [%216, %$33] ; # P
; # (pair L)
  %151 = and i64 %144, 15
  %152 = icmp eq i64 %151, 0
  br i1 %152, label %$29, label %$30
$29:
  %153 = phi i64 [%143, %$28] ; # X
  %154 = phi i64 [%144, %$28] ; # L
  %155 = phi i64 [%145, %$28] ; # A
  %156 = phi i64 [%146, %$28] ; # N
  %157 = phi i64 [%147, %$28] ; # Y
  %158 = phi i64 [%148, %$28] ; # Z
  %159 = phi i64 [%149, %$28] ; # I
  %160 = phi i64 [%150, %$28] ; # P
; # (++ L)
  %161 = inttoptr i64 %154 to i64*
  %162 = load i64, i64* %161
  %163 = getelementptr i64, i64* %161, i32 1
  %164 = load i64, i64* %163
; # (until (lt0 (dec 'I)) (let (V (++ Z) K (++ Z)) (? (equal Y K) (se...
  br label %$31
$31:
  %165 = phi i64 [%153, %$29], [%200, %$34] ; # X
  %166 = phi i64 [%164, %$29], [%201, %$34] ; # L
  %167 = phi i64 [%155, %$29], [%202, %$34] ; # A
  %168 = phi i64 [%156, %$29], [%203, %$34] ; # N
  %169 = phi i64 [%162, %$29], [%204, %$34] ; # Y
  %170 = phi i64 [%155, %$29], [%205, %$34] ; # Z
  %171 = phi i64 [%156, %$29], [%206, %$34] ; # I
  %172 = phi i64 [%160, %$29], [%207, %$34] ; # P
; # (dec 'I)
  %173 = sub i64 %171, 1
; # (lt0 (dec 'I))
  %174 = icmp slt i64 %173, 0
  br i1 %174, label %$33, label %$32
$32:
  %175 = phi i64 [%165, %$31] ; # X
  %176 = phi i64 [%166, %$31] ; # L
  %177 = phi i64 [%167, %$31] ; # A
  %178 = phi i64 [%168, %$31] ; # N
  %179 = phi i64 [%169, %$31] ; # Y
  %180 = phi i64 [%170, %$31] ; # Z
  %181 = phi i64 [%173, %$31] ; # I
  %182 = phi i64 [%172, %$31] ; # P
; # (let (V (++ Z) K (++ Z)) (? (equal Y K) (setq Y V)))
; # (++ Z)
  %183 = inttoptr i64 %180 to i64*
  %184 = load i64, i64* %183
  %185 = getelementptr i64, i64* %183, i32 1
  %186 = load i64, i64* %185
; # (++ Z)
  %187 = inttoptr i64 %186 to i64*
  %188 = load i64, i64* %187
  %189 = getelementptr i64, i64* %187, i32 1
  %190 = load i64, i64* %189
; # (? (equal Y K) (setq Y V))
; # (equal Y K)
  %191 = call i1 @equal(i64 %179, i64 %188)
  br i1 %191, label %$35, label %$34
$35:
  %192 = phi i64 [%175, %$32] ; # X
  %193 = phi i64 [%176, %$32] ; # L
  %194 = phi i64 [%177, %$32] ; # A
  %195 = phi i64 [%178, %$32] ; # N
  %196 = phi i64 [%179, %$32] ; # Y
  %197 = phi i64 [%190, %$32] ; # Z
  %198 = phi i64 [%181, %$32] ; # I
  %199 = phi i64 [%182, %$32] ; # P
  br label %$33
$34:
  %200 = phi i64 [%175, %$32] ; # X
  %201 = phi i64 [%176, %$32] ; # L
  %202 = phi i64 [%177, %$32] ; # A
  %203 = phi i64 [%178, %$32] ; # N
  %204 = phi i64 [%179, %$32] ; # Y
  %205 = phi i64 [%190, %$32] ; # Z
  %206 = phi i64 [%181, %$32] ; # I
  %207 = phi i64 [%182, %$32] ; # P
  br label %$31
$33:
  %208 = phi i64 [%165, %$31], [%192, %$35] ; # X
  %209 = phi i64 [%166, %$31], [%193, %$35] ; # L
  %210 = phi i64 [%167, %$31], [%194, %$35] ; # A
  %211 = phi i64 [%168, %$31], [%195, %$35] ; # N
  %212 = phi i64 [%169, %$31], [%184, %$35] ; # Y
  %213 = phi i64 [%170, %$31], [%197, %$35] ; # Z
  %214 = phi i64 [%173, %$31], [%198, %$35] ; # I
  %215 = phi i64 [%172, %$31], [%199, %$35] ; # P
; # (set 2 P (cons Y $Nil))
; # (cons Y $Nil)
  %216 = call i64 @cons(i64 %212, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %217 = inttoptr i64 %215 to i64*
  %218 = getelementptr i64, i64* %217, i32 1
  store i64 %216, i64* %218
  br label %$28
$30:
  %219 = phi i64 [%143, %$28] ; # X
  %220 = phi i64 [%144, %$28] ; # L
  %221 = phi i64 [%145, %$28] ; # A
  %222 = phi i64 [%146, %$28] ; # N
  %223 = phi i64 [%147, %$28] ; # Y
  %224 = phi i64 [%148, %$28] ; # Z
  %225 = phi i64 [%149, %$28] ; # I
  %226 = phi i64 [%150, %$28] ; # P
; # (val R)
  %227 = inttoptr i64 %29 to i64*
  %228 = load i64, i64* %227
  br label %$9
$9:
  %229 = phi i64 [%24, %$7], [%219, %$30] ; # X
  %230 = phi i64 [%25, %$7], [%220, %$30] ; # L
  %231 = phi i64 [%13, %$7], [%228, %$30] ; # ->
; # (drop *Safe)
  %232 = inttoptr i64 %17 to i64*
  %233 = getelementptr i64, i64* %232, i32 1
  %234 = load i64, i64* %233
  %235 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %234, i64* %235
  ret i64 %231
}

define i64 @_insert(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) L (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = add i64 %21, 8
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %25
; # (shift X)
  %26 = inttoptr i64 %7 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (car (shift X))
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (eval (car (shift X)))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  br label %$7
$8:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$11, label %$10
$11:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$7
$10:
  %37 = call i64 @evList(i64 %30)
  br label %$7
$7:
  %38 = phi i64 [%30, %$9], [%36, %$11], [%37, %$10] ; # ->
; # (if (or (atom L) (le0 (dec 'N))) (cons X L) (let (Y (cons (car L)...
; # (or (atom L) (le0 (dec 'N)))
; # (atom L)
  %39 = and i64 %17, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$12, label %$13
$13:
  %41 = phi i64 [%38, %$7] ; # X
  %42 = phi i64 [%4, %$7] ; # N
  %43 = phi i64 [%17, %$7] ; # L
; # (dec 'N)
  %44 = sub i64 %42, 1
; # (le0 (dec 'N))
  %45 = icmp sle i64 %44, 0
  br label %$12
$12:
  %46 = phi i64 [%38, %$7], [%41, %$13] ; # X
  %47 = phi i64 [%4, %$7], [%44, %$13] ; # N
  %48 = phi i64 [%17, %$7], [%43, %$13] ; # L
  %49 = phi i1 [1, %$7], [%45, %$13] ; # ->
  br i1 %49, label %$14, label %$15
$14:
  %50 = phi i64 [%46, %$12] ; # X
  %51 = phi i64 [%47, %$12] ; # N
  %52 = phi i64 [%48, %$12] ; # L
; # (cons X L)
  %53 = call i64 @cons(i64 %50, i64 %52)
  br label %$16
$15:
  %54 = phi i64 [%46, %$12] ; # X
  %55 = phi i64 [%47, %$12] ; # N
  %56 = phi i64 [%48, %$12] ; # L
; # (let (Y (cons (car L) $Nil) R (save Y)) (while (and (pair (shift ...
; # (car L)
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
; # (cons (car L) $Nil)
  %59 = call i64 @cons(i64 %58, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %61 = load i64, i64* %60
  %62 = alloca i64, i64 2, align 16
  %63 = ptrtoint i64* %62 to i64
  %64 = inttoptr i64 %63 to i64*
  store i64 %59, i64* %64
  %65 = add i64 %63, 8
  %66 = inttoptr i64 %65 to i64*
  store i64 %61, i64* %66
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %63, i64* %67
; # (while (and (pair (shift L)) (dec 'N)) (setq Y (set 2 Y (cons (ca...
  br label %$17
$17:
  %68 = phi i64 [%54, %$15], [%88, %$20] ; # X
  %69 = phi i64 [%55, %$15], [%89, %$20] ; # N
  %70 = phi i64 [%56, %$15], [%90, %$20] ; # L
  %71 = phi i64 [%59, %$15], [%94, %$20] ; # Y
; # (and (pair (shift L)) (dec 'N))
; # (shift L)
  %72 = inttoptr i64 %70 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (pair (shift L))
  %75 = and i64 %74, 15
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %$19, label %$18
$19:
  %77 = phi i64 [%68, %$17] ; # X
  %78 = phi i64 [%69, %$17] ; # N
  %79 = phi i64 [%74, %$17] ; # L
  %80 = phi i64 [%71, %$17] ; # Y
; # (dec 'N)
  %81 = sub i64 %78, 1
  %82 = icmp ne i64 %81, 0
  br label %$18
$18:
  %83 = phi i64 [%68, %$17], [%77, %$19] ; # X
  %84 = phi i64 [%69, %$17], [%81, %$19] ; # N
  %85 = phi i64 [%74, %$17], [%79, %$19] ; # L
  %86 = phi i64 [%71, %$17], [%80, %$19] ; # Y
  %87 = phi i1 [0, %$17], [%82, %$19] ; # ->
  br i1 %87, label %$20, label %$21
$20:
  %88 = phi i64 [%83, %$18] ; # X
  %89 = phi i64 [%84, %$18] ; # N
  %90 = phi i64 [%85, %$18] ; # L
  %91 = phi i64 [%86, %$18] ; # Y
; # (set 2 Y (cons (car L) $Nil))
; # (car L)
  %92 = inttoptr i64 %90 to i64*
  %93 = load i64, i64* %92
; # (cons (car L) $Nil)
  %94 = call i64 @cons(i64 %93, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %95 = inttoptr i64 %91 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %94, i64* %96
  br label %$17
$21:
  %97 = phi i64 [%83, %$18] ; # X
  %98 = phi i64 [%84, %$18] ; # N
  %99 = phi i64 [%85, %$18] ; # L
  %100 = phi i64 [%86, %$18] ; # Y
; # (set 2 Y (cons X L))
; # (cons X L)
  %101 = call i64 @cons(i64 %97, i64 %99)
  %102 = inttoptr i64 %100 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  store i64 %101, i64* %103
  br label %$16
$16:
  %104 = phi i64 [%50, %$14], [%97, %$21] ; # X
  %105 = phi i64 [%51, %$14], [%98, %$21] ; # N
  %106 = phi i64 [%52, %$14], [%99, %$21] ; # L
  %107 = phi i64 [%53, %$14], [%59, %$21] ; # ->
; # (drop *Safe)
  %108 = inttoptr i64 %21 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  %110 = load i64, i64* %109
  %111 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %110, i64* %111
  ret i64 %107
}

define i64 @_remove(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) L (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = add i64 %21, 8
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %25
; # (cond ((or (atom L) (lt0 (dec 'N))) L) ((=0 N) (cdr L)) (T (let (...
; # (or (atom L) (lt0 (dec 'N)))
; # (atom L)
  %26 = and i64 %17, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$8, label %$9
$9:
  %28 = phi i64 [%4, %$2] ; # N
  %29 = phi i64 [%17, %$2] ; # L
; # (dec 'N)
  %30 = sub i64 %28, 1
; # (lt0 (dec 'N))
  %31 = icmp slt i64 %30, 0
  br label %$8
$8:
  %32 = phi i64 [%4, %$2], [%30, %$9] ; # N
  %33 = phi i64 [%17, %$2], [%29, %$9] ; # L
  %34 = phi i1 [1, %$2], [%31, %$9] ; # ->
  br i1 %34, label %$11, label %$10
$11:
  %35 = phi i64 [%32, %$8] ; # N
  %36 = phi i64 [%33, %$8] ; # L
  br label %$7
$10:
  %37 = phi i64 [%32, %$8] ; # N
  %38 = phi i64 [%33, %$8] ; # L
; # (=0 N)
  %39 = icmp eq i64 %37, 0
  br i1 %39, label %$13, label %$12
$13:
  %40 = phi i64 [%37, %$10] ; # N
  %41 = phi i64 [%38, %$10] ; # L
; # (cdr L)
  %42 = inttoptr i64 %41 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
  br label %$7
$12:
  %45 = phi i64 [%37, %$10] ; # N
  %46 = phi i64 [%38, %$10] ; # L
; # (let (Y (cons (car L) $Nil) R (save Y)) (loop (? (atom (shift L))...
; # (car L)
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
; # (cons (car L) $Nil)
  %49 = call i64 @cons(i64 %48, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = alloca i64, i64 2, align 16
  %53 = ptrtoint i64* %52 to i64
  %54 = inttoptr i64 %53 to i64*
  store i64 %49, i64* %54
  %55 = add i64 %53, 8
  %56 = inttoptr i64 %55 to i64*
  store i64 %51, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %57
; # (loop (? (atom (shift L)) (set 2 Y L)) (? (=0 (dec 'N)) (set 2 Y ...
  br label %$14
$14:
  %58 = phi i64 [%45, %$12], [%84, %$18] ; # N
  %59 = phi i64 [%46, %$12], [%85, %$18] ; # L
  %60 = phi i64 [%49, %$12], [%89, %$18] ; # Y
; # (? (atom (shift L)) (set 2 Y L))
; # (shift L)
  %61 = inttoptr i64 %59 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
; # (atom (shift L))
  %64 = and i64 %63, 15
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$17, label %$15
$17:
  %66 = phi i64 [%58, %$14] ; # N
  %67 = phi i64 [%63, %$14] ; # L
  %68 = phi i64 [%60, %$14] ; # Y
; # (set 2 Y L)
  %69 = inttoptr i64 %68 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  store i64 %67, i64* %70
  br label %$16
$15:
  %71 = phi i64 [%58, %$14] ; # N
  %72 = phi i64 [%63, %$14] ; # L
  %73 = phi i64 [%60, %$14] ; # Y
; # (? (=0 (dec 'N)) (set 2 Y (cdr L)))
; # (dec 'N)
  %74 = sub i64 %71, 1
; # (=0 (dec 'N))
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$19, label %$18
$19:
  %76 = phi i64 [%74, %$15] ; # N
  %77 = phi i64 [%72, %$15] ; # L
  %78 = phi i64 [%73, %$15] ; # Y
; # (set 2 Y (cdr L))
; # (cdr L)
  %79 = inttoptr i64 %77 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %78 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  store i64 %81, i64* %83
  br label %$16
$18:
  %84 = phi i64 [%74, %$15] ; # N
  %85 = phi i64 [%72, %$15] ; # L
  %86 = phi i64 [%73, %$15] ; # Y
; # (set 2 Y (cons (car L) $Nil))
; # (car L)
  %87 = inttoptr i64 %85 to i64*
  %88 = load i64, i64* %87
; # (cons (car L) $Nil)
  %89 = call i64 @cons(i64 %88, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %90 = inttoptr i64 %86 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %89, i64* %91
  br label %$14
$16:
  %92 = phi i64 [%66, %$17], [%76, %$19] ; # N
  %93 = phi i64 [%67, %$17], [%77, %$19] ; # L
  %94 = phi i64 [%68, %$17], [%78, %$19] ; # Y
  %95 = phi i64 [%67, %$17], [%81, %$19] ; # ->
  br label %$7
$7:
  %96 = phi i64 [%35, %$11], [%40, %$13], [%92, %$16] ; # N
  %97 = phi i64 [%36, %$11], [%41, %$13], [%93, %$16] ; # L
  %98 = phi i64 [%36, %$11], [%44, %$13], [%49, %$16] ; # ->
; # (drop *Safe)
  %99 = inttoptr i64 %21 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %101, i64* %102
  ret i64 %98
}

define i64 @_place(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) L (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = add i64 %21, 8
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %25
; # (shift X)
  %26 = inttoptr i64 %7 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (car (shift X))
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (eval (car (shift X)))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  br label %$7
$8:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$11, label %$10
$11:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$7
$10:
  %37 = call i64 @evList(i64 %30)
  br label %$7
$7:
  %38 = phi i64 [%30, %$9], [%36, %$11], [%37, %$10] ; # ->
; # (save (eval (car (shift X))))
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = add i64 %42, 8
  %45 = inttoptr i64 %44 to i64*
  store i64 %40, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %46
; # (cond ((atom L) (cons Y $Nil)) ((le0 (dec 'N)) (cons Y (cdr L))) ...
; # (atom L)
  %47 = and i64 %17, 15
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$14, label %$13
$14:
  %49 = phi i64 [%4, %$7] ; # N
  %50 = phi i64 [%17, %$7] ; # L
; # (cons Y $Nil)
  %51 = call i64 @cons(i64 %38, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$12
$13:
  %52 = phi i64 [%4, %$7] ; # N
  %53 = phi i64 [%17, %$7] ; # L
; # (dec 'N)
  %54 = sub i64 %52, 1
; # (le0 (dec 'N))
  %55 = icmp sle i64 %54, 0
  br i1 %55, label %$16, label %$15
$16:
  %56 = phi i64 [%54, %$13] ; # N
  %57 = phi i64 [%53, %$13] ; # L
; # (cdr L)
  %58 = inttoptr i64 %57 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
; # (cons Y (cdr L))
  %61 = call i64 @cons(i64 %38, i64 %60)
  br label %$12
$15:
  %62 = phi i64 [%54, %$13] ; # N
  %63 = phi i64 [%53, %$13] ; # L
; # (let (Z (cons (car L) $Nil) R (save Z)) (loop (? (atom (shift L))...
; # (car L)
  %64 = inttoptr i64 %63 to i64*
  %65 = load i64, i64* %64
; # (cons (car L) $Nil)
  %66 = call i64 @cons(i64 %65, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Z)
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %68 = load i64, i64* %67
  %69 = alloca i64, i64 2, align 16
  %70 = ptrtoint i64* %69 to i64
  %71 = inttoptr i64 %70 to i64*
  store i64 %66, i64* %71
  %72 = add i64 %70, 8
  %73 = inttoptr i64 %72 to i64*
  store i64 %68, i64* %73
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %74
; # (loop (? (atom (shift L)) (set 2 Z (cons Y L))) (? (=0 (dec 'N)) ...
  br label %$17
$17:
  %75 = phi i64 [%62, %$15], [%103, %$21] ; # N
  %76 = phi i64 [%63, %$15], [%104, %$21] ; # L
  %77 = phi i64 [%66, %$15], [%108, %$21] ; # Z
; # (? (atom (shift L)) (set 2 Z (cons Y L)))
; # (shift L)
  %78 = inttoptr i64 %76 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  %80 = load i64, i64* %79
; # (atom (shift L))
  %81 = and i64 %80, 15
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$20, label %$18
$20:
  %83 = phi i64 [%75, %$17] ; # N
  %84 = phi i64 [%80, %$17] ; # L
  %85 = phi i64 [%77, %$17] ; # Z
; # (set 2 Z (cons Y L))
; # (cons Y L)
  %86 = call i64 @cons(i64 %38, i64 %84)
  %87 = inttoptr i64 %85 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  store i64 %86, i64* %88
  br label %$19
$18:
  %89 = phi i64 [%75, %$17] ; # N
  %90 = phi i64 [%80, %$17] ; # L
  %91 = phi i64 [%77, %$17] ; # Z
; # (? (=0 (dec 'N)) (set 2 Z (cons Y (cdr L))))
; # (dec 'N)
  %92 = sub i64 %89, 1
; # (=0 (dec 'N))
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %$22, label %$21
$22:
  %94 = phi i64 [%92, %$18] ; # N
  %95 = phi i64 [%90, %$18] ; # L
  %96 = phi i64 [%91, %$18] ; # Z
; # (set 2 Z (cons Y (cdr L)))
; # (cdr L)
  %97 = inttoptr i64 %95 to i64*
  %98 = getelementptr i64, i64* %97, i32 1
  %99 = load i64, i64* %98
; # (cons Y (cdr L))
  %100 = call i64 @cons(i64 %38, i64 %99)
  %101 = inttoptr i64 %96 to i64*
  %102 = getelementptr i64, i64* %101, i32 1
  store i64 %100, i64* %102
  br label %$19
$21:
  %103 = phi i64 [%92, %$18] ; # N
  %104 = phi i64 [%90, %$18] ; # L
  %105 = phi i64 [%91, %$18] ; # Z
; # (set 2 Z (cons (car L) $Nil))
; # (car L)
  %106 = inttoptr i64 %104 to i64*
  %107 = load i64, i64* %106
; # (cons (car L) $Nil)
  %108 = call i64 @cons(i64 %107, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %109 = inttoptr i64 %105 to i64*
  %110 = getelementptr i64, i64* %109, i32 1
  store i64 %108, i64* %110
  br label %$17
$19:
  %111 = phi i64 [%83, %$20], [%94, %$22] ; # N
  %112 = phi i64 [%84, %$20], [%95, %$22] ; # L
  %113 = phi i64 [%85, %$20], [%96, %$22] ; # Z
  %114 = phi i64 [%86, %$20], [%100, %$22] ; # ->
  br label %$12
$12:
  %115 = phi i64 [%49, %$14], [%56, %$16], [%111, %$19] ; # N
  %116 = phi i64 [%50, %$14], [%57, %$16], [%112, %$19] ; # L
  %117 = phi i64 [%51, %$14], [%61, %$16], [%66, %$19] ; # ->
; # (drop *Safe)
  %118 = inttoptr i64 %21 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %120, i64* %121
  ret i64 %117
}

define i64 @_strip(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (while (and (pair X) (== $Quote (car X))...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (while (and (pair X) (== $Quote (car X))) (? (== (cdr X) X)) (set...
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%26, %$12] ; # X
; # (and (pair X) (== $Quote (car X)))
; # (pair X)
  %15 = and i64 %14, 15
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i64 [%14, %$7] ; # X
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (== $Quote (car X))
  %20 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 264) to i64), %19
  br label %$8
$8:
  %21 = phi i64 [%14, %$7], [%17, %$9] ; # X
  %22 = phi i1 [0, %$7], [%20, %$9] ; # ->
  br i1 %22, label %$10, label %$11
$10:
  %23 = phi i64 [%21, %$8] ; # X
; # (? (== (cdr X) X))
; # (cdr X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (== (cdr X) X)
  %27 = icmp eq i64 %26, %23
  br i1 %27, label %$11, label %$12
$12:
  %28 = phi i64 [%23, %$10] ; # X
  br label %$7
$11:
  %29 = phi i64 [%21, %$8], [%23, %$10] ; # X
  ret i64 %29
}

define i64 @_split(i64) align 8 {
$1:
; # (let (X (cdr Exe) L (save (eval (car X)))) (if (atom L) @ (let (A...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (if (atom L) @ (let (A $Nil N 0) (while (pair (shift X)) (setq A ...
; # (atom L)
  %22 = and i64 %13, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$7, label %$8
$7:
  %24 = phi i64 [%3, %$2] ; # X
  %25 = phi i64 [%13, %$2] ; # L
  br label %$9
$8:
  %26 = phi i64 [%3, %$2] ; # X
  %27 = phi i64 [%13, %$2] ; # L
; # (let (A $Nil N 0) (while (pair (shift X)) (setq A (link (push (ev...
; # (while (pair (shift X)) (setq A (link (push (eval (car X)) NIL)))...
  br label %$10
$10:
  %28 = phi i64 [%26, %$8], [%37, %$13] ; # X
  %29 = phi i64 [%27, %$8], [%38, %$13] ; # L
  %30 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8], [%52, %$13] ; # A
  %31 = phi i64 [0, %$8], [%59, %$13] ; # N
; # (shift X)
  %32 = inttoptr i64 %28 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (pair (shift X))
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$11, label %$12
$11:
  %37 = phi i64 [%34, %$10] ; # X
  %38 = phi i64 [%29, %$10] ; # L
  %39 = phi i64 [%30, %$10] ; # A
  %40 = phi i64 [%31, %$10] ; # N
; # (car X)
  %41 = inttoptr i64 %37 to i64*
  %42 = load i64, i64* %41
; # (eval (car X))
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$14
$15:
  br label %$13
$14:
  %45 = and i64 %42, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$17, label %$16
$17:
  %47 = inttoptr i64 %42 to i64*
  %48 = load i64, i64* %47
  br label %$13
$16:
  %49 = call i64 @evList(i64 %42)
  br label %$13
$13:
  %50 = phi i64 [%42, %$15], [%48, %$17], [%49, %$16] ; # ->
; # (push (eval (car X)) NIL)
  %51 = alloca i64, i64 2, align 16
  %52 = ptrtoint i64* %51 to i64
  %53 = inttoptr i64 %52 to i64*
  store i64 %50, i64* %53
; # (link (push (eval (car X)) NIL))
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = inttoptr i64 %52 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  store i64 %55, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %58
; # (inc 'N)
  %59 = add i64 %40, 1
  br label %$10
$12:
  %60 = phi i64 [%34, %$10] ; # X
  %61 = phi i64 [%29, %$10] ; # L
  %62 = phi i64 [%30, %$10] ; # A
  %63 = phi i64 [%31, %$10] ; # N
; # (let (P $Nil R (link (push P NIL)) Q $Nil S (link (push Q NIL))) ...
; # (push P NIL)
  %64 = alloca i64, i64 2, align 16
  %65 = ptrtoint i64* %64 to i64
  %66 = inttoptr i64 %65 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %66
; # (link (push P NIL))
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %68 = load i64, i64* %67
  %69 = inttoptr i64 %65 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  store i64 %68, i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %71
; # (push Q NIL)
  %72 = alloca i64, i64 2, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = inttoptr i64 %73 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %74
; # (link (push Q NIL))
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %73 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %79
; # (loop (let (Y (++ L) Z A I N) (loop (? (lt0 (dec 'I)) (let C (con...
  br label %$18
$18:
  %80 = phi i64 [%60, %$12], [%211, %$31] ; # X
  %81 = phi i64 [%61, %$12], [%212, %$31] ; # L
  %82 = phi i64 [%62, %$12], [%213, %$31] ; # A
  %83 = phi i64 [%63, %$12], [%214, %$31] ; # N
  %84 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%215, %$31] ; # P
  %85 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%216, %$31] ; # Q
; # (let (Y (++ L) Z A I N) (loop (? (lt0 (dec 'I)) (let C (cons Y $N...
; # (++ L)
  %86 = inttoptr i64 %81 to i64*
  %87 = load i64, i64* %86
  %88 = getelementptr i64, i64* %86, i32 1
  %89 = load i64, i64* %88
; # (loop (? (lt0 (dec 'I)) (let C (cons Y $Nil) (setq Q (if (nil? Q)...
  br label %$19
$19:
  %90 = phi i64 [%80, %$18], [%192, %$26] ; # X
  %91 = phi i64 [%89, %$18], [%193, %$26] ; # L
  %92 = phi i64 [%82, %$18], [%194, %$26] ; # A
  %93 = phi i64 [%83, %$18], [%195, %$26] ; # N
  %94 = phi i64 [%84, %$18], [%196, %$26] ; # P
  %95 = phi i64 [%85, %$18], [%197, %$26] ; # Q
  %96 = phi i64 [%82, %$18], [%198, %$26] ; # Z
  %97 = phi i64 [%83, %$18], [%199, %$26] ; # I
; # (? (lt0 (dec 'I)) (let C (cons Y $Nil) (setq Q (if (nil? Q) (set ...
; # (dec 'I)
  %98 = sub i64 %97, 1
; # (lt0 (dec 'I))
  %99 = icmp slt i64 %98, 0
  br i1 %99, label %$22, label %$20
$22:
  %100 = phi i64 [%90, %$19] ; # X
  %101 = phi i64 [%91, %$19] ; # L
  %102 = phi i64 [%92, %$19] ; # A
  %103 = phi i64 [%93, %$19] ; # N
  %104 = phi i64 [%94, %$19] ; # P
  %105 = phi i64 [%95, %$19] ; # Q
  %106 = phi i64 [%96, %$19] ; # Z
  %107 = phi i64 [%98, %$19] ; # I
; # (let C (cons Y $Nil) (setq Q (if (nil? Q) (set S C) (set 2 Q C)))...
; # (cons Y $Nil)
  %108 = call i64 @cons(i64 %87, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if (nil? Q) (set S C) (set 2 Q C))
; # (nil? Q)
  %109 = icmp eq i64 %105, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %109, label %$23, label %$24
$23:
  %110 = phi i64 [%100, %$22] ; # X
  %111 = phi i64 [%101, %$22] ; # L
  %112 = phi i64 [%102, %$22] ; # A
  %113 = phi i64 [%103, %$22] ; # N
  %114 = phi i64 [%104, %$22] ; # P
  %115 = phi i64 [%105, %$22] ; # Q
  %116 = phi i64 [%106, %$22] ; # Z
  %117 = phi i64 [%107, %$22] ; # I
; # (set S C)
  %118 = inttoptr i64 %73 to i64*
  store i64 %108, i64* %118
  br label %$25
$24:
  %119 = phi i64 [%100, %$22] ; # X
  %120 = phi i64 [%101, %$22] ; # L
  %121 = phi i64 [%102, %$22] ; # A
  %122 = phi i64 [%103, %$22] ; # N
  %123 = phi i64 [%104, %$22] ; # P
  %124 = phi i64 [%105, %$22] ; # Q
  %125 = phi i64 [%106, %$22] ; # Z
  %126 = phi i64 [%107, %$22] ; # I
; # (set 2 Q C)
  %127 = inttoptr i64 %124 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  store i64 %108, i64* %128
  br label %$25
$25:
  %129 = phi i64 [%110, %$23], [%119, %$24] ; # X
  %130 = phi i64 [%111, %$23], [%120, %$24] ; # L
  %131 = phi i64 [%112, %$23], [%121, %$24] ; # A
  %132 = phi i64 [%113, %$23], [%122, %$24] ; # N
  %133 = phi i64 [%114, %$23], [%123, %$24] ; # P
  %134 = phi i64 [%115, %$23], [%124, %$24] ; # Q
  %135 = phi i64 [%116, %$23], [%125, %$24] ; # Z
  %136 = phi i64 [%117, %$23], [%126, %$24] ; # I
  %137 = phi i64 [%108, %$23], [%108, %$24] ; # ->
  br label %$21
$20:
  %138 = phi i64 [%90, %$19] ; # X
  %139 = phi i64 [%91, %$19] ; # L
  %140 = phi i64 [%92, %$19] ; # A
  %141 = phi i64 [%93, %$19] ; # N
  %142 = phi i64 [%94, %$19] ; # P
  %143 = phi i64 [%95, %$19] ; # Q
  %144 = phi i64 [%96, %$19] ; # Z
  %145 = phi i64 [%98, %$19] ; # I
; # (? (equal Y (++ Z)) (let C (cons (val S) $Nil) (setq P (if (nil? ...
; # (++ Z)
  %146 = inttoptr i64 %144 to i64*
  %147 = load i64, i64* %146
  %148 = getelementptr i64, i64* %146, i32 1
  %149 = load i64, i64* %148
; # (equal Y (++ Z))
  %150 = call i1 @equal(i64 %87, i64 %147)
  br i1 %150, label %$27, label %$26
$27:
  %151 = phi i64 [%138, %$20] ; # X
  %152 = phi i64 [%139, %$20] ; # L
  %153 = phi i64 [%140, %$20] ; # A
  %154 = phi i64 [%141, %$20] ; # N
  %155 = phi i64 [%142, %$20] ; # P
  %156 = phi i64 [%143, %$20] ; # Q
  %157 = phi i64 [%149, %$20] ; # Z
  %158 = phi i64 [%145, %$20] ; # I
; # (let C (cons (val S) $Nil) (setq P (if (nil? P) (set R C) (set 2 ...
; # (val S)
  %159 = inttoptr i64 %73 to i64*
  %160 = load i64, i64* %159
; # (cons (val S) $Nil)
  %161 = call i64 @cons(i64 %160, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if (nil? P) (set R C) (set 2 P C))
; # (nil? P)
  %162 = icmp eq i64 %155, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %162, label %$28, label %$29
$28:
  %163 = phi i64 [%151, %$27] ; # X
  %164 = phi i64 [%152, %$27] ; # L
  %165 = phi i64 [%153, %$27] ; # A
  %166 = phi i64 [%154, %$27] ; # N
  %167 = phi i64 [%155, %$27] ; # P
  %168 = phi i64 [%156, %$27] ; # Q
  %169 = phi i64 [%157, %$27] ; # Z
  %170 = phi i64 [%158, %$27] ; # I
; # (set R C)
  %171 = inttoptr i64 %65 to i64*
  store i64 %161, i64* %171
  br label %$30
$29:
  %172 = phi i64 [%151, %$27] ; # X
  %173 = phi i64 [%152, %$27] ; # L
  %174 = phi i64 [%153, %$27] ; # A
  %175 = phi i64 [%154, %$27] ; # N
  %176 = phi i64 [%155, %$27] ; # P
  %177 = phi i64 [%156, %$27] ; # Q
  %178 = phi i64 [%157, %$27] ; # Z
  %179 = phi i64 [%158, %$27] ; # I
; # (set 2 P C)
  %180 = inttoptr i64 %176 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  store i64 %161, i64* %181
  br label %$30
$30:
  %182 = phi i64 [%163, %$28], [%172, %$29] ; # X
  %183 = phi i64 [%164, %$28], [%173, %$29] ; # L
  %184 = phi i64 [%165, %$28], [%174, %$29] ; # A
  %185 = phi i64 [%166, %$28], [%175, %$29] ; # N
  %186 = phi i64 [%167, %$28], [%176, %$29] ; # P
  %187 = phi i64 [%168, %$28], [%177, %$29] ; # Q
  %188 = phi i64 [%169, %$28], [%178, %$29] ; # Z
  %189 = phi i64 [%170, %$28], [%179, %$29] ; # I
  %190 = phi i64 [%161, %$28], [%161, %$29] ; # ->
; # (set S $Nil)
  %191 = inttoptr i64 %73 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %191
  br label %$21
$26:
  %192 = phi i64 [%138, %$20] ; # X
  %193 = phi i64 [%139, %$20] ; # L
  %194 = phi i64 [%140, %$20] ; # A
  %195 = phi i64 [%141, %$20] ; # N
  %196 = phi i64 [%142, %$20] ; # P
  %197 = phi i64 [%143, %$20] ; # Q
  %198 = phi i64 [%149, %$20] ; # Z
  %199 = phi i64 [%145, %$20] ; # I
  br label %$19
$21:
  %200 = phi i64 [%129, %$25], [%182, %$30] ; # X
  %201 = phi i64 [%130, %$25], [%183, %$30] ; # L
  %202 = phi i64 [%131, %$25], [%184, %$30] ; # A
  %203 = phi i64 [%132, %$25], [%185, %$30] ; # N
  %204 = phi i64 [%133, %$25], [%190, %$30] ; # P
  %205 = phi i64 [%137, %$25], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$30] ; # Q
  %206 = phi i64 [%135, %$25], [%188, %$30] ; # Z
  %207 = phi i64 [%136, %$25], [%189, %$30] ; # I
  %208 = phi i64 [%137, %$25], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$30] ; # ->
; # (? (atom L))
; # (atom L)
  %209 = and i64 %201, 15
  %210 = icmp ne i64 %209, 0
  br i1 %210, label %$32, label %$31
$31:
  %211 = phi i64 [%200, %$21] ; # X
  %212 = phi i64 [%201, %$21] ; # L
  %213 = phi i64 [%202, %$21] ; # A
  %214 = phi i64 [%203, %$21] ; # N
  %215 = phi i64 [%204, %$21] ; # P
  %216 = phi i64 [%205, %$21] ; # Q
  br label %$18
$32:
  %217 = phi i64 [%200, %$21] ; # X
  %218 = phi i64 [%201, %$21] ; # L
  %219 = phi i64 [%202, %$21] ; # A
  %220 = phi i64 [%203, %$21] ; # N
  %221 = phi i64 [%204, %$21] ; # P
  %222 = phi i64 [%205, %$21] ; # Q
  %223 = phi i64 [0, %$21] ; # ->
; # (let C (cons (val S) $Nil) (if (nil? P) C (set 2 P C) (val R)))
; # (val S)
  %224 = inttoptr i64 %73 to i64*
  %225 = load i64, i64* %224
; # (cons (val S) $Nil)
  %226 = call i64 @cons(i64 %225, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if (nil? P) C (set 2 P C) (val R))
; # (nil? P)
  %227 = icmp eq i64 %221, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %227, label %$33, label %$34
$33:
  %228 = phi i64 [%217, %$32] ; # X
  %229 = phi i64 [%218, %$32] ; # L
  %230 = phi i64 [%219, %$32] ; # A
  %231 = phi i64 [%220, %$32] ; # N
  %232 = phi i64 [%221, %$32] ; # P
  %233 = phi i64 [%222, %$32] ; # Q
  br label %$35
$34:
  %234 = phi i64 [%217, %$32] ; # X
  %235 = phi i64 [%218, %$32] ; # L
  %236 = phi i64 [%219, %$32] ; # A
  %237 = phi i64 [%220, %$32] ; # N
  %238 = phi i64 [%221, %$32] ; # P
  %239 = phi i64 [%222, %$32] ; # Q
; # (set 2 P C)
  %240 = inttoptr i64 %238 to i64*
  %241 = getelementptr i64, i64* %240, i32 1
  store i64 %226, i64* %241
; # (val R)
  %242 = inttoptr i64 %65 to i64*
  %243 = load i64, i64* %242
  br label %$35
$35:
  %244 = phi i64 [%228, %$33], [%234, %$34] ; # X
  %245 = phi i64 [%229, %$33], [%235, %$34] ; # L
  %246 = phi i64 [%230, %$33], [%236, %$34] ; # A
  %247 = phi i64 [%231, %$33], [%237, %$34] ; # N
  %248 = phi i64 [%232, %$33], [%238, %$34] ; # P
  %249 = phi i64 [%233, %$33], [%239, %$34] ; # Q
  %250 = phi i64 [%226, %$33], [%243, %$34] ; # ->
  br label %$9
$9:
  %251 = phi i64 [%24, %$7], [%244, %$35] ; # X
  %252 = phi i64 [%25, %$7], [%245, %$35] ; # L
  %253 = phi i64 [%13, %$7], [%250, %$35] ; # ->
; # (drop *Safe)
  %254 = inttoptr i64 %17 to i64*
  %255 = getelementptr i64, i64* %254, i32 1
  %256 = load i64, i64* %255
  %257 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %256, i64* %257
  ret i64 %253
}

define i64 @_reverse(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X))) Z $Nil) (while (pair Y)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (while (pair Y) (setq Z (cons (++ Y) Z)))
  br label %$7
$7:
  %22 = phi i64 [%13, %$2], [%31, %$8] ; # Y
  %23 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%32, %$8] ; # Z
; # (pair Y)
  %24 = and i64 %22, 15
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %$8, label %$9
$8:
  %26 = phi i64 [%22, %$7] ; # Y
  %27 = phi i64 [%23, %$7] ; # Z
; # (++ Y)
  %28 = inttoptr i64 %26 to i64*
  %29 = load i64, i64* %28
  %30 = getelementptr i64, i64* %28, i32 1
  %31 = load i64, i64* %30
; # (cons (++ Y) Z)
  %32 = call i64 @cons(i64 %29, i64 %27)
  br label %$7
$9:
  %33 = phi i64 [%22, %$7] ; # Y
  %34 = phi i64 [%23, %$7] ; # Z
; # (drop *Safe)
  %35 = inttoptr i64 %17 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %38
  ret i64 %34
}

define i64 @_flip(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (if (atom Y) Y (let Z (cdr Y)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (atom Y) Y (let Z (cdr Y) (cond ((atom Z) Y) ((atom (shift X)...
; # (atom Y)
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%3, %$2] ; # X
  %17 = phi i64 [%13, %$2] ; # Y
  br label %$9
$8:
  %18 = phi i64 [%3, %$2] ; # X
  %19 = phi i64 [%13, %$2] ; # Y
; # (let Z (cdr Y) (cond ((atom Z) Y) ((atom (shift X)) (set 2 Y $Nil...
; # (cdr Y)
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (cond ((atom Z) Y) ((atom (shift X)) (set 2 Y $Nil) (loop (setq X...
; # (atom Z)
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%18, %$8] ; # X
  %26 = phi i64 [%19, %$8] ; # Y
  %27 = phi i64 [%22, %$8] ; # Z
  br label %$10
$11:
  %28 = phi i64 [%18, %$8] ; # X
  %29 = phi i64 [%19, %$8] ; # Y
  %30 = phi i64 [%22, %$8] ; # Z
; # (shift X)
  %31 = inttoptr i64 %28 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
; # (atom (shift X))
  %34 = and i64 %33, 15
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$14, label %$13
$14:
  %36 = phi i64 [%33, %$11] ; # X
  %37 = phi i64 [%29, %$11] ; # Y
  %38 = phi i64 [%30, %$11] ; # Z
; # (set 2 Y $Nil)
  %39 = inttoptr i64 %37 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %40
; # (loop (setq X (cdr Z)) (set 2 Z Y) (? (atom X) Z) (setq Y Z Z X))...
  br label %$15
$15:
  %41 = phi i64 [%36, %$14], [%54, %$16] ; # X
  %42 = phi i64 [%37, %$14], [%56, %$16] ; # Y
  %43 = phi i64 [%38, %$14], [%54, %$16] ; # Z
; # (cdr Z)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (set 2 Z Y)
  %47 = inttoptr i64 %43 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %42, i64* %48
; # (? (atom X) Z)
; # (atom X)
  %49 = and i64 %46, 15
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$18, label %$16
$18:
  %51 = phi i64 [%46, %$15] ; # X
  %52 = phi i64 [%42, %$15] ; # Y
  %53 = phi i64 [%43, %$15] ; # Z
  br label %$17
$16:
  %54 = phi i64 [%46, %$15] ; # X
  %55 = phi i64 [%42, %$15] ; # Y
  %56 = phi i64 [%43, %$15] ; # Z
  br label %$15
$17:
  %57 = phi i64 [%51, %$18] ; # X
  %58 = phi i64 [%52, %$18] ; # Y
  %59 = phi i64 [%53, %$18] ; # Z
  %60 = phi i64 [%53, %$18] ; # ->
  br label %$10
$13:
  %61 = phi i64 [%33, %$11] ; # X
  %62 = phi i64 [%29, %$11] ; # Y
  %63 = phi i64 [%30, %$11] ; # Z
; # (let N (save Y (evCnt Exe X)) (if (le0 (dec 'N)) Y (set 2 Y (cdr ...
; # (save Y (evCnt Exe X))
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %65 = load i64, i64* %64
  %66 = alloca i64, i64 2, align 16
  %67 = ptrtoint i64* %66 to i64
  %68 = inttoptr i64 %67 to i64*
  store i64 %62, i64* %68
  %69 = add i64 %67, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 %65, i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %71
; # (evCnt Exe X)
  %72 = call i64 @evCnt(i64 %0, i64 %61)
; # drop
  %73 = inttoptr i64 %67 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %76
; # (if (le0 (dec 'N)) Y (set 2 Y (cdr Z) 2 Z Y) (until (or (=0 (dec ...
; # (dec 'N)
  %77 = sub i64 %72, 1
; # (le0 (dec 'N))
  %78 = icmp sle i64 %77, 0
  br i1 %78, label %$19, label %$20
$19:
  %79 = phi i64 [%61, %$13] ; # X
  %80 = phi i64 [%62, %$13] ; # Y
  %81 = phi i64 [%63, %$13] ; # Z
  %82 = phi i64 [%77, %$13] ; # N
  br label %$21
$20:
  %83 = phi i64 [%61, %$13] ; # X
  %84 = phi i64 [%62, %$13] ; # Y
  %85 = phi i64 [%63, %$13] ; # Z
  %86 = phi i64 [%77, %$13] ; # N
; # (set 2 Y (cdr Z) 2 Z Y)
; # (cdr Z)
  %87 = inttoptr i64 %85 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
  %90 = inttoptr i64 %84 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %89, i64* %91
  %92 = inttoptr i64 %85 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  store i64 %84, i64* %93
; # (until (or (=0 (dec 'N)) (atom (setq X (cdr Y)))) (set 2 Y (cdr X...
  br label %$22
$22:
  %94 = phi i64 [%83, %$20], [%114, %$25] ; # X
  %95 = phi i64 [%84, %$20], [%115, %$25] ; # Y
  %96 = phi i64 [%85, %$20], [%114, %$25] ; # Z
  %97 = phi i64 [%86, %$20], [%117, %$25] ; # N
; # (or (=0 (dec 'N)) (atom (setq X (cdr Y))))
; # (dec 'N)
  %98 = sub i64 %97, 1
; # (=0 (dec 'N))
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %$23, label %$24
$24:
  %100 = phi i64 [%94, %$22] ; # X
  %101 = phi i64 [%95, %$22] ; # Y
  %102 = phi i64 [%96, %$22] ; # Z
  %103 = phi i64 [%98, %$22] ; # N
; # (cdr Y)
  %104 = inttoptr i64 %101 to i64*
  %105 = getelementptr i64, i64* %104, i32 1
  %106 = load i64, i64* %105
; # (atom (setq X (cdr Y)))
  %107 = and i64 %106, 15
  %108 = icmp ne i64 %107, 0
  br label %$23
$23:
  %109 = phi i64 [%94, %$22], [%106, %$24] ; # X
  %110 = phi i64 [%95, %$22], [%101, %$24] ; # Y
  %111 = phi i64 [%96, %$22], [%102, %$24] ; # Z
  %112 = phi i64 [%98, %$22], [%103, %$24] ; # N
  %113 = phi i1 [1, %$22], [%108, %$24] ; # ->
  br i1 %113, label %$26, label %$25
$25:
  %114 = phi i64 [%109, %$23] ; # X
  %115 = phi i64 [%110, %$23] ; # Y
  %116 = phi i64 [%111, %$23] ; # Z
  %117 = phi i64 [%112, %$23] ; # N
; # (set 2 Y (cdr X) 2 X Z)
; # (cdr X)
  %118 = inttoptr i64 %114 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
  %121 = inttoptr i64 %115 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  store i64 %120, i64* %122
  %123 = inttoptr i64 %114 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  store i64 %116, i64* %124
  br label %$22
$26:
  %125 = phi i64 [%109, %$23] ; # X
  %126 = phi i64 [%110, %$23] ; # Y
  %127 = phi i64 [%111, %$23] ; # Z
  %128 = phi i64 [%112, %$23] ; # N
  br label %$21
$21:
  %129 = phi i64 [%79, %$19], [%125, %$26] ; # X
  %130 = phi i64 [%80, %$19], [%126, %$26] ; # Y
  %131 = phi i64 [%81, %$19], [%127, %$26] ; # Z
  %132 = phi i64 [%82, %$19], [%128, %$26] ; # N
  %133 = phi i64 [%80, %$19], [%127, %$26] ; # ->
  br label %$10
$10:
  %134 = phi i64 [%25, %$12], [%57, %$17], [%129, %$21] ; # X
  %135 = phi i64 [%26, %$12], [%58, %$17], [%130, %$21] ; # Y
  %136 = phi i64 [%27, %$12], [%59, %$17], [%131, %$21] ; # Z
  %137 = phi i64 [%26, %$12], [%60, %$17], [%133, %$21] ; # ->
  br label %$9
$9:
  %138 = phi i64 [%16, %$7], [%134, %$10] ; # X
  %139 = phi i64 [%17, %$7], [%135, %$10] ; # Y
  %140 = phi i64 [%17, %$7], [%137, %$10] ; # ->
  ret i64 %140
}

define i64 @trim(i64) align 8 {
$1:
; # (if (atom X) X (stkChk 0) (let Y (trim (cdr X)) (if (and (nil? Y)...
; # (atom X)
  %1 = and i64 %0, 15
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  br label %$4
$3:
; # (stkChk 0)
  %3 = load i8*, i8** @$StkLimit
  %4 = call i8* @llvm.stacksave()
  %5 = icmp ugt i8* %3, %4
  br i1 %5, label %$5, label %$6
$5:
  call void @stkErr(i64 0)
  unreachable
$6:
; # (let Y (trim (cdr X)) (if (and (nil? Y) (isBlank (car X))) $Nil (...
; # (cdr X)
  %6 = inttoptr i64 %0 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
; # (trim (cdr X))
  %9 = call i64 @trim(i64 %8)
; # (if (and (nil? Y) (isBlank (car X))) $Nil (cons (car X) Y))
; # (and (nil? Y) (isBlank (car X)))
; # (nil? Y)
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$8, label %$7
$8:
; # (car X)
  %11 = inttoptr i64 %0 to i64*
  %12 = load i64, i64* %11
; # (isBlank (car X))
  %13 = call i1 @isBlank(i64 %12)
  br label %$7
$7:
  %14 = phi i1 [0, %$6], [%13, %$8] ; # ->
  br i1 %14, label %$9, label %$10
$9:
  br label %$11
$10:
; # (car X)
  %15 = inttoptr i64 %0 to i64*
  %16 = load i64, i64* %15
; # (cons (car X) Y)
  %17 = call i64 @cons(i64 %16, i64 %9)
  br label %$11
$11:
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%17, %$10] ; # ->
  br label %$4
$4:
  %19 = phi i64 [%0, %$2], [%18, %$11] ; # ->
  ret i64 %19
}

define i64 @_trim(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (cadr Exe)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (trim (save (eval (cadr Exe))))
  %22 = call i64 @trim(i64 %13)
; # (drop *Safe)
  %23 = inttoptr i64 %17 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %26
  ret i64 %22
}

define i64 @_clip(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (while (and (pair Y) (isBlank...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (while (and (pair Y) (isBlank (car Y))) (shift Y))
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%26, %$10] ; # Y
; # (and (pair Y) (isBlank (car Y)))
; # (pair Y)
  %15 = and i64 %14, 15
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i64 [%14, %$7] ; # Y
; # (car Y)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (isBlank (car Y))
  %20 = call i1 @isBlank(i64 %19)
  br label %$8
$8:
  %21 = phi i64 [%14, %$7], [%17, %$9] ; # Y
  %22 = phi i1 [0, %$7], [%20, %$9] ; # ->
  br i1 %22, label %$10, label %$11
$10:
  %23 = phi i64 [%21, %$8] ; # Y
; # (shift Y)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
  br label %$7
$11:
  %27 = phi i64 [%21, %$8] ; # Y
; # (save Y)
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %27, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %29, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
; # (trim (save Y))
  %36 = call i64 @trim(i64 %27)
; # (drop *Safe)
  %37 = inttoptr i64 %31 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %40
  ret i64 %36
}

define i64 @_head(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((nil? Y) Y) ((pair Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((nil? Y) Y) ((pair Y) (save Y (let (Z Y L (eval (car X))) ...
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  br label %$7
$8:
; # (pair Y)
  %17 = and i64 %15, 15
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (save Y (let (Z Y L (eval (car X))) (loop (? (or (atom L) (not (e...
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (let (Z Y L (eval (car X))) (loop (? (or (atom L) (not (equal (ca...
; # (car X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
; # (eval (car X))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  br label %$12
$13:
  %31 = and i64 %28, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$15
$16:
  %33 = inttoptr i64 %28 to i64*
  %34 = load i64, i64* %33
  br label %$12
$15:
  %35 = call i64 @evList(i64 %28)
  br label %$12
$12:
  %36 = phi i64 [%28, %$14], [%34, %$16], [%35, %$15] ; # ->
; # (loop (? (or (atom L) (not (equal (car Z) (car L)))) $Nil) (? (at...
  br label %$17
$17:
  %37 = phi i64 [%15, %$12], [%63, %$23] ; # Z
  %38 = phi i64 [%36, %$12], [%67, %$23] ; # L
; # (? (or (atom L) (not (equal (car Z) (car L)))) $Nil)
; # (or (atom L) (not (equal (car Z) (car L))))
; # (atom L)
  %39 = and i64 %38, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$18, label %$19
$19:
  %41 = phi i64 [%37, %$17] ; # Z
  %42 = phi i64 [%38, %$17] ; # L
; # (car Z)
  %43 = inttoptr i64 %41 to i64*
  %44 = load i64, i64* %43
; # (car L)
  %45 = inttoptr i64 %42 to i64*
  %46 = load i64, i64* %45
; # (equal (car Z) (car L))
  %47 = call i1 @equal(i64 %44, i64 %46)
; # (not (equal (car Z) (car L)))
  %48 = icmp eq i1 %47, 0
  br label %$18
$18:
  %49 = phi i64 [%37, %$17], [%41, %$19] ; # Z
  %50 = phi i64 [%38, %$17], [%42, %$19] ; # L
  %51 = phi i1 [1, %$17], [%48, %$19] ; # ->
  br i1 %51, label %$22, label %$20
$22:
  %52 = phi i64 [%49, %$18] ; # Z
  %53 = phi i64 [%50, %$18] ; # L
  br label %$21
$20:
  %54 = phi i64 [%49, %$18] ; # Z
  %55 = phi i64 [%50, %$18] ; # L
; # (? (atom (shift Z)) Y)
; # (shift Z)
  %56 = inttoptr i64 %54 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (atom (shift Z))
  %59 = and i64 %58, 15
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$24:
  %61 = phi i64 [%58, %$20] ; # Z
  %62 = phi i64 [%55, %$20] ; # L
  br label %$21
$23:
  %63 = phi i64 [%58, %$20] ; # Z
  %64 = phi i64 [%55, %$20] ; # L
; # (shift L)
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  br label %$17
$21:
  %68 = phi i64 [%52, %$22], [%61, %$24] ; # Z
  %69 = phi i64 [%53, %$22], [%62, %$24] ; # L
  %70 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$22], [%15, %$24] ; # ->
; # drop
  %71 = inttoptr i64 %22 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %74
  br label %$7
$10:
; # (xCnt Exe Y)
  %75 = call i64 @xCnt(i64 %0, i64 %15)
; # (=0 (xCnt Exe Y))
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %$26, label %$25
$26:
  br label %$7
$25:
; # (let (N @ L (eval (car X))) (cond ((atom L) L) ((and (lt0 N) (le0...
; # (car X)
  %77 = inttoptr i64 %7 to i64*
  %78 = load i64, i64* %77
; # (eval (car X))
  %79 = and i64 %78, 6
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$29, label %$28
$29:
  br label %$27
$28:
  %81 = and i64 %78, 8
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$31, label %$30
$31:
  %83 = inttoptr i64 %78 to i64*
  %84 = load i64, i64* %83
  br label %$27
$30:
  %85 = call i64 @evList(i64 %78)
  br label %$27
$27:
  %86 = phi i64 [%78, %$29], [%84, %$31], [%85, %$30] ; # ->
; # (cond ((atom L) L) ((and (lt0 N) (le0 (inc 'N (length L)))) $Nil)...
; # (atom L)
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$34, label %$33
$34:
  %89 = phi i64 [%75, %$27] ; # N
  %90 = phi i64 [%86, %$27] ; # L
  br label %$32
$33:
  %91 = phi i64 [%75, %$27] ; # N
  %92 = phi i64 [%86, %$27] ; # L
; # (and (lt0 N) (le0 (inc 'N (length L))))
; # (lt0 N)
  %93 = icmp slt i64 %91, 0
  br i1 %93, label %$36, label %$35
$36:
  %94 = phi i64 [%91, %$33] ; # N
  %95 = phi i64 [%92, %$33] ; # L
; # (length L)
  br label %$37
$37:
  %96 = phi i64 [%95, %$36], [%105, %$38] ; # X
  %97 = phi i64 [0, %$36], [%102, %$38] ; # N
  %98 = and i64 %96, 15
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %$38, label %$39
$38:
  %100 = phi i64 [%96, %$37] ; # X
  %101 = phi i64 [%97, %$37] ; # N
  %102 = add i64 %101, 1
  %103 = inttoptr i64 %100 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
  br label %$37
$39:
  %106 = phi i64 [%96, %$37] ; # X
  %107 = phi i64 [%97, %$37] ; # N
; # (inc 'N (length L))
  %108 = add i64 %94, %107
; # (le0 (inc 'N (length L)))
  %109 = icmp sle i64 %108, 0
  br label %$35
$35:
  %110 = phi i64 [%91, %$33], [%108, %$39] ; # N
  %111 = phi i64 [%92, %$33], [%95, %$39] ; # L
  %112 = phi i1 [0, %$33], [%109, %$39] ; # ->
  br i1 %112, label %$41, label %$40
$41:
  %113 = phi i64 [%110, %$35] ; # N
  %114 = phi i64 [%111, %$35] ; # L
  br label %$32
$40:
  %115 = phi i64 [%110, %$35] ; # N
  %116 = phi i64 [%111, %$35] ; # L
; # (save L (let (Z (cons (car L) $Nil) R (save Z)) (while (and (dec ...
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %118 = load i64, i64* %117
  %119 = alloca i64, i64 2, align 16
  %120 = ptrtoint i64* %119 to i64
  %121 = inttoptr i64 %120 to i64*
  store i64 %116, i64* %121
  %122 = add i64 %120, 8
  %123 = inttoptr i64 %122 to i64*
  store i64 %118, i64* %123
  %124 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %120, i64* %124
; # (let (Z (cons (car L) $Nil) R (save Z)) (while (and (dec 'N) (pai...
; # (car L)
  %125 = inttoptr i64 %116 to i64*
  %126 = load i64, i64* %125
; # (cons (car L) $Nil)
  %127 = call i64 @cons(i64 %126, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Z)
  %128 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %129 = load i64, i64* %128
  %130 = alloca i64, i64 2, align 16
  %131 = ptrtoint i64* %130 to i64
  %132 = inttoptr i64 %131 to i64*
  store i64 %127, i64* %132
  %133 = add i64 %131, 8
  %134 = inttoptr i64 %133 to i64*
  store i64 %129, i64* %134
  %135 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %131, i64* %135
; # (while (and (dec 'N) (pair (shift L))) (setq Z (set 2 Z (cons (ca...
  br label %$42
$42:
  %136 = phi i64 [%115, %$40], [%153, %$45] ; # N
  %137 = phi i64 [%116, %$40], [%154, %$45] ; # L
  %138 = phi i64 [%127, %$40], [%158, %$45] ; # Z
; # (and (dec 'N) (pair (shift L)))
; # (dec 'N)
  %139 = sub i64 %136, 1
  %140 = icmp ne i64 %139, 0
  br i1 %140, label %$44, label %$43
$44:
  %141 = phi i64 [%139, %$42] ; # N
  %142 = phi i64 [%137, %$42] ; # L
  %143 = phi i64 [%138, %$42] ; # Z
; # (shift L)
  %144 = inttoptr i64 %142 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (pair (shift L))
  %147 = and i64 %146, 15
  %148 = icmp eq i64 %147, 0
  br label %$43
$43:
  %149 = phi i64 [%139, %$42], [%141, %$44] ; # N
  %150 = phi i64 [%137, %$42], [%146, %$44] ; # L
  %151 = phi i64 [%138, %$42], [%143, %$44] ; # Z
  %152 = phi i1 [0, %$42], [%148, %$44] ; # ->
  br i1 %152, label %$45, label %$46
$45:
  %153 = phi i64 [%149, %$43] ; # N
  %154 = phi i64 [%150, %$43] ; # L
  %155 = phi i64 [%151, %$43] ; # Z
; # (set 2 Z (cons (car L) $Nil))
; # (car L)
  %156 = inttoptr i64 %154 to i64*
  %157 = load i64, i64* %156
; # (cons (car L) $Nil)
  %158 = call i64 @cons(i64 %157, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %159 = inttoptr i64 %155 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  store i64 %158, i64* %160
  br label %$42
$46:
  %161 = phi i64 [%149, %$43] ; # N
  %162 = phi i64 [%150, %$43] ; # L
  %163 = phi i64 [%151, %$43] ; # Z
; # drop
  %164 = inttoptr i64 %120 to i64*
  %165 = getelementptr i64, i64* %164, i32 1
  %166 = load i64, i64* %165
  %167 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %166, i64* %167
  br label %$32
$32:
  %168 = phi i64 [%89, %$34], [%113, %$41], [%161, %$46] ; # N
  %169 = phi i64 [%90, %$34], [%114, %$41], [%162, %$46] ; # L
  %170 = phi i64 [%90, %$34], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$41], [%127, %$46] ; # ->
  br label %$7
$7:
  %171 = phi i64 [%15, %$9], [%70, %$21], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$26], [%170, %$32] ; # ->
  ret i64 %171
}

define i64 @_tail(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((nil? Y) Y) ((pair Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((nil? Y) Y) ((pair Y) (save Y (let L (eval (car X)) (loop ...
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  br label %$7
$8:
; # (pair Y)
  %17 = and i64 %15, 15
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (save Y (let L (eval (car X)) (loop (? (atom L) $Nil) (? (equal L...
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = add i64 %22, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %26
; # (let L (eval (car X)) (loop (? (atom L) $Nil) (? (equal L Y) Y) (...
; # (car X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
; # (eval (car X))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  br label %$12
$13:
  %31 = and i64 %28, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$15
$16:
  %33 = inttoptr i64 %28 to i64*
  %34 = load i64, i64* %33
  br label %$12
$15:
  %35 = call i64 @evList(i64 %28)
  br label %$12
$12:
  %36 = phi i64 [%28, %$14], [%34, %$16], [%35, %$15] ; # ->
; # (loop (? (atom L) $Nil) (? (equal L Y) Y) (? (atom (shift L)) $Ni...
  br label %$17
$17:
  %37 = phi i64 [%36, %$12], [%51, %$23] ; # L
; # (? (atom L) $Nil)
; # (atom L)
  %38 = and i64 %37, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$20, label %$18
$20:
  %40 = phi i64 [%37, %$17] ; # L
  br label %$19
$18:
  %41 = phi i64 [%37, %$17] ; # L
; # (? (equal L Y) Y)
; # (equal L Y)
  %42 = call i1 @equal(i64 %41, i64 %15)
  br i1 %42, label %$22, label %$21
$22:
  %43 = phi i64 [%41, %$18] ; # L
  br label %$19
$21:
  %44 = phi i64 [%41, %$18] ; # L
; # (? (atom (shift L)) $Nil)
; # (shift L)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (atom (shift L))
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$24, label %$23
$24:
  %50 = phi i64 [%47, %$21] ; # L
  br label %$19
$23:
  %51 = phi i64 [%47, %$21] ; # L
  br label %$17
$19:
  %52 = phi i64 [%40, %$20], [%43, %$22], [%50, %$24] ; # L
  %53 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$20], [%15, %$22], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$24] ; # ->
; # drop
  %54 = inttoptr i64 %22 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %56, i64* %57
  br label %$7
$10:
; # (xCnt Exe Y)
  %58 = call i64 @xCnt(i64 %0, i64 %15)
; # (=0 (xCnt Exe Y))
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$26, label %$25
$26:
  br label %$7
$25:
; # (let (N @ L (eval (car X))) (cond ((atom L) L) ((lt0 N) (loop (sh...
; # (car X)
  %60 = inttoptr i64 %7 to i64*
  %61 = load i64, i64* %60
; # (eval (car X))
  %62 = and i64 %61, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$29, label %$28
$29:
  br label %$27
$28:
  %64 = and i64 %61, 8
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$31, label %$30
$31:
  %66 = inttoptr i64 %61 to i64*
  %67 = load i64, i64* %66
  br label %$27
$30:
  %68 = call i64 @evList(i64 %61)
  br label %$27
$27:
  %69 = phi i64 [%61, %$29], [%67, %$31], [%68, %$30] ; # ->
; # (cond ((atom L) L) ((lt0 N) (loop (shift L) (? (=0 (inc 'N)) L)))...
; # (atom L)
  %70 = and i64 %69, 15
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$34, label %$33
$34:
  %72 = phi i64 [%58, %$27] ; # N
  %73 = phi i64 [%69, %$27] ; # L
  br label %$32
$33:
  %74 = phi i64 [%58, %$27] ; # N
  %75 = phi i64 [%69, %$27] ; # L
; # (lt0 N)
  %76 = icmp slt i64 %74, 0
  br i1 %76, label %$36, label %$35
$36:
  %77 = phi i64 [%74, %$33] ; # N
  %78 = phi i64 [%75, %$33] ; # L
; # (loop (shift L) (? (=0 (inc 'N)) L))
  br label %$37
$37:
  %79 = phi i64 [%77, %$36], [%88, %$38] ; # N
  %80 = phi i64 [%78, %$36], [%89, %$38] ; # L
; # (shift L)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (? (=0 (inc 'N)) L)
; # (inc 'N)
  %84 = add i64 %79, 1
; # (=0 (inc 'N))
  %85 = icmp eq i64 %84, 0
  br i1 %85, label %$40, label %$38
$40:
  %86 = phi i64 [%84, %$37] ; # N
  %87 = phi i64 [%83, %$37] ; # L
  br label %$39
$38:
  %88 = phi i64 [%84, %$37] ; # N
  %89 = phi i64 [%83, %$37] ; # L
  br label %$37
$39:
  %90 = phi i64 [%86, %$40] ; # N
  %91 = phi i64 [%87, %$40] ; # L
  %92 = phi i64 [%87, %$40] ; # ->
  br label %$32
$35:
  %93 = phi i64 [%74, %$33] ; # N
  %94 = phi i64 [%75, %$33] ; # L
; # (let Z L (loop (? (=0 (dec 'N))) (? (atom (shift Z)))) (while (pa...
; # (loop (? (=0 (dec 'N))) (? (atom (shift Z))))
  br label %$41
$41:
  %95 = phi i64 [%93, %$35], [%108, %$44] ; # N
  %96 = phi i64 [%94, %$35], [%109, %$44] ; # L
  %97 = phi i64 [%94, %$35], [%110, %$44] ; # Z
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %98 = sub i64 %95, 1
; # (=0 (dec 'N))
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %$43, label %$42
$42:
  %100 = phi i64 [%98, %$41] ; # N
  %101 = phi i64 [%96, %$41] ; # L
  %102 = phi i64 [%97, %$41] ; # Z
; # (? (atom (shift Z)))
; # (shift Z)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
; # (atom (shift Z))
  %106 = and i64 %105, 15
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$43, label %$44
$44:
  %108 = phi i64 [%100, %$42] ; # N
  %109 = phi i64 [%101, %$42] ; # L
  %110 = phi i64 [%105, %$42] ; # Z
  br label %$41
$43:
  %111 = phi i64 [%98, %$41], [%100, %$42] ; # N
  %112 = phi i64 [%96, %$41], [%101, %$42] ; # L
  %113 = phi i64 [%97, %$41], [%105, %$42] ; # Z
  %114 = phi i64 [0, %$41], [0, %$42] ; # ->
; # (while (pair (shift Z)) (shift L))
  br label %$45
$45:
  %115 = phi i64 [%111, %$43], [%123, %$46] ; # N
  %116 = phi i64 [%112, %$43], [%128, %$46] ; # L
  %117 = phi i64 [%113, %$43], [%125, %$46] ; # Z
; # (shift Z)
  %118 = inttoptr i64 %117 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
; # (pair (shift Z))
  %121 = and i64 %120, 15
  %122 = icmp eq i64 %121, 0
  br i1 %122, label %$46, label %$47
$46:
  %123 = phi i64 [%115, %$45] ; # N
  %124 = phi i64 [%116, %$45] ; # L
  %125 = phi i64 [%120, %$45] ; # Z
; # (shift L)
  %126 = inttoptr i64 %124 to i64*
  %127 = getelementptr i64, i64* %126, i32 1
  %128 = load i64, i64* %127
  br label %$45
$47:
  %129 = phi i64 [%115, %$45] ; # N
  %130 = phi i64 [%116, %$45] ; # L
  %131 = phi i64 [%120, %$45] ; # Z
  br label %$32
$32:
  %132 = phi i64 [%72, %$34], [%90, %$39], [%129, %$47] ; # N
  %133 = phi i64 [%73, %$34], [%91, %$39], [%130, %$47] ; # L
  %134 = phi i64 [%73, %$34], [%92, %$39], [%130, %$47] ; # ->
  br label %$7
$7:
  %135 = phi i64 [%15, %$9], [%53, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$26], [%134, %$32] ; # ->
  ret i64 %135
}

define i64 @_stem(i64) align 8 {
$1:
; # (let (X (cdr Exe) L (save (eval (++ X)))) (if (atom X) L (let (R ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (if (atom X) L (let (R L N 1 A T) (loop (setq A (link (push (eval...
; # (atom X)
  %24 = and i64 %7, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$7, label %$8
$7:
  %26 = phi i64 [%7, %$2] ; # X
  %27 = phi i64 [%15, %$2] ; # L
  br label %$9
$8:
  %28 = phi i64 [%7, %$2] ; # X
  %29 = phi i64 [%15, %$2] ; # L
; # (let (R L N 1 A T) (loop (setq A (link (push (eval (car X)) NIL))...
; # (loop (setq A (link (push (eval (car X)) NIL))) (? (atom (shift X...
  br label %$10
$10:
  %30 = phi i64 [%28, %$8], [%57, %$16] ; # X
  %31 = phi i64 [%29, %$8], [%58, %$16] ; # L
  %32 = phi i64 [%29, %$8], [%59, %$16] ; # R
  %33 = phi i64 [1, %$8], [%62, %$16] ; # N
; # (car X)
  %34 = inttoptr i64 %30 to i64*
  %35 = load i64, i64* %34
; # (eval (car X))
  %36 = and i64 %35, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$13, label %$12
$13:
  br label %$11
$12:
  %38 = and i64 %35, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$15, label %$14
$15:
  %40 = inttoptr i64 %35 to i64*
  %41 = load i64, i64* %40
  br label %$11
$14:
  %42 = call i64 @evList(i64 %35)
  br label %$11
$11:
  %43 = phi i64 [%35, %$13], [%41, %$15], [%42, %$14] ; # ->
; # (push (eval (car X)) NIL)
  %44 = alloca i64, i64 2, align 16
  %45 = ptrtoint i64* %44 to i64
  %46 = inttoptr i64 %45 to i64*
  store i64 %43, i64* %46
; # (link (push (eval (car X)) NIL))
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %48 = load i64, i64* %47
  %49 = inttoptr i64 %45 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  store i64 %48, i64* %50
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %51
; # (? (atom (shift X)))
; # (shift X)
  %52 = inttoptr i64 %30 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (atom (shift X))
  %55 = and i64 %54, 15
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$17, label %$16
$16:
  %57 = phi i64 [%54, %$11] ; # X
  %58 = phi i64 [%31, %$11] ; # L
  %59 = phi i64 [%32, %$11] ; # R
  %60 = phi i64 [%33, %$11] ; # N
  %61 = phi i64 [%45, %$11] ; # A
; # (inc 'N)
  %62 = add i64 %60, 1
  br label %$10
$17:
  %63 = phi i64 [%54, %$11] ; # X
  %64 = phi i64 [%31, %$11] ; # L
  %65 = phi i64 [%32, %$11] ; # R
  %66 = phi i64 [%33, %$11] ; # N
  %67 = phi i64 [%45, %$11] ; # A
  %68 = phi i64 [0, %$11] ; # ->
; # (loop (let (P A I N) (loop (? (equal (car L) (car P)) (setq R (cd...
  br label %$18
$18:
  %69 = phi i64 [%63, %$17], [%128, %$24] ; # X
  %70 = phi i64 [%64, %$17], [%129, %$24] ; # L
  %71 = phi i64 [%65, %$17], [%130, %$24] ; # R
  %72 = phi i64 [%66, %$17], [%131, %$24] ; # N
  %73 = phi i64 [%67, %$17], [%132, %$24] ; # A
; # (let (P A I N) (loop (? (equal (car L) (car P)) (setq R (cdr L)))...
; # (loop (? (equal (car L) (car P)) (setq R (cdr L))) (? (=0 (dec 'I...
  br label %$19
$19:
  %74 = phi i64 [%69, %$18], [%105, %$23] ; # X
  %75 = phi i64 [%70, %$18], [%106, %$23] ; # L
  %76 = phi i64 [%71, %$18], [%107, %$23] ; # R
  %77 = phi i64 [%72, %$18], [%108, %$23] ; # N
  %78 = phi i64 [%73, %$18], [%109, %$23] ; # A
  %79 = phi i64 [%73, %$18], [%114, %$23] ; # P
  %80 = phi i64 [%72, %$18], [%111, %$23] ; # I
; # (? (equal (car L) (car P)) (setq R (cdr L)))
; # (car L)
  %81 = inttoptr i64 %75 to i64*
  %82 = load i64, i64* %81
; # (car P)
  %83 = inttoptr i64 %79 to i64*
  %84 = load i64, i64* %83
; # (equal (car L) (car P))
  %85 = call i1 @equal(i64 %82, i64 %84)
  br i1 %85, label %$22, label %$20
$22:
  %86 = phi i64 [%74, %$19] ; # X
  %87 = phi i64 [%75, %$19] ; # L
  %88 = phi i64 [%76, %$19] ; # R
  %89 = phi i64 [%77, %$19] ; # N
  %90 = phi i64 [%78, %$19] ; # A
  %91 = phi i64 [%79, %$19] ; # P
  %92 = phi i64 [%80, %$19] ; # I
; # (cdr L)
  %93 = inttoptr i64 %87 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  %95 = load i64, i64* %94
  br label %$21
$20:
  %96 = phi i64 [%74, %$19] ; # X
  %97 = phi i64 [%75, %$19] ; # L
  %98 = phi i64 [%76, %$19] ; # R
  %99 = phi i64 [%77, %$19] ; # N
  %100 = phi i64 [%78, %$19] ; # A
  %101 = phi i64 [%79, %$19] ; # P
  %102 = phi i64 [%80, %$19] ; # I
; # (? (=0 (dec 'I)))
; # (dec 'I)
  %103 = sub i64 %102, 1
; # (=0 (dec 'I))
  %104 = icmp eq i64 %103, 0
  br i1 %104, label %$21, label %$23
$23:
  %105 = phi i64 [%96, %$20] ; # X
  %106 = phi i64 [%97, %$20] ; # L
  %107 = phi i64 [%98, %$20] ; # R
  %108 = phi i64 [%99, %$20] ; # N
  %109 = phi i64 [%100, %$20] ; # A
  %110 = phi i64 [%101, %$20] ; # P
  %111 = phi i64 [%103, %$20] ; # I
; # (shift P)
  %112 = inttoptr i64 %110 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  %114 = load i64, i64* %113
  br label %$19
$21:
  %115 = phi i64 [%86, %$22], [%96, %$20] ; # X
  %116 = phi i64 [%87, %$22], [%97, %$20] ; # L
  %117 = phi i64 [%95, %$22], [%98, %$20] ; # R
  %118 = phi i64 [%89, %$22], [%99, %$20] ; # N
  %119 = phi i64 [%90, %$22], [%100, %$20] ; # A
  %120 = phi i64 [%91, %$22], [%101, %$20] ; # P
  %121 = phi i64 [%92, %$22], [%103, %$20] ; # I
  %122 = phi i64 [%95, %$22], [0, %$20] ; # ->
; # (? (atom (shift L)))
; # (shift L)
  %123 = inttoptr i64 %116 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
; # (atom (shift L))
  %126 = and i64 %125, 15
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$25, label %$24
$24:
  %128 = phi i64 [%115, %$21] ; # X
  %129 = phi i64 [%125, %$21] ; # L
  %130 = phi i64 [%117, %$21] ; # R
  %131 = phi i64 [%118, %$21] ; # N
  %132 = phi i64 [%119, %$21] ; # A
  br label %$18
$25:
  %133 = phi i64 [%115, %$21] ; # X
  %134 = phi i64 [%125, %$21] ; # L
  %135 = phi i64 [%117, %$21] ; # R
  %136 = phi i64 [%118, %$21] ; # N
  %137 = phi i64 [%119, %$21] ; # A
  %138 = phi i64 [0, %$21] ; # ->
  br label %$9
$9:
  %139 = phi i64 [%26, %$7], [%133, %$25] ; # X
  %140 = phi i64 [%27, %$7], [%134, %$25] ; # L
  %141 = phi i64 [%27, %$7], [%135, %$25] ; # ->
; # (drop *Safe)
  %142 = inttoptr i64 %19 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  %144 = load i64, i64* %143
  %145 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %144, i64* %145
  ret i64 %141
}

define i64 @_fin(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (while (pair X) (shift X)) X)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (while (pair X) (shift X))
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%20, %$8] ; # X
; # (pair X)
  %15 = and i64 %14, 15
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$9
$8:
  %17 = phi i64 [%14, %$7] ; # X
; # (shift X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  br label %$7
$9:
  %21 = phi i64 [%14, %$7] ; # X
  ret i64 %21
}

define i64 @_last(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (if (atom X) X (while (pair (cdr X)) (se...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (atom X) X (while (pair (cdr X)) (setq X @)) (car X))
; # (atom X)
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%13, %$2] ; # X
  br label %$9
$8:
  %17 = phi i64 [%13, %$2] ; # X
; # (while (pair (cdr X)) (setq X @))
  br label %$10
$10:
  %18 = phi i64 [%17, %$8], [%21, %$11] ; # X
; # (cdr X)
  %19 = inttoptr i64 %18 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
; # (pair (cdr X))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  %24 = phi i64 [%18, %$10] ; # X
  br label %$10
$12:
  %25 = phi i64 [%18, %$10] ; # X
; # (car X)
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
  br label %$9
$9:
  %28 = phi i64 [%16, %$7], [%25, %$12] ; # X
  %29 = phi i64 [%16, %$7], [%27, %$12] ; # ->
  ret i64 %29
}

define i64 @_eq(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $T) (? (<> Y (eval (car X))) $Nil))
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%42, %$16] ; # X
; # (? (atom (shift X)) $T)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (<> Y (eval (car X))) $Nil)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (<> Y (eval (car X)))
  %40 = icmp ne i64 %13, %39
  br i1 %40, label %$17, label %$16
$17:
  %41 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %43 = phi i64 [%28, %$10], [%41, %$17] ; # X
  %44 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %45 = inttoptr i64 %17 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret i64 %44
}

define i64 @_neq(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $Nil) (? (<> Y (eval (car X))) $T))
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%42, %$16] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (<> Y (eval (car X))) $T)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (<> Y (eval (car X)))
  %40 = icmp ne i64 %13, %39
  br i1 %40, label %$17, label %$16
$17:
  %41 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %43 = phi i64 [%28, %$10], [%41, %$17] ; # X
  %44 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$17] ; # ->
; # (drop *Safe)
  %45 = inttoptr i64 %17 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret i64 %44
}

define i64 @_equal(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $T) (? (not (equal Y (eval (car X)))) $...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%43, %$16] ; # X
; # (? (atom (shift X)) $T)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (not (equal Y (eval (car X)))) $Nil)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (equal Y (eval (car X)))
  %40 = call i1 @equal(i64 %13, i64 %39)
; # (not (equal Y (eval (car X))))
  %41 = icmp eq i1 %40, 0
  br i1 %41, label %$17, label %$16
$17:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %43 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %44 = phi i64 [%28, %$10], [%42, %$17] ; # X
  %45 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %46 = inttoptr i64 %17 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %49
  ret i64 %45
}

define i64 @_nequal(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $Nil) (? (not (equal Y (eval (car X))))...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%43, %$16] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (not (equal Y (eval (car X)))) $T)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (equal Y (eval (car X)))
  %40 = call i1 @equal(i64 %13, i64 %39)
; # (not (equal Y (eval (car X))))
  %41 = icmp eq i1 %40, 0
  br i1 %41, label %$17, label %$16
$17:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %43 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %44 = phi i64 [%28, %$10], [%42, %$17] ; # X
  %45 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$17] ; # ->
; # (drop *Safe)
  %46 = inttoptr i64 %17 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %49
  ret i64 %45
}

define i64 @_eq0(i64) align 8 {
$1:
; # (if (== (eval (cadr Exe)) ZERO) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) ZERO)
  %14 = icmp eq i64 %13, 2
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_eq1(i64) align 8 {
$1:
; # (if (== (eval (cadr Exe)) ONE) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) ONE)
  %14 = icmp eq i64 %13, 18
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_eqT(i64) align 8 {
$1:
; # (if (t? (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (t? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_neq0(i64) align 8 {
$1:
; # (if (== (eval (cadr Exe)) ZERO) $Nil $T)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) ZERO)
  %14 = icmp eq i64 %13, 2
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_neqT(i64) align 8 {
$1:
; # (if (t? (eval (cadr Exe))) $Nil $T)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (t? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_lt(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (ge0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (ge0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (ge0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (ge0 (compare Y Z))
  %44 = icmp sge i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %17 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %17 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_le(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (gt0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (gt0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (gt0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (gt0 (compare Y Z))
  %44 = icmp sgt i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %17 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %17 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_gt(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (le0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (le0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (le0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (le0 (compare Y Z))
  %44 = icmp sle i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %17 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %17 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_ge(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (lt0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (lt0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (lt0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (lt0 (compare Y Z))
  %44 = icmp slt i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %17 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %17 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_max(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save (eval (car X)))) (while (pair (shift X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (while (pair (shift X)) (let Z (eval (car X)) (when (gt0 (compare...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%46, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%47, %$16] ; # R
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (pair (shift X))
  %27 = and i64 %26, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$9
$8:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # R
; # (let Z (eval (car X)) (when (gt0 (compare Z R)) (setq R (safe Z))...
; # (car X)
  %31 = inttoptr i64 %29 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  br label %$10
$11:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$14, label %$13
$14:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$10
$13:
  %39 = call i64 @evList(i64 %32)
  br label %$10
$10:
  %40 = phi i64 [%32, %$12], [%38, %$14], [%39, %$13] ; # ->
; # (when (gt0 (compare Z R)) (setq R (safe Z)))
; # (compare Z R)
  %41 = call i64 @compare(i64 %40, i64 %30)
; # (gt0 (compare Z R))
  %42 = icmp sgt i64 %41, 0
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%29, %$10] ; # X
  %44 = phi i64 [%30, %$10] ; # R
; # (safe Z)
  %45 = inttoptr i64 %17 to i64*
  store i64 %40, i64* %45
  br label %$16
$16:
  %46 = phi i64 [%29, %$10], [%43, %$15] ; # X
  %47 = phi i64 [%30, %$10], [%40, %$15] ; # R
  br label %$7
$9:
  %48 = phi i64 [%26, %$7] ; # X
  %49 = phi i64 [%23, %$7] ; # R
; # (drop *Safe)
  %50 = inttoptr i64 %17 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %49
}

define i64 @_min(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save (eval (car X)))) (while (pair (shift X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (while (pair (shift X)) (let Z (eval (car X)) (when (lt0 (compare...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%46, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%47, %$16] ; # R
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (pair (shift X))
  %27 = and i64 %26, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$9
$8:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # R
; # (let Z (eval (car X)) (when (lt0 (compare Z R)) (setq R (safe Z))...
; # (car X)
  %31 = inttoptr i64 %29 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  br label %$10
$11:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$14, label %$13
$14:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$10
$13:
  %39 = call i64 @evList(i64 %32)
  br label %$10
$10:
  %40 = phi i64 [%32, %$12], [%38, %$14], [%39, %$13] ; # ->
; # (when (lt0 (compare Z R)) (setq R (safe Z)))
; # (compare Z R)
  %41 = call i64 @compare(i64 %40, i64 %30)
; # (lt0 (compare Z R))
  %42 = icmp slt i64 %41, 0
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%29, %$10] ; # X
  %44 = phi i64 [%30, %$10] ; # R
; # (safe Z)
  %45 = inttoptr i64 %17 to i64*
  store i64 %40, i64* %45
  br label %$16
$16:
  %46 = phi i64 [%29, %$10], [%43, %$15] ; # X
  %47 = phi i64 [%30, %$10], [%40, %$15] ; # R
  br label %$7
$9:
  %48 = phi i64 [%26, %$7] ; # X
  %49 = phi i64 [%23, %$7] ; # R
; # (drop *Safe)
  %50 = inttoptr i64 %17 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %49
}

define i64 @_atom(i64) align 8 {
$1:
; # (if (atom (eval (cadr Exe))) $T $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (atom (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_pair(i64) align 8 {
$1:
; # (if (pair (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (pair (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_circQ(i64) align 8 {
$1:
; # (if (circ (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (circ (eval (cadr Exe)))
  %14 = call i64 @circ(i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_lstQ(i64) align 8 {
$1:
; # (if (or (pair (eval (cadr Exe))) (nil? @)) $T $Nil)
; # (or (pair (eval (cadr Exe))) (nil? @))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (pair (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$2, label %$8
$8:
; # (nil? @)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$2
$2:
  %17 = phi i1 [1, %$3], [%16, %$8] ; # ->
  br i1 %17, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %18
}

define i64 @_numQ(i64) align 8 {
$1:
; # (if (num? (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_symQ(i64) align 8 {
$1:
; # (if (symb? (eval (cadr Exe))) $T $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (symb? (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %17 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %17
}

define i64 @_flgQ(i64) align 8 {
$1:
; # (if (or (t? (eval (cadr Exe))) (nil? @)) $T $Nil)
; # (or (t? (eval (cadr Exe))) (nil? @))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (t? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %14, label %$2, label %$8
$8:
; # (nil? @)
  %15 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$2
$2:
  %16 = phi i1 [1, %$3], [%15, %$8] ; # ->
  br i1 %16, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %17 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %17
}

define i64 @_member(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) (if (equal Y Z) Z $Nil)) (? (equal Y (car Z)) Z...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%54, %$21] ; # Z
; # (? (atom Z) (if (equal Y Z) Z $Nil))
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
; # (if (equal Y Z) Z $Nil)
; # (equal Y Z)
  %38 = call i1 @equal(i64 %15, i64 %37)
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%37, %$15] ; # Z
  br label %$18
$17:
  %40 = phi i64 [%37, %$15] ; # Z
  br label %$18
$18:
  %41 = phi i64 [%39, %$16], [%40, %$17] ; # Z
  %42 = phi i64 [%39, %$16], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
  br label %$14
$13:
  %43 = phi i64 [%34, %$12] ; # Z
; # (? (equal Y (car Z)) Z)
; # (car Z)
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
; # (equal Y (car Z))
  %46 = call i1 @equal(i64 %15, i64 %45)
  br i1 %46, label %$20, label %$19
$20:
  %47 = phi i64 [%43, %$13] ; # Z
  br label %$14
$19:
  %48 = phi i64 [%43, %$13] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (== H (shift Z))
  %52 = icmp eq i64 %33, %51
  br i1 %52, label %$22, label %$21
$22:
  %53 = phi i64 [%51, %$19] ; # Z
  br label %$14
$21:
  %54 = phi i64 [%51, %$19] ; # Z
  br label %$12
$14:
  %55 = phi i64 [%41, %$18], [%47, %$20], [%53, %$22] ; # Z
  %56 = phi i64 [%42, %$18], [%47, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
; # (drop *Safe)
  %57 = inttoptr i64 %19 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 %56
}

define i64 @_memq(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) (if (== Y Z) Z $Nil)) (? (== Y (car Z)) Z) (? (...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%54, %$21] ; # Z
; # (? (atom Z) (if (== Y Z) Z $Nil))
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
; # (if (== Y Z) Z $Nil)
; # (== Y Z)
  %38 = icmp eq i64 %15, %37
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%37, %$15] ; # Z
  br label %$18
$17:
  %40 = phi i64 [%37, %$15] ; # Z
  br label %$18
$18:
  %41 = phi i64 [%39, %$16], [%40, %$17] ; # Z
  %42 = phi i64 [%39, %$16], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
  br label %$14
$13:
  %43 = phi i64 [%34, %$12] ; # Z
; # (? (== Y (car Z)) Z)
; # (car Z)
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
; # (== Y (car Z))
  %46 = icmp eq i64 %15, %45
  br i1 %46, label %$20, label %$19
$20:
  %47 = phi i64 [%43, %$13] ; # Z
  br label %$14
$19:
  %48 = phi i64 [%43, %$13] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (== H (shift Z))
  %52 = icmp eq i64 %33, %51
  br i1 %52, label %$22, label %$21
$22:
  %53 = phi i64 [%51, %$19] ; # Z
  br label %$14
$21:
  %54 = phi i64 [%51, %$19] ; # Z
  br label %$12
$14:
  %55 = phi i64 [%41, %$18], [%47, %$20], [%53, %$22] ; # Z
  %56 = phi i64 [%42, %$18], [%47, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
; # (drop *Safe)
  %57 = inttoptr i64 %19 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 %56
}

define i64 @_mmeq(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (while (pair Y) (let (U (++ Y) V Z) (while (pair V) (when (== U (...
  br label %$12
$12:
  %34 = phi i64 [%15, %$7], [%76, %$22] ; # Y
; # (pair Y)
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$13, label %$14
$13:
  %37 = phi i64 [%34, %$12] ; # Y
; # (let (U (++ Y) V Z) (while (pair V) (when (== U (car V)) (ret V))...
; # (++ Y)
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
  %40 = getelementptr i64, i64* %38, i32 1
  %41 = load i64, i64* %40
; # (while (pair V) (when (== U (car V)) (ret V)) (when (== Z (shift ...
  br label %$15
$15:
  %42 = phi i64 [%41, %$13], [%69, %$21] ; # Y
  %43 = phi i64 [%33, %$13], [%70, %$21] ; # V
; # (pair V)
  %44 = and i64 %43, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$16, label %$17
$16:
  %46 = phi i64 [%42, %$15] ; # Y
  %47 = phi i64 [%43, %$15] ; # V
; # (when (== U (car V)) (ret V))
; # (car V)
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (== U (car V))
  %50 = icmp eq i64 %39, %49
  br i1 %50, label %$18, label %$19
$18:
  %51 = phi i64 [%46, %$16] ; # Y
  %52 = phi i64 [%47, %$16] ; # V
; # (ret V)
; # (drop *Safe)
  %53 = inttoptr i64 %19 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
$19:
  %57 = phi i64 [%46, %$16] ; # Y
  %58 = phi i64 [%47, %$16] ; # V
; # (when (== Z (shift V)) (ret $Nil))
; # (shift V)
  %59 = inttoptr i64 %58 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
; # (== Z (shift V))
  %62 = icmp eq i64 %33, %61
  br i1 %62, label %$20, label %$21
$20:
  %63 = phi i64 [%57, %$19] ; # Y
  %64 = phi i64 [%61, %$19] ; # V
; # (ret $Nil)
; # (drop *Safe)
  %65 = inttoptr i64 %19 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %68
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$21:
  %69 = phi i64 [%57, %$19] ; # Y
  %70 = phi i64 [%61, %$19] ; # V
  br label %$15
$17:
  %71 = phi i64 [%42, %$15] ; # Y
  %72 = phi i64 [%43, %$15] ; # V
; # (? (== U V) V)
; # (== U V)
  %73 = icmp eq i64 %39, %72
  br i1 %73, label %$23, label %$22
$23:
  %74 = phi i64 [%71, %$17] ; # Y
  %75 = phi i64 [%72, %$17] ; # V
  br label %$14
$22:
  %76 = phi i64 [%71, %$17] ; # Y
  %77 = phi i64 [%72, %$17] ; # V
  br label %$12
$14:
  %78 = phi i64 [%34, %$12], [%74, %$23] ; # Y
; # (drop *Safe)
  %79 = inttoptr i64 %19 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %81, i64* %82
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_sect(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (car X))) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %33, i64* %38
  %39 = add i64 %37, 8
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %41
; # (push $Nil NIL)
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %44
; # (link (push $Nil NIL))
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %43 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %46, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %49
; # (while (pair Y) (let U (++ Y) (when (member U Z) (let V (cons U $...
  br label %$12
$12:
  %50 = phi i64 [%15, %$7], [%89, %$22] ; # Y
  %51 = phi i64 [0, %$7], [%90, %$22] ; # P
; # (pair Y)
  %52 = and i64 %50, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$13, label %$14
$13:
  %54 = phi i64 [%50, %$12] ; # Y
  %55 = phi i64 [%51, %$12] ; # P
; # (let U (++ Y) (when (member U Z) (let V (cons U $Nil) (setq P (if...
; # (++ Y)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
  %58 = getelementptr i64, i64* %56, i32 1
  %59 = load i64, i64* %58
; # (when (member U Z) (let V (cons U $Nil) (setq P (if P (set 2 P V)...
; # (member U Z)
  br label %$15
$15:
  %60 = phi i64 [%33, %$13], [%72, %$19] ; # L
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$18, label %$16
$18:
  %63 = phi i64 [%60, %$15] ; # L
  br label %$17
$16:
  %64 = phi i64 [%60, %$15] ; # L
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = call i1 @equal(i64 %57, i64 %66)
  br i1 %67, label %$20, label %$19
$20:
  %68 = phi i64 [%64, %$16] ; # L
  br label %$17
$19:
  %69 = phi i64 [%64, %$16] ; # L
  %70 = inttoptr i64 %69 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  br label %$15
$17:
  %73 = phi i64 [%63, %$18], [%68, %$20] ; # L
  %74 = phi i1 [0, %$18], [1, %$20] ; # ->
  br i1 %74, label %$21, label %$22
$21:
  %75 = phi i64 [%59, %$17] ; # Y
  %76 = phi i64 [%55, %$17] ; # P
; # (let V (cons U $Nil) (setq P (if P (set 2 P V) (set R V))))
; # (cons U $Nil)
  %77 = call i64 @cons(i64 %57, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if P (set 2 P V) (set R V))
  %78 = icmp ne i64 %76, 0
  br i1 %78, label %$23, label %$24
$23:
  %79 = phi i64 [%75, %$21] ; # Y
  %80 = phi i64 [%76, %$21] ; # P
; # (set 2 P V)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  store i64 %77, i64* %82
  br label %$25
$24:
  %83 = phi i64 [%75, %$21] ; # Y
  %84 = phi i64 [%76, %$21] ; # P
; # (set R V)
  %85 = inttoptr i64 %43 to i64*
  store i64 %77, i64* %85
  br label %$25
$25:
  %86 = phi i64 [%79, %$23], [%83, %$24] ; # Y
  %87 = phi i64 [%80, %$23], [%84, %$24] ; # P
  %88 = phi i64 [%77, %$23], [%77, %$24] ; # ->
  br label %$22
$22:
  %89 = phi i64 [%59, %$17], [%86, %$25] ; # Y
  %90 = phi i64 [%55, %$17], [%88, %$25] ; # P
  br label %$12
$14:
  %91 = phi i64 [%50, %$12] ; # Y
  %92 = phi i64 [%51, %$12] ; # P
; # (val R)
  %93 = inttoptr i64 %43 to i64*
  %94 = load i64, i64* %93
; # (drop *Safe)
  %95 = inttoptr i64 %19 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %97, i64* %98
  ret i64 %94
}

define i64 @_diff(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (car X))) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %33, i64* %38
  %39 = add i64 %37, 8
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %41
; # (push $Nil NIL)
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %44
; # (link (push $Nil NIL))
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %43 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %46, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %49
; # (while (pair Y) (let U (++ Y) (unless (member U Z) (let V (cons U...
  br label %$12
$12:
  %50 = phi i64 [%15, %$7], [%89, %$22] ; # Y
  %51 = phi i64 [0, %$7], [%90, %$22] ; # P
; # (pair Y)
  %52 = and i64 %50, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$13, label %$14
$13:
  %54 = phi i64 [%50, %$12] ; # Y
  %55 = phi i64 [%51, %$12] ; # P
; # (let U (++ Y) (unless (member U Z) (let V (cons U $Nil) (setq P (...
; # (++ Y)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
  %58 = getelementptr i64, i64* %56, i32 1
  %59 = load i64, i64* %58
; # (unless (member U Z) (let V (cons U $Nil) (setq P (if P (set 2 P ...
; # (member U Z)
  br label %$15
$15:
  %60 = phi i64 [%33, %$13], [%72, %$19] ; # L
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$18, label %$16
$18:
  %63 = phi i64 [%60, %$15] ; # L
  br label %$17
$16:
  %64 = phi i64 [%60, %$15] ; # L
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = call i1 @equal(i64 %57, i64 %66)
  br i1 %67, label %$20, label %$19
$20:
  %68 = phi i64 [%64, %$16] ; # L
  br label %$17
$19:
  %69 = phi i64 [%64, %$16] ; # L
  %70 = inttoptr i64 %69 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  br label %$15
$17:
  %73 = phi i64 [%63, %$18], [%68, %$20] ; # L
  %74 = phi i1 [0, %$18], [1, %$20] ; # ->
  br i1 %74, label %$22, label %$21
$21:
  %75 = phi i64 [%59, %$17] ; # Y
  %76 = phi i64 [%55, %$17] ; # P
; # (let V (cons U $Nil) (setq P (if P (set 2 P V) (set R V))))
; # (cons U $Nil)
  %77 = call i64 @cons(i64 %57, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if P (set 2 P V) (set R V))
  %78 = icmp ne i64 %76, 0
  br i1 %78, label %$23, label %$24
$23:
  %79 = phi i64 [%75, %$21] ; # Y
  %80 = phi i64 [%76, %$21] ; # P
; # (set 2 P V)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  store i64 %77, i64* %82
  br label %$25
$24:
  %83 = phi i64 [%75, %$21] ; # Y
  %84 = phi i64 [%76, %$21] ; # P
; # (set R V)
  %85 = inttoptr i64 %43 to i64*
  store i64 %77, i64* %85
  br label %$25
$25:
  %86 = phi i64 [%79, %$23], [%83, %$24] ; # Y
  %87 = phi i64 [%80, %$23], [%84, %$24] ; # P
  %88 = phi i64 [%77, %$23], [%77, %$24] ; # ->
  br label %$22
$22:
  %89 = phi i64 [%59, %$17], [%86, %$25] ; # Y
  %90 = phi i64 [%55, %$17], [%88, %$25] ; # P
  br label %$12
$14:
  %91 = phi i64 [%50, %$12] ; # Y
  %92 = phi i64 [%51, %$12] ; # P
; # (val R)
  %93 = inttoptr i64 %43 to i64*
  %94 = load i64, i64* %93
; # (drop *Safe)
  %95 = inttoptr i64 %19 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %97, i64* %98
  ret i64 %94
}

define i64 @_index(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) Cnt 1 U...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (? (equal Y (car Z)) (cnt Cnt)) (inc 'Cnt...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%58, %$18] ; # Z
  %35 = phi i64 [1, %$7], [%59, %$18] ; # Cnt
; # (? (atom Z) $Nil)
; # (atom Z)
  %36 = and i64 %34, 15
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$15, label %$13
$15:
  %38 = phi i64 [%34, %$12] ; # Z
  %39 = phi i64 [%35, %$12] ; # Cnt
  br label %$14
$13:
  %40 = phi i64 [%34, %$12] ; # Z
  %41 = phi i64 [%35, %$12] ; # Cnt
; # (? (equal Y (car Z)) (cnt Cnt))
; # (car Z)
  %42 = inttoptr i64 %40 to i64*
  %43 = load i64, i64* %42
; # (equal Y (car Z))
  %44 = call i1 @equal(i64 %15, i64 %43)
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%40, %$13] ; # Z
  %46 = phi i64 [%41, %$13] ; # Cnt
; # (cnt Cnt)
  %47 = shl i64 %46, 4
  %48 = or i64 %47, 2
  br label %$14
$16:
  %49 = phi i64 [%40, %$13] ; # Z
  %50 = phi i64 [%41, %$13] ; # Cnt
; # (inc 'Cnt)
  %51 = add i64 %50, 1
; # (? (== U (shift Z)) $Nil)
; # (shift Z)
  %52 = inttoptr i64 %49 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (== U (shift Z))
  %55 = icmp eq i64 %33, %54
  br i1 %55, label %$19, label %$18
$19:
  %56 = phi i64 [%54, %$16] ; # Z
  %57 = phi i64 [%51, %$16] ; # Cnt
  br label %$14
$18:
  %58 = phi i64 [%54, %$16] ; # Z
  %59 = phi i64 [%51, %$16] ; # Cnt
  br label %$12
$14:
  %60 = phi i64 [%38, %$15], [%45, %$17], [%56, %$19] ; # Z
  %61 = phi i64 [%39, %$15], [%46, %$17], [%57, %$19] ; # Cnt
  %62 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%48, %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$19] ; # ->
; # (drop *Safe)
  %63 = inttoptr i64 %19 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  %65 = load i64, i64* %64
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %66
  ret i64 %62
}

define i64 @_offset(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) Cnt 1) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (? (equal Y Z) (cnt Cnt)) (inc 'Cnt) (shi...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%52, %$16] ; # Z
  %35 = phi i64 [1, %$7], [%49, %$16] ; # Cnt
; # (? (atom Z) $Nil)
; # (atom Z)
  %36 = and i64 %34, 15
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$15, label %$13
$15:
  %38 = phi i64 [%34, %$12] ; # Z
  %39 = phi i64 [%35, %$12] ; # Cnt
  br label %$14
$13:
  %40 = phi i64 [%34, %$12] ; # Z
  %41 = phi i64 [%35, %$12] ; # Cnt
; # (? (equal Y Z) (cnt Cnt))
; # (equal Y Z)
  %42 = call i1 @equal(i64 %15, i64 %40)
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%40, %$13] ; # Z
  %44 = phi i64 [%41, %$13] ; # Cnt
; # (cnt Cnt)
  %45 = shl i64 %44, 4
  %46 = or i64 %45, 2
  br label %$14
$16:
  %47 = phi i64 [%40, %$13] ; # Z
  %48 = phi i64 [%41, %$13] ; # Cnt
; # (inc 'Cnt)
  %49 = add i64 %48, 1
; # (shift Z)
  %50 = inttoptr i64 %47 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  br label %$12
$14:
  %53 = phi i64 [%38, %$15], [%43, %$17] ; # Z
  %54 = phi i64 [%39, %$15], [%44, %$17] ; # Cnt
  %55 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%46, %$17] ; # ->
; # (drop *Safe)
  %56 = inttoptr i64 %19 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %55
}

define i64 @_prior(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (when (and (pair Y) (<> Y Z)) (while (pair Z) (when (== (cdr Z) Y...
; # (and (pair Y) (<> Y Z))
; # (pair Y)
  %34 = and i64 %15, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$13, label %$12
$13:
  %36 = phi i64 [%33, %$7] ; # Z
; # (<> Y Z)
  %37 = icmp ne i64 %15, %36
  br label %$12
$12:
  %38 = phi i64 [%33, %$7], [%36, %$13] ; # Z
  %39 = phi i1 [0, %$7], [%37, %$13] ; # ->
  br i1 %39, label %$14, label %$15
$14:
  %40 = phi i64 [%38, %$12] ; # Z
; # (while (pair Z) (when (== (cdr Z) Y) (ret Z)) (setq Z @))
  br label %$16
$16:
  %41 = phi i64 [%40, %$14], [%47, %$20] ; # Z
; # (pair Z)
  %42 = and i64 %41, 15
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %$17, label %$18
$17:
  %44 = phi i64 [%41, %$16] ; # Z
; # (when (== (cdr Z) Y) (ret Z))
; # (cdr Z)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (== (cdr Z) Y)
  %48 = icmp eq i64 %47, %15
  br i1 %48, label %$19, label %$20
$19:
  %49 = phi i64 [%44, %$17] ; # Z
; # (ret Z)
; # (drop *Safe)
  %50 = inttoptr i64 %19 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %49
$20:
  %54 = phi i64 [%44, %$17] ; # Z
  br label %$16
$18:
  %55 = phi i64 [%41, %$16] ; # Z
  br label %$15
$15:
  %56 = phi i64 [%38, %$12], [%55, %$18] ; # Z
; # (drop *Safe)
  %57 = inttoptr i64 %19 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_length(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (cond ((num? X) (fmtNum X -2 0 0 null)) ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((num? X) (fmtNum X -2 0 0 null)) ((pair X) (let (C ONE Y X...
; # (num? X)
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%13, %$2] ; # X
; # (fmtNum X -2 0 0 null)
  %17 = call i64 @fmtNum(i64 %16, i64 -2, i8 0, i8 0, i64* null)
  br label %$7
$8:
  %18 = phi i64 [%13, %$2] ; # X
; # (pair X)
  %19 = and i64 %18, 15
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %$11, label %$10
$11:
  %21 = phi i64 [%18, %$8] ; # X
; # (let (C ONE Y X) (loop (set X (| (car X) 1)) (? (atom (shift X)) ...
; # (loop (set X (| (car X) 1)) (? (atom (shift X)) (loop (set Y (& (...
  br label %$12
$12:
  %22 = phi i64 [%21, %$11], [%100, %$19] ; # X
  %23 = phi i64 [18, %$11], [%103, %$19] ; # C
  %24 = phi i64 [%21, %$11], [%102, %$19] ; # Y
; # (set X (| (car X) 1))
; # (car X)
  %25 = inttoptr i64 %22 to i64*
  %26 = load i64, i64* %25
; # (| (car X) 1)
  %27 = or i64 %26, 1
  %28 = inttoptr i64 %22 to i64*
  store i64 %27, i64* %28
; # (? (atom (shift X)) (loop (set Y (& (car Y) -2)) (? (== X (shift ...
; # (shift X)
  %29 = inttoptr i64 %22 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (atom (shift X))
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$15, label %$13
$15:
  %34 = phi i64 [%31, %$12] ; # X
  %35 = phi i64 [%23, %$12] ; # C
  %36 = phi i64 [%24, %$12] ; # Y
; # (loop (set Y (& (car Y) -2)) (? (== X (shift Y))))
  br label %$16
$16:
  %37 = phi i64 [%34, %$15], [%48, %$17] ; # X
  %38 = phi i64 [%35, %$15], [%49, %$17] ; # C
  %39 = phi i64 [%36, %$15], [%50, %$17] ; # Y
; # (set Y (& (car Y) -2))
; # (car Y)
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
; # (& (car Y) -2)
  %42 = and i64 %41, -2
  %43 = inttoptr i64 %39 to i64*
  store i64 %42, i64* %43
; # (? (== X (shift Y)))
; # (shift Y)
  %44 = inttoptr i64 %39 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (== X (shift Y))
  %47 = icmp eq i64 %37, %46
  br i1 %47, label %$18, label %$17
$17:
  %48 = phi i64 [%37, %$16] ; # X
  %49 = phi i64 [%38, %$16] ; # C
  %50 = phi i64 [%46, %$16] ; # Y
  br label %$16
$18:
  %51 = phi i64 [%37, %$16] ; # X
  %52 = phi i64 [%38, %$16] ; # C
  %53 = phi i64 [%46, %$16] ; # Y
  %54 = phi i64 [0, %$16] ; # ->
  br label %$14
$13:
  %55 = phi i64 [%31, %$12] ; # X
  %56 = phi i64 [%23, %$12] ; # C
  %57 = phi i64 [%24, %$12] ; # Y
; # (? (& (car X) 1) (until (== X Y) (set Y (& (car Y) -2)) (shift Y)...
; # (car X)
  %58 = inttoptr i64 %55 to i64*
  %59 = load i64, i64* %58
; # (& (car X) 1)
  %60 = and i64 %59, 1
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$20, label %$19
$20:
  %62 = phi i64 [%55, %$13] ; # X
  %63 = phi i64 [%56, %$13] ; # C
  %64 = phi i64 [%57, %$13] ; # Y
; # (until (== X Y) (set Y (& (car Y) -2)) (shift Y))
  br label %$21
$21:
  %65 = phi i64 [%62, %$20], [%69, %$22] ; # X
  %66 = phi i64 [%63, %$20], [%70, %$22] ; # C
  %67 = phi i64 [%64, %$20], [%78, %$22] ; # Y
; # (== X Y)
  %68 = icmp eq i64 %65, %67
  br i1 %68, label %$23, label %$22
$22:
  %69 = phi i64 [%65, %$21] ; # X
  %70 = phi i64 [%66, %$21] ; # C
  %71 = phi i64 [%67, %$21] ; # Y
; # (set Y (& (car Y) -2))
; # (car Y)
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
; # (& (car Y) -2)
  %74 = and i64 %73, -2
  %75 = inttoptr i64 %71 to i64*
  store i64 %74, i64* %75
; # (shift Y)
  %76 = inttoptr i64 %71 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
  br label %$21
$23:
  %79 = phi i64 [%65, %$21] ; # X
  %80 = phi i64 [%66, %$21] ; # C
  %81 = phi i64 [%67, %$21] ; # Y
; # (loop (set Y (& (car Y) -2)) (? (== X (shift Y))))
  br label %$24
$24:
  %82 = phi i64 [%79, %$23], [%93, %$25] ; # X
  %83 = phi i64 [%80, %$23], [%94, %$25] ; # C
  %84 = phi i64 [%81, %$23], [%95, %$25] ; # Y
; # (set Y (& (car Y) -2))
; # (car Y)
  %85 = inttoptr i64 %84 to i64*
  %86 = load i64, i64* %85
; # (& (car Y) -2)
  %87 = and i64 %86, -2
  %88 = inttoptr i64 %84 to i64*
  store i64 %87, i64* %88
; # (? (== X (shift Y)))
; # (shift Y)
  %89 = inttoptr i64 %84 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  %91 = load i64, i64* %90
; # (== X (shift Y))
  %92 = icmp eq i64 %82, %91
  br i1 %92, label %$26, label %$25
$25:
  %93 = phi i64 [%82, %$24] ; # X
  %94 = phi i64 [%83, %$24] ; # C
  %95 = phi i64 [%91, %$24] ; # Y
  br label %$24
$26:
  %96 = phi i64 [%82, %$24] ; # X
  %97 = phi i64 [%83, %$24] ; # C
  %98 = phi i64 [%91, %$24] ; # Y
  %99 = phi i64 [0, %$24] ; # ->
  br label %$14
$19:
  %100 = phi i64 [%55, %$13] ; # X
  %101 = phi i64 [%56, %$13] ; # C
  %102 = phi i64 [%57, %$13] ; # Y
; # (inc 'C (hex "10"))
  %103 = add i64 %101, 16
  br label %$12
$14:
  %104 = phi i64 [%51, %$18], [%96, %$26] ; # X
  %105 = phi i64 [%52, %$18], [%97, %$26] ; # C
  %106 = phi i64 [%53, %$18], [%98, %$26] ; # Y
  %107 = phi i64 [%52, %$18], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$26] ; # ->
  br label %$7
$10:
  %108 = phi i64 [%18, %$8] ; # X
; # (nil? X)
  %109 = icmp eq i64 %108, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %109, label %$28, label %$27
$28:
  %110 = phi i64 [%108, %$10] ; # X
  br label %$7
$27:
  %111 = phi i64 [%108, %$10] ; # X
; # (tail X)
  %112 = add i64 %111, -8
; # (val (tail X))
  %113 = inttoptr i64 %112 to i64*
  %114 = load i64, i64* %113
; # (sym? (val (tail X)))
  %115 = and i64 %114, 8
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$30, label %$29
$30:
  %117 = phi i64 [%111, %$27] ; # X
  br label %$7
$29:
  %118 = phi i64 [%111, %$27] ; # X
; # (let (C ZERO P (push 0 (name @))) (while (symChar P) (inc 'C (hex...
; # (name @)
  br label %$31
$31:
  %119 = phi i64 [%114, %$29], [%125, %$32] ; # Tail
  %120 = and i64 %119, 6
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$33, label %$32
$32:
  %122 = phi i64 [%119, %$31] ; # Tail
  %123 = inttoptr i64 %122 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  br label %$31
$33:
  %126 = phi i64 [%119, %$31] ; # Tail
; # (push 0 (name @))
  %127 = alloca i64, i64 2, align 16
  store i64 0, i64* %127
  %128 = getelementptr i64, i64* %127, i32 1
  store i64 %126, i64* %128
; # (while (symChar P) (inc 'C (hex "10")))
  br label %$34
$34:
  %129 = phi i64 [%118, %$33], [%133, %$35] ; # X
  %130 = phi i64 [2, %$33], [%135, %$35] ; # C
; # (symChar P)
  %131 = call i32 @symChar(i64* %127)
  %132 = icmp ne i32 %131, 0
  br i1 %132, label %$35, label %$36
$35:
  %133 = phi i64 [%129, %$34] ; # X
  %134 = phi i64 [%130, %$34] ; # C
; # (inc 'C (hex "10"))
  %135 = add i64 %134, 16
  br label %$34
$36:
  %136 = phi i64 [%129, %$34] ; # X
  %137 = phi i64 [%130, %$34] ; # C
  br label %$7
$7:
  %138 = phi i64 [%16, %$9], [%104, %$14], [%110, %$28], [%117, %$30], [%136, %$36] ; # X
  %139 = phi i64 [%17, %$9], [%107, %$14], [2, %$28], [2, %$30], [%137, %$36] ; # ->
  ret i64 %139
}

define i64 @size(i64) align 8 {
$1:
; # (let (C 1 X L Y (car X)) (loop (when (pair Y) (stkChk 0) (inc 'C ...
; # (car X)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (loop (when (pair Y) (stkChk 0) (inc 'C (size Y))) (set X (| Y 1)...
  br label %$2
$2:
  %3 = phi i64 [%0, %$1], [%107, %$13] ; # L
  %4 = phi i64 [1, %$1], [%111, %$13] ; # C
  %5 = phi i64 [%0, %$1], [%109, %$13] ; # X
  %6 = phi i64 [%2, %$1], [%110, %$13] ; # Y
; # (when (pair Y) (stkChk 0) (inc 'C (size Y)))
; # (pair Y)
  %7 = and i64 %6, 15
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %$3, label %$4
$3:
  %9 = phi i64 [%3, %$2] ; # L
  %10 = phi i64 [%4, %$2] ; # C
  %11 = phi i64 [%5, %$2] ; # X
  %12 = phi i64 [%6, %$2] ; # Y
; # (stkChk 0)
  %13 = load i8*, i8** @$StkLimit
  %14 = call i8* @llvm.stacksave()
  %15 = icmp ugt i8* %13, %14
  br i1 %15, label %$5, label %$6
$5:
  call void @stkErr(i64 0)
  unreachable
$6:
; # (size Y)
  %16 = call i64 @size(i64 %12)
; # (inc 'C (size Y))
  %17 = add i64 %10, %16
  br label %$4
$4:
  %18 = phi i64 [%3, %$2], [%9, %$6] ; # L
  %19 = phi i64 [%4, %$2], [%17, %$6] ; # C
  %20 = phi i64 [%5, %$2], [%11, %$6] ; # X
  %21 = phi i64 [%6, %$2], [%12, %$6] ; # Y
; # (set X (| Y 1))
; # (| Y 1)
  %22 = or i64 %21, 1
  %23 = inttoptr i64 %20 to i64*
  store i64 %22, i64* %23
; # (? (atom (shift X)) (loop (set L (& (car L) -2)) (? (== X (shift ...
; # (shift X)
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$9, label %$7
$9:
  %29 = phi i64 [%18, %$4] ; # L
  %30 = phi i64 [%19, %$4] ; # C
  %31 = phi i64 [%26, %$4] ; # X
  %32 = phi i64 [%21, %$4] ; # Y
; # (loop (set L (& (car L) -2)) (? (== X (shift L))))
  br label %$10
$10:
  %33 = phi i64 [%29, %$9], [%45, %$11] ; # L
  %34 = phi i64 [%30, %$9], [%46, %$11] ; # C
  %35 = phi i64 [%31, %$9], [%47, %$11] ; # X
  %36 = phi i64 [%32, %$9], [%48, %$11] ; # Y
; # (set L (& (car L) -2))
; # (car L)
  %37 = inttoptr i64 %33 to i64*
  %38 = load i64, i64* %37
; # (& (car L) -2)
  %39 = and i64 %38, -2
  %40 = inttoptr i64 %33 to i64*
  store i64 %39, i64* %40
; # (? (== X (shift L)))
; # (shift L)
  %41 = inttoptr i64 %33 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (== X (shift L))
  %44 = icmp eq i64 %35, %43
  br i1 %44, label %$12, label %$11
$11:
  %45 = phi i64 [%43, %$10] ; # L
  %46 = phi i64 [%34, %$10] ; # C
  %47 = phi i64 [%35, %$10] ; # X
  %48 = phi i64 [%36, %$10] ; # Y
  br label %$10
$12:
  %49 = phi i64 [%43, %$10] ; # L
  %50 = phi i64 [%34, %$10] ; # C
  %51 = phi i64 [%35, %$10] ; # X
  %52 = phi i64 [%36, %$10] ; # Y
  %53 = phi i64 [0, %$10] ; # ->
  br label %$8
$7:
  %54 = phi i64 [%18, %$4] ; # L
  %55 = phi i64 [%19, %$4] ; # C
  %56 = phi i64 [%26, %$4] ; # X
  %57 = phi i64 [%21, %$4] ; # Y
; # (? (& (setq Y (car X)) 1) (until (== X L) (set L (& (car L) -2)) ...
; # (car X)
  %58 = inttoptr i64 %56 to i64*
  %59 = load i64, i64* %58
; # (& (setq Y (car X)) 1)
  %60 = and i64 %59, 1
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$14, label %$13
$14:
  %62 = phi i64 [%54, %$7] ; # L
  %63 = phi i64 [%55, %$7] ; # C
  %64 = phi i64 [%56, %$7] ; # X
  %65 = phi i64 [%59, %$7] ; # Y
; # (until (== X L) (set L (& (car L) -2)) (shift L))
  br label %$15
$15:
  %66 = phi i64 [%62, %$14], [%81, %$16] ; # L
  %67 = phi i64 [%63, %$14], [%72, %$16] ; # C
  %68 = phi i64 [%64, %$14], [%73, %$16] ; # X
  %69 = phi i64 [%65, %$14], [%74, %$16] ; # Y
; # (== X L)
  %70 = icmp eq i64 %68, %66
  br i1 %70, label %$17, label %$16
$16:
  %71 = phi i64 [%66, %$15] ; # L
  %72 = phi i64 [%67, %$15] ; # C
  %73 = phi i64 [%68, %$15] ; # X
  %74 = phi i64 [%69, %$15] ; # Y
; # (set L (& (car L) -2))
; # (car L)
  %75 = inttoptr i64 %71 to i64*
  %76 = load i64, i64* %75
; # (& (car L) -2)
  %77 = and i64 %76, -2
  %78 = inttoptr i64 %71 to i64*
  store i64 %77, i64* %78
; # (shift L)
  %79 = inttoptr i64 %71 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  br label %$15
$17:
  %82 = phi i64 [%66, %$15] ; # L
  %83 = phi i64 [%67, %$15] ; # C
  %84 = phi i64 [%68, %$15] ; # X
  %85 = phi i64 [%69, %$15] ; # Y
; # (loop (set L (& (car L) -2)) (? (== X (shift L))))
  br label %$18
$18:
  %86 = phi i64 [%82, %$17], [%98, %$19] ; # L
  %87 = phi i64 [%83, %$17], [%99, %$19] ; # C
  %88 = phi i64 [%84, %$17], [%100, %$19] ; # X
  %89 = phi i64 [%85, %$17], [%101, %$19] ; # Y
; # (set L (& (car L) -2))
; # (car L)
  %90 = inttoptr i64 %86 to i64*
  %91 = load i64, i64* %90
; # (& (car L) -2)
  %92 = and i64 %91, -2
  %93 = inttoptr i64 %86 to i64*
  store i64 %92, i64* %93
; # (? (== X (shift L)))
; # (shift L)
  %94 = inttoptr i64 %86 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
; # (== X (shift L))
  %97 = icmp eq i64 %88, %96
  br i1 %97, label %$20, label %$19
$19:
  %98 = phi i64 [%96, %$18] ; # L
  %99 = phi i64 [%87, %$18] ; # C
  %100 = phi i64 [%88, %$18] ; # X
  %101 = phi i64 [%89, %$18] ; # Y
  br label %$18
$20:
  %102 = phi i64 [%96, %$18] ; # L
  %103 = phi i64 [%87, %$18] ; # C
  %104 = phi i64 [%88, %$18] ; # X
  %105 = phi i64 [%89, %$18] ; # Y
  %106 = phi i64 [0, %$18] ; # ->
  br label %$8
$13:
  %107 = phi i64 [%54, %$7] ; # L
  %108 = phi i64 [%55, %$7] ; # C
  %109 = phi i64 [%56, %$7] ; # X
  %110 = phi i64 [%59, %$7] ; # Y
; # (inc 'C)
  %111 = add i64 %108, 1
  br label %$2
$8:
  %112 = phi i64 [%49, %$12], [%102, %$20] ; # L
  %113 = phi i64 [%50, %$12], [%103, %$20] ; # C
  %114 = phi i64 [%51, %$12], [%104, %$20] ; # X
  %115 = phi i64 [%52, %$12], [%105, %$20] ; # Y
  %116 = phi i64 [%50, %$12], [%103, %$20] ; # ->
  ret i64 %116
}

define i64 @binSize(i64) align 8 {
$1:
; # (cond ((cnt? X) (setq X (shr X 3)) (: 1 (let C 2 (while (setq X (...
; # (cnt? X)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
; # (shr X 3)
  %4 = lshr i64 %3, 3
; # (: 1 (let C 2 (while (setq X (shr X 8)) (inc 'C)) C))
  br label %$-1
$-1:
  %5 = phi i64 [%4, %$4], [%98, %$32] ; # X
; # (let C 2 (while (setq X (shr X 8)) (inc 'C)) C)
; # (while (setq X (shr X 8)) (inc 'C))
  br label %$5
$5:
  %6 = phi i64 [%5, %$-1], [%10, %$6] ; # X
  %7 = phi i64 [2, %$-1], [%12, %$6] ; # C
; # (shr X 8)
  %8 = lshr i64 %6, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$7
$6:
  %10 = phi i64 [%8, %$5] ; # X
  %11 = phi i64 [%7, %$5] ; # C
; # (inc 'C)
  %12 = add i64 %11, 1
  br label %$5
$7:
  %13 = phi i64 [%8, %$5] ; # X
  %14 = phi i64 [%7, %$5] ; # C
  br label %$2
$3:
  %15 = phi i64 [%0, %$1] ; # X
; # (big? X)
  %16 = and i64 %15, 4
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = phi i64 [%15, %$3] ; # X
; # (pos X)
  %19 = and i64 %18, -9
; # (let C 9 (loop (setq D (val (dig X))) (? (cnt? (setq X (val (big ...
; # (loop (setq D (val (dig X))) (? (cnt? (setq X (val (big X))))) (i...
  br label %$10
$10:
  %20 = phi i64 [%19, %$9], [%30, %$11] ; # X
  %21 = phi i64 [9, %$9], [%32, %$11] ; # C
; # (dig X)
  %22 = add i64 %20, -4
; # (val (dig X))
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %25 = add i64 %20, 4
; # (val (big X))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (cnt? (setq X (val (big X))))
  %28 = and i64 %27, 2
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$11
$11:
  %30 = phi i64 [%27, %$10] ; # X
  %31 = phi i64 [%21, %$10] ; # C
; # (inc 'C 8)
  %32 = add i64 %31, 8
  br label %$10
$12:
  %33 = phi i64 [%27, %$10] ; # X
  %34 = phi i64 [%21, %$10] ; # C
  %35 = phi i64 [0, %$10] ; # ->
; # (int X)
  %36 = lshr i64 %33, 4
; # (add D D)
  %37 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %24, i64 %24)
  %38 = extractvalue {i64, i1} %37, 1
  %39 = extractvalue {i64, i1} %37, 0
; # (+ X X @@)
  %40 = add i64 %36, %36
  %41 = zext i1 %38 to i64
  %42 = add i64 %40, %41
; # (: 2 (when X (loop (inc 'C) (? (=0 (setq X (shr X 8)))))) (if (>=...
  br label %$-2
$-2:
  %43 = phi i64 [%42, %$12], [%112, %$35] ; # X
  %44 = phi i64 [%34, %$12], [%111, %$35] ; # C
; # (when X (loop (inc 'C) (? (=0 (setq X (shr X 8))))))
  %45 = icmp ne i64 %43, 0
  br i1 %45, label %$13, label %$14
$13:
  %46 = phi i64 [%43, %$-2] ; # X
  %47 = phi i64 [%44, %$-2] ; # C
; # (loop (inc 'C) (? (=0 (setq X (shr X 8)))))
  br label %$15
$15:
  %48 = phi i64 [%46, %$13], [%53, %$16] ; # X
  %49 = phi i64 [%47, %$13], [%54, %$16] ; # C
; # (inc 'C)
  %50 = add i64 %49, 1
; # (? (=0 (setq X (shr X 8))))
; # (shr X 8)
  %51 = lshr i64 %48, 8
; # (=0 (setq X (shr X 8)))
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %$17, label %$16
$16:
  %53 = phi i64 [%51, %$15] ; # X
  %54 = phi i64 [%50, %$15] ; # C
  br label %$15
$17:
  %55 = phi i64 [%51, %$15] ; # X
  %56 = phi i64 [%50, %$15] ; # C
  %57 = phi i64 [0, %$15] ; # ->
  br label %$14
$14:
  %58 = phi i64 [%43, %$-2], [%55, %$17] ; # X
  %59 = phi i64 [%44, %$-2], [%56, %$17] ; # C
; # (if (>= C (+ 63 1)) (+ C (/ (- C 64) 255) 1) C)
; # (+ 63 1)
; # (>= C (+ 63 1))
  %60 = icmp uge i64 %59, 64
  br i1 %60, label %$18, label %$19
$18:
  %61 = phi i64 [%58, %$14] ; # X
  %62 = phi i64 [%59, %$14] ; # C
; # (- C 64)
  %63 = sub i64 %62, 64
; # (/ (- C 64) 255)
  %64 = udiv i64 %63, 255
; # (+ C (/ (- C 64) 255) 1)
  %65 = add i64 %62, %64
  %66 = add i64 %65, 1
  br label %$20
$19:
  %67 = phi i64 [%58, %$14] ; # X
  %68 = phi i64 [%59, %$14] ; # C
  br label %$20
$20:
  %69 = phi i64 [%61, %$18], [%67, %$19] ; # X
  %70 = phi i64 [%62, %$18], [%68, %$19] ; # C
  %71 = phi i64 [%66, %$18], [%68, %$19] ; # ->
  br label %$2
$8:
  %72 = phi i64 [%15, %$3] ; # X
; # (sym? X)
  %73 = and i64 %72, 8
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$22, label %$21
$22:
  %75 = phi i64 [%72, %$8] ; # X
; # (cond ((nil? X) 1) ((== (name (& (val (tail X)) -9)) ZERO) 1) ((c...
; # (nil? X)
  %76 = icmp eq i64 %75, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %76, label %$25, label %$24
$25:
  %77 = phi i64 [%75, %$22] ; # X
  br label %$23
$24:
  %78 = phi i64 [%75, %$22] ; # X
; # (tail X)
  %79 = add i64 %78, -8
; # (val (tail X))
  %80 = inttoptr i64 %79 to i64*
  %81 = load i64, i64* %80
; # (& (val (tail X)) -9)
  %82 = and i64 %81, -9
; # (name (& (val (tail X)) -9))
  br label %$26
$26:
  %83 = phi i64 [%82, %$24], [%89, %$27] ; # Tail
  %84 = and i64 %83, 6
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$28, label %$27
$27:
  %86 = phi i64 [%83, %$26] ; # Tail
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
  br label %$26
$28:
  %90 = phi i64 [%83, %$26] ; # Tail
; # (== (name (& (val (tail X)) -9)) ZERO)
  %91 = icmp eq i64 %90, 2
  br i1 %91, label %$30, label %$29
$30:
  %92 = phi i64 [%78, %$28] ; # X
  br label %$23
$29:
  %93 = phi i64 [%78, %$28] ; # X
; # (cnt? (setq X @))
  %94 = and i64 %90, 2
  %95 = icmp ne i64 %94, 0
  br i1 %95, label %$32, label %$31
$32:
  %96 = phi i64 [%90, %$29] ; # X
; # (shl X 2)
  %97 = shl i64 %96, 2
; # (shr (shl X 2) 6)
  %98 = lshr i64 %97, 6
; # (goto 1)
  br label %$-1
$31:
  %99 = phi i64 [%90, %$29] ; # X
; # (let C 9 (until (cnt? (setq X (val (big X)))) (inc 'C 8)) (setq X...
; # (until (cnt? (setq X (val (big X)))) (inc 'C 8))
  br label %$33
$33:
  %100 = phi i64 [%99, %$31], [%107, %$34] ; # X
  %101 = phi i64 [9, %$31], [%109, %$34] ; # C
; # (big X)
  %102 = add i64 %100, 4
; # (val (big X))
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
; # (cnt? (setq X (val (big X))))
  %105 = and i64 %104, 2
  %106 = icmp ne i64 %105, 0
  br i1 %106, label %$35, label %$34
$34:
  %107 = phi i64 [%104, %$33] ; # X
  %108 = phi i64 [%101, %$33] ; # C
; # (inc 'C 8)
  %109 = add i64 %108, 8
  br label %$33
$35:
  %110 = phi i64 [%104, %$33] ; # X
  %111 = phi i64 [%101, %$33] ; # C
; # (int X)
  %112 = lshr i64 %110, 4
; # (goto 2)
  br label %$-2
$23:
  %113 = phi i64 [%77, %$25], [%92, %$30] ; # X
  %114 = phi i64 [1, %$25], [1, %$30] ; # ->
  br label %$2
$21:
  %115 = phi i64 [%72, %$8] ; # X
; # (let (C 2 Y X) (loop (inc 'C (binSize (++ X))) (? (nil? X) C) (? ...
; # (loop (inc 'C (binSize (++ X))) (? (nil? X) C) (? (== Y X) (inc C...
  br label %$36
$36:
  %116 = phi i64 [%115, %$21], [%141, %$42] ; # X
  %117 = phi i64 [2, %$21], [%142, %$42] ; # C
; # (++ X)
  %118 = inttoptr i64 %116 to i64*
  %119 = load i64, i64* %118
  %120 = getelementptr i64, i64* %118, i32 1
  %121 = load i64, i64* %120
; # (binSize (++ X))
  %122 = call i64 @binSize(i64 %119)
; # (inc 'C (binSize (++ X)))
  %123 = add i64 %117, %122
; # (? (nil? X) C)
; # (nil? X)
  %124 = icmp eq i64 %121, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %124, label %$39, label %$37
$39:
  %125 = phi i64 [%121, %$36] ; # X
  %126 = phi i64 [%123, %$36] ; # C
  br label %$38
$37:
  %127 = phi i64 [%121, %$36] ; # X
  %128 = phi i64 [%123, %$36] ; # C
; # (? (== Y X) (inc C))
; # (== Y X)
  %129 = icmp eq i64 %115, %127
  br i1 %129, label %$41, label %$40
$41:
  %130 = phi i64 [%127, %$37] ; # X
  %131 = phi i64 [%128, %$37] ; # C
; # (inc C)
  %132 = add i64 %131, 1
  br label %$38
$40:
  %133 = phi i64 [%127, %$37] ; # X
  %134 = phi i64 [%128, %$37] ; # C
; # (? (atom X) (+ C (binSize X)))
; # (atom X)
  %135 = and i64 %133, 15
  %136 = icmp ne i64 %135, 0
  br i1 %136, label %$43, label %$42
$43:
  %137 = phi i64 [%133, %$40] ; # X
  %138 = phi i64 [%134, %$40] ; # C
; # (binSize X)
  %139 = call i64 @binSize(i64 %137)
; # (+ C (binSize X))
  %140 = add i64 %138, %139
  br label %$38
$42:
  %141 = phi i64 [%133, %$40] ; # X
  %142 = phi i64 [%134, %$40] ; # C
  br label %$36
$38:
  %143 = phi i64 [%125, %$39], [%130, %$41], [%137, %$43] ; # X
  %144 = phi i64 [%126, %$39], [%131, %$41], [%138, %$43] ; # C
  %145 = phi i64 [%126, %$39], [%132, %$41], [%140, %$43] ; # ->
  br label %$2
$2:
  %146 = phi i64 [%13, %$7], [%69, %$20], [%113, %$23], [%143, %$38] ; # X
  %147 = phi i64 [%14, %$7], [%71, %$20], [%114, %$23], [%145, %$38] ; # ->
  ret i64 %147
}

define i64 @_size(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (cond ((cnt? X) (setq X (shr X 3)) (let ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((cnt? X) (setq X (shr X 3)) (let C ONE (while (setq X (shr...
; # (cnt? X)
  %14 = and i64 %13, 2
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%13, %$2] ; # X
; # (shr X 3)
  %17 = lshr i64 %16, 3
; # (let C ONE (while (setq X (shr X 8)) (inc 'C (hex "10"))) C)
; # (while (setq X (shr X 8)) (inc 'C (hex "10")))
  br label %$10
$10:
  %18 = phi i64 [%17, %$9], [%22, %$11] ; # X
  %19 = phi i64 [18, %$9], [%24, %$11] ; # C
; # (shr X 8)
  %20 = lshr i64 %18, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$12
$11:
  %22 = phi i64 [%20, %$10] ; # X
  %23 = phi i64 [%19, %$10] ; # C
; # (inc 'C (hex "10"))
  %24 = add i64 %23, 16
  br label %$10
$12:
  %25 = phi i64 [%20, %$10] ; # X
  %26 = phi i64 [%19, %$10] ; # C
  br label %$7
$8:
  %27 = phi i64 [%13, %$2] ; # X
; # (big? X)
  %28 = and i64 %27, 4
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$14, label %$13
$14:
  %30 = phi i64 [%27, %$8] ; # X
; # (pos X)
  %31 = and i64 %30, -9
; # (let (C (hex "82") D T) (loop (setq D (val (dig X))) (? (cnt? (se...
; # (loop (setq D (val (dig X))) (? (cnt? (setq X (val (big X))))) (i...
  br label %$15
$15:
  %32 = phi i64 [%31, %$14], [%42, %$16] ; # X
  %33 = phi i64 [130, %$14], [%45, %$16] ; # C
; # (dig X)
  %34 = add i64 %32, -4
; # (val (dig X))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %37 = add i64 %32, 4
; # (val (big X))
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
; # (cnt? (setq X (val (big X))))
  %40 = and i64 %39, 2
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$17, label %$16
$16:
  %42 = phi i64 [%39, %$15] ; # X
  %43 = phi i64 [%33, %$15] ; # C
  %44 = phi i64 [%36, %$15] ; # D
; # (inc 'C (hex "80"))
  %45 = add i64 %43, 128
  br label %$15
$17:
  %46 = phi i64 [%39, %$15] ; # X
  %47 = phi i64 [%33, %$15] ; # C
  %48 = phi i64 [%36, %$15] ; # D
  %49 = phi i64 [0, %$15] ; # ->
; # (int X)
  %50 = lshr i64 %46, 4
; # (add D D)
  %51 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %48, i64 %48)
  %52 = extractvalue {i64, i1} %51, 1
  %53 = extractvalue {i64, i1} %51, 0
; # (when (setq X (+ X X @@)) (loop (inc 'C (hex "10")) (? (=0 (setq ...
; # (+ X X @@)
  %54 = add i64 %50, %50
  %55 = zext i1 %52 to i64
  %56 = add i64 %54, %55
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$18, label %$19
$18:
  %58 = phi i64 [%56, %$17] ; # X
  %59 = phi i64 [%47, %$17] ; # C
  %60 = phi i64 [%48, %$17] ; # D
; # (loop (inc 'C (hex "10")) (? (=0 (setq X (shr X 8)))))
  br label %$20
$20:
  %61 = phi i64 [%58, %$18], [%67, %$21] ; # X
  %62 = phi i64 [%59, %$18], [%68, %$21] ; # C
  %63 = phi i64 [%60, %$18], [%69, %$21] ; # D
; # (inc 'C (hex "10"))
  %64 = add i64 %62, 16
; # (? (=0 (setq X (shr X 8))))
; # (shr X 8)
  %65 = lshr i64 %61, 8
; # (=0 (setq X (shr X 8)))
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$22, label %$21
$21:
  %67 = phi i64 [%65, %$20] ; # X
  %68 = phi i64 [%64, %$20] ; # C
  %69 = phi i64 [%63, %$20] ; # D
  br label %$20
$22:
  %70 = phi i64 [%65, %$20] ; # X
  %71 = phi i64 [%64, %$20] ; # C
  %72 = phi i64 [%63, %$20] ; # D
  %73 = phi i64 [0, %$20] ; # ->
  br label %$19
$19:
  %74 = phi i64 [%56, %$17], [%70, %$22] ; # X
  %75 = phi i64 [%47, %$17], [%71, %$22] ; # C
  %76 = phi i64 [%48, %$17], [%72, %$22] ; # D
  br label %$7
$13:
  %77 = phi i64 [%27, %$8] ; # X
; # (pair X)
  %78 = and i64 %77, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$24, label %$23
$24:
  %80 = phi i64 [%77, %$13] ; # X
; # (size X)
  %81 = call i64 @size(i64 %80)
; # (cnt (size X))
  %82 = shl i64 %81, 4
  %83 = or i64 %82, 2
  br label %$7
$23:
  %84 = phi i64 [%77, %$13] ; # X
; # (nil? X)
  %85 = icmp eq i64 %84, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %85, label %$26, label %$25
$26:
  %86 = phi i64 [%84, %$23] ; # X
  br label %$7
$25:
  %87 = phi i64 [%84, %$23] ; # X
; # (tail X)
  %88 = add i64 %87, -8
; # (val (tail X))
  %89 = inttoptr i64 %88 to i64*
  %90 = load i64, i64* %89
; # (sym? (val (tail X)))
  %91 = and i64 %90, 8
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$28, label %$27
$28:
  %93 = phi i64 [%87, %$25] ; # X
; # (dbFetch Exe X)
  call void @dbFetch(i64 %0, i64 %93)
; # (let (C (+ (binSize (val X)) (inc BLK)) Y (& (val (tail X)) -9)) ...
; # (val X)
  %94 = inttoptr i64 %93 to i64*
  %95 = load i64, i64* %94
; # (binSize (val X))
  %96 = call i64 @binSize(i64 %95)
; # (inc BLK)
; # (+ (binSize (val X)) (inc BLK))
  %97 = add i64 %96, 7
; # (tail X)
  %98 = add i64 %93, -8
; # (val (tail X))
  %99 = inttoptr i64 %98 to i64*
  %100 = load i64, i64* %99
; # (& (val (tail X)) -9)
  %101 = and i64 %100, -9
; # (while (pair Y) (let Z (++ Y) (setq C (+ C (if (atom Z) (+ (binSi...
  br label %$29
$29:
  %102 = phi i64 [%93, %$28], [%132, %$34] ; # X
  %103 = phi i64 [%97, %$28], [%136, %$34] ; # C
  %104 = phi i64 [%101, %$28], [%134, %$34] ; # Y
; # (pair Y)
  %105 = and i64 %104, 15
  %106 = icmp eq i64 %105, 0
  br i1 %106, label %$30, label %$31
$30:
  %107 = phi i64 [%102, %$29] ; # X
  %108 = phi i64 [%103, %$29] ; # C
  %109 = phi i64 [%104, %$29] ; # Y
; # (let Z (++ Y) (setq C (+ C (if (atom Z) (+ (binSize Z) 2) (+ (bin...
; # (++ Y)
  %110 = inttoptr i64 %109 to i64*
  %111 = load i64, i64* %110
  %112 = getelementptr i64, i64* %110, i32 1
  %113 = load i64, i64* %112
; # (if (atom Z) (+ (binSize Z) 2) (+ (binSize (car Z)) (binSize (cdr...
; # (atom Z)
  %114 = and i64 %111, 15
  %115 = icmp ne i64 %114, 0
  br i1 %115, label %$32, label %$33
$32:
  %116 = phi i64 [%107, %$30] ; # X
  %117 = phi i64 [%108, %$30] ; # C
  %118 = phi i64 [%113, %$30] ; # Y
; # (binSize Z)
  %119 = call i64 @binSize(i64 %111)
; # (+ (binSize Z) 2)
  %120 = add i64 %119, 2
  br label %$34
$33:
  %121 = phi i64 [%107, %$30] ; # X
  %122 = phi i64 [%108, %$30] ; # C
  %123 = phi i64 [%113, %$30] ; # Y
; # (car Z)
  %124 = inttoptr i64 %111 to i64*
  %125 = load i64, i64* %124
; # (binSize (car Z))
  %126 = call i64 @binSize(i64 %125)
; # (cdr Z)
  %127 = inttoptr i64 %111 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  %129 = load i64, i64* %128
; # (binSize (cdr Z))
  %130 = call i64 @binSize(i64 %129)
; # (+ (binSize (car Z)) (binSize (cdr Z)))
  %131 = add i64 %126, %130
  br label %$34
$34:
  %132 = phi i64 [%116, %$32], [%121, %$33] ; # X
  %133 = phi i64 [%117, %$32], [%122, %$33] ; # C
  %134 = phi i64 [%118, %$32], [%123, %$33] ; # Y
  %135 = phi i64 [%120, %$32], [%131, %$33] ; # ->
; # (+ C (if (atom Z) (+ (binSize Z) 2) (+ (binSize (car Z)) (binSize...
  %136 = add i64 %108, %135
  br label %$29
$31:
  %137 = phi i64 [%102, %$29] ; # X
  %138 = phi i64 [%103, %$29] ; # C
  %139 = phi i64 [%104, %$29] ; # Y
; # (cnt C)
  %140 = shl i64 %138, 4
  %141 = or i64 %140, 2
  br label %$7
$27:
  %142 = phi i64 [%87, %$25] ; # X
; # (name @)
  br label %$35
$35:
  %143 = phi i64 [%90, %$27], [%149, %$36] ; # Tail
  %144 = and i64 %143, 6
  %145 = icmp ne i64 %144, 0
  br i1 %145, label %$37, label %$36
$36:
  %146 = phi i64 [%143, %$35] ; # Tail
  %147 = inttoptr i64 %146 to i64*
  %148 = getelementptr i64, i64* %147, i32 1
  %149 = load i64, i64* %148
  br label %$35
$37:
  %150 = phi i64 [%143, %$35] ; # Tail
; # (== (name @) ZERO)
  %151 = icmp eq i64 %150, 2
  br i1 %151, label %$39, label %$38
$39:
  %152 = phi i64 [%142, %$37] ; # X
  br label %$7
$38:
  %153 = phi i64 [%142, %$37] ; # X
; # (cnt? @)
  %154 = and i64 %150, 2
  %155 = icmp ne i64 %154, 0
  br i1 %155, label %$41, label %$40
$41:
  %156 = phi i64 [%153, %$38] ; # X
; # (let (C ONE Z (int @)) (while (setq Z (shr Z 8)) (inc 'C (hex "10...
; # (int @)
  %157 = lshr i64 %150, 4
; # (while (setq Z (shr Z 8)) (inc 'C (hex "10")))
  br label %$42
$42:
  %158 = phi i64 [%156, %$41], [%163, %$43] ; # X
  %159 = phi i64 [18, %$41], [%166, %$43] ; # C
  %160 = phi i64 [%157, %$41], [%165, %$43] ; # Z
; # (shr Z 8)
  %161 = lshr i64 %160, 8
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$43, label %$44
$43:
  %163 = phi i64 [%158, %$42] ; # X
  %164 = phi i64 [%159, %$42] ; # C
  %165 = phi i64 [%161, %$42] ; # Z
; # (inc 'C (hex "10"))
  %166 = add i64 %164, 16
  br label %$42
$44:
  %167 = phi i64 [%158, %$42] ; # X
  %168 = phi i64 [%159, %$42] ; # C
  %169 = phi i64 [%161, %$42] ; # Z
  br label %$7
$40:
  %170 = phi i64 [%153, %$38] ; # X
; # (let (C (hex "82") Z @) (until (cnt? (setq Z (val (big Z)))) (inc...
; # (until (cnt? (setq Z (val (big Z)))) (inc 'C (hex "80")))
  br label %$45
$45:
  %171 = phi i64 [%170, %$40], [%179, %$46] ; # X
  %172 = phi i64 [130, %$40], [%182, %$46] ; # C
  %173 = phi i64 [%150, %$40], [%181, %$46] ; # Z
; # (big Z)
  %174 = add i64 %173, 4
; # (val (big Z))
  %175 = inttoptr i64 %174 to i64*
  %176 = load i64, i64* %175
; # (cnt? (setq Z (val (big Z))))
  %177 = and i64 %176, 2
  %178 = icmp ne i64 %177, 0
  br i1 %178, label %$47, label %$46
$46:
  %179 = phi i64 [%171, %$45] ; # X
  %180 = phi i64 [%172, %$45] ; # C
  %181 = phi i64 [%176, %$45] ; # Z
; # (inc 'C (hex "80"))
  %182 = add i64 %180, 128
  br label %$45
$47:
  %183 = phi i64 [%171, %$45] ; # X
  %184 = phi i64 [%172, %$45] ; # C
  %185 = phi i64 [%176, %$45] ; # Z
; # (when (setq Z (int Z)) (loop (inc 'C (hex "10")) (? (=0 (setq Z (...
; # (int Z)
  %186 = lshr i64 %185, 4
  %187 = icmp ne i64 %186, 0
  br i1 %187, label %$48, label %$49
$48:
  %188 = phi i64 [%183, %$47] ; # X
  %189 = phi i64 [%184, %$47] ; # C
  %190 = phi i64 [%186, %$47] ; # Z
; # (loop (inc 'C (hex "10")) (? (=0 (setq Z (shr Z 8)))))
  br label %$50
$50:
  %191 = phi i64 [%188, %$48], [%197, %$51] ; # X
  %192 = phi i64 [%189, %$48], [%198, %$51] ; # C
  %193 = phi i64 [%190, %$48], [%199, %$51] ; # Z
; # (inc 'C (hex "10"))
  %194 = add i64 %192, 16
; # (? (=0 (setq Z (shr Z 8))))
; # (shr Z 8)
  %195 = lshr i64 %193, 8
; # (=0 (setq Z (shr Z 8)))
  %196 = icmp eq i64 %195, 0
  br i1 %196, label %$52, label %$51
$51:
  %197 = phi i64 [%191, %$50] ; # X
  %198 = phi i64 [%194, %$50] ; # C
  %199 = phi i64 [%195, %$50] ; # Z
  br label %$50
$52:
  %200 = phi i64 [%191, %$50] ; # X
  %201 = phi i64 [%194, %$50] ; # C
  %202 = phi i64 [%195, %$50] ; # Z
  %203 = phi i64 [0, %$50] ; # ->
  br label %$49
$49:
  %204 = phi i64 [%183, %$47], [%200, %$52] ; # X
  %205 = phi i64 [%184, %$47], [%201, %$52] ; # C
  %206 = phi i64 [%186, %$47], [%202, %$52] ; # Z
  br label %$7
$7:
  %207 = phi i64 [%25, %$12], [%74, %$19], [%80, %$24], [%86, %$26], [%137, %$31], [%152, %$39], [%167, %$44], [%204, %$49] ; # X
  %208 = phi i64 [%26, %$12], [%75, %$19], [%83, %$24], [2, %$26], [%141, %$31], [%150, %$39], [%168, %$44], [%205, %$49] ; # ->
  ret i64 %208
}

define i64 @_bytes(i64) align 8 {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (binSize (eval (cadr Exe)))
  %14 = call i64 @binSize(i64 %13)
; # (cnt (binSize (eval (cadr Exe))))
  %15 = shl i64 %14, 4
  %16 = or i64 %15, 2
  ret i64 %16
}

define i64 @_assoc(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (let C (car Z) (? (and (pair C) (equal Y ...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%56, %$20] ; # Z
; # (? (atom Z) $Nil)
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
  br label %$14
$13:
  %38 = phi i64 [%34, %$12] ; # Z
; # (let C (car Z) (? (and (pair C) (equal Y (car C))) C))
; # (car Z)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (? (and (pair C) (equal Y (car C))) C)
; # (and (pair C) (equal Y (car C)))
; # (pair C)
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%38, %$13] ; # Z
; # (car C)
  %44 = inttoptr i64 %40 to i64*
  %45 = load i64, i64* %44
; # (equal Y (car C))
  %46 = call i1 @equal(i64 %15, i64 %45)
  br label %$16
$16:
  %47 = phi i64 [%38, %$13], [%43, %$17] ; # Z
  %48 = phi i1 [0, %$13], [%46, %$17] ; # ->
  br i1 %48, label %$19, label %$18
$19:
  %49 = phi i64 [%47, %$16] ; # Z
  br label %$14
$18:
  %50 = phi i64 [%47, %$16] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %51 = inttoptr i64 %50 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
; # (== H (shift Z))
  %54 = icmp eq i64 %33, %53
  br i1 %54, label %$21, label %$20
$21:
  %55 = phi i64 [%53, %$18] ; # Z
  br label %$14
$20:
  %56 = phi i64 [%53, %$18] ; # Z
  br label %$12
$14:
  %57 = phi i64 [%37, %$15], [%49, %$19], [%55, %$21] ; # Z
  %58 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%40, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
; # (drop *Safe)
  %59 = inttoptr i64 %19 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %61, i64* %62
  ret i64 %58
}

define i64 @_rassoc(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (let C (car Z) (? (and (pair C) (equal Y ...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%57, %$20] ; # Z
; # (? (atom Z) $Nil)
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
  br label %$14
$13:
  %38 = phi i64 [%34, %$12] ; # Z
; # (let C (car Z) (? (and (pair C) (equal Y (cdr C))) C))
; # (car Z)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (? (and (pair C) (equal Y (cdr C))) C)
; # (and (pair C) (equal Y (cdr C)))
; # (pair C)
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%38, %$13] ; # Z
; # (cdr C)
  %44 = inttoptr i64 %40 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (equal Y (cdr C))
  %47 = call i1 @equal(i64 %15, i64 %46)
  br label %$16
$16:
  %48 = phi i64 [%38, %$13], [%43, %$17] ; # Z
  %49 = phi i1 [0, %$13], [%47, %$17] ; # ->
  br i1 %49, label %$19, label %$18
$19:
  %50 = phi i64 [%48, %$16] ; # Z
  br label %$14
$18:
  %51 = phi i64 [%48, %$16] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %52 = inttoptr i64 %51 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (== H (shift Z))
  %55 = icmp eq i64 %33, %54
  br i1 %55, label %$21, label %$20
$21:
  %56 = phi i64 [%54, %$18] ; # Z
  br label %$14
$20:
  %57 = phi i64 [%54, %$18] ; # Z
  br label %$12
$14:
  %58 = phi i64 [%37, %$15], [%50, %$19], [%56, %$21] ; # Z
  %59 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%40, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
; # (drop *Safe)
  %60 = inttoptr i64 %19 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %62, i64* %63
  ret i64 %59
}

define i64 @_asoq(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (let C (car Z) (? (and (pair C) (== Y (ca...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%56, %$20] ; # Z
; # (? (atom Z) $Nil)
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
  br label %$14
$13:
  %38 = phi i64 [%34, %$12] ; # Z
; # (let C (car Z) (? (and (pair C) (== Y (car C))) C))
; # (car Z)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (? (and (pair C) (== Y (car C))) C)
; # (and (pair C) (== Y (car C)))
; # (pair C)
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%38, %$13] ; # Z
; # (car C)
  %44 = inttoptr i64 %40 to i64*
  %45 = load i64, i64* %44
; # (== Y (car C))
  %46 = icmp eq i64 %15, %45
  br label %$16
$16:
  %47 = phi i64 [%38, %$13], [%43, %$17] ; # Z
  %48 = phi i1 [0, %$13], [%46, %$17] ; # ->
  br i1 %48, label %$19, label %$18
$19:
  %49 = phi i64 [%47, %$16] ; # Z
  br label %$14
$18:
  %50 = phi i64 [%47, %$16] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %51 = inttoptr i64 %50 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
; # (== H (shift Z))
  %54 = icmp eq i64 %33, %53
  br i1 %54, label %$21, label %$20
$21:
  %55 = phi i64 [%53, %$18] ; # Z
  br label %$14
$20:
  %56 = phi i64 [%53, %$18] ; # Z
  br label %$12
$14:
  %57 = phi i64 [%37, %$15], [%49, %$19], [%55, %$21] ; # Z
  %58 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%40, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
; # (drop *Safe)
  %59 = inttoptr i64 %19 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %61, i64* %62
  ret i64 %58
}

define i64 @_rasoq(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (let C (car Z) (? (and (pair C) (== Y (cd...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%57, %$20] ; # Z
; # (? (atom Z) $Nil)
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
  br label %$14
$13:
  %38 = phi i64 [%34, %$12] ; # Z
; # (let C (car Z) (? (and (pair C) (== Y (cdr C))) C))
; # (car Z)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (? (and (pair C) (== Y (cdr C))) C)
; # (and (pair C) (== Y (cdr C)))
; # (pair C)
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%38, %$13] ; # Z
; # (cdr C)
  %44 = inttoptr i64 %40 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (== Y (cdr C))
  %47 = icmp eq i64 %15, %46
  br label %$16
$16:
  %48 = phi i64 [%38, %$13], [%43, %$17] ; # Z
  %49 = phi i1 [0, %$13], [%47, %$17] ; # ->
  br i1 %49, label %$19, label %$18
$19:
  %50 = phi i64 [%48, %$16] ; # Z
  br label %$14
$18:
  %51 = phi i64 [%48, %$16] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %52 = inttoptr i64 %51 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (== H (shift Z))
  %55 = icmp eq i64 %33, %54
  br i1 %55, label %$21, label %$20
$21:
  %56 = phi i64 [%54, %$18] ; # Z
  br label %$14
$20:
  %57 = phi i64 [%54, %$18] ; # Z
  br label %$12
$14:
  %58 = phi i64 [%37, %$15], [%50, %$19], [%56, %$21] ; # Z
  %59 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%40, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
; # (drop *Safe)
  %60 = inttoptr i64 %19 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %62, i64* %63
  ret i64 %59
}

define i64 @_rank(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (++ X))) R...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %37 = load i64, i64* %36
  %38 = alloca i64, i64 2, align 16
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = add i64 %39, 8
  %42 = inttoptr i64 %41 to i64*
  store i64 %37, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %43
; # (if (nil? (eval (car X))) (until (gt0 (compare (caar Z) Y)) (setq...
; # (car X)
  %44 = inttoptr i64 %27 to i64*
  %45 = load i64, i64* %44
; # (eval (car X))
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  br label %$12
$13:
  %48 = and i64 %45, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$16, label %$15
$16:
  %50 = inttoptr i64 %45 to i64*
  %51 = load i64, i64* %50
  br label %$12
$15:
  %52 = call i64 @evList(i64 %45)
  br label %$12
$12:
  %53 = phi i64 [%45, %$14], [%51, %$16], [%52, %$15] ; # ->
; # (nil? (eval (car X)))
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %54, label %$17, label %$18
$17:
  %55 = phi i64 [%35, %$12] ; # Z
  %56 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # R
; # (until (gt0 (compare (caar Z) Y)) (setq R Z) (? (atom (shift Z)))...
  br label %$20
$20:
  %57 = phi i64 [%55, %$17], [%72, %$23] ; # Z
  %58 = phi i64 [%56, %$17], [%73, %$23] ; # R
; # (caar Z)
  %59 = inttoptr i64 %57 to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (compare (caar Z) Y)
  %63 = call i64 @compare(i64 %62, i64 %15)
; # (gt0 (compare (caar Z) Y))
  %64 = icmp sgt i64 %63, 0
  br i1 %64, label %$22, label %$21
$21:
  %65 = phi i64 [%57, %$20] ; # Z
  %66 = phi i64 [%58, %$20] ; # R
; # (? (atom (shift Z)))
; # (shift Z)
  %67 = inttoptr i64 %65 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
; # (atom (shift Z))
  %70 = and i64 %69, 15
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$22, label %$23
$23:
  %72 = phi i64 [%69, %$21] ; # Z
  %73 = phi i64 [%65, %$21] ; # R
  br label %$20
$22:
  %74 = phi i64 [%57, %$20], [%69, %$21] ; # Z
  %75 = phi i64 [%58, %$20], [%65, %$21] ; # R
  br label %$19
$18:
  %76 = phi i64 [%35, %$12] ; # Z
  %77 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # R
; # (until (lt0 (compare (caar Z) Y)) (setq R Z) (? (atom (shift Z)))...
  br label %$24
$24:
  %78 = phi i64 [%76, %$18], [%93, %$27] ; # Z
  %79 = phi i64 [%77, %$18], [%94, %$27] ; # R
; # (caar Z)
  %80 = inttoptr i64 %78 to i64*
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %81 to i64*
  %83 = load i64, i64* %82
; # (compare (caar Z) Y)
  %84 = call i64 @compare(i64 %83, i64 %15)
; # (lt0 (compare (caar Z) Y))
  %85 = icmp slt i64 %84, 0
  br i1 %85, label %$26, label %$25
$25:
  %86 = phi i64 [%78, %$24] ; # Z
  %87 = phi i64 [%79, %$24] ; # R
; # (? (atom (shift Z)))
; # (shift Z)
  %88 = inttoptr i64 %86 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
; # (atom (shift Z))
  %91 = and i64 %90, 15
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$26, label %$27
$27:
  %93 = phi i64 [%90, %$25] ; # Z
  %94 = phi i64 [%86, %$25] ; # R
  br label %$24
$26:
  %95 = phi i64 [%78, %$24], [%90, %$25] ; # Z
  %96 = phi i64 [%79, %$24], [%86, %$25] ; # R
  br label %$19
$19:
  %97 = phi i64 [%74, %$22], [%95, %$26] ; # Z
  %98 = phi i64 [%75, %$22], [%96, %$26] ; # R
; # (car R)
  %99 = inttoptr i64 %98 to i64*
  %100 = load i64, i64* %99
; # (drop *Safe)
  %101 = inttoptr i64 %19 to i64*
  %102 = getelementptr i64, i64* %101, i32 1
  %103 = load i64, i64* %102
  %104 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %103, i64* %104
  ret i64 %100
}

define i1 @match(i64, i64) align 8 {
$1:
; # (loop (? (atom Pat) (if (or (num? Pat) (<> (firstByte Pat) (char ...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%118, %$29] ; # Pat
  %3 = phi i64 [%1, %$1], [%121, %$29] ; # Dat
; # (? (atom Pat) (if (or (num? Pat) (<> (firstByte Pat) (char "@")))...
; # (atom Pat)
  %4 = and i64 %2, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$5, label %$3
$5:
  %6 = phi i64 [%2, %$2] ; # Pat
  %7 = phi i64 [%3, %$2] ; # Dat
; # (if (or (num? Pat) (<> (firstByte Pat) (char "@"))) (equal Pat Da...
; # (or (num? Pat) (<> (firstByte Pat) (char "@")))
; # (num? Pat)
  %8 = and i64 %6, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$7
$7:
  %10 = phi i64 [%6, %$5] ; # Pat
  %11 = phi i64 [%7, %$5] ; # Dat
; # (firstByte Pat)
  %12 = call i8 @firstByte(i64 %10)
; # (<> (firstByte Pat) (char "@"))
  %13 = icmp ne i8 %12, 64
  br label %$6
$6:
  %14 = phi i64 [%6, %$5], [%10, %$7] ; # Pat
  %15 = phi i64 [%7, %$5], [%11, %$7] ; # Dat
  %16 = phi i1 [1, %$5], [%13, %$7] ; # ->
  br i1 %16, label %$8, label %$9
$8:
  %17 = phi i64 [%14, %$6] ; # Pat
  %18 = phi i64 [%15, %$6] ; # Dat
; # (equal Pat Dat)
  %19 = call i1 @equal(i64 %17, i64 %18)
  br label %$10
$9:
  %20 = phi i64 [%14, %$6] ; # Pat
  %21 = phi i64 [%15, %$6] ; # Dat
; # (set Pat Dat)
  %22 = inttoptr i64 %20 to i64*
  store i64 %21, i64* %22
  br label %$10
$10:
  %23 = phi i64 [%17, %$8], [%20, %$9] ; # Pat
  %24 = phi i64 [%18, %$8], [%21, %$9] ; # Dat
  %25 = phi i1 [%19, %$8], [1, %$9] ; # ->
  br label %$4
$3:
  %26 = phi i64 [%2, %$2] ; # Pat
  %27 = phi i64 [%3, %$2] ; # Dat
; # (stkChk 0)
  %28 = load i8*, i8** @$StkLimit
  %29 = call i8* @llvm.stacksave()
  %30 = icmp ugt i8* %28, %29
  br i1 %30, label %$11, label %$12
$11:
  call void @stkErr(i64 0)
  unreachable
$12:
; # (let X (car Pat) (when (and (symb? X) (== (firstByte X) (char "@"...
; # (car Pat)
  %31 = inttoptr i64 %26 to i64*
  %32 = load i64, i64* %31
; # (when (and (symb? X) (== (firstByte X) (char "@"))) (? (atom Dat)...
; # (and (symb? X) (== (firstByte X) (char "@")))
; # (symb? X)
  %33 = xor i64 %32, 8
  %34 = and i64 %33, 14
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$14, label %$13
$14:
  %36 = phi i64 [%26, %$12] ; # Pat
  %37 = phi i64 [%27, %$12] ; # Dat
; # (firstByte X)
  %38 = call i8 @firstByte(i64 %32)
; # (== (firstByte X) (char "@"))
  %39 = icmp eq i8 %38, 64
  br label %$13
$13:
  %40 = phi i64 [%26, %$12], [%36, %$14] ; # Pat
  %41 = phi i64 [%27, %$12], [%37, %$14] ; # Dat
  %42 = phi i1 [0, %$12], [%39, %$14] ; # ->
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%40, %$13] ; # Pat
  %44 = phi i64 [%41, %$13] ; # Dat
; # (? (atom Dat) (and (equal (cdr Pat) Dat) (prog (set X $Nil) YES))...
; # (atom Dat)
  %45 = and i64 %44, 15
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$18, label %$17
$18:
  %47 = phi i64 [%43, %$15] ; # Pat
  %48 = phi i64 [%44, %$15] ; # Dat
; # (and (equal (cdr Pat) Dat) (prog (set X $Nil) YES))
; # (cdr Pat)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (equal (cdr Pat) Dat)
  %52 = call i1 @equal(i64 %51, i64 %48)
  br i1 %52, label %$20, label %$19
$20:
  %53 = phi i64 [%47, %$18] ; # Pat
  %54 = phi i64 [%48, %$18] ; # Dat
; # (set X $Nil)
  %55 = inttoptr i64 %32 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %55
  br label %$19
$19:
  %56 = phi i64 [%47, %$18], [%53, %$20] ; # Pat
  %57 = phi i64 [%48, %$18], [%54, %$20] ; # Dat
  %58 = phi i1 [0, %$18], [1, %$20] ; # ->
  br label %$4
$17:
  %59 = phi i64 [%43, %$15] ; # Pat
  %60 = phi i64 [%44, %$15] ; # Dat
; # (? (match (cdr Pat) (cdr Dat)) (set X (cons (car Dat) $Nil)) YES)...
; # (cdr Pat)
  %61 = inttoptr i64 %59 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
; # (cdr Dat)
  %64 = inttoptr i64 %60 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  %66 = load i64, i64* %65
; # (match (cdr Pat) (cdr Dat))
  %67 = call i1 @match(i64 %63, i64 %66)
  br i1 %67, label %$22, label %$21
$22:
  %68 = phi i64 [%59, %$17] ; # Pat
  %69 = phi i64 [%60, %$17] ; # Dat
; # (set X (cons (car Dat) $Nil))
; # (car Dat)
  %70 = inttoptr i64 %69 to i64*
  %71 = load i64, i64* %70
; # (cons (car Dat) $Nil)
  %72 = call i64 @cons(i64 %71, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %73 = inttoptr i64 %32 to i64*
  store i64 %72, i64* %73
  br label %$4
$21:
  %74 = phi i64 [%59, %$17] ; # Pat
  %75 = phi i64 [%60, %$17] ; # Dat
; # (? (match (cdr Pat) Dat) (set X $Nil) YES)
; # (cdr Pat)
  %76 = inttoptr i64 %74 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (match (cdr Pat) Dat)
  %79 = call i1 @match(i64 %78, i64 %75)
  br i1 %79, label %$24, label %$23
$24:
  %80 = phi i64 [%74, %$21] ; # Pat
  %81 = phi i64 [%75, %$21] ; # Dat
; # (set X $Nil)
  %82 = inttoptr i64 %32 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %82
  br label %$4
$23:
  %83 = phi i64 [%74, %$21] ; # Pat
  %84 = phi i64 [%75, %$21] ; # Dat
; # (? (match Pat (cdr Dat)) (set X (cons (car Dat) (val X))) YES)
; # (cdr Dat)
  %85 = inttoptr i64 %84 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  %87 = load i64, i64* %86
; # (match Pat (cdr Dat))
  %88 = call i1 @match(i64 %83, i64 %87)
  br i1 %88, label %$26, label %$25
$26:
  %89 = phi i64 [%83, %$23] ; # Pat
  %90 = phi i64 [%84, %$23] ; # Dat
; # (set X (cons (car Dat) (val X)))
; # (car Dat)
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (val X)
  %93 = inttoptr i64 %32 to i64*
  %94 = load i64, i64* %93
; # (cons (car Dat) (val X))
  %95 = call i64 @cons(i64 %92, i64 %94)
  %96 = inttoptr i64 %32 to i64*
  store i64 %95, i64* %96
  br label %$4
$25:
  %97 = phi i64 [%83, %$23] ; # Pat
  %98 = phi i64 [%84, %$23] ; # Dat
  br label %$16
$16:
  %99 = phi i64 [%40, %$13], [%97, %$25] ; # Pat
  %100 = phi i64 [%41, %$13], [%98, %$25] ; # Dat
; # (? (or (atom Dat) (not (match X (car Dat)))) NO)
; # (or (atom Dat) (not (match X (car Dat))))
; # (atom Dat)
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$27, label %$28
$28:
  %103 = phi i64 [%99, %$16] ; # Pat
  %104 = phi i64 [%100, %$16] ; # Dat
; # (car Dat)
  %105 = inttoptr i64 %104 to i64*
  %106 = load i64, i64* %105
; # (match X (car Dat))
  %107 = call i1 @match(i64 %32, i64 %106)
; # (not (match X (car Dat)))
  %108 = icmp eq i1 %107, 0
  br label %$27
$27:
  %109 = phi i64 [%99, %$16], [%103, %$28] ; # Pat
  %110 = phi i64 [%100, %$16], [%104, %$28] ; # Dat
  %111 = phi i1 [1, %$16], [%108, %$28] ; # ->
  br i1 %111, label %$30, label %$29
$30:
  %112 = phi i64 [%109, %$27] ; # Pat
  %113 = phi i64 [%110, %$27] ; # Dat
  br label %$4
$29:
  %114 = phi i64 [%109, %$27] ; # Pat
  %115 = phi i64 [%110, %$27] ; # Dat
; # (shift Pat)
  %116 = inttoptr i64 %114 to i64*
  %117 = getelementptr i64, i64* %116, i32 1
  %118 = load i64, i64* %117
; # (shift Dat)
  %119 = inttoptr i64 %115 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  br label %$2
$4:
  %122 = phi i64 [%23, %$10], [%56, %$19], [%68, %$22], [%80, %$24], [%89, %$26], [%112, %$30] ; # Pat
  %123 = phi i64 [%24, %$10], [%57, %$19], [%69, %$22], [%81, %$24], [%90, %$26], [%113, %$30] ; # Dat
  %124 = phi i1 [%25, %$10], [%58, %$19], [1, %$22], [1, %$24], [1, %$26], [0, %$30] ; # ->
  ret i1 %124
}

define i64 @_match(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (match (save (eval (++ X))) (save (eval (car...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (match (save (eval (++ X))) (save (eval (car X)))) $T $Nil)
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %33, i64* %38
  %39 = add i64 %37, 8
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %41
; # (match (save (eval (++ X))) (save (eval (car X))))
  %42 = call i1 @match(i64 %15, i64 %33)
  br i1 %42, label %$12, label %$13
$12:
  %43 = phi i64 [%7, %$7] ; # X
  br label %$14
$13:
  %44 = phi i64 [%7, %$7] ; # X
  br label %$14
$14:
  %45 = phi i64 [%43, %$12], [%44, %$13] ; # X
  %46 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13] ; # ->
; # (drop *Safe)
  %47 = inttoptr i64 %19 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %50
  ret i64 %46
}

define i64 @fill2(i64, i64) align 8 {
$1:
; # (cond ((num? X) 0) ((sym? X) (let V (val X) (cond ((== X V) 0) ((...
; # (num? X)
  %2 = and i64 %0, 6
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # X
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
; # (sym? X)
  %6 = and i64 %5, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$3] ; # X
; # (let V (val X) (cond ((== X V) 0) ((nil? Y) (cond ((== X $At) 0) ...
; # (val X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (cond ((== X V) 0) ((nil? Y) (cond ((== X $At) 0) ((== (firstByte...
; # (== X V)
  %11 = icmp eq i64 %8, %10
  br i1 %11, label %$9, label %$8
$9:
  %12 = phi i64 [%8, %$6] ; # X
  br label %$7
$8:
  %13 = phi i64 [%8, %$6] ; # X
; # (nil? Y)
  %14 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$11, label %$10
$11:
  %15 = phi i64 [%13, %$8] ; # X
; # (cond ((== X $At) 0) ((== (firstByte X) (char "@")) V) (T 0))
; # (== X $At)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64)
  br i1 %16, label %$14, label %$13
$14:
  %17 = phi i64 [%15, %$11] ; # X
  br label %$12
$13:
  %18 = phi i64 [%15, %$11] ; # X
; # (firstByte X)
  %19 = call i8 @firstByte(i64 %18)
; # (== (firstByte X) (char "@"))
  %20 = icmp eq i8 %19, 64
  br i1 %20, label %$16, label %$15
$16:
  %21 = phi i64 [%18, %$13] ; # X
  br label %$12
$15:
  %22 = phi i64 [%18, %$13] ; # X
  br label %$12
$12:
  %23 = phi i64 [%17, %$14], [%21, %$16], [%22, %$15] ; # X
  %24 = phi i64 [0, %$14], [%10, %$16], [0, %$15] ; # ->
  br label %$7
$10:
  %25 = phi i64 [%13, %$8] ; # X
; # (or (== X Y) (memq X Y))
; # (== X Y)
  %26 = icmp eq i64 %25, %1
  br i1 %26, label %$17, label %$18
$18:
  %27 = phi i64 [%25, %$10] ; # X
; # (memq X Y)
  br label %$19
$19:
  %28 = phi i64 [%1, %$18], [%40, %$23] ; # L
  %29 = and i64 %28, 15
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$22, label %$20
$22:
  %31 = phi i64 [%28, %$19] ; # L
  br label %$21
$20:
  %32 = phi i64 [%28, %$19] ; # L
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = icmp eq i64 %27, %34
  br i1 %35, label %$24, label %$23
$24:
  %36 = phi i64 [%32, %$20] ; # L
  br label %$21
$23:
  %37 = phi i64 [%32, %$20] ; # L
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  br label %$19
$21:
  %41 = phi i64 [%31, %$22], [%36, %$24] ; # L
  %42 = phi i1 [0, %$22], [1, %$24] ; # ->
  br label %$17
$17:
  %43 = phi i64 [%25, %$10], [%27, %$21] ; # X
  %44 = phi i1 [1, %$10], [%42, %$21] ; # ->
  br i1 %44, label %$26, label %$25
$26:
  %45 = phi i64 [%43, %$17] ; # X
  br label %$7
$25:
  %46 = phi i64 [%43, %$17] ; # X
  br label %$7
$7:
  %47 = phi i64 [%12, %$9], [%23, %$12], [%45, %$26], [%46, %$25] ; # X
  %48 = phi i64 [0, %$9], [%24, %$12], [%10, %$26], [0, %$25] ; # ->
  br label %$2
$5:
  %49 = phi i64 [%5, %$3] ; # X
; # (stkChk 0)
  %50 = load i8*, i8** @$StkLimit
  %51 = call i8* @llvm.stacksave()
  %52 = icmp ugt i8* %50, %51
  br i1 %52, label %$27, label %$28
$27:
  call void @stkErr(i64 0)
  unreachable
$28:
; # (let Z (++ X) (if (== Z $Up) (let V (eval (++ X)) (if (nil? V) (i...
; # (++ X)
  %53 = inttoptr i64 %49 to i64*
  %54 = load i64, i64* %53
  %55 = getelementptr i64, i64* %53, i32 1
  %56 = load i64, i64* %55
; # (if (== Z $Up) (let V (eval (++ X)) (if (nil? V) (if (fill2 X Y) ...
; # (== Z $Up)
  %57 = icmp eq i64 %54, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64)
  br i1 %57, label %$29, label %$30
$29:
  %58 = phi i64 [%56, %$28] ; # X
  %59 = phi i64 [%54, %$28] ; # Z
; # (let V (eval (++ X)) (if (nil? V) (if (fill2 X Y) @ X) (save (set...
; # (++ X)
  %60 = inttoptr i64 %58 to i64*
  %61 = load i64, i64* %60
  %62 = getelementptr i64, i64* %60, i32 1
  %63 = load i64, i64* %62
; # (eval (++ X))
  %64 = and i64 %61, 6
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$34, label %$33
$34:
  br label %$32
$33:
  %66 = and i64 %61, 8
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$36, label %$35
$36:
  %68 = inttoptr i64 %61 to i64*
  %69 = load i64, i64* %68
  br label %$32
$35:
  %70 = call i64 @evList(i64 %61)
  br label %$32
$32:
  %71 = phi i64 [%61, %$34], [%69, %$36], [%70, %$35] ; # ->
; # (if (nil? V) (if (fill2 X Y) @ X) (save (setq Z V) (if (atom V) (...
; # (nil? V)
  %72 = icmp eq i64 %71, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %72, label %$37, label %$38
$37:
  %73 = phi i64 [%63, %$32] ; # X
  %74 = phi i64 [%59, %$32] ; # Z
  %75 = phi i64 [%71, %$32] ; # V
; # (if (fill2 X Y) @ X)
; # (fill2 X Y)
  %76 = call i64 @fill2(i64 %73, i64 %1)
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$40, label %$41
$40:
  %78 = phi i64 [%73, %$37] ; # X
  %79 = phi i64 [%74, %$37] ; # Z
  %80 = phi i64 [%75, %$37] ; # V
  br label %$42
$41:
  %81 = phi i64 [%73, %$37] ; # X
  %82 = phi i64 [%74, %$37] ; # Z
  %83 = phi i64 [%75, %$37] ; # V
  br label %$42
$42:
  %84 = phi i64 [%78, %$40], [%81, %$41] ; # X
  %85 = phi i64 [%79, %$40], [%82, %$41] ; # Z
  %86 = phi i64 [%80, %$40], [%83, %$41] ; # V
  %87 = phi i64 [%76, %$40], [%81, %$41] ; # ->
  br label %$39
$38:
  %88 = phi i64 [%63, %$32] ; # X
  %89 = phi i64 [%59, %$32] ; # Z
  %90 = phi i64 [%71, %$32] ; # V
; # (save (setq Z V) (if (atom V) (safe (setq Z (setq V (cons V $Nil)...
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %92 = load i64, i64* %91
  %93 = alloca i64, i64 2, align 16
  %94 = ptrtoint i64* %93 to i64
  %95 = inttoptr i64 %94 to i64*
  store i64 %90, i64* %95
  %96 = add i64 %94, 8
  %97 = inttoptr i64 %96 to i64*
  store i64 %92, i64* %97
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %94, i64* %98
; # (if (atom V) (safe (setq Z (setq V (cons V $Nil)))) (while (pair ...
; # (atom V)
  %99 = and i64 %90, 15
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$43, label %$44
$43:
  %101 = phi i64 [%88, %$38] ; # X
  %102 = phi i64 [%90, %$38] ; # Z
  %103 = phi i64 [%90, %$38] ; # V
; # (cons V $Nil)
  %104 = call i64 @cons(i64 %103, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (safe (setq Z (setq V (cons V $Nil))))
  %105 = inttoptr i64 %94 to i64*
  store i64 %104, i64* %105
  br label %$45
$44:
  %106 = phi i64 [%88, %$38] ; # X
  %107 = phi i64 [%90, %$38] ; # Z
  %108 = phi i64 [%90, %$38] ; # V
; # (while (pair (cdr V)) (setq V @))
  br label %$46
$46:
  %109 = phi i64 [%106, %$44], [%117, %$47] ; # X
  %110 = phi i64 [%107, %$44], [%118, %$47] ; # Z
  %111 = phi i64 [%108, %$44], [%114, %$47] ; # V
; # (cdr V)
  %112 = inttoptr i64 %111 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  %114 = load i64, i64* %113
; # (pair (cdr V))
  %115 = and i64 %114, 15
  %116 = icmp eq i64 %115, 0
  br i1 %116, label %$47, label %$48
$47:
  %117 = phi i64 [%109, %$46] ; # X
  %118 = phi i64 [%110, %$46] ; # Z
  %119 = phi i64 [%111, %$46] ; # V
  br label %$46
$48:
  %120 = phi i64 [%109, %$46] ; # X
  %121 = phi i64 [%110, %$46] ; # Z
  %122 = phi i64 [%111, %$46] ; # V
  br label %$45
$45:
  %123 = phi i64 [%101, %$43], [%120, %$48] ; # X
  %124 = phi i64 [%104, %$43], [%121, %$48] ; # Z
  %125 = phi i64 [%104, %$43], [%122, %$48] ; # V
; # (set 2 V (if (fill2 X Y) @ X))
; # (if (fill2 X Y) @ X)
; # (fill2 X Y)
  %126 = call i64 @fill2(i64 %123, i64 %1)
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$49, label %$50
$49:
  %128 = phi i64 [%123, %$45] ; # X
  %129 = phi i64 [%124, %$45] ; # Z
  %130 = phi i64 [%125, %$45] ; # V
  br label %$51
$50:
  %131 = phi i64 [%123, %$45] ; # X
  %132 = phi i64 [%124, %$45] ; # Z
  %133 = phi i64 [%125, %$45] ; # V
  br label %$51
$51:
  %134 = phi i64 [%128, %$49], [%131, %$50] ; # X
  %135 = phi i64 [%129, %$49], [%132, %$50] ; # Z
  %136 = phi i64 [%130, %$49], [%133, %$50] ; # V
  %137 = phi i64 [%126, %$49], [%131, %$50] ; # ->
  %138 = inttoptr i64 %125 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  store i64 %137, i64* %139
; # drop
  %140 = inttoptr i64 %94 to i64*
  %141 = getelementptr i64, i64* %140, i32 1
  %142 = load i64, i64* %141
  %143 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %142, i64* %143
  br label %$39
$39:
  %144 = phi i64 [%84, %$42], [%134, %$51] ; # X
  %145 = phi i64 [%85, %$42], [%135, %$51] ; # Z
  %146 = phi i64 [%86, %$42], [%136, %$51] ; # V
  %147 = phi i64 [%87, %$42], [%135, %$51] ; # ->
  br label %$31
$30:
  %148 = phi i64 [%56, %$28] ; # X
  %149 = phi i64 [%54, %$28] ; # Z
; # (cond ((fill2 Z Y) (save @ (cons @ (if (fill2 X Y) @ X)))) ((fill...
; # (fill2 Z Y)
  %150 = call i64 @fill2(i64 %149, i64 %1)
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$54, label %$53
$54:
  %152 = phi i64 [%148, %$30] ; # X
  %153 = phi i64 [%149, %$30] ; # Z
; # (save @ (cons @ (if (fill2 X Y) @ X)))
  %154 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %155 = load i64, i64* %154
  %156 = alloca i64, i64 2, align 16
  %157 = ptrtoint i64* %156 to i64
  %158 = inttoptr i64 %157 to i64*
  store i64 %150, i64* %158
  %159 = add i64 %157, 8
  %160 = inttoptr i64 %159 to i64*
  store i64 %155, i64* %160
  %161 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %157, i64* %161
; # (if (fill2 X Y) @ X)
; # (fill2 X Y)
  %162 = call i64 @fill2(i64 %152, i64 %1)
  %163 = icmp ne i64 %162, 0
  br i1 %163, label %$55, label %$56
$55:
  %164 = phi i64 [%152, %$54] ; # X
  %165 = phi i64 [%153, %$54] ; # Z
  br label %$57
$56:
  %166 = phi i64 [%152, %$54] ; # X
  %167 = phi i64 [%153, %$54] ; # Z
  br label %$57
$57:
  %168 = phi i64 [%164, %$55], [%166, %$56] ; # X
  %169 = phi i64 [%165, %$55], [%167, %$56] ; # Z
  %170 = phi i64 [%162, %$55], [%166, %$56] ; # ->
; # (cons @ (if (fill2 X Y) @ X))
  %171 = call i64 @cons(i64 %150, i64 %170)
; # drop
  %172 = inttoptr i64 %157 to i64*
  %173 = getelementptr i64, i64* %172, i32 1
  %174 = load i64, i64* %173
  %175 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %174, i64* %175
  br label %$52
$53:
  %176 = phi i64 [%148, %$30] ; # X
  %177 = phi i64 [%149, %$30] ; # Z
; # (fill2 X Y)
  %178 = call i64 @fill2(i64 %176, i64 %1)
  %179 = icmp ne i64 %178, 0
  br i1 %179, label %$59, label %$58
$59:
  %180 = phi i64 [%176, %$53] ; # X
  %181 = phi i64 [%177, %$53] ; # Z
; # (cons Z @)
  %182 = call i64 @cons(i64 %181, i64 %178)
  br label %$52
$58:
  %183 = phi i64 [%176, %$53] ; # X
  %184 = phi i64 [%177, %$53] ; # Z
  br label %$52
$52:
  %185 = phi i64 [%168, %$57], [%180, %$59], [%183, %$58] ; # X
  %186 = phi i64 [%169, %$57], [%181, %$59], [%184, %$58] ; # Z
  %187 = phi i64 [%171, %$57], [%182, %$59], [0, %$58] ; # ->
  br label %$31
$31:
  %188 = phi i64 [%144, %$39], [%185, %$52] ; # X
  %189 = phi i64 [%145, %$39], [%186, %$52] ; # Z
  %190 = phi i64 [%147, %$39], [%187, %$52] ; # ->
  br label %$2
$2:
  %191 = phi i64 [%4, %$4], [%47, %$7], [%188, %$31] ; # X
  %192 = phi i64 [0, %$4], [%48, %$7], [%190, %$31] ; # ->
  ret i64 %192
}

define i64 @fill3(i64, i64, i64) align 8 {
$1:
; # (if (atom X) (if (== X Y) Z 0) (stkChk 0) (let A (++ X) (cond ((f...
; # (atom X)
  %3 = and i64 %0, 15
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%0, %$1] ; # X
; # (if (== X Y) Z 0)
; # (== X Y)
  %6 = icmp eq i64 %5, %1
  br i1 %6, label %$5, label %$6
$5:
  %7 = phi i64 [%5, %$2] ; # X
  br label %$7
$6:
  %8 = phi i64 [%5, %$2] ; # X
  br label %$7
$7:
  %9 = phi i64 [%7, %$5], [%8, %$6] ; # X
  %10 = phi i64 [%2, %$5], [0, %$6] ; # ->
  br label %$4
$3:
  %11 = phi i64 [%0, %$1] ; # X
; # (stkChk 0)
  %12 = load i8*, i8** @$StkLimit
  %13 = call i8* @llvm.stacksave()
  %14 = icmp ugt i8* %12, %13
  br i1 %14, label %$8, label %$9
$8:
  call void @stkErr(i64 0)
  unreachable
$9:
; # (let A (++ X) (cond ((fill3 A Y Z) (save @ (cons @ (if (fill3 X Y...
; # (++ X)
  %15 = inttoptr i64 %11 to i64*
  %16 = load i64, i64* %15
  %17 = getelementptr i64, i64* %15, i32 1
  %18 = load i64, i64* %17
; # (cond ((fill3 A Y Z) (save @ (cons @ (if (fill3 X Y Z) @ X)))) ((...
; # (fill3 A Y Z)
  %19 = call i64 @fill3(i64 %16, i64 %1, i64 %2)
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$12, label %$11
$12:
  %21 = phi i64 [%18, %$9] ; # X
; # (save @ (cons @ (if (fill3 X Y Z) @ X)))
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 %19, i64* %26
  %27 = add i64 %25, 8
  %28 = inttoptr i64 %27 to i64*
  store i64 %23, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %29
; # (if (fill3 X Y Z) @ X)
; # (fill3 X Y Z)
  %30 = call i64 @fill3(i64 %21, i64 %1, i64 %2)
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$13, label %$14
$13:
  %32 = phi i64 [%21, %$12] ; # X
  br label %$15
$14:
  %33 = phi i64 [%21, %$12] ; # X
  br label %$15
$15:
  %34 = phi i64 [%32, %$13], [%33, %$14] ; # X
  %35 = phi i64 [%30, %$13], [%33, %$14] ; # ->
; # (cons @ (if (fill3 X Y Z) @ X))
  %36 = call i64 @cons(i64 %19, i64 %35)
; # drop
  %37 = inttoptr i64 %25 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %40
  br label %$10
$11:
  %41 = phi i64 [%18, %$9] ; # X
; # (fill3 X Y Z)
  %42 = call i64 @fill3(i64 %41, i64 %1, i64 %2)
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$17, label %$16
$17:
  %44 = phi i64 [%41, %$11] ; # X
; # (cons A @)
  %45 = call i64 @cons(i64 %16, i64 %42)
  br label %$10
$16:
  %46 = phi i64 [%41, %$11] ; # X
  br label %$10
$10:
  %47 = phi i64 [%34, %$15], [%44, %$17], [%46, %$16] ; # X
  %48 = phi i64 [%36, %$15], [%45, %$17], [0, %$16] ; # ->
  br label %$4
$4:
  %49 = phi i64 [%9, %$7], [%47, %$10] ; # X
  %50 = phi i64 [%10, %$7], [%48, %$10] ; # ->
  ret i64 %50
}

define i64 @_fill(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (++ X)))) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %37 = load i64, i64* %36
  %38 = alloca i64, i64 2, align 16
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 %39 to i64*
  store i64 %35, i64* %40
  %41 = add i64 %39, 8
  %42 = inttoptr i64 %41 to i64*
  store i64 %37, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %43
; # (if (if (pair X) (fill3 Y Z (save (eval (car X)))) (fill2 Y Z)) @...
; # (if (pair X) (fill3 Y Z (save (eval (car X)))) (fill2 Y Z))
; # (pair X)
  %44 = and i64 %27, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$12, label %$13
$12:
; # (car X)
  %46 = inttoptr i64 %27 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$17, label %$16
$17:
  br label %$15
$16:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$19, label %$18
$19:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$15
$18:
  %54 = call i64 @evList(i64 %47)
  br label %$15
$15:
  %55 = phi i64 [%47, %$17], [%53, %$19], [%54, %$18] ; # ->
; # (save (eval (car X)))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = alloca i64, i64 2, align 16
  %59 = ptrtoint i64* %58 to i64
  %60 = inttoptr i64 %59 to i64*
  store i64 %55, i64* %60
  %61 = add i64 %59, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %63
; # (fill3 Y Z (save (eval (car X))))
  %64 = call i64 @fill3(i64 %15, i64 %35, i64 %55)
  br label %$14
$13:
; # (fill2 Y Z)
  %65 = call i64 @fill2(i64 %15, i64 %35)
  br label %$14
$14:
  %66 = phi i64 [%64, %$15], [%65, %$13] ; # ->
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$20, label %$21
$20:
  br label %$22
$21:
  br label %$22
$22:
  %68 = phi i64 [%66, %$20], [%15, %$21] ; # ->
; # (drop *Safe)
  %69 = inttoptr i64 %19 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  ret i64 %68
}
@$Penv = global i64 0
@$Pnl = global i64 0

define i1 @unify(i64, i64, i64, i64) align 8 {
$1:
; # (let Penv (val $Penv) (: 1 (when (and (symb? X1) (== (firstByte X...
; # (val $Penv)
  %4 = load i64, i64* @$Penv
; # (: 1 (when (and (symb? X1) (== (firstByte X1) (char "@"))) (let X...
  br label %$-1
$-1:
  %5 = phi i64 [%0, %$1], [%75, %$11] ; # N1
  %6 = phi i64 [%1, %$1], [%78, %$11] ; # X1
  %7 = phi i64 [%2, %$1], [%67, %$11] ; # N2
  %8 = phi i64 [%3, %$1], [%68, %$11] ; # X2
; # (when (and (symb? X1) (== (firstByte X1) (char "@"))) (let X (val...
; # (and (symb? X1) (== (firstByte X1) (char "@")))
; # (symb? X1)
  %9 = xor i64 %6, 8
  %10 = and i64 %9, 14
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$3, label %$2
$3:
  %12 = phi i64 [%5, %$-1] ; # N1
  %13 = phi i64 [%6, %$-1] ; # X1
  %14 = phi i64 [%7, %$-1] ; # N2
  %15 = phi i64 [%8, %$-1] ; # X2
; # (firstByte X1)
  %16 = call i8 @firstByte(i64 %13)
; # (== (firstByte X1) (char "@"))
  %17 = icmp eq i8 %16, 64
  br label %$2
$2:
  %18 = phi i64 [%5, %$-1], [%12, %$3] ; # N1
  %19 = phi i64 [%6, %$-1], [%13, %$3] ; # X1
  %20 = phi i64 [%7, %$-1], [%14, %$3] ; # N2
  %21 = phi i64 [%8, %$-1], [%15, %$3] ; # X2
  %22 = phi i1 [0, %$-1], [%17, %$3] ; # ->
  br i1 %22, label %$4, label %$5
$4:
  %23 = phi i64 [%18, %$2] ; # N1
  %24 = phi i64 [%19, %$2] ; # X1
  %25 = phi i64 [%20, %$2] ; # N2
  %26 = phi i64 [%21, %$2] ; # X2
; # (let X (val Penv) (while (pair (car X)) (let (Y @ Z (car Y)) (whe...
; # (val Penv)
  %27 = inttoptr i64 %4 to i64*
  %28 = load i64, i64* %27
; # (while (pair (car X)) (let (Y @ Z (car Y)) (when (and (== N1 (car...
  br label %$6
$6:
  %29 = phi i64 [%23, %$4], [%79, %$12] ; # N1
  %30 = phi i64 [%24, %$4], [%80, %$12] ; # X1
  %31 = phi i64 [%25, %$4], [%81, %$12] ; # N2
  %32 = phi i64 [%26, %$4], [%82, %$12] ; # X2
  %33 = phi i64 [%28, %$4], [%87, %$12] ; # X
; # (car X)
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (pair (car X))
  %36 = and i64 %35, 15
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %$7, label %$8
$7:
  %38 = phi i64 [%29, %$6] ; # N1
  %39 = phi i64 [%30, %$6] ; # X1
  %40 = phi i64 [%31, %$6] ; # N2
  %41 = phi i64 [%32, %$6] ; # X2
  %42 = phi i64 [%33, %$6] ; # X
; # (let (Y @ Z (car Y)) (when (and (== N1 (car Z)) (== X1 (cdr Z))) ...
; # (car Y)
  %43 = inttoptr i64 %35 to i64*
  %44 = load i64, i64* %43
; # (when (and (== N1 (car Z)) (== X1 (cdr Z))) (setq Z (cdr Y) N1 (c...
; # (and (== N1 (car Z)) (== X1 (cdr Z)))
; # (car Z)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (== N1 (car Z))
  %47 = icmp eq i64 %38, %46
  br i1 %47, label %$10, label %$9
$10:
  %48 = phi i64 [%38, %$7] ; # N1
  %49 = phi i64 [%39, %$7] ; # X1
  %50 = phi i64 [%40, %$7] ; # N2
  %51 = phi i64 [%41, %$7] ; # X2
  %52 = phi i64 [%42, %$7] ; # X
  %53 = phi i64 [%44, %$7] ; # Z
; # (cdr Z)
  %54 = inttoptr i64 %53 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
; # (== X1 (cdr Z))
  %57 = icmp eq i64 %49, %56
  br label %$9
$9:
  %58 = phi i64 [%38, %$7], [%48, %$10] ; # N1
  %59 = phi i64 [%39, %$7], [%49, %$10] ; # X1
  %60 = phi i64 [%40, %$7], [%50, %$10] ; # N2
  %61 = phi i64 [%41, %$7], [%51, %$10] ; # X2
  %62 = phi i64 [%42, %$7], [%52, %$10] ; # X
  %63 = phi i64 [%44, %$7], [%53, %$10] ; # Z
  %64 = phi i1 [0, %$7], [%57, %$10] ; # ->
  br i1 %64, label %$11, label %$12
$11:
  %65 = phi i64 [%58, %$9] ; # N1
  %66 = phi i64 [%59, %$9] ; # X1
  %67 = phi i64 [%60, %$9] ; # N2
  %68 = phi i64 [%61, %$9] ; # X2
  %69 = phi i64 [%62, %$9] ; # X
  %70 = phi i64 [%63, %$9] ; # Z
; # (cdr Y)
  %71 = inttoptr i64 %35 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
; # (car Z)
  %74 = inttoptr i64 %73 to i64*
  %75 = load i64, i64* %74
; # (cdr Z)
  %76 = inttoptr i64 %73 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (goto 1)
  br label %$-1
$12:
  %79 = phi i64 [%58, %$9] ; # N1
  %80 = phi i64 [%59, %$9] ; # X1
  %81 = phi i64 [%60, %$9] ; # N2
  %82 = phi i64 [%61, %$9] ; # X2
  %83 = phi i64 [%62, %$9] ; # X
  %84 = phi i64 [%63, %$9] ; # Z
; # (shift X)
  %85 = inttoptr i64 %83 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  %87 = load i64, i64* %86
  br label %$6
$8:
  %88 = phi i64 [%29, %$6] ; # N1
  %89 = phi i64 [%30, %$6] ; # X1
  %90 = phi i64 [%31, %$6] ; # N2
  %91 = phi i64 [%32, %$6] ; # X2
  %92 = phi i64 [%33, %$6] ; # X
  br label %$5
$5:
  %93 = phi i64 [%18, %$2], [%88, %$8] ; # N1
  %94 = phi i64 [%19, %$2], [%89, %$8] ; # X1
  %95 = phi i64 [%20, %$2], [%90, %$8] ; # N2
  %96 = phi i64 [%21, %$2], [%91, %$8] ; # X2
; # (: 2 (when (and (symb? X2) (== (firstByte X2) (char "@"))) (let X...
  br label %$-2
$-2:
  %97 = phi i64 [%93, %$5], [%157, %$22] ; # N1
  %98 = phi i64 [%94, %$5], [%158, %$22] ; # X1
  %99 = phi i64 [%95, %$5], [%167, %$22] ; # N2
  %100 = phi i64 [%96, %$5], [%170, %$22] ; # X2
; # (when (and (symb? X2) (== (firstByte X2) (char "@"))) (let X (val...
; # (and (symb? X2) (== (firstByte X2) (char "@")))
; # (symb? X2)
  %101 = xor i64 %100, 8
  %102 = and i64 %101, 14
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %$14, label %$13
$14:
  %104 = phi i64 [%97, %$-2] ; # N1
  %105 = phi i64 [%98, %$-2] ; # X1
  %106 = phi i64 [%99, %$-2] ; # N2
  %107 = phi i64 [%100, %$-2] ; # X2
; # (firstByte X2)
  %108 = call i8 @firstByte(i64 %107)
; # (== (firstByte X2) (char "@"))
  %109 = icmp eq i8 %108, 64
  br label %$13
$13:
  %110 = phi i64 [%97, %$-2], [%104, %$14] ; # N1
  %111 = phi i64 [%98, %$-2], [%105, %$14] ; # X1
  %112 = phi i64 [%99, %$-2], [%106, %$14] ; # N2
  %113 = phi i64 [%100, %$-2], [%107, %$14] ; # X2
  %114 = phi i1 [0, %$-2], [%109, %$14] ; # ->
  br i1 %114, label %$15, label %$16
$15:
  %115 = phi i64 [%110, %$13] ; # N1
  %116 = phi i64 [%111, %$13] ; # X1
  %117 = phi i64 [%112, %$13] ; # N2
  %118 = phi i64 [%113, %$13] ; # X2
; # (let X (val Penv) (while (pair (car X)) (let (Y @ Z (car Y)) (whe...
; # (val Penv)
  %119 = inttoptr i64 %4 to i64*
  %120 = load i64, i64* %119
; # (while (pair (car X)) (let (Y @ Z (car Y)) (when (and (== N2 (car...
  br label %$17
$17:
  %121 = phi i64 [%115, %$15], [%171, %$23] ; # N1
  %122 = phi i64 [%116, %$15], [%172, %$23] ; # X1
  %123 = phi i64 [%117, %$15], [%173, %$23] ; # N2
  %124 = phi i64 [%118, %$15], [%174, %$23] ; # X2
  %125 = phi i64 [%120, %$15], [%179, %$23] ; # X
; # (car X)
  %126 = inttoptr i64 %125 to i64*
  %127 = load i64, i64* %126
; # (pair (car X))
  %128 = and i64 %127, 15
  %129 = icmp eq i64 %128, 0
  br i1 %129, label %$18, label %$19
$18:
  %130 = phi i64 [%121, %$17] ; # N1
  %131 = phi i64 [%122, %$17] ; # X1
  %132 = phi i64 [%123, %$17] ; # N2
  %133 = phi i64 [%124, %$17] ; # X2
  %134 = phi i64 [%125, %$17] ; # X
; # (let (Y @ Z (car Y)) (when (and (== N2 (car Z)) (== X2 (cdr Z))) ...
; # (car Y)
  %135 = inttoptr i64 %127 to i64*
  %136 = load i64, i64* %135
; # (when (and (== N2 (car Z)) (== X2 (cdr Z))) (setq Z (cdr Y) N2 (c...
; # (and (== N2 (car Z)) (== X2 (cdr Z)))
; # (car Z)
  %137 = inttoptr i64 %136 to i64*
  %138 = load i64, i64* %137
; # (== N2 (car Z))
  %139 = icmp eq i64 %132, %138
  br i1 %139, label %$21, label %$20
$21:
  %140 = phi i64 [%130, %$18] ; # N1
  %141 = phi i64 [%131, %$18] ; # X1
  %142 = phi i64 [%132, %$18] ; # N2
  %143 = phi i64 [%133, %$18] ; # X2
  %144 = phi i64 [%134, %$18] ; # X
  %145 = phi i64 [%136, %$18] ; # Z
; # (cdr Z)
  %146 = inttoptr i64 %145 to i64*
  %147 = getelementptr i64, i64* %146, i32 1
  %148 = load i64, i64* %147
; # (== X2 (cdr Z))
  %149 = icmp eq i64 %143, %148
  br label %$20
$20:
  %150 = phi i64 [%130, %$18], [%140, %$21] ; # N1
  %151 = phi i64 [%131, %$18], [%141, %$21] ; # X1
  %152 = phi i64 [%132, %$18], [%142, %$21] ; # N2
  %153 = phi i64 [%133, %$18], [%143, %$21] ; # X2
  %154 = phi i64 [%134, %$18], [%144, %$21] ; # X
  %155 = phi i64 [%136, %$18], [%145, %$21] ; # Z
  %156 = phi i1 [0, %$18], [%149, %$21] ; # ->
  br i1 %156, label %$22, label %$23
$22:
  %157 = phi i64 [%150, %$20] ; # N1
  %158 = phi i64 [%151, %$20] ; # X1
  %159 = phi i64 [%152, %$20] ; # N2
  %160 = phi i64 [%153, %$20] ; # X2
  %161 = phi i64 [%154, %$20] ; # X
  %162 = phi i64 [%155, %$20] ; # Z
; # (cdr Y)
  %163 = inttoptr i64 %127 to i64*
  %164 = getelementptr i64, i64* %163, i32 1
  %165 = load i64, i64* %164
; # (car Z)
  %166 = inttoptr i64 %165 to i64*
  %167 = load i64, i64* %166
; # (cdr Z)
  %168 = inttoptr i64 %165 to i64*
  %169 = getelementptr i64, i64* %168, i32 1
  %170 = load i64, i64* %169
; # (goto 2)
  br label %$-2
$23:
  %171 = phi i64 [%150, %$20] ; # N1
  %172 = phi i64 [%151, %$20] ; # X1
  %173 = phi i64 [%152, %$20] ; # N2
  %174 = phi i64 [%153, %$20] ; # X2
  %175 = phi i64 [%154, %$20] ; # X
  %176 = phi i64 [%155, %$20] ; # Z
; # (shift X)
  %177 = inttoptr i64 %175 to i64*
  %178 = getelementptr i64, i64* %177, i32 1
  %179 = load i64, i64* %178
  br label %$17
$19:
  %180 = phi i64 [%121, %$17] ; # N1
  %181 = phi i64 [%122, %$17] ; # X1
  %182 = phi i64 [%123, %$17] ; # N2
  %183 = phi i64 [%124, %$17] ; # X2
  %184 = phi i64 [%125, %$17] ; # X
  br label %$16
$16:
  %185 = phi i64 [%110, %$13], [%180, %$19] ; # N1
  %186 = phi i64 [%111, %$13], [%181, %$19] ; # X1
  %187 = phi i64 [%112, %$13], [%182, %$19] ; # N2
  %188 = phi i64 [%113, %$13], [%183, %$19] ; # X2
; # (cond ((and (== N1 N2) (equal X1 X2)) YES) ((and (symb? X1) (== (...
; # (and (== N1 N2) (equal X1 X2))
; # (== N1 N2)
  %189 = icmp eq i64 %185, %187
  br i1 %189, label %$26, label %$25
$26:
  %190 = phi i64 [%185, %$16] ; # N1
  %191 = phi i64 [%186, %$16] ; # X1
  %192 = phi i64 [%187, %$16] ; # N2
  %193 = phi i64 [%188, %$16] ; # X2
; # (equal X1 X2)
  %194 = call i1 @equal(i64 %191, i64 %193)
  br label %$25
$25:
  %195 = phi i64 [%185, %$16], [%190, %$26] ; # N1
  %196 = phi i64 [%186, %$16], [%191, %$26] ; # X1
  %197 = phi i64 [%187, %$16], [%192, %$26] ; # N2
  %198 = phi i64 [%188, %$16], [%193, %$26] ; # X2
  %199 = phi i1 [0, %$16], [%194, %$26] ; # ->
  br i1 %199, label %$28, label %$27
$28:
  %200 = phi i64 [%195, %$25] ; # N1
  %201 = phi i64 [%196, %$25] ; # X1
  %202 = phi i64 [%197, %$25] ; # N2
  %203 = phi i64 [%198, %$25] ; # X2
  br label %$24
$27:
  %204 = phi i64 [%195, %$25] ; # N1
  %205 = phi i64 [%196, %$25] ; # X1
  %206 = phi i64 [%197, %$25] ; # N2
  %207 = phi i64 [%198, %$25] ; # X2
; # (and (symb? X1) (== (firstByte X1) (char "@")))
; # (symb? X1)
  %208 = xor i64 %205, 8
  %209 = and i64 %208, 14
  %210 = icmp eq i64 %209, 0
  br i1 %210, label %$30, label %$29
$30:
  %211 = phi i64 [%204, %$27] ; # N1
  %212 = phi i64 [%205, %$27] ; # X1
  %213 = phi i64 [%206, %$27] ; # N2
  %214 = phi i64 [%207, %$27] ; # X2
; # (firstByte X1)
  %215 = call i8 @firstByte(i64 %212)
; # (== (firstByte X1) (char "@"))
  %216 = icmp eq i8 %215, 64
  br label %$29
$29:
  %217 = phi i64 [%204, %$27], [%211, %$30] ; # N1
  %218 = phi i64 [%205, %$27], [%212, %$30] ; # X1
  %219 = phi i64 [%206, %$27], [%213, %$30] ; # N2
  %220 = phi i64 [%207, %$27], [%214, %$30] ; # X2
  %221 = phi i1 [0, %$27], [%216, %$30] ; # ->
  br i1 %221, label %$32, label %$31
$32:
  %222 = phi i64 [%217, %$29] ; # N1
  %223 = phi i64 [%218, %$29] ; # X1
  %224 = phi i64 [%219, %$29] ; # N2
  %225 = phi i64 [%220, %$29] ; # X2
; # (unless (== X1 $At) (set Penv (cons (cons3 N1 X1 N2 X2) (val Penv...
; # (== X1 $At)
  %226 = icmp eq i64 %223, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64)
  br i1 %226, label %$34, label %$33
$33:
  %227 = phi i64 [%222, %$32] ; # N1
  %228 = phi i64 [%223, %$32] ; # X1
  %229 = phi i64 [%224, %$32] ; # N2
  %230 = phi i64 [%225, %$32] ; # X2
; # (set Penv (cons (cons3 N1 X1 N2 X2) (val Penv)))
; # (cons3 N1 X1 N2 X2)
  %231 = call i64 @cons3(i64 %227, i64 %228, i64 %229, i64 %230)
; # (val Penv)
  %232 = inttoptr i64 %4 to i64*
  %233 = load i64, i64* %232
; # (cons (cons3 N1 X1 N2 X2) (val Penv))
  %234 = call i64 @cons(i64 %231, i64 %233)
  %235 = inttoptr i64 %4 to i64*
  store i64 %234, i64* %235
  br label %$34
$34:
  %236 = phi i64 [%222, %$32], [%227, %$33] ; # N1
  %237 = phi i64 [%223, %$32], [%228, %$33] ; # X1
  %238 = phi i64 [%224, %$32], [%229, %$33] ; # N2
  %239 = phi i64 [%225, %$32], [%230, %$33] ; # X2
  br label %$24
$31:
  %240 = phi i64 [%217, %$29] ; # N1
  %241 = phi i64 [%218, %$29] ; # X1
  %242 = phi i64 [%219, %$29] ; # N2
  %243 = phi i64 [%220, %$29] ; # X2
; # (and (symb? X2) (== (firstByte X2) (char "@")))
; # (symb? X2)
  %244 = xor i64 %243, 8
  %245 = and i64 %244, 14
  %246 = icmp eq i64 %245, 0
  br i1 %246, label %$36, label %$35
$36:
  %247 = phi i64 [%240, %$31] ; # N1
  %248 = phi i64 [%241, %$31] ; # X1
  %249 = phi i64 [%242, %$31] ; # N2
  %250 = phi i64 [%243, %$31] ; # X2
; # (firstByte X2)
  %251 = call i8 @firstByte(i64 %250)
; # (== (firstByte X2) (char "@"))
  %252 = icmp eq i8 %251, 64
  br label %$35
$35:
  %253 = phi i64 [%240, %$31], [%247, %$36] ; # N1
  %254 = phi i64 [%241, %$31], [%248, %$36] ; # X1
  %255 = phi i64 [%242, %$31], [%249, %$36] ; # N2
  %256 = phi i64 [%243, %$31], [%250, %$36] ; # X2
  %257 = phi i1 [0, %$31], [%252, %$36] ; # ->
  br i1 %257, label %$38, label %$37
$38:
  %258 = phi i64 [%253, %$35] ; # N1
  %259 = phi i64 [%254, %$35] ; # X1
  %260 = phi i64 [%255, %$35] ; # N2
  %261 = phi i64 [%256, %$35] ; # X2
; # (unless (== X2 $At) (set Penv (cons (cons3 N2 X2 N1 X1) (val Penv...
; # (== X2 $At)
  %262 = icmp eq i64 %261, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64)
  br i1 %262, label %$40, label %$39
$39:
  %263 = phi i64 [%258, %$38] ; # N1
  %264 = phi i64 [%259, %$38] ; # X1
  %265 = phi i64 [%260, %$38] ; # N2
  %266 = phi i64 [%261, %$38] ; # X2
; # (set Penv (cons (cons3 N2 X2 N1 X1) (val Penv)))
; # (cons3 N2 X2 N1 X1)
  %267 = call i64 @cons3(i64 %265, i64 %266, i64 %263, i64 %264)
; # (val Penv)
  %268 = inttoptr i64 %4 to i64*
  %269 = load i64, i64* %268
; # (cons (cons3 N2 X2 N1 X1) (val Penv))
  %270 = call i64 @cons(i64 %267, i64 %269)
  %271 = inttoptr i64 %4 to i64*
  store i64 %270, i64* %271
  br label %$40
$40:
  %272 = phi i64 [%258, %$38], [%263, %$39] ; # N1
  %273 = phi i64 [%259, %$38], [%264, %$39] ; # X1
  %274 = phi i64 [%260, %$38], [%265, %$39] ; # N2
  %275 = phi i64 [%261, %$38], [%266, %$39] ; # X2
  br label %$24
$37:
  %276 = phi i64 [%253, %$35] ; # N1
  %277 = phi i64 [%254, %$35] ; # X1
  %278 = phi i64 [%255, %$35] ; # N2
  %279 = phi i64 [%256, %$35] ; # X2
; # (or (atom X1) (atom X2))
; # (atom X1)
  %280 = and i64 %277, 15
  %281 = icmp ne i64 %280, 0
  br i1 %281, label %$41, label %$42
$42:
  %282 = phi i64 [%276, %$37] ; # N1
  %283 = phi i64 [%277, %$37] ; # X1
  %284 = phi i64 [%278, %$37] ; # N2
  %285 = phi i64 [%279, %$37] ; # X2
; # (atom X2)
  %286 = and i64 %285, 15
  %287 = icmp ne i64 %286, 0
  br label %$41
$41:
  %288 = phi i64 [%276, %$37], [%282, %$42] ; # N1
  %289 = phi i64 [%277, %$37], [%283, %$42] ; # X1
  %290 = phi i64 [%278, %$37], [%284, %$42] ; # N2
  %291 = phi i64 [%279, %$37], [%285, %$42] ; # X2
  %292 = phi i1 [1, %$37], [%287, %$42] ; # ->
  br i1 %292, label %$44, label %$43
$44:
  %293 = phi i64 [%288, %$41] ; # N1
  %294 = phi i64 [%289, %$41] ; # X1
  %295 = phi i64 [%290, %$41] ; # N2
  %296 = phi i64 [%291, %$41] ; # X2
; # (equal X1 X2)
  %297 = call i1 @equal(i64 %294, i64 %296)
  br label %$24
$43:
  %298 = phi i64 [%288, %$41] ; # N1
  %299 = phi i64 [%289, %$41] ; # X1
  %300 = phi i64 [%290, %$41] ; # N2
  %301 = phi i64 [%291, %$41] ; # X2
; # (stkChk 0)
  %302 = load i8*, i8** @$StkLimit
  %303 = call i8* @llvm.stacksave()
  %304 = icmp ugt i8* %302, %303
  br i1 %304, label %$45, label %$46
$45:
  call void @stkErr(i64 0)
  unreachable
$46:
; # (let Env (val Penv) (or (and (unify N1 (car X1) N2 (car X2)) (uni...
; # (val Penv)
  %305 = inttoptr i64 %4 to i64*
  %306 = load i64, i64* %305
; # (or (and (unify N1 (car X1) N2 (car X2)) (unify N1 (cdr X1) N2 (c...
; # (and (unify N1 (car X1) N2 (car X2)) (unify N1 (cdr X1) N2 (cdr X...
; # (car X1)
  %307 = inttoptr i64 %299 to i64*
  %308 = load i64, i64* %307
; # (car X2)
  %309 = inttoptr i64 %301 to i64*
  %310 = load i64, i64* %309
; # (unify N1 (car X1) N2 (car X2))
  %311 = call i1 @unify(i64 %298, i64 %308, i64 %300, i64 %310)
  br i1 %311, label %$49, label %$48
$49:
  %312 = phi i64 [%298, %$46] ; # N1
  %313 = phi i64 [%299, %$46] ; # X1
  %314 = phi i64 [%300, %$46] ; # N2
  %315 = phi i64 [%301, %$46] ; # X2
; # (cdr X1)
  %316 = inttoptr i64 %313 to i64*
  %317 = getelementptr i64, i64* %316, i32 1
  %318 = load i64, i64* %317
; # (cdr X2)
  %319 = inttoptr i64 %315 to i64*
  %320 = getelementptr i64, i64* %319, i32 1
  %321 = load i64, i64* %320
; # (unify N1 (cdr X1) N2 (cdr X2))
  %322 = call i1 @unify(i64 %312, i64 %318, i64 %314, i64 %321)
  br label %$48
$48:
  %323 = phi i64 [%298, %$46], [%312, %$49] ; # N1
  %324 = phi i64 [%299, %$46], [%313, %$49] ; # X1
  %325 = phi i64 [%300, %$46], [%314, %$49] ; # N2
  %326 = phi i64 [%301, %$46], [%315, %$49] ; # X2
  %327 = phi i1 [0, %$46], [%322, %$49] ; # ->
  br i1 %327, label %$47, label %$50
$50:
  %328 = phi i64 [%323, %$48] ; # N1
  %329 = phi i64 [%324, %$48] ; # X1
  %330 = phi i64 [%325, %$48] ; # N2
  %331 = phi i64 [%326, %$48] ; # X2
; # (set Penv Env)
  %332 = inttoptr i64 %4 to i64*
  store i64 %306, i64* %332
  br label %$47
$47:
  %333 = phi i64 [%323, %$48], [%328, %$50] ; # N1
  %334 = phi i64 [%324, %$48], [%329, %$50] ; # X1
  %335 = phi i64 [%325, %$48], [%330, %$50] ; # N2
  %336 = phi i64 [%326, %$48], [%331, %$50] ; # X2
  %337 = phi i1 [1, %$48], [0, %$50] ; # ->
  br label %$24
$24:
  %338 = phi i64 [%200, %$28], [%236, %$34], [%272, %$40], [%293, %$44], [%333, %$47] ; # N1
  %339 = phi i64 [%201, %$28], [%237, %$34], [%273, %$40], [%294, %$44], [%334, %$47] ; # X1
  %340 = phi i64 [%202, %$28], [%238, %$34], [%274, %$40], [%295, %$44], [%335, %$47] ; # N2
  %341 = phi i64 [%203, %$28], [%239, %$34], [%275, %$40], [%296, %$44], [%336, %$47] ; # X2
  %342 = phi i1 [1, %$28], [1, %$34], [1, %$40], [%297, %$44], [%337, %$47] ; # ->
  ret i1 %342
}

define i64 @lup(i64, i64) align 8 {
$1:
; # (let Penv (val $Penv) (: 1 (when (and (symb? X) (== (firstByte X)...
; # (val $Penv)
  %2 = load i64, i64* @$Penv
; # (: 1 (when (and (symb? X) (== (firstByte X) (char "@"))) (let V (...
  br label %$-1
$-1:
  %3 = phi i64 [%0, %$1], [%55, %$11] ; # N
  %4 = phi i64 [%1, %$1], [%58, %$11] ; # X
; # (when (and (symb? X) (== (firstByte X) (char "@"))) (let V (val P...
; # (and (symb? X) (== (firstByte X) (char "@")))
; # (symb? X)
  %5 = xor i64 %4, 8
  %6 = and i64 %5, 14
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %$3, label %$2
$3:
  %8 = phi i64 [%3, %$-1] ; # N
  %9 = phi i64 [%4, %$-1] ; # X
; # (firstByte X)
  %10 = call i8 @firstByte(i64 %9)
; # (== (firstByte X) (char "@"))
  %11 = icmp eq i8 %10, 64
  br label %$2
$2:
  %12 = phi i64 [%3, %$-1], [%8, %$3] ; # N
  %13 = phi i64 [%4, %$-1], [%9, %$3] ; # X
  %14 = phi i1 [0, %$-1], [%11, %$3] ; # ->
  br i1 %14, label %$4, label %$5
$4:
  %15 = phi i64 [%12, %$2] ; # N
  %16 = phi i64 [%13, %$2] ; # X
; # (let V (val Penv) (while (pair (car V)) (let (Y @ Z (car Y)) (whe...
; # (val Penv)
  %17 = inttoptr i64 %2 to i64*
  %18 = load i64, i64* %17
; # (while (pair (car V)) (let (Y @ Z (car Y)) (when (and (== N (car ...
  br label %$6
$6:
  %19 = phi i64 [%15, %$4], [%59, %$12] ; # N
  %20 = phi i64 [%16, %$4], [%60, %$12] ; # X
  %21 = phi i64 [%18, %$4], [%65, %$12] ; # V
; # (car V)
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
; # (pair (car V))
  %24 = and i64 %23, 15
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %$7, label %$8
$7:
  %26 = phi i64 [%19, %$6] ; # N
  %27 = phi i64 [%20, %$6] ; # X
  %28 = phi i64 [%21, %$6] ; # V
; # (let (Y @ Z (car Y)) (when (and (== N (car Z)) (== X (cdr Z))) (s...
; # (car Y)
  %29 = inttoptr i64 %23 to i64*
  %30 = load i64, i64* %29
; # (when (and (== N (car Z)) (== X (cdr Z))) (setq Z (cdr Y) N (car ...
; # (and (== N (car Z)) (== X (cdr Z)))
; # (car Z)
  %31 = inttoptr i64 %30 to i64*
  %32 = load i64, i64* %31
; # (== N (car Z))
  %33 = icmp eq i64 %26, %32
  br i1 %33, label %$10, label %$9
$10:
  %34 = phi i64 [%26, %$7] ; # N
  %35 = phi i64 [%27, %$7] ; # X
  %36 = phi i64 [%28, %$7] ; # V
  %37 = phi i64 [%30, %$7] ; # Z
; # (cdr Z)
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (== X (cdr Z))
  %41 = icmp eq i64 %35, %40
  br label %$9
$9:
  %42 = phi i64 [%26, %$7], [%34, %$10] ; # N
  %43 = phi i64 [%27, %$7], [%35, %$10] ; # X
  %44 = phi i64 [%28, %$7], [%36, %$10] ; # V
  %45 = phi i64 [%30, %$7], [%37, %$10] ; # Z
  %46 = phi i1 [0, %$7], [%41, %$10] ; # ->
  br i1 %46, label %$11, label %$12
$11:
  %47 = phi i64 [%42, %$9] ; # N
  %48 = phi i64 [%43, %$9] ; # X
  %49 = phi i64 [%44, %$9] ; # V
  %50 = phi i64 [%45, %$9] ; # Z
; # (cdr Y)
  %51 = inttoptr i64 %23 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
; # (car Z)
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (cdr Z)
  %56 = inttoptr i64 %53 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (goto 1)
  br label %$-1
$12:
  %59 = phi i64 [%42, %$9] ; # N
  %60 = phi i64 [%43, %$9] ; # X
  %61 = phi i64 [%44, %$9] ; # V
  %62 = phi i64 [%45, %$9] ; # Z
; # (shift V)
  %63 = inttoptr i64 %61 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  %65 = load i64, i64* %64
  br label %$6
$8:
  %66 = phi i64 [%19, %$6] ; # N
  %67 = phi i64 [%20, %$6] ; # X
  %68 = phi i64 [%21, %$6] ; # V
  br label %$5
$5:
  %69 = phi i64 [%12, %$2], [%66, %$8] ; # N
  %70 = phi i64 [%13, %$2], [%67, %$8] ; # X
; # (if (or (atom X) (cnt? (car X)) (== @ $Up)) X (stkChk 0) (let Z (...
; # (or (atom X) (cnt? (car X)) (== @ $Up))
; # (atom X)
  %71 = and i64 %70, 15
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$13, label %$14
$14:
  %73 = phi i64 [%69, %$5] ; # N
  %74 = phi i64 [%70, %$5] ; # X
; # (car X)
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
; # (cnt? (car X))
  %77 = and i64 %76, 2
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %$13, label %$15
$15:
  %79 = phi i64 [%73, %$14] ; # N
  %80 = phi i64 [%74, %$14] ; # X
; # (== @ $Up)
  %81 = icmp eq i64 %76, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64)
  br label %$13
$13:
  %82 = phi i64 [%69, %$5], [%73, %$14], [%79, %$15] ; # N
  %83 = phi i64 [%70, %$5], [%74, %$14], [%80, %$15] ; # X
  %84 = phi i1 [1, %$5], [1, %$14], [%81, %$15] ; # ->
  br i1 %84, label %$16, label %$17
$16:
  %85 = phi i64 [%82, %$13] ; # N
  %86 = phi i64 [%83, %$13] ; # X
  br label %$18
$17:
  %87 = phi i64 [%82, %$13] ; # N
  %88 = phi i64 [%83, %$13] ; # X
; # (stkChk 0)
  %89 = load i8*, i8** @$StkLimit
  %90 = call i8* @llvm.stacksave()
  %91 = icmp ugt i8* %89, %90
  br i1 %91, label %$19, label %$20
$19:
  call void @stkErr(i64 0)
  unreachable
$20:
; # (let Z (save (lup N (car X))) (cons Z (lup N (cdr X))))
; # (car X)
  %92 = inttoptr i64 %88 to i64*
  %93 = load i64, i64* %92
; # (lup N (car X))
  %94 = call i64 @lup(i64 %87, i64 %93)
; # (save (lup N (car X)))
  %95 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %96 = load i64, i64* %95
  %97 = alloca i64, i64 2, align 16
  %98 = ptrtoint i64* %97 to i64
  %99 = inttoptr i64 %98 to i64*
  store i64 %94, i64* %99
  %100 = add i64 %98, 8
  %101 = inttoptr i64 %100 to i64*
  store i64 %96, i64* %101
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %98, i64* %102
; # (cdr X)
  %103 = inttoptr i64 %88 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
; # (lup N (cdr X))
  %106 = call i64 @lup(i64 %87, i64 %105)
; # (cons Z (lup N (cdr X)))
  %107 = call i64 @cons(i64 %94, i64 %106)
; # (drop *Safe)
  %108 = inttoptr i64 %98 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  %110 = load i64, i64* %109
  %111 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %110, i64* %111
  br label %$18
$18:
  %112 = phi i64 [%85, %$16], [%87, %$20] ; # N
  %113 = phi i64 [%86, %$16], [%88, %$20] ; # X
  %114 = phi i64 [%86, %$16], [%107, %$20] ; # ->
  ret i64 %114
}

define i64 @lookup(i64, i64) align 8 {
$1:
; # (if (and (symb? (setq X (lup N X))) (== (firstByte X) (char "@"))...
; # (and (symb? (setq X (lup N X))) (== (firstByte X) (char "@")))
; # (lup N X)
  %2 = call i64 @lup(i64 %0, i64 %1)
; # (symb? (setq X (lup N X)))
  %3 = xor i64 %2, 8
  %4 = and i64 %3, 14
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$3, label %$2
$3:
  %6 = phi i64 [%2, %$1] ; # X
; # (firstByte X)
  %7 = call i8 @firstByte(i64 %6)
; # (== (firstByte X) (char "@"))
  %8 = icmp eq i8 %7, 64
  br label %$2
$2:
  %9 = phi i64 [%2, %$1], [%6, %$3] ; # X
  %10 = phi i1 [0, %$1], [%8, %$3] ; # ->
  br i1 %10, label %$4, label %$5
$4:
  %11 = phi i64 [%9, %$2] ; # X
  br label %$6
$5:
  %12 = phi i64 [%9, %$2] ; # X
  br label %$6
$6:
  %13 = phi i64 [%11, %$4], [%12, %$5] ; # X
  %14 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%12, %$5] ; # ->
  ret i64 %14
}

define i64 @uniFill(i64) align 8 {
$1:
; # (cond ((num? X) X) ((sym? X) (lup (car (val (val $Pnl))) X)) (T (...
; # (num? X)
  %1 = and i64 %0, 6
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  br label %$2
$3:
; # (sym? X)
  %3 = and i64 %0, 8
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$6, label %$5
$6:
; # (val $Pnl)
  %5 = load i64, i64* @$Pnl
; # (val (val $Pnl))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (car (val (val $Pnl)))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (lup (car (val (val $Pnl))) X)
  %10 = call i64 @lup(i64 %9, i64 %0)
  br label %$2
$5:
; # (stkChk 0)
  %11 = load i8*, i8** @$StkLimit
  %12 = call i8* @llvm.stacksave()
  %13 = icmp ugt i8* %11, %12
  br i1 %13, label %$7, label %$8
$7:
  call void @stkErr(i64 0)
  unreachable
$8:
; # (let Y (save (uniFill (car X))) (cons Y (uniFill (cdr X))))
; # (car X)
  %14 = inttoptr i64 %0 to i64*
  %15 = load i64, i64* %14
; # (uniFill (car X))
  %16 = call i64 @uniFill(i64 %15)
; # (save (uniFill (car X)))
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = add i64 %20, 8
  %23 = inttoptr i64 %22 to i64*
  store i64 %18, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %24
; # (cdr X)
  %25 = inttoptr i64 %0 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (uniFill (cdr X))
  %28 = call i64 @uniFill(i64 %27)
; # (cons Y (uniFill (cdr X)))
  %29 = call i64 @cons(i64 %16, i64 %28)
; # (drop *Safe)
  %30 = inttoptr i64 %20 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %33
  br label %$2
$2:
  %34 = phi i64 [%0, %$4], [%10, %$6], [%29, %$8] ; # ->
  ret i64 %34
}

define i64 @uniRun(i64) align 8 {
$1:
; # (let (P (val $Bind) Q P Z Prg Tos 0) (loop (until (atom (car Z)) ...
; # (val $Bind)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %2 = load i64, i64* %1
; # (loop (until (atom (car Z)) (let U Z (setq Z @) (set U Tos) (setq...
  br label %$2
$2:
  %3 = phi i64 [%0, %$1], [%261, %$13] ; # Prg
  %4 = phi i64 [%2, %$1], [%262, %$13] ; # P
  %5 = phi i64 [%0, %$1], [%263, %$13] ; # Z
  %6 = phi i64 [0, %$1], [%264, %$13] ; # Tos
; # (until (atom (car Z)) (let U Z (setq Z @) (set U Tos) (setq Tos U...
  br label %$3
$3:
  %7 = phi i64 [%3, %$2], [%15, %$4] ; # Prg
  %8 = phi i64 [%4, %$2], [%16, %$4] ; # P
  %9 = phi i64 [%5, %$2], [%12, %$4] ; # Z
  %10 = phi i64 [%6, %$2], [%17, %$4] ; # Tos
; # (car Z)
  %11 = inttoptr i64 %9 to i64*
  %12 = load i64, i64* %11
; # (atom (car Z))
  %13 = and i64 %12, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$5, label %$4
$4:
  %15 = phi i64 [%7, %$3] ; # Prg
  %16 = phi i64 [%8, %$3] ; # P
  %17 = phi i64 [%9, %$3] ; # Z
  %18 = phi i64 [%10, %$3] ; # Tos
; # (let U Z (setq Z @) (set U Tos) (setq Tos U))
; # (set U Tos)
  %19 = inttoptr i64 %17 to i64*
  store i64 %18, i64* %19
  br label %$3
$5:
  %20 = phi i64 [%7, %$3] ; # Prg
  %21 = phi i64 [%8, %$3] ; # P
  %22 = phi i64 [%9, %$3] ; # Z
  %23 = phi i64 [%10, %$3] ; # Tos
; # (let Y (car Z) (when (and (symb? Y) (<> -ZERO (val Y)) (== (first...
; # (car Z)
  %24 = inttoptr i64 %22 to i64*
  %25 = load i64, i64* %24
; # (when (and (symb? Y) (<> -ZERO (val Y)) (== (firstByte Y) (char "...
; # (and (symb? Y) (<> -ZERO (val Y)) (== (firstByte Y) (char "@")))
; # (symb? Y)
  %26 = xor i64 %25, 8
  %27 = and i64 %26, 14
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$7, label %$6
$7:
  %29 = phi i64 [%20, %$5] ; # Prg
  %30 = phi i64 [%21, %$5] ; # P
  %31 = phi i64 [%22, %$5] ; # Z
  %32 = phi i64 [%23, %$5] ; # Tos
; # (val Y)
  %33 = inttoptr i64 %25 to i64*
  %34 = load i64, i64* %33
; # (<> -ZERO (val Y))
  %35 = icmp ne i64 10, %34
  br i1 %35, label %$8, label %$6
$8:
  %36 = phi i64 [%29, %$7] ; # Prg
  %37 = phi i64 [%30, %$7] ; # P
  %38 = phi i64 [%31, %$7] ; # Z
  %39 = phi i64 [%32, %$7] ; # Tos
; # (firstByte Y)
  %40 = call i8 @firstByte(i64 %25)
; # (== (firstByte Y) (char "@"))
  %41 = icmp eq i8 %40, 64
  br label %$6
$6:
  %42 = phi i64 [%20, %$5], [%29, %$7], [%36, %$8] ; # Prg
  %43 = phi i64 [%21, %$5], [%30, %$7], [%37, %$8] ; # P
  %44 = phi i64 [%22, %$5], [%31, %$7], [%38, %$8] ; # Z
  %45 = phi i64 [%23, %$5], [%32, %$7], [%39, %$8] ; # Tos
  %46 = phi i1 [0, %$5], [0, %$7], [%41, %$8] ; # ->
  br i1 %46, label %$9, label %$10
$9:
  %47 = phi i64 [%42, %$6] ; # Prg
  %48 = phi i64 [%43, %$6] ; # P
  %49 = phi i64 [%44, %$6] ; # Z
  %50 = phi i64 [%45, %$6] ; # Tos
; # (set $Bind (setq P (push (val Y) Y P)))
; # (val Y)
  %51 = inttoptr i64 %25 to i64*
  %52 = load i64, i64* %51
; # (push (val Y) Y P)
  %53 = alloca i64, i64 3, align 16
  %54 = ptrtoint i64* %53 to i64
  %55 = inttoptr i64 %54 to i64*
  store i64 %52, i64* %55
  %56 = add i64 %54, 8
  %57 = inttoptr i64 %56 to i64*
  store i64 %25, i64* %57
  %58 = add i64 %54, 16
  %59 = inttoptr i64 %58 to i64*
  store i64 %48, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %54, i64* %60
; # (set Y -ZERO)
  %61 = inttoptr i64 %25 to i64*
  store i64 10, i64* %61
  br label %$10
$10:
  %62 = phi i64 [%42, %$6], [%47, %$9] ; # Prg
  %63 = phi i64 [%43, %$6], [%54, %$9] ; # P
  %64 = phi i64 [%44, %$6], [%49, %$9] ; # Z
  %65 = phi i64 [%45, %$6], [%50, %$9] ; # Tos
; # (loop (? (pair (cdr Z)) (let U Z (setq Z @) (set 2 U Tos) (setq T...
  br label %$11
$11:
  %66 = phi i64 [%62, %$10], [%256, %$40] ; # Prg
  %67 = phi i64 [%63, %$10], [%257, %$40] ; # P
  %68 = phi i64 [%64, %$10], [%258, %$40] ; # Z
  %69 = phi i64 [%65, %$10], [%259, %$40] ; # Tos
; # (? (pair (cdr Z)) (let U Z (setq Z @) (set 2 U Tos) (setq Tos (| ...
; # (cdr Z)
  %70 = inttoptr i64 %68 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
; # (pair (cdr Z))
  %73 = and i64 %72, 15
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %$14, label %$12
$14:
  %75 = phi i64 [%66, %$11] ; # Prg
  %76 = phi i64 [%67, %$11] ; # P
  %77 = phi i64 [%68, %$11] ; # Z
  %78 = phi i64 [%69, %$11] ; # Tos
; # (let U Z (setq Z @) (set 2 U Tos) (setq Tos (| U 8)))
; # (set 2 U Tos)
  %79 = inttoptr i64 %77 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  store i64 %78, i64* %80
; # (| U 8)
  %81 = or i64 %77, 8
  br label %$13
$12:
  %82 = phi i64 [%66, %$11] ; # Prg
  %83 = phi i64 [%67, %$11] ; # P
  %84 = phi i64 [%68, %$11] ; # Z
  %85 = phi i64 [%69, %$11] ; # Tos
; # (let Y @ (when (and (symb? Y) (<> -ZERO (val Y)) (== (firstByte Y...
; # (when (and (symb? Y) (<> -ZERO (val Y)) (== (firstByte Y) (char "...
; # (and (symb? Y) (<> -ZERO (val Y)) (== (firstByte Y) (char "@")))
; # (symb? Y)
  %86 = xor i64 %72, 8
  %87 = and i64 %86, 14
  %88 = icmp eq i64 %87, 0
  br i1 %88, label %$16, label %$15
$16:
  %89 = phi i64 [%82, %$12] ; # Prg
  %90 = phi i64 [%83, %$12] ; # P
  %91 = phi i64 [%84, %$12] ; # Z
  %92 = phi i64 [%85, %$12] ; # Tos
; # (val Y)
  %93 = inttoptr i64 %72 to i64*
  %94 = load i64, i64* %93
; # (<> -ZERO (val Y))
  %95 = icmp ne i64 10, %94
  br i1 %95, label %$17, label %$15
$17:
  %96 = phi i64 [%89, %$16] ; # Prg
  %97 = phi i64 [%90, %$16] ; # P
  %98 = phi i64 [%91, %$16] ; # Z
  %99 = phi i64 [%92, %$16] ; # Tos
; # (firstByte Y)
  %100 = call i8 @firstByte(i64 %72)
; # (== (firstByte Y) (char "@"))
  %101 = icmp eq i8 %100, 64
  br label %$15
$15:
  %102 = phi i64 [%82, %$12], [%89, %$16], [%96, %$17] ; # Prg
  %103 = phi i64 [%83, %$12], [%90, %$16], [%97, %$17] ; # P
  %104 = phi i64 [%84, %$12], [%91, %$16], [%98, %$17] ; # Z
  %105 = phi i64 [%85, %$12], [%92, %$16], [%99, %$17] ; # Tos
  %106 = phi i1 [0, %$12], [0, %$16], [%101, %$17] ; # ->
  br i1 %106, label %$18, label %$19
$18:
  %107 = phi i64 [%102, %$15] ; # Prg
  %108 = phi i64 [%103, %$15] ; # P
  %109 = phi i64 [%104, %$15] ; # Z
  %110 = phi i64 [%105, %$15] ; # Tos
; # (set $Bind (setq P (push (val Y) Y P)))
; # (val Y)
  %111 = inttoptr i64 %72 to i64*
  %112 = load i64, i64* %111
; # (push (val Y) Y P)
  %113 = alloca i64, i64 3, align 16
  %114 = ptrtoint i64* %113 to i64
  %115 = inttoptr i64 %114 to i64*
  store i64 %112, i64* %115
  %116 = add i64 %114, 8
  %117 = inttoptr i64 %116 to i64*
  store i64 %72, i64* %117
  %118 = add i64 %114, 16
  %119 = inttoptr i64 %118 to i64*
  store i64 %108, i64* %119
  %120 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %114, i64* %120
; # (set Y -ZERO)
  %121 = inttoptr i64 %72 to i64*
  store i64 10, i64* %121
  br label %$19
$19:
  %122 = phi i64 [%102, %$15], [%107, %$18] ; # Prg
  %123 = phi i64 [%103, %$15], [%114, %$18] ; # P
  %124 = phi i64 [%104, %$15], [%109, %$18] ; # Z
  %125 = phi i64 [%105, %$15], [%110, %$18] ; # Tos
; # (loop (unless Tos (let (X P N (car (val (val $Pnl)))) (until (== ...
  br label %$20
$20:
  %126 = phi i64 [%122, %$19], [%246, %$39] ; # Prg
  %127 = phi i64 [%123, %$19], [%247, %$39] ; # P
  %128 = phi i64 [%124, %$19], [%250, %$39] ; # Z
  %129 = phi i64 [%125, %$19], [%253, %$39] ; # Tos
; # (unless Tos (let (X P N (car (val (val $Pnl)))) (until (== Q X) (...
  %130 = icmp ne i64 %129, 0
  br i1 %130, label %$22, label %$21
$21:
  %131 = phi i64 [%126, %$20] ; # Prg
  %132 = phi i64 [%127, %$20] ; # P
  %133 = phi i64 [%128, %$20] ; # Z
  %134 = phi i64 [%129, %$20] ; # Tos
; # (let (X P N (car (val (val $Pnl)))) (until (== Q X) (let Y (val 2...
; # (val $Pnl)
  %135 = load i64, i64* @$Pnl
; # (val (val $Pnl))
  %136 = inttoptr i64 %135 to i64*
  %137 = load i64, i64* %136
; # (car (val (val $Pnl)))
  %138 = inttoptr i64 %137 to i64*
  %139 = load i64, i64* %138
; # (until (== Q X) (let Y (val 2 X) (set Y (lookup N Y))) (setq X (v...
  br label %$23
$23:
  %140 = phi i64 [%131, %$21], [%146, %$24] ; # Prg
  %141 = phi i64 [%132, %$21], [%147, %$24] ; # P
  %142 = phi i64 [%133, %$21], [%148, %$24] ; # Z
  %143 = phi i64 [%134, %$21], [%149, %$24] ; # Tos
  %144 = phi i64 [%132, %$21], [%158, %$24] ; # X
; # (== Q X)
  %145 = icmp eq i64 %2, %144
  br i1 %145, label %$25, label %$24
$24:
  %146 = phi i64 [%140, %$23] ; # Prg
  %147 = phi i64 [%141, %$23] ; # P
  %148 = phi i64 [%142, %$23] ; # Z
  %149 = phi i64 [%143, %$23] ; # Tos
  %150 = phi i64 [%144, %$23] ; # X
; # (let Y (val 2 X) (set Y (lookup N Y)))
; # (val 2 X)
  %151 = inttoptr i64 %150 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
; # (set Y (lookup N Y))
; # (lookup N Y)
  %154 = call i64 @lookup(i64 %139, i64 %153)
  %155 = inttoptr i64 %153 to i64*
  store i64 %154, i64* %155
; # (val 3 X)
  %156 = inttoptr i64 %150 to i64*
  %157 = getelementptr i64, i64* %156, i32 2
  %158 = load i64, i64* %157
  br label %$23
$25:
  %159 = phi i64 [%140, %$23] ; # Prg
  %160 = phi i64 [%141, %$23] ; # P
  %161 = phi i64 [%142, %$23] ; # Z
  %162 = phi i64 [%143, %$23] ; # Tos
  %163 = phi i64 [%144, %$23] ; # X
; # (loop (let X (++ Prg) (when (atom Prg) (setq X (eval X)) (until (...
  br label %$26
$26:
  %164 = phi i64 [%159, %$25], [%227, %$37] ; # Prg
  %165 = phi i64 [%160, %$25], [%228, %$37] ; # P
  %166 = phi i64 [%161, %$25], [%229, %$37] ; # Z
  %167 = phi i64 [%162, %$25], [%230, %$37] ; # Tos
; # (let X (++ Prg) (when (atom Prg) (setq X (eval X)) (until (== Q P...
; # (++ Prg)
  %168 = inttoptr i64 %164 to i64*
  %169 = load i64, i64* %168
  %170 = getelementptr i64, i64* %168, i32 1
  %171 = load i64, i64* %170
; # (when (atom Prg) (setq X (eval X)) (until (== Q P) (set (val 2 P)...
; # (atom Prg)
  %172 = and i64 %171, 15
  %173 = icmp ne i64 %172, 0
  br i1 %173, label %$27, label %$28
$27:
  %174 = phi i64 [%171, %$26] ; # Prg
  %175 = phi i64 [%165, %$26] ; # P
  %176 = phi i64 [%166, %$26] ; # Z
  %177 = phi i64 [%167, %$26] ; # Tos
  %178 = phi i64 [%169, %$26] ; # X
; # (eval X)
  %179 = and i64 %178, 6
  %180 = icmp ne i64 %179, 0
  br i1 %180, label %$31, label %$30
$31:
  br label %$29
$30:
  %181 = and i64 %178, 8
  %182 = icmp ne i64 %181, 0
  br i1 %182, label %$33, label %$32
$33:
  %183 = inttoptr i64 %178 to i64*
  %184 = load i64, i64* %183
  br label %$29
$32:
  %185 = call i64 @evList(i64 %178)
  br label %$29
$29:
  %186 = phi i64 [%178, %$31], [%184, %$33], [%185, %$32] ; # ->
; # (until (== Q P) (set (val 2 P) (val P)) (setq P (val 3 P)))
  br label %$34
$34:
  %187 = phi i64 [%174, %$29], [%193, %$35] ; # Prg
  %188 = phi i64 [%175, %$29], [%206, %$35] ; # P
  %189 = phi i64 [%176, %$29], [%195, %$35] ; # Z
  %190 = phi i64 [%177, %$29], [%196, %$35] ; # Tos
  %191 = phi i64 [%186, %$29], [%197, %$35] ; # X
; # (== Q P)
  %192 = icmp eq i64 %2, %188
  br i1 %192, label %$36, label %$35
$35:
  %193 = phi i64 [%187, %$34] ; # Prg
  %194 = phi i64 [%188, %$34] ; # P
  %195 = phi i64 [%189, %$34] ; # Z
  %196 = phi i64 [%190, %$34] ; # Tos
  %197 = phi i64 [%191, %$34] ; # X
; # (set (val 2 P) (val P))
; # (val 2 P)
  %198 = inttoptr i64 %194 to i64*
  %199 = getelementptr i64, i64* %198, i32 1
  %200 = load i64, i64* %199
; # (val P)
  %201 = inttoptr i64 %194 to i64*
  %202 = load i64, i64* %201
  %203 = inttoptr i64 %200 to i64*
  store i64 %202, i64* %203
; # (val 3 P)
  %204 = inttoptr i64 %194 to i64*
  %205 = getelementptr i64, i64* %204, i32 2
  %206 = load i64, i64* %205
  br label %$34
$36:
  %207 = phi i64 [%187, %$34] ; # Prg
  %208 = phi i64 [%188, %$34] ; # P
  %209 = phi i64 [%189, %$34] ; # Z
  %210 = phi i64 [%190, %$34] ; # Tos
  %211 = phi i64 [%191, %$34] ; # X
; # (set $Bind P)
  %212 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %208, i64* %212
; # (ret X)
  ret i64 %211
$28:
  %213 = phi i64 [%171, %$26] ; # Prg
  %214 = phi i64 [%165, %$26] ; # P
  %215 = phi i64 [%166, %$26] ; # Z
  %216 = phi i64 [%167, %$26] ; # Tos
  %217 = phi i64 [%169, %$26] ; # X
; # (and (pair X) (evList X))
; # (pair X)
  %218 = and i64 %217, 15
  %219 = icmp eq i64 %218, 0
  br i1 %219, label %$38, label %$37
$38:
  %220 = phi i64 [%213, %$28] ; # Prg
  %221 = phi i64 [%214, %$28] ; # P
  %222 = phi i64 [%215, %$28] ; # Z
  %223 = phi i64 [%216, %$28] ; # Tos
  %224 = phi i64 [%217, %$28] ; # X
; # (evList X)
  %225 = call i64 @evList(i64 %224)
  %226 = icmp ne i64 %225, 0
  br label %$37
$37:
  %227 = phi i64 [%213, %$28], [%220, %$38] ; # Prg
  %228 = phi i64 [%214, %$28], [%221, %$38] ; # P
  %229 = phi i64 [%215, %$28], [%222, %$38] ; # Z
  %230 = phi i64 [%216, %$28], [%223, %$38] ; # Tos
  %231 = phi i64 [%217, %$28], [%224, %$38] ; # X
  %232 = phi i1 [0, %$28], [%226, %$38] ; # ->
  br label %$26
$22:
  %233 = phi i64 [%126, %$20] ; # Prg
  %234 = phi i64 [%127, %$20] ; # P
  %235 = phi i64 [%128, %$20] ; # Z
  %236 = phi i64 [%129, %$20] ; # Tos
; # (? (=0 (& Tos 8)) (let U Tos (setq Tos (car U)) (set U Z) (setq Z...
; # (& Tos 8)
  %237 = and i64 %236, 8
; # (=0 (& Tos 8))
  %238 = icmp eq i64 %237, 0
  br i1 %238, label %$41, label %$39
$41:
  %239 = phi i64 [%233, %$22] ; # Prg
  %240 = phi i64 [%234, %$22] ; # P
  %241 = phi i64 [%235, %$22] ; # Z
  %242 = phi i64 [%236, %$22] ; # Tos
; # (let U Tos (setq Tos (car U)) (set U Z) (setq Z U))
; # (car U)
  %243 = inttoptr i64 %242 to i64*
  %244 = load i64, i64* %243
; # (set U Z)
  %245 = inttoptr i64 %242 to i64*
  store i64 %241, i64* %245
  br label %$40
$39:
  %246 = phi i64 [%233, %$22] ; # Prg
  %247 = phi i64 [%234, %$22] ; # P
  %248 = phi i64 [%235, %$22] ; # Z
  %249 = phi i64 [%236, %$22] ; # Tos
; # (let U (& Tos -9) (setq Tos (cdr U)) (set 2 U Z) (setq Z U))
; # (& Tos -9)
  %250 = and i64 %249, -9
; # (cdr U)
  %251 = inttoptr i64 %250 to i64*
  %252 = getelementptr i64, i64* %251, i32 1
  %253 = load i64, i64* %252
; # (set 2 U Z)
  %254 = inttoptr i64 %250 to i64*
  %255 = getelementptr i64, i64* %254, i32 1
  store i64 %248, i64* %255
  br label %$20
$40:
  %256 = phi i64 [%239, %$41] ; # Prg
  %257 = phi i64 [%240, %$41] ; # P
  %258 = phi i64 [%242, %$41] ; # Z
  %259 = phi i64 [%244, %$41] ; # Tos
  %260 = phi i64 [%242, %$41] ; # ->
  br label %$11
$13:
  %261 = phi i64 [%75, %$14] ; # Prg
  %262 = phi i64 [%76, %$14] ; # P
  %263 = phi i64 [%72, %$14] ; # Z
  %264 = phi i64 [%81, %$14] ; # Tos
  %265 = phi i64 [%81, %$14] ; # ->
  br label %$2
}

define i64 @_prove(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (atom (eval (car X))) $Nil (let (Q (save @) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom (eval (car X))) $Nil (let (Q (save @) Dbg (if (nil? (ev...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (atom (eval (car X)))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %17 = phi i64 [%3, %$2] ; # X
; # (let (Q (save @) Dbg (if (nil? (eval (cadr X))) 0 (save @)) P (pr...
; # (save @)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %13, i64* %22
  %23 = add i64 %21, 8
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %25
; # (if (nil? (eval (cadr X))) 0 (save @))
; # (cadr X)
  %26 = inttoptr i64 %17 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (eval (cadr X))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$12, label %$11
$12:
  br label %$10
$11:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$14, label %$13
$14:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$10
$13:
  %37 = call i64 @evList(i64 %30)
  br label %$10
$10:
  %38 = phi i64 [%30, %$12], [%36, %$14], [%37, %$13] ; # ->
; # (nil? (eval (cadr X)))
  %39 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %39, label %$15, label %$16
$15:
  %40 = phi i64 [%17, %$10] ; # X
  br label %$17
$16:
  %41 = phi i64 [%17, %$10] ; # X
; # (save @)
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %43 = load i64, i64* %42
  %44 = alloca i64, i64 2, align 16
  %45 = ptrtoint i64* %44 to i64
  %46 = inttoptr i64 %45 to i64*
  store i64 %38, i64* %46
  %47 = add i64 %45, 8
  %48 = inttoptr i64 %47 to i64*
  store i64 %43, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %49
  br label %$17
$17:
  %50 = phi i64 [%40, %$15], [%41, %$16] ; # X
  %51 = phi i64 [0, %$15], [%38, %$16] ; # ->
; # (prog1 (caar Q) (set Q (cdar Q)))
; # (caar Q)
  %52 = inttoptr i64 %13 to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (set Q (cdar Q))
; # (cdar Q)
  %56 = inttoptr i64 %13 to i64*
  %57 = load i64, i64* %56
  %58 = inttoptr i64 %57 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %13 to i64*
  store i64 %60, i64* %61
; # (++ P)
  %62 = inttoptr i64 %55 to i64*
  %63 = load i64, i64* %62
  %64 = getelementptr i64, i64* %62, i32 1
  %65 = load i64, i64* %64
; # (++ P)
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
  %68 = getelementptr i64, i64* %66, i32 1
  %69 = load i64, i64* %68
; # (push (++ P) NIL)
  %70 = alloca i64, i64 2, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = inttoptr i64 %71 to i64*
  store i64 %67, i64* %72
; # (link (push (++ P) NIL))
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %74 = load i64, i64* %73
  %75 = inttoptr i64 %71 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %74, i64* %76
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %77
; # (++ P)
  %78 = inttoptr i64 %69 to i64*
  %79 = load i64, i64* %78
  %80 = getelementptr i64, i64* %78, i32 1
  %81 = load i64, i64* %80
; # (push (++ P) NIL)
  %82 = alloca i64, i64 2, align 16
  %83 = ptrtoint i64* %82 to i64
  %84 = inttoptr i64 %83 to i64*
  store i64 %79, i64* %84
; # (link (push (++ P) NIL))
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %86 = load i64, i64* %85
  %87 = inttoptr i64 %83 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  store i64 %86, i64* %88
  %89 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %89
; # (++ P)
  %90 = inttoptr i64 %81 to i64*
  %91 = load i64, i64* %90
  %92 = getelementptr i64, i64* %90, i32 1
  %93 = load i64, i64* %92
; # (push (++ P) NIL)
  %94 = alloca i64, i64 2, align 16
  %95 = ptrtoint i64* %94 to i64
  %96 = inttoptr i64 %95 to i64*
  store i64 %91, i64* %96
; # (link (push (++ P) NIL))
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %98 = load i64, i64* %97
  %99 = inttoptr i64 %95 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  store i64 %98, i64* %100
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %95, i64* %101
; # (++ P)
  %102 = inttoptr i64 %93 to i64*
  %103 = load i64, i64* %102
  %104 = getelementptr i64, i64* %102, i32 1
  %105 = load i64, i64* %104
; # (push (++ P) NIL)
  %106 = alloca i64, i64 2, align 16
  %107 = ptrtoint i64* %106 to i64
  %108 = inttoptr i64 %107 to i64*
  store i64 %103, i64* %108
; # (link (push (++ P) NIL))
  %109 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %110 = load i64, i64* %109
  %111 = inttoptr i64 %107 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  store i64 %110, i64* %112
  %113 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %113
; # (push P NIL)
  %114 = alloca i64, i64 2, align 16
  %115 = ptrtoint i64* %114 to i64
  %116 = inttoptr i64 %115 to i64*
  store i64 %105, i64* %116
; # (link (push P NIL))
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %118 = load i64, i64* %117
  %119 = inttoptr i64 %115 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  store i64 %118, i64* %120
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %115, i64* %121
; # (push $Nil NIL)
  %122 = alloca i64, i64 2, align 16
  %123 = ptrtoint i64* %122 to i64
  %124 = inttoptr i64 %123 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %124
; # (link (push $Nil NIL))
  %125 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %126 = load i64, i64* %125
  %127 = inttoptr i64 %123 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  store i64 %126, i64* %128
  %129 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %123, i64* %129
; # (val $At)
  %130 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %131 = load i64, i64* %130
; # (save (val $At))
  %132 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %133 = load i64, i64* %132
  %134 = alloca i64, i64 2, align 16
  %135 = ptrtoint i64* %134 to i64
  %136 = inttoptr i64 %135 to i64*
  store i64 %131, i64* %136
  %137 = add i64 %135, 8
  %138 = inttoptr i64 %137 to i64*
  store i64 %133, i64* %138
  %139 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %135, i64* %139
; # (val $Penv)
  %140 = load i64, i64* @$Penv
; # (val $Pnl)
  %141 = load i64, i64* @$Pnl
; # (set $Penv Env $Pnl Nl)
  store i64 %115, i64* @$Penv
  store i64 %71, i64* @$Pnl
; # (while (or (pair (val Tp1)) (pair (val Tp2))) (sigChk Exe) (cond ...
  br label %$18
$18:
  %142 = phi i64 [%50, %$17], [%649, %$25] ; # X
  %143 = phi i64 [%105, %$17], [%650, %$25] ; # P
  %144 = phi i64 [%63, %$17], [%651, %$25] ; # N
; # (or (pair (val Tp1)) (pair (val Tp2)))
; # (val Tp1)
  %145 = inttoptr i64 %95 to i64*
  %146 = load i64, i64* %145
; # (pair (val Tp1))
  %147 = and i64 %146, 15
  %148 = icmp eq i64 %147, 0
  br i1 %148, label %$19, label %$20
$20:
  %149 = phi i64 [%142, %$18] ; # X
  %150 = phi i64 [%143, %$18] ; # P
  %151 = phi i64 [%144, %$18] ; # N
; # (val Tp2)
  %152 = inttoptr i64 %107 to i64*
  %153 = load i64, i64* %152
; # (pair (val Tp2))
  %154 = and i64 %153, 15
  %155 = icmp eq i64 %154, 0
  br label %$19
$19:
  %156 = phi i64 [%142, %$18], [%149, %$20] ; # X
  %157 = phi i64 [%143, %$18], [%150, %$20] ; # P
  %158 = phi i64 [%144, %$18], [%151, %$20] ; # N
  %159 = phi i1 [1, %$18], [%155, %$20] ; # ->
  br i1 %159, label %$21, label %$22
$21:
  %160 = phi i64 [%156, %$19] ; # X
  %161 = phi i64 [%157, %$19] ; # P
  %162 = phi i64 [%158, %$19] ; # N
; # (sigChk Exe)
  %163 = load i32, i32* bitcast ([16 x i32]* @$Signal to i32*)
  %164 = icmp ne i32 %163, 0
  br i1 %164, label %$23, label %$24
$23:
  call void @sighandler(i64 %0)
  br label %$24
$24:
; # (cond ((pair (val Alt)) (set E (val Env)) (ifn (unify (car (val N...
; # (val Alt)
  %165 = inttoptr i64 %83 to i64*
  %166 = load i64, i64* %165
; # (pair (val Alt))
  %167 = and i64 %166, 15
  %168 = icmp eq i64 %167, 0
  br i1 %168, label %$27, label %$26
$27:
  %169 = phi i64 [%160, %$24] ; # X
  %170 = phi i64 [%161, %$24] ; # P
  %171 = phi i64 [%162, %$24] ; # N
; # (set E (val Env))
; # (val Env)
  %172 = inttoptr i64 %115 to i64*
  %173 = load i64, i64* %172
  %174 = inttoptr i64 %123 to i64*
  store i64 %173, i64* %174
; # (ifn (unify (car (val Nl)) (cdar (val Tp1)) N (caar (val Alt))) (...
; # (val Nl)
  %175 = inttoptr i64 %71 to i64*
  %176 = load i64, i64* %175
; # (car (val Nl))
  %177 = inttoptr i64 %176 to i64*
  %178 = load i64, i64* %177
; # (val Tp1)
  %179 = inttoptr i64 %95 to i64*
  %180 = load i64, i64* %179
; # (cdar (val Tp1))
  %181 = inttoptr i64 %180 to i64*
  %182 = load i64, i64* %181
  %183 = inttoptr i64 %182 to i64*
  %184 = getelementptr i64, i64* %183, i32 1
  %185 = load i64, i64* %184
; # (val Alt)
  %186 = inttoptr i64 %83 to i64*
  %187 = load i64, i64* %186
; # (caar (val Alt))
  %188 = inttoptr i64 %187 to i64*
  %189 = load i64, i64* %188
  %190 = inttoptr i64 %189 to i64*
  %191 = load i64, i64* %190
; # (unify (car (val Nl)) (cdar (val Tp1)) N (caar (val Alt)))
  %192 = call i1 @unify(i64 %178, i64 %185, i64 %171, i64 %191)
  br i1 %192, label %$29, label %$28
$28:
  %193 = phi i64 [%169, %$27] ; # X
  %194 = phi i64 [%170, %$27] ; # P
  %195 = phi i64 [%171, %$27] ; # N
; # (when (atom (set Alt (cdr (val Alt)))) (setq P (caar Q)) (set Q (...
; # (set Alt (cdr (val Alt)))
; # (val Alt)
  %196 = inttoptr i64 %83 to i64*
  %197 = load i64, i64* %196
; # (cdr (val Alt))
  %198 = inttoptr i64 %197 to i64*
  %199 = getelementptr i64, i64* %198, i32 1
  %200 = load i64, i64* %199
  %201 = inttoptr i64 %83 to i64*
  store i64 %200, i64* %201
; # (atom (set Alt (cdr (val Alt))))
  %202 = and i64 %200, 15
  %203 = icmp ne i64 %202, 0
  br i1 %203, label %$31, label %$32
$31:
  %204 = phi i64 [%193, %$28] ; # X
  %205 = phi i64 [%194, %$28] ; # P
  %206 = phi i64 [%195, %$28] ; # N
; # (caar Q)
  %207 = inttoptr i64 %13 to i64*
  %208 = load i64, i64* %207
  %209 = inttoptr i64 %208 to i64*
  %210 = load i64, i64* %209
; # (set Q (cdar Q))
; # (cdar Q)
  %211 = inttoptr i64 %13 to i64*
  %212 = load i64, i64* %211
  %213 = inttoptr i64 %212 to i64*
  %214 = getelementptr i64, i64* %213, i32 1
  %215 = load i64, i64* %214
  %216 = inttoptr i64 %13 to i64*
  store i64 %215, i64* %216
; # (++ P)
  %217 = inttoptr i64 %210 to i64*
  %218 = load i64, i64* %217
  %219 = getelementptr i64, i64* %217, i32 1
  %220 = load i64, i64* %219
; # (set Nl (++ P) Alt (++ P) Tp1 (++ P) Tp2 (++ P) Env P)
; # (++ P)
  %221 = inttoptr i64 %220 to i64*
  %222 = load i64, i64* %221
  %223 = getelementptr i64, i64* %221, i32 1
  %224 = load i64, i64* %223
  %225 = inttoptr i64 %71 to i64*
  store i64 %222, i64* %225
; # (++ P)
  %226 = inttoptr i64 %224 to i64*
  %227 = load i64, i64* %226
  %228 = getelementptr i64, i64* %226, i32 1
  %229 = load i64, i64* %228
  %230 = inttoptr i64 %83 to i64*
  store i64 %227, i64* %230
; # (++ P)
  %231 = inttoptr i64 %229 to i64*
  %232 = load i64, i64* %231
  %233 = getelementptr i64, i64* %231, i32 1
  %234 = load i64, i64* %233
  %235 = inttoptr i64 %95 to i64*
  store i64 %232, i64* %235
; # (++ P)
  %236 = inttoptr i64 %234 to i64*
  %237 = load i64, i64* %236
  %238 = getelementptr i64, i64* %236, i32 1
  %239 = load i64, i64* %238
  %240 = inttoptr i64 %107 to i64*
  store i64 %237, i64* %240
  %241 = inttoptr i64 %115 to i64*
  store i64 %239, i64* %241
  br label %$32
$32:
  %242 = phi i64 [%193, %$28], [%204, %$31] ; # X
  %243 = phi i64 [%194, %$28], [%239, %$31] ; # P
  %244 = phi i64 [%195, %$28], [%218, %$31] ; # N
  br label %$30
$29:
  %245 = phi i64 [%169, %$27] ; # X
  %246 = phi i64 [%170, %$27] ; # P
  %247 = phi i64 [%171, %$27] ; # N
; # (when Dbg (let Y (car (val Tp1)) (when (memq (car Y) Dbg) (let (L...
  %248 = icmp ne i64 %51, 0
  br i1 %248, label %$33, label %$34
$33:
  %249 = phi i64 [%245, %$29] ; # X
  %250 = phi i64 [%246, %$29] ; # P
  %251 = phi i64 [%247, %$29] ; # N
; # (let Y (car (val Tp1)) (when (memq (car Y) Dbg) (let (L (get (car...
; # (val Tp1)
  %252 = inttoptr i64 %95 to i64*
  %253 = load i64, i64* %252
; # (car (val Tp1))
  %254 = inttoptr i64 %253 to i64*
  %255 = load i64, i64* %254
; # (when (memq (car Y) Dbg) (let (L (get (car Y) $T) I 1) (until (eq...
; # (car Y)
  %256 = inttoptr i64 %255 to i64*
  %257 = load i64, i64* %256
; # (memq (car Y) Dbg)
  br label %$35
$35:
  %258 = phi i64 [%51, %$33], [%270, %$39] ; # L
  %259 = and i64 %258, 15
  %260 = icmp ne i64 %259, 0
  br i1 %260, label %$38, label %$36
$38:
  %261 = phi i64 [%258, %$35] ; # L
  br label %$37
$36:
  %262 = phi i64 [%258, %$35] ; # L
  %263 = inttoptr i64 %262 to i64*
  %264 = load i64, i64* %263
  %265 = icmp eq i64 %257, %264
  br i1 %265, label %$40, label %$39
$40:
  %266 = phi i64 [%262, %$36] ; # L
  br label %$37
$39:
  %267 = phi i64 [%262, %$36] ; # L
  %268 = inttoptr i64 %267 to i64*
  %269 = getelementptr i64, i64* %268, i32 1
  %270 = load i64, i64* %269
  br label %$35
$37:
  %271 = phi i64 [%261, %$38], [%266, %$40] ; # L
  %272 = phi i1 [0, %$38], [1, %$40] ; # ->
  br i1 %272, label %$41, label %$42
$41:
  %273 = phi i64 [%249, %$37] ; # X
  %274 = phi i64 [%250, %$37] ; # P
  %275 = phi i64 [%251, %$37] ; # N
; # (let (L (get (car Y) $T) I 1) (until (equal (car (val Alt)) (car ...
; # (car Y)
  %276 = inttoptr i64 %255 to i64*
  %277 = load i64, i64* %276
; # (get (car Y) $T)
  %278 = call i64 @get(i64 %277, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64))
; # (until (equal (car (val Alt)) (car L)) (inc 'I) (shift L))
  br label %$43
$43:
  %279 = phi i64 [%273, %$41], [%291, %$44] ; # X
  %280 = phi i64 [%274, %$41], [%292, %$44] ; # P
  %281 = phi i64 [%275, %$41], [%293, %$44] ; # N
  %282 = phi i64 [%278, %$41], [%299, %$44] ; # L
  %283 = phi i64 [1, %$41], [%296, %$44] ; # I
; # (val Alt)
  %284 = inttoptr i64 %83 to i64*
  %285 = load i64, i64* %284
; # (car (val Alt))
  %286 = inttoptr i64 %285 to i64*
  %287 = load i64, i64* %286
; # (car L)
  %288 = inttoptr i64 %282 to i64*
  %289 = load i64, i64* %288
; # (equal (car (val Alt)) (car L))
  %290 = call i1 @equal(i64 %287, i64 %289)
  br i1 %290, label %$45, label %$44
$44:
  %291 = phi i64 [%279, %$43] ; # X
  %292 = phi i64 [%280, %$43] ; # P
  %293 = phi i64 [%281, %$43] ; # N
  %294 = phi i64 [%282, %$43] ; # L
  %295 = phi i64 [%283, %$43] ; # I
; # (inc 'I)
  %296 = add i64 %295, 1
; # (shift L)
  %297 = inttoptr i64 %294 to i64*
  %298 = getelementptr i64, i64* %297, i32 1
  %299 = load i64, i64* %298
  br label %$43
$45:
  %300 = phi i64 [%279, %$43] ; # X
  %301 = phi i64 [%280, %$43] ; # P
  %302 = phi i64 [%281, %$43] ; # N
  %303 = phi i64 [%282, %$43] ; # L
  %304 = phi i64 [%283, %$43] ; # I
; # (outWord I)
  call void @outWord(i64 %304)
; # (space)
  call void @space()
; # (uniFill Y)
  %305 = call i64 @uniFill(i64 %255)
; # (print (uniFill Y))
  call void @print(i64 %305)
; # (newline)
  call void @newline()
  br label %$42
$42:
  %306 = phi i64 [%249, %$37], [%300, %$45] ; # X
  %307 = phi i64 [%250, %$37], [%301, %$45] ; # P
  %308 = phi i64 [%251, %$37], [%302, %$45] ; # N
  br label %$34
$34:
  %309 = phi i64 [%245, %$29], [%306, %$42] ; # X
  %310 = phi i64 [%246, %$29], [%307, %$42] ; # P
  %311 = phi i64 [%247, %$29], [%308, %$42] ; # N
; # (when (pair (cdr (val Alt))) (set Q (cons (cons N (cons (val Nl) ...
; # (val Alt)
  %312 = inttoptr i64 %83 to i64*
  %313 = load i64, i64* %312
; # (cdr (val Alt))
  %314 = inttoptr i64 %313 to i64*
  %315 = getelementptr i64, i64* %314, i32 1
  %316 = load i64, i64* %315
; # (pair (cdr (val Alt)))
  %317 = and i64 %316, 15
  %318 = icmp eq i64 %317, 0
  br i1 %318, label %$46, label %$47
$46:
  %319 = phi i64 [%309, %$34] ; # X
  %320 = phi i64 [%310, %$34] ; # P
  %321 = phi i64 [%311, %$34] ; # N
; # (set Q (cons (cons N (cons (val Nl) (cons @ (cons (val Tp1) (cons...
; # (val Nl)
  %322 = inttoptr i64 %71 to i64*
  %323 = load i64, i64* %322
; # (val Tp1)
  %324 = inttoptr i64 %95 to i64*
  %325 = load i64, i64* %324
; # (val Tp2)
  %326 = inttoptr i64 %107 to i64*
  %327 = load i64, i64* %326
; # (val E)
  %328 = inttoptr i64 %123 to i64*
  %329 = load i64, i64* %328
; # (cons (val Tp2) (val E))
  %330 = call i64 @cons(i64 %327, i64 %329)
; # (cons (val Tp1) (cons (val Tp2) (val E)))
  %331 = call i64 @cons(i64 %325, i64 %330)
; # (cons @ (cons (val Tp1) (cons (val Tp2) (val E))))
  %332 = call i64 @cons(i64 %316, i64 %331)
; # (cons (val Nl) (cons @ (cons (val Tp1) (cons (val Tp2) (val E))))...
  %333 = call i64 @cons(i64 %323, i64 %332)
; # (cons N (cons (val Nl) (cons @ (cons (val Tp1) (cons (val Tp2) (v...
  %334 = call i64 @cons(i64 %321, i64 %333)
; # (car Q)
  %335 = inttoptr i64 %13 to i64*
  %336 = load i64, i64* %335
; # (cons (cons N (cons (val Nl) (cons @ (cons (val Tp1) (cons (val T...
  %337 = call i64 @cons(i64 %334, i64 %336)
  %338 = inttoptr i64 %13 to i64*
  store i64 %337, i64* %338
  br label %$47
$47:
  %339 = phi i64 [%309, %$34], [%319, %$46] ; # X
  %340 = phi i64 [%310, %$34], [%320, %$46] ; # P
  %341 = phi i64 [%311, %$34], [%321, %$46] ; # N
; # (set Nl (cons N (val Nl)) Tp2 (cons (cdr (val Tp1)) (val Tp2)) Tp...
; # (val Nl)
  %342 = inttoptr i64 %71 to i64*
  %343 = load i64, i64* %342
; # (cons N (val Nl))
  %344 = call i64 @cons(i64 %341, i64 %343)
  %345 = inttoptr i64 %71 to i64*
  store i64 %344, i64* %345
; # (val Tp1)
  %346 = inttoptr i64 %95 to i64*
  %347 = load i64, i64* %346
; # (cdr (val Tp1))
  %348 = inttoptr i64 %347 to i64*
  %349 = getelementptr i64, i64* %348, i32 1
  %350 = load i64, i64* %349
; # (val Tp2)
  %351 = inttoptr i64 %107 to i64*
  %352 = load i64, i64* %351
; # (cons (cdr (val Tp1)) (val Tp2))
  %353 = call i64 @cons(i64 %350, i64 %352)
  %354 = inttoptr i64 %107 to i64*
  store i64 %353, i64* %354
; # (val Alt)
  %355 = inttoptr i64 %83 to i64*
  %356 = load i64, i64* %355
; # (cdar (val Alt))
  %357 = inttoptr i64 %356 to i64*
  %358 = load i64, i64* %357
  %359 = inttoptr i64 %358 to i64*
  %360 = getelementptr i64, i64* %359, i32 1
  %361 = load i64, i64* %360
  %362 = inttoptr i64 %95 to i64*
  store i64 %361, i64* %362
  %363 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %363
; # (inc 'N (hex "10"))
  %364 = add i64 %341, 16
  br label %$30
$30:
  %365 = phi i64 [%242, %$32], [%339, %$47] ; # X
  %366 = phi i64 [%243, %$32], [%340, %$47] ; # P
  %367 = phi i64 [%244, %$32], [%364, %$47] ; # N
  br label %$25
$26:
  %368 = phi i64 [%160, %$24] ; # X
  %369 = phi i64 [%161, %$24] ; # P
  %370 = phi i64 [%162, %$24] ; # N
; # (val Tp1)
  %371 = inttoptr i64 %95 to i64*
  %372 = load i64, i64* %371
; # (atom (setq X (val Tp1)))
  %373 = and i64 %372, 15
  %374 = icmp ne i64 %373, 0
  br i1 %374, label %$49, label %$48
$49:
  %375 = phi i64 [%372, %$26] ; # X
  %376 = phi i64 [%369, %$26] ; # P
  %377 = phi i64 [%370, %$26] ; # N
; # (set Tp1 (car (val Tp2)) Tp2 (cdr (val Tp2)) Nl (cdr (val Nl)))
; # (val Tp2)
  %378 = inttoptr i64 %107 to i64*
  %379 = load i64, i64* %378
; # (car (val Tp2))
  %380 = inttoptr i64 %379 to i64*
  %381 = load i64, i64* %380
  %382 = inttoptr i64 %95 to i64*
  store i64 %381, i64* %382
; # (val Tp2)
  %383 = inttoptr i64 %107 to i64*
  %384 = load i64, i64* %383
; # (cdr (val Tp2))
  %385 = inttoptr i64 %384 to i64*
  %386 = getelementptr i64, i64* %385, i32 1
  %387 = load i64, i64* %386
  %388 = inttoptr i64 %107 to i64*
  store i64 %387, i64* %388
; # (val Nl)
  %389 = inttoptr i64 %71 to i64*
  %390 = load i64, i64* %389
; # (cdr (val Nl))
  %391 = inttoptr i64 %390 to i64*
  %392 = getelementptr i64, i64* %391, i32 1
  %393 = load i64, i64* %392
  %394 = inttoptr i64 %71 to i64*
  store i64 %393, i64* %394
  br label %$25
$48:
  %395 = phi i64 [%372, %$26] ; # X
  %396 = phi i64 [%369, %$26] ; # P
  %397 = phi i64 [%370, %$26] ; # N
; # (car X)
  %398 = inttoptr i64 %395 to i64*
  %399 = load i64, i64* %398
; # (atom (car X))
  %400 = and i64 %399, 15
  %401 = icmp ne i64 %400, 0
  br i1 %401, label %$51, label %$50
$51:
  %402 = phi i64 [%395, %$48] ; # X
  %403 = phi i64 [%396, %$48] ; # P
  %404 = phi i64 [%397, %$48] ; # N
; # (while (and (pair (car Q)) (>= (caar @) (car (val Nl)))) (set Q (...
  br label %$52
$52:
  %405 = phi i64 [%402, %$51], [%428, %$55] ; # X
  %406 = phi i64 [%403, %$51], [%429, %$55] ; # P
  %407 = phi i64 [%404, %$51], [%430, %$55] ; # N
; # (and (pair (car Q)) (>= (caar @) (car (val Nl))))
; # (car Q)
  %408 = inttoptr i64 %13 to i64*
  %409 = load i64, i64* %408
; # (pair (car Q))
  %410 = and i64 %409, 15
  %411 = icmp eq i64 %410, 0
  br i1 %411, label %$54, label %$53
$54:
  %412 = phi i64 [%405, %$52] ; # X
  %413 = phi i64 [%406, %$52] ; # P
  %414 = phi i64 [%407, %$52] ; # N
; # (caar @)
  %415 = inttoptr i64 %409 to i64*
  %416 = load i64, i64* %415
  %417 = inttoptr i64 %416 to i64*
  %418 = load i64, i64* %417
; # (val Nl)
  %419 = inttoptr i64 %71 to i64*
  %420 = load i64, i64* %419
; # (car (val Nl))
  %421 = inttoptr i64 %420 to i64*
  %422 = load i64, i64* %421
; # (>= (caar @) (car (val Nl)))
  %423 = icmp uge i64 %418, %422
  br label %$53
$53:
  %424 = phi i64 [%405, %$52], [%412, %$54] ; # X
  %425 = phi i64 [%406, %$52], [%413, %$54] ; # P
  %426 = phi i64 [%407, %$52], [%414, %$54] ; # N
  %427 = phi i1 [0, %$52], [%423, %$54] ; # ->
  br i1 %427, label %$55, label %$56
$55:
  %428 = phi i64 [%424, %$53] ; # X
  %429 = phi i64 [%425, %$53] ; # P
  %430 = phi i64 [%426, %$53] ; # N
; # (set Q (cdar Q))
; # (cdar Q)
  %431 = inttoptr i64 %13 to i64*
  %432 = load i64, i64* %431
  %433 = inttoptr i64 %432 to i64*
  %434 = getelementptr i64, i64* %433, i32 1
  %435 = load i64, i64* %434
  %436 = inttoptr i64 %13 to i64*
  store i64 %435, i64* %436
  br label %$52
$56:
  %437 = phi i64 [%424, %$53] ; # X
  %438 = phi i64 [%425, %$53] ; # P
  %439 = phi i64 [%426, %$53] ; # N
; # (set Tp1 (cdr X))
; # (cdr X)
  %440 = inttoptr i64 %437 to i64*
  %441 = getelementptr i64, i64* %440, i32 1
  %442 = load i64, i64* %441
  %443 = inttoptr i64 %95 to i64*
  store i64 %442, i64* %443
  br label %$25
$50:
  %444 = phi i64 [%395, %$48] ; # X
  %445 = phi i64 [%396, %$48] ; # P
  %446 = phi i64 [%397, %$48] ; # N
; # (car @)
  %447 = inttoptr i64 %399 to i64*
  %448 = load i64, i64* %447
; # (cnt? (car @))
  %449 = and i64 %448, 2
  %450 = icmp ne i64 %449, 0
  br i1 %450, label %$58, label %$57
$58:
  %451 = phi i64 [%444, %$50] ; # X
  %452 = phi i64 [%445, %$50] ; # P
  %453 = phi i64 [%446, %$50] ; # N
; # (set E (uniRun (cdar X)))
; # (cdar X)
  %454 = inttoptr i64 %451 to i64*
  %455 = load i64, i64* %454
  %456 = inttoptr i64 %455 to i64*
  %457 = getelementptr i64, i64* %456, i32 1
  %458 = load i64, i64* %457
; # (uniRun (cdar X))
  %459 = call i64 @uniRun(i64 %458)
  %460 = inttoptr i64 %123 to i64*
  store i64 %459, i64* %460
; # (let (I (int (caar X)) Y (val Nl)) (while (gt0 (dec 'I)) (shift Y...
; # (caar X)
  %461 = inttoptr i64 %451 to i64*
  %462 = load i64, i64* %461
  %463 = inttoptr i64 %462 to i64*
  %464 = load i64, i64* %463
; # (int (caar X))
  %465 = lshr i64 %464, 4
; # (val Nl)
  %466 = inttoptr i64 %71 to i64*
  %467 = load i64, i64* %466
; # (while (gt0 (dec 'I)) (shift Y))
  br label %$59
$59:
  %468 = phi i64 [%451, %$58], [%475, %$60] ; # X
  %469 = phi i64 [%452, %$58], [%476, %$60] ; # P
  %470 = phi i64 [%453, %$58], [%477, %$60] ; # N
  %471 = phi i64 [%465, %$58], [%478, %$60] ; # I
  %472 = phi i64 [%467, %$58], [%482, %$60] ; # Y
; # (dec 'I)
  %473 = sub i64 %471, 1
; # (gt0 (dec 'I))
  %474 = icmp sgt i64 %473, 0
  br i1 %474, label %$60, label %$61
$60:
  %475 = phi i64 [%468, %$59] ; # X
  %476 = phi i64 [%469, %$59] ; # P
  %477 = phi i64 [%470, %$59] ; # N
  %478 = phi i64 [%473, %$59] ; # I
  %479 = phi i64 [%472, %$59] ; # Y
; # (shift Y)
  %480 = inttoptr i64 %479 to i64*
  %481 = getelementptr i64, i64* %480, i32 1
  %482 = load i64, i64* %481
  br label %$59
$61:
  %483 = phi i64 [%468, %$59] ; # X
  %484 = phi i64 [%469, %$59] ; # P
  %485 = phi i64 [%470, %$59] ; # N
  %486 = phi i64 [%473, %$59] ; # I
  %487 = phi i64 [%472, %$59] ; # Y
; # (set Nl (cons (car Y) (val Nl)) Tp2 (cons (cdr X) (val Tp2)) Tp1 ...
; # (car Y)
  %488 = inttoptr i64 %487 to i64*
  %489 = load i64, i64* %488
; # (val Nl)
  %490 = inttoptr i64 %71 to i64*
  %491 = load i64, i64* %490
; # (cons (car Y) (val Nl))
  %492 = call i64 @cons(i64 %489, i64 %491)
  %493 = inttoptr i64 %71 to i64*
  store i64 %492, i64* %493
; # (cdr X)
  %494 = inttoptr i64 %483 to i64*
  %495 = getelementptr i64, i64* %494, i32 1
  %496 = load i64, i64* %495
; # (val Tp2)
  %497 = inttoptr i64 %107 to i64*
  %498 = load i64, i64* %497
; # (cons (cdr X) (val Tp2))
  %499 = call i64 @cons(i64 %496, i64 %498)
  %500 = inttoptr i64 %107 to i64*
  store i64 %499, i64* %500
; # (val E)
  %501 = inttoptr i64 %123 to i64*
  %502 = load i64, i64* %501
  %503 = inttoptr i64 %95 to i64*
  store i64 %502, i64* %503
  br label %$25
$57:
  %504 = phi i64 [%444, %$50] ; # X
  %505 = phi i64 [%445, %$50] ; # P
  %506 = phi i64 [%446, %$50] ; # N
; # (== @ $Up)
  %507 = icmp eq i64 %448, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 728) to i64)
  br i1 %507, label %$63, label %$62
$63:
  %508 = phi i64 [%504, %$57] ; # X
  %509 = phi i64 [%505, %$57] ; # P
  %510 = phi i64 [%506, %$57] ; # N
; # (if (and (not (nil? (set E (uniRun (cddr (car X)))))) (unify (car...
; # (and (not (nil? (set E (uniRun (cddr (car X)))))) (unify (car (va...
; # (set E (uniRun (cddr (car X))))
; # (car X)
  %511 = inttoptr i64 %508 to i64*
  %512 = load i64, i64* %511
; # (cddr (car X))
  %513 = inttoptr i64 %512 to i64*
  %514 = getelementptr i64, i64* %513, i32 1
  %515 = load i64, i64* %514
  %516 = inttoptr i64 %515 to i64*
  %517 = getelementptr i64, i64* %516, i32 1
  %518 = load i64, i64* %517
; # (uniRun (cddr (car X)))
  %519 = call i64 @uniRun(i64 %518)
  %520 = inttoptr i64 %123 to i64*
  store i64 %519, i64* %520
; # (nil? (set E (uniRun (cddr (car X)))))
  %521 = icmp eq i64 %519, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (set E (uniRun (cddr (car X))))))
  %522 = icmp eq i1 %521, 0
  br i1 %522, label %$65, label %$64
$65:
  %523 = phi i64 [%508, %$63] ; # X
  %524 = phi i64 [%509, %$63] ; # P
  %525 = phi i64 [%510, %$63] ; # N
; # (val Nl)
  %526 = inttoptr i64 %71 to i64*
  %527 = load i64, i64* %526
; # (car (val Nl))
  %528 = inttoptr i64 %527 to i64*
  %529 = load i64, i64* %528
; # (car X)
  %530 = inttoptr i64 %523 to i64*
  %531 = load i64, i64* %530
; # (cadr (car X))
  %532 = inttoptr i64 %531 to i64*
  %533 = getelementptr i64, i64* %532, i32 1
  %534 = load i64, i64* %533
  %535 = inttoptr i64 %534 to i64*
  %536 = load i64, i64* %535
; # (val Nl)
  %537 = inttoptr i64 %71 to i64*
  %538 = load i64, i64* %537
; # (car (val Nl))
  %539 = inttoptr i64 %538 to i64*
  %540 = load i64, i64* %539
; # (val E)
  %541 = inttoptr i64 %123 to i64*
  %542 = load i64, i64* %541
; # (unify (car (val Nl)) (cadr (car X)) (car (val Nl)) (val E))
  %543 = call i1 @unify(i64 %529, i64 %536, i64 %540, i64 %542)
  br label %$64
$64:
  %544 = phi i64 [%508, %$63], [%523, %$65] ; # X
  %545 = phi i64 [%509, %$63], [%524, %$65] ; # P
  %546 = phi i64 [%510, %$63], [%525, %$65] ; # N
  %547 = phi i1 [0, %$63], [%543, %$65] ; # ->
  br i1 %547, label %$66, label %$67
$66:
  %548 = phi i64 [%544, %$64] ; # X
  %549 = phi i64 [%545, %$64] ; # P
  %550 = phi i64 [%546, %$64] ; # N
; # (set Tp1 (cdr X))
; # (cdr X)
  %551 = inttoptr i64 %548 to i64*
  %552 = getelementptr i64, i64* %551, i32 1
  %553 = load i64, i64* %552
  %554 = inttoptr i64 %95 to i64*
  store i64 %553, i64* %554
  br label %$68
$67:
  %555 = phi i64 [%544, %$64] ; # X
  %556 = phi i64 [%545, %$64] ; # P
  %557 = phi i64 [%546, %$64] ; # N
; # (caar Q)
  %558 = inttoptr i64 %13 to i64*
  %559 = load i64, i64* %558
  %560 = inttoptr i64 %559 to i64*
  %561 = load i64, i64* %560
; # (set Q (cdar Q))
; # (cdar Q)
  %562 = inttoptr i64 %13 to i64*
  %563 = load i64, i64* %562
  %564 = inttoptr i64 %563 to i64*
  %565 = getelementptr i64, i64* %564, i32 1
  %566 = load i64, i64* %565
  %567 = inttoptr i64 %13 to i64*
  store i64 %566, i64* %567
; # (++ P)
  %568 = inttoptr i64 %561 to i64*
  %569 = load i64, i64* %568
  %570 = getelementptr i64, i64* %568, i32 1
  %571 = load i64, i64* %570
; # (set Nl (++ P) Alt (++ P) Tp1 (++ P) Tp2 (++ P) Env P)
; # (++ P)
  %572 = inttoptr i64 %571 to i64*
  %573 = load i64, i64* %572
  %574 = getelementptr i64, i64* %572, i32 1
  %575 = load i64, i64* %574
  %576 = inttoptr i64 %71 to i64*
  store i64 %573, i64* %576
; # (++ P)
  %577 = inttoptr i64 %575 to i64*
  %578 = load i64, i64* %577
  %579 = getelementptr i64, i64* %577, i32 1
  %580 = load i64, i64* %579
  %581 = inttoptr i64 %83 to i64*
  store i64 %578, i64* %581
; # (++ P)
  %582 = inttoptr i64 %580 to i64*
  %583 = load i64, i64* %582
  %584 = getelementptr i64, i64* %582, i32 1
  %585 = load i64, i64* %584
  %586 = inttoptr i64 %95 to i64*
  store i64 %583, i64* %586
; # (++ P)
  %587 = inttoptr i64 %585 to i64*
  %588 = load i64, i64* %587
  %589 = getelementptr i64, i64* %587, i32 1
  %590 = load i64, i64* %589
  %591 = inttoptr i64 %107 to i64*
  store i64 %588, i64* %591
  %592 = inttoptr i64 %115 to i64*
  store i64 %590, i64* %592
  br label %$68
$68:
  %593 = phi i64 [%548, %$66], [%555, %$67] ; # X
  %594 = phi i64 [%549, %$66], [%590, %$67] ; # P
  %595 = phi i64 [%550, %$66], [%569, %$67] ; # N
  %596 = phi i64 [%553, %$66], [%590, %$67] ; # ->
  br label %$25
$62:
  %597 = phi i64 [%504, %$57] ; # X
  %598 = phi i64 [%505, %$57] ; # P
  %599 = phi i64 [%506, %$57] ; # N
; # (set Alt (get (caar X) $T))
; # (caar X)
  %600 = inttoptr i64 %597 to i64*
  %601 = load i64, i64* %600
  %602 = inttoptr i64 %601 to i64*
  %603 = load i64, i64* %602
; # (get (caar X) $T)
  %604 = call i64 @get(i64 %603, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64))
  %605 = inttoptr i64 %83 to i64*
  store i64 %604, i64* %605
; # (atom (set Alt (get (caar X) $T)))
  %606 = and i64 %604, 15
  %607 = icmp ne i64 %606, 0
  br i1 %607, label %$70, label %$69
$70:
  %608 = phi i64 [%597, %$62] ; # X
  %609 = phi i64 [%598, %$62] ; # P
  %610 = phi i64 [%599, %$62] ; # N
; # (caar Q)
  %611 = inttoptr i64 %13 to i64*
  %612 = load i64, i64* %611
  %613 = inttoptr i64 %612 to i64*
  %614 = load i64, i64* %613
; # (set Q (cdar Q))
; # (cdar Q)
  %615 = inttoptr i64 %13 to i64*
  %616 = load i64, i64* %615
  %617 = inttoptr i64 %616 to i64*
  %618 = getelementptr i64, i64* %617, i32 1
  %619 = load i64, i64* %618
  %620 = inttoptr i64 %13 to i64*
  store i64 %619, i64* %620
; # (++ P)
  %621 = inttoptr i64 %614 to i64*
  %622 = load i64, i64* %621
  %623 = getelementptr i64, i64* %621, i32 1
  %624 = load i64, i64* %623
; # (set Nl (++ P) Alt (++ P) Tp1 (++ P) Tp2 (++ P) Env P)
; # (++ P)
  %625 = inttoptr i64 %624 to i64*
  %626 = load i64, i64* %625
  %627 = getelementptr i64, i64* %625, i32 1
  %628 = load i64, i64* %627
  %629 = inttoptr i64 %71 to i64*
  store i64 %626, i64* %629
; # (++ P)
  %630 = inttoptr i64 %628 to i64*
  %631 = load i64, i64* %630
  %632 = getelementptr i64, i64* %630, i32 1
  %633 = load i64, i64* %632
  %634 = inttoptr i64 %83 to i64*
  store i64 %631, i64* %634
; # (++ P)
  %635 = inttoptr i64 %633 to i64*
  %636 = load i64, i64* %635
  %637 = getelementptr i64, i64* %635, i32 1
  %638 = load i64, i64* %637
  %639 = inttoptr i64 %95 to i64*
  store i64 %636, i64* %639
; # (++ P)
  %640 = inttoptr i64 %638 to i64*
  %641 = load i64, i64* %640
  %642 = getelementptr i64, i64* %640, i32 1
  %643 = load i64, i64* %642
  %644 = inttoptr i64 %107 to i64*
  store i64 %641, i64* %644
  %645 = inttoptr i64 %115 to i64*
  store i64 %643, i64* %645
  br label %$25
$69:
  %646 = phi i64 [%597, %$62] ; # X
  %647 = phi i64 [%598, %$62] ; # P
  %648 = phi i64 [%599, %$62] ; # N
  br label %$25
$25:
  %649 = phi i64 [%365, %$30], [%375, %$49], [%437, %$56], [%483, %$61], [%593, %$68], [%608, %$70], [%646, %$69] ; # X
  %650 = phi i64 [%366, %$30], [%376, %$49], [%438, %$56], [%484, %$61], [%594, %$68], [%643, %$70], [%647, %$69] ; # P
  %651 = phi i64 [%367, %$30], [%377, %$49], [%439, %$56], [%485, %$61], [%595, %$68], [%622, %$70], [%648, %$69] ; # N
  br label %$18
$22:
  %652 = phi i64 [%156, %$19] ; # X
  %653 = phi i64 [%157, %$19] ; # P
  %654 = phi i64 [%158, %$19] ; # N
; # (set E $Nil)
  %655 = inttoptr i64 %123 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %655
; # (let Y (val Env) (while (pair (cdr Y)) (let Z (caar Y) (when (== ...
; # (val Env)
  %656 = inttoptr i64 %115 to i64*
  %657 = load i64, i64* %656
; # (while (pair (cdr Y)) (let Z (caar Y) (when (== (car Z) ZERO) (se...
  br label %$71
$71:
  %658 = phi i64 [%652, %$22], [%692, %$75] ; # X
  %659 = phi i64 [%653, %$22], [%693, %$75] ; # P
  %660 = phi i64 [%654, %$22], [%694, %$75] ; # N
  %661 = phi i64 [%657, %$22], [%699, %$75] ; # Y
; # (cdr Y)
  %662 = inttoptr i64 %661 to i64*
  %663 = getelementptr i64, i64* %662, i32 1
  %664 = load i64, i64* %663
; # (pair (cdr Y))
  %665 = and i64 %664, 15
  %666 = icmp eq i64 %665, 0
  br i1 %666, label %$72, label %$73
$72:
  %667 = phi i64 [%658, %$71] ; # X
  %668 = phi i64 [%659, %$71] ; # P
  %669 = phi i64 [%660, %$71] ; # N
  %670 = phi i64 [%661, %$71] ; # Y
; # (let Z (caar Y) (when (== (car Z) ZERO) (set E (cons (cons (shift...
; # (caar Y)
  %671 = inttoptr i64 %670 to i64*
  %672 = load i64, i64* %671
  %673 = inttoptr i64 %672 to i64*
  %674 = load i64, i64* %673
; # (when (== (car Z) ZERO) (set E (cons (cons (shift Z) (lookup ZERO...
; # (car Z)
  %675 = inttoptr i64 %674 to i64*
  %676 = load i64, i64* %675
; # (== (car Z) ZERO)
  %677 = icmp eq i64 %676, 2
  br i1 %677, label %$74, label %$75
$74:
  %678 = phi i64 [%667, %$72] ; # X
  %679 = phi i64 [%668, %$72] ; # P
  %680 = phi i64 [%669, %$72] ; # N
  %681 = phi i64 [%670, %$72] ; # Y
  %682 = phi i64 [%674, %$72] ; # Z
; # (set E (cons (cons (shift Z) (lookup ZERO Z)) (val E)))
; # (shift Z)
  %683 = inttoptr i64 %682 to i64*
  %684 = getelementptr i64, i64* %683, i32 1
  %685 = load i64, i64* %684
; # (lookup ZERO Z)
  %686 = call i64 @lookup(i64 2, i64 %685)
; # (cons (shift Z) (lookup ZERO Z))
  %687 = call i64 @cons(i64 %685, i64 %686)
; # (val E)
  %688 = inttoptr i64 %123 to i64*
  %689 = load i64, i64* %688
; # (cons (cons (shift Z) (lookup ZERO Z)) (val E))
  %690 = call i64 @cons(i64 %687, i64 %689)
  %691 = inttoptr i64 %123 to i64*
  store i64 %690, i64* %691
  br label %$75
$75:
  %692 = phi i64 [%667, %$72], [%678, %$74] ; # X
  %693 = phi i64 [%668, %$72], [%679, %$74] ; # P
  %694 = phi i64 [%669, %$72], [%680, %$74] ; # N
  %695 = phi i64 [%670, %$72], [%681, %$74] ; # Y
  %696 = phi i64 [%674, %$72], [%685, %$74] ; # Z
; # (shift Y)
  %697 = inttoptr i64 %695 to i64*
  %698 = getelementptr i64, i64* %697, i32 1
  %699 = load i64, i64* %698
  br label %$71
$73:
  %700 = phi i64 [%658, %$71] ; # X
  %701 = phi i64 [%659, %$71] ; # P
  %702 = phi i64 [%660, %$71] ; # N
  %703 = phi i64 [%661, %$71] ; # Y
; # (set $Pnl Pnl $Penv Penv $At At)
  store i64 %141, i64* @$Pnl
  store i64 %140, i64* @$Penv
  %704 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %131, i64* %704
; # (cond ((pair (val E)) @) ((pair (val Env)) $T) (T $Nil))
; # (val E)
  %705 = inttoptr i64 %123 to i64*
  %706 = load i64, i64* %705
; # (pair (val E))
  %707 = and i64 %706, 15
  %708 = icmp eq i64 %707, 0
  br i1 %708, label %$78, label %$77
$78:
  %709 = phi i64 [%700, %$73] ; # X
  %710 = phi i64 [%701, %$73] ; # P
  %711 = phi i64 [%702, %$73] ; # N
  br label %$76
$77:
  %712 = phi i64 [%700, %$73] ; # X
  %713 = phi i64 [%701, %$73] ; # P
  %714 = phi i64 [%702, %$73] ; # N
; # (val Env)
  %715 = inttoptr i64 %115 to i64*
  %716 = load i64, i64* %715
; # (pair (val Env))
  %717 = and i64 %716, 15
  %718 = icmp eq i64 %717, 0
  br i1 %718, label %$80, label %$79
$80:
  %719 = phi i64 [%712, %$77] ; # X
  %720 = phi i64 [%713, %$77] ; # P
  %721 = phi i64 [%714, %$77] ; # N
  br label %$76
$79:
  %722 = phi i64 [%712, %$77] ; # X
  %723 = phi i64 [%713, %$77] ; # P
  %724 = phi i64 [%714, %$77] ; # N
  br label %$76
$76:
  %725 = phi i64 [%709, %$78], [%719, %$80], [%722, %$79] ; # X
  %726 = phi i64 [%710, %$78], [%720, %$80], [%723, %$79] ; # P
  %727 = phi i64 [%711, %$78], [%721, %$80], [%724, %$79] ; # N
  %728 = phi i64 [%706, %$78], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$80], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$79] ; # ->
; # (drop *Safe)
  %729 = inttoptr i64 %21 to i64*
  %730 = getelementptr i64, i64* %729, i32 1
  %731 = load i64, i64* %730
  %732 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %731, i64* %732
  br label %$9
$9:
  %733 = phi i64 [%16, %$7], [%725, %$76] ; # X
  %734 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%728, %$76] ; # ->
  ret i64 %734
}

define i64 @_arrow(i64) align 8 {
$1:
; # (let (X (cdr Exe) L (val (val $Pnl))) (when (cnt? (cadr X)) (let ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $Pnl)
  %4 = load i64, i64* @$Pnl
; # (val (val $Pnl))
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (when (cnt? (cadr X)) (let I (int @) (while (gt0 (dec 'I)) (shift...
; # (cadr X)
  %7 = inttoptr i64 %3 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
; # (cnt? (cadr X))
  %12 = and i64 %11, 2
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%6, %$1] ; # L
; # (let I (int @) (while (gt0 (dec 'I)) (shift L)))
; # (int @)
  %15 = lshr i64 %11, 4
; # (while (gt0 (dec 'I)) (shift L))
  br label %$4
$4:
  %16 = phi i64 [%14, %$2], [%24, %$5] ; # L
  %17 = phi i64 [%15, %$2], [%21, %$5] ; # I
; # (dec 'I)
  %18 = sub i64 %17, 1
; # (gt0 (dec 'I))
  %19 = icmp sgt i64 %18, 0
  br i1 %19, label %$5, label %$6
$5:
  %20 = phi i64 [%16, %$4] ; # L
  %21 = phi i64 [%18, %$4] ; # I
; # (shift L)
  %22 = inttoptr i64 %20 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  br label %$4
$6:
  %25 = phi i64 [%16, %$4] ; # L
  %26 = phi i64 [%18, %$4] ; # I
  br label %$3
$3:
  %27 = phi i64 [%6, %$1], [%25, %$6] ; # L
; # (car L)
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (car X)
  %30 = inttoptr i64 %3 to i64*
  %31 = load i64, i64* %30
; # (lookup (car L) (car X))
  %32 = call i64 @lookup(i64 %29, i64 %31)
  ret i64 %32
}

define i64 @_unify(i64) align 8 {
$1:
; # (let (X (eval (cadr Exe)) Pnl (val (val $Pnl)) N (car Pnl)) (ifn ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (val $Pnl)
  %14 = load i64, i64* @$Pnl
; # (val (val $Pnl))
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
; # (car Pnl)
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
; # (ifn (cnt? X) (save X (if (unify (cadr Pnl) X N X) (val (val $Pen...
; # (cnt? X)
  %19 = and i64 %13, 2
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$8, label %$7
$7:
  %21 = phi i64 [%16, %$2] ; # Pnl
; # (save X (if (unify (cadr Pnl) X N X) (val (val $Penv)) $Nil))
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 %13, i64* %26
  %27 = add i64 %25, 8
  %28 = inttoptr i64 %27 to i64*
  store i64 %23, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %29
; # (if (unify (cadr Pnl) X N X) (val (val $Penv)) $Nil)
; # (cadr Pnl)
  %30 = inttoptr i64 %21 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (unify (cadr Pnl) X N X)
  %35 = call i1 @unify(i64 %34, i64 %13, i64 %18, i64 %13)
  br i1 %35, label %$10, label %$11
$10:
  %36 = phi i64 [%21, %$7] ; # Pnl
; # (val $Penv)
  %37 = load i64, i64* @$Penv
; # (val (val $Penv))
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
  br label %$12
$11:
  %40 = phi i64 [%21, %$7] ; # Pnl
  br label %$12
$12:
  %41 = phi i64 [%36, %$10], [%40, %$11] ; # Pnl
  %42 = phi i64 [%39, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
; # drop
  %43 = inttoptr i64 %25 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %46
  br label %$9
$8:
  %47 = phi i64 [%16, %$2] ; # Pnl
; # (let (I (int @) Penv (val (val $Penv))) (while (gt0 (dec 'I)) (sh...
; # (int @)
  %48 = lshr i64 %13, 4
; # (val $Penv)
  %49 = load i64, i64* @$Penv
; # (val (val $Penv))
  %50 = inttoptr i64 %49 to i64*
  %51 = load i64, i64* %50
; # (while (gt0 (dec 'I)) (shift Pnl))
  br label %$13
$13:
  %52 = phi i64 [%47, %$8], [%62, %$14] ; # Pnl
  %53 = phi i64 [%48, %$8], [%58, %$14] ; # I
  %54 = phi i64 [%51, %$8], [%59, %$14] ; # Penv
; # (dec 'I)
  %55 = sub i64 %53, 1
; # (gt0 (dec 'I))
  %56 = icmp sgt i64 %55, 0
  br i1 %56, label %$14, label %$15
$14:
  %57 = phi i64 [%52, %$13] ; # Pnl
  %58 = phi i64 [%55, %$13] ; # I
  %59 = phi i64 [%54, %$13] ; # Penv
; # (shift Pnl)
  %60 = inttoptr i64 %57 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
  br label %$13
$15:
  %63 = phi i64 [%52, %$13] ; # Pnl
  %64 = phi i64 [%55, %$13] ; # I
  %65 = phi i64 [%54, %$13] ; # Penv
; # (let M (car Pnl) (while (pair (car Penv)) (let Y (car @) (when (=...
; # (car Pnl)
  %66 = inttoptr i64 %63 to i64*
  %67 = load i64, i64* %66
; # (while (pair (car Penv)) (let Y (car @) (when (== (car Y) M) (let...
  br label %$16
$16:
  %68 = phi i64 [%63, %$15], [%90, %$20] ; # Pnl
  %69 = phi i64 [%64, %$15], [%91, %$20] ; # I
  %70 = phi i64 [%65, %$15], [%95, %$20] ; # Penv
; # (car Penv)
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
; # (pair (car Penv))
  %73 = and i64 %72, 15
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %$17, label %$18
$17:
  %75 = phi i64 [%68, %$16] ; # Pnl
  %76 = phi i64 [%69, %$16] ; # I
  %77 = phi i64 [%70, %$16] ; # Penv
; # (let Y (car @) (when (== (car Y) M) (let S (cdr Y) (unify M S N S...
; # (car @)
  %78 = inttoptr i64 %72 to i64*
  %79 = load i64, i64* %78
; # (when (== (car Y) M) (let S (cdr Y) (unify M S N S)))
; # (car Y)
  %80 = inttoptr i64 %79 to i64*
  %81 = load i64, i64* %80
; # (== (car Y) M)
  %82 = icmp eq i64 %81, %67
  br i1 %82, label %$19, label %$20
$19:
  %83 = phi i64 [%75, %$17] ; # Pnl
  %84 = phi i64 [%76, %$17] ; # I
  %85 = phi i64 [%77, %$17] ; # Penv
; # (let S (cdr Y) (unify M S N S))
; # (cdr Y)
  %86 = inttoptr i64 %79 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
; # (unify M S N S)
  %89 = call i1 @unify(i64 %67, i64 %88, i64 %18, i64 %88)
  br label %$20
$20:
  %90 = phi i64 [%75, %$17], [%83, %$19] ; # Pnl
  %91 = phi i64 [%76, %$17], [%84, %$19] ; # I
  %92 = phi i64 [%77, %$17], [%85, %$19] ; # Penv
; # (shift Penv)
  %93 = inttoptr i64 %92 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  %95 = load i64, i64* %94
  br label %$16
$18:
  %96 = phi i64 [%68, %$16] ; # Pnl
  %97 = phi i64 [%69, %$16] ; # I
  %98 = phi i64 [%70, %$16] ; # Penv
  br label %$9
$9:
  %99 = phi i64 [%41, %$12], [%96, %$18] ; # Pnl
  %100 = phi i64 [%42, %$12], [%13, %$18] ; # ->
  ret i64 %100
}

define i64 @_group(i64) align 8 {
$1:
; # (let X (save (eval (cadr Exe))) (if (atom X) $Nil (let Y (cons (c...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (cadr Exe)))
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %21
; # (if (atom X) $Nil (let Y (cons (cdar X) $Nil) (setq Y (cons (cons...
; # (atom X)
  %22 = and i64 %13, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$7, label %$8
$7:
  %24 = phi i64 [%13, %$2] ; # X
  br label %$9
$8:
  %25 = phi i64 [%13, %$2] ; # X
; # (let Y (cons (cdar X) $Nil) (setq Y (cons (cons (caar X) (cons Y ...
; # (cdar X)
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %27 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (cons (cdar X) $Nil)
  %31 = call i64 @cons(i64 %30, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (caar X)
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (cons Y Y)
  %36 = call i64 @cons(i64 %31, i64 %31)
; # (cons (caar X) (cons Y Y))
  %37 = call i64 @cons(i64 %35, i64 %36)
; # (cons (cons (caar X) (cons Y Y)) $Nil)
  %38 = call i64 @cons(i64 %37, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (let R (save Y) (while (pair (shift X)) (let (L (car X) K (car L)...
; # (save Y)
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = add i64 %42, 8
  %45 = inttoptr i64 %44 to i64*
  store i64 %40, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %46
; # (while (pair (shift X)) (let (L (car X) K (car L)) (setq Y (cons ...
  br label %$10
$10:
  %47 = phi i64 [%25, %$8], [%106, %$15] ; # X
  %48 = phi i64 [%38, %$8], [%107, %$15] ; # Y
; # (shift X)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (pair (shift X))
  %52 = and i64 %51, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$11, label %$12
$11:
  %54 = phi i64 [%51, %$10] ; # X
  %55 = phi i64 [%48, %$10] ; # Y
; # (let (L (car X) K (car L)) (setq Y (cons (cdr L) $Nil)) (let Z R ...
; # (car X)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
; # (car L)
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (cdr L)
  %60 = inttoptr i64 %57 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
; # (cons (cdr L) $Nil)
  %63 = call i64 @cons(i64 %62, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (let Z R (loop (let V (car Z) (? (equal K (car V)) (set (shift V)...
; # (loop (let V (car Z) (? (equal K (car V)) (set (shift V) (set 2 (...
  br label %$13
$13:
  %64 = phi i64 [%54, %$11], [%102, %$17] ; # X
  %65 = phi i64 [%63, %$11], [%103, %$17] ; # Y
  %66 = phi i64 [%38, %$11], [%90, %$17] ; # Z
; # (let V (car Z) (? (equal K (car V)) (set (shift V) (set 2 (car V)...
; # (car Z)
  %67 = inttoptr i64 %66 to i64*
  %68 = load i64, i64* %67
; # (? (equal K (car V)) (set (shift V) (set 2 (car V) Y)))
; # (car V)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (equal K (car V))
  %71 = call i1 @equal(i64 %59, i64 %70)
  br i1 %71, label %$16, label %$14
$16:
  %72 = phi i64 [%64, %$13] ; # X
  %73 = phi i64 [%65, %$13] ; # Y
  %74 = phi i64 [%66, %$13] ; # Z
  %75 = phi i64 [%68, %$13] ; # V
; # (set (shift V) (set 2 (car V) Y))
; # (shift V)
  %76 = inttoptr i64 %75 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (set 2 (car V) Y)
; # (car V)
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  store i64 %73, i64* %82
  %83 = inttoptr i64 %78 to i64*
  store i64 %73, i64* %83
  br label %$15
$14:
  %84 = phi i64 [%64, %$13] ; # X
  %85 = phi i64 [%65, %$13] ; # Y
  %86 = phi i64 [%66, %$13] ; # Z
  %87 = phi i64 [%68, %$13] ; # V
; # (? (atom (cdr Z)) (set 2 Z (cons (cons K (cons Y Y)) $Nil)))
; # (cdr Z)
  %88 = inttoptr i64 %86 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
; # (atom (cdr Z))
  %91 = and i64 %90, 15
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$18, label %$17
$18:
  %93 = phi i64 [%84, %$14] ; # X
  %94 = phi i64 [%85, %$14] ; # Y
  %95 = phi i64 [%86, %$14] ; # Z
  %96 = phi i64 [%87, %$14] ; # V
; # (set 2 Z (cons (cons K (cons Y Y)) $Nil))
; # (cons Y Y)
  %97 = call i64 @cons(i64 %94, i64 %94)
; # (cons K (cons Y Y))
  %98 = call i64 @cons(i64 %59, i64 %97)
; # (cons (cons K (cons Y Y)) $Nil)
  %99 = call i64 @cons(i64 %98, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %100 = inttoptr i64 %95 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  store i64 %99, i64* %101
  br label %$15
$17:
  %102 = phi i64 [%84, %$14] ; # X
  %103 = phi i64 [%85, %$14] ; # Y
  %104 = phi i64 [%86, %$14] ; # Z
  %105 = phi i64 [%87, %$14] ; # V
  br label %$13
$15:
  %106 = phi i64 [%72, %$16], [%93, %$18] ; # X
  %107 = phi i64 [%73, %$16], [%94, %$18] ; # Y
  %108 = phi i64 [%74, %$16], [%95, %$18] ; # Z
  %109 = phi i64 [%73, %$16], [%99, %$18] ; # ->
  br label %$10
$12:
  %110 = phi i64 [%51, %$10] ; # X
  %111 = phi i64 [%48, %$10] ; # Y
; # (let Z R (loop (let V (car Z) (set 2 V (cddr V))) (? (atom (shift...
; # (loop (let V (car Z) (set 2 V (cddr V))) (? (atom (shift Z))))
  br label %$19
$19:
  %112 = phi i64 [%110, %$12], [%130, %$20] ; # X
  %113 = phi i64 [%111, %$12], [%131, %$20] ; # Y
  %114 = phi i64 [%38, %$12], [%132, %$20] ; # Z
; # (let V (car Z) (set 2 V (cddr V)))
; # (car Z)
  %115 = inttoptr i64 %114 to i64*
  %116 = load i64, i64* %115
; # (set 2 V (cddr V))
; # (cddr V)
  %117 = inttoptr i64 %116 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  %119 = load i64, i64* %118
  %120 = inttoptr i64 %119 to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  %122 = load i64, i64* %121
  %123 = inttoptr i64 %116 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  store i64 %122, i64* %124
; # (? (atom (shift Z)))
; # (shift Z)
  %125 = inttoptr i64 %114 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
; # (atom (shift Z))
  %128 = and i64 %127, 15
  %129 = icmp ne i64 %128, 0
  br i1 %129, label %$21, label %$20
$20:
  %130 = phi i64 [%112, %$19] ; # X
  %131 = phi i64 [%113, %$19] ; # Y
  %132 = phi i64 [%127, %$19] ; # Z
  br label %$19
$21:
  %133 = phi i64 [%112, %$19] ; # X
  %134 = phi i64 [%113, %$19] ; # Y
  %135 = phi i64 [%127, %$19] ; # Z
  %136 = phi i64 [0, %$19] ; # ->
  br label %$9
$9:
  %137 = phi i64 [%24, %$7], [%133, %$21] ; # X
  %138 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%38, %$21] ; # ->
; # (drop *Safe)
  %139 = inttoptr i64 %17 to i64*
  %140 = getelementptr i64, i64* %139, i32 1
  %141 = load i64, i64* %140
  %142 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %141, i64* %142
  ret i64 %138
}

define i64 @_sort(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((atom Y) @) ((atom X) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((atom Y) @) ((atom X) (let (Out0 Y Out1 $Nil) (loop (let (...
; # (atom Y)
  %16 = and i64 %15, 15
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  br label %$7
$8:
; # (atom X)
  %18 = and i64 %7, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
; # (let (Out0 Y Out1 $Nil) (loop (let (In0 Out0 In1 Out1 P) (if (and...
; # (loop (let (In0 Out0 In1 Out1 P) (if (and (pair In1) (ge0 (compar...
  br label %$12
$12:
  %20 = phi i64 [%15, %$11], [%375, %$47] ; # Out0
  %21 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [%376, %$47] ; # Out1
; # (let (In0 Out0 In1 Out1 P) (if (and (pair In1) (ge0 (compare (car...
; # (if (and (pair In1) (ge0 (compare (car In0) (car In1)))) (setq In...
; # (and (pair In1) (ge0 (compare (car In0) (car In1))))
; # (pair In1)
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = phi i64 [%20, %$12] ; # Out0
  %25 = phi i64 [%21, %$12] ; # Out1
  %26 = phi i64 [%20, %$12] ; # In0
  %27 = phi i64 [%21, %$12] ; # In1
; # (car In0)
  %28 = inttoptr i64 %26 to i64*
  %29 = load i64, i64* %28
; # (car In1)
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
; # (compare (car In0) (car In1))
  %32 = call i64 @compare(i64 %29, i64 %31)
; # (ge0 (compare (car In0) (car In1)))
  %33 = icmp sge i64 %32, 0
  br label %$13
$13:
  %34 = phi i64 [%20, %$12], [%24, %$14] ; # Out0
  %35 = phi i64 [%21, %$12], [%25, %$14] ; # Out1
  %36 = phi i64 [%20, %$12], [%26, %$14] ; # In0
  %37 = phi i64 [%21, %$12], [%27, %$14] ; # In1
  %38 = phi i1 [0, %$12], [%33, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%34, %$13] ; # Out0
  %40 = phi i64 [%35, %$13] ; # Out1
  %41 = phi i64 [%36, %$13] ; # In0
  %42 = phi i64 [%37, %$13] ; # In1
; # (cdr (setq P In1))
  %43 = inttoptr i64 %42 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  br label %$17
$16:
  %46 = phi i64 [%34, %$13] ; # Out0
  %47 = phi i64 [%35, %$13] ; # Out1
  %48 = phi i64 [%36, %$13] ; # In0
  %49 = phi i64 [%37, %$13] ; # In1
; # (cdr (setq P In0))
  %50 = inttoptr i64 %48 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  br label %$17
$17:
  %53 = phi i64 [%39, %$15], [%46, %$16] ; # Out0
  %54 = phi i64 [%40, %$15], [%47, %$16] ; # Out1
  %55 = phi i64 [%41, %$15], [%52, %$16] ; # In0
  %56 = phi i64 [%45, %$15], [%49, %$16] ; # In1
  %57 = phi i64 [%42, %$15], [%48, %$16] ; # P
  %58 = phi i64 [%45, %$15], [%52, %$16] ; # ->
; # (let (Tail0 (ofs P 1) Tail1 0 Last (car P)) (setq Out0 P Out1 $Ni...
; # (ofs P 1)
  %59 = add i64 %57, 8
; # (car P)
  %60 = inttoptr i64 %57 to i64*
  %61 = load i64, i64* %60
; # (set 2 P $Nil)
  %62 = inttoptr i64 %57 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
; # (while (or (pair In0) (pair In1)) (cond ((atom In1) (setq In0 (cd...
  br label %$18
$18:
  %64 = phi i64 [%57, %$17], [%349, %$46] ; # Out0
  %65 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [%350, %$46] ; # Out1
  %66 = phi i64 [%55, %$17], [%351, %$46] ; # In0
  %67 = phi i64 [%56, %$17], [%352, %$46] ; # In1
  %68 = phi i64 [%57, %$17], [%353, %$46] ; # P
  %69 = phi i64 [%59, %$17], [%358, %$46] ; # Tail0
  %70 = phi i64 [0, %$17], [%355, %$46] ; # Tail1
  %71 = phi i64 [%61, %$17], [%362, %$46] ; # Last
; # (or (pair In0) (pair In1))
; # (pair In0)
  %72 = and i64 %66, 15
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %$19, label %$20
$20:
  %74 = phi i64 [%64, %$18] ; # Out0
  %75 = phi i64 [%65, %$18] ; # Out1
  %76 = phi i64 [%66, %$18] ; # In0
  %77 = phi i64 [%67, %$18] ; # In1
  %78 = phi i64 [%68, %$18] ; # P
  %79 = phi i64 [%69, %$18] ; # Tail0
  %80 = phi i64 [%70, %$18] ; # Tail1
  %81 = phi i64 [%71, %$18] ; # Last
; # (pair In1)
  %82 = and i64 %77, 15
  %83 = icmp eq i64 %82, 0
  br label %$19
$19:
  %84 = phi i64 [%64, %$18], [%74, %$20] ; # Out0
  %85 = phi i64 [%65, %$18], [%75, %$20] ; # Out1
  %86 = phi i64 [%66, %$18], [%76, %$20] ; # In0
  %87 = phi i64 [%67, %$18], [%77, %$20] ; # In1
  %88 = phi i64 [%68, %$18], [%78, %$20] ; # P
  %89 = phi i64 [%69, %$18], [%79, %$20] ; # Tail0
  %90 = phi i64 [%70, %$18], [%80, %$20] ; # Tail1
  %91 = phi i64 [%71, %$18], [%81, %$20] ; # Last
  %92 = phi i1 [1, %$18], [%83, %$20] ; # ->
  br i1 %92, label %$21, label %$22
$21:
  %93 = phi i64 [%84, %$19] ; # Out0
  %94 = phi i64 [%85, %$19] ; # Out1
  %95 = phi i64 [%86, %$19] ; # In0
  %96 = phi i64 [%87, %$19] ; # In1
  %97 = phi i64 [%88, %$19] ; # P
  %98 = phi i64 [%89, %$19] ; # Tail0
  %99 = phi i64 [%90, %$19] ; # Tail1
  %100 = phi i64 [%91, %$19] ; # Last
; # (cond ((atom In1) (setq In0 (cdr (setq P In0))) (when (lt0 (compa...
; # (atom In1)
  %101 = and i64 %96, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$25, label %$24
$25:
  %103 = phi i64 [%93, %$21] ; # Out0
  %104 = phi i64 [%94, %$21] ; # Out1
  %105 = phi i64 [%95, %$21] ; # In0
  %106 = phi i64 [%96, %$21] ; # In1
  %107 = phi i64 [%97, %$21] ; # P
  %108 = phi i64 [%98, %$21] ; # Tail0
  %109 = phi i64 [%99, %$21] ; # Tail1
  %110 = phi i64 [%100, %$21] ; # Last
; # (cdr (setq P In0))
  %111 = inttoptr i64 %105 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  %113 = load i64, i64* %112
; # (when (lt0 (compare (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %114 = inttoptr i64 %105 to i64*
  %115 = load i64, i64* %114
; # (compare (car P) Last)
  %116 = call i64 @compare(i64 %115, i64 %110)
; # (lt0 (compare (car P) Last))
  %117 = icmp slt i64 %116, 0
  br i1 %117, label %$26, label %$27
$26:
  %118 = phi i64 [%103, %$25] ; # Out0
  %119 = phi i64 [%104, %$25] ; # Out1
  %120 = phi i64 [%113, %$25] ; # In0
  %121 = phi i64 [%106, %$25] ; # In1
  %122 = phi i64 [%105, %$25] ; # P
  %123 = phi i64 [%108, %$25] ; # Tail0
  %124 = phi i64 [%109, %$25] ; # Tail1
  %125 = phi i64 [%110, %$25] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$27
$27:
  %126 = phi i64 [%103, %$25], [%118, %$26] ; # Out0
  %127 = phi i64 [%104, %$25], [%119, %$26] ; # Out1
  %128 = phi i64 [%113, %$25], [%120, %$26] ; # In0
  %129 = phi i64 [%106, %$25], [%121, %$26] ; # In1
  %130 = phi i64 [%105, %$25], [%122, %$26] ; # P
  %131 = phi i64 [%108, %$25], [%124, %$26] ; # Tail0
  %132 = phi i64 [%109, %$25], [%123, %$26] ; # Tail1
  %133 = phi i64 [%110, %$25], [%125, %$26] ; # Last
  br label %$23
$24:
  %134 = phi i64 [%93, %$21] ; # Out0
  %135 = phi i64 [%94, %$21] ; # Out1
  %136 = phi i64 [%95, %$21] ; # In0
  %137 = phi i64 [%96, %$21] ; # In1
  %138 = phi i64 [%97, %$21] ; # P
  %139 = phi i64 [%98, %$21] ; # Tail0
  %140 = phi i64 [%99, %$21] ; # Tail1
  %141 = phi i64 [%100, %$21] ; # Last
; # (atom In0)
  %142 = and i64 %136, 15
  %143 = icmp ne i64 %142, 0
  br i1 %143, label %$29, label %$28
$29:
  %144 = phi i64 [%134, %$24] ; # Out0
  %145 = phi i64 [%135, %$24] ; # Out1
  %146 = phi i64 [%136, %$24] ; # In0
  %147 = phi i64 [%137, %$24] ; # In1
  %148 = phi i64 [%138, %$24] ; # P
  %149 = phi i64 [%139, %$24] ; # Tail0
  %150 = phi i64 [%140, %$24] ; # Tail1
  %151 = phi i64 [%141, %$24] ; # Last
; # (cdr (setq P In1))
  %152 = inttoptr i64 %147 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
; # (when (lt0 (compare (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %155 = inttoptr i64 %147 to i64*
  %156 = load i64, i64* %155
; # (compare (car P) Last)
  %157 = call i64 @compare(i64 %156, i64 %151)
; # (lt0 (compare (car P) Last))
  %158 = icmp slt i64 %157, 0
  br i1 %158, label %$30, label %$31
$30:
  %159 = phi i64 [%144, %$29] ; # Out0
  %160 = phi i64 [%145, %$29] ; # Out1
  %161 = phi i64 [%146, %$29] ; # In0
  %162 = phi i64 [%154, %$29] ; # In1
  %163 = phi i64 [%147, %$29] ; # P
  %164 = phi i64 [%149, %$29] ; # Tail0
  %165 = phi i64 [%150, %$29] ; # Tail1
  %166 = phi i64 [%151, %$29] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$31
$31:
  %167 = phi i64 [%144, %$29], [%159, %$30] ; # Out0
  %168 = phi i64 [%145, %$29], [%160, %$30] ; # Out1
  %169 = phi i64 [%146, %$29], [%161, %$30] ; # In0
  %170 = phi i64 [%154, %$29], [%162, %$30] ; # In1
  %171 = phi i64 [%147, %$29], [%163, %$30] ; # P
  %172 = phi i64 [%149, %$29], [%165, %$30] ; # Tail0
  %173 = phi i64 [%150, %$29], [%164, %$30] ; # Tail1
  %174 = phi i64 [%151, %$29], [%166, %$30] ; # Last
  br label %$23
$28:
  %175 = phi i64 [%134, %$24] ; # Out0
  %176 = phi i64 [%135, %$24] ; # Out1
  %177 = phi i64 [%136, %$24] ; # In0
  %178 = phi i64 [%137, %$24] ; # In1
  %179 = phi i64 [%138, %$24] ; # P
  %180 = phi i64 [%139, %$24] ; # Tail0
  %181 = phi i64 [%140, %$24] ; # Tail1
  %182 = phi i64 [%141, %$24] ; # Last
; # (car In0)
  %183 = inttoptr i64 %177 to i64*
  %184 = load i64, i64* %183
; # (compare (car In0) Last)
  %185 = call i64 @compare(i64 %184, i64 %182)
; # (lt0 (compare (car In0) Last))
  %186 = icmp slt i64 %185, 0
  br i1 %186, label %$33, label %$32
$33:
  %187 = phi i64 [%175, %$28] ; # Out0
  %188 = phi i64 [%176, %$28] ; # Out1
  %189 = phi i64 [%177, %$28] ; # In0
  %190 = phi i64 [%178, %$28] ; # In1
  %191 = phi i64 [%179, %$28] ; # P
  %192 = phi i64 [%180, %$28] ; # Tail0
  %193 = phi i64 [%181, %$28] ; # Tail1
  %194 = phi i64 [%182, %$28] ; # Last
; # (if (ge0 (compare (car In1) Last)) (setq In1 (cdr (setq P In1))) ...
; # (car In1)
  %195 = inttoptr i64 %190 to i64*
  %196 = load i64, i64* %195
; # (compare (car In1) Last)
  %197 = call i64 @compare(i64 %196, i64 %194)
; # (ge0 (compare (car In1) Last))
  %198 = icmp sge i64 %197, 0
  br i1 %198, label %$34, label %$35
$34:
  %199 = phi i64 [%187, %$33] ; # Out0
  %200 = phi i64 [%188, %$33] ; # Out1
  %201 = phi i64 [%189, %$33] ; # In0
  %202 = phi i64 [%190, %$33] ; # In1
  %203 = phi i64 [%191, %$33] ; # P
  %204 = phi i64 [%192, %$33] ; # Tail0
  %205 = phi i64 [%193, %$33] ; # Tail1
  %206 = phi i64 [%194, %$33] ; # Last
; # (cdr (setq P In1))
  %207 = inttoptr i64 %202 to i64*
  %208 = getelementptr i64, i64* %207, i32 1
  %209 = load i64, i64* %208
  br label %$36
$35:
  %210 = phi i64 [%187, %$33] ; # Out0
  %211 = phi i64 [%188, %$33] ; # Out1
  %212 = phi i64 [%189, %$33] ; # In0
  %213 = phi i64 [%190, %$33] ; # In1
  %214 = phi i64 [%191, %$33] ; # P
  %215 = phi i64 [%192, %$33] ; # Tail0
  %216 = phi i64 [%193, %$33] ; # Tail1
  %217 = phi i64 [%194, %$33] ; # Last
; # (if (lt0 (compare (car In0) (car In1))) (setq In0 (cdr (setq P In...
; # (car In0)
  %218 = inttoptr i64 %212 to i64*
  %219 = load i64, i64* %218
; # (car In1)
  %220 = inttoptr i64 %213 to i64*
  %221 = load i64, i64* %220
; # (compare (car In0) (car In1))
  %222 = call i64 @compare(i64 %219, i64 %221)
; # (lt0 (compare (car In0) (car In1)))
  %223 = icmp slt i64 %222, 0
  br i1 %223, label %$37, label %$38
$37:
  %224 = phi i64 [%210, %$35] ; # Out0
  %225 = phi i64 [%211, %$35] ; # Out1
  %226 = phi i64 [%212, %$35] ; # In0
  %227 = phi i64 [%213, %$35] ; # In1
  %228 = phi i64 [%214, %$35] ; # P
  %229 = phi i64 [%215, %$35] ; # Tail0
  %230 = phi i64 [%216, %$35] ; # Tail1
  %231 = phi i64 [%217, %$35] ; # Last
; # (cdr (setq P In0))
  %232 = inttoptr i64 %226 to i64*
  %233 = getelementptr i64, i64* %232, i32 1
  %234 = load i64, i64* %233
  br label %$39
$38:
  %235 = phi i64 [%210, %$35] ; # Out0
  %236 = phi i64 [%211, %$35] ; # Out1
  %237 = phi i64 [%212, %$35] ; # In0
  %238 = phi i64 [%213, %$35] ; # In1
  %239 = phi i64 [%214, %$35] ; # P
  %240 = phi i64 [%215, %$35] ; # Tail0
  %241 = phi i64 [%216, %$35] ; # Tail1
  %242 = phi i64 [%217, %$35] ; # Last
; # (cdr (setq P In1))
  %243 = inttoptr i64 %238 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  %245 = load i64, i64* %244
  br label %$39
$39:
  %246 = phi i64 [%224, %$37], [%235, %$38] ; # Out0
  %247 = phi i64 [%225, %$37], [%236, %$38] ; # Out1
  %248 = phi i64 [%234, %$37], [%237, %$38] ; # In0
  %249 = phi i64 [%227, %$37], [%245, %$38] ; # In1
  %250 = phi i64 [%226, %$37], [%238, %$38] ; # P
  %251 = phi i64 [%229, %$37], [%240, %$38] ; # Tail0
  %252 = phi i64 [%230, %$37], [%241, %$38] ; # Tail1
  %253 = phi i64 [%231, %$37], [%242, %$38] ; # Last
  %254 = phi i64 [%234, %$37], [%245, %$38] ; # ->
; # (xchg 'Tail0 'Tail1)
  br label %$36
$36:
  %255 = phi i64 [%199, %$34], [%246, %$39] ; # Out0
  %256 = phi i64 [%200, %$34], [%247, %$39] ; # Out1
  %257 = phi i64 [%201, %$34], [%248, %$39] ; # In0
  %258 = phi i64 [%209, %$34], [%249, %$39] ; # In1
  %259 = phi i64 [%202, %$34], [%250, %$39] ; # P
  %260 = phi i64 [%204, %$34], [%252, %$39] ; # Tail0
  %261 = phi i64 [%205, %$34], [%251, %$39] ; # Tail1
  %262 = phi i64 [%206, %$34], [%253, %$39] ; # Last
  %263 = phi i64 [%209, %$34], [%251, %$39] ; # ->
  br label %$23
$32:
  %264 = phi i64 [%175, %$28] ; # Out0
  %265 = phi i64 [%176, %$28] ; # Out1
  %266 = phi i64 [%177, %$28] ; # In0
  %267 = phi i64 [%178, %$28] ; # In1
  %268 = phi i64 [%179, %$28] ; # P
  %269 = phi i64 [%180, %$28] ; # Tail0
  %270 = phi i64 [%181, %$28] ; # Tail1
  %271 = phi i64 [%182, %$28] ; # Last
; # (car In1)
  %272 = inttoptr i64 %267 to i64*
  %273 = load i64, i64* %272
; # (compare (car In1) Last)
  %274 = call i64 @compare(i64 %273, i64 %271)
; # (lt0 (compare (car In1) Last))
  %275 = icmp slt i64 %274, 0
  br i1 %275, label %$41, label %$40
$41:
  %276 = phi i64 [%264, %$32] ; # Out0
  %277 = phi i64 [%265, %$32] ; # Out1
  %278 = phi i64 [%266, %$32] ; # In0
  %279 = phi i64 [%267, %$32] ; # In1
  %280 = phi i64 [%268, %$32] ; # P
  %281 = phi i64 [%269, %$32] ; # Tail0
  %282 = phi i64 [%270, %$32] ; # Tail1
  %283 = phi i64 [%271, %$32] ; # Last
; # (cdr (setq P In0))
  %284 = inttoptr i64 %278 to i64*
  %285 = getelementptr i64, i64* %284, i32 1
  %286 = load i64, i64* %285
  br label %$23
$40:
  %287 = phi i64 [%264, %$32] ; # Out0
  %288 = phi i64 [%265, %$32] ; # Out1
  %289 = phi i64 [%266, %$32] ; # In0
  %290 = phi i64 [%267, %$32] ; # In1
  %291 = phi i64 [%268, %$32] ; # P
  %292 = phi i64 [%269, %$32] ; # Tail0
  %293 = phi i64 [%270, %$32] ; # Tail1
  %294 = phi i64 [%271, %$32] ; # Last
; # (car In0)
  %295 = inttoptr i64 %289 to i64*
  %296 = load i64, i64* %295
; # (car In1)
  %297 = inttoptr i64 %290 to i64*
  %298 = load i64, i64* %297
; # (compare (car In0) (car In1))
  %299 = call i64 @compare(i64 %296, i64 %298)
; # (lt0 (compare (car In0) (car In1)))
  %300 = icmp slt i64 %299, 0
  br i1 %300, label %$43, label %$42
$43:
  %301 = phi i64 [%287, %$40] ; # Out0
  %302 = phi i64 [%288, %$40] ; # Out1
  %303 = phi i64 [%289, %$40] ; # In0
  %304 = phi i64 [%290, %$40] ; # In1
  %305 = phi i64 [%291, %$40] ; # P
  %306 = phi i64 [%292, %$40] ; # Tail0
  %307 = phi i64 [%293, %$40] ; # Tail1
  %308 = phi i64 [%294, %$40] ; # Last
; # (cdr (setq P In0))
  %309 = inttoptr i64 %303 to i64*
  %310 = getelementptr i64, i64* %309, i32 1
  %311 = load i64, i64* %310
  br label %$23
$42:
  %312 = phi i64 [%287, %$40] ; # Out0
  %313 = phi i64 [%288, %$40] ; # Out1
  %314 = phi i64 [%289, %$40] ; # In0
  %315 = phi i64 [%290, %$40] ; # In1
  %316 = phi i64 [%291, %$40] ; # P
  %317 = phi i64 [%292, %$40] ; # Tail0
  %318 = phi i64 [%293, %$40] ; # Tail1
  %319 = phi i64 [%294, %$40] ; # Last
; # (cdr (setq P In1))
  %320 = inttoptr i64 %315 to i64*
  %321 = getelementptr i64, i64* %320, i32 1
  %322 = load i64, i64* %321
  br label %$23
$23:
  %323 = phi i64 [%126, %$27], [%167, %$31], [%255, %$36], [%276, %$41], [%301, %$43], [%312, %$42] ; # Out0
  %324 = phi i64 [%127, %$27], [%168, %$31], [%256, %$36], [%277, %$41], [%302, %$43], [%313, %$42] ; # Out1
  %325 = phi i64 [%128, %$27], [%169, %$31], [%257, %$36], [%286, %$41], [%311, %$43], [%314, %$42] ; # In0
  %326 = phi i64 [%129, %$27], [%170, %$31], [%258, %$36], [%279, %$41], [%304, %$43], [%322, %$42] ; # In1
  %327 = phi i64 [%130, %$27], [%171, %$31], [%259, %$36], [%278, %$41], [%303, %$43], [%315, %$42] ; # P
  %328 = phi i64 [%131, %$27], [%172, %$31], [%260, %$36], [%281, %$41], [%306, %$43], [%317, %$42] ; # Tail0
  %329 = phi i64 [%132, %$27], [%173, %$31], [%261, %$36], [%282, %$41], [%307, %$43], [%318, %$42] ; # Tail1
  %330 = phi i64 [%133, %$27], [%174, %$31], [%262, %$36], [%283, %$41], [%308, %$43], [%319, %$42] ; # Last
; # (if Tail0 (set Tail0 P) (setq Out1 P))
  %331 = icmp ne i64 %328, 0
  br i1 %331, label %$44, label %$45
$44:
  %332 = phi i64 [%323, %$23] ; # Out0
  %333 = phi i64 [%324, %$23] ; # Out1
  %334 = phi i64 [%325, %$23] ; # In0
  %335 = phi i64 [%326, %$23] ; # In1
  %336 = phi i64 [%327, %$23] ; # P
  %337 = phi i64 [%328, %$23] ; # Tail0
  %338 = phi i64 [%329, %$23] ; # Tail1
  %339 = phi i64 [%330, %$23] ; # Last
; # (set Tail0 P)
  %340 = inttoptr i64 %337 to i64*
  store i64 %336, i64* %340
  br label %$46
$45:
  %341 = phi i64 [%323, %$23] ; # Out0
  %342 = phi i64 [%324, %$23] ; # Out1
  %343 = phi i64 [%325, %$23] ; # In0
  %344 = phi i64 [%326, %$23] ; # In1
  %345 = phi i64 [%327, %$23] ; # P
  %346 = phi i64 [%328, %$23] ; # Tail0
  %347 = phi i64 [%329, %$23] ; # Tail1
  %348 = phi i64 [%330, %$23] ; # Last
  br label %$46
$46:
  %349 = phi i64 [%332, %$44], [%341, %$45] ; # Out0
  %350 = phi i64 [%333, %$44], [%345, %$45] ; # Out1
  %351 = phi i64 [%334, %$44], [%343, %$45] ; # In0
  %352 = phi i64 [%335, %$44], [%344, %$45] ; # In1
  %353 = phi i64 [%336, %$44], [%345, %$45] ; # P
  %354 = phi i64 [%337, %$44], [%346, %$45] ; # Tail0
  %355 = phi i64 [%338, %$44], [%347, %$45] ; # Tail1
  %356 = phi i64 [%339, %$44], [%348, %$45] ; # Last
  %357 = phi i64 [%336, %$44], [%345, %$45] ; # ->
; # (ofs (if Tail0 (set Tail0 P) (setq Out1 P)) 1)
  %358 = add i64 %357, 8
; # (set 2 P $Nil)
  %359 = inttoptr i64 %353 to i64*
  %360 = getelementptr i64, i64* %359, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %360
; # (car P)
  %361 = inttoptr i64 %353 to i64*
  %362 = load i64, i64* %361
  br label %$18
$22:
  %363 = phi i64 [%84, %$19] ; # Out0
  %364 = phi i64 [%85, %$19] ; # Out1
  %365 = phi i64 [%86, %$19] ; # In0
  %366 = phi i64 [%87, %$19] ; # In1
  %367 = phi i64 [%88, %$19] ; # P
  %368 = phi i64 [%89, %$19] ; # Tail0
  %369 = phi i64 [%90, %$19] ; # Tail1
  %370 = phi i64 [%91, %$19] ; # Last
; # (? (atom Out1) Out0)
; # (atom Out1)
  %371 = and i64 %364, 15
  %372 = icmp ne i64 %371, 0
  br i1 %372, label %$49, label %$47
$49:
  %373 = phi i64 [%363, %$22] ; # Out0
  %374 = phi i64 [%364, %$22] ; # Out1
  br label %$48
$47:
  %375 = phi i64 [%363, %$22] ; # Out0
  %376 = phi i64 [%364, %$22] ; # Out1
  br label %$12
$48:
  %377 = phi i64 [%373, %$49] ; # Out0
  %378 = phi i64 [%374, %$49] ; # Out1
  %379 = phi i64 [%373, %$49] ; # ->
  br label %$7
$10:
; # (let (Out0 (link (push Y NIL) T) Out1 (link (push $Nil NIL)) In0 ...
; # (push Y NIL)
  %380 = alloca i64, i64 2, align 16
  %381 = ptrtoint i64* %380 to i64
  %382 = inttoptr i64 %381 to i64*
  store i64 %15, i64* %382
; # (link (push Y NIL) T)
  %383 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %384 = load i64, i64* %383
  %385 = inttoptr i64 %381 to i64*
  %386 = getelementptr i64, i64* %385, i32 1
  store i64 %384, i64* %386
  %387 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %381, i64* %387
; # (push $Nil NIL)
  %388 = alloca i64, i64 2, align 16
  %389 = ptrtoint i64* %388 to i64
  %390 = inttoptr i64 %389 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %390
; # (link (push $Nil NIL))
  %391 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %392 = load i64, i64* %391
  %393 = inttoptr i64 %389 to i64*
  %394 = getelementptr i64, i64* %393, i32 1
  store i64 %392, i64* %394
  %395 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %389, i64* %395
; # (push -ZERO NIL)
  %396 = alloca i64, i64 2, align 16
  %397 = ptrtoint i64* %396 to i64
  %398 = inttoptr i64 %397 to i64*
  store i64 10, i64* %398
; # (link (push -ZERO NIL))
  %399 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %400 = load i64, i64* %399
  %401 = inttoptr i64 %397 to i64*
  %402 = getelementptr i64, i64* %401, i32 1
  store i64 %400, i64* %402
  %403 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %397, i64* %403
; # (push -ZERO NIL)
  %404 = alloca i64, i64 2, align 16
  %405 = ptrtoint i64* %404 to i64
  %406 = inttoptr i64 %405 to i64*
  store i64 10, i64* %406
; # (link (push -ZERO NIL))
  %407 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %408 = load i64, i64* %407
  %409 = inttoptr i64 %405 to i64*
  %410 = getelementptr i64, i64* %409, i32 1
  store i64 %408, i64* %410
  %411 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %405, i64* %411
; # (push NIL $Nil ZERO NIL)
  %412 = alloca i64, i64 4, align 16
  %413 = ptrtoint i64* %412 to i64
  %414 = add i64 %413, 8
  %415 = inttoptr i64 %414 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %415
  %416 = add i64 %413, 16
  %417 = inttoptr i64 %416 to i64*
  store i64 2, i64* %417
; # (push NIL B ZERO NIL)
  %418 = alloca i64, i64 4, align 16
  %419 = ptrtoint i64* %418 to i64
  %420 = add i64 %419, 8
  %421 = inttoptr i64 %420 to i64*
  store i64 %413, i64* %421
  %422 = add i64 %419, 16
  %423 = inttoptr i64 %422 to i64*
  store i64 2, i64* %423
; # (car X)
  %424 = inttoptr i64 %7 to i64*
  %425 = load i64, i64* %424
; # (eval (car X))
  %426 = and i64 %425, 6
  %427 = icmp ne i64 %426, 0
  br i1 %427, label %$52, label %$51
$52:
  br label %$50
$51:
  %428 = and i64 %425, 8
  %429 = icmp ne i64 %428, 0
  br i1 %429, label %$54, label %$53
$54:
  %430 = inttoptr i64 %425 to i64*
  %431 = load i64, i64* %430
  br label %$50
$53:
  %432 = call i64 @evList(i64 %425)
  br label %$50
$50:
  %433 = phi i64 [%425, %$52], [%431, %$54], [%432, %$53] ; # ->
; # (push NIL A ZERO (eval (car X)) NIL)
  %434 = alloca i64, i64 5, align 16
  %435 = ptrtoint i64* %434 to i64
  %436 = add i64 %435, 8
  %437 = inttoptr i64 %436 to i64*
  store i64 %419, i64* %437
  %438 = add i64 %435, 16
  %439 = inttoptr i64 %438 to i64*
  store i64 2, i64* %439
  %440 = add i64 %435, 24
  %441 = inttoptr i64 %440 to i64*
  store i64 %433, i64* %441
; # (set B (ofs B 3) A (ofs A 3) E (link (ofs E 3)))
; # (ofs B 3)
  %442 = add i64 %413, 24
  %443 = inttoptr i64 %413 to i64*
  store i64 %442, i64* %443
; # (ofs A 3)
  %444 = add i64 %419, 24
  %445 = inttoptr i64 %419 to i64*
  store i64 %444, i64* %445
; # (ofs E 3)
  %446 = add i64 %435, 24
; # (link (ofs E 3))
  %447 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %448 = load i64, i64* %447
  %449 = inttoptr i64 %446 to i64*
  %450 = getelementptr i64, i64* %449, i32 1
  store i64 %448, i64* %450
  %451 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %446, i64* %451
  %452 = inttoptr i64 %435 to i64*
  store i64 %446, i64* %452
; # (loop (set In0 (val Out0) In1 (val Out1)) (if (and (pair (val In1...
  br label %$55
$55:
  %453 = phi i64 [%413, %$50], [%896, %$114] ; # B
  %454 = phi i64 [%419, %$50], [%897, %$114] ; # A
  %455 = phi i64 [%435, %$50], [%898, %$114] ; # E
; # (set In0 (val Out0) In1 (val Out1))
; # (val Out0)
  %456 = inttoptr i64 %381 to i64*
  %457 = load i64, i64* %456
  %458 = inttoptr i64 %397 to i64*
  store i64 %457, i64* %458
; # (val Out1)
  %459 = inttoptr i64 %389 to i64*
  %460 = load i64, i64* %459
  %461 = inttoptr i64 %405 to i64*
  store i64 %460, i64* %461
; # (if (and (pair (val In1)) (ge0 (cmpSort (caar In0) (caar In1)))) ...
; # (and (pair (val In1)) (ge0 (cmpSort (caar In0) (caar In1))))
; # (val In1)
  %462 = inttoptr i64 %405 to i64*
  %463 = load i64, i64* %462
; # (pair (val In1))
  %464 = and i64 %463, 15
  %465 = icmp eq i64 %464, 0
  br i1 %465, label %$57, label %$56
$57:
  %466 = phi i64 [%453, %$55] ; # B
  %467 = phi i64 [%454, %$55] ; # A
  %468 = phi i64 [%455, %$55] ; # E
; # (caar In0)
  %469 = inttoptr i64 %397 to i64*
  %470 = load i64, i64* %469
  %471 = inttoptr i64 %470 to i64*
  %472 = load i64, i64* %471
; # (caar In1)
  %473 = inttoptr i64 %405 to i64*
  %474 = load i64, i64* %473
  %475 = inttoptr i64 %474 to i64*
  %476 = load i64, i64* %475
; # (cmpSort (caar In0) (caar In1))
  %477 = inttoptr i64 %467 to i64*
  %478 = getelementptr i64, i64* %477, i32 3
  store i64 %472, i64* %478
  %479 = inttoptr i64 %466 to i64*
  %480 = getelementptr i64, i64* %479, i32 3
  store i64 %476, i64* %480
  %481 = call i64 @evList(i64 %468)
  %482 = icmp eq i64 %481, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %482, label %$58, label %$59
$58:
  br label %$60
$59:
  br label %$60
$60:
  %483 = phi i64 [0, %$58], [-1, %$59] ; # ->
; # (ge0 (cmpSort (caar In0) (caar In1)))
  %484 = icmp sge i64 %483, 0
  br label %$56
$56:
  %485 = phi i64 [%453, %$55], [%466, %$60] ; # B
  %486 = phi i64 [%454, %$55], [%467, %$60] ; # A
  %487 = phi i64 [%455, %$55], [%468, %$60] ; # E
  %488 = phi i1 [0, %$55], [%484, %$60] ; # ->
  br i1 %488, label %$61, label %$62
$61:
  %489 = phi i64 [%485, %$56] ; # B
  %490 = phi i64 [%486, %$56] ; # A
  %491 = phi i64 [%487, %$56] ; # E
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %492 = inttoptr i64 %405 to i64*
  %493 = load i64, i64* %492
; # (cdr (setq P (val In1)))
  %494 = inttoptr i64 %493 to i64*
  %495 = getelementptr i64, i64* %494, i32 1
  %496 = load i64, i64* %495
  %497 = inttoptr i64 %405 to i64*
  store i64 %496, i64* %497
  br label %$63
$62:
  %498 = phi i64 [%485, %$56] ; # B
  %499 = phi i64 [%486, %$56] ; # A
  %500 = phi i64 [%487, %$56] ; # E
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %501 = inttoptr i64 %397 to i64*
  %502 = load i64, i64* %501
; # (cdr (setq P (val In0)))
  %503 = inttoptr i64 %502 to i64*
  %504 = getelementptr i64, i64* %503, i32 1
  %505 = load i64, i64* %504
  %506 = inttoptr i64 %397 to i64*
  store i64 %505, i64* %506
  br label %$63
$63:
  %507 = phi i64 [%489, %$61], [%498, %$62] ; # B
  %508 = phi i64 [%490, %$61], [%499, %$62] ; # A
  %509 = phi i64 [%491, %$61], [%500, %$62] ; # E
  %510 = phi i64 [%493, %$61], [%502, %$62] ; # P
  %511 = phi i64 [%496, %$61], [%505, %$62] ; # ->
; # (let (Tail0 (ofs P 1) Tail1 0 Last (car P)) (set Out0 P Out1 $Nil...
; # (ofs P 1)
  %512 = add i64 %510, 8
; # (car P)
  %513 = inttoptr i64 %510 to i64*
  %514 = load i64, i64* %513
; # (set Out0 P Out1 $Nil)
  %515 = inttoptr i64 %381 to i64*
  store i64 %510, i64* %515
  %516 = inttoptr i64 %389 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %516
; # (set 2 P $Nil)
  %517 = inttoptr i64 %510 to i64*
  %518 = getelementptr i64, i64* %517, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %518
; # (while (or (pair (val In0)) (pair (val In1))) (cond ((atom (val I...
  br label %$64
$64:
  %519 = phi i64 [%507, %$63], [%866, %$113] ; # B
  %520 = phi i64 [%508, %$63], [%867, %$113] ; # A
  %521 = phi i64 [%509, %$63], [%868, %$113] ; # E
  %522 = phi i64 [%510, %$63], [%869, %$113] ; # P
  %523 = phi i64 [%512, %$63], [%874, %$113] ; # Tail0
  %524 = phi i64 [0, %$63], [%871, %$113] ; # Tail1
  %525 = phi i64 [%514, %$63], [%878, %$113] ; # Last
; # (or (pair (val In0)) (pair (val In1)))
; # (val In0)
  %526 = inttoptr i64 %397 to i64*
  %527 = load i64, i64* %526
; # (pair (val In0))
  %528 = and i64 %527, 15
  %529 = icmp eq i64 %528, 0
  br i1 %529, label %$65, label %$66
$66:
  %530 = phi i64 [%519, %$64] ; # B
  %531 = phi i64 [%520, %$64] ; # A
  %532 = phi i64 [%521, %$64] ; # E
  %533 = phi i64 [%522, %$64] ; # P
  %534 = phi i64 [%523, %$64] ; # Tail0
  %535 = phi i64 [%524, %$64] ; # Tail1
  %536 = phi i64 [%525, %$64] ; # Last
; # (val In1)
  %537 = inttoptr i64 %405 to i64*
  %538 = load i64, i64* %537
; # (pair (val In1))
  %539 = and i64 %538, 15
  %540 = icmp eq i64 %539, 0
  br label %$65
$65:
  %541 = phi i64 [%519, %$64], [%530, %$66] ; # B
  %542 = phi i64 [%520, %$64], [%531, %$66] ; # A
  %543 = phi i64 [%521, %$64], [%532, %$66] ; # E
  %544 = phi i64 [%522, %$64], [%533, %$66] ; # P
  %545 = phi i64 [%523, %$64], [%534, %$66] ; # Tail0
  %546 = phi i64 [%524, %$64], [%535, %$66] ; # Tail1
  %547 = phi i64 [%525, %$64], [%536, %$66] ; # Last
  %548 = phi i1 [1, %$64], [%540, %$66] ; # ->
  br i1 %548, label %$67, label %$68
$67:
  %549 = phi i64 [%541, %$65] ; # B
  %550 = phi i64 [%542, %$65] ; # A
  %551 = phi i64 [%543, %$65] ; # E
  %552 = phi i64 [%544, %$65] ; # P
  %553 = phi i64 [%545, %$65] ; # Tail0
  %554 = phi i64 [%546, %$65] ; # Tail1
  %555 = phi i64 [%547, %$65] ; # Last
; # (cond ((atom (val In1)) (set In0 (cdr (setq P (val In0)))) (when ...
; # (val In1)
  %556 = inttoptr i64 %405 to i64*
  %557 = load i64, i64* %556
; # (atom (val In1))
  %558 = and i64 %557, 15
  %559 = icmp ne i64 %558, 0
  br i1 %559, label %$71, label %$70
$71:
  %560 = phi i64 [%549, %$67] ; # B
  %561 = phi i64 [%550, %$67] ; # A
  %562 = phi i64 [%551, %$67] ; # E
  %563 = phi i64 [%552, %$67] ; # P
  %564 = phi i64 [%553, %$67] ; # Tail0
  %565 = phi i64 [%554, %$67] ; # Tail1
  %566 = phi i64 [%555, %$67] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %567 = inttoptr i64 %397 to i64*
  %568 = load i64, i64* %567
; # (cdr (setq P (val In0)))
  %569 = inttoptr i64 %568 to i64*
  %570 = getelementptr i64, i64* %569, i32 1
  %571 = load i64, i64* %570
  %572 = inttoptr i64 %397 to i64*
  store i64 %571, i64* %572
; # (when (lt0 (cmpSort (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %573 = inttoptr i64 %568 to i64*
  %574 = load i64, i64* %573
; # (cmpSort (car P) Last)
  %575 = inttoptr i64 %561 to i64*
  %576 = getelementptr i64, i64* %575, i32 3
  store i64 %574, i64* %576
  %577 = inttoptr i64 %560 to i64*
  %578 = getelementptr i64, i64* %577, i32 3
  store i64 %566, i64* %578
  %579 = call i64 @evList(i64 %562)
  %580 = icmp eq i64 %579, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %580, label %$72, label %$73
$72:
  br label %$74
$73:
  br label %$74
$74:
  %581 = phi i64 [0, %$72], [-1, %$73] ; # ->
; # (lt0 (cmpSort (car P) Last))
  %582 = icmp slt i64 %581, 0
  br i1 %582, label %$75, label %$76
$75:
  %583 = phi i64 [%560, %$74] ; # B
  %584 = phi i64 [%561, %$74] ; # A
  %585 = phi i64 [%562, %$74] ; # E
  %586 = phi i64 [%568, %$74] ; # P
  %587 = phi i64 [%564, %$74] ; # Tail0
  %588 = phi i64 [%565, %$74] ; # Tail1
  %589 = phi i64 [%566, %$74] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$76
$76:
  %590 = phi i64 [%560, %$74], [%583, %$75] ; # B
  %591 = phi i64 [%561, %$74], [%584, %$75] ; # A
  %592 = phi i64 [%562, %$74], [%585, %$75] ; # E
  %593 = phi i64 [%568, %$74], [%586, %$75] ; # P
  %594 = phi i64 [%564, %$74], [%588, %$75] ; # Tail0
  %595 = phi i64 [%565, %$74], [%587, %$75] ; # Tail1
  %596 = phi i64 [%566, %$74], [%589, %$75] ; # Last
  br label %$69
$70:
  %597 = phi i64 [%549, %$67] ; # B
  %598 = phi i64 [%550, %$67] ; # A
  %599 = phi i64 [%551, %$67] ; # E
  %600 = phi i64 [%552, %$67] ; # P
  %601 = phi i64 [%553, %$67] ; # Tail0
  %602 = phi i64 [%554, %$67] ; # Tail1
  %603 = phi i64 [%555, %$67] ; # Last
; # (val In0)
  %604 = inttoptr i64 %397 to i64*
  %605 = load i64, i64* %604
; # (atom (val In0))
  %606 = and i64 %605, 15
  %607 = icmp ne i64 %606, 0
  br i1 %607, label %$78, label %$77
$78:
  %608 = phi i64 [%597, %$70] ; # B
  %609 = phi i64 [%598, %$70] ; # A
  %610 = phi i64 [%599, %$70] ; # E
  %611 = phi i64 [%600, %$70] ; # P
  %612 = phi i64 [%601, %$70] ; # Tail0
  %613 = phi i64 [%602, %$70] ; # Tail1
  %614 = phi i64 [%603, %$70] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %615 = inttoptr i64 %405 to i64*
  %616 = load i64, i64* %615
; # (cdr (setq P (val In1)))
  %617 = inttoptr i64 %616 to i64*
  %618 = getelementptr i64, i64* %617, i32 1
  %619 = load i64, i64* %618
  %620 = inttoptr i64 %405 to i64*
  store i64 %619, i64* %620
; # (when (lt0 (cmpSort (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %621 = inttoptr i64 %616 to i64*
  %622 = load i64, i64* %621
; # (cmpSort (car P) Last)
  %623 = inttoptr i64 %609 to i64*
  %624 = getelementptr i64, i64* %623, i32 3
  store i64 %622, i64* %624
  %625 = inttoptr i64 %608 to i64*
  %626 = getelementptr i64, i64* %625, i32 3
  store i64 %614, i64* %626
  %627 = call i64 @evList(i64 %610)
  %628 = icmp eq i64 %627, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %628, label %$79, label %$80
$79:
  br label %$81
$80:
  br label %$81
$81:
  %629 = phi i64 [0, %$79], [-1, %$80] ; # ->
; # (lt0 (cmpSort (car P) Last))
  %630 = icmp slt i64 %629, 0
  br i1 %630, label %$82, label %$83
$82:
  %631 = phi i64 [%608, %$81] ; # B
  %632 = phi i64 [%609, %$81] ; # A
  %633 = phi i64 [%610, %$81] ; # E
  %634 = phi i64 [%616, %$81] ; # P
  %635 = phi i64 [%612, %$81] ; # Tail0
  %636 = phi i64 [%613, %$81] ; # Tail1
  %637 = phi i64 [%614, %$81] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$83
$83:
  %638 = phi i64 [%608, %$81], [%631, %$82] ; # B
  %639 = phi i64 [%609, %$81], [%632, %$82] ; # A
  %640 = phi i64 [%610, %$81], [%633, %$82] ; # E
  %641 = phi i64 [%616, %$81], [%634, %$82] ; # P
  %642 = phi i64 [%612, %$81], [%636, %$82] ; # Tail0
  %643 = phi i64 [%613, %$81], [%635, %$82] ; # Tail1
  %644 = phi i64 [%614, %$81], [%637, %$82] ; # Last
  br label %$69
$77:
  %645 = phi i64 [%597, %$70] ; # B
  %646 = phi i64 [%598, %$70] ; # A
  %647 = phi i64 [%599, %$70] ; # E
  %648 = phi i64 [%600, %$70] ; # P
  %649 = phi i64 [%601, %$70] ; # Tail0
  %650 = phi i64 [%602, %$70] ; # Tail1
  %651 = phi i64 [%603, %$70] ; # Last
; # (caar In0)
  %652 = inttoptr i64 %397 to i64*
  %653 = load i64, i64* %652
  %654 = inttoptr i64 %653 to i64*
  %655 = load i64, i64* %654
; # (cmpSort (caar In0) Last)
  %656 = inttoptr i64 %646 to i64*
  %657 = getelementptr i64, i64* %656, i32 3
  store i64 %655, i64* %657
  %658 = inttoptr i64 %645 to i64*
  %659 = getelementptr i64, i64* %658, i32 3
  store i64 %651, i64* %659
  %660 = call i64 @evList(i64 %647)
  %661 = icmp eq i64 %660, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %661, label %$84, label %$85
$84:
  br label %$86
$85:
  br label %$86
$86:
  %662 = phi i64 [0, %$84], [-1, %$85] ; # ->
; # (lt0 (cmpSort (caar In0) Last))
  %663 = icmp slt i64 %662, 0
  br i1 %663, label %$88, label %$87
$88:
  %664 = phi i64 [%645, %$86] ; # B
  %665 = phi i64 [%646, %$86] ; # A
  %666 = phi i64 [%647, %$86] ; # E
  %667 = phi i64 [%648, %$86] ; # P
  %668 = phi i64 [%649, %$86] ; # Tail0
  %669 = phi i64 [%650, %$86] ; # Tail1
  %670 = phi i64 [%651, %$86] ; # Last
; # (if (ge0 (cmpSort (caar In1) Last)) (set In1 (cdr (setq P (val In...
; # (caar In1)
  %671 = inttoptr i64 %405 to i64*
  %672 = load i64, i64* %671
  %673 = inttoptr i64 %672 to i64*
  %674 = load i64, i64* %673
; # (cmpSort (caar In1) Last)
  %675 = inttoptr i64 %665 to i64*
  %676 = getelementptr i64, i64* %675, i32 3
  store i64 %674, i64* %676
  %677 = inttoptr i64 %664 to i64*
  %678 = getelementptr i64, i64* %677, i32 3
  store i64 %670, i64* %678
  %679 = call i64 @evList(i64 %666)
  %680 = icmp eq i64 %679, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %680, label %$89, label %$90
$89:
  br label %$91
$90:
  br label %$91
$91:
  %681 = phi i64 [0, %$89], [-1, %$90] ; # ->
; # (ge0 (cmpSort (caar In1) Last))
  %682 = icmp sge i64 %681, 0
  br i1 %682, label %$92, label %$93
$92:
  %683 = phi i64 [%664, %$91] ; # B
  %684 = phi i64 [%665, %$91] ; # A
  %685 = phi i64 [%666, %$91] ; # E
  %686 = phi i64 [%667, %$91] ; # P
  %687 = phi i64 [%668, %$91] ; # Tail0
  %688 = phi i64 [%669, %$91] ; # Tail1
  %689 = phi i64 [%670, %$91] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %690 = inttoptr i64 %405 to i64*
  %691 = load i64, i64* %690
; # (cdr (setq P (val In1)))
  %692 = inttoptr i64 %691 to i64*
  %693 = getelementptr i64, i64* %692, i32 1
  %694 = load i64, i64* %693
  %695 = inttoptr i64 %405 to i64*
  store i64 %694, i64* %695
  br label %$94
$93:
  %696 = phi i64 [%664, %$91] ; # B
  %697 = phi i64 [%665, %$91] ; # A
  %698 = phi i64 [%666, %$91] ; # E
  %699 = phi i64 [%667, %$91] ; # P
  %700 = phi i64 [%668, %$91] ; # Tail0
  %701 = phi i64 [%669, %$91] ; # Tail1
  %702 = phi i64 [%670, %$91] ; # Last
; # (if (lt0 (cmpSort (caar In0) (caar In1))) (set In0 (cdr (setq P (...
; # (caar In0)
  %703 = inttoptr i64 %397 to i64*
  %704 = load i64, i64* %703
  %705 = inttoptr i64 %704 to i64*
  %706 = load i64, i64* %705
; # (caar In1)
  %707 = inttoptr i64 %405 to i64*
  %708 = load i64, i64* %707
  %709 = inttoptr i64 %708 to i64*
  %710 = load i64, i64* %709
; # (cmpSort (caar In0) (caar In1))
  %711 = inttoptr i64 %697 to i64*
  %712 = getelementptr i64, i64* %711, i32 3
  store i64 %706, i64* %712
  %713 = inttoptr i64 %696 to i64*
  %714 = getelementptr i64, i64* %713, i32 3
  store i64 %710, i64* %714
  %715 = call i64 @evList(i64 %698)
  %716 = icmp eq i64 %715, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %716, label %$95, label %$96
$95:
  br label %$97
$96:
  br label %$97
$97:
  %717 = phi i64 [0, %$95], [-1, %$96] ; # ->
; # (lt0 (cmpSort (caar In0) (caar In1)))
  %718 = icmp slt i64 %717, 0
  br i1 %718, label %$98, label %$99
$98:
  %719 = phi i64 [%696, %$97] ; # B
  %720 = phi i64 [%697, %$97] ; # A
  %721 = phi i64 [%698, %$97] ; # E
  %722 = phi i64 [%699, %$97] ; # P
  %723 = phi i64 [%700, %$97] ; # Tail0
  %724 = phi i64 [%701, %$97] ; # Tail1
  %725 = phi i64 [%702, %$97] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %726 = inttoptr i64 %397 to i64*
  %727 = load i64, i64* %726
; # (cdr (setq P (val In0)))
  %728 = inttoptr i64 %727 to i64*
  %729 = getelementptr i64, i64* %728, i32 1
  %730 = load i64, i64* %729
  %731 = inttoptr i64 %397 to i64*
  store i64 %730, i64* %731
  br label %$100
$99:
  %732 = phi i64 [%696, %$97] ; # B
  %733 = phi i64 [%697, %$97] ; # A
  %734 = phi i64 [%698, %$97] ; # E
  %735 = phi i64 [%699, %$97] ; # P
  %736 = phi i64 [%700, %$97] ; # Tail0
  %737 = phi i64 [%701, %$97] ; # Tail1
  %738 = phi i64 [%702, %$97] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %739 = inttoptr i64 %405 to i64*
  %740 = load i64, i64* %739
; # (cdr (setq P (val In1)))
  %741 = inttoptr i64 %740 to i64*
  %742 = getelementptr i64, i64* %741, i32 1
  %743 = load i64, i64* %742
  %744 = inttoptr i64 %405 to i64*
  store i64 %743, i64* %744
  br label %$100
$100:
  %745 = phi i64 [%719, %$98], [%732, %$99] ; # B
  %746 = phi i64 [%720, %$98], [%733, %$99] ; # A
  %747 = phi i64 [%721, %$98], [%734, %$99] ; # E
  %748 = phi i64 [%727, %$98], [%740, %$99] ; # P
  %749 = phi i64 [%723, %$98], [%736, %$99] ; # Tail0
  %750 = phi i64 [%724, %$98], [%737, %$99] ; # Tail1
  %751 = phi i64 [%725, %$98], [%738, %$99] ; # Last
  %752 = phi i64 [%730, %$98], [%743, %$99] ; # ->
; # (xchg 'Tail0 'Tail1)
  br label %$94
$94:
  %753 = phi i64 [%683, %$92], [%745, %$100] ; # B
  %754 = phi i64 [%684, %$92], [%746, %$100] ; # A
  %755 = phi i64 [%685, %$92], [%747, %$100] ; # E
  %756 = phi i64 [%691, %$92], [%748, %$100] ; # P
  %757 = phi i64 [%687, %$92], [%750, %$100] ; # Tail0
  %758 = phi i64 [%688, %$92], [%749, %$100] ; # Tail1
  %759 = phi i64 [%689, %$92], [%751, %$100] ; # Last
  %760 = phi i64 [%694, %$92], [%749, %$100] ; # ->
  br label %$69
$87:
  %761 = phi i64 [%645, %$86] ; # B
  %762 = phi i64 [%646, %$86] ; # A
  %763 = phi i64 [%647, %$86] ; # E
  %764 = phi i64 [%648, %$86] ; # P
  %765 = phi i64 [%649, %$86] ; # Tail0
  %766 = phi i64 [%650, %$86] ; # Tail1
  %767 = phi i64 [%651, %$86] ; # Last
; # (caar In1)
  %768 = inttoptr i64 %405 to i64*
  %769 = load i64, i64* %768
  %770 = inttoptr i64 %769 to i64*
  %771 = load i64, i64* %770
; # (cmpSort (caar In1) Last)
  %772 = inttoptr i64 %762 to i64*
  %773 = getelementptr i64, i64* %772, i32 3
  store i64 %771, i64* %773
  %774 = inttoptr i64 %761 to i64*
  %775 = getelementptr i64, i64* %774, i32 3
  store i64 %767, i64* %775
  %776 = call i64 @evList(i64 %763)
  %777 = icmp eq i64 %776, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %777, label %$101, label %$102
$101:
  br label %$103
$102:
  br label %$103
$103:
  %778 = phi i64 [0, %$101], [-1, %$102] ; # ->
; # (lt0 (cmpSort (caar In1) Last))
  %779 = icmp slt i64 %778, 0
  br i1 %779, label %$105, label %$104
$105:
  %780 = phi i64 [%761, %$103] ; # B
  %781 = phi i64 [%762, %$103] ; # A
  %782 = phi i64 [%763, %$103] ; # E
  %783 = phi i64 [%764, %$103] ; # P
  %784 = phi i64 [%765, %$103] ; # Tail0
  %785 = phi i64 [%766, %$103] ; # Tail1
  %786 = phi i64 [%767, %$103] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %787 = inttoptr i64 %397 to i64*
  %788 = load i64, i64* %787
; # (cdr (setq P (val In0)))
  %789 = inttoptr i64 %788 to i64*
  %790 = getelementptr i64, i64* %789, i32 1
  %791 = load i64, i64* %790
  %792 = inttoptr i64 %397 to i64*
  store i64 %791, i64* %792
  br label %$69
$104:
  %793 = phi i64 [%761, %$103] ; # B
  %794 = phi i64 [%762, %$103] ; # A
  %795 = phi i64 [%763, %$103] ; # E
  %796 = phi i64 [%764, %$103] ; # P
  %797 = phi i64 [%765, %$103] ; # Tail0
  %798 = phi i64 [%766, %$103] ; # Tail1
  %799 = phi i64 [%767, %$103] ; # Last
; # (caar In0)
  %800 = inttoptr i64 %397 to i64*
  %801 = load i64, i64* %800
  %802 = inttoptr i64 %801 to i64*
  %803 = load i64, i64* %802
; # (caar In1)
  %804 = inttoptr i64 %405 to i64*
  %805 = load i64, i64* %804
  %806 = inttoptr i64 %805 to i64*
  %807 = load i64, i64* %806
; # (cmpSort (caar In0) (caar In1))
  %808 = inttoptr i64 %794 to i64*
  %809 = getelementptr i64, i64* %808, i32 3
  store i64 %803, i64* %809
  %810 = inttoptr i64 %793 to i64*
  %811 = getelementptr i64, i64* %810, i32 3
  store i64 %807, i64* %811
  %812 = call i64 @evList(i64 %795)
  %813 = icmp eq i64 %812, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %813, label %$106, label %$107
$106:
  br label %$108
$107:
  br label %$108
$108:
  %814 = phi i64 [0, %$106], [-1, %$107] ; # ->
; # (lt0 (cmpSort (caar In0) (caar In1)))
  %815 = icmp slt i64 %814, 0
  br i1 %815, label %$110, label %$109
$110:
  %816 = phi i64 [%793, %$108] ; # B
  %817 = phi i64 [%794, %$108] ; # A
  %818 = phi i64 [%795, %$108] ; # E
  %819 = phi i64 [%796, %$108] ; # P
  %820 = phi i64 [%797, %$108] ; # Tail0
  %821 = phi i64 [%798, %$108] ; # Tail1
  %822 = phi i64 [%799, %$108] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %823 = inttoptr i64 %397 to i64*
  %824 = load i64, i64* %823
; # (cdr (setq P (val In0)))
  %825 = inttoptr i64 %824 to i64*
  %826 = getelementptr i64, i64* %825, i32 1
  %827 = load i64, i64* %826
  %828 = inttoptr i64 %397 to i64*
  store i64 %827, i64* %828
  br label %$69
$109:
  %829 = phi i64 [%793, %$108] ; # B
  %830 = phi i64 [%794, %$108] ; # A
  %831 = phi i64 [%795, %$108] ; # E
  %832 = phi i64 [%796, %$108] ; # P
  %833 = phi i64 [%797, %$108] ; # Tail0
  %834 = phi i64 [%798, %$108] ; # Tail1
  %835 = phi i64 [%799, %$108] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %836 = inttoptr i64 %405 to i64*
  %837 = load i64, i64* %836
; # (cdr (setq P (val In1)))
  %838 = inttoptr i64 %837 to i64*
  %839 = getelementptr i64, i64* %838, i32 1
  %840 = load i64, i64* %839
  %841 = inttoptr i64 %405 to i64*
  store i64 %840, i64* %841
  br label %$69
$69:
  %842 = phi i64 [%590, %$76], [%638, %$83], [%753, %$94], [%780, %$105], [%816, %$110], [%829, %$109] ; # B
  %843 = phi i64 [%591, %$76], [%639, %$83], [%754, %$94], [%781, %$105], [%817, %$110], [%830, %$109] ; # A
  %844 = phi i64 [%592, %$76], [%640, %$83], [%755, %$94], [%782, %$105], [%818, %$110], [%831, %$109] ; # E
  %845 = phi i64 [%593, %$76], [%641, %$83], [%756, %$94], [%788, %$105], [%824, %$110], [%837, %$109] ; # P
  %846 = phi i64 [%594, %$76], [%642, %$83], [%757, %$94], [%784, %$105], [%820, %$110], [%833, %$109] ; # Tail0
  %847 = phi i64 [%595, %$76], [%643, %$83], [%758, %$94], [%785, %$105], [%821, %$110], [%834, %$109] ; # Tail1
  %848 = phi i64 [%596, %$76], [%644, %$83], [%759, %$94], [%786, %$105], [%822, %$110], [%835, %$109] ; # Last
; # (if Tail0 (set Tail0 P) (set Out1 P))
  %849 = icmp ne i64 %846, 0
  br i1 %849, label %$111, label %$112
$111:
  %850 = phi i64 [%842, %$69] ; # B
  %851 = phi i64 [%843, %$69] ; # A
  %852 = phi i64 [%844, %$69] ; # E
  %853 = phi i64 [%845, %$69] ; # P
  %854 = phi i64 [%846, %$69] ; # Tail0
  %855 = phi i64 [%847, %$69] ; # Tail1
  %856 = phi i64 [%848, %$69] ; # Last
; # (set Tail0 P)
  %857 = inttoptr i64 %854 to i64*
  store i64 %853, i64* %857
  br label %$113
$112:
  %858 = phi i64 [%842, %$69] ; # B
  %859 = phi i64 [%843, %$69] ; # A
  %860 = phi i64 [%844, %$69] ; # E
  %861 = phi i64 [%845, %$69] ; # P
  %862 = phi i64 [%846, %$69] ; # Tail0
  %863 = phi i64 [%847, %$69] ; # Tail1
  %864 = phi i64 [%848, %$69] ; # Last
; # (set Out1 P)
  %865 = inttoptr i64 %389 to i64*
  store i64 %861, i64* %865
  br label %$113
$113:
  %866 = phi i64 [%850, %$111], [%858, %$112] ; # B
  %867 = phi i64 [%851, %$111], [%859, %$112] ; # A
  %868 = phi i64 [%852, %$111], [%860, %$112] ; # E
  %869 = phi i64 [%853, %$111], [%861, %$112] ; # P
  %870 = phi i64 [%854, %$111], [%862, %$112] ; # Tail0
  %871 = phi i64 [%855, %$111], [%863, %$112] ; # Tail1
  %872 = phi i64 [%856, %$111], [%864, %$112] ; # Last
  %873 = phi i64 [%853, %$111], [%861, %$112] ; # ->
; # (ofs (if Tail0 (set Tail0 P) (set Out1 P)) 1)
  %874 = add i64 %873, 8
; # (set 2 P $Nil)
  %875 = inttoptr i64 %869 to i64*
  %876 = getelementptr i64, i64* %875, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %876
; # (car P)
  %877 = inttoptr i64 %869 to i64*
  %878 = load i64, i64* %877
  br label %$64
$68:
  %879 = phi i64 [%541, %$65] ; # B
  %880 = phi i64 [%542, %$65] ; # A
  %881 = phi i64 [%543, %$65] ; # E
  %882 = phi i64 [%544, %$65] ; # P
  %883 = phi i64 [%545, %$65] ; # Tail0
  %884 = phi i64 [%546, %$65] ; # Tail1
  %885 = phi i64 [%547, %$65] ; # Last
; # (? (atom (val Out1)) (val Out0))
; # (val Out1)
  %886 = inttoptr i64 %389 to i64*
  %887 = load i64, i64* %886
; # (atom (val Out1))
  %888 = and i64 %887, 15
  %889 = icmp ne i64 %888, 0
  br i1 %889, label %$116, label %$114
$116:
  %890 = phi i64 [%879, %$68] ; # B
  %891 = phi i64 [%880, %$68] ; # A
  %892 = phi i64 [%881, %$68] ; # E
  %893 = phi i64 [%882, %$68] ; # P
; # (val Out0)
  %894 = inttoptr i64 %381 to i64*
  %895 = load i64, i64* %894
  br label %$115
$114:
  %896 = phi i64 [%879, %$68] ; # B
  %897 = phi i64 [%880, %$68] ; # A
  %898 = phi i64 [%881, %$68] ; # E
  %899 = phi i64 [%882, %$68] ; # P
  br label %$55
$115:
  %900 = phi i64 [%890, %$116] ; # B
  %901 = phi i64 [%891, %$116] ; # A
  %902 = phi i64 [%892, %$116] ; # E
  %903 = phi i64 [%893, %$116] ; # P
  %904 = phi i64 [%895, %$116] ; # ->
; # (drop *Safe)
  %905 = inttoptr i64 %381 to i64*
  %906 = getelementptr i64, i64* %905, i32 1
  %907 = load i64, i64* %906
  %908 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %907, i64* %908
  br label %$7
$7:
  %909 = phi i64 [%15, %$9], [%379, %$48], [%904, %$115] ; # ->
  ret i64 %909
}

define i64 @_quit(i64) align 8 {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) Msg (bufString Nm (b8 ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (bufSize Nm)
  %6 = call i64 @bufSize(i64 %5)
; # (b8 (bufSize Nm))
  %7 = alloca i8, i64 %6
; # (bufString Nm (b8 (bufSize Nm)))
  %8 = call i8* @bufString(i64 %5, i8* %7)
; # (if (atom (shift X)) 0 (eval (car X)))
; # (shift X)
  %9 = inttoptr i64 %3 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (atom (shift X))
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%11, %$1] ; # X
  br label %$4
$3:
  %15 = phi i64 [%11, %$1] ; # X
; # (car X)
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (eval (car X))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$7, label %$6
$7:
  br label %$5
$6:
  %20 = and i64 %17, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$8
$9:
  %22 = inttoptr i64 %17 to i64*
  %23 = load i64, i64* %22
  br label %$5
$8:
  %24 = call i64 @evList(i64 %17)
  br label %$5
$5:
  %25 = phi i64 [%17, %$7], [%23, %$9], [%24, %$8] ; # ->
  br label %$4
$4:
  %26 = phi i64 [%14, %$2], [%15, %$5] ; # X
  %27 = phi i64 [0, %$2], [%25, %$5] ; # ->
; # (err 0 (if (atom (shift X)) 0 (eval (car X))) ($ "%s") Msg)
  call void @err(i64 0, i64 %27, i8* bitcast ([3 x i8]* @$86 to i8*), i8* %8)
  unreachable
}

define i64 @_sys(i64) align 8 {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) S (bufString Nm (b8 (b...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (bufSize Nm)
  %6 = call i64 @bufSize(i64 %5)
; # (b8 (bufSize Nm))
  %7 = alloca i8, i64 %6
; # (bufString Nm (b8 (bufSize Nm)))
  %8 = call i8* @bufString(i64 %5, i8* %7)
; # (if (atom (shift X)) (mkStr (getenv S)) (let (Y (evSym X) Nm2 (xN...
; # (shift X)
  %9 = inttoptr i64 %3 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (atom (shift X))
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%11, %$1] ; # X
; # (getenv S)
  %15 = call i8* @getenv(i8* %8)
; # (mkStr (getenv S))
  %16 = call i64 @mkStr(i8* %15)
  br label %$4
$3:
  %17 = phi i64 [%11, %$1] ; # X
; # (let (Y (evSym X) Nm2 (xName Exe Y)) (if (setenv S (bufString Nm2...
; # (evSym X)
  %18 = call i64 @evSym(i64 %17)
; # (xName Exe Y)
  %19 = call i64 @xName(i64 %0, i64 %18)
; # (if (setenv S (bufString Nm2 (b8 (bufSize Nm2))) 1) $Nil Y)
; # (bufSize Nm2)
  %20 = call i64 @bufSize(i64 %19)
; # (b8 (bufSize Nm2))
  %21 = alloca i8, i64 %20
; # (bufString Nm2 (b8 (bufSize Nm2)))
  %22 = call i8* @bufString(i64 %19, i8* %21)
; # (setenv S (bufString Nm2 (b8 (bufSize Nm2))) 1)
  %23 = call i32 @setenv(i8* %8, i8* %22, i32 1)
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %$5, label %$6
$5:
  %25 = phi i64 [%17, %$3] ; # X
  br label %$7
$6:
  %26 = phi i64 [%17, %$3] ; # X
  br label %$7
$7:
  %27 = phi i64 [%25, %$5], [%26, %$6] ; # X
  %28 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%18, %$6] ; # ->
  br label %$4
$4:
  %29 = phi i64 [%14, %$2], [%27, %$7] ; # X
  %30 = phi i64 [%16, %$2], [%28, %$7] ; # ->
  ret i64 %30
}

define i64 @_pwd(i64) align 8 {
$1:
; # (let P (getcwd null 0) (if P (prog1 (mkStr P) (free P)) $Nil))
; # (getcwd null 0)
  %1 = call i8* @getcwd(i8* null, i64 0)
; # (if P (prog1 (mkStr P) (free P)) $Nil)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$2, label %$3
$2:
; # (prog1 (mkStr P) (free P))
; # (mkStr P)
  %3 = call i64 @mkStr(i8* %1)
; # (free P)
  call void @free(i8* %1)
  br label %$4
$3:
  br label %$4
$4:
  %4 = phi i64 [%3, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %4
}

define i64 @_cd(i64) align 8 {
$1:
; # (let (Nm (xName Exe (evSym (cdr Exe))) P (getcwd null 0)) (if P (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym (cdr Exe)))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (getcwd null 0)
  %6 = call i8* @getcwd(i8* null, i64 0)
; # (if P (prog1 (if (lt0 (chdir (pathString Nm (b8 (pathSize Nm)))))...
  %7 = icmp ne i8* %6, null
  br i1 %7, label %$2, label %$3
$2:
; # (prog1 (if (lt0 (chdir (pathString Nm (b8 (pathSize Nm))))) $Nil ...
; # (if (lt0 (chdir (pathString Nm (b8 (pathSize Nm))))) $Nil (mkStr ...
; # (pathSize Nm)
  %8 = call i64 @pathSize(i64 %5)
; # (b8 (pathSize Nm))
  %9 = alloca i8, i64 %8
; # (pathString Nm (b8 (pathSize Nm)))
  %10 = call i8* @pathString(i64 %5, i8* %9)
; # (chdir (pathString Nm (b8 (pathSize Nm))))
  %11 = call i32 @chdir(i8* %10)
; # (lt0 (chdir (pathString Nm (b8 (pathSize Nm)))))
  %12 = icmp slt i32 %11, 0
  br i1 %12, label %$5, label %$6
$5:
  br label %$7
$6:
; # (mkStr P)
  %13 = call i64 @mkStr(i8* %6)
  br label %$7
$7:
  %14 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%13, %$6] ; # ->
; # (free P)
  call void @free(i8* %6)
  br label %$4
$3:
  br label %$4
$4:
  %15 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %15
}

define i64 @_ctty(i64) align 8 {
$1:
; # (let X (eval (cadr Exe)) (cond ((cnt? X) (set $TtyPid (i32 (int @...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((cnt? X) (set $TtyPid (i32 (int @))) X) ((nil? X) (let Pty...
; # (cnt? X)
  %14 = and i64 %13, 2
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
; # (set $TtyPid (i32 (int @)))
; # (int @)
  %16 = lshr i64 %13, 4
; # (i32 (int @))
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* @$TtyPid
  br label %$7
$8:
; # (nil? X)
  %18 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$11, label %$10
$11:
; # (let Pty (b32 2) (when (lt0 (openpty Pty (ofs Pty 1) null null nu...
; # (b32 2)
  %19 = alloca i32, i64 2
; # (when (lt0 (openpty Pty (ofs Pty 1) null null null)) (err Exe 0 (...
; # (ofs Pty 1)
  %20 = getelementptr i32, i32* %19, i32 1
; # (openpty Pty (ofs Pty 1) null null null)
  %21 = call i32 @openpty(i32* %19, i32* %20, i8* null, i8* null, i8* null)
; # (lt0 (openpty Pty (ofs Pty 1) null null null))
  %22 = icmp slt i32 %21, 0
  br i1 %22, label %$12, label %$13
$12:
; # (strErrno)
  %23 = call i8* @strErrno()
; # (err Exe 0 ($ "Can't open PTY: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([19 x i8]* @$87 to i8*), i8* %23)
  unreachable
$13:
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (close (val 2 Pty)) (l...
; # (fork)
  %24 = call i32 @fork()
; # (lt0 (fork))
  %25 = icmp slt i32 %24, 0
  br i1 %25, label %$16, label %$15
$16:
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$15:
; # (=0 @)
  %26 = icmp eq i32 %24, 0
  br i1 %26, label %$18, label %$17
$18:
; # (val 2 Pty)
  %27 = getelementptr i32, i32* %19, i32 1
  %28 = load i32, i32* %27
; # (close (val 2 Pty))
  %29 = call i32 @close(i32 %28)
; # (let (Fd (val Pty) Poll (b64 2) Buf (b8 BUFSIZ)) (loop (pollIn 0 ...
; # (val Pty)
  %30 = load i32, i32* %19
; # (b64 2)
  %31 = alloca i64, i64 2
; # (b8 BUFSIZ)
  %32 = alloca i8, i64 4096
; # (loop (pollIn 0 Poll) (pollIn Fd (ofs Poll 1)) (if (lt0 (poll Pol...
  br label %$19
$19:
; # (pollIn 0 Poll)
  call void @pollIn(i32 0, i64* %31)
; # (ofs Poll 1)
  %33 = getelementptr i64, i64* %31, i32 1
; # (pollIn Fd (ofs Poll 1))
  call void @pollIn(i32 %30, i64* %33)
; # (if (lt0 (poll Poll 2 -1)) (? (<> (gErrno) EINTR)) (when (readyIn...
; # (poll Poll 2 -1)
  %34 = call i32 @poll(i64* %31, i32 2, i64 -1)
; # (lt0 (poll Poll 2 -1))
  %35 = icmp slt i32 %34, 0
  br i1 %35, label %$20, label %$21
$20:
; # (? (<> (gErrno) EINTR))
; # (gErrno)
  %36 = call i32 @gErrno()
; # (<> (gErrno) EINTR)
  %37 = icmp ne i32 %36, 2
  br i1 %37, label %$24, label %$23
$23:
  br label %$22
$21:
; # (when (readyIn Poll) (let N (read 0 Buf BUFSIZ) (? (le0 N)) (writ...
; # (readyIn Poll)
  %38 = call i1 @readyIn(i64* %31)
  br i1 %38, label %$25, label %$26
$25:
; # (let N (read 0 Buf BUFSIZ) (? (le0 N)) (write Fd Buf N))
; # (read 0 Buf BUFSIZ)
  %39 = call i64 @read(i32 0, i8* %32, i64 4096)
; # (? (le0 N))
; # (le0 N)
  %40 = icmp sle i64 %39, 0
  br i1 %40, label %$24, label %$27
$27:
; # (write Fd Buf N)
  %41 = call i64 @write(i32 %30, i8* %32, i64 %39)
  br label %$26
$26:
; # (when (readyIn (ofs Poll 1)) (let N (read Fd Buf BUFSIZ) (? (le0 ...
; # (ofs Poll 1)
  %42 = getelementptr i64, i64* %31, i32 1
; # (readyIn (ofs Poll 1))
  %43 = call i1 @readyIn(i64* %42)
  br i1 %43, label %$28, label %$29
$28:
; # (let N (read Fd Buf BUFSIZ) (? (le0 N)) (write 1 Buf N))
; # (read Fd Buf BUFSIZ)
  %44 = call i64 @read(i32 %30, i8* %32, i64 4096)
; # (? (le0 N))
; # (le0 N)
  %45 = icmp sle i64 %44, 0
  br i1 %45, label %$24, label %$30
$30:
; # (write 1 Buf N)
  %46 = call i64 @write(i32 1, i8* %32, i64 %44)
  br label %$29
$29:
  br label %$22
$22:
  br label %$19
$24:
  %47 = phi i64 [0, %$20], [0, %$25], [0, %$28] ; # ->
; # (exit 0)
  call void @exit(i32 0)
  unreachable
$17:
  br label %$14
$14:
  %48 = phi i64 [0, %$17] ; # ->
; # (val Pty)
  %49 = load i32, i32* %19
; # (close (val Pty))
  %50 = call i32 @close(i32 %49)
; # (val 2 Pty)
  %51 = getelementptr i32, i32* %19, i32 1
  %52 = load i32, i32* %51
; # (login_tty (val 2 Pty))
  %53 = call i32 @login_tty(i32 %52)
; # (val SIGINT Sig)
  %54 = getelementptr i32, i32* @Sig, i32 1
  %55 = load i32, i32* %54
; # (val SigIgn)
  %56 = load i8*, i8** @SigIgn
; # (signal (val SIGINT Sig) (val SigIgn))
  %57 = call i8* @signal(i32 %55, i8* %56)
; # (val $InFiles)
  %58 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %59 = load i8*, i8** %58
; # ((inFile (val (val $InFiles))) tty YES)
  %60 = getelementptr i8, i8* %59, i32 4128
  %61 = bitcast i8* %60 to i1*
  store i1 1, i1* %61
; # (val $OutFiles)
  %62 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %63 = getelementptr i8*, i8** %62, i32 1
  %64 = load i8*, i8** %63
; # ((outFile (val 2 (val $OutFiles))) tty YES)
  %65 = getelementptr i8, i8* %64, i32 4104
  %66 = bitcast i8* %65 to i1*
  store i1 1, i1* %66
; # (val $OutFiles)
  %67 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %68 = getelementptr i8*, i8** %67, i32 2
  %69 = load i8*, i8** %68
; # ((outFile (val 3 (val $OutFiles))) tty YES)
  %70 = getelementptr i8, i8* %69, i32 4104
  %71 = bitcast i8* %70 to i1*
  store i1 1, i1* %71
; # (set Tio (=0 (tcgetattr 0 OrgTermio)))
; # (tcgetattr 0 OrgTermio)
  %72 = call i32 @tcgetattr(i32 0, i8* @OrgTermio)
; # (=0 (tcgetattr 0 OrgTermio))
  %73 = icmp eq i32 %72, 0
  store i1 %73, i1* @Tio
  br label %$7
$10:
; # (let Nm (xName Exe (xSym X)) (if (reopenTty (bufString Nm (b8 (bu...
; # (xSym X)
  %74 = call i64 @xSym(i64 %13)
; # (xName Exe (xSym X))
  %75 = call i64 @xName(i64 %0, i64 %74)
; # (if (reopenTty (bufString Nm (b8 (bufSize Nm)))) (let (In: (inFil...
; # (bufSize Nm)
  %76 = call i64 @bufSize(i64 %75)
; # (b8 (bufSize Nm))
  %77 = alloca i8, i64 %76
; # (bufString Nm (b8 (bufSize Nm)))
  %78 = call i8* @bufString(i64 %75, i8* %77)
; # (reopenTty (bufString Nm (b8 (bufSize Nm))))
  %79 = call i1 @reopenTty(i8* %78)
  br i1 %79, label %$31, label %$32
$31:
; # (let (In: (inFile (val (val $InFiles))) Out: (outFile (val 2 (val...
; # (val $InFiles)
  %80 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %81 = load i8*, i8** %80
; # (val $OutFiles)
  %82 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %83 = getelementptr i8*, i8** %82, i32 1
  %84 = load i8*, i8** %83
; # (In: chr 0)
  %85 = getelementptr i8, i8* %81, i32 12
  %86 = bitcast i8* %85 to i32*
  store i32 0, i32* %86
; # (In: ix (In: cnt 0))
  %87 = getelementptr i8, i8* %81, i32 24
  %88 = bitcast i8* %87 to i32*
  %89 = getelementptr i8, i8* %81, i32 28
  %90 = bitcast i8* %89 to i32*
  store i32 0, i32* %90
  store i32 0, i32* %88
; # (In: tty YES)
  %91 = getelementptr i8, i8* %81, i32 4128
  %92 = bitcast i8* %91 to i1*
  store i1 1, i1* %92
; # (set Tio (=0 (tcgetattr 0 OrgTermio)))
; # (tcgetattr 0 OrgTermio)
  %93 = call i32 @tcgetattr(i32 0, i8* @OrgTermio)
; # (=0 (tcgetattr 0 OrgTermio))
  %94 = icmp eq i32 %93, 0
  store i1 %94, i1* @Tio
; # (Out: ix 0)
  %95 = getelementptr i8, i8* %84, i32 4
  %96 = bitcast i8* %95 to i32*
  store i32 0, i32* %96
; # (Out: tty YES)
  %97 = getelementptr i8, i8* %84, i32 4104
  %98 = bitcast i8* %97 to i1*
  store i1 1, i1* %98
; # (val $OutFiles)
  %99 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %100 = getelementptr i8*, i8** %99, i32 2
  %101 = load i8*, i8** %100
; # ((outFile (val 3 (val $OutFiles))) tty YES)
  %102 = getelementptr i8, i8* %101, i32 4104
  %103 = bitcast i8* %102 to i1*
  store i1 1, i1* %103
  br label %$33
$32:
  br label %$33
$33:
  %104 = phi i64 [%13, %$31], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$32] ; # ->
  br label %$7
$7:
  %105 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$14], [%104, %$33] ; # ->
  ret i64 %105
}

define i64 @_cmd(i64) align 8 {
$1:
; # (if (nil? (evSym (cdr Exe))) (mkStr (val $AV0)) (bufString (xName...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (nil? (evSym (cdr Exe)))
  %5 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$2, label %$3
$2:
; # (val $AV0)
  %6 = load i8*, i8** @$AV0
; # (mkStr (val $AV0))
  %7 = call i64 @mkStr(i8* %6)
  br label %$4
$3:
; # (xName Exe @)
  %8 = call i64 @xName(i64 %0, i64 %4)
; # (val $AV0)
  %9 = load i8*, i8** @$AV0
; # (bufString (xName Exe @) (val $AV0))
  %10 = call i8* @bufString(i64 %8, i8* %9)
  br label %$4
$4:
  %11 = phi i64 [%7, %$2], [%4, %$3] ; # ->
  ret i64 %11
}

define i64 @_dir(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (getDir (if (nil? (evSym X)) ($ ".") (let Nm...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (getDir (if (nil? (evSym X)) ($ ".") (let Nm (xName Exe @) (p...
; # (if (nil? (evSym X)) ($ ".") (let Nm (xName Exe @) (pathString Nm...
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (nil? (evSym X))
  %5 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
  br label %$4
$3:
  %7 = phi i64 [%3, %$1] ; # X
; # (let Nm (xName Exe @) (pathString Nm (b8 (pathSize Nm))))
; # (xName Exe @)
  %8 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %9 = call i64 @pathSize(i64 %8)
; # (b8 (pathSize Nm))
  %10 = alloca i8, i64 %9
; # (pathString Nm (b8 (pathSize Nm)))
  %11 = call i8* @pathString(i64 %8, i8* %10)
  br label %$4
$4:
  %12 = phi i64 [%6, %$2], [%7, %$3] ; # X
  %13 = phi i8* [bitcast ([2 x i8]* @$88 to i8*), %$2], [%11, %$3] ; # ->
; # (getDir (if (nil? (evSym X)) ($ ".") (let Nm (xName Exe @) (pathS...
  %14 = call i8* @getDir(i8* %13)
  %15 = icmp ne i8* %14, null
  br i1 %15, label %$5, label %$6
$5:
  %16 = phi i64 [%12, %$4] ; # X
; # (let (P @ F (eval (car (shift X)))) (when (nil? F) (while (== (va...
; # (shift X)
  %17 = inttoptr i64 %16 to i64*
  %18 = getelementptr i64, i64* %17, i32 1
  %19 = load i64, i64* %18
; # (car (shift X))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (eval (car (shift X)))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$9
$10:
  br label %$8
$9:
  %24 = and i64 %21, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$12, label %$11
$12:
  %26 = inttoptr i64 %21 to i64*
  %27 = load i64, i64* %26
  br label %$8
$11:
  %28 = call i64 @evList(i64 %21)
  br label %$8
$8:
  %29 = phi i64 [%21, %$10], [%27, %$12], [%28, %$11] ; # ->
; # (when (nil? F) (while (== (val P) (char ".")) (unless (setq P (ge...
; # (nil? F)
  %30 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %30, label %$13, label %$14
$13:
  %31 = phi i64 [%19, %$8] ; # X
  %32 = phi i8* [%14, %$8] ; # P
; # (while (== (val P) (char ".")) (unless (setq P (getDir null)) (re...
  br label %$15
$15:
  %33 = phi i64 [%31, %$13], [%43, %$19] ; # X
  %34 = phi i8* [%32, %$13], [%44, %$19] ; # P
; # (val P)
  %35 = load i8, i8* %34
; # (== (val P) (char "."))
  %36 = icmp eq i8 %35, 46
  br i1 %36, label %$16, label %$17
$16:
  %37 = phi i64 [%33, %$15] ; # X
  %38 = phi i8* [%34, %$15] ; # P
; # (unless (setq P (getDir null)) (ret $Nil))
; # (getDir null)
  %39 = call i8* @getDir(i8* null)
  %40 = icmp ne i8* %39, null
  br i1 %40, label %$19, label %$18
$18:
  %41 = phi i64 [%37, %$16] ; # X
  %42 = phi i8* [%39, %$16] ; # P
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
$19:
  %43 = phi i64 [%37, %$16] ; # X
  %44 = phi i8* [%39, %$16] ; # P
  br label %$15
$17:
  %45 = phi i64 [%33, %$15] ; # X
  %46 = phi i8* [%34, %$15] ; # P
  br label %$14
$14:
  %47 = phi i64 [%19, %$8], [%45, %$17] ; # X
  %48 = phi i8* [%14, %$8], [%46, %$17] ; # P
; # (let (Y (cons (mkStr P) $Nil) R (save Y)) (while (setq P (getDir ...
; # (mkStr P)
  %49 = call i64 @mkStr(i8* %48)
; # (cons (mkStr P) $Nil)
  %50 = call i64 @cons(i64 %49, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %52 = load i64, i64* %51
  %53 = alloca i64, i64 2, align 16
  %54 = ptrtoint i64* %53 to i64
  %55 = inttoptr i64 %54 to i64*
  store i64 %50, i64* %55
  %56 = add i64 %54, 8
  %57 = inttoptr i64 %56 to i64*
  store i64 %52, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %58
; # (while (setq P (getDir null)) (unless (and (nil? F) (== (val P) (...
  br label %$20
$20:
  %59 = phi i64 [%47, %$14], [%84, %$26] ; # X
  %60 = phi i8* [%48, %$14], [%85, %$26] ; # P
  %61 = phi i64 [%50, %$14], [%86, %$26] ; # Y
; # (getDir null)
  %62 = call i8* @getDir(i8* null)
  %63 = icmp ne i8* %62, null
  br i1 %63, label %$21, label %$22
$21:
  %64 = phi i64 [%59, %$20] ; # X
  %65 = phi i8* [%62, %$20] ; # P
  %66 = phi i64 [%61, %$20] ; # Y
; # (unless (and (nil? F) (== (val P) (char "."))) (setq Y (set 2 Y (...
; # (and (nil? F) (== (val P) (char ".")))
; # (nil? F)
  %67 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %67, label %$24, label %$23
$24:
  %68 = phi i64 [%64, %$21] ; # X
  %69 = phi i8* [%65, %$21] ; # P
  %70 = phi i64 [%66, %$21] ; # Y
; # (val P)
  %71 = load i8, i8* %69
; # (== (val P) (char "."))
  %72 = icmp eq i8 %71, 46
  br label %$23
$23:
  %73 = phi i64 [%64, %$21], [%68, %$24] ; # X
  %74 = phi i8* [%65, %$21], [%69, %$24] ; # P
  %75 = phi i64 [%66, %$21], [%70, %$24] ; # Y
  %76 = phi i1 [0, %$21], [%72, %$24] ; # ->
  br i1 %76, label %$26, label %$25
$25:
  %77 = phi i64 [%73, %$23] ; # X
  %78 = phi i8* [%74, %$23] ; # P
  %79 = phi i64 [%75, %$23] ; # Y
; # (set 2 Y (cons (mkStr P) $Nil))
; # (mkStr P)
  %80 = call i64 @mkStr(i8* %78)
; # (cons (mkStr P) $Nil)
  %81 = call i64 @cons(i64 %80, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %82 = inttoptr i64 %79 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  store i64 %81, i64* %83
  br label %$26
$26:
  %84 = phi i64 [%73, %$23], [%77, %$25] ; # X
  %85 = phi i8* [%74, %$23], [%78, %$25] ; # P
  %86 = phi i64 [%75, %$23], [%81, %$25] ; # Y
  br label %$20
$22:
  %87 = phi i64 [%59, %$20] ; # X
  %88 = phi i8* [%62, %$20] ; # P
  %89 = phi i64 [%61, %$20] ; # Y
; # (drop *Safe)
  %90 = inttoptr i64 %54 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  %92 = load i64, i64* %91
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %92, i64* %93
  br label %$7
$6:
  %94 = phi i64 [%12, %$4] ; # X
  br label %$7
$7:
  %95 = phi i64 [%87, %$22], [%94, %$6] ; # X
  %96 = phi i64 [%50, %$22], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$6] ; # ->
  ret i64 %96
}

define i64 @_info(i64) align 8 {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (set $At2 (evSym X))) Size (b64 1...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set $At2 (evSym X))
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  store i64 %4, i64* %5
; # (xName Exe (set $At2 (evSym X)))
  %6 = call i64 @xName(i64 %0, i64 %4)
; # (b64 1)
  %7 = alloca i64, i64 1
; # (if (lt0 (fileInfo (nil? (eval (car (shift X)))) (pathString Nm (...
; # (shift X)
  %8 = inttoptr i64 %3 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
; # (car (shift X))
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car (shift X)))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$4, label %$3
$4:
  br label %$2
$3:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$6, label %$5
$6:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$2
$5:
  %19 = call i64 @evList(i64 %12)
  br label %$2
$2:
  %20 = phi i64 [%12, %$4], [%18, %$6], [%19, %$5] ; # ->
; # (nil? (eval (car (shift X))))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (pathSize Nm)
  %22 = call i64 @pathSize(i64 %6)
; # (b8 (pathSize Nm))
  %23 = alloca i8, i64 %22
; # (pathString Nm (b8 (pathSize Nm)))
  %24 = call i8* @pathString(i64 %6, i8* %23)
; # (fileInfo (nil? (eval (car (shift X)))) (pathString Nm (b8 (pathS...
  %25 = call i64 @fileInfo(i1 %21, i8* %24, i64* %7)
; # (lt0 (fileInfo (nil? (eval (car (shift X)))) (pathString Nm (b8 (...
  %26 = icmp slt i64 %25, 0
  br i1 %26, label %$7, label %$8
$7:
  %27 = phi i64 [%10, %$2] ; # X
  br label %$9
$8:
  %28 = phi i64 [%10, %$2] ; # X
; # (let N @ (cons (case (& N 3) (1 $T) (2 $Nil) (T (box64 (val Size)...
; # (case (& N 3) (1 $T) (2 $Nil) (T (box64 (val Size))))
; # (& N 3)
  %29 = and i64 %25, 3
  switch i64 %29, label %$10 [
    i64 1, label %$12
    i64 2, label %$13
  ]
$12:
  %30 = phi i64 [%28, %$8] ; # X
  %31 = phi i64 [%25, %$8] ; # N
  br label %$11
$13:
  %32 = phi i64 [%28, %$8] ; # X
  %33 = phi i64 [%25, %$8] ; # N
  br label %$11
$10:
  %34 = phi i64 [%28, %$8] ; # X
  %35 = phi i64 [%25, %$8] ; # N
; # (val Size)
  %36 = load i64, i64* %7
; # (box64 (val Size))
  %37 = and i64 %36, 17293822569102704640
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$14, label %$15
$14:
  %39 = call i64 @boxNum(i64 %36)
  br label %$16
$15:
  %40 = shl i64 %36, 4
  %41 = or i64 %40, 2
  br label %$16
$16:
  %42 = phi i64 [%39, %$14], [%41, %$15] ; # ->
  br label %$11
$11:
  %43 = phi i64 [%30, %$12], [%32, %$13], [%34, %$16] ; # X
  %44 = phi i64 [%31, %$12], [%33, %$13], [%35, %$16] ; # N
  %45 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%42, %$16] ; # ->
; # (shr N 2)
  %46 = lshr i64 %44, 2
; # (& (setq N (shr N 2)) (hex "FFFF"))
  %47 = and i64 %46, 65535
; # (shr N 16)
  %48 = lshr i64 %46, 16
; # (& (setq N (shr N 16)) (hex "FF"))
  %49 = and i64 %48, 255
; # (shr N 8)
  %50 = lshr i64 %48, 8
; # (& (setq N (shr N 8)) (hex "FF"))
  %51 = and i64 %50, 255
; # (tmDate (& (setq N (shr N 2)) (hex "FFFF")) (& (setq N (shr N 16)...
  %52 = call i64 @tmDate(i64 %47, i64 %49, i64 %51)
; # (shr N 8)
  %53 = lshr i64 %50, 8
; # (cnt (shr N 8))
  %54 = shl i64 %53, 4
  %55 = or i64 %54, 2
; # (cons (tmDate (& (setq N (shr N 2)) (hex "FFFF")) (& (setq N (shr...
  %56 = call i64 @cons(i64 %52, i64 %55)
; # (cons (case (& N 3) (1 $T) (2 $Nil) (T (box64 (val Size)))) (cons...
  %57 = call i64 @cons(i64 %45, i64 %56)
  br label %$9
$9:
  %58 = phi i64 [%27, %$7], [%43, %$11] ; # X
  %59 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%57, %$11] ; # ->
  ret i64 %59
}

define i64 @_file(i64) align 8 {
$1:
; # (let In: (inFile (val $InFile)) (ifn (and (In:) (In: name)) $Nil ...
; # (val $InFile)
  %1 = load i8*, i8** @$InFile
; # (ifn (and (In:) (In: name)) $Nil (let (N (cnt (i64 (In: src))) S ...
; # (and (In:) (In: name))
; # (In:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (In: name)
  %3 = bitcast i8* %1 to i8**
  %4 = load i8*, i8** %3
  %5 = icmp ne i8* %4, null
  br label %$2
$2:
  %6 = phi i1 [0, %$1], [%5, %$3] ; # ->
  br i1 %6, label %$5, label %$4
$4:
  br label %$6
$5:
; # (let (N (cnt (i64 (In: src))) S (In: name) P (strrchr S (char "/"...
; # (In: src)
  %7 = getelementptr i8, i8* %1, i32 20
  %8 = bitcast i8* %7 to i32*
  %9 = load i32, i32* %8
; # (i64 (In: src))
  %10 = sext i32 %9 to i64
; # (cnt (i64 (In: src)))
  %11 = shl i64 %10, 4
  %12 = or i64 %11, 2
; # (In: name)
  %13 = bitcast i8* %1 to i8**
  %14 = load i8*, i8** %13
; # (strrchr S (char "/"))
  %15 = call i8* @strrchr(i8* %14, i32 47)
; # (if P (let X (save (mkStrE S (inc 'P))) (cons X (cons (mkStr P) N...
  %16 = icmp ne i8* %15, null
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i8* [%15, %$5] ; # P
; # (let X (save (mkStrE S (inc 'P))) (cons X (cons (mkStr P) N)))
; # (inc 'P)
  %18 = getelementptr i8, i8* %17, i32 1
; # (mkStrE S (inc 'P))
  %19 = call i64 @mkStrE(i8* %14, i8* %18)
; # (save (mkStrE S (inc 'P)))
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = alloca i64, i64 2, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = inttoptr i64 %23 to i64*
  store i64 %19, i64* %24
  %25 = add i64 %23, 8
  %26 = inttoptr i64 %25 to i64*
  store i64 %21, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %27
; # (mkStr P)
  %28 = call i64 @mkStr(i8* %18)
; # (cons (mkStr P) N)
  %29 = call i64 @cons(i64 %28, i64 %12)
; # (cons X (cons (mkStr P) N))
  %30 = call i64 @cons(i64 %19, i64 %29)
; # (drop *Safe)
  %31 = inttoptr i64 %23 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %33, i64* %34
  br label %$9
$8:
  %35 = phi i8* [%15, %$5] ; # P
; # (mkStr S)
  %36 = call i64 @mkStr(i8* %14)
; # (cons (mkStr S) N)
  %37 = call i64 @cons(i64 %36, i64 %12)
; # (cons $Nil (cons (mkStr S) N))
  %38 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64 %37)
  br label %$9
$9:
  %39 = phi i8* [%18, %$7], [%35, %$8] ; # P
  %40 = phi i64 [%30, %$7], [%38, %$8] ; # ->
  br label %$6
$6:
  %41 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%40, %$9] ; # ->
  ret i64 %41
}

define i64 @_argv(i64) align 8 {
$1:
; # (let (X (cdr Exe) A (val $AV) P (val A)) (when (and P (== (val P)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $AV)
  %4 = load i8**, i8*** @$AV
; # (val A)
  %5 = load i8*, i8** %4
; # (when (and P (== (val P) (char "-")) (=0 (val 2 P))) (inc 'A))
; # (and P (== (val P) (char "-")) (=0 (val 2 P)))
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$3, label %$2
$3:
  %7 = phi i64 [%3, %$1] ; # X
  %8 = phi i8** [%4, %$1] ; # A
  %9 = phi i8* [%5, %$1] ; # P
; # (val P)
  %10 = load i8, i8* %9
; # (== (val P) (char "-"))
  %11 = icmp eq i8 %10, 45
  br i1 %11, label %$4, label %$2
$4:
  %12 = phi i64 [%7, %$3] ; # X
  %13 = phi i8** [%8, %$3] ; # A
  %14 = phi i8* [%9, %$3] ; # P
; # (val 2 P)
  %15 = getelementptr i8, i8* %14, i32 1
  %16 = load i8, i8* %15
; # (=0 (val 2 P))
  %17 = icmp eq i8 %16, 0
  br label %$2
$2:
  %18 = phi i64 [%3, %$1], [%7, %$3], [%12, %$4] ; # X
  %19 = phi i8** [%4, %$1], [%8, %$3], [%13, %$4] ; # A
  %20 = phi i8* [%5, %$1], [%9, %$3], [%14, %$4] ; # P
  %21 = phi i1 [0, %$1], [0, %$3], [%17, %$4] ; # ->
  br i1 %21, label %$5, label %$6
$5:
  %22 = phi i64 [%18, %$2] ; # X
  %23 = phi i8** [%19, %$2] ; # A
  %24 = phi i8* [%20, %$2] ; # P
; # (inc 'A)
  %25 = getelementptr i8*, i8** %23, i32 1
  br label %$6
$6:
  %26 = phi i64 [%18, %$2], [%22, %$5] ; # X
  %27 = phi i8** [%19, %$2], [%25, %$5] ; # A
  %28 = phi i8* [%20, %$2], [%24, %$5] ; # P
; # (if (nil? X) (if (setq P (val A)) (let (Y (cons (mkStr P) $Nil) R...
; # (nil? X)
  %29 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %29, label %$7, label %$8
$7:
  %30 = phi i64 [%26, %$6] ; # X
  %31 = phi i8** [%27, %$6] ; # A
  %32 = phi i8* [%28, %$6] ; # P
; # (if (setq P (val A)) (let (Y (cons (mkStr P) $Nil) R (save Y)) (w...
; # (val A)
  %33 = load i8*, i8** %31
  %34 = icmp ne i8* %33, null
  br i1 %34, label %$10, label %$11
$10:
  %35 = phi i64 [%30, %$7] ; # X
  %36 = phi i8** [%31, %$7] ; # A
  %37 = phi i8* [%33, %$7] ; # P
; # (let (Y (cons (mkStr P) $Nil) R (save Y)) (while (setq P (val (in...
; # (mkStr P)
  %38 = call i64 @mkStr(i8* %37)
; # (cons (mkStr P) $Nil)
  %39 = call i64 @cons(i64 %38, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 %39, i64* %44
  %45 = add i64 %43, 8
  %46 = inttoptr i64 %45 to i64*
  store i64 %41, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %47
; # (while (setq P (val (inc 'A))) (setq Y (set 2 Y (cons (mkStr P) $...
  br label %$13
$13:
  %48 = phi i64 [%35, %$10], [%55, %$14] ; # X
  %49 = phi i8** [%36, %$10], [%56, %$14] ; # A
  %50 = phi i8* [%37, %$10], [%57, %$14] ; # P
  %51 = phi i64 [%39, %$10], [%60, %$14] ; # Y
; # (inc 'A)
  %52 = getelementptr i8*, i8** %49, i32 1
; # (val (inc 'A))
  %53 = load i8*, i8** %52
  %54 = icmp ne i8* %53, null
  br i1 %54, label %$14, label %$15
$14:
  %55 = phi i64 [%48, %$13] ; # X
  %56 = phi i8** [%52, %$13] ; # A
  %57 = phi i8* [%53, %$13] ; # P
  %58 = phi i64 [%51, %$13] ; # Y
; # (set 2 Y (cons (mkStr P) $Nil))
; # (mkStr P)
  %59 = call i64 @mkStr(i8* %57)
; # (cons (mkStr P) $Nil)
  %60 = call i64 @cons(i64 %59, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %61 = inttoptr i64 %58 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  br label %$13
$15:
  %63 = phi i64 [%48, %$13] ; # X
  %64 = phi i8** [%52, %$13] ; # A
  %65 = phi i8* [%53, %$13] ; # P
  %66 = phi i64 [%51, %$13] ; # Y
; # (drop *Safe)
  %67 = inttoptr i64 %43 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %69, i64* %70
  br label %$12
$11:
  %71 = phi i64 [%30, %$7] ; # X
  %72 = phi i8** [%31, %$7] ; # A
  %73 = phi i8* [%33, %$7] ; # P
  br label %$12
$12:
  %74 = phi i64 [%63, %$15], [%71, %$11] ; # X
  %75 = phi i8** [%64, %$15], [%72, %$11] ; # A
  %76 = phi i8* [%65, %$15], [%73, %$11] ; # P
  %77 = phi i64 [%39, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  br label %$9
$8:
  %78 = phi i64 [%26, %$6] ; # X
  %79 = phi i8** [%27, %$6] ; # A
  %80 = phi i8* [%28, %$6] ; # P
; # (loop (? (atom X) (set (needChkVar Exe X) (if (setq P (val A)) (l...
  br label %$16
$16:
  %81 = phi i64 [%78, %$8], [%171, %$41] ; # X
  %82 = phi i8** [%79, %$8], [%172, %$41] ; # A
  %83 = phi i8* [%80, %$8], [%173, %$41] ; # P
; # (? (atom X) (set (needChkVar Exe X) (if (setq P (val A)) (let (Y ...
; # (atom X)
  %84 = and i64 %81, 15
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$19, label %$17
$19:
  %86 = phi i64 [%81, %$16] ; # X
  %87 = phi i8** [%82, %$16] ; # A
  %88 = phi i8* [%83, %$16] ; # P
; # (set (needChkVar Exe X) (if (setq P (val A)) (let (Y (cons (mkStr...
; # (needChkVar Exe X)
  %89 = and i64 %86, 6
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$20, label %$21
$20:
  call void @varErr(i64 %0, i64 %86)
  unreachable
$21:
  %91 = icmp uge i64 %86, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %91, label %$23, label %$22
$23:
  %92 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %86
  br label %$22
$22:
  %93 = phi i1 [0, %$21], [%92, %$23] ; # ->
  br i1 %93, label %$24, label %$25
$24:
  call void @protErr(i64 %0, i64 %86)
  unreachable
$25:
; # (if (setq P (val A)) (let (Y (cons (mkStr P) $Nil) R Y) (save R (...
; # (val A)
  %94 = load i8*, i8** %87
  %95 = icmp ne i8* %94, null
  br i1 %95, label %$26, label %$27
$26:
  %96 = phi i64 [%86, %$25] ; # X
  %97 = phi i8** [%87, %$25] ; # A
  %98 = phi i8* [%94, %$25] ; # P
; # (let (Y (cons (mkStr P) $Nil) R Y) (save R (while (setq P (val (i...
; # (mkStr P)
  %99 = call i64 @mkStr(i8* %98)
; # (cons (mkStr P) $Nil)
  %100 = call i64 @cons(i64 %99, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save R (while (setq P (val (inc 'A))) (setq Y (set 2 Y (cons (mk...
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %102 = load i64, i64* %101
  %103 = alloca i64, i64 2, align 16
  %104 = ptrtoint i64* %103 to i64
  %105 = inttoptr i64 %104 to i64*
  store i64 %100, i64* %105
  %106 = add i64 %104, 8
  %107 = inttoptr i64 %106 to i64*
  store i64 %102, i64* %107
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %104, i64* %108
; # (while (setq P (val (inc 'A))) (setq Y (set 2 Y (cons (mkStr P) $...
  br label %$29
$29:
  %109 = phi i64 [%96, %$26], [%116, %$30] ; # X
  %110 = phi i8** [%97, %$26], [%117, %$30] ; # A
  %111 = phi i8* [%98, %$26], [%118, %$30] ; # P
  %112 = phi i64 [%100, %$26], [%121, %$30] ; # Y
; # (inc 'A)
  %113 = getelementptr i8*, i8** %110, i32 1
; # (val (inc 'A))
  %114 = load i8*, i8** %113
  %115 = icmp ne i8* %114, null
  br i1 %115, label %$30, label %$31
$30:
  %116 = phi i64 [%109, %$29] ; # X
  %117 = phi i8** [%113, %$29] ; # A
  %118 = phi i8* [%114, %$29] ; # P
  %119 = phi i64 [%112, %$29] ; # Y
; # (set 2 Y (cons (mkStr P) $Nil))
; # (mkStr P)
  %120 = call i64 @mkStr(i8* %118)
; # (cons (mkStr P) $Nil)
  %121 = call i64 @cons(i64 %120, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %122 = inttoptr i64 %119 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  store i64 %121, i64* %123
  br label %$29
$31:
  %124 = phi i64 [%109, %$29] ; # X
  %125 = phi i8** [%113, %$29] ; # A
  %126 = phi i8* [%114, %$29] ; # P
  %127 = phi i64 [%112, %$29] ; # Y
; # drop
  %128 = inttoptr i64 %104 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %130, i64* %131
  br label %$28
$27:
  %132 = phi i64 [%86, %$25] ; # X
  %133 = phi i8** [%87, %$25] ; # A
  %134 = phi i8* [%94, %$25] ; # P
  br label %$28
$28:
  %135 = phi i64 [%124, %$31], [%132, %$27] ; # X
  %136 = phi i8** [%125, %$31], [%133, %$27] ; # A
  %137 = phi i8* [%126, %$31], [%134, %$27] ; # P
  %138 = phi i64 [%100, %$31], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$27] ; # ->
  %139 = inttoptr i64 %86 to i64*
  store i64 %138, i64* %139
  br label %$18
$17:
  %140 = phi i64 [%81, %$16] ; # X
  %141 = phi i8** [%82, %$16] ; # A
  %142 = phi i8* [%83, %$16] ; # P
; # (let Y (ifn (setq P (val A)) $Nil (inc 'A) (mkStr P)) (set (needC...
; # (ifn (setq P (val A)) $Nil (inc 'A) (mkStr P))
; # (val A)
  %143 = load i8*, i8** %141
  %144 = icmp ne i8* %143, null
  br i1 %144, label %$33, label %$32
$32:
  %145 = phi i64 [%140, %$17] ; # X
  %146 = phi i8** [%141, %$17] ; # A
  %147 = phi i8* [%143, %$17] ; # P
  br label %$34
$33:
  %148 = phi i64 [%140, %$17] ; # X
  %149 = phi i8** [%141, %$17] ; # A
  %150 = phi i8* [%143, %$17] ; # P
; # (inc 'A)
  %151 = getelementptr i8*, i8** %149, i32 1
; # (mkStr P)
  %152 = call i64 @mkStr(i8* %150)
  br label %$34
$34:
  %153 = phi i64 [%145, %$32], [%148, %$33] ; # X
  %154 = phi i8** [%146, %$32], [%151, %$33] ; # A
  %155 = phi i8* [%147, %$32], [%150, %$33] ; # P
  %156 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$32], [%152, %$33] ; # ->
; # (set (needChkVar Exe (++ X)) Y)
; # (++ X)
  %157 = inttoptr i64 %153 to i64*
  %158 = load i64, i64* %157
  %159 = getelementptr i64, i64* %157, i32 1
  %160 = load i64, i64* %159
; # (needChkVar Exe (++ X))
  %161 = and i64 %158, 6
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$35, label %$36
$35:
  call void @varErr(i64 %0, i64 %158)
  unreachable
$36:
  %163 = icmp uge i64 %158, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %163, label %$38, label %$37
$38:
  %164 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %158
  br label %$37
$37:
  %165 = phi i1 [0, %$36], [%164, %$38] ; # ->
  br i1 %165, label %$39, label %$40
$39:
  call void @protErr(i64 %0, i64 %158)
  unreachable
$40:
  %166 = inttoptr i64 %158 to i64*
  store i64 %156, i64* %166
; # (? (nil? X) Y)
; # (nil? X)
  %167 = icmp eq i64 %160, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %167, label %$42, label %$41
$42:
  %168 = phi i64 [%160, %$40] ; # X
  %169 = phi i8** [%154, %$40] ; # A
  %170 = phi i8* [%155, %$40] ; # P
  br label %$18
$41:
  %171 = phi i64 [%160, %$40] ; # X
  %172 = phi i8** [%154, %$40] ; # A
  %173 = phi i8* [%155, %$40] ; # P
  br label %$16
$18:
  %174 = phi i64 [%135, %$28], [%168, %$42] ; # X
  %175 = phi i8** [%136, %$28], [%169, %$42] ; # A
  %176 = phi i8* [%137, %$28], [%170, %$42] ; # P
  %177 = phi i64 [%138, %$28], [%156, %$42] ; # ->
  br label %$9
$9:
  %178 = phi i64 [%74, %$12], [%174, %$18] ; # X
  %179 = phi i8** [%75, %$12], [%175, %$18] ; # A
  %180 = phi i8* [%76, %$12], [%176, %$18] ; # P
  %181 = phi i64 [%77, %$12], [%177, %$18] ; # ->
  ret i64 %181
}

define i64 @_opt(i64) align 8 {
$1:
; # (let (A (val $AV) P (val A)) (if (or (=0 P) (and (== (val P) (cha...
; # (val $AV)
  %1 = load i8**, i8*** @$AV
; # (val A)
  %2 = load i8*, i8** %1
; # (if (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P)))) $Nil...
; # (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P))))
; # (=0 P)
  %3 = icmp eq i8* %2, null
  br i1 %3, label %$2, label %$3
$3:
; # (and (== (val P) (char "-")) (=0 (val 2 P)))
; # (val P)
  %4 = load i8, i8* %2
; # (== (val P) (char "-"))
  %5 = icmp eq i8 %4, 45
  br i1 %5, label %$5, label %$4
$5:
; # (val 2 P)
  %6 = getelementptr i8, i8* %2, i32 1
  %7 = load i8, i8* %6
; # (=0 (val 2 P))
  %8 = icmp eq i8 %7, 0
  br label %$4
$4:
  %9 = phi i1 [0, %$3], [%8, %$5] ; # ->
  br label %$2
$2:
  %10 = phi i1 [1, %$1], [%9, %$4] ; # ->
  br i1 %10, label %$6, label %$7
$6:
  br label %$8
$7:
; # (set $AV (inc A))
; # (inc A)
  %11 = getelementptr i8*, i8** %1, i32 1
  store i8** %11, i8*** @$AV
; # (mkStr P)
  %12 = call i64 @mkStr(i8* %2)
  br label %$8
$8:
  %13 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$6], [%12, %$7] ; # ->
  ret i64 %13
}

define i64 @_errno(i64) align 8 {
$1:
; # (nErrno)
  %1 = call i32 @nErrno()
; # (i64 (nErrno))
  %2 = sext i32 %1 to i64
; # (cnt (i64 (nErrno)))
  %3 = shl i64 %2, 4
  %4 = or i64 %3, 2
  ret i64 %4
}

define i32 @fetchChar(i8**) align 8 {
$1:
; # (let (P (val Ptr) C (i32 (val P))) (prog2 (inc 'P) (cond ((>= 127...
; # (val Ptr)
  %1 = load i8*, i8** %0
; # (val P)
  %2 = load i8, i8* %1
; # (i32 (val P))
  %3 = zext i8 %2 to i32
; # (prog2 (inc 'P) (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)...
; # (inc 'P)
  %4 = getelementptr i8, i8* %1, i32 1
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (| (shl (if...
; # (>= 127 C)
  %5 = icmp sge i32 127, %3
  br i1 %5, label %$4, label %$3
$4:
  %6 = phi i8* [%4, %$1] ; # P
  br label %$2
$3:
  %7 = phi i8* [%4, %$1] ; # P
; # (== C (hex "FF"))
  %8 = icmp eq i32 %3, 255
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i8* [%7, %$3] ; # P
; # (i32 TOP)
  br label %$2
$5:
  %10 = phi i8* [%7, %$3] ; # P
; # (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (hex "10...
; # (& C (hex "20"))
  %11 = and i32 %3, 32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %$8, label %$7
$7:
  %13 = phi i8* [%10, %$5] ; # P
; # (& C (hex "1F"))
  %14 = and i32 %3, 31
  br label %$9
$8:
  %15 = phi i8* [%10, %$5] ; # P
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7")) 6)...
; # (& C (hex "10"))
  %16 = and i32 %3, 16
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %$11, label %$10
$10:
  %18 = phi i8* [%15, %$8] ; # P
; # (& C (hex "0F"))
  %19 = and i32 %3, 15
  br label %$12
$11:
  %20 = phi i8* [%15, %$8] ; # P
; # (& C (hex "7"))
  %21 = and i32 %3, 7
; # (shl (& C (hex "7")) 6)
  %22 = shl i32 %21, 6
; # (prog1 (val P) (inc 'P))
; # (val P)
  %23 = load i8, i8* %20
; # (inc 'P)
  %24 = getelementptr i8, i8* %20, i32 1
; # (i32 (prog1 (val P) (inc 'P)))
  %25 = zext i8 %23 to i32
; # (& (i32 (prog1 (val P) (inc 'P))) (hex "3F"))
  %26 = and i32 %25, 63
; # (| (shl (& C (hex "7")) 6) (& (i32 (prog1 (val P) (inc 'P))) (hex...
  %27 = or i32 %22, %26
  br label %$12
$12:
  %28 = phi i8* [%18, %$10], [%24, %$11] ; # P
  %29 = phi i32 [%19, %$10], [%27, %$11] ; # ->
; # (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7"...
  %30 = shl i32 %29, 6
; # (prog1 (val P) (inc 'P))
; # (val P)
  %31 = load i8, i8* %28
; # (inc 'P)
  %32 = getelementptr i8, i8* %28, i32 1
; # (i32 (prog1 (val P) (inc 'P)))
  %33 = zext i8 %31 to i32
; # (& (i32 (prog1 (val P) (inc 'P))) (hex "3F"))
  %34 = and i32 %33, 63
; # (| (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex ...
  %35 = or i32 %30, %34
  br label %$9
$9:
  %36 = phi i8* [%13, %$7], [%32, %$12] ; # P
  %37 = phi i32 [%14, %$7], [%35, %$12] ; # ->
; # (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (he...
  %38 = shl i32 %37, 6
; # (prog1 (val P) (inc 'P))
; # (val P)
  %39 = load i8, i8* %36
; # (inc 'P)
  %40 = getelementptr i8, i8* %36, i32 1
; # (i32 (prog1 (val P) (inc 'P)))
  %41 = zext i8 %39 to i32
; # (& (i32 (prog1 (val P) (inc 'P))) (hex "3F"))
  %42 = and i32 %41, 63
; # (| (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C ...
  %43 = or i32 %38, %42
  br label %$2
$2:
  %44 = phi i8* [%6, %$4], [%9, %$6], [%40, %$9] ; # P
  %45 = phi i32 [%3, %$4], [1114112, %$6], [%43, %$9] ; # ->
; # (set Ptr P)
  store i8* %44, i8** %0
  ret i32 %45
}

define i64 @natBuf(i64, i8*) align 8 {
$1:
; # (if (atom Val) (if (sign? Val) (let P (i32* Ptr) (set P (i32 (int...
; # (atom Val)
  %2 = and i64 %0, 15
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # Val
  %5 = phi i8* [%1, %$1] ; # Ptr
; # (if (sign? Val) (let P (i32* Ptr) (set P (i32 (int Val))) 4) (set...
; # (sign? Val)
  %6 = and i64 %4, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$2] ; # Val
  %9 = phi i8* [%5, %$2] ; # Ptr
; # (let P (i32* Ptr) (set P (i32 (int Val))) 4)
; # (i32* Ptr)
  %10 = bitcast i8* %9 to i32*
; # (set P (i32 (int Val)))
; # (int Val)
  %11 = lshr i64 %8, 4
; # (i32 (int Val))
  %12 = trunc i64 %11 to i32
  store i32 %12, i32* %10
  br label %$7
$6:
  %13 = phi i64 [%4, %$2] ; # Val
  %14 = phi i8* [%5, %$2] ; # Ptr
; # (set Ptr (i8 (int Val)))
; # (int Val)
  %15 = lshr i64 %13, 4
; # (i8 (int Val))
  %16 = trunc i64 %15 to i8
  store i8 %16, i8* %14
  br label %$7
$7:
  %17 = phi i64 [%8, %$5], [%13, %$6] ; # Val
  %18 = phi i8* [%9, %$5], [%14, %$6] ; # Ptr
  %19 = phi i64 [4, %$5], [1, %$6] ; # ->
  br label %$4
$3:
  %20 = phi i64 [%0, %$1] ; # Val
  %21 = phi i8* [%1, %$1] ; # Ptr
; # (let X (++ Val) (if (cnt? Val) (let Siz (int Val) (cond ((num? X)...
; # (++ Val)
  %22 = inttoptr i64 %20 to i64*
  %23 = load i64, i64* %22
  %24 = getelementptr i64, i64* %22, i32 1
  %25 = load i64, i64* %24
; # (if (cnt? Val) (let Siz (int Val) (cond ((num? X) (let N (if (cnt...
; # (cnt? Val)
  %26 = and i64 %25, 2
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$8, label %$9
$8:
  %28 = phi i64 [%25, %$3] ; # Val
  %29 = phi i8* [%21, %$3] ; # Ptr
  %30 = phi i64 [%23, %$3] ; # X
; # (let Siz (int Val) (cond ((num? X) (let N (if (cnt? X) (int @) (v...
; # (int Val)
  %31 = lshr i64 %28, 4
; # (cond ((num? X) (let N (if (cnt? X) (int @) (val (dig @))) (when ...
; # (num? X)
  %32 = and i64 %30, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  %34 = phi i64 [%28, %$8] ; # Val
  %35 = phi i8* [%29, %$8] ; # Ptr
  %36 = phi i64 [%30, %$8] ; # X
; # (let N (if (cnt? X) (int @) (val (dig @))) (when (sign? X) (setq ...
; # (if (cnt? X) (int @) (val (dig @)))
; # (cnt? X)
  %37 = and i64 %36, 2
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$14, label %$15
$14:
  %39 = phi i64 [%34, %$13] ; # Val
  %40 = phi i8* [%35, %$13] ; # Ptr
  %41 = phi i64 [%36, %$13] ; # X
; # (int @)
  %42 = lshr i64 %36, 4
  br label %$16
$15:
  %43 = phi i64 [%34, %$13] ; # Val
  %44 = phi i8* [%35, %$13] ; # Ptr
  %45 = phi i64 [%36, %$13] ; # X
; # (dig @)
  %46 = add i64 %36, -4
; # (val (dig @))
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
  br label %$16
$16:
  %49 = phi i64 [%39, %$14], [%43, %$15] ; # Val
  %50 = phi i8* [%40, %$14], [%44, %$15] ; # Ptr
  %51 = phi i64 [%41, %$14], [%45, %$15] ; # X
  %52 = phi i64 [%42, %$14], [%48, %$15] ; # ->
; # (when (sign? X) (setq N (- N)))
; # (sign? X)
  %53 = and i64 %51, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$17, label %$18
$17:
  %55 = phi i64 [%49, %$16] ; # Val
  %56 = phi i8* [%50, %$16] ; # Ptr
  %57 = phi i64 [%51, %$16] ; # X
  %58 = phi i64 [%52, %$16] ; # N
; # (- N)
  %59 = sub i64 0, %58
  br label %$18
$18:
  %60 = phi i64 [%49, %$16], [%55, %$17] ; # Val
  %61 = phi i8* [%50, %$16], [%56, %$17] ; # Ptr
  %62 = phi i64 [%51, %$16], [%57, %$17] ; # X
  %63 = phi i64 [%52, %$16], [%59, %$17] ; # N
; # (case Siz (1 (set Ptr (i8 N))) (2 (set (i16* Ptr) (i16 N))) (4 (s...
  switch i64 %31, label %$19 [
    i64 1, label %$21
    i64 2, label %$22
    i64 4, label %$23
  ]
$21:
  %64 = phi i64 [%60, %$18] ; # Val
  %65 = phi i8* [%61, %$18] ; # Ptr
  %66 = phi i64 [%62, %$18] ; # X
  %67 = phi i64 [%63, %$18] ; # N
; # (set Ptr (i8 N))
; # (i8 N)
  %68 = trunc i64 %67 to i8
  store i8 %68, i8* %65
  br label %$20
$22:
  %69 = phi i64 [%60, %$18] ; # Val
  %70 = phi i8* [%61, %$18] ; # Ptr
  %71 = phi i64 [%62, %$18] ; # X
  %72 = phi i64 [%63, %$18] ; # N
; # (set (i16* Ptr) (i16 N))
; # (i16* Ptr)
  %73 = bitcast i8* %70 to i16*
; # (i16 N)
  %74 = trunc i64 %72 to i16
  store i16 %74, i16* %73
  br label %$20
$23:
  %75 = phi i64 [%60, %$18] ; # Val
  %76 = phi i8* [%61, %$18] ; # Ptr
  %77 = phi i64 [%62, %$18] ; # X
  %78 = phi i64 [%63, %$18] ; # N
; # (set (i32* Ptr) (i32 N))
; # (i32* Ptr)
  %79 = bitcast i8* %76 to i32*
; # (i32 N)
  %80 = trunc i64 %78 to i32
  store i32 %80, i32* %79
  br label %$20
$19:
  %81 = phi i64 [%60, %$18] ; # Val
  %82 = phi i8* [%61, %$18] ; # Ptr
  %83 = phi i64 [%62, %$18] ; # X
  %84 = phi i64 [%63, %$18] ; # N
; # (set (i64* Ptr) N)
; # (i64* Ptr)
  %85 = bitcast i8* %82 to i64*
  store i64 %84, i64* %85
  br label %$20
$20:
  %86 = phi i64 [%64, %$21], [%69, %$22], [%75, %$23], [%81, %$19] ; # Val
  %87 = phi i8* [%65, %$21], [%70, %$22], [%76, %$23], [%82, %$19] ; # Ptr
  %88 = phi i64 [%66, %$21], [%71, %$22], [%77, %$23], [%83, %$19] ; # X
  %89 = phi i64 [%67, %$21], [%72, %$22], [%78, %$23], [%84, %$19] ; # N
  br label %$11
$12:
  %90 = phi i64 [%28, %$8] ; # Val
  %91 = phi i8* [%29, %$8] ; # Ptr
  %92 = phi i64 [%30, %$8] ; # X
; # (nil? X)
  %93 = icmp eq i64 %92, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %93, label %$25, label %$24
$25:
  %94 = phi i64 [%90, %$12] ; # Val
  %95 = phi i8* [%91, %$12] ; # Ptr
  %96 = phi i64 [%92, %$12] ; # X
; # (set Ptr (i8 0))
; # (i8 0)
  store i8 0, i8* %95
  br label %$11
$24:
  %97 = phi i64 [%90, %$12] ; # Val
  %98 = phi i8* [%91, %$12] ; # Ptr
  %99 = phi i64 [%92, %$12] ; # X
; # (sym? X)
  %100 = and i64 %99, 8
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$27, label %$26
$27:
  %102 = phi i64 [%97, %$24] ; # Val
  %103 = phi i8* [%98, %$24] ; # Ptr
  %104 = phi i64 [%99, %$24] ; # X
; # (tail X)
  %105 = add i64 %104, -8
; # (val (tail X))
  %106 = inttoptr i64 %105 to i64*
  %107 = load i64, i64* %106
; # (name (val (tail X)))
  br label %$28
$28:
  %108 = phi i64 [%107, %$27], [%114, %$29] ; # Tail
  %109 = and i64 %108, 6
  %110 = icmp ne i64 %109, 0
  br i1 %110, label %$30, label %$29
$29:
  %111 = phi i64 [%108, %$28] ; # Tail
  %112 = inttoptr i64 %111 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  %114 = load i64, i64* %113
  br label %$28
$30:
  %115 = phi i64 [%108, %$28] ; # Tail
; # (bufString X Ptr)
  %116 = call i8* @bufString(i64 %115, i8* %103)
  br label %$11
$26:
  %117 = phi i64 [%97, %$24] ; # Val
  %118 = phi i8* [%98, %$24] ; # Ptr
  %119 = phi i64 [%99, %$24] ; # X
  br label %$11
$11:
  %120 = phi i64 [%86, %$20], [%94, %$25], [%102, %$30], [%117, %$26] ; # Val
  %121 = phi i8* [%87, %$20], [%95, %$25], [%103, %$30], [%118, %$26] ; # Ptr
  %122 = phi i64 [%88, %$20], [%96, %$25], [%115, %$30], [%119, %$26] ; # X
  br label %$10
$9:
  %123 = phi i64 [%25, %$3] ; # Val
  %124 = phi i8* [%21, %$3] ; # Ptr
  %125 = phi i64 [%23, %$3] ; # X
; # (let (N 0 Scl (int X)) (if (sign? X) (while (pair Val) (bufFloat ...
; # (int X)
  %126 = lshr i64 %125, 4
; # (if (sign? X) (while (pair Val) (bufFloat (++ Val) Scl Ptr) (inc ...
; # (sign? X)
  %127 = and i64 %125, 8
  %128 = icmp ne i64 %127, 0
  br i1 %128, label %$31, label %$32
$31:
  %129 = phi i64 [%123, %$9] ; # Val
  %130 = phi i8* [%124, %$9] ; # Ptr
  %131 = phi i64 [%125, %$9] ; # X
  %132 = phi i64 [0, %$9] ; # N
; # (while (pair Val) (bufFloat (++ Val) Scl Ptr) (inc 'N 4) (setq Pt...
  br label %$34
$34:
  %133 = phi i64 [%129, %$31], [%146, %$35] ; # Val
  %134 = phi i8* [%130, %$31], [%148, %$35] ; # Ptr
  %135 = phi i64 [%131, %$31], [%141, %$35] ; # X
  %136 = phi i64 [%132, %$31], [%147, %$35] ; # N
; # (pair Val)
  %137 = and i64 %133, 15
  %138 = icmp eq i64 %137, 0
  br i1 %138, label %$35, label %$36
$35:
  %139 = phi i64 [%133, %$34] ; # Val
  %140 = phi i8* [%134, %$34] ; # Ptr
  %141 = phi i64 [%135, %$34] ; # X
  %142 = phi i64 [%136, %$34] ; # N
; # (++ Val)
  %143 = inttoptr i64 %139 to i64*
  %144 = load i64, i64* %143
  %145 = getelementptr i64, i64* %143, i32 1
  %146 = load i64, i64* %145
; # (bufFloat (++ Val) Scl Ptr)
  call void @bufFloat(i64 %144, i64 %126, i8* %140)
; # (inc 'N 4)
  %147 = add i64 %142, 4
; # (ofs Ptr 4)
  %148 = getelementptr i8, i8* %140, i32 4
  br label %$34
$36:
  %149 = phi i64 [%133, %$34] ; # Val
  %150 = phi i8* [%134, %$34] ; # Ptr
  %151 = phi i64 [%135, %$34] ; # X
  %152 = phi i64 [%136, %$34] ; # N
  br label %$33
$32:
  %153 = phi i64 [%123, %$9] ; # Val
  %154 = phi i8* [%124, %$9] ; # Ptr
  %155 = phi i64 [%125, %$9] ; # X
  %156 = phi i64 [0, %$9] ; # N
; # (while (pair Val) (bufDouble (++ Val) Scl Ptr) (inc 'N 8) (setq P...
  br label %$37
$37:
  %157 = phi i64 [%153, %$32], [%170, %$38] ; # Val
  %158 = phi i8* [%154, %$32], [%172, %$38] ; # Ptr
  %159 = phi i64 [%155, %$32], [%165, %$38] ; # X
  %160 = phi i64 [%156, %$32], [%171, %$38] ; # N
; # (pair Val)
  %161 = and i64 %157, 15
  %162 = icmp eq i64 %161, 0
  br i1 %162, label %$38, label %$39
$38:
  %163 = phi i64 [%157, %$37] ; # Val
  %164 = phi i8* [%158, %$37] ; # Ptr
  %165 = phi i64 [%159, %$37] ; # X
  %166 = phi i64 [%160, %$37] ; # N
; # (++ Val)
  %167 = inttoptr i64 %163 to i64*
  %168 = load i64, i64* %167
  %169 = getelementptr i64, i64* %167, i32 1
  %170 = load i64, i64* %169
; # (bufDouble (++ Val) Scl Ptr)
  call void @bufDouble(i64 %168, i64 %126, i8* %164)
; # (inc 'N 8)
  %171 = add i64 %166, 8
; # (ofs Ptr 8)
  %172 = getelementptr i8, i8* %164, i32 8
  br label %$37
$39:
  %173 = phi i64 [%157, %$37] ; # Val
  %174 = phi i8* [%158, %$37] ; # Ptr
  %175 = phi i64 [%159, %$37] ; # X
  %176 = phi i64 [%160, %$37] ; # N
  br label %$33
$33:
  %177 = phi i64 [%149, %$36], [%173, %$39] ; # Val
  %178 = phi i8* [%150, %$36], [%174, %$39] ; # Ptr
  %179 = phi i64 [%151, %$36], [%175, %$39] ; # X
  %180 = phi i64 [%152, %$36], [%176, %$39] ; # N
  br label %$10
$10:
  %181 = phi i64 [%120, %$11], [%177, %$33] ; # Val
  %182 = phi i8* [%121, %$11], [%178, %$33] ; # Ptr
  %183 = phi i64 [%122, %$11], [%179, %$33] ; # X
  %184 = phi i64 [%31, %$11], [%180, %$33] ; # ->
  br label %$4
$4:
  %185 = phi i64 [%17, %$7], [%181, %$10] ; # Val
  %186 = phi i8* [%18, %$7], [%182, %$10] ; # Ptr
  %187 = phi i64 [%19, %$7], [%184, %$10] ; # ->
  ret i64 %187
}

define void @natErr(i64) align 8 {
$1:
; # (err 0 Spec ($ "Bad result spec") null)
  call void @err(i64 0, i64 %0, i8* bitcast ([16 x i8]* @$89 to i8*), i8* null)
  unreachable
}

define i64 @natRetFloat(i32, i64) align 8 {
$1:
; # (let R (boxFloat Val Scl) (unless R (let X (setq R (save (boxNum ...
; # (boxFloat Val Scl)
  %2 = call i64 @boxFloat(i32 %0, i64 %1)
; # (unless R (let X (setq R (save (boxNum (val Fdigit)))) (until (bo...
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # R
; # (let X (setq R (save (boxNum (val Fdigit)))) (until (boxFlt) (set...
; # (val Fdigit)
  %5 = load i64, i64* @Fdigit
; # (boxNum (val Fdigit))
  %6 = call i64 @boxNum(i64 %5)
; # (save (boxNum (val Fdigit)))
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = alloca i64, i64 2, align 16
  %10 = ptrtoint i64* %9 to i64
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = add i64 %10, 8
  %13 = inttoptr i64 %12 to i64*
  store i64 %8, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %10, i64* %14
; # (until (boxFlt) (setq X (set (big X) (boxNum (val Fdigit)))))
  br label %$4
$4:
  %15 = phi i64 [%6, %$2], [%19, %$5] ; # R
  %16 = phi i64 [%6, %$2], [%23, %$5] ; # X
; # (boxFlt)
  %17 = call i64 @boxFlt()
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$6, label %$5
$5:
  %19 = phi i64 [%15, %$4] ; # R
  %20 = phi i64 [%16, %$4] ; # X
; # (set (big X) (boxNum (val Fdigit)))
; # (big X)
  %21 = add i64 %20, 4
; # (val Fdigit)
  %22 = load i64, i64* @Fdigit
; # (boxNum (val Fdigit))
  %23 = call i64 @boxNum(i64 %22)
  %24 = inttoptr i64 %21 to i64*
  store i64 %23, i64* %24
  br label %$4
$6:
  %25 = phi i64 [%15, %$4] ; # R
  %26 = phi i64 [%16, %$4] ; # X
; # (set (big X) @)
; # (big X)
  %27 = add i64 %26, 4
  %28 = inttoptr i64 %27 to i64*
  store i64 %17, i64* %28
; # (drop *Safe)
  %29 = inttoptr i64 %10 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %32
  br label %$3
$3:
  %33 = phi i64 [%2, %$1], [%25, %$6] ; # R
; # (if (val Fsign) (neg R) R)
; # (val Fsign)
  %34 = load i1, i1* @Fsign
  br i1 %34, label %$7, label %$8
$7:
  %35 = phi i64 [%33, %$3] ; # R
; # (neg R)
  %36 = icmp eq i64 %35, 2
  br i1 %36, label %$10, label %$11
$10:
  br label %$12
$11:
  %37 = xor i64 %35, 8
  br label %$12
$12:
  %38 = phi i64 [%35, %$10], [%37, %$11] ; # ->
  br label %$9
$8:
  %39 = phi i64 [%33, %$3] ; # R
  br label %$9
$9:
  %40 = phi i64 [%35, %$12], [%39, %$8] ; # R
  %41 = phi i64 [%38, %$12], [%39, %$8] ; # ->
  ret i64 %41
}

define i64 @natRetDouble(i64, i64) align 8 {
$1:
; # (let R (boxDouble Val Scl) (unless R (let X (setq R (save (boxNum...
; # (boxDouble Val Scl)
  %2 = call i64 @boxDouble(i64 %0, i64 %1)
; # (unless R (let X (setq R (save (boxNum (val Fdigit)))) (until (bo...
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # R
; # (let X (setq R (save (boxNum (val Fdigit)))) (until (boxDbl) (set...
; # (val Fdigit)
  %5 = load i64, i64* @Fdigit
; # (boxNum (val Fdigit))
  %6 = call i64 @boxNum(i64 %5)
; # (save (boxNum (val Fdigit)))
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = alloca i64, i64 2, align 16
  %10 = ptrtoint i64* %9 to i64
  %11 = inttoptr i64 %10 to i64*
  store i64 %6, i64* %11
  %12 = add i64 %10, 8
  %13 = inttoptr i64 %12 to i64*
  store i64 %8, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %10, i64* %14
; # (until (boxDbl) (setq X (set (big X) (boxNum (val Fdigit)))))
  br label %$4
$4:
  %15 = phi i64 [%6, %$2], [%19, %$5] ; # R
  %16 = phi i64 [%6, %$2], [%23, %$5] ; # X
; # (boxDbl)
  %17 = call i64 @boxDbl()
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$6, label %$5
$5:
  %19 = phi i64 [%15, %$4] ; # R
  %20 = phi i64 [%16, %$4] ; # X
; # (set (big X) (boxNum (val Fdigit)))
; # (big X)
  %21 = add i64 %20, 4
; # (val Fdigit)
  %22 = load i64, i64* @Fdigit
; # (boxNum (val Fdigit))
  %23 = call i64 @boxNum(i64 %22)
  %24 = inttoptr i64 %21 to i64*
  store i64 %23, i64* %24
  br label %$4
$6:
  %25 = phi i64 [%15, %$4] ; # R
  %26 = phi i64 [%16, %$4] ; # X
; # (set (big X) @)
; # (big X)
  %27 = add i64 %26, 4
  %28 = inttoptr i64 %27 to i64*
  store i64 %17, i64* %28
; # (drop *Safe)
  %29 = inttoptr i64 %10 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %32
  br label %$3
$3:
  %33 = phi i64 [%2, %$1], [%25, %$6] ; # R
; # (if (val Fsign) (neg R) R)
; # (val Fsign)
  %34 = load i1, i1* @Fsign
  br i1 %34, label %$7, label %$8
$7:
  %35 = phi i64 [%33, %$3] ; # R
; # (neg R)
  %36 = icmp eq i64 %35, 2
  br i1 %36, label %$10, label %$11
$10:
  br label %$12
$11:
  %37 = xor i64 %35, 8
  br label %$12
$12:
  %38 = phi i64 [%35, %$10], [%37, %$11] ; # ->
  br label %$9
$8:
  %39 = phi i64 [%33, %$3] ; # R
  br label %$9
$9:
  %40 = phi i64 [%35, %$12], [%39, %$8] ; # R
  %41 = phi i64 [%38, %$12], [%39, %$8] ; # ->
  ret i64 %41
}

define i64 @natRetBuf(i64, i8**) align 8 {
$1:
; # (cond ((t? Spec) (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) ...
; # (t? Spec)
  %2 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %4 = load i8*, i8** %1
; # (i64* (val Ptr))
  %5 = bitcast i8* %4 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %6 = getelementptr i64, i64* %5, i32 1
; # (i8* (inc P))
  %7 = bitcast i64* %6 to i8*
  store i8* %7, i8** %1
; # (val P)
  %8 = load i64, i64* %5
  br label %$2
$3:
  %9 = phi i64 [%0, %$1] ; # Spec
; # (== Spec $N)
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 296) to i64)
  br i1 %10, label %$6, label %$5
$6:
  %11 = phi i64 [%9, %$3] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (box (val P)))
; # (val Ptr)
  %12 = load i8*, i8** %1
; # (i64* (val Ptr))
  %13 = bitcast i8* %12 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %14 = getelementptr i64, i64* %13, i32 1
; # (i8* (inc P))
  %15 = bitcast i64* %14 to i8*
  store i8* %15, i8** %1
; # (val P)
  %16 = load i64, i64* %13
; # (box (val P))
  %17 = call i64 @box(i64 %16)
  br label %$2
$5:
  %18 = phi i64 [%9, %$3] ; # Spec
; # (== Spec $P)
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 376) to i64)
  br i1 %19, label %$8, label %$7
$8:
  %20 = phi i64 [%18, %$5] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (box64 (val P)))
; # (val Ptr)
  %21 = load i8*, i8** %1
; # (i64* (val Ptr))
  %22 = bitcast i8* %21 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %23 = getelementptr i64, i64* %22, i32 1
; # (i8* (inc P))
  %24 = bitcast i64* %23 to i8*
  store i8* %24, i8** %1
; # (val P)
  %25 = load i64, i64* %22
; # (box64 (val P))
  %26 = and i64 %25, 17293822569102704640
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$10
$9:
  %28 = call i64 @boxNum(i64 %25)
  br label %$11
$10:
  %29 = shl i64 %25, 4
  %30 = or i64 %29, 2
  br label %$11
$11:
  %31 = phi i64 [%28, %$9], [%30, %$10] ; # ->
  br label %$2
$7:
  %32 = phi i64 [%18, %$5] ; # Spec
; # (== Spec $I)
  %33 = icmp eq i64 %32, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 360) to i64)
  br i1 %33, label %$13, label %$12
$13:
  %34 = phi i64 [%32, %$7] ; # Spec
; # (if (ge0 (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P))...
; # (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %35 = load i8*, i8** %1
; # (i32* (val Ptr))
  %36 = bitcast i8* %35 to i32*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %37 = getelementptr i32, i32* %36, i32 1
; # (i8* (inc P))
  %38 = bitcast i32* %37 to i8*
  store i8* %38, i8** %1
; # (val P)
  %39 = load i32, i32* %36
; # (ge0 (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P)))
  %40 = icmp sge i32 %39, 0
  br i1 %40, label %$14, label %$15
$14:
  %41 = phi i64 [%34, %$13] ; # Spec
; # (i64 @)
  %42 = sext i32 %39 to i64
; # (cnt (i64 @))
  %43 = shl i64 %42, 4
  %44 = or i64 %43, 2
  br label %$16
$15:
  %45 = phi i64 [%34, %$13] ; # Spec
; # (- @)
  %46 = sub i32 0, %39
; # (i64 (- @))
  %47 = sext i32 %46 to i64
; # (cnt (i64 (- @)))
  %48 = shl i64 %47, 4
  %49 = or i64 %48, 2
; # (sign (cnt (i64 (- @))))
  %50 = or i64 %49, 8
  br label %$16
$16:
  %51 = phi i64 [%41, %$14], [%45, %$15] ; # Spec
  %52 = phi i64 [%44, %$14], [%50, %$15] ; # ->
  br label %$2
$12:
  %53 = phi i64 [%32, %$7] ; # Spec
; # (== Spec $C)
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br i1 %54, label %$18, label %$17
$18:
  %55 = phi i64 [%53, %$12] ; # Spec
; # (if (fetchChar Ptr) (mkChar @) $Nil)
; # (fetchChar Ptr)
  %56 = call i32 @fetchChar(i8** %1)
  %57 = icmp ne i32 %56, 0
  br i1 %57, label %$19, label %$20
$19:
  %58 = phi i64 [%55, %$18] ; # Spec
; # (mkChar @)
  %59 = call i64 @mkChar(i32 %56)
  br label %$21
$20:
  %60 = phi i64 [%55, %$18] ; # Spec
  br label %$21
$21:
  %61 = phi i64 [%58, %$19], [%60, %$20] ; # Spec
  %62 = phi i64 [%59, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$20] ; # ->
  br label %$2
$17:
  %63 = phi i64 [%53, %$12] ; # Spec
; # (== Spec $W)
  %64 = icmp eq i64 %63, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %64, label %$23, label %$22
$23:
  %65 = phi i64 [%63, %$17] ; # Spec
; # (if (ge0 (let P (i16* (val Ptr)) (set Ptr (i8* (inc P))) (val P))...
; # (let P (i16* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %66 = load i8*, i8** %1
; # (i16* (val Ptr))
  %67 = bitcast i8* %66 to i16*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %68 = getelementptr i16, i16* %67, i32 1
; # (i8* (inc P))
  %69 = bitcast i16* %68 to i8*
  store i8* %69, i8** %1
; # (val P)
  %70 = load i16, i16* %67
; # (ge0 (let P (i16* (val Ptr)) (set Ptr (i8* (inc P))) (val P)))
  %71 = icmp sge i16 %70, 0
  br i1 %71, label %$24, label %$25
$24:
  %72 = phi i64 [%65, %$23] ; # Spec
; # (i64 @)
  %73 = sext i16 %70 to i64
; # (cnt (i64 @))
  %74 = shl i64 %73, 4
  %75 = or i64 %74, 2
  br label %$26
$25:
  %76 = phi i64 [%65, %$23] ; # Spec
; # (- @)
  %77 = sub i16 0, %70
; # (i64 (- @))
  %78 = sext i16 %77 to i64
; # (cnt (i64 (- @)))
  %79 = shl i64 %78, 4
  %80 = or i64 %79, 2
; # (sign (cnt (i64 (- @))))
  %81 = or i64 %80, 8
  br label %$26
$26:
  %82 = phi i64 [%72, %$24], [%76, %$25] ; # Spec
  %83 = phi i64 [%75, %$24], [%81, %$25] ; # ->
  br label %$2
$22:
  %84 = phi i64 [%63, %$17] ; # Spec
; # (== Spec $B)
  %85 = icmp eq i64 %84, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 344) to i64)
  br i1 %85, label %$28, label %$27
$28:
  %86 = phi i64 [%84, %$22] ; # Spec
; # (let P (val Ptr) (set Ptr (inc P)) (cnt (i64 (val P))))
; # (val Ptr)
  %87 = load i8*, i8** %1
; # (set Ptr (inc P))
; # (inc P)
  %88 = getelementptr i8, i8* %87, i32 1
  store i8* %88, i8** %1
; # (val P)
  %89 = load i8, i8* %87
; # (i64 (val P))
  %90 = zext i8 %89 to i64
; # (cnt (i64 (val P)))
  %91 = shl i64 %90, 4
  %92 = or i64 %91, 2
  br label %$2
$27:
  %93 = phi i64 [%84, %$22] ; # Spec
; # (== Spec $S)
  %94 = icmp eq i64 %93, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 328) to i64)
  br i1 %94, label %$30, label %$29
$30:
  %95 = phi i64 [%93, %$27] ; # Spec
; # (let P (i8** (val Ptr)) (set Ptr (i8* (inc P))) (mkStr (val P)))
; # (val Ptr)
  %96 = load i8*, i8** %1
; # (i8** (val Ptr))
  %97 = bitcast i8* %96 to i8**
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %98 = getelementptr i8*, i8** %97, i32 1
; # (i8* (inc P))
  %99 = bitcast i8** %98 to i8*
  store i8* %99, i8** %1
; # (val P)
  %100 = load i8*, i8** %97
; # (mkStr (val P))
  %101 = call i64 @mkStr(i8* %100)
  br label %$2
$29:
  %102 = phi i64 [%93, %$27] ; # Spec
; # (cnt? Spec)
  %103 = and i64 %102, 2
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$32, label %$31
$32:
  %105 = phi i64 [%102, %$29] ; # Spec
; # (if (sign? Spec) (natRetFloat (let P (i32* (val Ptr)) (set Ptr (i...
; # (sign? Spec)
  %106 = and i64 %105, 8
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$33, label %$34
$33:
  %108 = phi i64 [%105, %$32] ; # Spec
; # (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %109 = load i8*, i8** %1
; # (i32* (val Ptr))
  %110 = bitcast i8* %109 to i32*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %111 = getelementptr i32, i32* %110, i32 1
; # (i8* (inc P))
  %112 = bitcast i32* %111 to i8*
  store i8* %112, i8** %1
; # (val P)
  %113 = load i32, i32* %110
; # (int Spec)
  %114 = lshr i64 %108, 4
; # (natRetFloat (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val...
  %115 = call i64 @natRetFloat(i32 %113, i64 %114)
  br label %$35
$34:
  %116 = phi i64 [%105, %$32] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %117 = load i8*, i8** %1
; # (i64* (val Ptr))
  %118 = bitcast i8* %117 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %119 = getelementptr i64, i64* %118, i32 1
; # (i8* (inc P))
  %120 = bitcast i64* %119 to i8*
  store i8* %120, i8** %1
; # (val P)
  %121 = load i64, i64* %118
; # (int Spec)
  %122 = lshr i64 %116, 4
; # (natRetDouble (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (va...
  %123 = call i64 @natRetDouble(i64 %121, i64 %122)
  br label %$35
$35:
  %124 = phi i64 [%108, %$33], [%116, %$34] ; # Spec
  %125 = phi i64 [%115, %$33], [%123, %$34] ; # ->
  br label %$2
$31:
  %126 = phi i64 [%102, %$29] ; # Spec
; # (pair Spec)
  %127 = and i64 %126, 15
  %128 = icmp eq i64 %127, 0
  br i1 %128, label %$37, label %$36
$37:
  %129 = phi i64 [%126, %$31] ; # Spec
; # (let (S (++ Spec) R (natRetBuf S Ptr)) (unless (and (nil? R) (== ...
; # (++ Spec)
  %130 = inttoptr i64 %129 to i64*
  %131 = load i64, i64* %130
  %132 = getelementptr i64, i64* %130, i32 1
  %133 = load i64, i64* %132
; # (natRetBuf S Ptr)
  %134 = call i64 @natRetBuf(i64 %131, i8** %1)
; # (unless (and (nil? R) (== S $C)) (let X (setq R (save (cons R $Ni...
; # (and (nil? R) (== S $C))
; # (nil? R)
  %135 = icmp eq i64 %134, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %135, label %$39, label %$38
$39:
  %136 = phi i64 [%133, %$37] ; # Spec
  %137 = phi i64 [%131, %$37] ; # S
  %138 = phi i64 [%134, %$37] ; # R
; # (== S $C)
  %139 = icmp eq i64 %137, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br label %$38
$38:
  %140 = phi i64 [%133, %$37], [%136, %$39] ; # Spec
  %141 = phi i64 [%131, %$37], [%137, %$39] ; # S
  %142 = phi i64 [%134, %$37], [%138, %$39] ; # R
  %143 = phi i1 [0, %$37], [%139, %$39] ; # ->
  br i1 %143, label %$41, label %$40
$40:
  %144 = phi i64 [%140, %$38] ; # Spec
  %145 = phi i64 [%141, %$38] ; # S
  %146 = phi i64 [%142, %$38] ; # R
; # (let X (setq R (save (cons R $Nil))) (loop (? (cnt? Spec) (let C ...
; # (cons R $Nil)
  %147 = call i64 @cons(i64 %146, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons R $Nil))
  %148 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %149 = load i64, i64* %148
  %150 = alloca i64, i64 2, align 16
  %151 = ptrtoint i64* %150 to i64
  %152 = inttoptr i64 %151 to i64*
  store i64 %147, i64* %152
  %153 = add i64 %151, 8
  %154 = inttoptr i64 %153 to i64*
  store i64 %149, i64* %154
  %155 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %151, i64* %155
; # (loop (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (na...
  br label %$42
$42:
  %156 = phi i64 [%144, %$40], [%232, %$55] ; # Spec
  %157 = phi i64 [%145, %$40], [%233, %$55] ; # S
  %158 = phi i64 [%147, %$40], [%234, %$55] ; # R
  %159 = phi i64 [%147, %$40], [%236, %$55] ; # X
; # (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (natRetBu...
; # (cnt? Spec)
  %160 = and i64 %156, 2
  %161 = icmp ne i64 %160, 0
  br i1 %161, label %$45, label %$43
$45:
  %162 = phi i64 [%156, %$42] ; # Spec
  %163 = phi i64 [%157, %$42] ; # S
  %164 = phi i64 [%158, %$42] ; # R
  %165 = phi i64 [%159, %$42] ; # X
; # (let C (int Spec) (while (dec 'C) (let Y (natRetBuf S Ptr) (? (an...
; # (int Spec)
  %166 = lshr i64 %162, 4
; # (while (dec 'C) (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $...
  br label %$46
$46:
  %167 = phi i64 [%162, %$45], [%193, %$51] ; # Spec
  %168 = phi i64 [%163, %$45], [%194, %$51] ; # S
  %169 = phi i64 [%164, %$45], [%195, %$51] ; # R
  %170 = phi i64 [%165, %$45], [%198, %$51] ; # X
  %171 = phi i64 [%166, %$45], [%197, %$51] ; # C
; # (dec 'C)
  %172 = sub i64 %171, 1
  %173 = icmp ne i64 %172, 0
  br i1 %173, label %$47, label %$48
$47:
  %174 = phi i64 [%167, %$46] ; # Spec
  %175 = phi i64 [%168, %$46] ; # S
  %176 = phi i64 [%169, %$46] ; # R
  %177 = phi i64 [%170, %$46] ; # X
  %178 = phi i64 [%172, %$46] ; # C
; # (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $C))) (setq X (se...
; # (natRetBuf S Ptr)
  %179 = call i64 @natRetBuf(i64 %175, i8** %1)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %180 = icmp eq i64 %179, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %180, label %$50, label %$49
$50:
  %181 = phi i64 [%174, %$47] ; # Spec
  %182 = phi i64 [%175, %$47] ; # S
  %183 = phi i64 [%176, %$47] ; # R
  %184 = phi i64 [%177, %$47] ; # X
  %185 = phi i64 [%178, %$47] ; # C
; # (== S $C)
  %186 = icmp eq i64 %182, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br label %$49
$49:
  %187 = phi i64 [%174, %$47], [%181, %$50] ; # Spec
  %188 = phi i64 [%175, %$47], [%182, %$50] ; # S
  %189 = phi i64 [%176, %$47], [%183, %$50] ; # R
  %190 = phi i64 [%177, %$47], [%184, %$50] ; # X
  %191 = phi i64 [%178, %$47], [%185, %$50] ; # C
  %192 = phi i1 [0, %$47], [%186, %$50] ; # ->
  br i1 %192, label %$48, label %$51
$51:
  %193 = phi i64 [%187, %$49] ; # Spec
  %194 = phi i64 [%188, %$49] ; # S
  %195 = phi i64 [%189, %$49] ; # R
  %196 = phi i64 [%190, %$49] ; # X
  %197 = phi i64 [%191, %$49] ; # C
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %198 = call i64 @cons(i64 %179, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %199 = inttoptr i64 %196 to i64*
  %200 = getelementptr i64, i64* %199, i32 1
  store i64 %198, i64* %200
  br label %$46
$48:
  %201 = phi i64 [%167, %$46], [%187, %$49] ; # Spec
  %202 = phi i64 [%168, %$46], [%188, %$49] ; # S
  %203 = phi i64 [%169, %$46], [%189, %$49] ; # R
  %204 = phi i64 [%170, %$46], [%190, %$49] ; # X
  %205 = phi i64 [%172, %$46], [%191, %$49] ; # C
  br label %$44
$43:
  %206 = phi i64 [%156, %$42] ; # Spec
  %207 = phi i64 [%157, %$42] ; # S
  %208 = phi i64 [%158, %$42] ; # R
  %209 = phi i64 [%159, %$42] ; # X
; # (? (atom Spec))
; # (atom Spec)
  %210 = and i64 %206, 15
  %211 = icmp ne i64 %210, 0
  br i1 %211, label %$44, label %$52
$52:
  %212 = phi i64 [%206, %$43] ; # Spec
  %213 = phi i64 [%207, %$43] ; # S
  %214 = phi i64 [%208, %$43] ; # R
  %215 = phi i64 [%209, %$43] ; # X
; # (let Y (natRetBuf (setq S (++ Spec)) Ptr) (? (and (nil? Y) (== S ...
; # (++ Spec)
  %216 = inttoptr i64 %212 to i64*
  %217 = load i64, i64* %216
  %218 = getelementptr i64, i64* %216, i32 1
  %219 = load i64, i64* %218
; # (natRetBuf (setq S (++ Spec)) Ptr)
  %220 = call i64 @natRetBuf(i64 %217, i8** %1)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %221 = icmp eq i64 %220, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %221, label %$54, label %$53
$54:
  %222 = phi i64 [%219, %$52] ; # Spec
  %223 = phi i64 [%217, %$52] ; # S
  %224 = phi i64 [%214, %$52] ; # R
  %225 = phi i64 [%215, %$52] ; # X
; # (== S $C)
  %226 = icmp eq i64 %223, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br label %$53
$53:
  %227 = phi i64 [%219, %$52], [%222, %$54] ; # Spec
  %228 = phi i64 [%217, %$52], [%223, %$54] ; # S
  %229 = phi i64 [%214, %$52], [%224, %$54] ; # R
  %230 = phi i64 [%215, %$52], [%225, %$54] ; # X
  %231 = phi i1 [0, %$52], [%226, %$54] ; # ->
  br i1 %231, label %$44, label %$55
$55:
  %232 = phi i64 [%227, %$53] ; # Spec
  %233 = phi i64 [%228, %$53] ; # S
  %234 = phi i64 [%229, %$53] ; # R
  %235 = phi i64 [%230, %$53] ; # X
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %236 = call i64 @cons(i64 %220, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %237 = inttoptr i64 %235 to i64*
  %238 = getelementptr i64, i64* %237, i32 1
  store i64 %236, i64* %238
  br label %$42
$44:
  %239 = phi i64 [%201, %$48], [%206, %$43], [%227, %$53] ; # Spec
  %240 = phi i64 [%202, %$48], [%207, %$43], [%228, %$53] ; # S
  %241 = phi i64 [%203, %$48], [%208, %$43], [%229, %$53] ; # R
  %242 = phi i64 [%204, %$48], [%209, %$43], [%230, %$53] ; # X
; # (drop *Safe)
  %243 = inttoptr i64 %151 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  %245 = load i64, i64* %244
  %246 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %245, i64* %246
  br label %$41
$41:
  %247 = phi i64 [%140, %$38], [%239, %$44] ; # Spec
  %248 = phi i64 [%141, %$38], [%240, %$44] ; # S
  %249 = phi i64 [%142, %$38], [%241, %$44] ; # R
  br label %$2
$36:
  %250 = phi i64 [%126, %$31] ; # Spec
; # (natErr Spec)
  call void @natErr(i64 %250)
  unreachable
$2:
  %251 = phi i64 [%3, %$4], [%11, %$6], [%20, %$11], [%51, %$16], [%61, %$21], [%82, %$26], [%86, %$28], [%95, %$30], [%124, %$35], [%247, %$41] ; # Spec
  %252 = phi i64 [%8, %$4], [%17, %$6], [%31, %$11], [%52, %$16], [%62, %$21], [%83, %$26], [%92, %$28], [%101, %$30], [%125, %$35], [%249, %$41] ; # ->
  ret i64 %252
}

define i64 @ffi(i64, i8*, i64, i64) align 8 {
$1:
; # (let (Spec (car Args) Val (ffiCall (cond ((cnt? Fun) (i8* (int Fu...
; # (car Args)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (cond ((cnt? Fun) (i8* (int Fun))) ((big? Fun) (i8* (val (dig Fun...
; # (cnt? Fun)
  %6 = and i64 %2, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  %8 = phi i64 [%5, %$1] ; # Spec
; # (int Fun)
  %9 = lshr i64 %2, 4
; # (i8* (int Fun))
  %10 = inttoptr i64 %9 to i8*
  br label %$2
$3:
  %11 = phi i64 [%5, %$1] ; # Spec
; # (big? Fun)
  %12 = and i64 %2, 4
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = phi i64 [%11, %$3] ; # Spec
; # (dig Fun)
  %15 = add i64 %2, -4
; # (val (dig Fun))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (i8* (val (dig Fun)))
  %18 = inttoptr i64 %17 to i8*
  br label %$2
$5:
  %19 = phi i64 [%11, %$3] ; # Spec
; # (pair Fun)
  %20 = and i64 %2, 15
  %21 = icmp eq i64 %20, 0
  br i1 %21, label %$8, label %$7
$8:
  %22 = phi i64 [%19, %$5] ; # Spec
; # (argErr Exe Fun)
  call void @argErr(i64 %0, i64 %2)
  unreachable
$7:
  %23 = phi i64 [%19, %$5] ; # Spec
; # (let Nm (xName Exe Fun) (unless (ffiPrep Lib (bufString Nm (b8 (b...
; # (xName Exe Fun)
  %24 = call i64 @xName(i64 %0, i64 %2)
; # (unless (ffiPrep Lib (bufString Nm (b8 (bufSize Nm))) Args) (err ...
; # (bufSize Nm)
  %25 = call i64 @bufSize(i64 %24)
; # (b8 (bufSize Nm))
  %26 = alloca i8, i64 %25
; # (bufString Nm (b8 (bufSize Nm)))
  %27 = call i8* @bufString(i64 %24, i8* %26)
; # (ffiPrep Lib (bufString Nm (b8 (bufSize Nm))) Args)
  %28 = call i8* @ffiPrep(i8* %1, i8* %27, i64 %3)
  %29 = icmp ne i8* %28, null
  br i1 %29, label %$10, label %$9
$9:
  %30 = phi i64 [%23, %$7] ; # Spec
; # (err Exe 0 ($ "Bad ffi") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([8 x i8]* @$90 to i8*), i8* null)
  unreachable
$10:
  %31 = phi i64 [%23, %$7] ; # Spec
; # (set Fun (box64 (i64 @)))
; # (i64 @)
  %32 = ptrtoint i8* %28 to i64
; # (box64 (i64 @))
  %33 = and i64 %32, 17293822569102704640
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$11, label %$12
$11:
  %35 = call i64 @boxNum(i64 %32)
  br label %$13
$12:
  %36 = shl i64 %32, 4
  %37 = or i64 %36, 2
  br label %$13
$13:
  %38 = phi i64 [%35, %$11], [%37, %$12] ; # ->
  %39 = inttoptr i64 %2 to i64*
  store i64 %38, i64* %39
  br label %$2
$2:
  %40 = phi i64 [%8, %$4], [%14, %$6], [%31, %$13] ; # Spec
  %41 = phi i8* [%10, %$4], [%18, %$6], [%28, %$13] ; # ->
; # (cdr Args)
  %42 = inttoptr i64 %3 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
; # (ffiCall (cond ((cnt? Fun) (i8* (int Fun))) ((big? Fun) (i8* (val...
  %45 = call i64 @ffiCall(i8* %41, i64 %44)
; # (cond ((nil? Spec) $Nil) ((== Spec $T) Val) ((== Spec $N) (box Va...
; # (nil? Spec)
  %46 = icmp eq i64 %40, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %46, label %$16, label %$15
$16:
  %47 = phi i64 [%40, %$2] ; # Spec
  br label %$14
$15:
  %48 = phi i64 [%40, %$2] ; # Spec
; # (== Spec $T)
  %49 = icmp eq i64 %48, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %49, label %$18, label %$17
$18:
  %50 = phi i64 [%48, %$15] ; # Spec
  br label %$14
$17:
  %51 = phi i64 [%48, %$15] ; # Spec
; # (== Spec $N)
  %52 = icmp eq i64 %51, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 296) to i64)
  br i1 %52, label %$20, label %$19
$20:
  %53 = phi i64 [%51, %$17] ; # Spec
; # (box Val)
  %54 = call i64 @box(i64 %45)
  br label %$14
$19:
  %55 = phi i64 [%51, %$17] ; # Spec
; # (== Spec $P)
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 376) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%55, %$19] ; # Spec
; # (box64 Val)
  %58 = and i64 %45, 17293822569102704640
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$23, label %$24
$23:
  %60 = call i64 @boxNum(i64 %45)
  br label %$25
$24:
  %61 = shl i64 %45, 4
  %62 = or i64 %61, 2
  br label %$25
$25:
  %63 = phi i64 [%60, %$23], [%62, %$24] ; # ->
  br label %$14
$21:
  %64 = phi i64 [%55, %$19] ; # Spec
; # (== Spec $I)
  %65 = icmp eq i64 %64, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 360) to i64)
  br i1 %65, label %$27, label %$26
$27:
  %66 = phi i64 [%64, %$21] ; # Spec
; # (if (ge0 (i32 Val)) (cnt (i64 @)) (sign (cnt (i64 (- @)))))
; # (i32 Val)
  %67 = trunc i64 %45 to i32
; # (ge0 (i32 Val))
  %68 = icmp sge i32 %67, 0
  br i1 %68, label %$28, label %$29
$28:
  %69 = phi i64 [%66, %$27] ; # Spec
; # (i64 @)
  %70 = sext i32 %67 to i64
; # (cnt (i64 @))
  %71 = shl i64 %70, 4
  %72 = or i64 %71, 2
  br label %$30
$29:
  %73 = phi i64 [%66, %$27] ; # Spec
; # (- @)
  %74 = sub i32 0, %67
; # (i64 (- @))
  %75 = sext i32 %74 to i64
; # (cnt (i64 (- @)))
  %76 = shl i64 %75, 4
  %77 = or i64 %76, 2
; # (sign (cnt (i64 (- @))))
  %78 = or i64 %77, 8
  br label %$30
$30:
  %79 = phi i64 [%69, %$28], [%73, %$29] ; # Spec
  %80 = phi i64 [%72, %$28], [%78, %$29] ; # ->
  br label %$14
$26:
  %81 = phi i64 [%64, %$21] ; # Spec
; # (== Spec $C)
  %82 = icmp eq i64 %81, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br i1 %82, label %$32, label %$31
$32:
  %83 = phi i64 [%81, %$26] ; # Spec
; # (if (i32 Val) (mkChar @) $Nil)
; # (i32 Val)
  %84 = trunc i64 %45 to i32
  %85 = icmp ne i32 %84, 0
  br i1 %85, label %$33, label %$34
$33:
  %86 = phi i64 [%83, %$32] ; # Spec
; # (mkChar @)
  %87 = call i64 @mkChar(i32 %84)
  br label %$35
$34:
  %88 = phi i64 [%83, %$32] ; # Spec
  br label %$35
$35:
  %89 = phi i64 [%86, %$33], [%88, %$34] ; # Spec
  %90 = phi i64 [%87, %$33], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$34] ; # ->
  br label %$14
$31:
  %91 = phi i64 [%81, %$26] ; # Spec
; # (== Spec $W)
  %92 = icmp eq i64 %91, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %92, label %$37, label %$36
$37:
  %93 = phi i64 [%91, %$31] ; # Spec
; # (if (ge0 (i16 Val)) (cnt (i64 @)) (sign (cnt (i64 (- @)))))
; # (i16 Val)
  %94 = trunc i64 %45 to i16
; # (ge0 (i16 Val))
  %95 = icmp sge i16 %94, 0
  br i1 %95, label %$38, label %$39
$38:
  %96 = phi i64 [%93, %$37] ; # Spec
; # (i64 @)
  %97 = sext i16 %94 to i64
; # (cnt (i64 @))
  %98 = shl i64 %97, 4
  %99 = or i64 %98, 2
  br label %$40
$39:
  %100 = phi i64 [%93, %$37] ; # Spec
; # (- @)
  %101 = sub i16 0, %94
; # (i64 (- @))
  %102 = sext i16 %101 to i64
; # (cnt (i64 (- @)))
  %103 = shl i64 %102, 4
  %104 = or i64 %103, 2
; # (sign (cnt (i64 (- @))))
  %105 = or i64 %104, 8
  br label %$40
$40:
  %106 = phi i64 [%96, %$38], [%100, %$39] ; # Spec
  %107 = phi i64 [%99, %$38], [%105, %$39] ; # ->
  br label %$14
$36:
  %108 = phi i64 [%91, %$31] ; # Spec
; # (== Spec $B)
  %109 = icmp eq i64 %108, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 344) to i64)
  br i1 %109, label %$42, label %$41
$42:
  %110 = phi i64 [%108, %$36] ; # Spec
; # (i8 Val)
  %111 = trunc i64 %45 to i8
; # (i64 (i8 Val))
  %112 = zext i8 %111 to i64
; # (cnt (i64 (i8 Val)))
  %113 = shl i64 %112, 4
  %114 = or i64 %113, 2
  br label %$14
$41:
  %115 = phi i64 [%108, %$36] ; # Spec
; # (== Spec $S)
  %116 = icmp eq i64 %115, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 328) to i64)
  br i1 %116, label %$44, label %$43
$44:
  %117 = phi i64 [%115, %$41] ; # Spec
; # (i8* Val)
  %118 = inttoptr i64 %45 to i8*
; # (mkStr (i8* Val))
  %119 = call i64 @mkStr(i8* %118)
  br label %$14
$43:
  %120 = phi i64 [%115, %$41] ; # Spec
; # (cnt? Spec)
  %121 = and i64 %120, 2
  %122 = icmp ne i64 %121, 0
  br i1 %122, label %$46, label %$45
$46:
  %123 = phi i64 [%120, %$43] ; # Spec
; # (if (sign? Spec) (natRetFloat (i32 Val) (int Spec)) (natRetDouble...
; # (sign? Spec)
  %124 = and i64 %123, 8
  %125 = icmp ne i64 %124, 0
  br i1 %125, label %$47, label %$48
$47:
  %126 = phi i64 [%123, %$46] ; # Spec
; # (i32 Val)
  %127 = trunc i64 %45 to i32
; # (int Spec)
  %128 = lshr i64 %126, 4
; # (natRetFloat (i32 Val) (int Spec))
  %129 = call i64 @natRetFloat(i32 %127, i64 %128)
  br label %$49
$48:
  %130 = phi i64 [%123, %$46] ; # Spec
; # (int Spec)
  %131 = lshr i64 %130, 4
; # (natRetDouble Val (int Spec))
  %132 = call i64 @natRetDouble(i64 %45, i64 %131)
  br label %$49
$49:
  %133 = phi i64 [%126, %$47], [%130, %$48] ; # Spec
  %134 = phi i64 [%129, %$47], [%132, %$48] ; # ->
  br label %$14
$45:
  %135 = phi i64 [%120, %$43] ; # Spec
; # (and (pair Spec) Val)
; # (pair Spec)
  %136 = and i64 %135, 15
  %137 = icmp eq i64 %136, 0
  br i1 %137, label %$51, label %$50
$51:
  %138 = phi i64 [%135, %$45] ; # Spec
  %139 = icmp ne i64 %45, 0
  br label %$50
$50:
  %140 = phi i64 [%135, %$45], [%138, %$51] ; # Spec
  %141 = phi i1 [0, %$45], [%139, %$51] ; # ->
  br i1 %141, label %$53, label %$52
$53:
  %142 = phi i64 [%140, %$50] ; # Spec
; # (let (Ptr (i8** (push Val)) S (++ Spec) R (natRetBuf S Ptr)) (unl...
; # (push Val)
  %143 = alloca i64, i64 1
  store i64 %45, i64* %143
; # (i8** (push Val))
  %144 = bitcast i64* %143 to i8**
; # (++ Spec)
  %145 = inttoptr i64 %142 to i64*
  %146 = load i64, i64* %145
  %147 = getelementptr i64, i64* %145, i32 1
  %148 = load i64, i64* %147
; # (natRetBuf S Ptr)
  %149 = call i64 @natRetBuf(i64 %146, i8** %144)
; # (unless (and (nil? R) (== S $C)) (let X (setq R (save (cons R $Ni...
; # (and (nil? R) (== S $C))
; # (nil? R)
  %150 = icmp eq i64 %149, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %150, label %$55, label %$54
$55:
  %151 = phi i64 [%148, %$53] ; # Spec
  %152 = phi i64 [%146, %$53] ; # S
  %153 = phi i64 [%149, %$53] ; # R
; # (== S $C)
  %154 = icmp eq i64 %152, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br label %$54
$54:
  %155 = phi i64 [%148, %$53], [%151, %$55] ; # Spec
  %156 = phi i64 [%146, %$53], [%152, %$55] ; # S
  %157 = phi i64 [%149, %$53], [%153, %$55] ; # R
  %158 = phi i1 [0, %$53], [%154, %$55] ; # ->
  br i1 %158, label %$57, label %$56
$56:
  %159 = phi i64 [%155, %$54] ; # Spec
  %160 = phi i64 [%156, %$54] ; # S
  %161 = phi i64 [%157, %$54] ; # R
; # (let X (setq R (save (cons R $Nil))) (loop (? (cnt? Spec) (let C ...
; # (cons R $Nil)
  %162 = call i64 @cons(i64 %161, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons R $Nil))
  %163 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %164 = load i64, i64* %163
  %165 = alloca i64, i64 2, align 16
  %166 = ptrtoint i64* %165 to i64
  %167 = inttoptr i64 %166 to i64*
  store i64 %162, i64* %167
  %168 = add i64 %166, 8
  %169 = inttoptr i64 %168 to i64*
  store i64 %164, i64* %169
  %170 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %166, i64* %170
; # (loop (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (na...
  br label %$58
$58:
  %171 = phi i64 [%159, %$56], [%247, %$71] ; # Spec
  %172 = phi i64 [%160, %$56], [%248, %$71] ; # S
  %173 = phi i64 [%162, %$56], [%249, %$71] ; # R
  %174 = phi i64 [%162, %$56], [%251, %$71] ; # X
; # (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (natRetBu...
; # (cnt? Spec)
  %175 = and i64 %171, 2
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$61, label %$59
$61:
  %177 = phi i64 [%171, %$58] ; # Spec
  %178 = phi i64 [%172, %$58] ; # S
  %179 = phi i64 [%173, %$58] ; # R
  %180 = phi i64 [%174, %$58] ; # X
; # (let C (int Spec) (while (dec 'C) (let Y (natRetBuf S Ptr) (? (an...
; # (int Spec)
  %181 = lshr i64 %177, 4
; # (while (dec 'C) (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $...
  br label %$62
$62:
  %182 = phi i64 [%177, %$61], [%208, %$67] ; # Spec
  %183 = phi i64 [%178, %$61], [%209, %$67] ; # S
  %184 = phi i64 [%179, %$61], [%210, %$67] ; # R
  %185 = phi i64 [%180, %$61], [%213, %$67] ; # X
  %186 = phi i64 [%181, %$61], [%212, %$67] ; # C
; # (dec 'C)
  %187 = sub i64 %186, 1
  %188 = icmp ne i64 %187, 0
  br i1 %188, label %$63, label %$64
$63:
  %189 = phi i64 [%182, %$62] ; # Spec
  %190 = phi i64 [%183, %$62] ; # S
  %191 = phi i64 [%184, %$62] ; # R
  %192 = phi i64 [%185, %$62] ; # X
  %193 = phi i64 [%187, %$62] ; # C
; # (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $C))) (setq X (se...
; # (natRetBuf S Ptr)
  %194 = call i64 @natRetBuf(i64 %190, i8** %144)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %195 = icmp eq i64 %194, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %195, label %$66, label %$65
$66:
  %196 = phi i64 [%189, %$63] ; # Spec
  %197 = phi i64 [%190, %$63] ; # S
  %198 = phi i64 [%191, %$63] ; # R
  %199 = phi i64 [%192, %$63] ; # X
  %200 = phi i64 [%193, %$63] ; # C
; # (== S $C)
  %201 = icmp eq i64 %197, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br label %$65
$65:
  %202 = phi i64 [%189, %$63], [%196, %$66] ; # Spec
  %203 = phi i64 [%190, %$63], [%197, %$66] ; # S
  %204 = phi i64 [%191, %$63], [%198, %$66] ; # R
  %205 = phi i64 [%192, %$63], [%199, %$66] ; # X
  %206 = phi i64 [%193, %$63], [%200, %$66] ; # C
  %207 = phi i1 [0, %$63], [%201, %$66] ; # ->
  br i1 %207, label %$64, label %$67
$67:
  %208 = phi i64 [%202, %$65] ; # Spec
  %209 = phi i64 [%203, %$65] ; # S
  %210 = phi i64 [%204, %$65] ; # R
  %211 = phi i64 [%205, %$65] ; # X
  %212 = phi i64 [%206, %$65] ; # C
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %213 = call i64 @cons(i64 %194, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %214 = inttoptr i64 %211 to i64*
  %215 = getelementptr i64, i64* %214, i32 1
  store i64 %213, i64* %215
  br label %$62
$64:
  %216 = phi i64 [%182, %$62], [%202, %$65] ; # Spec
  %217 = phi i64 [%183, %$62], [%203, %$65] ; # S
  %218 = phi i64 [%184, %$62], [%204, %$65] ; # R
  %219 = phi i64 [%185, %$62], [%205, %$65] ; # X
  %220 = phi i64 [%187, %$62], [%206, %$65] ; # C
  br label %$60
$59:
  %221 = phi i64 [%171, %$58] ; # Spec
  %222 = phi i64 [%172, %$58] ; # S
  %223 = phi i64 [%173, %$58] ; # R
  %224 = phi i64 [%174, %$58] ; # X
; # (? (atom Spec))
; # (atom Spec)
  %225 = and i64 %221, 15
  %226 = icmp ne i64 %225, 0
  br i1 %226, label %$60, label %$68
$68:
  %227 = phi i64 [%221, %$59] ; # Spec
  %228 = phi i64 [%222, %$59] ; # S
  %229 = phi i64 [%223, %$59] ; # R
  %230 = phi i64 [%224, %$59] ; # X
; # (let Y (natRetBuf (setq S (++ Spec)) Ptr) (? (and (nil? Y) (== S ...
; # (++ Spec)
  %231 = inttoptr i64 %227 to i64*
  %232 = load i64, i64* %231
  %233 = getelementptr i64, i64* %231, i32 1
  %234 = load i64, i64* %233
; # (natRetBuf (setq S (++ Spec)) Ptr)
  %235 = call i64 @natRetBuf(i64 %232, i8** %144)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %236 = icmp eq i64 %235, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %236, label %$70, label %$69
$70:
  %237 = phi i64 [%234, %$68] ; # Spec
  %238 = phi i64 [%232, %$68] ; # S
  %239 = phi i64 [%229, %$68] ; # R
  %240 = phi i64 [%230, %$68] ; # X
; # (== S $C)
  %241 = icmp eq i64 %238, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 312) to i64)
  br label %$69
$69:
  %242 = phi i64 [%234, %$68], [%237, %$70] ; # Spec
  %243 = phi i64 [%232, %$68], [%238, %$70] ; # S
  %244 = phi i64 [%229, %$68], [%239, %$70] ; # R
  %245 = phi i64 [%230, %$68], [%240, %$70] ; # X
  %246 = phi i1 [0, %$68], [%241, %$70] ; # ->
  br i1 %246, label %$60, label %$71
$71:
  %247 = phi i64 [%242, %$69] ; # Spec
  %248 = phi i64 [%243, %$69] ; # S
  %249 = phi i64 [%244, %$69] ; # R
  %250 = phi i64 [%245, %$69] ; # X
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %251 = call i64 @cons(i64 %235, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %252 = inttoptr i64 %250 to i64*
  %253 = getelementptr i64, i64* %252, i32 1
  store i64 %251, i64* %253
  br label %$58
$60:
  %254 = phi i64 [%216, %$64], [%221, %$59], [%242, %$69] ; # Spec
  %255 = phi i64 [%217, %$64], [%222, %$59], [%243, %$69] ; # S
  %256 = phi i64 [%218, %$64], [%223, %$59], [%244, %$69] ; # R
  %257 = phi i64 [%219, %$64], [%224, %$59], [%245, %$69] ; # X
; # (drop *Safe)
  %258 = inttoptr i64 %166 to i64*
  %259 = getelementptr i64, i64* %258, i32 1
  %260 = load i64, i64* %259
  %261 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %260, i64* %261
  br label %$57
$57:
  %262 = phi i64 [%155, %$54], [%254, %$60] ; # Spec
  %263 = phi i64 [%156, %$54], [%255, %$60] ; # S
  %264 = phi i64 [%157, %$54], [%256, %$60] ; # R
  br label %$14
$52:
  %265 = phi i64 [%140, %$50] ; # Spec
; # (natErr Spec)
  call void @natErr(i64 %265)
  unreachable
$14:
  %266 = phi i64 [%47, %$16], [%50, %$18], [%53, %$20], [%57, %$25], [%79, %$30], [%89, %$35], [%106, %$40], [%110, %$42], [%117, %$44], [%133, %$49], [%262, %$57] ; # Spec
  %267 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%45, %$18], [%54, %$20], [%63, %$25], [%80, %$30], [%90, %$35], [%107, %$40], [%114, %$42], [%119, %$44], [%134, %$49], [%264, %$57] ; # ->
  ret i64 %267
}

define i64 @_nat(i64) align 8 {
$1:
; # (let (X (cdr Exe) Fun (save (eval (++ X))) Args (save (cons (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = add i64 %19, 8
  %22 = inttoptr i64 %21 to i64*
  store i64 %17, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (cons (eval (++ X)) $Nil)
  %36 = call i64 @cons(i64 %35, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons (eval (++ X)) $Nil))
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %38 = load i64, i64* %37
  %39 = alloca i64, i64 2, align 16
  %40 = ptrtoint i64* %39 to i64
  %41 = inttoptr i64 %40 to i64*
  store i64 %36, i64* %41
  %42 = add i64 %40, 8
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %44
; # (while (pair X) (let Z (push (save (eval (++ X))) $Nil) (set 2 L ...
  br label %$12
$12:
  %45 = phi i64 [%27, %$7], [%54, %$15] ; # X
  %46 = phi i64 [%36, %$7], [%72, %$15] ; # L
; # (pair X)
  %47 = and i64 %45, 15
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %$13, label %$14
$13:
  %49 = phi i64 [%45, %$12] ; # X
  %50 = phi i64 [%46, %$12] ; # L
; # (let Z (push (save (eval (++ X))) $Nil) (set 2 L Z) (setq L Z))
; # (++ X)
  %51 = inttoptr i64 %49 to i64*
  %52 = load i64, i64* %51
  %53 = getelementptr i64, i64* %51, i32 1
  %54 = load i64, i64* %53
; # (eval (++ X))
  %55 = and i64 %52, 6
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$17, label %$16
$17:
  br label %$15
$16:
  %57 = and i64 %52, 8
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$19, label %$18
$19:
  %59 = inttoptr i64 %52 to i64*
  %60 = load i64, i64* %59
  br label %$15
$18:
  %61 = call i64 @evList(i64 %52)
  br label %$15
$15:
  %62 = phi i64 [%52, %$17], [%60, %$19], [%61, %$18] ; # ->
; # (save (eval (++ X)))
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %64 = load i64, i64* %63
  %65 = alloca i64, i64 2, align 16
  %66 = ptrtoint i64* %65 to i64
  %67 = inttoptr i64 %66 to i64*
  store i64 %62, i64* %67
  %68 = add i64 %66, 8
  %69 = inttoptr i64 %68 to i64*
  store i64 %64, i64* %69
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %66, i64* %70
; # (push (save (eval (++ X))) $Nil)
  %71 = alloca i64, i64 2, align 16
  %72 = ptrtoint i64* %71 to i64
  %73 = inttoptr i64 %72 to i64*
  store i64 %62, i64* %73
  %74 = add i64 %72, 8
  %75 = inttoptr i64 %74 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %75
; # (set 2 L Z)
  %76 = inttoptr i64 %50 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  store i64 %72, i64* %77
  br label %$12
$14:
  %78 = phi i64 [%45, %$12] ; # X
  %79 = phi i64 [%46, %$12] ; # L
; # (ffi Exe null Fun Args)
  %80 = tail call i64 @ffi(i64 %0, i8* null, i64 %15, i64 %36)
; # (drop *Safe)
  %81 = inttoptr i64 %19 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_native(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (eval (++ X)) Lib (cond ((cnt? Y) (i8* (int Y...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((cnt? Y) (i8* (int Y))) ((big? Y) (i8* (val (dig Y)))) ((p...
; # (cnt? Y)
  %16 = and i64 %15, 2
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = phi i64 [%7, %$2] ; # X
; # (int Y)
  %19 = lshr i64 %15, 4
; # (i8* (int Y))
  %20 = inttoptr i64 %19 to i8*
  br label %$7
$8:
  %21 = phi i64 [%7, %$2] ; # X
; # (big? Y)
  %22 = and i64 %15, 4
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$11:
  %24 = phi i64 [%21, %$8] ; # X
; # (dig Y)
  %25 = add i64 %15, -4
; # (val (dig Y))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (i8* (val (dig Y)))
  %28 = inttoptr i64 %27 to i8*
  br label %$7
$10:
  %29 = phi i64 [%21, %$8] ; # X
; # (pair Y)
  %30 = and i64 %15, 15
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$13, label %$12
$13:
  %32 = phi i64 [%29, %$10] ; # X
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %15)
  unreachable
$12:
  %33 = phi i64 [%29, %$10] ; # X
; # (xName Exe Y)
  %34 = call i64 @xName(i64 %0, i64 %15)
; # (| 2 (>> -4 (char "@")))
; # (== (xName Exe Y) (| 2 (>> -4 (char "@"))))
  %35 = icmp eq i64 %34, 1026
  br i1 %35, label %$15, label %$14
$15:
  %36 = phi i64 [%33, %$12] ; # X
; # (set Y ZERO)
  %37 = inttoptr i64 %15 to i64*
  store i64 2, i64* %37
  br label %$7
$14:
  %38 = phi i64 [%33, %$12] ; # X
; # (unless (dlOpen (pathString @ (b8 (pathSize @)))) (err Exe Y ($ "...
; # (pathSize @)
  %39 = call i64 @pathSize(i64 %34)
; # (b8 (pathSize @))
  %40 = alloca i8, i64 %39
; # (pathString @ (b8 (pathSize @)))
  %41 = call i8* @pathString(i64 %34, i8* %40)
; # (dlOpen (pathString @ (b8 (pathSize @))))
  %42 = call i8* @dlOpen(i8* %41)
  %43 = icmp ne i8* %42, null
  br i1 %43, label %$17, label %$16
$16:
  %44 = phi i64 [%38, %$14] ; # X
; # (dlerror)
  %45 = call i8* @dlerror()
; # (err Exe Y ($ "[DLL] %s") (dlerror))
  call void @err(i64 %0, i64 %15, i8* bitcast ([9 x i8]* @$91 to i8*), i8* %45)
  unreachable
$17:
  %46 = phi i64 [%38, %$14] ; # X
; # (set Y (box64 (i64 @)))
; # (i64 @)
  %47 = ptrtoint i8* %42 to i64
; # (box64 (i64 @))
  %48 = and i64 %47, 17293822569102704640
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$19
$18:
  %50 = call i64 @boxNum(i64 %47)
  br label %$20
$19:
  %51 = shl i64 %47, 4
  %52 = or i64 %51, 2
  br label %$20
$20:
  %53 = phi i64 [%50, %$18], [%52, %$19] ; # ->
  %54 = inttoptr i64 %15 to i64*
  store i64 %53, i64* %54
  br label %$7
$7:
  %55 = phi i64 [%18, %$9], [%24, %$11], [%36, %$15], [%46, %$20] ; # X
  %56 = phi i8* [%20, %$9], [%28, %$11], [null, %$15], [%42, %$20] ; # ->
; # (++ X)
  %57 = inttoptr i64 %55 to i64*
  %58 = load i64, i64* %57
  %59 = getelementptr i64, i64* %57, i32 1
  %60 = load i64, i64* %59
; # (eval (++ X))
  %61 = and i64 %58, 6
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$23, label %$22
$23:
  br label %$21
$22:
  %63 = and i64 %58, 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$25, label %$24
$25:
  %65 = inttoptr i64 %58 to i64*
  %66 = load i64, i64* %65
  br label %$21
$24:
  %67 = call i64 @evList(i64 %58)
  br label %$21
$21:
  %68 = phi i64 [%58, %$23], [%66, %$25], [%67, %$24] ; # ->
; # (save (eval (++ X)))
  %69 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %70 = load i64, i64* %69
  %71 = alloca i64, i64 2, align 16
  %72 = ptrtoint i64* %71 to i64
  %73 = inttoptr i64 %72 to i64*
  store i64 %68, i64* %73
  %74 = add i64 %72, 8
  %75 = inttoptr i64 %74 to i64*
  store i64 %70, i64* %75
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %72, i64* %76
; # (++ X)
  %77 = inttoptr i64 %60 to i64*
  %78 = load i64, i64* %77
  %79 = getelementptr i64, i64* %77, i32 1
  %80 = load i64, i64* %79
; # (eval (++ X))
  %81 = and i64 %78, 6
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$28, label %$27
$28:
  br label %$26
$27:
  %83 = and i64 %78, 8
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$30, label %$29
$30:
  %85 = inttoptr i64 %78 to i64*
  %86 = load i64, i64* %85
  br label %$26
$29:
  %87 = call i64 @evList(i64 %78)
  br label %$26
$26:
  %88 = phi i64 [%78, %$28], [%86, %$30], [%87, %$29] ; # ->
; # (cons (eval (++ X)) $Nil)
  %89 = call i64 @cons(i64 %88, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons (eval (++ X)) $Nil))
  %90 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %91 = load i64, i64* %90
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %93 to i64*
  store i64 %89, i64* %94
  %95 = add i64 %93, 8
  %96 = inttoptr i64 %95 to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %93, i64* %97
; # (while (pair X) (let Z (push (save (eval (++ X))) $Nil) (set 2 L ...
  br label %$31
$31:
  %98 = phi i64 [%80, %$26], [%107, %$34] ; # X
  %99 = phi i64 [%89, %$26], [%125, %$34] ; # L
; # (pair X)
  %100 = and i64 %98, 15
  %101 = icmp eq i64 %100, 0
  br i1 %101, label %$32, label %$33
$32:
  %102 = phi i64 [%98, %$31] ; # X
  %103 = phi i64 [%99, %$31] ; # L
; # (let Z (push (save (eval (++ X))) $Nil) (set 2 L Z) (setq L Z))
; # (++ X)
  %104 = inttoptr i64 %102 to i64*
  %105 = load i64, i64* %104
  %106 = getelementptr i64, i64* %104, i32 1
  %107 = load i64, i64* %106
; # (eval (++ X))
  %108 = and i64 %105, 6
  %109 = icmp ne i64 %108, 0
  br i1 %109, label %$36, label %$35
$36:
  br label %$34
$35:
  %110 = and i64 %105, 8
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$38, label %$37
$38:
  %112 = inttoptr i64 %105 to i64*
  %113 = load i64, i64* %112
  br label %$34
$37:
  %114 = call i64 @evList(i64 %105)
  br label %$34
$34:
  %115 = phi i64 [%105, %$36], [%113, %$38], [%114, %$37] ; # ->
; # (save (eval (++ X)))
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %117 = load i64, i64* %116
  %118 = alloca i64, i64 2, align 16
  %119 = ptrtoint i64* %118 to i64
  %120 = inttoptr i64 %119 to i64*
  store i64 %115, i64* %120
  %121 = add i64 %119, 8
  %122 = inttoptr i64 %121 to i64*
  store i64 %117, i64* %122
  %123 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %119, i64* %123
; # (push (save (eval (++ X))) $Nil)
  %124 = alloca i64, i64 2, align 16
  %125 = ptrtoint i64* %124 to i64
  %126 = inttoptr i64 %125 to i64*
  store i64 %115, i64* %126
  %127 = add i64 %125, 8
  %128 = inttoptr i64 %127 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %128
; # (set 2 L Z)
  %129 = inttoptr i64 %103 to i64*
  %130 = getelementptr i64, i64* %129, i32 1
  store i64 %125, i64* %130
  br label %$31
$33:
  %131 = phi i64 [%98, %$31] ; # X
  %132 = phi i64 [%99, %$31] ; # L
; # (ffi Exe Lib Fun Args)
  %133 = tail call i64 @ffi(i64 %0, i8* %56, i64 %68, i64 %89)
; # (drop *Safe)
  %134 = inttoptr i64 %72 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  %136 = load i64, i64* %135
  %137 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %136, i64* %137
  ret i64 %133
}

define i64 @_struct(i64) align 8 {
$1:
; # (let (X (cdr Exe) N (if (cnt? (needNum Exe (eval (++ X)))) (int @...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cnt? (needNum Exe (eval (++ X))))
  %18 = and i64 %15, 2
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  %20 = phi i64 [%7, %$8] ; # X
; # (int @)
  %21 = lshr i64 %15, 4
  br label %$11
$10:
  %22 = phi i64 [%7, %$8] ; # X
; # (dig @)
  %23 = add i64 %15, -4
; # (val (dig @))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  br label %$11
$11:
  %26 = phi i64 [%20, %$9], [%22, %$10] ; # X
  %27 = phi i64 [%21, %$9], [%25, %$10] ; # ->
; # (i8* N)
  %28 = inttoptr i64 %27 to i8*
; # (car X)
  %29 = inttoptr i64 %26 to i64*
  %30 = load i64, i64* %29
; # (eval (car X))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$14, label %$13
$14:
  br label %$12
$13:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$16, label %$15
$16:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$12
$15:
  %37 = call i64 @evList(i64 %30)
  br label %$12
$12:
  %38 = phi i64 [%30, %$14], [%36, %$16], [%37, %$15] ; # ->
; # (save (eval (car X)))
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = add i64 %42, 8
  %45 = inttoptr i64 %44 to i64*
  store i64 %40, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %46
; # (while (pair (shift X)) (setq P (ofs P (natBuf (eval (car X)) P))...
  br label %$17
$17:
  %47 = phi i64 [%26, %$12], [%54, %$20] ; # X
  %48 = phi i8* [%28, %$12], [%67, %$20] ; # P
; # (shift X)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (pair (shift X))
  %52 = and i64 %51, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$18, label %$19
$18:
  %54 = phi i64 [%51, %$17] ; # X
  %55 = phi i8* [%48, %$17] ; # P
; # (car X)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
; # (eval (car X))
  %58 = and i64 %57, 6
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$22, label %$21
$22:
  br label %$20
$21:
  %60 = and i64 %57, 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$24, label %$23
$24:
  %62 = inttoptr i64 %57 to i64*
  %63 = load i64, i64* %62
  br label %$20
$23:
  %64 = call i64 @evList(i64 %57)
  br label %$20
$20:
  %65 = phi i64 [%57, %$22], [%63, %$24], [%64, %$23] ; # ->
; # (natBuf (eval (car X)) P)
  %66 = call i64 @natBuf(i64 %65, i8* %55)
; # (ofs P (natBuf (eval (car X)) P))
  %67 = getelementptr i8, i8* %55, i64 %66
  br label %$17
$19:
  %68 = phi i64 [%51, %$17] ; # X
  %69 = phi i8* [%48, %$17] ; # P
; # (cond ((nil? Y) @) ((== Y $S) (mkStr (i8* N))) (T (natRetBuf Y (i...
; # (nil? Y)
  %70 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %70, label %$27, label %$26
$27:
  %71 = phi i64 [%68, %$19] ; # X
  %72 = phi i8* [%69, %$19] ; # P
  br label %$25
$26:
  %73 = phi i64 [%68, %$19] ; # X
  %74 = phi i8* [%69, %$19] ; # P
; # (== Y $S)
  %75 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 328) to i64)
  br i1 %75, label %$29, label %$28
$29:
  %76 = phi i64 [%73, %$26] ; # X
  %77 = phi i8* [%74, %$26] ; # P
; # (i8* N)
  %78 = inttoptr i64 %27 to i8*
; # (mkStr (i8* N))
  %79 = call i64 @mkStr(i8* %78)
  br label %$25
$28:
  %80 = phi i64 [%73, %$26] ; # X
  %81 = phi i8* [%74, %$26] ; # P
; # (push N)
  %82 = alloca i64, i64 1
  store i64 %27, i64* %82
; # (i8** (push N))
  %83 = bitcast i64* %82 to i8**
; # (natRetBuf Y (i8** (push N)))
  %84 = call i64 @natRetBuf(i64 %38, i8** %83)
  br label %$25
$25:
  %85 = phi i64 [%71, %$27], [%76, %$29], [%80, %$28] ; # X
  %86 = phi i8* [%72, %$27], [%77, %$29], [%81, %$28] ; # P
  %87 = phi i64 [%38, %$27], [%79, %$29], [%84, %$28] ; # ->
; # (drop *Safe)
  %88 = inttoptr i64 %42 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %90, i64* %91
  ret i64 %87
}

define i64 @cbl(i64, i64, i64, i64, i64, i64) align 8 {
$1:
; # (let Exe (push NIL NIL ZERO Fun) (set Exe (ofs Exe 3)) (let P (se...
; # (push NIL NIL ZERO Fun)
  %6 = alloca i64, i64 4, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = add i64 %7, 16
  %9 = inttoptr i64 %8 to i64*
  store i64 2, i64* %9
  %10 = add i64 %7, 24
  %11 = inttoptr i64 %10 to i64*
  store i64 %0, i64* %11
; # (set Exe (ofs Exe 3))
; # (ofs Exe 3)
  %12 = add i64 %7, 24
  %13 = inttoptr i64 %7 to i64*
  store i64 %12, i64* %13
; # (let P (set 2 Exe (push NIL NIL ZERO (box A))) (set P (ofs P 3)) ...
; # (set 2 Exe (push NIL NIL ZERO (box A)))
; # (box A)
  %14 = call i64 @box(i64 %1)
; # (push NIL NIL ZERO (box A))
  %15 = alloca i64, i64 4, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = add i64 %16, 16
  %18 = inttoptr i64 %17 to i64*
  store i64 2, i64* %18
  %19 = add i64 %16, 24
  %20 = inttoptr i64 %19 to i64*
  store i64 %14, i64* %20
  %21 = inttoptr i64 %7 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %16, i64* %22
; # (set P (ofs P 3))
; # (ofs P 3)
  %23 = add i64 %16, 24
  %24 = inttoptr i64 %16 to i64*
  store i64 %23, i64* %24
; # (set 2 P (push NIL NIL ZERO (box B)))
; # (box B)
  %25 = call i64 @box(i64 %2)
; # (push NIL NIL ZERO (box B))
  %26 = alloca i64, i64 4, align 16
  %27 = ptrtoint i64* %26 to i64
  %28 = add i64 %27, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %27, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %25, i64* %31
  %32 = inttoptr i64 %16 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %27, i64* %33
; # (set P (ofs P 3))
; # (ofs P 3)
  %34 = add i64 %27, 24
  %35 = inttoptr i64 %27 to i64*
  store i64 %34, i64* %35
; # (set 2 P (push NIL NIL ZERO (box C)))
; # (box C)
  %36 = call i64 @box(i64 %3)
; # (push NIL NIL ZERO (box C))
  %37 = alloca i64, i64 4, align 16
  %38 = ptrtoint i64* %37 to i64
  %39 = add i64 %38, 16
  %40 = inttoptr i64 %39 to i64*
  store i64 2, i64* %40
  %41 = add i64 %38, 24
  %42 = inttoptr i64 %41 to i64*
  store i64 %36, i64* %42
  %43 = inttoptr i64 %27 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %38, i64* %44
; # (set P (ofs P 3))
; # (ofs P 3)
  %45 = add i64 %38, 24
  %46 = inttoptr i64 %38 to i64*
  store i64 %45, i64* %46
; # (set 2 P (push NIL NIL ZERO (box D)))
; # (box D)
  %47 = call i64 @box(i64 %4)
; # (push NIL NIL ZERO (box D))
  %48 = alloca i64, i64 4, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = add i64 %49, 16
  %51 = inttoptr i64 %50 to i64*
  store i64 2, i64* %51
  %52 = add i64 %49, 24
  %53 = inttoptr i64 %52 to i64*
  store i64 %47, i64* %53
  %54 = inttoptr i64 %38 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %49, i64* %55
; # (set P (ofs P 3))
; # (ofs P 3)
  %56 = add i64 %49, 24
  %57 = inttoptr i64 %49 to i64*
  store i64 %56, i64* %57
; # (set 2 P (push NIL $Nil ZERO (box E)))
; # (box E)
  %58 = call i64 @box(i64 %5)
; # (push NIL $Nil ZERO (box E))
  %59 = alloca i64, i64 4, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = add i64 %60, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %62
  %63 = add i64 %60, 16
  %64 = inttoptr i64 %63 to i64*
  store i64 2, i64* %64
  %65 = add i64 %60, 24
  %66 = inttoptr i64 %65 to i64*
  store i64 %58, i64* %66
  %67 = inttoptr i64 %49 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  store i64 %60, i64* %68
; # (set P (ofs P 3))
; # (ofs P 3)
  %69 = add i64 %60, 24
  %70 = inttoptr i64 %60 to i64*
  store i64 %69, i64* %70
; # (evList Exe)
  %71 = call i64 @evList(i64 %7)
; # (xCnt 0 (evList Exe))
  %72 = call i64 @xCnt(i64 0, i64 %71)
  ret i64 %72
}

define i64 @_cb1(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 2 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (cbl (val 2 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb2(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb3(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 6 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 5
  %7 = load i64, i64* %6
; # (cbl (val 6 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb4(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 8 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 7
  %7 = load i64, i64* %6
; # (cbl (val 8 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb5(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 10 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 9
  %7 = load i64, i64* %6
; # (cbl (val 10 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb6(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 12 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 11
  %7 = load i64, i64* %6
; # (cbl (val 12 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb7(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 14 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 13
  %7 = load i64, i64* %6
; # (cbl (val 14 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb8(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 16 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 15
  %7 = load i64, i64* %6
; # (cbl (val 16 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb9(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 18 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 17
  %7 = load i64, i64* %6
; # (cbl (val 18 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb10(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 20 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 19
  %7 = load i64, i64* %6
; # (cbl (val 20 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb11(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 22 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 21
  %7 = load i64, i64* %6
; # (cbl (val 22 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb12(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 24 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 23
  %7 = load i64, i64* %6
; # (cbl (val 24 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb13(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 26 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 25
  %7 = load i64, i64* %6
; # (cbl (val 26 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb14(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 28 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 27
  %7 = load i64, i64* %6
; # (cbl (val 28 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb15(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 30 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 29
  %7 = load i64, i64* %6
; # (cbl (val 30 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb16(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 32 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 31
  %7 = load i64, i64* %6
; # (cbl (val 32 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb17(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 34 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 33
  %7 = load i64, i64* %6
; # (cbl (val 34 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb18(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 36 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 35
  %7 = load i64, i64* %6
; # (cbl (val 36 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb19(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 38 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 37
  %7 = load i64, i64* %6
; # (cbl (val 38 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb20(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 40 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 39
  %7 = load i64, i64* %6
; # (cbl (val 40 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb21(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 42 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 41
  %7 = load i64, i64* %6
; # (cbl (val 42 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb22(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 44 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 43
  %7 = load i64, i64* %6
; # (cbl (val 44 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb23(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 46 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 45
  %7 = load i64, i64* %6
; # (cbl (val 46 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb24(i64, i64, i64, i64, i64) align 8 {
$1:
; # (val 48 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 47
  %7 = load i64, i64* %6
; # (cbl (val 48 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_lisp(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (evSym X)) (let (P $Lisp Q (i8** (cbFuns))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (let (P $Lisp Q (i8** (cbFuns))) (loop (? (== Y (val P))) (setq P...
; # (i8* $Cb)
  %5 = bitcast i64(i64,i64,i64,i64,i64)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @cbFuns to i8*), i32 0) to i64(i64,i64,i64,i64,i64)**) to i8*
; # (i8** (cbFuns))
  %6 = bitcast i8* %5 to i8**
; # (loop (? (== Y (val P))) (setq P (ofs P 2) Q (ofs Q 1)) (? (> P $...
  br label %$2
$2:
  %7 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64), %$1], [%39, %$5] ; # P
  %8 = phi i8** [%6, %$1], [%40, %$5] ; # Q
; # (? (== Y (val P)))
; # (val P)
  %9 = inttoptr i64 %7 to i64*
  %10 = load i64, i64* %9
; # (== Y (val P))
  %11 = icmp eq i64 %4, %10
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i64 [%7, %$2] ; # P
  %13 = phi i8** [%8, %$2] ; # Q
; # (ofs P 2)
  %14 = add i64 %12, 16
; # (ofs Q 1)
  %15 = getelementptr i8*, i8** %13, i32 1
; # (? (> P $LispEnd) (setq P $Lisp Q (i8** (cbFuns))) (until (nil? (...
; # (> P $LispEnd)
  %16 = icmp ugt i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 416) to i64)
  br i1 %16, label %$6, label %$5
$6:
  %17 = phi i64 [%14, %$3] ; # P
  %18 = phi i8** [%15, %$3] ; # Q
; # (i8* $Cb)
  %19 = bitcast i64(i64,i64,i64,i64,i64)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @cbFuns to i8*), i32 0) to i64(i64,i64,i64,i64,i64)**) to i8*
; # (i8** (cbFuns))
  %20 = bitcast i8* %19 to i8**
; # (until (nil? (val 2 P)) (setq P (ofs P 2) Q (ofs Q 1)) (when (> P...
  br label %$7
$7:
  %21 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 40) to i64), %$6], [%34, %$11] ; # P
  %22 = phi i8** [%20, %$6], [%35, %$11] ; # Q
; # (val 2 P)
  %23 = inttoptr i64 %21 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (nil? (val 2 P))
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %26, label %$9, label %$8
$8:
  %27 = phi i64 [%21, %$7] ; # P
  %28 = phi i8** [%22, %$7] ; # Q
; # (ofs P 2)
  %29 = add i64 %27, 16
; # (ofs Q 1)
  %30 = getelementptr i8*, i8** %28, i32 1
; # (when (> P $LispEnd) (err Exe 0 ($ "Too many callbacks") null))
; # (> P $LispEnd)
  %31 = icmp ugt i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([53 x i64]* @gcData to i8*), i32 416) to i64)
  br i1 %31, label %$10, label %$11
$10:
  %32 = phi i64 [%29, %$8] ; # P
  %33 = phi i8** [%30, %$8] ; # Q
; # (err Exe 0 ($ "Too many callbacks") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([19 x i8]* @$92 to i8*), i8* null)
  unreachable
$11:
  %34 = phi i64 [%29, %$8] ; # P
  %35 = phi i8** [%30, %$8] ; # Q
  br label %$7
$9:
  %36 = phi i64 [%21, %$7] ; # P
  %37 = phi i8** [%22, %$7] ; # Q
; # (set P Y)
  %38 = inttoptr i64 %36 to i64*
  store i64 %4, i64* %38
  br label %$4
$5:
  %39 = phi i64 [%14, %$3] ; # P
  %40 = phi i8** [%15, %$3] ; # Q
  br label %$2
$4:
  %41 = phi i64 [%7, %$2], [%36, %$9] ; # P
  %42 = phi i8** [%8, %$2], [%37, %$9] ; # Q
  %43 = phi i64 [0, %$2], [%4, %$9] ; # ->
; # (set 2 P (eval (cadr X)))
; # (cadr X)
  %44 = inttoptr i64 %3 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
; # (eval (cadr X))
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$14, label %$13
$14:
  br label %$12
$13:
  %51 = and i64 %48, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$16, label %$15
$16:
  %53 = inttoptr i64 %48 to i64*
  %54 = load i64, i64* %53
  br label %$12
$15:
  %55 = call i64 @evList(i64 %48)
  br label %$12
$12:
  %56 = phi i64 [%48, %$14], [%54, %$16], [%55, %$15] ; # ->
  %57 = inttoptr i64 %41 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
; # (val Q)
  %59 = load i8*, i8** %42
; # (i64 (val Q))
  %60 = ptrtoint i8* %59 to i64
; # (box64 (i64 (val Q)))
  %61 = and i64 %60, 17293822569102704640
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$17, label %$18
$17:
  %63 = call i64 @boxNum(i64 %60)
  br label %$19
$18:
  %64 = shl i64 %60, 4
  %65 = or i64 %64, 2
  br label %$19
$19:
  %66 = phi i64 [%63, %$17], [%65, %$18] ; # ->
  ret i64 %66
}

define i64 @_args(i64) align 8 {
$1:
; # (if (pair (val $Next)) $T $Nil)
; # (val $Next)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %2 = load i64, i64* %1
; # (pair (val $Next))
  %3 = and i64 %2, 15
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %5 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %5
}

define i64 @_next(i64) align 8 {
$1:
; # (let X (val $Next) (set $Next (car X)) (cdr X))
; # (val $Next)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %2 = load i64, i64* %1
; # (set $Next (car X))
; # (car X)
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  store i64 %4, i64* %5
; # (cdr X)
  %6 = inttoptr i64 %2 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
  ret i64 %8
}

define i64 @_arg(i64) align 8 {
$1:
; # (if (le0 (evCnt Exe (cdr Exe))) $Nil (let (N @ X (val $Next)) (wh...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe (cdr Exe))
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (le0 (evCnt Exe (cdr Exe)))
  %5 = icmp sle i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let (N @ X (val $Next)) (while (gt0 (dec 'N)) (setq X (car X))) ...
; # (val $Next)
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %7 = load i64, i64* %6
; # (while (gt0 (dec 'N)) (setq X (car X)))
  br label %$5
$5:
  %8 = phi i64 [%4, %$3], [%12, %$6] ; # N
  %9 = phi i64 [%7, %$3], [%15, %$6] ; # X
; # (dec 'N)
  %10 = sub i64 %8, 1
; # (gt0 (dec 'N))
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %$6, label %$7
$6:
  %12 = phi i64 [%10, %$5] ; # N
  %13 = phi i64 [%9, %$5] ; # X
; # (car X)
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
  br label %$5
$7:
  %16 = phi i64 [%10, %$5] ; # N
  %17 = phi i64 [%9, %$5] ; # X
; # (cdr X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  br label %$4
$4:
  %21 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%20, %$7] ; # ->
  ret i64 %21
}

define i64 @_rest(i64) align 8 {
$1:
; # (let X (val $Next) (if (atom X) X (let (Y (cons (cdr X) $Nil) R (...
; # (val $Next)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 88) to i64) to i64*
  %2 = load i64, i64* %1
; # (if (atom X) X (let (Y (cons (cdr X) $Nil) R (save Y)) (while (pa...
; # (atom X)
  %3 = and i64 %2, 15
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%2, %$1] ; # X
  br label %$4
$3:
  %6 = phi i64 [%2, %$1] ; # X
; # (let (Y (cons (cdr X) $Nil) R (save Y)) (while (pair (setq X (car...
; # (cdr X)
  %7 = inttoptr i64 %6 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
; # (cons (cdr X) $Nil)
  %10 = call i64 @cons(i64 %9, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %12 = load i64, i64* %11
  %13 = alloca i64, i64 2, align 16
  %14 = ptrtoint i64* %13 to i64
  %15 = inttoptr i64 %14 to i64*
  store i64 %10, i64* %15
  %16 = add i64 %14, 8
  %17 = inttoptr i64 %16 to i64*
  store i64 %12, i64* %17
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %14, i64* %18
; # (while (pair (setq X (car X))) (setq Y (set 2 Y (cons (cdr X) $Ni...
  br label %$5
$5:
  %19 = phi i64 [%6, %$3], [%25, %$6] ; # X
  %20 = phi i64 [%10, %$3], [%30, %$6] ; # Y
; # (car X)
  %21 = inttoptr i64 %19 to i64*
  %22 = load i64, i64* %21
; # (pair (setq X (car X)))
  %23 = and i64 %22, 15
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$6, label %$7
$6:
  %25 = phi i64 [%22, %$5] ; # X
  %26 = phi i64 [%20, %$5] ; # Y
; # (set 2 Y (cons (cdr X) $Nil))
; # (cdr X)
  %27 = inttoptr i64 %25 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
; # (cons (cdr X) $Nil)
  %30 = call i64 @cons(i64 %29, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %31 = inttoptr i64 %26 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  store i64 %30, i64* %32
  br label %$5
$7:
  %33 = phi i64 [%22, %$5] ; # X
  %34 = phi i64 [%20, %$5] ; # Y
; # (drop *Safe)
  %35 = inttoptr i64 %14 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %38
  br label %$4
$4:
  %39 = phi i64 [%5, %$2], [%33, %$7] ; # X
  %40 = phi i64 [%5, %$2], [%10, %$7] ; # ->
  ret i64 %40
}

define i64 @_adr(i64) align 8 {
$1:
; # (cond ((cnt? (eval (cadr Exe))) (int @)) ((big? @) (val (dig @)))...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (cnt? (eval (cadr Exe)))
  %14 = and i64 %13, 2
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
; # (int @)
  %16 = lshr i64 %13, 4
  br label %$2
$8:
; # (big? @)
  %17 = and i64 %13, 4
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (dig @)
  %19 = add i64 %13, -4
; # (val (dig @))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
  br label %$2
$10:
; # (box64 @)
  %22 = and i64 %13, 17293822569102704640
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$13
$12:
  %24 = call i64 @boxNum(i64 %13)
  br label %$14
$13:
  %25 = shl i64 %13, 4
  %26 = or i64 %25, 2
  br label %$14
$14:
  %27 = phi i64 [%24, %$12], [%26, %$13] ; # ->
  br label %$2
$2:
  %28 = phi i64 [%16, %$9], [%21, %$11], [%27, %$14] ; # ->
  ret i64 %28
}

define i64 @_byte(i64) align 8 {
$1:
; # (let (X (cdr Exe) P (i8* (if (cnt? (needNum Exe (eval (++ X)))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cnt? (needNum Exe (eval (++ X))))
  %18 = and i64 %15, 2
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
; # (int @)
  %20 = lshr i64 %15, 4
  br label %$11
$10:
; # (dig @)
  %21 = add i64 %15, -4
; # (val (dig @))
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  br label %$11
$11:
  %24 = phi i64 [%20, %$9], [%23, %$10] ; # ->
; # (i8* (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @))...
  %25 = inttoptr i64 %24 to i8*
; # (if (atom X) (cnt (i64 (val P))) (let (Y (needCnt Exe (eval (car ...
; # (atom X)
  %26 = and i64 %7, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$12, label %$13
$12:
; # (val P)
  %28 = load i8, i8* %25
; # (i64 (val P))
  %29 = zext i8 %28 to i64
; # (cnt (i64 (val P)))
  %30 = shl i64 %29, 4
  %31 = or i64 %30, 2
  br label %$14
$13:
; # (let (Y (needCnt Exe (eval (car X))) N (int @)) (set P (i8 (if (s...
; # (car X)
  %32 = inttoptr i64 %7 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  br label %$15
$16:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$19, label %$18
$19:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$15
$18:
  %40 = call i64 @evList(i64 %33)
  br label %$15
$15:
  %41 = phi i64 [%33, %$17], [%39, %$19], [%40, %$18] ; # ->
; # (needCnt Exe (eval (car X)))
  %42 = and i64 %41, 2
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$21, label %$20
$20:
  call void @cntErr(i64 %0, i64 %41)
  unreachable
$21:
; # (int @)
  %44 = lshr i64 %41, 4
; # (set P (i8 (if (sign? Y) (- N) N)))
; # (if (sign? Y) (- N) N)
; # (sign? Y)
  %45 = and i64 %41, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$22, label %$23
$22:
; # (- N)
  %47 = sub i64 0, %44
  br label %$24
$23:
  br label %$24
$24:
  %48 = phi i64 [%47, %$22], [%44, %$23] ; # ->
; # (i8 (if (sign? Y) (- N) N))
  %49 = trunc i64 %48 to i8
  store i8 %49, i8* %25
  br label %$14
$14:
  %50 = phi i64 [%31, %$12], [%41, %$24] ; # ->
  ret i64 %50
}

define i64 @_env(i64) align 8 {
$1:
; # (let (X (cdr Exe) R (save $Nil)) (if (atom X) (let Bnd (val $Bind...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %8
  %9 = add i64 %7, 8
  %10 = inttoptr i64 %9 to i64*
  store i64 %5, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %11
; # (if (atom X) (let Bnd (val $Bind) (while Bnd (let (S (val 2 Bnd) ...
; # (atom X)
  %12 = and i64 %3, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%3, %$1] ; # X
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (let Bnd (val $Bind) (while Bnd (let (S (val 2 Bnd) Y R) (loop (?...
; # (val $Bind)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %17 = load i64, i64* %16
; # (while Bnd (let (S (val 2 Bnd) Y R) (loop (? (atom Y) (setq R (sa...
  br label %$5
$5:
  %18 = phi i64 [%14, %$2], [%59, %$10] ; # X
  %19 = phi i64 [%15, %$2], [%60, %$10] ; # R
  %20 = phi i64 [%17, %$2], [%66, %$10] ; # Bnd
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$6, label %$7
$6:
  %22 = phi i64 [%18, %$5] ; # X
  %23 = phi i64 [%19, %$5] ; # R
  %24 = phi i64 [%20, %$5] ; # Bnd
; # (let (S (val 2 Bnd) Y R) (loop (? (atom Y) (setq R (safe (cons (c...
; # (val 2 Bnd)
  %25 = inttoptr i64 %24 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (loop (? (atom Y) (setq R (safe (cons (cons S (val S)) R)))) (? (...
  br label %$8
$8:
  %28 = phi i64 [%22, %$6], [%52, %$12] ; # X
  %29 = phi i64 [%23, %$6], [%53, %$12] ; # R
  %30 = phi i64 [%24, %$6], [%54, %$12] ; # Bnd
  %31 = phi i64 [%23, %$6], [%58, %$12] ; # Y
; # (? (atom Y) (setq R (safe (cons (cons S (val S)) R))))
; # (atom Y)
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$11, label %$9
$11:
  %34 = phi i64 [%28, %$8] ; # X
  %35 = phi i64 [%29, %$8] ; # R
  %36 = phi i64 [%30, %$8] ; # Bnd
  %37 = phi i64 [%31, %$8] ; # Y
; # (val S)
  %38 = inttoptr i64 %27 to i64*
  %39 = load i64, i64* %38
; # (cons S (val S))
  %40 = call i64 @cons(i64 %27, i64 %39)
; # (cons (cons S (val S)) R)
  %41 = call i64 @cons(i64 %40, i64 %35)
; # (safe (cons (cons S (val S)) R))
  %42 = inttoptr i64 %7 to i64*
  store i64 %41, i64* %42
  br label %$10
$9:
  %43 = phi i64 [%28, %$8] ; # X
  %44 = phi i64 [%29, %$8] ; # R
  %45 = phi i64 [%30, %$8] ; # Bnd
  %46 = phi i64 [%31, %$8] ; # Y
; # (? (== S (caar Y)))
; # (caar Y)
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (== S (caar Y))
  %51 = icmp eq i64 %27, %50
  br i1 %51, label %$10, label %$12
$12:
  %52 = phi i64 [%43, %$9] ; # X
  %53 = phi i64 [%44, %$9] ; # R
  %54 = phi i64 [%45, %$9] ; # Bnd
  %55 = phi i64 [%46, %$9] ; # Y
; # (shift Y)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  br label %$8
$10:
  %59 = phi i64 [%34, %$11], [%43, %$9] ; # X
  %60 = phi i64 [%41, %$11], [%44, %$9] ; # R
  %61 = phi i64 [%36, %$11], [%45, %$9] ; # Bnd
  %62 = phi i64 [%37, %$11], [%46, %$9] ; # Y
  %63 = phi i64 [%41, %$11], [0, %$9] ; # ->
; # (val 3 Bnd)
  %64 = inttoptr i64 %61 to i64*
  %65 = getelementptr i64, i64* %64, i32 2
  %66 = load i64, i64* %65
  br label %$5
$7:
  %67 = phi i64 [%18, %$5] ; # X
  %68 = phi i64 [%19, %$5] ; # R
  %69 = phi i64 [%20, %$5] ; # Bnd
  br label %$4
$3:
  %70 = phi i64 [%3, %$1] ; # X
  %71 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (let Y (link (push $Nil NIL)) (loop (let Z (set Y (eval (++ X))) ...
; # (push $Nil NIL)
  %72 = alloca i64, i64 2, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = inttoptr i64 %73 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i64* %74
; # (link (push $Nil NIL))
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %73 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %79
; # (loop (let Z (set Y (eval (++ X))) (nond ((atom Z) (loop (let V (...
  br label %$13
$13:
  %80 = phi i64 [%70, %$3], [%170, %$35] ; # X
  %81 = phi i64 [%71, %$3], [%171, %$35] ; # R
; # (let Z (set Y (eval (++ X))) (nond ((atom Z) (loop (let V (++ Z) ...
; # (set Y (eval (++ X)))
; # (++ X)
  %82 = inttoptr i64 %80 to i64*
  %83 = load i64, i64* %82
  %84 = getelementptr i64, i64* %82, i32 1
  %85 = load i64, i64* %84
; # (eval (++ X))
  %86 = and i64 %83, 6
  %87 = icmp ne i64 %86, 0
  br i1 %87, label %$16, label %$15
$16:
  br label %$14
$15:
  %88 = and i64 %83, 8
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$18, label %$17
$18:
  %90 = inttoptr i64 %83 to i64*
  %91 = load i64, i64* %90
  br label %$14
$17:
  %92 = call i64 @evList(i64 %83)
  br label %$14
$14:
  %93 = phi i64 [%83, %$16], [%91, %$18], [%92, %$17] ; # ->
  %94 = inttoptr i64 %73 to i64*
  store i64 %93, i64* %94
; # (nond ((atom Z) (loop (let V (++ Z) (setq R (safe (cons (if (pair...
; # (atom Z)
  %95 = and i64 %93, 15
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$20, label %$21
$21:
  %97 = phi i64 [%85, %$14] ; # X
  %98 = phi i64 [%81, %$14] ; # R
  %99 = phi i64 [%93, %$14] ; # Z
; # (loop (let V (++ Z) (setq R (safe (cons (if (pair V) (cons (car V...
  br label %$22
$22:
  %100 = phi i64 [%97, %$21], [%132, %$26] ; # X
  %101 = phi i64 [%98, %$21], [%133, %$26] ; # R
  %102 = phi i64 [%99, %$21], [%134, %$26] ; # Z
; # (let V (++ Z) (setq R (safe (cons (if (pair V) (cons (car V) (cdr...
; # (++ Z)
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
  %105 = getelementptr i64, i64* %103, i32 1
  %106 = load i64, i64* %105
; # (if (pair V) (cons (car V) (cdr V)) (cons V (val V)))
; # (pair V)
  %107 = and i64 %104, 15
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %$23, label %$24
$23:
  %109 = phi i64 [%100, %$22] ; # X
  %110 = phi i64 [%101, %$22] ; # R
  %111 = phi i64 [%106, %$22] ; # Z
; # (car V)
  %112 = inttoptr i64 %104 to i64*
  %113 = load i64, i64* %112
; # (cdr V)
  %114 = inttoptr i64 %104 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
; # (cons (car V) (cdr V))
  %117 = call i64 @cons(i64 %113, i64 %116)
  br label %$25
$24:
  %118 = phi i64 [%100, %$22] ; # X
  %119 = phi i64 [%101, %$22] ; # R
  %120 = phi i64 [%106, %$22] ; # Z
; # (val V)
  %121 = inttoptr i64 %104 to i64*
  %122 = load i64, i64* %121
; # (cons V (val V))
  %123 = call i64 @cons(i64 %104, i64 %122)
  br label %$25
$25:
  %124 = phi i64 [%109, %$23], [%118, %$24] ; # X
  %125 = phi i64 [%110, %$23], [%119, %$24] ; # R
  %126 = phi i64 [%111, %$23], [%120, %$24] ; # Z
  %127 = phi i64 [%117, %$23], [%123, %$24] ; # ->
; # (cons (if (pair V) (cons (car V) (cdr V)) (cons V (val V))) R)
  %128 = call i64 @cons(i64 %127, i64 %125)
; # (safe (cons (if (pair V) (cons (car V) (cdr V)) (cons V (val V)))...
  %129 = inttoptr i64 %7 to i64*
  store i64 %128, i64* %129
; # (? (atom Z))
; # (atom Z)
  %130 = and i64 %126, 15
  %131 = icmp ne i64 %130, 0
  br i1 %131, label %$27, label %$26
$26:
  %132 = phi i64 [%124, %$25] ; # X
  %133 = phi i64 [%128, %$25] ; # R
  %134 = phi i64 [%126, %$25] ; # Z
  br label %$22
$27:
  %135 = phi i64 [%124, %$25] ; # X
  %136 = phi i64 [%128, %$25] ; # R
  %137 = phi i64 [%126, %$25] ; # Z
  %138 = phi i64 [0, %$25] ; # ->
  br label %$19
$20:
  %139 = phi i64 [%85, %$14] ; # X
  %140 = phi i64 [%81, %$14] ; # R
  %141 = phi i64 [%93, %$14] ; # Z
; # (nil? Z)
  %142 = icmp eq i64 %141, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %142, label %$28, label %$29
$29:
  %143 = phi i64 [%139, %$20] ; # X
  %144 = phi i64 [%140, %$20] ; # R
  %145 = phi i64 [%141, %$20] ; # Z
; # (++ X)
  %146 = inttoptr i64 %143 to i64*
  %147 = load i64, i64* %146
  %148 = getelementptr i64, i64* %146, i32 1
  %149 = load i64, i64* %148
; # (eval (++ X))
  %150 = and i64 %147, 6
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$32, label %$31
$32:
  br label %$30
$31:
  %152 = and i64 %147, 8
  %153 = icmp ne i64 %152, 0
  br i1 %153, label %$34, label %$33
$34:
  %154 = inttoptr i64 %147 to i64*
  %155 = load i64, i64* %154
  br label %$30
$33:
  %156 = call i64 @evList(i64 %147)
  br label %$30
$30:
  %157 = phi i64 [%147, %$32], [%155, %$34], [%156, %$33] ; # ->
; # (cons Z (eval (++ X)))
  %158 = call i64 @cons(i64 %145, i64 %157)
; # (cons (cons Z (eval (++ X))) R)
  %159 = call i64 @cons(i64 %158, i64 %144)
; # (safe (cons (cons Z (eval (++ X))) R))
  %160 = inttoptr i64 %7 to i64*
  store i64 %159, i64* %160
  br label %$19
$28:
  %161 = phi i64 [%139, %$20] ; # X
  %162 = phi i64 [%140, %$20] ; # R
  %163 = phi i64 [%141, %$20] ; # Z
  br label %$19
$19:
  %164 = phi i64 [%135, %$27], [%149, %$30], [%161, %$28] ; # X
  %165 = phi i64 [%136, %$27], [%159, %$30], [%162, %$28] ; # R
  %166 = phi i64 [%137, %$27], [%145, %$30], [%163, %$28] ; # Z
  %167 = phi i64 [%138, %$27], [%159, %$30], [0, %$28] ; # ->
; # (? (atom X))
; # (atom X)
  %168 = and i64 %164, 15
  %169 = icmp ne i64 %168, 0
  br i1 %169, label %$36, label %$35
$35:
  %170 = phi i64 [%164, %$19] ; # X
  %171 = phi i64 [%165, %$19] ; # R
  br label %$13
$36:
  %172 = phi i64 [%164, %$19] ; # X
  %173 = phi i64 [%165, %$19] ; # R
  %174 = phi i64 [0, %$19] ; # ->
  br label %$4
$4:
  %175 = phi i64 [%67, %$7], [%172, %$36] ; # X
  %176 = phi i64 [%68, %$7], [%173, %$36] ; # R
; # (drop *Safe)
  %177 = inttoptr i64 %7 to i64*
  %178 = getelementptr i64, i64* %177, i32 1
  %179 = load i64, i64* %178
  %180 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %179, i64* %180
  ret i64 %176
}

define i64 @_trail(i64) align 8 {
$1:
; # (let (F (not (nil? (eval (cadr Exe)))) Bnd (val $Bind) R $Nil) (w...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (cadr Exe))))
  %15 = icmp eq i1 %14, 0
; # (val $Bind)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %17 = load i64, i64* %16
; # (while Bnd (let S (val 2 Bnd) (cond ((== S $At) (when (val 4 Bnd)...
  br label %$7
$7:
  %18 = phi i64 [%17, %$2], [%55, %$10] ; # Bnd
  %19 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%52, %$10] ; # R
  %20 = icmp ne i64 %18, 0
  br i1 %20, label %$8, label %$9
$8:
  %21 = phi i64 [%18, %$7] ; # Bnd
  %22 = phi i64 [%19, %$7] ; # R
; # (let S (val 2 Bnd) (cond ((== S $At) (when (val 4 Bnd) (setq R (c...
; # (val 2 Bnd)
  %23 = inttoptr i64 %21 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (cond ((== S $At) (when (val 4 Bnd) (setq R (cons @ R)))) (F (set...
; # (== S $At)
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64)
  br i1 %26, label %$12, label %$11
$12:
  %27 = phi i64 [%21, %$8] ; # Bnd
  %28 = phi i64 [%22, %$8] ; # R
; # (when (val 4 Bnd) (setq R (cons @ R)))
; # (val 4 Bnd)
  %29 = inttoptr i64 %27 to i64*
  %30 = getelementptr i64, i64* %29, i32 3
  %31 = load i64, i64* %30
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$13, label %$14
$13:
  %33 = phi i64 [%27, %$12] ; # Bnd
  %34 = phi i64 [%28, %$12] ; # R
; # (cons @ R)
  %35 = call i64 @cons(i64 %31, i64 %34)
  br label %$14
$14:
  %36 = phi i64 [%27, %$12], [%33, %$13] ; # Bnd
  %37 = phi i64 [%28, %$12], [%35, %$13] ; # R
  br label %$10
$11:
  %38 = phi i64 [%21, %$8] ; # Bnd
  %39 = phi i64 [%22, %$8] ; # R
  br i1 %15, label %$16, label %$15
$16:
  %40 = phi i64 [%38, %$11] ; # Bnd
  %41 = phi i64 [%39, %$11] ; # R
; # (val S)
  %42 = inttoptr i64 %25 to i64*
  %43 = load i64, i64* %42
; # (cons (val S) R)
  %44 = call i64 @cons(i64 %43, i64 %41)
; # (cons S (cons (val S) R))
  %45 = call i64 @cons(i64 %25, i64 %44)
; # (set S (val Bnd))
; # (val Bnd)
  %46 = inttoptr i64 %40 to i64*
  %47 = load i64, i64* %46
  %48 = inttoptr i64 %25 to i64*
  store i64 %47, i64* %48
  br label %$10
$15:
  %49 = phi i64 [%38, %$11] ; # Bnd
  %50 = phi i64 [%39, %$11] ; # R
  br label %$10
$10:
  %51 = phi i64 [%36, %$14], [%40, %$16], [%49, %$15] ; # Bnd
  %52 = phi i64 [%37, %$14], [%45, %$16], [%50, %$15] ; # R
; # (val 3 Bnd)
  %53 = inttoptr i64 %51 to i64*
  %54 = getelementptr i64, i64* %53, i32 2
  %55 = load i64, i64* %54
  br label %$7
$9:
  %56 = phi i64 [%18, %$7] ; # Bnd
  %57 = phi i64 [%19, %$7] ; # R
; # (let X R (until (atom X) (when (atom (++ X)) (set @ (++ X)))))
; # (until (atom X) (when (atom (++ X)) (set @ (++ X))))
  br label %$17
$17:
  %58 = phi i64 [%56, %$9], [%80, %$21] ; # Bnd
  %59 = phi i64 [%57, %$9], [%81, %$21] ; # R
  %60 = phi i64 [%57, %$9], [%82, %$21] ; # X
; # (atom X)
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$18
$18:
  %63 = phi i64 [%58, %$17] ; # Bnd
  %64 = phi i64 [%59, %$17] ; # R
  %65 = phi i64 [%60, %$17] ; # X
; # (when (atom (++ X)) (set @ (++ X)))
; # (++ X)
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
  %68 = getelementptr i64, i64* %66, i32 1
  %69 = load i64, i64* %68
; # (atom (++ X))
  %70 = and i64 %67, 15
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$20, label %$21
$20:
  %72 = phi i64 [%63, %$18] ; # Bnd
  %73 = phi i64 [%64, %$18] ; # R
  %74 = phi i64 [%69, %$18] ; # X
; # (set @ (++ X))
; # (++ X)
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
  %77 = getelementptr i64, i64* %75, i32 1
  %78 = load i64, i64* %77
  %79 = inttoptr i64 %67 to i64*
  store i64 %76, i64* %79
  br label %$21
$21:
  %80 = phi i64 [%63, %$18], [%72, %$20] ; # Bnd
  %81 = phi i64 [%64, %$18], [%73, %$20] ; # R
  %82 = phi i64 [%69, %$18], [%78, %$20] ; # X
  br label %$17
$19:
  %83 = phi i64 [%58, %$17] ; # Bnd
  %84 = phi i64 [%59, %$17] ; # R
  %85 = phi i64 [%60, %$17] ; # X
  ret i64 %84
}

define i64 @_up(i64) align 8 {
$1:
; # (let (X (cdr Exe) Y (car X) N 1 Bnd (val $Bind)) (when (num? Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (val $Bind)
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 8) to i64) to i64*
  %7 = load i64, i64* %6
; # (when (num? Y) (setq N (int Y) Y (car (shift X))))
; # (num? Y)
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  %10 = phi i64 [%3, %$1] ; # X
  %11 = phi i64 [%5, %$1] ; # Y
  %12 = phi i64 [1, %$1] ; # N
  %13 = phi i64 [%7, %$1] ; # Bnd
; # (int Y)
  %14 = lshr i64 %11, 4
; # (shift X)
  %15 = inttoptr i64 %10 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
; # (car (shift X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  br label %$3
$3:
  %20 = phi i64 [%3, %$1], [%17, %$2] ; # X
  %21 = phi i64 [%5, %$1], [%19, %$2] ; # Y
  %22 = phi i64 [1, %$1], [%14, %$2] ; # N
  %23 = phi i64 [%7, %$1], [%13, %$2] ; # Bnd
; # (if (nil? Y) (if N (loop (? (=0 Bnd) $Nil) (? (and (== $At (val 2...
; # (nil? Y)
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %24, label %$4, label %$5
$4:
  %25 = phi i64 [%20, %$3] ; # X
  %26 = phi i64 [%21, %$3] ; # Y
  %27 = phi i64 [%22, %$3] ; # N
  %28 = phi i64 [%23, %$3] ; # Bnd
; # (if N (loop (? (=0 Bnd) $Nil) (? (and (== $At (val 2 Bnd)) (=0 (d...
  %29 = icmp ne i64 %27, 0
  br i1 %29, label %$7, label %$8
$7:
  %30 = phi i64 [%25, %$4] ; # X
  %31 = phi i64 [%26, %$4] ; # Y
  %32 = phi i64 [%27, %$4] ; # N
  %33 = phi i64 [%28, %$4] ; # Bnd
; # (loop (? (=0 Bnd) $Nil) (? (and (== $At (val 2 Bnd)) (=0 (dec 'N)...
  br label %$10
$10:
  %34 = phi i64 [%30, %$7], [%83, %$16] ; # X
  %35 = phi i64 [%31, %$7], [%84, %$16] ; # Y
  %36 = phi i64 [%32, %$7], [%85, %$16] ; # N
  %37 = phi i64 [%33, %$7], [%89, %$16] ; # Bnd
; # (? (=0 Bnd) $Nil)
; # (=0 Bnd)
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$13, label %$11
$13:
  %39 = phi i64 [%34, %$10] ; # X
  %40 = phi i64 [%35, %$10] ; # Y
  %41 = phi i64 [%36, %$10] ; # N
  %42 = phi i64 [%37, %$10] ; # Bnd
  br label %$12
$11:
  %43 = phi i64 [%34, %$10] ; # X
  %44 = phi i64 [%35, %$10] ; # Y
  %45 = phi i64 [%36, %$10] ; # N
  %46 = phi i64 [%37, %$10] ; # Bnd
; # (? (and (== $At (val 2 Bnd)) (=0 (dec 'N))) (if (val 4 Bnd) @ $Ni...
; # (and (== $At (val 2 Bnd)) (=0 (dec 'N)))
; # (val 2 Bnd)
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
; # (== $At (val 2 Bnd))
  %50 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 440) to i64), %49
  br i1 %50, label %$15, label %$14
$15:
  %51 = phi i64 [%43, %$11] ; # X
  %52 = phi i64 [%44, %$11] ; # Y
  %53 = phi i64 [%45, %$11] ; # N
  %54 = phi i64 [%46, %$11] ; # Bnd
; # (dec 'N)
  %55 = sub i64 %53, 1
; # (=0 (dec 'N))
  %56 = icmp eq i64 %55, 0
  br label %$14
$14:
  %57 = phi i64 [%43, %$11], [%51, %$15] ; # X
  %58 = phi i64 [%44, %$11], [%52, %$15] ; # Y
  %59 = phi i64 [%45, %$11], [%55, %$15] ; # N
  %60 = phi i64 [%46, %$11], [%54, %$15] ; # Bnd
  %61 = phi i1 [0, %$11], [%56, %$15] ; # ->
  br i1 %61, label %$17, label %$16
$17:
  %62 = phi i64 [%57, %$14] ; # X
  %63 = phi i64 [%58, %$14] ; # Y
  %64 = phi i64 [%59, %$14] ; # N
  %65 = phi i64 [%60, %$14] ; # Bnd
; # (if (val 4 Bnd) @ $Nil)
; # (val 4 Bnd)
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 3
  %68 = load i64, i64* %67
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$18, label %$19
$18:
  %70 = phi i64 [%62, %$17] ; # X
  %71 = phi i64 [%63, %$17] ; # Y
  %72 = phi i64 [%64, %$17] ; # N
  %73 = phi i64 [%65, %$17] ; # Bnd
  br label %$20
$19:
  %74 = phi i64 [%62, %$17] ; # X
  %75 = phi i64 [%63, %$17] ; # Y
  %76 = phi i64 [%64, %$17] ; # N
  %77 = phi i64 [%65, %$17] ; # Bnd
  br label %$20
$20:
  %78 = phi i64 [%70, %$18], [%74, %$19] ; # X
  %79 = phi i64 [%71, %$18], [%75, %$19] ; # Y
  %80 = phi i64 [%72, %$18], [%76, %$19] ; # N
  %81 = phi i64 [%73, %$18], [%77, %$19] ; # Bnd
  %82 = phi i64 [%68, %$18], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$19] ; # ->
  br label %$12
$16:
  %83 = phi i64 [%57, %$14] ; # X
  %84 = phi i64 [%58, %$14] ; # Y
  %85 = phi i64 [%59, %$14] ; # N
  %86 = phi i64 [%60, %$14] ; # Bnd
; # (val 3 Bnd)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 2
  %89 = load i64, i64* %88
  br label %$10
$12:
  %90 = phi i64 [%39, %$13], [%78, %$20] ; # X
  %91 = phi i64 [%40, %$13], [%79, %$20] ; # Y
  %92 = phi i64 [%41, %$13], [%80, %$20] ; # N
  %93 = phi i64 [%42, %$13], [%81, %$20] ; # Bnd
  %94 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%82, %$20] ; # ->
  br label %$9
$8:
  %95 = phi i64 [%25, %$4] ; # X
  %96 = phi i64 [%26, %$4] ; # Y
  %97 = phi i64 [%27, %$4] ; # N
  %98 = phi i64 [%28, %$4] ; # Bnd
  br label %$9
$9:
  %99 = phi i64 [%90, %$12], [%95, %$8] ; # X
  %100 = phi i64 [%91, %$12], [%96, %$8] ; # Y
  %101 = phi i64 [%92, %$12], [%97, %$8] ; # N
  %102 = phi i64 [%93, %$12], [%98, %$8] ; # Bnd
  %103 = phi i64 [%94, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  br label %$6
$5:
  %104 = phi i64 [%20, %$3] ; # X
  %105 = phi i64 [%21, %$3] ; # Y
  %106 = phi i64 [%22, %$3] ; # N
  %107 = phi i64 [%23, %$3] ; # Bnd
; # (let Z Y (when N (loop (? (=0 Bnd)) (? (and (== Y (val 2 Bnd)) (p...
; # (when N (loop (? (=0 Bnd)) (? (and (== Y (val 2 Bnd)) (prog (setq...
  %108 = icmp ne i64 %106, 0
  br i1 %108, label %$21, label %$22
$21:
  %109 = phi i64 [%104, %$5] ; # X
  %110 = phi i64 [%105, %$5] ; # Y
  %111 = phi i64 [%106, %$5] ; # N
  %112 = phi i64 [%107, %$5] ; # Bnd
  %113 = phi i64 [%105, %$5] ; # Z
; # (loop (? (=0 Bnd)) (? (and (== Y (val 2 Bnd)) (prog (setq Z Bnd) ...
  br label %$23
$23:
  %114 = phi i64 [%109, %$21], [%142, %$28] ; # X
  %115 = phi i64 [%110, %$21], [%143, %$28] ; # Y
  %116 = phi i64 [%111, %$21], [%144, %$28] ; # N
  %117 = phi i64 [%112, %$21], [%149, %$28] ; # Bnd
  %118 = phi i64 [%113, %$21], [%146, %$28] ; # Z
; # (? (=0 Bnd))
; # (=0 Bnd)
  %119 = icmp eq i64 %117, 0
  br i1 %119, label %$25, label %$24
$24:
  %120 = phi i64 [%114, %$23] ; # X
  %121 = phi i64 [%115, %$23] ; # Y
  %122 = phi i64 [%116, %$23] ; # N
  %123 = phi i64 [%117, %$23] ; # Bnd
  %124 = phi i64 [%118, %$23] ; # Z
; # (? (and (== Y (val 2 Bnd)) (prog (setq Z Bnd) (=0 (dec 'N)))))
; # (and (== Y (val 2 Bnd)) (prog (setq Z Bnd) (=0 (dec 'N))))
; # (val 2 Bnd)
  %125 = inttoptr i64 %123 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
; # (== Y (val 2 Bnd))
  %128 = icmp eq i64 %121, %127
  br i1 %128, label %$27, label %$26
$27:
  %129 = phi i64 [%120, %$24] ; # X
  %130 = phi i64 [%121, %$24] ; # Y
  %131 = phi i64 [%122, %$24] ; # N
  %132 = phi i64 [%123, %$24] ; # Bnd
  %133 = phi i64 [%124, %$24] ; # Z
; # (dec 'N)
  %134 = sub i64 %131, 1
; # (=0 (dec 'N))
  %135 = icmp eq i64 %134, 0
  br label %$26
$26:
  %136 = phi i64 [%120, %$24], [%129, %$27] ; # X
  %137 = phi i64 [%121, %$24], [%130, %$27] ; # Y
  %138 = phi i64 [%122, %$24], [%134, %$27] ; # N
  %139 = phi i64 [%123, %$24], [%132, %$27] ; # Bnd
  %140 = phi i64 [%124, %$24], [%132, %$27] ; # Z
  %141 = phi i1 [0, %$24], [%135, %$27] ; # ->
  br i1 %141, label %$25, label %$28
$28:
  %142 = phi i64 [%136, %$26] ; # X
  %143 = phi i64 [%137, %$26] ; # Y
  %144 = phi i64 [%138, %$26] ; # N
  %145 = phi i64 [%139, %$26] ; # Bnd
  %146 = phi i64 [%140, %$26] ; # Z
; # (val 3 Bnd)
  %147 = inttoptr i64 %145 to i64*
  %148 = getelementptr i64, i64* %147, i32 2
  %149 = load i64, i64* %148
  br label %$23
$25:
  %150 = phi i64 [%114, %$23], [%136, %$26] ; # X
  %151 = phi i64 [%115, %$23], [%137, %$26] ; # Y
  %152 = phi i64 [%116, %$23], [%138, %$26] ; # N
  %153 = phi i64 [%117, %$23], [%139, %$26] ; # Bnd
  %154 = phi i64 [%118, %$23], [%140, %$26] ; # Z
  %155 = phi i64 [0, %$23], [0, %$26] ; # ->
  br label %$22
$22:
  %156 = phi i64 [%104, %$5], [%150, %$25] ; # X
  %157 = phi i64 [%105, %$5], [%151, %$25] ; # Y
  %158 = phi i64 [%106, %$5], [%152, %$25] ; # N
  %159 = phi i64 [%107, %$5], [%153, %$25] ; # Bnd
  %160 = phi i64 [%105, %$5], [%154, %$25] ; # Z
; # (if (atom (shift X)) (val Z) (set Z (eval (car X))))
; # (shift X)
  %161 = inttoptr i64 %156 to i64*
  %162 = getelementptr i64, i64* %161, i32 1
  %163 = load i64, i64* %162
; # (atom (shift X))
  %164 = and i64 %163, 15
  %165 = icmp ne i64 %164, 0
  br i1 %165, label %$29, label %$30
$29:
  %166 = phi i64 [%163, %$22] ; # X
  %167 = phi i64 [%157, %$22] ; # Y
  %168 = phi i64 [%158, %$22] ; # N
  %169 = phi i64 [%159, %$22] ; # Bnd
  %170 = phi i64 [%160, %$22] ; # Z
; # (val Z)
  %171 = inttoptr i64 %170 to i64*
  %172 = load i64, i64* %171
  br label %$31
$30:
  %173 = phi i64 [%163, %$22] ; # X
  %174 = phi i64 [%157, %$22] ; # Y
  %175 = phi i64 [%158, %$22] ; # N
  %176 = phi i64 [%159, %$22] ; # Bnd
  %177 = phi i64 [%160, %$22] ; # Z
; # (set Z (eval (car X)))
; # (car X)
  %178 = inttoptr i64 %173 to i64*
  %179 = load i64, i64* %178
; # (eval (car X))
  %180 = and i64 %179, 6
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$34, label %$33
$34:
  br label %$32
$33:
  %182 = and i64 %179, 8
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$36, label %$35
$36:
  %184 = inttoptr i64 %179 to i64*
  %185 = load i64, i64* %184
  br label %$32
$35:
  %186 = call i64 @evList(i64 %179)
  br label %$32
$32:
  %187 = phi i64 [%179, %$34], [%185, %$36], [%186, %$35] ; # ->
  %188 = inttoptr i64 %177 to i64*
  store i64 %187, i64* %188
  br label %$31
$31:
  %189 = phi i64 [%166, %$29], [%173, %$32] ; # X
  %190 = phi i64 [%167, %$29], [%174, %$32] ; # Y
  %191 = phi i64 [%168, %$29], [%175, %$32] ; # N
  %192 = phi i64 [%169, %$29], [%176, %$32] ; # Bnd
  %193 = phi i64 [%170, %$29], [%177, %$32] ; # Z
  %194 = phi i64 [%172, %$29], [%187, %$32] ; # ->
  br label %$6
$6:
  %195 = phi i64 [%99, %$9], [%189, %$31] ; # X
  %196 = phi i64 [%100, %$9], [%190, %$31] ; # Y
  %197 = phi i64 [%101, %$9], [%191, %$31] ; # N
  %198 = phi i64 [%102, %$9], [%192, %$31] ; # Bnd
  %199 = phi i64 [%103, %$9], [%194, %$31] ; # ->
  ret i64 %199
}

define i64 @_history(i64) align 8 {
$1:
; # (let X (cdr Exe) (if (atom X) (let P (history_list) (if (and P (v...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom X) (let P (history_list) (if (and P (val P)) (let (Y (c...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
; # (let P (history_list) (if (and P (val P)) (let (Y (cons (mkStr (v...
; # (history_list)
  %6 = call i8*** @history_list()
; # (if (and P (val P)) (let (Y (cons (mkStr (val (val P))) $Nil) R (...
; # (and P (val P))
  %7 = icmp ne i8*** %6, null
  br i1 %7, label %$6, label %$5
$6:
; # (val P)
  %8 = load i8**, i8*** %6
  %9 = icmp ne i8** %8, null
  br label %$5
$5:
  %10 = phi i1 [0, %$2], [%9, %$6] ; # ->
  br i1 %10, label %$7, label %$8
$7:
; # (let (Y (cons (mkStr (val (val P))) $Nil) R (save Y) I 0) (while ...
; # (val P)
  %11 = load i8**, i8*** %6
; # (val (val P))
  %12 = load i8*, i8** %11
; # (mkStr (val (val P)))
  %13 = call i64 @mkStr(i8* %12)
; # (cons (mkStr (val (val P))) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %14, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 %16, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %22
; # (while (val (ofs P (inc 'I))) (setq Y (set 2 Y (cons (mkStr (val ...
  br label %$10
$10:
  %23 = phi i64 [%14, %$7], [%33, %$11] ; # Y
  %24 = phi i64 [0, %$7], [%30, %$11] ; # I
; # (inc 'I)
  %25 = add i64 %24, 1
; # (ofs P (inc 'I))
  %26 = getelementptr i8**, i8*** %6, i64 %25
; # (val (ofs P (inc 'I)))
  %27 = load i8**, i8*** %26
  %28 = icmp ne i8** %27, null
  br i1 %28, label %$11, label %$12
$11:
  %29 = phi i64 [%23, %$10] ; # Y
  %30 = phi i64 [%25, %$10] ; # I
; # (set 2 Y (cons (mkStr (val @)) $Nil))
; # (val @)
  %31 = load i8*, i8** %27
; # (mkStr (val @))
  %32 = call i64 @mkStr(i8* %31)
; # (cons (mkStr (val @)) $Nil)
  %33 = call i64 @cons(i64 %32, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  %34 = inttoptr i64 %29 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  store i64 %33, i64* %35
  br label %$10
$12:
  %36 = phi i64 [%23, %$10] ; # Y
  %37 = phi i64 [%25, %$10] ; # I
; # (drop *Safe)
  %38 = inttoptr i64 %18 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  br label %$9
$8:
  br label %$9
$9:
  %42 = phi i64 [%14, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  br label %$4
$3:
; # (let (Y (needLst Exe (eval (car X))) Z Y) (clear_history) (while ...
; # (car X)
  %43 = inttoptr i64 %3 to i64*
  %44 = load i64, i64* %43
; # (eval (car X))
  %45 = and i64 %44, 6
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$15, label %$14
$15:
  br label %$13
$14:
  %47 = and i64 %44, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$17, label %$16
$17:
  %49 = inttoptr i64 %44 to i64*
  %50 = load i64, i64* %49
  br label %$13
$16:
  %51 = call i64 @evList(i64 %44)
  br label %$13
$13:
  %52 = phi i64 [%44, %$15], [%50, %$17], [%51, %$16] ; # ->
; # (needLst Exe (eval (car X)))
  %53 = and i64 %52, 15
  %54 = icmp eq i64 %53, 0
  br i1 %54, label %$18, label %$19
$19:
  %55 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$18
$18:
  %56 = phi i1 [1, %$13], [%55, %$19] ; # ->
  br i1 %56, label %$21, label %$20
$20:
  call void @lstErr(i64 %0, i64 %52)
  unreachable
$21:
; # (clear_history)
  call void @clear_history()
; # (while (pair Z) (let (Nm (xName Exe (xSym (++ Z))) Stk (stack)) (...
  br label %$22
$22:
  %57 = phi i64 [%52, %$21], [%64, %$23] ; # Z
; # (pair Z)
  %58 = and i64 %57, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$23, label %$24
$23:
  %60 = phi i64 [%57, %$22] ; # Z
; # (let (Nm (xName Exe (xSym (++ Z))) Stk (stack)) (add_history (buf...
; # (++ Z)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  %63 = getelementptr i64, i64* %61, i32 1
  %64 = load i64, i64* %63
; # (xSym (++ Z))
  %65 = call i64 @xSym(i64 %62)
; # (xName Exe (xSym (++ Z)))
  %66 = call i64 @xName(i64 %0, i64 %65)
; # (stack)
  %67 = call i8* @llvm.stacksave()
; # (bufSize Nm)
  %68 = call i64 @bufSize(i64 %66)
; # (b8 (bufSize Nm))
  %69 = alloca i8, i64 %68
; # (bufString Nm (b8 (bufSize Nm)))
  %70 = call i8* @bufString(i64 %66, i8* %69)
; # (add_history (bufString Nm (b8 (bufSize Nm))))
  call void @add_history(i8* %70)
; # (stack Stk)
  call void @llvm.stackrestore(i8* %67)
  br label %$22
$24:
  %71 = phi i64 [%57, %$22] ; # Z
  br label %$4
$4:
  %72 = phi i64 [%42, %$9], [%52, %$24] ; # ->
  ret i64 %72
}

define i64 @_version(i64) align 8 {
$1:
; # (when (nil? (eval (cadr Exe))) (outWord (int (val $Y))) (call $Pu...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
; # (val $Y)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
; # (int (val $Y))
  %17 = lshr i64 %16, 4
; # (outWord (int (val $Y)))
  call void @outWord(i64 %17)
; # (call $Put (char "."))
  %18 = load void(i8)*, void(i8)** @$Put
  call void %18(i8 46)
; # (val $M)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 8) to i64) to i64*
  %20 = load i64, i64* %19
; # (int (val $M))
  %21 = lshr i64 %20, 4
; # (outWord (int (val $M)))
  call void @outWord(i64 %21)
; # (call $Put (char "."))
  %22 = load void(i8)*, void(i8)** @$Put
  call void %22(i8 46)
; # (val $D)
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 16) to i64) to i64*
  %24 = load i64, i64* %23
; # (int (val $D))
  %25 = lshr i64 %24, 4
; # (outWord (int (val $D)))
  call void @outWord(i64 %25)
; # (newline)
  call void @newline()
  br label %$8
$8:
; # (val $Y)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
; # (val $M)
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 8) to i64) to i64*
  %29 = load i64, i64* %28
; # (val $D)
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 16) to i64) to i64*
  %31 = load i64, i64* %30
; # (cons (val $D) $Nil)
  %32 = call i64 @cons(i64 %31, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (val $M) (cons (val $D) $Nil))
  %33 = call i64 @cons(i64 %29, i64 %32)
; # (cons (val $Y) (cons (val $M) (cons (val $D) $Nil)))
  %34 = call i64 @cons(i64 %27, i64 %33)
  ret i64 %34
}

define i32 @main(i32, i8**) align 8 {
$1:
; # (set $AV0 (val Av) $AV (setq Av (ofs Av 1)) $StkLimit (set $StkBr...
; # (val Av)
  %2 = load i8*, i8** %1
  store i8* %2, i8** @$AV0
; # (ofs Av 1)
  %3 = getelementptr i8*, i8** %1, i32 1
  store i8** %3, i8*** @$AV
; # (set $StkBrk (ulimStk))
; # (ulimStk)
  %4 = call i8* @ulimStk()
  store i8* %4, i8** @$StkBrk
  store i8* %4, i8** @$StkLimit
; # (let P (ofs Av (- Ac 2)) (unless (strcmp (val P) ($ "+")) (set $D...
; # (- Ac 2)
  %5 = sub i32 %0, 2
; # (ofs Av (- Ac 2))
  %6 = getelementptr i8*, i8** %3, i32 %5
; # (unless (strcmp (val P) ($ "+")) (set $Dbg $T P null))
; # (val P)
  %7 = load i8*, i8** %6
; # (strcmp (val P) ($ "+"))
  %8 = call i32 @strcmp(i8* %7, i8* bitcast ([2 x i8]* @$93 to i8*))
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %$3, label %$2
$2:
  %10 = phi i8** [%3, %$1] ; # Av
; # (set $Dbg $T P null)
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 824) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 280) to i64), i64* %11
  store i8* null, i8** %6
  br label %$3
$3:
  %12 = phi i8** [%3, %$1], [%10, %$2] ; # Av
; # (let P (val Av) (when (and P (<> (val P) (char "-"))) (let Q (str...
; # (val Av)
  %13 = load i8*, i8** %12
; # (when (and P (<> (val P) (char "-"))) (let Q (strrchr P (char "/"...
; # (and P (<> (val P) (char "-")))
  %14 = icmp ne i8* %13, null
  br i1 %14, label %$5, label %$4
$5:
  %15 = phi i8** [%12, %$3] ; # Av
; # (val P)
  %16 = load i8, i8* %13
; # (<> (val P) (char "-"))
  %17 = icmp ne i8 %16, 45
  br label %$4
$4:
  %18 = phi i8** [%12, %$3], [%15, %$5] ; # Av
  %19 = phi i1 [0, %$3], [%17, %$5] ; # ->
  br i1 %19, label %$6, label %$7
$6:
  %20 = phi i8** [%18, %$4] ; # Av
; # (let Q (strrchr P (char "/")) (unless (or (=0 Q) (and (== Q (+ P ...
; # (strrchr P (char "/"))
  %21 = call i8* @strrchr(i8* %13, i32 47)
; # (unless (or (=0 Q) (and (== Q (+ P 1)) (== (val P) (char ".")))) ...
; # (or (=0 Q) (and (== Q (+ P 1)) (== (val P) (char "."))))
; # (=0 Q)
  %22 = icmp eq i8* %21, null
  br i1 %22, label %$8, label %$9
$9:
  %23 = phi i8** [%20, %$6] ; # Av
; # (and (== Q (+ P 1)) (== (val P) (char ".")))
; # (+ P 1)
  %24 = getelementptr i8, i8* %13, i32 1
; # (== Q (+ P 1))
  %25 = icmp eq i8* %21, %24
  br i1 %25, label %$11, label %$10
$11:
  %26 = phi i8** [%23, %$9] ; # Av
; # (val P)
  %27 = load i8, i8* %13
; # (== (val P) (char "."))
  %28 = icmp eq i8 %27, 46
  br label %$10
$10:
  %29 = phi i8** [%23, %$9], [%26, %$11] ; # Av
  %30 = phi i1 [0, %$9], [%28, %$11] ; # ->
  br label %$8
$8:
  %31 = phi i8** [%20, %$6], [%29, %$10] ; # Av
  %32 = phi i1 [1, %$6], [%30, %$10] ; # ->
  br i1 %32, label %$13, label %$12
$12:
  %33 = phi i8** [%31, %$8] ; # Av
; # (let (N (+ (- Q P) 1) H (malloc (+ N 1))) (set $PilHome H $PilLen...
; # (- Q P)
  %34 = ptrtoint i8* %21 to i64
  %35 = ptrtoint i8* %13 to i64
  %36 = sub i64 %34, %35
; # (+ (- Q P) 1)
  %37 = add i64 %36, 1
; # (+ N 1)
  %38 = add i64 %37, 1
; # (malloc (+ N 1))
  %39 = call i8* @malloc(i64 %38)
; # (set $PilHome H $PilLen N)
  store i8* %39, i8** @$PilHome
  store i64 %37, i64* @$PilLen
; # (memcpy H P N)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %39, i8* %13, i64 %37, i1 0)
; # (set (ofs H N) 0)
; # (ofs H N)
  %40 = getelementptr i8, i8* %39, i64 %37
  store i8 0, i8* %40
  br label %$13
$13:
  %41 = phi i8** [%31, %$8], [%33, %$12] ; # Av
  br label %$7
$7:
  %42 = phi i8** [%18, %$4], [%41, %$13] ; # Av
; # (when (getenv ($ "HOME")) (set $UsrHome @ $UsrLen (strlen @)))
; # (getenv ($ "HOME"))
  %43 = call i8* @getenv(i8* bitcast ([5 x i8]* @$94 to i8*))
  %44 = icmp ne i8* %43, null
  br i1 %44, label %$14, label %$15
$14:
  %45 = phi i8** [%42, %$7] ; # Av
; # (set $UsrHome @ $UsrLen (strlen @))
  store i8* %43, i8** @$UsrHome
; # (strlen @)
  %46 = call i64 @strlen(i8* %43)
  store i64 %46, i64* @$UsrLen
  br label %$15
$15:
  %47 = phi i8** [%42, %$7], [%45, %$14] ; # Av
; # (heapAlloc)
  call void @heapAlloc()
; # (let P $Nil (loop (let Nm (val (tail P)) (when (num? Nm) (intern ...
; # (loop (let Nm (val (tail P)) (when (num? Nm) (intern P 0 @ (cdr $...
  br label %$16
$16:
  %48 = phi i8** [%47, %$15], [%71, %$18] ; # Av
  %49 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%73, %$18] ; # P
; # (let Nm (val (tail P)) (when (num? Nm) (intern P 0 @ (cdr $Pico) ...
; # (tail P)
  %50 = add i64 %49, -8
; # (val (tail P))
  %51 = inttoptr i64 %50 to i64*
  %52 = load i64, i64* %51
; # (when (num? Nm) (intern P 0 @ (cdr $Pico) $Nil NO) (? (== P $Last...
; # (num? Nm)
  %53 = and i64 %52, 6
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$17, label %$18
$17:
  %55 = phi i8** [%48, %$16] ; # Av
  %56 = phi i64 [%49, %$16] ; # P
; # (cdr $Pico)
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 64) to i64) to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
; # (intern P 0 @ (cdr $Pico) $Nil NO)
  %60 = call i64 @intern(i64 %56, i64 0, i64 %52, i64 %59, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64), i1 0)
; # (? (== P $LastSym))
; # (== P $LastSym)
  %61 = icmp eq i64 %56, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 7000) to i64)
  br i1 %61, label %$20, label %$19
$19:
  %62 = phi i8** [%55, %$17] ; # Av
  %63 = phi i64 [%56, %$17] ; # P
; # (when (big? Nm) (setq P (ofs P 2)))
; # (big? Nm)
  %64 = and i64 %52, 4
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$21, label %$22
$21:
  %66 = phi i8** [%62, %$19] ; # Av
  %67 = phi i64 [%63, %$19] ; # P
; # (ofs P 2)
  %68 = add i64 %67, 16
  br label %$22
$22:
  %69 = phi i8** [%62, %$19], [%66, %$21] ; # Av
  %70 = phi i64 [%63, %$19], [%68, %$21] ; # P
  br label %$18
$18:
  %71 = phi i8** [%48, %$16], [%69, %$22] ; # Av
  %72 = phi i64 [%49, %$16], [%70, %$22] ; # P
; # (ofs P 2)
  %73 = add i64 %72, 16
  br label %$16
$20:
  %74 = phi i8** [%55, %$17] ; # Av
  %75 = phi i64 [%56, %$17] ; # P
  %76 = phi i64 [0, %$17] ; # ->
; # (set $OS (mkStr TgOS) $CPU (mkStr TgCPU) $Pid (cnt (i64 (getpid))...
; # (mkStr TgOS)
  %77 = call i64 @mkStr(i8* @TgOS)
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 168) to i64) to i64*
  store i64 %77, i64* %78
; # (mkStr TgCPU)
  %79 = call i64 @mkStr(i8* @TgCPU)
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 184) to i64) to i64*
  store i64 %79, i64* %80
; # (getpid)
  %81 = call i32 @getpid()
; # (i64 (getpid))
  %82 = sext i32 %81 to i64
; # (cnt (i64 (getpid)))
  %83 = shl i64 %82, 4
  %84 = or i64 %83, 2
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 200) to i64) to i64*
  store i64 %84, i64* %85
  %86 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 232) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 408) to i64), i64* %86
; # (tail $Db1)
  %87 = add i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 408) to i64), -8
  %88 = inttoptr i64 %87 to i64*
  store i64 26, i64* %88
; # (cons $Db1 $Nil)
  %89 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 408) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64))
  store i64 %89, i64* @$Extern
; # (b8 (ioFrame T))
  %90 = alloca i8, i64 28
; # (initOutFile 2)
  %91 = call i8* @initOutFile(i32 2)
; # (pushOutFile (b8 (ioFrame T)) (initOutFile 2) 0)
  call void @pushOutFile(i8* %90, i8* %91, i32 0)
; # (set $Stdout (b8 (ioFrame T)))
; # (b8 (ioFrame T))
  %92 = alloca i8, i64 28
  store i8* %92, i8** @$Stdout
; # (initOutFile 1)
  %93 = call i8* @initOutFile(i32 1)
; # (pushOutFile (set $Stdout (b8 (ioFrame T))) (initOutFile 1) 0)
  call void @pushOutFile(i8* %92, i8* %93, i32 0)
; # (set $Stdin (b8 (ioFrame T)))
; # (b8 (ioFrame T))
  %94 = alloca i8, i64 28
  store i8* %94, i8** @$Stdin
; # (initInFile 0 null)
  %95 = call i8* @initInFile(i32 0, i8* null)
; # (pushInFile (set $Stdin (b8 (ioFrame T))) (initInFile 0 null) 0)
  call void @pushInFile(i8* %94, i8* %95, i32 0)
; # (set Tio (=0 (tcgetattr 0 OrgTermio)))
; # (tcgetattr 0 OrgTermio)
  %96 = call i32 @tcgetattr(i32 0, i8* @OrgTermio)
; # (=0 (tcgetattr 0 OrgTermio))
  %97 = icmp eq i32 %96, 0
  store i1 %97, i1* @Tio
; # (sigUnblock 0)
  call void @sigUnblock(i32 0)
; # (val SIGHUP Sig)
  %98 = getelementptr i32, i32* @Sig, i32 0
  %99 = load i32, i32* %98
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %100 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGHUP Sig) (fun sig))
  call void @iSignal(i32 %99, i8* %100)
; # (val SIGUSR1 Sig)
  %101 = getelementptr i32, i32* @Sig, i32 2
  %102 = load i32, i32* %101
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %103 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGUSR1 Sig) (fun sig))
  call void @iSignal(i32 %102, i8* %103)
; # (val SIGUSR2 Sig)
  %104 = getelementptr i32, i32* @Sig, i32 3
  %105 = load i32, i32* %104
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %106 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGUSR2 Sig) (fun sig))
  call void @iSignal(i32 %105, i8* %106)
; # (val SIGALRM Sig)
  %107 = getelementptr i32, i32* @Sig, i32 5
  %108 = load i32, i32* %107
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %109 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGALRM Sig) (fun sig))
  call void @iSignal(i32 %108, i8* %109)
; # (val SIGTERM Sig)
  %110 = getelementptr i32, i32* @Sig, i32 6
  %111 = load i32, i32* %110
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %112 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGTERM Sig) (fun sig))
  call void @iSignal(i32 %111, i8* %112)
; # (val SIGWINCH Sig)
  %113 = getelementptr i32, i32* @Sig, i32 13
  %114 = load i32, i32* %113
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %115 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGWINCH Sig) (fun sig))
  call void @iSignal(i32 %114, i8* %115)
; # (val SIGIO Sig)
  %116 = getelementptr i32, i32* @Sig, i32 14
  %117 = load i32, i32* %116
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %118 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGIO Sig) (fun sig))
  call void @iSignal(i32 %117, i8* %118)
; # (when (== (signal (val SIGTSTP Sig) (val SigIgn)) (val SigDfl)) (...
; # (val SIGTSTP Sig)
  %119 = getelementptr i32, i32* @Sig, i32 10
  %120 = load i32, i32* %119
; # (val SigIgn)
  %121 = load i8*, i8** @SigIgn
; # (signal (val SIGTSTP Sig) (val SigIgn))
  %122 = call i8* @signal(i32 %120, i8* %121)
; # (val SigDfl)
  %123 = load i8*, i8** @SigDfl
; # (== (signal (val SIGTSTP Sig) (val SigIgn)) (val SigDfl))
  %124 = icmp eq i8* %122, %123
  br i1 %124, label %$23, label %$24
$23:
  %125 = phi i8** [%74, %$20] ; # Av
; # (val SIGTSTP Sig)
  %126 = getelementptr i32, i32* @Sig, i32 10
  %127 = load i32, i32* %126
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %128 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGTSTP Sig) (fun sig))
  call void @iSignal(i32 %127, i8* %128)
  br label %$24
$24:
  %129 = phi i8** [%74, %$20], [%125, %$23] ; # Av
; # (val SIGINT Sig)
  %130 = getelementptr i32, i32* @Sig, i32 1
  %131 = load i32, i32* %130
; # (fun sigTerm)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %132 = bitcast void(i32)* @sigTerm to i8*
; # (iSignal (val SIGINT Sig) (fun sigTerm))
  call void @iSignal(i32 %131, i8* %132)
; # (val SIGCHLD Sig)
  %133 = getelementptr i32, i32* @Sig, i32 7
  %134 = load i32, i32* %133
; # (fun sigChld)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %135 = bitcast void(i32)* @sigChld to i8*
; # (signal (val SIGCHLD Sig) (fun sigChld))
  %136 = call i8* @signal(i32 %134, i8* %135)
; # (val SIGPIPE Sig)
  %137 = getelementptr i32, i32* @Sig, i32 4
  %138 = load i32, i32* %137
; # (val SigIgn)
  %139 = load i8*, i8** @SigIgn
; # (signal (val SIGPIPE Sig) (val SigIgn))
  %140 = call i8* @signal(i32 %138, i8* %139)
; # (val SIGTTIN Sig)
  %141 = getelementptr i32, i32* @Sig, i32 11
  %142 = load i32, i32* %141
; # (val SigIgn)
  %143 = load i8*, i8** @SigIgn
; # (signal (val SIGTTIN Sig) (val SigIgn))
  %144 = call i8* @signal(i32 %142, i8* %143)
; # (val SIGTTOU Sig)
  %145 = getelementptr i32, i32* @Sig, i32 12
  %146 = load i32, i32* %145
; # (val SigIgn)
  %147 = load i8*, i8** @SigIgn
; # (signal (val SIGTTOU Sig) (val SigIgn))
  %148 = call i8* @signal(i32 %146, i8* %147)
; # (initReadline)
  call void @initReadline()
; # (set $USec (getUsec YES))
; # (getUsec YES)
  %149 = call i64 @getUsec(i1 1)
  store i64 %149, i64* @$USec
; # (unless (setjmp QuitRst) (loadAll 0))
; # (setjmp QuitRst)
  %150 = call i32 @setjmp(i8* @QuitRst)
  %151 = icmp ne i32 %150, 0
  br i1 %151, label %$26, label %$25
$25:
  %152 = phi i8** [%129, %$24] ; # Av
; # (loadAll 0)
  %153 = call i64 @loadAll(i64 0)
  br label %$26
$26:
  %154 = phi i8** [%129, %$24], [%152, %$25] ; # Av
; # (setCooked)
  call void @setCooked()
; # (unless (val $Repl) (set $Repl YES) (iSignal (val SIGINT Sig) (fu...
; # (val $Repl)
  %155 = load i1, i1* @$Repl
  br i1 %155, label %$28, label %$27
$27:
  %156 = phi i8** [%154, %$26] ; # Av
; # (set $Repl YES)
  store i1 1, i1* @$Repl
; # (val SIGINT Sig)
  %157 = getelementptr i32, i32* @Sig, i32 1
  %158 = load i32, i32* %157
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car cross~Args)) (func (; cross~Ar...
  %159 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGINT Sig) (fun sig))
  call void @iSignal(i32 %158, i8* %159)
  br label %$28
$28:
  %160 = phi i8** [%154, %$26], [%156, %$27] ; # Av
; # (loop (let X (save (stdRead ($ ": "))) (cond ((lt0 (val $Chr)) (b...
  br label %$29
$29:
  %161 = phi i8** [%160, %$28], [%191, %$30] ; # Av
; # (let X (save (stdRead ($ ": "))) (cond ((lt0 (val $Chr)) (bye 0))...
; # (stdRead ($ ": "))
  %162 = call i64 @stdRead(i8* bitcast ([3 x i8]* @$95 to i8*))
; # (save (stdRead ($ ": ")))
  %163 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  %164 = load i64, i64* %163
  %165 = alloca i64, i64 2, align 16
  %166 = ptrtoint i64* %165 to i64
  %167 = inttoptr i64 %166 to i64*
  store i64 %162, i64* %167
  %168 = add i64 %166, 8
  %169 = inttoptr i64 %168 to i64*
  store i64 %164, i64* %169
  %170 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %166, i64* %170
; # (cond ((lt0 (val $Chr)) (bye 0)) ((=0 (val $Chr)) (unless (nil? X...
; # (val $Chr)
  %171 = load i32, i32* @$Chr
; # (lt0 (val $Chr))
  %172 = icmp slt i32 %171, 0
  br i1 %172, label %$32, label %$31
$32:
  %173 = phi i8** [%161, %$29] ; # Av
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$31:
  %174 = phi i8** [%161, %$29] ; # Av
; # (val $Chr)
  %175 = load i32, i32* @$Chr
; # (=0 (val $Chr))
  %176 = icmp eq i32 %175, 0
  br i1 %176, label %$34, label %$33
$34:
  %177 = phi i8** [%174, %$31] ; # Av
; # (unless (nil? X) (stdEval X))
; # (nil? X)
  %178 = icmp eq i64 %162, ptrtoint (i8* getelementptr (i8, i8* bitcast ([876 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %178, label %$36, label %$35
$35:
  %179 = phi i8** [%177, %$34] ; # Av
; # (stdEval X)
  %180 = call i64 @stdEval(i64 %162)
  br label %$36
$36:
  %181 = phi i8** [%177, %$34], [%179, %$35] ; # Av
  br label %$30
$33:
  %182 = phi i8** [%174, %$31] ; # Av
; # (eval X)
  %183 = and i64 %162, 6
  %184 = icmp ne i64 %183, 0
  br i1 %184, label %$39, label %$38
$39:
  br label %$37
$38:
  %185 = and i64 %162, 8
  %186 = icmp ne i64 %185, 0
  br i1 %186, label %$41, label %$40
$41:
  %187 = inttoptr i64 %162 to i64*
  %188 = load i64, i64* %187
  br label %$37
$40:
  %189 = call i64 @evList(i64 %162)
  br label %$37
$37:
  %190 = phi i64 [%162, %$39], [%188, %$41], [%189, %$40] ; # ->
  br label %$30
$30:
  %191 = phi i8** [%181, %$36], [%182, %$37] ; # Av
; # (drop *Safe)
  %192 = inttoptr i64 %166 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
  %195 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([18 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %194, i64* %195
  br label %$29
}

@$95 = private constant [3 x i8] c": \00"
@$94 = private constant [5 x i8] c"HOME\00"
@$93 = private constant [2 x i8] c"+\00"
@$92 = private constant [19 x i8] c"Too many callbacks\00"
@$91 = private constant [9 x i8] c"[DLL] %s\00"
@$90 = private constant [8 x i8] c"Bad ffi\00"
@$89 = private constant [16 x i8] c"Bad result spec\00"
@$88 = private constant [2 x i8] c".\00"
@$87 = private constant [19 x i8] c"Can't open PTY: %s\00"
@$86 = private constant [3 x i8] c"%s\00"
@$85 = private constant [11 x i8] c"Not making\00"
@$84 = private constant [3 x i8] c"+ \00"
@$83 = private constant [9 x i8] c"wait pid\00"
@$82 = private constant [4 x i8] c" = \00"
@$81 = private constant [3 x i8] c" :\00"
@$80 = private constant [9 x i8] c"No Break\00"
@$79 = private constant [3 x i8] c"! \00"
@$78 = private constant [13 x i8] c"Tag expected\00"
@$77 = private constant [20 x i8] c"Coroutine not found\00"
@$76 = private constant [14 x i8] c"No coroutines\00"
@$75 = private constant [24 x i8] c"Can't stop main routine\00"
@$74 = private constant [20 x i8] c"Reentrant coroutine\00"
@$73 = private constant [14 x i8] c"Tag not found\00"
@$72 = private constant [10 x i8] c"Bad extra\00"
@$71 = private constant [10 x i8] c"Bad super\00"
@$70 = private constant [12 x i8] c"Bad message\00"
@$69 = private constant [12 x i8] c" redefined\0A\00"
@$68 = private constant [3 x i8] c"# \00"
@$67 = private constant [10 x i8] c"Bad count\00"
@$66 = private constant [10 x i8] c"Bad chain\00"
@$65 = private constant [19 x i8] c"Circular free list\00"
@$64 = private constant [28 x i8] c"Transaction fsync error: %s\00"
@$63 = private constant [7 x i8] c"Bad ID\00"
@$62 = private constant [2 x i8] c"r\00"
@$61 = private constant [3 x i8] c"a+\00"
@$60 = private constant [2 x i8] c"a\00"
@$59 = private constant [23 x i8] c"Log truncate error: %s\00"
@$58 = private constant [42 x i8] c"Last transaction not completed: Rollback\0A\00"
@$57 = private constant [35 x i8] c"Discarding incomplete transaction\0A\00"
@$56 = private constant [12 x i8] c"DB Oversize\00"
@$55 = private constant [14 x i8] c"Log write: %s\00"
@$54 = private constant [18 x i8] c"Journal write: %s\00"
@$53 = private constant [19 x i8] c"DB fsync error: %s\00"
@$52 = private constant [12 x i8] c"Bad Journal\00"
@$51 = private constant [13 x i8] c"DB write: %s\00"
@$50 = private constant [12 x i8] c"DB read: %s\00"
@$49 = private constant [12 x i8] c"Bad DB file\00"
@$48 = private constant [3 x i8] c"> \00"
@$47 = private constant [4 x i8] c"-> \00"
@$46 = private constant [4 x i8] c"   \00"
@$45 = private constant [4 x i8] c" . \00"
@$44 = private constant [6 x i8] c"priv~\00"
@$43 = private constant [27 x i8] c"Super parentheses mismatch\00"
@$42 = private constant [16 x i8] c"Bad dotted pair\00"
@$41 = private constant [15 x i8] c"sync write: %s\00"
@$40 = private constant [14 x i8] c"No current fd\00"
@$39 = private constant [14 x i8] c"Tell PIPE_BUF\00"
@$38 = private constant [16 x i8] c"child write: %s\00"
@$37 = private constant [16 x i8] c"bytes write: %s\00"
@$36 = private constant [9 x i8] c"SETFD %s\00"
@$35 = private constant [17 x i8] c"Select error: %s\00"
@$34 = private constant [7 x i8] c"Bad FD\00"
@$33 = private constant [15 x i8] c"Bad input '%s'\00"
@$32 = private constant [12 x i8] c"EOF Overrun\00"
@$31 = private constant [14 x i8] c"Size overflow\00"
@$30 = private constant [15 x i8] c"Pipe error: %s\00"
@$29 = private constant [16 x i8] c"Close error: %s\00"
@$28 = private constant [15 x i8] c"Open error: %s\00"
@$27 = private constant [10 x i8] c"Undefined\00"
@$26 = private constant [6 x i8] c"Div/0\00"
@$25 = private constant [4 x i8] c".so\00"
@$24 = private constant [5 x i8] c"lib/\00"
@$23 = private constant [21 x i8] c"Bad symbol namespace\00"
@$22 = private constant [11 x i8] c"Can't fork\00"
@$21 = private constant [14 x i8] c"File lock: %s\00"
@$20 = private constant [10 x i8] c"Protected\00"
@$19 = private constant [15 x i8] c"Item not found\00"
@$18 = private constant [18 x i8] c"Variable expected\00"
@$17 = private constant [14 x i8] c"List expected\00"
@$16 = private constant [19 x i8] c"Cons pair expected\00"
@$15 = private constant [14 x i8] c"Atom expected\00"
@$14 = private constant [14 x i8] c"Name expected\00"
@$13 = private constant [25 x i8] c"External symbol expected\00"
@$12 = private constant [14 x i8] c"Char expected\00"
@$11 = private constant [16 x i8] c"Symbol expected\00"
@$10 = private constant [16 x i8] c"Number expected\00"
@$9 = private constant [22 x i8] c"Small number expected\00"
@$8 = private constant [13 x i8] c"Bad argument\00"
@$7 = private constant [15 x i8] c"Stack overflow\00"
@$6 = private constant [3 x i8] c"? \00"
@$5 = private constant [5 x i8] c" -- \00"
@$4 = private constant [4 x i8] c"!? \00"
@$3 = private constant [10 x i8] c"No memory\00"
@$2 = private constant [16 x i8] c"%s: Can't exec\0A\00"
@$1 = private constant [2 x i8] c"\0A\00"
