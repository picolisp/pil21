source_filename = "base.l"

declare {i64, i1} @llvm.uadd.with.overflow.i64(i64, i64)
declare {i64, i1} @llvm.usub.with.overflow.i64(i64, i64)
declare i64 @llvm.fshl.i64(i64, i64, i64)
declare i64 @llvm.fshr.i64(i64, i64, i64)
declare void @llvm.memcpy.p0i8.p0i8.i64(i8*, i8*, i64, i1)
declare void @llvm.memset.p0i8.p0i8.i64(i8*, i8, i64, i1)
declare i8* @llvm.stacksave()
declare void @llvm.stackrestore(i8*)

@$AV0 = global i8* null
@$AV = global i8** null
@$Home = global i8* null
@$HomeLen = global i64 0
@$Heaps = global i64 0
@$Avail = global i64 0
@$Extern = global i64 0
@$ExtCnt = global i64 1
@$ExtSkip = global i64 0
@$Coroutines = global i8* null
@$StkSize = global i64 65536
@$StkLimit = global i8* null
@$LinePtr = global i8* null
@$LineBuf = global i8* null
@$LinePrmt = global i8* null
@$ReplPrmt = global i8* null
@$Ret = global i64 0
@$TtyPid = global i32 0
@$InFiles = global i8** null
@$OutFiles = global i8** null
@$InFDs = global i32 0
@$OutFDs = global i32 0
@$PutBin = global void(i8)* null
@$GetBin = global i32()* null
@$SeedL = global i64 0
@$SeedH = global i64 0
@$USec = global i64 0
@$TickU = global i64 0
@$TickS = global i64 0
@$Children = global i64 0
@$Child = global i8* null
@$Slot = global i64 0
@$Spkr = global i32 0
@$Mic = global i32 0
@$SpMiPipe = global [2 x i32] [
  i32 0,
  i32 0
]
@$Talking = global i32 0
@$Hear = global i32 0
@$Tell = global i32 0
@$TellBuf = global i8* null
@$Ptr = global i8* null
@$End = global i8* null
@$BufX = global i8* null
@$PtrX = global i8* null
@$EndX = global i8* null
@$ExtN = global i32 0
@$Extn = global i32 0
@$StrP = global i64* null
@$GcCount = global i64 65536
@$DbFiles = global i8* null
@$DbFile = global i8* null
@$DBs = global i32 0
@$MaxBlkSize = global i32 0
@$DbBlock = global i8* null
@$BlkIndex = global i64 0
@$BlkLink = global i64 0
@$BlkPtr = global i8* null
@$BlkEnd = global i8* null
@$DbJnl = global i8* null
@$DbLog = global i8* null
@$Signal = global [15 x i32] [
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0,
  i32 0
]
@SymTab = global [840 x i64] [
  ; # [0] NIL
  i64 79992034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 0,
  i64 0,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [48] ~
  i64 2018,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 56) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 56) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 64) to i64),
  ; # [96] pico
  i64 29900576514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 80) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 104) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [128] *DB
  i64 69485218,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 40) to i64),
  ; # [144] meth
  i64 28039337682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_meth to i8*), i32 2) to i64),
  ; # [160] quote
  i64 6971922536210,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_quote to i8*), i32 2) to i64),
  ; # [176] T
  i64 1346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64),
  ; # [192] N
  i64 1250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [208] C
  i64 1074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [224] S
  i64 1330,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [240] B
  i64 1058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [256] I
  i64 1170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [272] P
  i64 1282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [288] W
  i64 1394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [304] *OS
  i64 87356066,
  i64 0,
  ; # [320] *CPU
  i64 22901174946,
  i64 0,
  ; # [336] *Pid
  i64 26953974434,
  i64 0,
  ; # [352] *PPid
  i64 6900217610914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [368] *Solo
  i64 7656969679522,
  i64 2,
  ; # [384] @
  i64 1026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [400] @@
  i64 263170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [416] @@@
  i64 67372034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [432] This
  i64 30980605250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [448] *Prompt
  i64 524395401951117986,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [464] *Tab
  i64 26408731298,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [480] *Zap
  i64 30166852258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [496] *Ext
  i64 31264625314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [512] *Scl
  i64 29095178914,
  i64 2,
  ; # [528] *Class
  i64 2031030286693026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [544] *Run
  i64 29650920098,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [560] *Hup
  i64 30187750050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [576] *Sig1
  i64 3395013653154,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [592] *Sig2
  i64 3463733129890,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [608] *TStp1
  i64 869744923460258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [624] *TStp2
  i64 887337109504674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [640] ^
  i64 1506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [656] *Err
  i64 30721462946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [672] *Msg
  i64 27769754274,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [688] *Uni
  i64 28301415074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [704] *Fork
  i64 7383702332066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [720] *Bye
  i64 27239129762,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [736] *Dbg
  i64 27751891618,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  ; # [752] gc
  i64 407154,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_gc to i8*), i32 2) to i64),
  ; # [768] format
  i64 2047388749854306,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_format to i8*), i32 2) to i64),
  ; # [784] +
  i64 690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_add to i8*), i32 2) to i64),
  ; # [800] -
  i64 722,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sub to i8*), i32 2) to i64),
  ; # [816] inc
  i64 104261266,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_inc to i8*), i32 2) to i64),
  ; # [832] dec
  i64 104224322,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dec to i8*), i32 2) to i64),
  ; # [848] *
  i64 674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mul to i8*), i32 2) to i64),
  ; # [864] */
  i64 193186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mulDiv to i8*), i32 2) to i64),
  ; # [880] /
  i64 754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_div to i8*), i32 2) to i64),
  ; # [896] %
  i64 594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rem to i8*), i32 2) to i64),
  ; # [912] >>
  i64 254946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_shr to i8*), i32 2) to i64),
  ; # [928] lt0
  i64 50808514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lt0 to i8*), i32 2) to i64),
  ; # [944] le0
  i64 50747074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_le0 to i8*), i32 2) to i64),
  ; # [960] ge0
  i64 50746994,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ge0 to i8*), i32 2) to i64),
  ; # [976] gt0
  i64 50808434,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_gt0 to i8*), i32 2) to i64),
  ; # [992] abs
  i64 120989202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_abs to i8*), i32 2) to i64),
  ; # [1008] bit?
  i64 17033500194,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitQ to i8*), i32 2) to i64),
  ; # [1024] &
  i64 610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitAnd to i8*), i32 2) to i64),
  ; # [1040] |
  i64 1986,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitOr to i8*), i32 2) to i64),
  ; # [1056] x|
  i64 509826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bitXor to i8*), i32 2) to i64),
  ; # [1072] sqrt
  i64 31258515250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sqrt to i8*), i32 2) to i64),
  ; # [1088] seed
  i64 26949867314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_seed to i8*), i32 2) to i64),
  ; # [1104] hash
  i64 28038272642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_hash to i8*), i32 2) to i64),
  ; # [1120] rand
  i64 26959288098,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rand to i8*), i32 2) to i64),
  ; # [1136] name
  i64 27226674914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_name to i8*), i32 2) to i64),
  ; # [1152] nsp
  i64 117913314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nsp to i8*), i32 2) to i64),
  ; # [1168] sp?
  i64 66520882,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_spQ to i8*), i32 2) to i64),
  ; # [1184] pat?
  i64 17033467650,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_patQ to i8*), i32 2) to i64),
  ; # [1200] fun?
  i64 17027257954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_funQ to i8*), i32 2) to i64),
  ; # [1216] getd
  i64 26965595762,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_getd to i8*), i32 2) to i64),
  ; # [1232] all
  i64 113690130,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_all to i8*), i32 2) to i64),
  ; # [1248] symbols
  i64 519821567523788594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_symbols to i8*), i32 2) to i64),
  ; # [1264] intern
  i64 1943001719301778,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_intern to i8*), i32 2) to i64),
  ; # [1280] box?
  i64 17037719074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_boxQ to i8*), i32 2) to i64),
  ; # [1296] str?
  i64 17031448370,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_strQ to i8*), i32 2) to i64),
  ; # [1312] zap
  i64 117839778,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_zap to i8*), i32 2) to i64),
  ; # [1328] chop
  i64 30181590578,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_chop to i8*), i32 2) to i64),
  ; # [1344] pack
  i64 28826801922,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pack to i8*), i32 2) to i64),
  ; # [1360] glue
  i64 27235108466,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_glue to i8*), i32 2) to i64),
  ; # [1376] text
  i64 31264757570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_text to i8*), i32 2) to i64),
  ; # [1392] pre?
  i64 17017808642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_preQ to i8*), i32 2) to i64),
  ; # [1408] sub?
  i64 17014675250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_subQ to i8*), i32 2) to i64),
  ; # [1424] val
  i64 113645410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_val to i8*), i32 2) to i64),
  ; # [1440] set
  i64 122050354,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_set to i8*), i32 2) to i64),
  ; # [1456] setq
  i64 30455256882,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_setq to i8*), i32 2) to i64),
  ; # [1472] swap
  i64 30166972210,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_swap to i8*), i32 2) to i64),
  ; # [1488] xchg
  i64 27758311298,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_xchg to i8*), i32 2) to i64),
  ; # [1504] on
  i64 452338,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_on to i8*), i32 2) to i64),
  ; # [1520] off
  i64 107374322,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_off to i8*), i32 2) to i64),
  ; # [1536] onOff
  i64 7036850333426,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_onOff to i8*), i32 2) to i64),
  ; # [1552] zero
  i64 29916288930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_zero to i8*), i32 2) to i64),
  ; # [1568] one
  i64 106358514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_one to i8*), i32 2) to i64),
  ; # [1584] default
  i64 524325579192161858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_default to i8*), i32 2) to i64),
  ; # [1600] push
  i64 28038354690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_push to i8*), i32 2) to i64),
  ; # [1616] push1
  i64 3395292714754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_push1 to i8*), i32 2) to i64),
  ; # [1632] push1q
  i64 1991312315733762,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_push1q to i8*), i32 2) to i64),
  ; # [1648] pop
  i64 117896962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pop to i8*), i32 2) to i64),
  ; # [1664] ++
  i64 176818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_popq to i8*), i32 2) to i64),
  ; # [1680] cut
  i64 122115634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cut to i8*), i32 2) to i64),
  ; # [1696] del
  i64 113661506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_del to i8*), i32 2) to i64),
  ; # [1712] queue
  i64 6972180485906,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_queue to i8*), i32 2) to i64),
  ; # [1728] fifo
  i64 29903722082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fifo to i8*), i32 2) to i64),
  ; # [1744] idx
  i64 126240402,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_idx to i8*), i32 2) to i64),
  ; # [1760] lup
  i64 117921474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lup to i8*), i32 2) to i64),
  ; # [1776] put
  i64 122115842,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_put to i8*), i32 2) to i64),
  ; # [1792] get
  i64 122050162,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_get to i8*), i32 2) to i64),
  ; # [1808] prop
  i64 30181631746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prop to i8*), i32 2) to i64),
  ; # [1824] ;
  i64 946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_semicol to i8*), i32 2) to i64),
  ; # [1840] =:
  i64 238546,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_setCol to i8*), i32 2) to i64),
  ; # [1856] :
  i64 930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_col to i8*), i32 2) to i64),
  ; # [1872] ::
  i64 238498,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_propCol to i8*), i32 2) to i64),
  ; # [1888] putl
  i64 29113145090,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_putl to i8*), i32 2) to i64),
  ; # [1904] getl
  i64 29113079410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_getl to i8*), i32 2) to i64),
  ; # [1920] wipe
  i64 27229853554,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_wipe to i8*), i32 2) to i64),
  ; # [1936] meta
  i64 26160289490,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_meta to i8*), i32 2) to i64),
  ; # [1952] low?
  i64 17036670658,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lowQ to i8*), i32 2) to i64),
  ; # [1968] upp?
  i64 17029334866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_uppQ to i8*), i32 2) to i64),
  ; # [1984] lowc
  i64 26700347074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lowc to i8*), i32 2) to i64),
  ; # [2000] uppc
  i64 26693011282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_uppc to i8*), i32 2) to i64),
  ; # [2016] fold
  i64 26957248098,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fold to i8*), i32 2) to i64),
  ; # [2032] path
  i64 28039321346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_path to i8*), i32 2) to i64),
  ; # [2048] wait
  i64 31249012594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_wait to i8*), i32 2) to i64),
  ; # [2064] sync
  i64 26690950962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sync to i8*), i32 2) to i64),
  ; # [2080] hear
  i64 30703769218,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_hear to i8*), i32 2) to i64),
  ; # [2096] tell
  i64 29104691010,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_tell to i8*), i32 2) to i64),
  ; # [2112] poll
  i64 29104731906,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_poll to i8*), i32 2) to i64),
  ; # [2128] read
  i64 26945672994,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_read to i8*), i32 2) to i64),
  ; # [2144] key
  i64 127293106,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_key to i8*), i32 2) to i64),
  ; # [2160] peek
  i64 28828915458,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_peek to i8*), i32 2) to i64),
  ; # [2176] char
  i64 30703781426,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_char to i8*), i32 2) to i64),
  ; # [2192] skip
  i64 30175311666,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_skip to i8*), i32 2) to i64),
  ; # [2208] eol
  i64 113702482,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eol to i8*), i32 2) to i64),
  ; # [2224] eof
  i64 107411026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eof to i8*), i32 2) to i64),
  ; # [2240] from
  i64 29376325218,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_from to i8*), i32 2) to i64),
  ; # [2256] till
  i64 29104707394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_till to i8*), i32 2) to i64),
  ; # [2272] line
  i64 27227756226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_line to i8*), i32 2) to i64),
  ; # [2288] in
  i64 452242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_in to i8*), i32 2) to i64),
  ; # [2304] out
  i64 122115826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_out to i8*), i32 2) to i64),
  ; # [2320] err
  i64 120006226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_err to i8*), i32 2) to i64),
  ; # [2336] ctl
  i64 113722930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ctl to i8*), i32 2) to i64),
  ; # [2352] fd
  i64 411234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fd to i8*), i32 2) to i64),
  ; # [2368] pipe
  i64 27229853442,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pipe to i8*), i32 2) to i64),
  ; # [2384] open
  i64 29634266866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_open to i8*), i32 2) to i64),
  ; # [2400] close
  i64 6971654063666,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_close to i8*), i32 2) to i64),
  ; # [2416] echo
  i64 29905794642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_echo to i8*), i32 2) to i64),
  ; # [2432] prin
  i64 29638469378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prin to i8*), i32 2) to i64),
  ; # [2448] prinl
  i64 7451341956866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prinl to i8*), i32 2) to i64),
  ; # [2464] space
  i64 6967344432946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_space to i8*), i32 2) to i64),
  ; # [2480] print
  i64 8001097770754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_print to i8*), i32 2) to i64),
  ; # [2496] printsp
  i64 506434260758374146,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_printsp to i8*), i32 2) to i64),
  ; # [2512] println
  i64 497303916201322242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_println to i8*), i32 2) to i64),
  ; # [2528] flush
  i64 7177818785378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_flush to i8*), i32 2) to i64),
  ; # [2544] rewind
  i64 1766806057801506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rewind to i8*), i32 2) to i64),
  ; # [2560] ext
  i64 122127954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ext to i8*), i32 2) to i64),
  ; # [2576] plio
  i64 29906880258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_plio to i8*), i32 2) to i64),
  ; # [2592] rd
  i64 411426,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rd to i8*), i32 2) to i64),
  ; # [2608] pr
  i64 468738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pr to i8*), i32 2) to i64),
  ; # [2624] wr
  i64 468850,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_wr to i8*), i32 2) to i64),
  ; # [2640] any
  i64 127329810,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_any to i8*), i32 2) to i64),
  ; # [2656] sym
  i64 114792242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sym to i8*), i32 2) to i64),
  ; # [2672] str
  i64 120014642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_str to i8*), i32 2) to i64),
  ; # [2688] load
  i64 26945713858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_load to i8*), i32 2) to i64),
  ; # [2704] ext?
  i64 17033561682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extQ to i8*), i32 2) to i64),
  ; # [2720] rollback
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 2740) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rollback to i8*), i32 2) to i64),
  i64 7738135660106379122,
  i64 2,
  ; # [2752] extern
  i64 1943001719342674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extern to i8*), i32 2) to i64),
  ; # [2768] pool
  i64 29107877634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pool to i8*), i32 2) to i64),
  ; # [2784] pool2
  i64 3465081714434,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pool2 to i8*), i32 2) to i64),
  ; # [2800] journal
  i64 488102791669544610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_journal to i8*), i32 2) to i64),
  ; # [2816] id
  i64 411282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_id to i8*), i32 2) to i64),
  ; # [2832] blk
  i64 112641570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_blk to i8*), i32 2) to i64),
  ; # [2848] seq
  i64 118904626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_seq to i8*), i32 2) to i64),
  ; # [2864] lieu
  i64 31513286338,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lieu to i8*), i32 2) to i64),
  ; # [2880] lock
  i64 28826859202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lock to i8*), i32 2) to i64),
  ; # [2896] touch
  i64 7173523830594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_touch to i8*), i32 2) to i64),
  ; # [2912] commit
  i64 2047938500425266,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_commit to i8*), i32 2) to i64),
  ; # [2928] mark
  i64 28842530514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mark to i8*), i32 2) to i64),
  ; # [2944] free
  i64 27218355810,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_free to i8*), i32 2) to i64),
  ; # [2960] dbck
  i64 28826805826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dbck to i8*), i32 2) to i64),
  ; # [2976] apply
  i64 8344165615122,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_apply to i8*), i32 2) to i64),
  ; # [2992] pass
  i64 30991062786,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pass to i8*), i32 2) to i64),
  ; # [3008] maps
  i64 30987917010,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_maps to i8*), i32 2) to i64),
  ; # [3024] map
  i64 117839570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_map to i8*), i32 2) to i64),
  ; # [3040] mapc
  i64 26692949714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapc to i8*), i32 2) to i64),
  ; # [3056] maplist
  i64 524447902824011474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_maplist to i8*), i32 2) to i64),
  ; # [3072] mapcar
  i64 2012201691256530,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapcar to i8*), i32 2) to i64),
  ; # [3088] mapcon
  i64 1942795019753170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapcon to i8*), i32 2) to i64),
  ; # [3104] mapcan
  i64 1941832947078866,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mapcan to i8*), i32 2) to i64),
  ; # [3120] filter
  i64 2012481128404578,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_filter to i8*), i32 2) to i64),
  ; # [3136] extract
  i64 524165879706388050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extract to i8*), i32 2) to i64),
  ; # [3152] seek
  i64 28828915506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_seek to i8*), i32 2) to i64),
  ; # [3168] find
  i64 26959320674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_find to i8*), i32 2) to i64),
  ; # [3184] pick
  i64 28826834690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pick to i8*), i32 2) to i64),
  ; # [3200] fully
  i64 8344161441378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fully to i8*), i32 2) to i64),
  ; # [3216] cnt
  i64 122086962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cnt to i8*), i32 2) to i64),
  ; # [3232] sum
  i64 114775858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sum to i8*), i32 2) to i64),
  ; # [3248] maxi
  i64 28311951058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_maxi to i8*), i32 2) to i64),
  ; # [3264] mini
  i64 28301498066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mini to i8*), i32 2) to i64),
  ; # [3280] fish
  i64 28038305378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fish to i8*), i32 2) to i64),
  ; # [3296] by
  i64 497186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_by to i8*), i32 2) to i64),
  ; # [3312] as
  i64 472594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_as to i8*), i32 2) to i64),
  ; # [3328] lit
  i64 122066626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lit to i8*), i32 2) to i64),
  ; # [3344] eval
  i64 29093226066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eval to i8*), i32 2) to i64),
  ; # [3360] run
  i64 115824418,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_run to i8*), i32 2) to i64),
  ; # [3376] def
  i64 107370050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_def to i8*), i32 2) to i64),
  ; # [3392] de
  i64 415298,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_de to i8*), i32 2) to i64),
  ; # [3408] dm
  i64 448066,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dm to i8*), i32 2) to i64),
  ; # [3424] box
  i64 126285346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_box to i8*), i32 2) to i64),
  ; # [3440] new
  i64 125196002,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_new to i8*), i32 2) to i64),
  ; # [3456] type
  i64 27229919042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_type to i8*), i32 2) to i64),
  ; # [3472] isa
  i64 102184594,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_isa to i8*), i32 2) to i64),
  ; # [3488] method
  i64 1766874505696978,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_method to i8*), i32 2) to i64),
  ; # [3504] send
  i64 26959304498,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_send to i8*), i32 2) to i64),
  ; # [3520] try
  i64 127346498,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_try to i8*), i32 2) to i64),
  ; # [3536] super
  i64 7861250250546,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_super to i8*), i32 2) to i64),
  ; # [3552] extra
  i64 6696513013330,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_extra to i8*), i32 2) to i64),
  ; # [3568] and
  i64 105309714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_and to i8*), i32 2) to i64),
  ; # [3584] or
  i64 468722,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_or to i8*), i32 2) to i64),
  ; # [3600] nand
  i64 26959288034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nand to i8*), i32 2) to i64),
  ; # [3616] nor
  i64 119994082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nor to i8*), i32 2) to i64),
  ; # [3632] xor
  i64 119994242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_xor to i8*), i32 2) to i64),
  ; # [3648] bool
  i64 29107877410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bool to i8*), i32 2) to i64),
  ; # [3664] not
  i64 122091234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_not to i8*), i32 2) to i64),
  ; # [3680] nil
  i64 113678050,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nil to i8*), i32 2) to i64),
  ; # [3696] t
  i64 1858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_t to i8*), i32 2) to i64),
  ; # [3712] prog
  i64 27765712642,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prog to i8*), i32 2) to i64),
  ; # [3728] prog1
  i64 3395020072706,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prog1 to i8*), i32 2) to i64),
  ; # [3744] prog2
  i64 3463739549442,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prog2 to i8*), i32 2) to i64),
  ; # [3760] if
  i64 419474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_if to i8*), i32 2) to i64),
  ; # [3776] ifn
  i64 115762834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ifn to i8*), i32 2) to i64),
  ; # [3792] if2
  i64 52848274,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_if2 to i8*), i32 2) to i64),
  ; # [3808] when
  i64 29634234226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_when to i8*), i32 2) to i64),
  ; # [3824] unless
  i64 2031031360612178,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_unless to i8*), i32 2) to i64),
  ; # [3840] cond
  i64 26959345202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cond to i8*), i32 2) to i64),
  ; # [3856] nond
  i64 26959345378,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nond to i8*), i32 2) to i64),
  ; # [3872] case
  i64 27232966194,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_case to i8*), i32 2) to i64),
  ; # [3888] casq
  i64 30454191666,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_casq to i8*), i32 2) to i64),
  ; # [3904] state
  i64 6971907852082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_state to i8*), i32 2) to i64),
  ; # [3920] while
  i64 6969768707954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_while to i8*), i32 2) to i64),
  ; # [3936] until
  i64 7450011297618,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_until to i8*), i32 2) to i64),
  ; # [3952] at
  i64 476690,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_at to i8*), i32 2) to i64),
  ; # [3968] do
  i64 456258,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_do to i8*), i32 2) to i64),
  ; # [3984] loop
  i64 30181619394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_loop to i8*), i32 2) to i64),
  ; # [4000] for
  i64 119993954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_for to i8*), i32 2) to i64),
  ; # [4016] with
  i64 28039354226,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_with to i8*), i32 2) to i64),
  ; # [4032] bind
  i64 26959320610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bind to i8*), i32 2) to i64),
  ; # [4048] job
  i64 103216802,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_job to i8*), i32 2) to i64),
  ; # [4064] let
  i64 122050242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_let to i8*), i32 2) to i64),
  ; # [4080] let?
  i64 17033483970,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_letQ to i8*), i32 2) to i64),
  ; # [4096] use
  i64 106379090,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_use to i8*), i32 2) to i64),
  ; # [4112] buf
  i64 107435554,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_buf to i8*), i32 2) to i64),
  ; # [4128] catch
  i64 7173522724402,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_catch to i8*), i32 2) to i64),
  ; # [4144] throw
  i64 8207534032706,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_throw to i8*), i32 2) to i64),
  ; # [4160] finally
  i64 546842958862128738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_finally to i8*), i32 2) to i64),
  ; # [4176] co
  i64 456242,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_co to i8*), i32 2) to i64),
  ; # [4192] yield
  i64 6901045041042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_yield to i8*), i32 2) to i64),
  ; # [4208] !
  i64 530,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_break to i8*), i32 2) to i64),
  ; # [4224] e
  i64 1618,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_e to i8*), i32 2) to i64),
  ; # [4240] $
  i64 578,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_trace to i8*), i32 2) to i64),
  ; # [4256] exec
  i64 26681509458,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_exec to i8*), i32 2) to i64),
  ; # [4272] call
  i64 29104674354,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_call to i8*), i32 2) to i64),
  ; # [4288] ipid
  i64 26954106514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ipid to i8*), i32 2) to i64),
  ; # [4304] opid
  i64 26954106610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_opid to i8*), i32 2) to i64),
  ; # [4320] kill
  i64 29104707250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_kill to i8*), i32 2) to i64),
  ; # [4336] fork
  i64 28842587746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fork to i8*), i32 2) to i64),
  ; # [4352] detach
  i64 1836416737105474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_detach to i8*), i32 2) to i64),
  ; # [4368] bye
  i64 106403362,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bye to i8*), i32 2) to i64),
  ; # [4384] car
  i64 119936562,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_car to i8*), i32 2) to i64),
  ; # [4400] cdr
  i64 119948850,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdr to i8*), i32 2) to i64),
  ; # [4416] caar
  i64 30703752754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caar to i8*), i32 2) to i64),
  ; # [4432] cadr
  i64 30706898482,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadr to i8*), i32 2) to i64),
  ; # [4448] cdar
  i64 30703765042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdar to i8*), i32 2) to i64),
  ; # [4464] cddr
  i64 30706910770,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddr to i8*), i32 2) to i64),
  ; # [4480] caaar
  i64 7860160697906,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaar to i8*), i32 2) to i64),
  ; # [4496] caadr
  i64 7860966004274,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caadr to i8*), i32 2) to i64),
  ; # [4512] cadar
  i64 7860163843634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadar to i8*), i32 2) to i64),
  ; # [4528] caddr
  i64 7860969150002,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caddr to i8*), i32 2) to i64),
  ; # [4544] cdaar
  i64 7860160710194,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaar to i8*), i32 2) to i64),
  ; # [4560] cdadr
  i64 7860966016562,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdadr to i8*), i32 2) to i64),
  ; # [4576] cddar
  i64 7860163855922,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddar to i8*), i32 2) to i64),
  ; # [4592] cdddr
  i64 7860969162290,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdddr to i8*), i32 2) to i64),
  ; # [4608] caaaar
  i64 2012201138656818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaaar to i8*), i32 2) to i64),
  ; # [4624] caaadr
  i64 2012407297087026,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaadr to i8*), i32 2) to i64),
  ; # [4640] caadar
  i64 2012201943963186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caadar to i8*), i32 2) to i64),
  ; # [4656] caaddr
  i64 2012408102393394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caaddr to i8*), i32 2) to i64),
  ; # [4672] cadaar
  i64 2012201141802546,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadaar to i8*), i32 2) to i64),
  ; # [4688] cadadr
  i64 2012407300232754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadadr to i8*), i32 2) to i64),
  ; # [4704] caddar
  i64 2012201947108914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_caddar to i8*), i32 2) to i64),
  ; # [4720] cadddr
  i64 2012408105539122,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cadddr to i8*), i32 2) to i64),
  ; # [4736] cdaaar
  i64 2012201138669106,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaaar to i8*), i32 2) to i64),
  ; # [4752] cdaadr
  i64 2012407297099314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaadr to i8*), i32 2) to i64),
  ; # [4768] cdadar
  i64 2012201943975474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdadar to i8*), i32 2) to i64),
  ; # [4784] cdaddr
  i64 2012408102405682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdaddr to i8*), i32 2) to i64),
  ; # [4800] cddaar
  i64 2012201141814834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddaar to i8*), i32 2) to i64),
  ; # [4816] cddadr
  i64 2012407300245042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddadr to i8*), i32 2) to i64),
  ; # [4832] cdddar
  i64 2012201947121202,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cdddar to i8*), i32 2) to i64),
  ; # [4848] cddddr
  i64 2012408105551410,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cddddr to i8*), i32 2) to i64),
  ; # [4864] nth
  i64 109528802,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nth to i8*), i32 2) to i64),
  ; # [4880] con
  i64 115799602,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_con to i8*), i32 2) to i64),
  ; # [4896] cons
  i64 30985877042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cons to i8*), i32 2) to i64),
  ; # [4912] conc
  i64 26690909746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_conc to i8*), i32 2) to i64),
  ; # [4928] circ
  i64 26695079474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_circ to i8*), i32 2) to i64),
  ; # [4944] rot
  i64 122091298,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rot to i8*), i32 2) to i64),
  ; # [4960] list
  i64 31259530946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_list to i8*), i32 2) to i64),
  ; # [4976] need
  i64 26949867234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_need to i8*), i32 2) to i64),
  ; # [4992] range
  i64 6968431744802,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_range to i8*), i32 2) to i64),
  ; # [5008] full
  i64 29104756322,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_full to i8*), i32 2) to i64),
  ; # [5024] make
  i64 27224577746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_make to i8*), i32 2) to i64),
  ; # [5040] made
  i64 27217237714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_made to i8*), i32 2) to i64),
  ; # [5056] chain
  i64 7587430303282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_chain to i8*), i32 2) to i64),
  ; # [5072] link
  i64 28838368962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_link to i8*), i32 2) to i64),
  ; # [5088] yoke
  i64 27224635282,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_yoke to i8*), i32 2) to i64),
  ; # [5104] copy
  i64 32598586930,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_copy to i8*), i32 2) to i64),
  ; # [5120] mix
  i64 126260946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mix to i8*), i32 2) to i64),
  ; # [5136] append
  i64 1766804976764434,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_append to i8*), i32 2) to i64),
  ; # [5152] delete
  i64 1784809475429954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_delete to i8*), i32 2) to i64),
  ; # [5168] delq
  i64 30446868034,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_delq to i8*), i32 2) to i64),
  ; # [5184] replace
  i64 456611883680945954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_replace to i8*), i32 2) to i64),
  ; # [5200] insert
  i64 2048554834519698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_insert to i8*), i32 2) to i64),
  ; # [5216] remove
  i64 1784949599786786,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_remove to i8*), i32 2) to i64),
  ; # [5232] place
  i64 6967344416514,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_place to i8*), i32 2) to i64),
  ; # [5248] strip
  i64 7724887131954,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_strip to i8*), i32 2) to i64),
  ; # [5264] split
  i64 7999758731058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_split to i8*), i32 2) to i64),
  ; # [5280] reverse
  i64 456894525016004386,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_reverse to i8*), i32 2) to i64),
  ; # [5296] flip
  i64 30175315554,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_flip to i8*), i32 2) to i64),
  ; # [5312] trim
  i64 29370033986,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_trim to i8*), i32 2) to i64),
  ; # [5328] clip
  i64 30175315506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_clip to i8*), i32 2) to i64),
  ; # [5344] head
  i64 26945672834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_head to i8*), i32 2) to i64),
  ; # [5360] tail
  i64 29101528898,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_tail to i8*), i32 2) to i64),
  ; # [5376] stem
  i64 29365847858,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_stem to i8*), i32 2) to i64),
  ; # [5392] fin
  i64 115775074,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fin to i8*), i32 2) to i64),
  ; # [5408] last
  i64 31259498178,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_last to i8*), i32 2) to i64),
  ; # [5424] ==
  i64 250834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eq to i8*), i32 2) to i64),
  ; # [5440] n==
  i64 64214754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_neq to i8*), i32 2) to i64),
  ; # [5456] =
  i64 978,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_equal to i8*), i32 2) to i64),
  ; # [5472] <>
  i64 254914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nequal to i8*), i32 2) to i64),
  ; # [5488] =0
  i64 197586,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eq0 to i8*), i32 2) to i64),
  ; # [5504] =1
  i64 201682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eq1 to i8*), i32 2) to i64),
  ; # [5520] =T
  i64 345042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_eqT to i8*), i32 2) to i64),
  ; # [5536] n0
  i64 198370,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_neq0 to i8*), i32 2) to i64),
  ; # [5552] nT
  i64 345826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_neqT to i8*), i32 2) to i64),
  ; # [5568] <
  i64 962,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lt to i8*), i32 2) to i64),
  ; # [5584] <=
  i64 250818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_le to i8*), i32 2) to i64),
  ; # [5600] >
  i64 994,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_gt to i8*), i32 2) to i64),
  ; # [5616] >=
  i64 250850,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ge to i8*), i32 2) to i64),
  ; # [5632] max
  i64 126228178,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_max to i8*), i32 2) to i64),
  ; # [5648] min
  i64 115775186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_min to i8*), i32 2) to i64),
  ; # [5664] atom
  i64 29376333330,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_atom to i8*), i32 2) to i64),
  ; # [5680] pair
  i64 30712141570,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pair to i8*), i32 2) to i64),
  ; # [5696] circ?
  i64 4356022113842,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_circQ to i8*), i32 2) to i64),
  ; # [5712] lst?
  i64 17033541314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lstQ to i8*), i32 2) to i64),
  ; # [5728] num?
  i64 17026209506,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_numQ to i8*), i32 2) to i64),
  ; # [5744] sym?
  i64 17026225970,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_symQ to i8*), i32 2) to i64),
  ; # [5760] flg?
  i64 17019881058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_flgQ to i8*), i32 2) to i64),
  ; # [5776] member
  i64 2012476297598674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_member to i8*), i32 2) to i64),
  ; # [5792] memq
  i64 30447916754,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_memq to i8*), i32 2) to i64),
  ; # [5808] mmeq
  i64 30439560914,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_mmeq to i8*), i32 2) to i64),
  ; # [5824] sect
  i64 31242737458,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sect to i8*), i32 2) to i64),
  ; # [5840] diff
  i64 27487802946,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_diff to i8*), i32 2) to i64),
  ; # [5856] index
  i64 8273554499218,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_index to i8*), i32 2) to i64),
  ; # [5872] offset
  i64 2047665225754354,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_offset to i8*), i32 2) to i64),
  ; # [5888] prior
  i64 7863927252738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prior to i8*), i32 2) to i64),
  ; # [5904] length
  i64 1837586572531394,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_length to i8*), i32 2) to i64),
  ; # [5920] size
  i64 27240339250,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_size to i8*), i32 2) to i64),
  ; # [5936] bytes
  i64 7929973937698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_bytes to i8*), i32 2) to i64),
  ; # [5952] assoc
  i64 6833145591314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_assoc to i8*), i32 2) to i64),
  ; # [5968] rassoc
  i64 1749285271377698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rassoc to i8*), i32 2) to i64),
  ; # [5984] asoq
  i64 30450071058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_asoq to i8*), i32 2) to i64),
  ; # [6000] rank
  i64 28838336290,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rank to i8*), i32 2) to i64),
  ; # [6016] match
  i64 7173522724562,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_match to i8*), i32 2) to i64),
  ; # [6032] fill
  i64 29104707170,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_fill to i8*), i32 2) to i64),
  ; # [6048] prove
  i64 6972459394818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_prove to i8*), i32 2) to i64),
  ; # [6064] ->
  i64 254674,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_arrow to i8*), i32 2) to i64),
  ; # [6080] unify
  i64 8342547654482,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_unify to i8*), i32 2) to i64),
  ; # [6096] group
  i64 7728105203314,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_group to i8*), i32 2) to i64),
  ; # [6112] sort
  i64 31258507058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sort to i8*), i32 2) to i64),
  ; # [6128] raw
  i64 125179682,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_raw to i8*), i32 2) to i64),
  ; # [6144] alarm
  i64 7521126762002,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_alarm to i8*), i32 2) to i64),
  ; # [6160] sigio
  i64 7656156075826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sigio to i8*), i32 2) to i64),
  ; # [6176] kids
  i64 30975366834,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_kids to i8*), i32 2) to i64),
  ; # [6192] protect
  i64 524166155115898626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_protect to i8*), i32 2) to i64),
  ; # [6208] heap
  i64 30166898306,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_heap to i8*), i32 2) to i64),
  ; # [6224] stack
  i64 7379661309746,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_stack to i8*), i32 2) to i64),
  ; # [6240] byte
  i64 27234113058,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_byte to i8*), i32 2) to i64),
  ; # [6256] env
  i64 124184146,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_env to i8*), i32 2) to i64),
  ; # [6272] date
  i64 27234014786,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_date to i8*), i32 2) to i64),
  ; # [6288] time
  i64 27226707778,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_time to i8*), i32 2) to i64),
  ; # [6304] usec
  i64 26681489234,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_usec to i8*), i32 2) to i64),
  ; # [6320] quit
  i64 31249094418,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_quit to i8*), i32 2) to i64),
  ; # [6336] sys
  i64 121083698,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_sys to i8*), i32 2) to i64),
  ; # [6352] pwd
  i64 105346818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_pwd to i8*), i32 2) to i64),
  ; # [6368] cd
  i64 411186,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cd to i8*), i32 2) to i64),
  ; # [6384] ctty
  i64 32602801714,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_ctty to i8*), i32 2) to i64),
  ; # [6400] cmd
  i64 105305650,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_cmd to i8*), i32 2) to i64),
  ; # [6416] dir
  i64 119969346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_dir to i8*), i32 2) to i64),
  ; # [6432] info
  i64 29903742610,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_info to i8*), i32 2) to i64),
  ; # [6448] file
  i64 27225658978,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_file to i8*), i32 2) to i64),
  ; # [6464] argv
  i64 31783855634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_argv to i8*), i32 2) to i64),
  ; # [6480] opt
  i64 122095346,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_opt to i8*), i32 2) to i64),
  ; # [6496] %@
  i64 262738,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_nat to i8*), i32 2) to i64),
  ; # [6512] errno
  i64 7657509824082,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_errno to i8*), i32 2) to i64),
  ; # [6528] native
  i64 1784947996497634,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_native to i8*), i32 2) to i64),
  ; # [6544] struct
  i64 2047528336312114,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_struct to i8*), i32 2) to i64),
  ; # [6560] lisp
  i64 30185789122,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_lisp to i8*), i32 2) to i64),
  ; # [6576] args
  i64 30978549266,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_args to i8*), i32 2) to i64),
  ; # [6592] next
  i64 31264757474,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_next to i8*), i32 2) to i64),
  ; # [6608] arg
  i64 108471826,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_arg to i8*), i32 2) to i64),
  ; # [6624] rest
  i64 31259514658,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_rest to i8*), i32 2) to i64),
  ; # [6640] adr
  i64 119948818,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_adr to i8*), i32 2) to i64),
  ; # [6656] trail
  i64 7449991391042,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_trail to i8*), i32 2) to i64),
  ; # [6672] up
  i64 460626,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_up to i8*), i32 2) to i64),
  ; # [6688] history
  i64 546948723242342018,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_history to i8*), i32 2) to i64),
  ; # [6704] version
  i64 497355938196772706,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast (i64(i64)* @_version to i8*), i32 2) to i64)
], align 16
@gcData = global [52 x i64] [
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
], align 8
@cbFuns = global [24 x i64] [
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb1 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb2 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb3 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb4 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb5 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb6 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb7 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb8 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb9 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb10 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb11 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb12 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb13 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb14 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb15 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb16 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb17 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb18 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb19 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb20 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb21 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb22 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb23 to i64),
  i64 ptrtoint (i64(i64,i64,i64,i64,i64)* @_cb24 to i64)
], align 8
@env = global [24 x i64] [
  i64 0,
  i64 0,
  i64 0,
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 sext (i32 0 to i64),
  i64 ptrtoint (void(i8)* @_putStdout to i64),
  i64 ptrtoint (i32()* @_getStdin to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i8* null to i64),
  i64 ptrtoint (i64* null to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 112) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 0,
  i64 0,
  i64 0,
  i64 0,
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 sext (i32 0 to i64),
  i64 sext (i32 0 to i64)
], align 8
@$Cell = global [2 x i64] [
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64),
  i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
]
@$Version = global [3 x i64] [
  i64 338,
  i64 2,
  i64 2
], align 8
@$TBuf = global [2 x i8] [
  i8 5,
  i8 84
]
@$Month = global [13 x i8] [
  i8 31,
  i8 31,
  i8 28,
  i8 31,
  i8 30,
  i8 31,
  i8 30,
  i8 31,
  i8 31,
  i8 30,
  i8 31,
  i8 30,
  i8 31
]
@$Repl = global i1 0
@$PRepl = global i1 0
@$Jam = global i1 0
@$InBye = global i1 0
@$Sync = global i1 0
@$Empty = constant [1 x i8] c"\00"
@$Indent = constant [4 x i8] c"   \00"
@$Delim = constant [16 x i8] c" \09\0A\0D\22'(),[]`~{}\00"
declare i8* @malloc(i64)
declare i8* @realloc(i8*, i64)
declare void @free(i8*)
declare i32 @fork()
declare i8* @getenv(i8*)
declare i32 @setenv(i8*, i8*, i32)
declare i8* @getcwd(i8*, i64)
declare i32 @chdir(i8*)
declare i32 @getpid()
declare i32 @getpgrp()
declare i32 @setsid()
declare i32 @alarm(i32)
declare i32 @setpgid(i32, i32)
declare i32 @execvp(i8*, i8**)
declare i32 @isatty(i32)
declare i32 @tcgetattr(i32, i8*)
declare i64 @read(i32, i8*, i64)
declare i64 @write(i32, i8*, i64)
declare i64 @pread(i32, i8*, i64, i64)
declare i64 @pwrite(i32, i8*, i64, i64)
declare i32 @fread(i8*, i32, i32, i8*)
declare i32 @fwrite(i8*, i32, i32, i8*)
declare i32 @putc_unlocked(i32, i8*)
declare i8* @fopen(i8*, i8*)
declare i32 @fflush(i8*)
declare i32 @feof(i8*)
declare i32 @fclose(i8*)
declare i32 @fileno(i8*)
declare i32 @fsync(i32)
declare i32 @pipe(i32*)
declare i32 @memcmp(i8*, i8*, i64)
declare i64 @strlen(i8*)
declare i8* @strcpy(i8*, i8*)
declare i8* @strdup(i8*)
declare i32 @strcmp(i8*, i8*)
declare i8* @strchr(i8*, i32)
declare i8* @strrchr(i8*, i32)
declare i8* @dlsym(i8*, i8*)
declare i8* @dlerror()
declare i32 @dup(i32)
declare i32 @dup2(i32, i32)
declare i32 @close(i32)
declare i8* @signal(i32, i8*)
declare i32 @tcsetpgrp(i32, i32)
declare i32 @waitpid(i32, i32*, i32)
declare i32 @setjmp(i8*)
declare void @longjmp(i8*, i32)
declare i32 @kill(i32, i32)
declare void @exit(i32)
declare i8* @readline(i8*)
declare void @add_history(i8*)
declare i8*** @history_list()
declare void @clear_history()
@TgOS = external global i8
@TgCPU = external global i8
@PipeBufSize = external global i64
declare i64 @stderrNum(i8*, i64)
declare i8* @stderrMsg(i8*, i8*)
declare i32 @gPrintf(i8*, i32, i8*, i8*)
declare i8* @strErrno()
declare i32 @openRd(i8*)
declare i32 @openWr(i8*)
declare i32 @openRdWr(i8*)
declare i32 @openRdWrExcl(i8*)
declare i32 @openRdWrCreate(i8*)
declare i32 @openRdWrAppend(i8*)
declare i32 @openWrAppend(i8*)
declare i1 @fseekOfs(i8*, i32)
declare i1 @fseek0(i8*)
declare i1 @seek0(i32)
declare i1 @truncate0(i32)
declare i32 @socketPair(i32*)
declare i32 @fcntlCloExec(i32)
declare void @fcntlSetFl(i32, i32)
declare i32 @nonBlocking(i32)
declare void @fcntlSetOwn(i32, i32)
declare i8* @getDir(i8*)
declare void @initReadline()
declare void @rlSigBeg()
declare void @rlSigEnd()
declare i8* @currentLine()
@Sig = external global i32
@SigDfl = external global i8*
@SigIgn = external global i8*
declare i32 @gSignal(i32)
declare void @sigUnblock(i32)
declare void @iSignal(i32, i8*)
declare void @waitNohang()
declare i32 @waitWuntraced(i32, i32*)
declare i32 @wifStopped(i32*)
declare i32 @nErrno()
declare i32 @gErrno()
@Tio = external global i1
@OrgTermio = external global i8
@Termio = global i8* null
declare void @stopTerm()
declare void @setRaw()
declare void @setCooked()
declare i1 @reopenTty(i8*)
declare i64 @getUsec(i1)
declare i64 @getMsec()
declare i64 @getDate()
declare i64 @getGmDate()
declare i64 @getTime()
declare i64 @getGmTime()
declare i64 @fileInfo(i1, i8*, i64*)
declare void @pollIn(i32, i64*)
declare void @pollOut(i32, i64*)
declare i32 @gPoll(i64*, i64, i64)
declare i1 @readyIn(i64*, i32)
declare i1 @readyOut(i64*, i32)
declare i32 @rdLock(i32, i64, i64)
declare i32 @wrLock(i32, i64, i64, i32)
declare i32 @unLock(i32, i64, i64)
declare i32 @getLock(i32, i64, i64)
@JmpBufSize = external global i64
@QuitRst = external global i8
declare i8* @dlOpen(i8*)
declare i8* @ffiPrep(i8*, i8*, i64)
declare i64 @ffiCall(i8*, i64)
declare i64 @boxFloat(i32, i64)
declare i64 @boxDouble(i64, i64)
declare void @bufFloat(i64, i64, i8*)
declare void @bufDouble(i64, i64, i8*)
declare i1 @isLowc(i32)
declare i1 @isUppc(i32)
declare i1 @isLetterOrDigit(i32)
declare i32 @toUpperCase(i32)
declare i32 @toLowerCase(i32)

define i64 @execAt(i64) {
$1:
; # (let At (save (val $At)) (exec Prg) (set $At At))
; # (val $At)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %2 = load i64, i64* %1
; # (save (val $At))
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 %2, i64* %5
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %4 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %10
; # (exec Prg)
  br label %$2
$2:
  %11 = phi i64 [%0, %$1], [%23, %$5] ; # Prg
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
  %16 = and i64 %13, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$3, label %$4
$3:
  %18 = phi i64 [%15, %$2] ; # Prg
  %19 = call i64 @evList(i64 %13)
  br label %$4
$4:
  %20 = phi i64 [%15, %$2], [%18, %$3] ; # Prg
  %21 = and i64 %20, 15
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$6, label %$5
$5:
  %23 = phi i64 [%20, %$4] ; # Prg
  br label %$2
$6:
  %24 = phi i64 [%20, %$4] ; # Prg
  %25 = phi i64 [0, %$4] ; # ->
; # (set $At At)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %2, i64* %26
; # (drop *Safe)
  %27 = inttoptr i64 %4 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %30
  ret i64 %2
}

define i64 @runAt(i64) {
$1:
; # (let At (save (val $At)) (prog1 (run Prg) (set $At At)))
; # (val $At)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %2 = load i64, i64* %1
; # (save (val $At))
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 %2, i64* %5
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %4 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %10
; # (prog1 (run Prg) (set $At At))
; # (run Prg)
  br label %$2
$2:
  %11 = phi i64 [%0, %$1], [%33, %$11] ; # Prg
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
  %16 = and i64 %15, 15
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$5, label %$3
$5:
  %18 = phi i64 [%15, %$2] ; # Prg
  %19 = and i64 %13, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$8, label %$7
$8:
  br label %$6
$7:
  %21 = and i64 %13, 8
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$10, label %$9
$10:
  %23 = inttoptr i64 %13 to i64*
  %24 = load i64, i64* %23
  br label %$6
$9:
  %25 = call i64 @evList(i64 %13)
  br label %$6
$6:
  %26 = phi i64 [%13, %$8], [%24, %$10], [%25, %$9] ; # ->
  br label %$4
$3:
  %27 = phi i64 [%15, %$2] ; # Prg
  %28 = and i64 %13, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$12, label %$11
$12:
  %30 = phi i64 [%27, %$3] ; # Prg
  %31 = call i64 @evList(i64 %13)
  %32 = icmp ne i64 %31, 0
  br label %$11
$11:
  %33 = phi i64 [%27, %$3], [%30, %$12] ; # Prg
  %34 = phi i1 [0, %$3], [%32, %$12] ; # ->
  br label %$2
$4:
  %35 = phi i64 [%18, %$6] ; # Prg
  %36 = phi i64 [%26, %$6] ; # ->
; # (set $At At)
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %2, i64* %37
; # (drop *Safe)
  %38 = inttoptr i64 %4 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  ret i64 %36
}

define i64 @wrnl() {
$1:
; # (write 1 ($ "^J") 1)
  %0 = call i64 @write(i32 1, i8* bitcast ([2 x i8]* @$1 to i8*), i64 1)
  ret i64 %0
}

define void @unwind(i8*) {
$1:
; # (let (Ca (val $Catch) Bnd (val $Bind)) (while Ca (let Ca: (caFram...
; # (val $Catch)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (val $Bind)
  %2 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %3 = load i64, i64* %2
; # (while Ca (let Ca: (caFrame Ca) (while (and Bnd (<> Bnd (Ca: (env...
  br label %$2
$2:
  %4 = phi i8* [%1, %$1], [%106, %$28] ; # Ca
  %5 = phi i64 [%3, %$1], [%104, %$28] ; # Bnd
  %6 = icmp ne i8* %4, null
  br i1 %6, label %$3, label %$4
$3:
  %7 = phi i8* [%4, %$2] ; # Ca
  %8 = phi i64 [%5, %$2] ; # Bnd
; # (let Ca: (caFrame Ca) (while (and Bnd (<> Bnd (Ca: (env $Bind any...
; # (while (and Bnd (<> Bnd (Ca: (env $Bind any)))) (set (val 2 Bnd) ...
  br label %$5
$5:
  %9 = phi i8* [%7, %$3], [%23, %$8] ; # Ca
  %10 = phi i64 [%8, %$3], [%33, %$8] ; # Bnd
; # (and Bnd (<> Bnd (Ca: (env $Bind any))))
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$7, label %$6
$7:
  %12 = phi i8* [%9, %$5] ; # Ca
  %13 = phi i64 [%10, %$5] ; # Bnd
; # (Ca: (env $Bind any))
  %14 = getelementptr i8, i8* %7, i32 24
  %15 = getelementptr i8, i8* %14, i32 8
  %16 = ptrtoint i8* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
; # (<> Bnd (Ca: (env $Bind any)))
  %19 = icmp ne i64 %13, %18
  br label %$6
$6:
  %20 = phi i8* [%9, %$5], [%12, %$7] ; # Ca
  %21 = phi i64 [%10, %$5], [%13, %$7] ; # Bnd
  %22 = phi i1 [0, %$5], [%19, %$7] ; # ->
  br i1 %22, label %$8, label %$9
$8:
  %23 = phi i8* [%20, %$6] ; # Ca
  %24 = phi i64 [%21, %$6] ; # Bnd
; # (set (val 2 Bnd) (val Bnd))
; # (val 2 Bnd)
  %25 = inttoptr i64 %24 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (val Bnd)
  %28 = inttoptr i64 %24 to i64*
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %27 to i64*
  store i64 %29, i64* %30
; # (val 3 Bnd)
  %31 = inttoptr i64 %24 to i64*
  %32 = getelementptr i64, i64* %31, i32 2
  %33 = load i64, i64* %32
  br label %$5
$9:
  %34 = phi i8* [%20, %$6] ; # Ca
  %35 = phi i64 [%21, %$6] ; # Bnd
; # (until (== (val $CtlFrames) (Ca: (env $CtlFrames i8*))) (popCtlFi...
  br label %$10
$10:
  %36 = phi i8* [%34, %$9], [%44, %$11] ; # Ca
  %37 = phi i64 [%35, %$9], [%45, %$11] ; # Bnd
; # (val $CtlFrames)
  %38 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 64) to i8**)
; # (Ca: (env $CtlFrames i8*))
  %39 = getelementptr i8, i8* %7, i32 24
  %40 = getelementptr i8, i8* %39, i32 64
  %41 = bitcast i8* %40 to i8**
  %42 = load i8*, i8** %41
; # (== (val $CtlFrames) (Ca: (env $CtlFrames i8*)))
  %43 = icmp eq i8* %38, %42
  br i1 %43, label %$12, label %$11
$11:
  %44 = phi i8* [%36, %$10] ; # Ca
  %45 = phi i64 [%37, %$10] ; # Bnd
; # (popCtlFiles)
  call void @popCtlFiles()
  br label %$10
$12:
  %46 = phi i8* [%36, %$10] ; # Ca
  %47 = phi i64 [%37, %$10] ; # Bnd
; # (until (== (val $ErrFrames) (Ca: (env $ErrFrames i8*))) (popErrFi...
  br label %$13
$13:
  %48 = phi i8* [%46, %$12], [%56, %$14] ; # Ca
  %49 = phi i64 [%47, %$12], [%57, %$14] ; # Bnd
; # (val $ErrFrames)
  %50 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 56) to i8**)
; # (Ca: (env $ErrFrames i8*))
  %51 = getelementptr i8, i8* %7, i32 24
  %52 = getelementptr i8, i8* %51, i32 56
  %53 = bitcast i8* %52 to i8**
  %54 = load i8*, i8** %53
; # (== (val $ErrFrames) (Ca: (env $ErrFrames i8*)))
  %55 = icmp eq i8* %50, %54
  br i1 %55, label %$15, label %$14
$14:
  %56 = phi i8* [%48, %$13] ; # Ca
  %57 = phi i64 [%49, %$13] ; # Bnd
; # (popErrFiles)
  call void @popErrFiles()
  br label %$13
$15:
  %58 = phi i8* [%48, %$13] ; # Ca
  %59 = phi i64 [%49, %$13] ; # Bnd
; # (until (== (val $OutFrames) (Ca: (env $OutFrames i8*))) (popOutFi...
  br label %$16
$16:
  %60 = phi i8* [%58, %$15], [%68, %$17] ; # Ca
  %61 = phi i64 [%59, %$15], [%69, %$17] ; # Bnd
; # (val $OutFrames)
  %62 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (Ca: (env $OutFrames i8*))
  %63 = getelementptr i8, i8* %7, i32 24
  %64 = getelementptr i8, i8* %63, i32 48
  %65 = bitcast i8* %64 to i8**
  %66 = load i8*, i8** %65
; # (== (val $OutFrames) (Ca: (env $OutFrames i8*)))
  %67 = icmp eq i8* %62, %66
  br i1 %67, label %$18, label %$17
$17:
  %68 = phi i8* [%60, %$16] ; # Ca
  %69 = phi i64 [%61, %$16] ; # Bnd
; # (popOutFiles)
  call void @popOutFiles()
  br label %$16
$18:
  %70 = phi i8* [%60, %$16] ; # Ca
  %71 = phi i64 [%61, %$16] ; # Bnd
; # (until (== (val $InFrames) (Ca: (env $InFrames i8*))) (popInFiles...
  br label %$19
$19:
  %72 = phi i8* [%70, %$18], [%80, %$20] ; # Ca
  %73 = phi i64 [%71, %$18], [%81, %$20] ; # Bnd
; # (val $InFrames)
  %74 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (Ca: (env $InFrames i8*))
  %75 = getelementptr i8, i8* %7, i32 24
  %76 = getelementptr i8, i8* %75, i32 40
  %77 = bitcast i8* %76 to i8**
  %78 = load i8*, i8** %77
; # (== (val $InFrames) (Ca: (env $InFrames i8*)))
  %79 = icmp eq i8* %74, %78
  br i1 %79, label %$21, label %$20
$20:
  %80 = phi i8* [%72, %$19] ; # Ca
  %81 = phi i64 [%73, %$19] ; # Bnd
; # (popInFiles)
  call void @popInFiles()
  br label %$19
$21:
  %82 = phi i8* [%72, %$19] ; # Ca
  %83 = phi i64 [%73, %$19] ; # Bnd
; # (i8* $Link)
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i8*
; # (Ca: (env))
  %85 = getelementptr i8, i8* %7, i32 24
; # (memcpy (env) (Ca: (env)) (env T))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %84, i8* %85, i64 192, i1 0)
; # (Ca: fin)
  %86 = getelementptr i8, i8* %7, i32 16
  %87 = ptrtoint i8* %86 to i64
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (eval (Ca: fin))
  %90 = and i64 %89, 6
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$24, label %$23
$24:
  br label %$22
$23:
  %92 = and i64 %89, 8
  %93 = icmp ne i64 %92, 0
  br i1 %93, label %$26, label %$25
$26:
  %94 = inttoptr i64 %89 to i64*
  %95 = load i64, i64* %94
  br label %$22
$25:
  %96 = call i64 @evList(i64 %89)
  br label %$22
$22:
  %97 = phi i64 [%89, %$24], [%95, %$26], [%96, %$25] ; # ->
; # (set $Catch (Ca: link))
; # (Ca: link)
  %98 = bitcast i8* %7 to i8**
  %99 = load i8*, i8** %98
  store i8* %99, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (when (== Ca Catch) (ret))
; # (== Ca Catch)
  %100 = icmp eq i8* %82, %0
  br i1 %100, label %$27, label %$28
$27:
  %101 = phi i8* [%82, %$22] ; # Ca
  %102 = phi i64 [%83, %$22] ; # Bnd
; # (ret)
  ret void
$28:
  %103 = phi i8* [%82, %$22] ; # Ca
  %104 = phi i64 [%83, %$22] ; # Bnd
; # (Ca: link)
  %105 = bitcast i8* %7 to i8**
  %106 = load i8*, i8** %105
  br label %$2
$4:
  %107 = phi i8* [%4, %$2] ; # Ca
  %108 = phi i64 [%5, %$2] ; # Bnd
; # (while Bnd (set (val 2 Bnd) (val Bnd)) (setq Bnd (val 3 Bnd)))
  br label %$29
$29:
  %109 = phi i8* [%107, %$4], [%112, %$30] ; # Ca
  %110 = phi i64 [%108, %$4], [%122, %$30] ; # Bnd
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$30, label %$31
$30:
  %112 = phi i8* [%109, %$29] ; # Ca
  %113 = phi i64 [%110, %$29] ; # Bnd
; # (set (val 2 Bnd) (val Bnd))
; # (val 2 Bnd)
  %114 = inttoptr i64 %113 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
; # (val Bnd)
  %117 = inttoptr i64 %113 to i64*
  %118 = load i64, i64* %117
  %119 = inttoptr i64 %116 to i64*
  store i64 %118, i64* %119
; # (val 3 Bnd)
  %120 = inttoptr i64 %113 to i64*
  %121 = getelementptr i64, i64* %120, i32 2
  %122 = load i64, i64* %121
  br label %$29
$31:
  %123 = phi i8* [%109, %$29] ; # Ca
  %124 = phi i64 [%110, %$29] ; # Bnd
; # (set $Bind 0)
  %125 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 0, i64* %125
; # (while (val $CtlFrames) (popCtlFiles))
  br label %$32
$32:
  %126 = phi i8* [%123, %$31], [%130, %$33] ; # Ca
  %127 = phi i64 [%124, %$31], [%131, %$33] ; # Bnd
; # (val $CtlFrames)
  %128 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 64) to i8**)
  %129 = icmp ne i8* %128, null
  br i1 %129, label %$33, label %$34
$33:
  %130 = phi i8* [%126, %$32] ; # Ca
  %131 = phi i64 [%127, %$32] ; # Bnd
; # (popCtlFiles)
  call void @popCtlFiles()
  br label %$32
$34:
  %132 = phi i8* [%126, %$32] ; # Ca
  %133 = phi i64 [%127, %$32] ; # Bnd
; # (while (val $ErrFrames) (popErrFiles))
  br label %$35
$35:
  %134 = phi i8* [%132, %$34], [%138, %$36] ; # Ca
  %135 = phi i64 [%133, %$34], [%139, %$36] ; # Bnd
; # (val $ErrFrames)
  %136 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 56) to i8**)
  %137 = icmp ne i8* %136, null
  br i1 %137, label %$36, label %$37
$36:
  %138 = phi i8* [%134, %$35] ; # Ca
  %139 = phi i64 [%135, %$35] ; # Bnd
; # (popErrFiles)
  call void @popErrFiles()
  br label %$35
$37:
  %140 = phi i8* [%134, %$35] ; # Ca
  %141 = phi i64 [%135, %$35] ; # Bnd
; # (while (val $OutFrames) (popOutFiles))
  br label %$38
$38:
  %142 = phi i8* [%140, %$37], [%146, %$39] ; # Ca
  %143 = phi i64 [%141, %$37], [%147, %$39] ; # Bnd
; # (val $OutFrames)
  %144 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
  %145 = icmp ne i8* %144, null
  br i1 %145, label %$39, label %$40
$39:
  %146 = phi i8* [%142, %$38] ; # Ca
  %147 = phi i64 [%143, %$38] ; # Bnd
; # (popOutFiles)
  call void @popOutFiles()
  br label %$38
$40:
  %148 = phi i8* [%142, %$38] ; # Ca
  %149 = phi i64 [%143, %$38] ; # Bnd
; # (while (val $InFrames) (popInFiles))
  br label %$41
$41:
  %150 = phi i8* [%148, %$40], [%154, %$42] ; # Ca
  %151 = phi i64 [%149, %$40], [%155, %$42] ; # Bnd
; # (val $InFrames)
  %152 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
  %153 = icmp ne i8* %152, null
  br i1 %153, label %$42, label %$43
$42:
  %154 = phi i8* [%150, %$41] ; # Ca
  %155 = phi i64 [%151, %$41] ; # Bnd
; # (popInFiles)
  call void @popInFiles()
  br label %$41
$43:
  %156 = phi i8* [%150, %$41] ; # Ca
  %157 = phi i64 [%151, %$41] ; # Bnd
  ret void
}

define void @finish(i32) {
$1:
; # (setCooked)
  call void @setCooked()
; # (exit N)
  call void @exit(i32 %0)
  unreachable
}

define void @giveup(i8*, i8*) {
$1:
; # (stderrMsg Fmt Msg)
  %2 = call i8* @stderrMsg(i8* %0, i8* %1)
; # (finish 1)
  call void @finish(i32 1)
  unreachable
}

define void @bye(i32) {
$1:
; # (unless (val $InBye) (set $InBye YES) (unwind null) (exec (val $B...
; # (val $InBye)
  %1 = load i1, i1* @$InBye
  br i1 %1, label %$3, label %$2
$2:
; # (set $InBye YES)
  store i1 1, i1* @$InBye
; # (unwind null)
  call void @unwind(i8* null)
; # (val $Bye)
  %2 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 728) to i64) to i64*
  %3 = load i64, i64* %2
; # (exec (val $Bye))
  br label %$4
$4:
  %4 = phi i64 [%3, %$2], [%16, %$7] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %6, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$5, label %$6
$5:
  %11 = phi i64 [%8, %$4] ; # Prg
  %12 = call i64 @evList(i64 %6)
  br label %$6
$6:
  %13 = phi i64 [%8, %$4], [%11, %$5] ; # Prg
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$7
$7:
  %16 = phi i64 [%13, %$6] ; # Prg
  br label %$4
$8:
  %17 = phi i64 [%13, %$6] ; # Prg
  %18 = phi i64 [0, %$6] ; # ->
  br label %$3
$3:
; # (flushAll)
  call void @flushAll()
; # (finish N)
  call void @finish(i32 %0)
  unreachable
}

define void @execErr(i8*) {
$1:
; # (stderrMsg ($ "%s: Can't exec^J") Cmd)
  %1 = call i8* @stderrMsg(i8* bitcast ([16 x i8]* @$2 to i8*), i8* %0)
; # (exit 127)
  call void @exit(i32 127)
  unreachable
}

define i8* @alloc(i8*, i64) {
$1:
; # (unless (realloc Ptr Siz) (giveup ($ "No memory") null))
; # (realloc Ptr Siz)
  %2 = call i8* @realloc(i8* %0, i64 %1)
  %3 = icmp ne i8* %2, null
  br i1 %3, label %$3, label %$2
$2:
; # (giveup ($ "No memory") null)
  call void @giveup(i8* bitcast ([10 x i8]* @$3 to i8*), i8* null)
  unreachable
$3:
  ret i8* %2
}

define void @heapAlloc() {
$1:
; # (let (H (any (alloc null (* 8 (inc HEAP)))) P (ofs H HEAP) A (val...
; # (inc HEAP)
; # (* 8 (inc HEAP))
; # (alloc null (* 8 (inc HEAP)))
  %0 = call i8* @alloc(i8* null, i64 1048584)
; # (any (alloc null (* 8 (inc HEAP))))
  %1 = ptrtoint i8* %0 to i64
; # (ofs H HEAP)
  %2 = add i64 %1, 1048576
; # (val $Avail)
  %3 = load i64, i64* @$Avail
; # (set P (val $Heaps) $Heaps H)
; # (val $Heaps)
  %4 = load i64, i64* @$Heaps
  %5 = inttoptr i64 %2 to i64*
  store i64 %4, i64* %5
  store i64 %1, i64* @$Heaps
; # (loop (set (setq P (ofs P -2)) A) (? (== (setq A P) H)))
  br label %$2
$2:
  %6 = phi i64 [%2, %$1], [%11, %$3] ; # P
  %7 = phi i64 [%3, %$1], [%12, %$3] ; # A
; # (set (setq P (ofs P -2)) A)
; # (ofs P -2)
  %8 = add i64 %6, -16
  %9 = inttoptr i64 %8 to i64*
  store i64 %7, i64* %9
; # (? (== (setq A P) H))
; # (== (setq A P) H)
  %10 = icmp eq i64 %8, %1
  br i1 %10, label %$4, label %$3
$3:
  %11 = phi i64 [%8, %$2] ; # P
  %12 = phi i64 [%8, %$2] ; # A
  br label %$2
$4:
  %13 = phi i64 [%8, %$2] ; # P
  %14 = phi i64 [%8, %$2] ; # A
  %15 = phi i64 [0, %$2] ; # ->
; # (set $Avail A)
  store i64 %14, i64* @$Avail
  ret void
}

define void @sig(i32) {
$1:
; # (if (val $TtyPid) (kill @ N) (set $Signal (+ (val $Signal) 1)) (l...
; # (val $TtyPid)
  %1 = load i32, i32* @$TtyPid
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (kill @ N)
  %3 = call i32 @kill(i32 %1, i32 %0)
  br label %$4
$3:
; # (set $Signal (+ (val $Signal) 1))
; # (val $Signal)
  %4 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (+ (val $Signal) 1)
  %5 = add i32 %4, 1
  store i32 %5, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (let P (ofs $Signal (gSignal N)) (set P (+ (val P) 1)))
; # (gSignal N)
  %6 = call i32 @gSignal(i32 %0)
; # (ofs $Signal (gSignal N))
  %7 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 %6
; # (set P (+ (val P) 1))
; # (val P)
  %8 = load i32, i32* %7
; # (+ (val P) 1)
  %9 = add i32 %8, 1
  store i32 %9, i32* %7
  br label %$4
$4:
  %10 = phi i32 [%3, %$2], [%9, %$3] ; # ->
  ret void
}

define void @sigTerm(i32) {
$1:
; # (if (val $TtyPid) (kill @ N) (set $Signal (+ (val $Signal) 1)) (l...
; # (val $TtyPid)
  %1 = load i32, i32* @$TtyPid
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (kill @ N)
  %3 = call i32 @kill(i32 %1, i32 %0)
  br label %$4
$3:
; # (set $Signal (+ (val $Signal) 1))
; # (val $Signal)
  %4 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (+ (val $Signal) 1)
  %5 = add i32 %4, 1
  store i32 %5, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (let P (ofs $Signal (gSignal (val SIGTERM Sig))) (set P (+ (val P...
; # (val SIGTERM Sig)
  %6 = getelementptr i32, i32* @Sig, i32 6
  %7 = load i32, i32* %6
; # (gSignal (val SIGTERM Sig))
  %8 = call i32 @gSignal(i32 %7)
; # (ofs $Signal (gSignal (val SIGTERM Sig)))
  %9 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 %8
; # (set P (+ (val P) 1))
; # (val P)
  %10 = load i32, i32* %9
; # (+ (val P) 1)
  %11 = add i32 %10, 1
  store i32 %11, i32* %9
  br label %$4
$4:
  %12 = phi i32 [%3, %$2], [%11, %$3] ; # ->
  ret void
}

define void @sigChld(i32) {
$1:
; # (waitNohang)
  call void @waitNohang()
  ret void
}

define void @sighandler(i64) {
$1:
; # (unless (val $Protect) (set $Protect 1) (let P T (loop (cond ((va...
; # (val $Protect)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
; # (set $Protect 1)
  store i32 1, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (let P T (loop (cond ((val (setq P (ofs $Signal SIGIO))) (set P (...
; # (loop (cond ((val (setq P (ofs $Signal SIGIO))) (set P (dec @)) (...
  br label %$4
$4:
; # (cond ((val (setq P (ofs $Signal SIGIO))) (set P (dec @)) (set $S...
; # (ofs $Signal SIGIO)
  %3 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 14
; # (val (setq P (ofs $Signal SIGIO)))
  %4 = load i32, i32* %3
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %$7, label %$6
$7:
  %6 = phi i32* [%3, %$4] ; # P
; # (set P (dec @))
; # (dec @)
  %7 = sub i32 %4, 1
  store i32 %7, i32* %6
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %8 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %9 = sub i32 %8, 1
  store i32 %9, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (val $Sigio)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 24) to i64) to i64*
  %11 = load i64, i64* %10
; # (execAt (val $Sigio))
  %12 = call i64 @execAt(i64 %11)
  br label %$5
$6:
  %13 = phi i32* [%3, %$4] ; # P
; # (ofs $Signal SIGUSR1)
  %14 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 3
; # (val (setq P (ofs $Signal SIGUSR1)))
  %15 = load i32, i32* %14
  %16 = icmp ne i32 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i32* [%14, %$6] ; # P
; # (set P (dec @))
; # (dec @)
  %18 = sub i32 %15, 1
  store i32 %18, i32* %17
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %19 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %20 = sub i32 %19, 1
  store i32 %20, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (val $Sig1)
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 584) to i64) to i64*
  %22 = load i64, i64* %21
; # (execAt (val $Sig1))
  %23 = call i64 @execAt(i64 %22)
  br label %$5
$8:
  %24 = phi i32* [%14, %$6] ; # P
; # (ofs $Signal SIGUSR2)
  %25 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 4
; # (val (setq P (ofs $Signal SIGUSR2)))
  %26 = load i32, i32* %25
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$11, label %$10
$11:
  %28 = phi i32* [%25, %$8] ; # P
; # (set P (dec @))
; # (dec @)
  %29 = sub i32 %26, 1
  store i32 %29, i32* %28
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %30 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %31 = sub i32 %30, 1
  store i32 %31, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (val $Sig2)
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 600) to i64) to i64*
  %33 = load i64, i64* %32
; # (execAt (val $Sig2))
  %34 = call i64 @execAt(i64 %33)
  br label %$5
$10:
  %35 = phi i32* [%25, %$8] ; # P
; # (ofs $Signal SIGALRM)
  %36 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 6
; # (val (setq P (ofs $Signal SIGALRM)))
  %37 = load i32, i32* %36
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %$13, label %$12
$13:
  %39 = phi i32* [%36, %$10] ; # P
; # (set P (dec @))
; # (dec @)
  %40 = sub i32 %37, 1
  store i32 %40, i32* %39
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %41 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %42 = sub i32 %41, 1
  store i32 %42, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (val $Alarm)
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 16) to i64) to i64*
  %44 = load i64, i64* %43
; # (execAt (val $Alarm))
  %45 = call i64 @execAt(i64 %44)
  br label %$5
$12:
  %46 = phi i32* [%36, %$10] ; # P
; # (ofs $Signal SIGHUP)
  %47 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 1
; # (val (setq P (ofs $Signal SIGHUP)))
  %48 = load i32, i32* %47
  %49 = icmp ne i32 %48, 0
  br i1 %49, label %$15, label %$14
$15:
  %50 = phi i32* [%47, %$12] ; # P
; # (set P (dec @))
; # (dec @)
  %51 = sub i32 %48, 1
  store i32 %51, i32* %50
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %52 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %53 = sub i32 %52, 1
  store i32 %53, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (val $Hup)
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 568) to i64) to i64*
  %55 = load i64, i64* %54
; # (execAt (val $Hup))
  %56 = call i64 @execAt(i64 %55)
  br label %$5
$14:
  %57 = phi i32* [%47, %$12] ; # P
; # (ofs $Signal SIGINT)
  %58 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 2
; # (val (setq P (ofs $Signal SIGINT)))
  %59 = load i32, i32* %58
  %60 = icmp ne i32 %59, 0
  br i1 %60, label %$17, label %$16
$17:
  %61 = phi i32* [%58, %$14] ; # P
; # (set P (dec @))
; # (dec @)
  %62 = sub i32 %59, 1
  store i32 %62, i32* %61
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %63 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %64 = sub i32 %63, 1
  store i32 %64, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (unless (val $PRepl) (wrnl) (rlSigBeg) (brkLoad (if Exe @ $Nil)) ...
; # (val $PRepl)
  %65 = load i1, i1* @$PRepl
  br i1 %65, label %$19, label %$18
$18:
  %66 = phi i32* [%61, %$17] ; # P
; # (wrnl)
  %67 = call i64 @wrnl()
; # (rlSigBeg)
  call void @rlSigBeg()
; # (if Exe @ $Nil)
  %68 = icmp ne i64 %0, 0
  br i1 %68, label %$20, label %$21
$20:
  %69 = phi i32* [%66, %$18] ; # P
  br label %$22
$21:
  %70 = phi i32* [%66, %$18] ; # P
  br label %$22
$22:
  %71 = phi i32* [%69, %$20], [%70, %$21] ; # P
  %72 = phi i64 [%0, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
; # (brkLoad (if Exe @ $Nil))
  %73 = call i64 @brkLoad(i64 %72)
; # (rlSigEnd)
  call void @rlSigEnd()
  br label %$19
$19:
  %74 = phi i32* [%61, %$17], [%71, %$22] ; # P
  br label %$5
$16:
  %75 = phi i32* [%58, %$14] ; # P
; # (ofs $Signal SIGTSTP)
  %76 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 11
; # (val (setq P (ofs $Signal SIGTSTP)))
  %77 = load i32, i32* %76
  %78 = icmp ne i32 %77, 0
  br i1 %78, label %$24, label %$23
$24:
  %79 = phi i32* [%76, %$16] ; # P
; # (set P (dec @))
; # (dec @)
  %80 = sub i32 %77, 1
  store i32 %80, i32* %79
; # (set $Signal (dec (val $Signal)))
; # (val $Signal)
  %81 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (dec (val $Signal))
  %82 = sub i32 %81, 1
  store i32 %82, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (rlSigBeg)
  call void @rlSigBeg()
; # (val $TStp1)
  %83 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 616) to i64) to i64*
  %84 = load i64, i64* %83
; # (execAt (val $TStp1))
  %85 = call i64 @execAt(i64 %84)
; # (stopTerm)
  call void @stopTerm()
; # (val SIGTSTP Sig)
  %86 = getelementptr i32, i32* @Sig, i32 10
  %87 = load i32, i32* %86
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car Args)) (func (; Args 1 priv~si...
  %88 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGTSTP Sig) (fun sig))
  call void @iSignal(i32 %87, i8* %88)
; # (val $TStp2)
  %89 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 632) to i64) to i64*
  %90 = load i64, i64* %89
; # (execAt (val $TStp2))
  %91 = call i64 @execAt(i64 %90)
; # (rlSigEnd)
  call void @rlSigEnd()
  br label %$5
$23:
  %92 = phi i32* [%76, %$16] ; # P
; # (ofs $Signal SIGTERM)
  %93 = getelementptr i32, i32* bitcast ([15 x i32]* @$Signal to i32*), i32 7
; # (val (setq P (ofs $Signal SIGTERM)))
  %94 = load i32, i32* %93
  %95 = icmp ne i32 %94, 0
  br i1 %95, label %$26, label %$25
$26:
  %96 = phi i32* [%93, %$23] ; # P
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %97 = load i8*, i8** @$Child
; # (val $Children)
  %98 = load i64, i64* @$Children
; # (* (val $Children) (child T))
  %99 = mul i64 %98, 36
; # (ofs Cld (* (val $Children) (child T)))
  %100 = getelementptr i8, i8* %97, i64 %99
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (and (Cld: pid) ...
  br label %$27
$27:
  %101 = phi i32* [%96, %$26], [%126, %$33] ; # P
  %102 = phi i8* [%97, %$26], [%129, %$33] ; # Cld
  %103 = phi i1 [0, %$26], [%128, %$33] ; # Flg
; # (== Cld <Cld)
  %104 = icmp eq i8* %102, %100
  br i1 %104, label %$29, label %$28
$28:
  %105 = phi i32* [%101, %$27] ; # P
  %106 = phi i8* [%102, %$27] ; # Cld
  %107 = phi i1 [%103, %$27] ; # Flg
; # (let Cld: (child Cld) (when (and (Cld: pid) (=0 (kill @ (val SIGT...
; # (when (and (Cld: pid) (=0 (kill @ (val SIGTERM Sig)))) (setq Flg ...
; # (and (Cld: pid) (=0 (kill @ (val SIGTERM Sig))))
; # (Cld: pid)
  %108 = getelementptr i8, i8* %106, i32 24
  %109 = bitcast i8* %108 to i32*
  %110 = load i32, i32* %109
  %111 = icmp ne i32 %110, 0
  br i1 %111, label %$31, label %$30
$31:
  %112 = phi i32* [%105, %$28] ; # P
  %113 = phi i8* [%106, %$28] ; # Cld
  %114 = phi i1 [%107, %$28] ; # Flg
; # (val SIGTERM Sig)
  %115 = getelementptr i32, i32* @Sig, i32 6
  %116 = load i32, i32* %115
; # (kill @ (val SIGTERM Sig))
  %117 = call i32 @kill(i32 %110, i32 %116)
; # (=0 (kill @ (val SIGTERM Sig)))
  %118 = icmp eq i32 %117, 0
  br label %$30
$30:
  %119 = phi i32* [%105, %$28], [%112, %$31] ; # P
  %120 = phi i8* [%106, %$28], [%113, %$31] ; # Cld
  %121 = phi i1 [%107, %$28], [%114, %$31] ; # Flg
  %122 = phi i1 [0, %$28], [%118, %$31] ; # ->
  br i1 %122, label %$32, label %$33
$32:
  %123 = phi i32* [%119, %$30] ; # P
  %124 = phi i8* [%120, %$30] ; # Cld
  %125 = phi i1 [%121, %$30] ; # Flg
  br label %$33
$33:
  %126 = phi i32* [%119, %$30], [%123, %$32] ; # P
  %127 = phi i8* [%120, %$30], [%124, %$32] ; # Cld
  %128 = phi i1 [%121, %$30], [1, %$32] ; # Flg
; # (ofs Cld (child T))
  %129 = getelementptr i8, i8* %127, i32 36
  br label %$27
$29:
  %130 = phi i32* [%101, %$27] ; # P
  %131 = phi i8* [%102, %$27] ; # Cld
  %132 = phi i1 [%103, %$27] ; # Flg
; # (? Flg)
  br i1 %132, label %$35, label %$34
$34:
  %133 = phi i32* [%130, %$29] ; # P
  %134 = phi i8* [%131, %$29] ; # Cld
  %135 = phi i1 [%132, %$29] ; # Flg
; # (set $Signal 0)
  store i32 0, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (rlSigBeg)
  call void @rlSigBeg()
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$25:
  %136 = phi i32* [%93, %$23] ; # P
  br label %$5
$5:
  %137 = phi i32* [%6, %$7], [%17, %$9], [%28, %$11], [%39, %$13], [%50, %$15], [%74, %$19], [%79, %$24], [%136, %$25] ; # P
; # (? (=0 (val $Signal)))
; # (val $Signal)
  %138 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
; # (=0 (val $Signal))
  %139 = icmp eq i32 %138, 0
  br i1 %139, label %$35, label %$36
$36:
  %140 = phi i32* [%137, %$5] ; # P
  br label %$4
$35:
  %141 = phi i32* [%130, %$29], [%137, %$5] ; # P
  %142 = phi i64 [0, %$29], [0, %$5] ; # ->
; # (set $Protect 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  br label %$3
$3:
  ret void
}

define void @err(i64, i64, i8*, i8*) {
$1:
; # (set $Up (if Exe @ $Nil))
; # (if Exe @ $Nil)
  %4 = icmp ne i64 %0, 0
  br i1 %4, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %5 = phi i64 [%0, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64) to i64*
  store i64 %5, i64* %6
; # (when X (link (push X NIL)))
  %7 = icmp ne i64 %1, 0
  br i1 %7, label %$5, label %$6
$5:
; # (push X NIL)
  %8 = alloca i64, i64 2, align 16
  %9 = ptrtoint i64* %8 to i64
  %10 = inttoptr i64 %9 to i64*
  store i64 %1, i64* %10
; # (link (push X NIL))
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %12 = load i64, i64* %11
  %13 = inttoptr i64 %9 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  store i64 %12, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %9, i64* %15
  br label %$6
$6:
; # (let Msg (b8 240) (gPrintf Msg 240 Fmt Arg) (when (val Msg) (set ...
; # (b8 240)
  %16 = alloca i8, i64 240
; # (gPrintf Msg 240 Fmt Arg)
  %17 = call i32 @gPrintf(i8* %16, i32 240, i8* %2, i8* %3)
; # (when (val Msg) (set $Msg (mkStr Msg)) (let Ca (val $Catch) (whil...
; # (val Msg)
  %18 = load i8, i8* %16
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %$7, label %$8
$7:
; # (set $Msg (mkStr Msg))
; # (mkStr Msg)
  %20 = call i64 @mkStr(i8* %16)
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 680) to i64) to i64*
  store i64 %20, i64* %21
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (let Tag (Ca...
; # (val $Catch)
  %22 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (let Tag (Ca: tag) (when Tag (whi...
  br label %$9
$9:
  %23 = phi i8* [%22, %$7], [%71, %$13] ; # Ca
  %24 = icmp ne i8* %23, null
  br i1 %24, label %$10, label %$11
$10:
  %25 = phi i8* [%23, %$9] ; # Ca
; # (let Ca: (caFrame Ca) (let Tag (Ca: tag) (when Tag (while (pair T...
; # (let Tag (Ca: tag) (when Tag (while (pair Tag) (when (subStr (car...
; # (Ca: tag)
  %26 = getelementptr i8, i8* %25, i32 8
  %27 = ptrtoint i8* %26 to i64
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (when Tag (while (pair Tag) (when (subStr (car Tag) (val $Msg)) (...
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$12, label %$13
$12:
  %31 = phi i8* [%25, %$10] ; # Ca
  %32 = phi i64 [%29, %$10] ; # Tag
; # (while (pair Tag) (when (subStr (car Tag) (val $Msg)) (set $Ret (...
  br label %$14
$14:
  %33 = phi i8* [%31, %$12], [%61, %$18] ; # Ca
  %34 = phi i64 [%32, %$12], [%65, %$18] ; # Tag
; # (pair Tag)
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$15, label %$16
$15:
  %37 = phi i8* [%33, %$14] ; # Ca
  %38 = phi i64 [%34, %$14] ; # Tag
; # (when (subStr (car Tag) (val $Msg)) (set $Ret (if (nil? (car Tag)...
; # (car Tag)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (val $Msg)
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 680) to i64) to i64*
  %42 = load i64, i64* %41
; # (subStr (car Tag) (val $Msg))
  %43 = call i1 @subStr(i64 %40, i64 %42)
  br i1 %43, label %$17, label %$18
$17:
  %44 = phi i8* [%37, %$15] ; # Ca
  %45 = phi i64 [%38, %$15] ; # Tag
; # (set $Ret (if (nil? (car Tag)) (val $Msg) (car Tag)))
; # (if (nil? (car Tag)) (val $Msg) (car Tag))
; # (car Tag)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (nil? (car Tag))
  %48 = icmp eq i64 %47, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %48, label %$19, label %$20
$19:
  %49 = phi i8* [%44, %$17] ; # Ca
  %50 = phi i64 [%45, %$17] ; # Tag
; # (val $Msg)
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 680) to i64) to i64*
  %52 = load i64, i64* %51
  br label %$21
$20:
  %53 = phi i8* [%44, %$17] ; # Ca
  %54 = phi i64 [%45, %$17] ; # Tag
; # (car Tag)
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
  br label %$21
$21:
  %57 = phi i8* [%49, %$19], [%53, %$20] ; # Ca
  %58 = phi i64 [%50, %$19], [%54, %$20] ; # Tag
  %59 = phi i64 [%52, %$19], [%56, %$20] ; # ->
  store i64 %59, i64* @$Ret
; # (Ca:)
; # (unwind (Ca:))
  call void @unwind(i8* %25)
; # (Ca: (rst))
  %60 = getelementptr i8, i8* %25, i32 216
; # (longjmp (Ca: (rst)) 1)
  call void @longjmp(i8* %60, i32 1)
  unreachable
$18:
  %61 = phi i8* [%37, %$15] ; # Ca
  %62 = phi i64 [%38, %$15] ; # Tag
; # (shift Tag)
  %63 = inttoptr i64 %62 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  %65 = load i64, i64* %64
  br label %$14
$16:
  %66 = phi i8* [%33, %$14] ; # Ca
  %67 = phi i64 [%34, %$14] ; # Tag
  br label %$13
$13:
  %68 = phi i8* [%25, %$10], [%66, %$16] ; # Ca
  %69 = phi i64 [%29, %$10], [%67, %$16] ; # Tag
; # (Ca: link)
  %70 = bitcast i8* %25 to i8**
  %71 = load i8*, i8** %70
  br label %$9
$11:
  %72 = phi i8* [%23, %$9] ; # Ca
  br label %$8
$8:
; # (set $Chr (set $ExtN 0))
; # (set $ExtN 0)
  store i32 0, i32* @$ExtN
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (set $Break 0)
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 16) to i64) to i64*
  store i64 0, i64* %73
; # (set $LinePtr null)
  store i8* null, i8** @$LinePtr
; # (set $Alarm (set $Sigio $Nil))
; # (set $Sigio $Nil)
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 24) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 16) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %75
; # (let Io: (ioFrame (b8 (ioFrame T))) (Io: fd 2) (Io: pid 0) (pushO...
; # (b8 (ioFrame T))
  %76 = alloca i8, i64 24
; # (Io: fd 2)
  %77 = getelementptr i8, i8* %76, i32 8
  %78 = bitcast i8* %77 to i32*
  store i32 2, i32* %78
; # (Io: pid 0)
  %79 = getelementptr i8, i8* %76, i32 12
  %80 = bitcast i8* %79 to i32*
  store i32 0, i32* %80
; # (Io:)
; # (pushOutFiles (Io:))
  call void @pushOutFiles(i8* %76)
; # (let In: (inFile (val $InFile)) (when (and (In:) (In: name)) (cal...
; # (val $InFile)
  %81 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (when (and (In:) (In: name)) (call $Put (char "[")) (outString (I...
; # (and (In:) (In: name))
; # (In:)
  %82 = icmp ne i8* %81, null
  br i1 %82, label %$23, label %$22
$23:
; # (In: name)
  %83 = getelementptr i8, i8* %81, i32 24
  %84 = bitcast i8* %83 to i8**
  %85 = load i8*, i8** %84
  %86 = icmp ne i8* %85, null
  br label %$22
$22:
  %87 = phi i1 [0, %$8], [%86, %$23] ; # ->
  br i1 %87, label %$24, label %$25
$24:
; # (call $Put (char "["))
  %88 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %88(i8 91)
; # (In: name)
  %89 = getelementptr i8, i8* %81, i32 24
  %90 = bitcast i8* %89 to i8**
  %91 = load i8*, i8** %90
; # (outString (In: name))
  call void @outString(i8* %91)
; # (call $Put (char ":"))
  %92 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %92(i8 58)
; # (In: src)
  %93 = getelementptr i8, i8* %81, i32 36
  %94 = bitcast i8* %93 to i32*
  %95 = load i32, i32* %94
; # (i64 (In: src))
  %96 = sext i32 %95 to i64
; # (outWord (i64 (In: src)))
  call void @outWord(i64 %96)
; # (call $Put (char "]"))
  %97 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %97(i8 93)
; # (space)
  call void @space()
  br label %$25
$25:
; # (when Exe (outString ($ "!? ")) (print Exe) (newline))
  %98 = icmp ne i64 %0, 0
  br i1 %98, label %$26, label %$27
$26:
; # (outString ($ "!? "))
  call void @outString(i8* bitcast ([4 x i8]* @$4 to i8*))
; # (print Exe)
  call void @print(i64 %0)
; # (newline)
  call void @newline()
  br label %$27
$27:
; # (when X (print X) (outString ($ " -- ")))
  %99 = icmp ne i64 %1, 0
  br i1 %99, label %$28, label %$29
$28:
; # (print X)
  call void @print(i64 %1)
; # (outString ($ " -- "))
  call void @outString(i8* bitcast ([5 x i8]* @$5 to i8*))
  br label %$29
$29:
; # (when (val Msg) (outString Msg) (newline) (unless (or (nil? (val ...
; # (val Msg)
  %100 = load i8, i8* %16
  %101 = icmp ne i8 %100, 0
  br i1 %101, label %$30, label %$31
$30:
; # (outString Msg)
  call void @outString(i8* %16)
; # (newline)
  call void @newline()
; # (unless (or (nil? (val $Err)) (val $Jam)) (set $Jam YES) (execAt ...
; # (or (nil? (val $Err)) (val $Jam))
; # (val $Err)
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 664) to i64) to i64*
  %103 = load i64, i64* %102
; # (nil? (val $Err))
  %104 = icmp eq i64 %103, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %104, label %$32, label %$33
$33:
; # (val $Jam)
  %105 = load i1, i1* @$Jam
  br label %$32
$32:
  %106 = phi i1 [1, %$30], [%105, %$33] ; # ->
  br i1 %106, label %$35, label %$34
$34:
; # (set $Jam YES)
  store i1 1, i1* @$Jam
; # (val $Err)
  %107 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 664) to i64) to i64*
  %108 = load i64, i64* %107
; # (execAt (val $Err))
  %109 = call i64 @execAt(i64 %108)
; # (set $Jam NO)
  store i1 0, i1* @$Jam
  br label %$35
$35:
; # (unless (and (isatty 0) (isatty 1)) (bye 1))
; # (and (isatty 0) (isatty 1))
; # (isatty 0)
  %110 = call i32 @isatty(i32 0)
  %111 = icmp ne i32 %110, 0
  br i1 %111, label %$37, label %$36
$37:
; # (isatty 1)
  %112 = call i32 @isatty(i32 1)
  %113 = icmp ne i32 %112, 0
  br label %$36
$36:
  %114 = phi i1 [0, %$35], [%113, %$37] ; # ->
  br i1 %114, label %$39, label %$38
$38:
; # (bye 1)
  call void @bye(i32 1)
  unreachable
$39:
; # (repl 0 ($ "? ") $Nil)
  %115 = call i64 @repl(i64 0, i8* bitcast ([3 x i8]* @$6 to i8*), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$31
$31:
; # (unwind null)
  call void @unwind(i8* null)
; # (set $Link 0 $Protect 0 $Task $Nil $Next $Nil $Make 0 $Yoke 0 $Tr...
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 0, i64* %116
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 168) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %117
  %118 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %118
  %119 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 0, i64* %119
  %120 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  store i64 0, i64* %120
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 184) to i32*)
; # (set $Put (fun (void i8) _putStdout))
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
; # (set $Get (fun (i32) _getStdin))
; # (fun (i32) _getStdin)
  store i32()* @_getStdin, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
; # (longjmp QuitRst 1)
  call void @longjmp(i8* @QuitRst, i32 1)
  unreachable
}

define void @stkErr(i64) {
$1:
; # (set $StkLimit null)
  store i8* null, i8** @$StkLimit
; # (err Exe 0 ($ "Stack overflow") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([15 x i8]* @$7 to i8*), i8* null)
  unreachable
}

define void @argErr(i64, i64) {
$1:
; # (err Exe X ($ "Bad argument") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([13 x i8]* @$8 to i8*), i8* null)
  unreachable
}

define void @cntErr(i64, i64) {
$1:
; # (err Exe X ($ "Small number expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([22 x i8]* @$9 to i8*), i8* null)
  unreachable
}

define void @numErr(i64, i64) {
$1:
; # (err Exe X ($ "Number expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([16 x i8]* @$10 to i8*), i8* null)
  unreachable
}

define void @symErr(i64, i64) {
$1:
; # (err Exe X ($ "Symbol expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([16 x i8]* @$11 to i8*), i8* null)
  unreachable
}

define void @extErr(i64, i64) {
$1:
; # (err Exe X ($ "External symbol expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([25 x i8]* @$12 to i8*), i8* null)
  unreachable
}

define void @nameErr(i64, i64) {
$1:
; # (err Exe X ($ "Name expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([14 x i8]* @$13 to i8*), i8* null)
  unreachable
}

define void @atomErr(i64, i64) {
$1:
; # (err Exe X ($ "Atom expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([14 x i8]* @$14 to i8*), i8* null)
  unreachable
}

define void @pairErr(i64, i64) {
$1:
; # (err Exe X ($ "Cons pair expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([19 x i8]* @$15 to i8*), i8* null)
  unreachable
}

define void @lstErr(i64, i64) {
$1:
; # (err Exe X ($ "List expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([14 x i8]* @$16 to i8*), i8* null)
  unreachable
}

define void @varErr(i64, i64) {
$1:
; # (err Exe X ($ "Variable expected") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([18 x i8]* @$17 to i8*), i8* null)
  unreachable
}

define void @itemErr(i64, i64) {
$1:
; # (err Exe X ($ "Item not found") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([15 x i8]* @$18 to i8*), i8* null)
  unreachable
}

define void @protErr(i64, i64) {
$1:
; # (err Exe X ($ "Protected symbol") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([17 x i8]* @$19 to i8*), i8* null)
  unreachable
}

define void @lockErr() {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "File lock: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$20 to i8*), i8* %0)
  unreachable
}

define void @forkErr(i64) {
$1:
; # (err Exe 0 ($ "Can't fork") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([11 x i8]* @$21 to i8*), i8* null)
  unreachable
}

define void @symNspErr(i64, i64) {
$1:
; # (err Exe X ($ "Bad symbol namespace") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([21 x i8]* @$22 to i8*), i8* null)
  unreachable
}

define i64 @xCnt(i64, i64) {
$1:
; # (let N (int (needCnt Exe X)) (if (sign? X) (- N) N))
; # (needCnt Exe X)
  %2 = and i64 %1, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  call void @cntErr(i64 %0, i64 %1)
  unreachable
$3:
; # (int (needCnt Exe X))
  %4 = lshr i64 %1, 4
; # (if (sign? X) (- N) N)
; # (sign? X)
  %5 = and i64 %1, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$4, label %$5
$4:
; # (- N)
  %7 = sub i64 0, %4
  br label %$6
$5:
  br label %$6
$6:
  %8 = phi i64 [%7, %$4], [%4, %$5] ; # ->
  ret i64 %8
}

define i64 @evCnt(i64, i64) {
$1:
; # (car X)
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (eval (car X))
  %4 = and i64 %3, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
  br label %$2
$3:
  %6 = and i64 %3, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
  %8 = inttoptr i64 %3 to i64*
  %9 = load i64, i64* %8
  br label %$2
$5:
  %10 = call i64 @evList(i64 %3)
  br label %$2
$2:
  %11 = phi i64 [%3, %$4], [%9, %$6], [%10, %$5] ; # ->
; # (xCnt Exe (eval (car X)))
  %12 = call i64 @xCnt(i64 %0, i64 %11)
  ret i64 %12
}

define i64 @evLst(i64) {
$1:
; # (let X (eval (car Exe)) (unless (or (pair X) (nil? X)) (lstErr Ex...
; # (car Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (eval (car Exe))
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$4, label %$3
$4:
  br label %$2
$3:
  %5 = and i64 %2, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  %7 = inttoptr i64 %2 to i64*
  %8 = load i64, i64* %7
  br label %$2
$5:
  %9 = call i64 @evList(i64 %2)
  br label %$2
$2:
  %10 = phi i64 [%2, %$4], [%8, %$6], [%9, %$5] ; # ->
; # (unless (or (pair X) (nil? X)) (lstErr Exe X))
; # (or (pair X) (nil? X))
; # (pair X)
  %11 = and i64 %10, 15
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %$7, label %$8
$8:
; # (nil? X)
  %13 = icmp eq i64 %10, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %14 = phi i1 [1, %$2], [%13, %$8] ; # ->
  br i1 %14, label %$10, label %$9
$9:
; # (lstErr Exe X)
  call void @lstErr(i64 %0, i64 %10)
  unreachable
$10:
  ret i64 %10
}

define i64 @xSym(i64) {
$1:
; # (if (symb? X) X (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (...
; # (symb? X)
  %1 = xor i64 %0, 8
  %2 = and i64 %1, 14
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (pack X P) (consS...
; # (push 4 NIL ZERO NIL)
  %4 = alloca i64, i64 4, align 16
  store i64 4, i64* %4
  %5 = getelementptr i64, i64* %4, i32 2
  store i64 2, i64* %5
; # (ofs P 2)
  %6 = getelementptr i64, i64* %4, i32 2
; # (link (ofs P 2) T)
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %7 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %12
; # (pack X P)
  call void @pack(i64 %0, i64* %4)
; # (val 3 P)
  %13 = getelementptr i64, i64* %4, i32 2
  %14 = load i64, i64* %13
; # (consStr (val 3 P))
  %15 = call i64 @consStr(i64 %14)
; # (drop *Safe)
  %16 = inttoptr i64 %7 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %19
  br label %$4
$4:
  %20 = phi i64 [%0, %$2], [%15, %$3] ; # ->
  ret i64 %20
}

define i64 @evSym(i64) {
$1:
; # (car Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (eval (car Exe))
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$4, label %$3
$4:
  br label %$2
$3:
  %5 = and i64 %2, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  %7 = inttoptr i64 %2 to i64*
  %8 = load i64, i64* %7
  br label %$2
$5:
  %9 = call i64 @evList(i64 %2)
  br label %$2
$2:
  %10 = phi i64 [%2, %$4], [%8, %$6], [%9, %$5] ; # ->
; # (xSym (eval (car Exe)))
  %11 = call i64 @xSym(i64 %10)
  ret i64 %11
}

define i64 @xName(i64, i64) {
$1:
; # (cond ((nil? Sym) ZERO) ((sym? (val (tail Sym))) (nameErr Exe Sym...
; # (nil? Sym)
  %2 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %2, label %$4, label %$3
$4:
  br label %$2
$3:
; # (tail Sym)
  %3 = add i64 %1, -8
; # (val (tail Sym))
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (sym? (val (tail Sym)))
  %6 = and i64 %5, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
; # (nameErr Exe Sym)
  call void @nameErr(i64 %0, i64 %1)
  unreachable
$5:
; # (name @)
  br label %$7
$7:
  %8 = phi i64 [%5, %$5], [%14, %$8] ; # Tail
  %9 = and i64 %8, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$9, label %$8
$8:
  %11 = phi i64 [%8, %$7] ; # Tail
  %12 = inttoptr i64 %11 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  %14 = load i64, i64* %13
  br label %$7
$9:
  %15 = phi i64 [%8, %$7] ; # Tail
  br label %$2
$2:
  %16 = phi i64 [2, %$4], [%15, %$9] ; # ->
  ret i64 %16
}

define i64 @circ(i64) {
$1:
; # (if (atom X) 0 (let Y X (loop (set Y (| (val Y) 1)) (? (atom (shi...
; # (atom X)
  %1 = and i64 %0, 15
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i64 [%0, %$1] ; # X
  br label %$4
$3:
  %4 = phi i64 [%0, %$1] ; # X
; # (let Y X (loop (set Y (| (val Y) 1)) (? (atom (shift Y)) (loop (s...
; # (loop (set Y (| (val Y) 1)) (? (atom (shift Y)) (loop (set X (& (...
  br label %$5
$5:
  %5 = phi i64 [%4, %$3], [%71, %$12] ; # X
  %6 = phi i64 [%4, %$3], [%72, %$12] ; # Y
; # (set Y (| (val Y) 1))
; # (val Y)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (| (val Y) 1)
  %9 = or i64 %8, 1
  %10 = inttoptr i64 %6 to i64*
  store i64 %9, i64* %10
; # (? (atom (shift Y)) (loop (set X (& (val X) -2)) (? (atom (shift ...
; # (shift Y)
  %11 = inttoptr i64 %6 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
; # (atom (shift Y))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$6
$8:
  %16 = phi i64 [%5, %$5] ; # X
  %17 = phi i64 [%13, %$5] ; # Y
; # (loop (set X (& (val X) -2)) (? (atom (shift X))))
  br label %$9
$9:
  %18 = phi i64 [%16, %$8], [%29, %$10] ; # X
  %19 = phi i64 [%17, %$8], [%30, %$10] ; # Y
; # (set X (& (val X) -2))
; # (val X)
  %20 = inttoptr i64 %18 to i64*
  %21 = load i64, i64* %20
; # (& (val X) -2)
  %22 = and i64 %21, -2
  %23 = inttoptr i64 %18 to i64*
  store i64 %22, i64* %23
; # (? (atom (shift X)))
; # (shift X)
  %24 = inttoptr i64 %18 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$11, label %$10
$10:
  %29 = phi i64 [%26, %$9] ; # X
  %30 = phi i64 [%19, %$9] ; # Y
  br label %$9
$11:
  %31 = phi i64 [%26, %$9] ; # X
  %32 = phi i64 [%19, %$9] ; # Y
  %33 = phi i64 [0, %$9] ; # ->
  br label %$7
$6:
  %34 = phi i64 [%5, %$5] ; # X
  %35 = phi i64 [%13, %$5] ; # Y
; # (? (& (val Y) 1) (until (== X Y) (set X (& (val X) -2)) (shift X)...
; # (val Y)
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
; # (& (val Y) 1)
  %38 = and i64 %37, 1
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$13, label %$12
$13:
  %40 = phi i64 [%34, %$6] ; # X
  %41 = phi i64 [%35, %$6] ; # Y
; # (until (== X Y) (set X (& (val X) -2)) (shift X))
  br label %$14
$14:
  %42 = phi i64 [%40, %$13], [%53, %$15] ; # X
  %43 = phi i64 [%41, %$13], [%46, %$15] ; # Y
; # (== X Y)
  %44 = icmp eq i64 %42, %43
  br i1 %44, label %$16, label %$15
$15:
  %45 = phi i64 [%42, %$14] ; # X
  %46 = phi i64 [%43, %$14] ; # Y
; # (set X (& (val X) -2))
; # (val X)
  %47 = inttoptr i64 %45 to i64*
  %48 = load i64, i64* %47
; # (& (val X) -2)
  %49 = and i64 %48, -2
  %50 = inttoptr i64 %45 to i64*
  store i64 %49, i64* %50
; # (shift X)
  %51 = inttoptr i64 %45 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  br label %$14
$16:
  %54 = phi i64 [%42, %$14] ; # X
  %55 = phi i64 [%43, %$14] ; # Y
; # (loop (set X (& (val X) -2)) (? (== Y (shift X))))
  br label %$17
$17:
  %56 = phi i64 [%54, %$16], [%66, %$18] ; # X
  %57 = phi i64 [%55, %$16], [%67, %$18] ; # Y
; # (set X (& (val X) -2))
; # (val X)
  %58 = inttoptr i64 %56 to i64*
  %59 = load i64, i64* %58
; # (& (val X) -2)
  %60 = and i64 %59, -2
  %61 = inttoptr i64 %56 to i64*
  store i64 %60, i64* %61
; # (? (== Y (shift X)))
; # (shift X)
  %62 = inttoptr i64 %56 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (== Y (shift X))
  %65 = icmp eq i64 %57, %64
  br i1 %65, label %$19, label %$18
$18:
  %66 = phi i64 [%64, %$17] ; # X
  %67 = phi i64 [%57, %$17] ; # Y
  br label %$17
$19:
  %68 = phi i64 [%64, %$17] ; # X
  %69 = phi i64 [%57, %$17] ; # Y
  %70 = phi i64 [0, %$17] ; # ->
  br label %$7
$12:
  %71 = phi i64 [%34, %$6] ; # X
  %72 = phi i64 [%35, %$6] ; # Y
  br label %$5
$7:
  %73 = phi i64 [%31, %$11], [%68, %$19] ; # X
  %74 = phi i64 [%32, %$11], [%69, %$19] ; # Y
  %75 = phi i64 [0, %$11], [%69, %$19] ; # ->
  br label %$4
$4:
  %76 = phi i64 [%3, %$2], [%73, %$7] ; # X
  %77 = phi i64 [0, %$2], [%75, %$7] ; # ->
  ret i64 %77
}

define i64 @funq(i64) {
$1:
; # (cond ((cnt? X) X) ((or (big? X) (sym? X)) 0) ((circ X) 0) (T (le...
; # (cnt? X)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
  br label %$2
$3:
  %4 = phi i64 [%0, %$1] ; # X
; # (or (big? X) (sym? X))
; # (big? X)
  %5 = and i64 %4, 4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$6
$6:
  %7 = phi i64 [%4, %$3] ; # X
; # (sym? X)
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
  br label %$5
$5:
  %10 = phi i64 [%4, %$3], [%7, %$6] ; # X
  %11 = phi i1 [1, %$3], [%9, %$6] ; # ->
  br i1 %11, label %$8, label %$7
$8:
  %12 = phi i64 [%10, %$5] ; # X
  br label %$2
$7:
  %13 = phi i64 [%10, %$5] ; # X
; # (circ X)
  %14 = call i64 @circ(i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$10, label %$9
$10:
  %16 = phi i64 [%13, %$7] ; # X
  br label %$2
$9:
  %17 = phi i64 [%13, %$7] ; # X
; # (let Y (cdr X) (loop (? (atom Y) (cond ((not (nil? Y)) 0) ((nil? ...
; # (cdr X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (loop (? (atom Y) (cond ((not (nil? Y)) 0) ((nil? (setq X (car X)...
  br label %$11
$11:
  %21 = phi i64 [%17, %$9], [%145, %$38] ; # X
  %22 = phi i64 [%20, %$9], [%146, %$38] ; # Y
; # (? (atom Y) (cond ((not (nil? Y)) 0) ((nil? (setq X (car X))) $T)...
; # (atom Y)
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$14, label %$12
$14:
  %25 = phi i64 [%21, %$11] ; # X
  %26 = phi i64 [%22, %$11] ; # Y
; # (cond ((not (nil? Y)) 0) ((nil? (setq X (car X))) $T) ((circ (set...
; # (nil? Y)
  %27 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %28 = icmp eq i1 %27, 0
  br i1 %28, label %$17, label %$16
$17:
  %29 = phi i64 [%25, %$14] ; # X
  %30 = phi i64 [%26, %$14] ; # Y
  br label %$15
$16:
  %31 = phi i64 [%25, %$14] ; # X
  %32 = phi i64 [%26, %$14] ; # Y
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (nil? (setq X (car X)))
  %35 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %35, label %$19, label %$18
$19:
  %36 = phi i64 [%34, %$16] ; # X
  %37 = phi i64 [%32, %$16] ; # Y
  br label %$15
$18:
  %38 = phi i64 [%34, %$16] ; # X
  %39 = phi i64 [%32, %$16] ; # Y
; # (circ (setq Y X))
  %40 = call i64 @circ(i64 %38)
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$21, label %$20
$21:
  %42 = phi i64 [%38, %$18] ; # X
  %43 = phi i64 [%38, %$18] ; # Y
  br label %$15
$20:
  %44 = phi i64 [%38, %$18] ; # X
  %45 = phi i64 [%38, %$18] ; # Y
; # (loop (? (atom Y) (if (or (num? Y) (t? Y)) 0 X)) (? (or (not (sym...
  br label %$22
$22:
  %46 = phi i64 [%44, %$20], [%88, %$34] ; # X
  %47 = phi i64 [%45, %$20], [%89, %$34] ; # Y
; # (? (atom Y) (if (or (num? Y) (t? Y)) 0 X))
; # (atom Y)
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$25, label %$23
$25:
  %50 = phi i64 [%46, %$22] ; # X
  %51 = phi i64 [%47, %$22] ; # Y
; # (if (or (num? Y) (t? Y)) 0 X)
; # (or (num? Y) (t? Y))
; # (num? Y)
  %52 = and i64 %51, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$26, label %$27
$27:
  %54 = phi i64 [%50, %$25] ; # X
  %55 = phi i64 [%51, %$25] ; # Y
; # (t? Y)
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br label %$26
$26:
  %57 = phi i64 [%50, %$25], [%54, %$27] ; # X
  %58 = phi i64 [%51, %$25], [%55, %$27] ; # Y
  %59 = phi i1 [1, %$25], [%56, %$27] ; # ->
  br i1 %59, label %$28, label %$29
$28:
  %60 = phi i64 [%57, %$26] ; # X
  %61 = phi i64 [%58, %$26] ; # Y
  br label %$30
$29:
  %62 = phi i64 [%57, %$26] ; # X
  %63 = phi i64 [%58, %$26] ; # Y
  br label %$30
$30:
  %64 = phi i64 [%60, %$28], [%62, %$29] ; # X
  %65 = phi i64 [%61, %$28], [%63, %$29] ; # Y
  %66 = phi i64 [0, %$28], [%62, %$29] ; # ->
  br label %$24
$23:
  %67 = phi i64 [%46, %$22] ; # X
  %68 = phi i64 [%47, %$22] ; # Y
; # (? (or (not (symb? (++ Y))) (nil? @) (t? @)) 0)
; # (or (not (symb? (++ Y))) (nil? @) (t? @))
; # (++ Y)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
  %71 = getelementptr i64, i64* %69, i32 1
  %72 = load i64, i64* %71
; # (symb? (++ Y))
  %73 = xor i64 %70, 8
  %74 = and i64 %73, 14
  %75 = icmp eq i64 %74, 0
; # (not (symb? (++ Y)))
  %76 = icmp eq i1 %75, 0
  br i1 %76, label %$31, label %$32
$32:
  %77 = phi i64 [%67, %$23] ; # X
  %78 = phi i64 [%72, %$23] ; # Y
; # (nil? @)
  %79 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %79, label %$31, label %$33
$33:
  %80 = phi i64 [%77, %$32] ; # X
  %81 = phi i64 [%78, %$32] ; # Y
; # (t? @)
  %82 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br label %$31
$31:
  %83 = phi i64 [%67, %$23], [%77, %$32], [%80, %$33] ; # X
  %84 = phi i64 [%72, %$23], [%78, %$32], [%81, %$33] ; # Y
  %85 = phi i1 [1, %$23], [1, %$32], [%82, %$33] ; # ->
  br i1 %85, label %$35, label %$34
$35:
  %86 = phi i64 [%83, %$31] ; # X
  %87 = phi i64 [%84, %$31] ; # Y
  br label %$24
$34:
  %88 = phi i64 [%83, %$31] ; # X
  %89 = phi i64 [%84, %$31] ; # Y
  br label %$22
$24:
  %90 = phi i64 [%64, %$30], [%86, %$35] ; # X
  %91 = phi i64 [%65, %$30], [%87, %$35] ; # Y
  %92 = phi i64 [%66, %$30], [0, %$35] ; # ->
  br label %$15
$15:
  %93 = phi i64 [%29, %$17], [%36, %$19], [%42, %$21], [%90, %$24] ; # X
  %94 = phi i64 [%30, %$17], [%37, %$19], [%43, %$21], [%91, %$24] ; # Y
  %95 = phi i64 [0, %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$19], [0, %$21], [%92, %$24] ; # ->
  br label %$13
$12:
  %96 = phi i64 [%21, %$11] ; # X
  %97 = phi i64 [%22, %$11] ; # Y
; # (let Z (++ Y) (if (pair Z) (if (num? (car Z)) (? (pair Y) 0) (? (...
; # (++ Y)
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
  %100 = getelementptr i64, i64* %98, i32 1
  %101 = load i64, i64* %100
; # (if (pair Z) (if (num? (car Z)) (? (pair Y) 0) (? (or (nil? (car ...
; # (pair Z)
  %102 = and i64 %99, 15
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %$36, label %$37
$36:
  %104 = phi i64 [%96, %$12] ; # X
  %105 = phi i64 [%101, %$12] ; # Y
; # (if (num? (car Z)) (? (pair Y) 0) (? (or (nil? (car Z)) (== $T (c...
; # (car Z)
  %106 = inttoptr i64 %99 to i64*
  %107 = load i64, i64* %106
; # (num? (car Z))
  %108 = and i64 %107, 6
  %109 = icmp ne i64 %108, 0
  br i1 %109, label %$39, label %$40
$39:
  %110 = phi i64 [%104, %$36] ; # X
  %111 = phi i64 [%105, %$36] ; # Y
; # (? (pair Y) 0)
; # (pair Y)
  %112 = and i64 %111, 15
  %113 = icmp eq i64 %112, 0
  br i1 %113, label %$43, label %$42
$43:
  %114 = phi i64 [%110, %$39] ; # X
  %115 = phi i64 [%111, %$39] ; # Y
  br label %$13
$42:
  %116 = phi i64 [%110, %$39] ; # X
  %117 = phi i64 [%111, %$39] ; # Y
  br label %$41
$40:
  %118 = phi i64 [%104, %$36] ; # X
  %119 = phi i64 [%105, %$36] ; # Y
; # (? (or (nil? (car Z)) (== $T (car Z))) 0)
; # (or (nil? (car Z)) (== $T (car Z)))
; # (car Z)
  %120 = inttoptr i64 %99 to i64*
  %121 = load i64, i64* %120
; # (nil? (car Z))
  %122 = icmp eq i64 %121, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %122, label %$44, label %$45
$45:
  %123 = phi i64 [%118, %$40] ; # X
  %124 = phi i64 [%119, %$40] ; # Y
; # (car Z)
  %125 = inttoptr i64 %99 to i64*
  %126 = load i64, i64* %125
; # (== $T (car Z))
  %127 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %126
  br label %$44
$44:
  %128 = phi i64 [%118, %$40], [%123, %$45] ; # X
  %129 = phi i64 [%119, %$40], [%124, %$45] ; # Y
  %130 = phi i1 [1, %$40], [%127, %$45] ; # ->
  br i1 %130, label %$47, label %$46
$47:
  %131 = phi i64 [%128, %$44] ; # X
  %132 = phi i64 [%129, %$44] ; # Y
  br label %$13
$46:
  %133 = phi i64 [%128, %$44] ; # X
  %134 = phi i64 [%129, %$44] ; # Y
  br label %$41
$41:
  %135 = phi i64 [%116, %$42], [%133, %$46] ; # X
  %136 = phi i64 [%117, %$42], [%134, %$46] ; # Y
  br label %$38
$37:
  %137 = phi i64 [%96, %$12] ; # X
  %138 = phi i64 [%101, %$12] ; # Y
; # (? (not (nil? Y)) 0)
; # (nil? Y)
  %139 = icmp eq i64 %138, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %140 = icmp eq i1 %139, 0
  br i1 %140, label %$49, label %$48
$49:
  %141 = phi i64 [%137, %$37] ; # X
  %142 = phi i64 [%138, %$37] ; # Y
  br label %$13
$48:
  %143 = phi i64 [%137, %$37] ; # X
  %144 = phi i64 [%138, %$37] ; # Y
  br label %$38
$38:
  %145 = phi i64 [%135, %$41], [%143, %$48] ; # X
  %146 = phi i64 [%136, %$41], [%144, %$48] ; # Y
  br label %$11
$13:
  %147 = phi i64 [%93, %$15], [%114, %$43], [%131, %$47], [%141, %$49] ; # X
  %148 = phi i64 [%94, %$15], [%115, %$43], [%132, %$47], [%142, %$49] ; # Y
  %149 = phi i64 [%95, %$15], [0, %$43], [0, %$47], [0, %$49] ; # ->
  br label %$2
$2:
  %150 = phi i64 [%3, %$4], [%12, %$8], [%16, %$10], [%147, %$13] ; # X
  %151 = phi i64 [%3, %$4], [0, %$8], [0, %$10], [%149, %$13] ; # ->
  ret i64 %151
}

define i64 @_raw(i64) {
$1:
; # (let X (cdr Exe) (cond ((atom X) (if (val Termio) $T $Nil)) ((nil...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (if (val Termio) $T $Nil)) ((nil? (eval (car X)))...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
; # (if (val Termio) $T $Nil)
; # (val Termio)
  %6 = load i8*, i8** @Termio
  %7 = icmp ne i8* %6, null
  br i1 %7, label %$5, label %$6
$5:
  br label %$7
$6:
  br label %$7
$7:
  %8 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$5], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$6] ; # ->
  br label %$2
$3:
; # (car X)
  %9 = inttoptr i64 %3 to i64*
  %10 = load i64, i64* %9
; # (eval (car X))
  %11 = and i64 %10, 6
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$10, label %$9
$10:
  br label %$8
$9:
  %13 = and i64 %10, 8
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$12, label %$11
$12:
  %15 = inttoptr i64 %10 to i64*
  %16 = load i64, i64* %15
  br label %$8
$11:
  %17 = call i64 @evList(i64 %10)
  br label %$8
$8:
  %18 = phi i64 [%10, %$10], [%16, %$12], [%17, %$11] ; # ->
; # (nil? (eval (car X)))
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %19, label %$14, label %$13
$14:
; # (setCooked)
  call void @setCooked()
  br label %$2
$13:
; # (setRaw)
  call void @setRaw()
  br label %$2
$2:
  %20 = phi i64 [%8, %$7], [%18, %$14], [%18, %$13] ; # ->
  ret i64 %20
}

define i64 @_alarm(i64) {
$1:
; # (let X (cdr Exe) (prog1 (cnt (i64 (alarm (i32 (evCnt Exe X))))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog1 (cnt (i64 (alarm (i32 (evCnt Exe X))))) (set $Alarm (cdr X...
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (i32 (evCnt Exe X))
  %5 = trunc i64 %4 to i32
; # (alarm (i32 (evCnt Exe X)))
  %6 = call i32 @alarm(i32 %5)
; # (i64 (alarm (i32 (evCnt Exe X))))
  %7 = sext i32 %6 to i64
; # (cnt (i64 (alarm (i32 (evCnt Exe X)))))
  %8 = shl i64 %7, 4
  %9 = or i64 %8, 2
; # (set $Alarm (cdr X))
; # (cdr X)
  %10 = inttoptr i64 %3 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 16) to i64) to i64*
  store i64 %12, i64* %13
  ret i64 %9
}

define i64 @_sigio(i64) {
$1:
; # (let (X (cdr Exe) Fd (evCnt Exe X)) (set $Sigio (cdr X)) (fcntlSe...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (set $Sigio (cdr X))
; # (cdr X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 24) to i64) to i64*
  store i64 %7, i64* %8
; # (i32 Fd)
  %9 = trunc i64 %4 to i32
; # (val $Pid)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 344) to i64) to i64*
  %11 = load i64, i64* %10
; # (int (val $Pid))
  %12 = lshr i64 %11, 4
; # (i32 (int (val $Pid)))
  %13 = trunc i64 %12 to i32
; # (fcntlSetOwn (i32 Fd) (i32 (int (val $Pid))))
  call void @fcntlSetOwn(i32 %9, i32 %13)
; # (cnt Fd)
  %14 = shl i64 %4, 4
  %15 = or i64 %14, 2
  ret i64 %15
}

define i64 @_kids(i64) {
$1:
; # (let (X $Nil Cld (val $Child) <Cld (ofs Cld (* (val $Children) (c...
; # (val $Child)
  %1 = load i8*, i8** @$Child
; # (val $Children)
  %2 = load i64, i64* @$Children
; # (* (val $Children) (child T))
  %3 = mul i64 %2, 36
; # (ofs Cld (* (val $Children) (child T)))
  %4 = getelementptr i8, i8* %1, i64 %3
; # (until (== Cld <Cld) (when ((child Cld) pid) (setq X (cons (cnt (...
  br label %$2
$2:
  %5 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%20, %$6] ; # X
  %6 = phi i8* [%1, %$1], [%22, %$6] ; # Cld
; # (== Cld <Cld)
  %7 = icmp eq i8* %6, %4
  br i1 %7, label %$4, label %$3
$3:
  %8 = phi i64 [%5, %$2] ; # X
  %9 = phi i8* [%6, %$2] ; # Cld
; # (when ((child Cld) pid) (setq X (cons (cnt (i64 @)) X)))
; # ((child Cld) pid)
  %10 = getelementptr i8, i8* %9, i32 24
  %11 = bitcast i8* %10 to i32*
  %12 = load i32, i32* %11
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %$5, label %$6
$5:
  %14 = phi i64 [%8, %$3] ; # X
  %15 = phi i8* [%9, %$3] ; # Cld
; # (i64 @)
  %16 = sext i32 %12 to i64
; # (cnt (i64 @))
  %17 = shl i64 %16, 4
  %18 = or i64 %17, 2
; # (cons (cnt (i64 @)) X)
  %19 = call i64 @cons(i64 %18, i64 %14)
  br label %$6
$6:
  %20 = phi i64 [%8, %$3], [%19, %$5] ; # X
  %21 = phi i8* [%9, %$3], [%15, %$5] ; # Cld
; # (ofs Cld (child T))
  %22 = getelementptr i8, i8* %21, i32 36
  br label %$2
$4:
  %23 = phi i64 [%5, %$2] ; # X
  %24 = phi i8* [%6, %$2] ; # Cld
  ret i64 %23
}

define i64 @_protect(i64) {
$1:
; # (let X (cdr Exe) (prog2 (set $Protect (+ (val $Protect) 1)) (run ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog2 (set $Protect (+ (val $Protect) 1)) (run X) (set $Protect ...
; # (set $Protect (+ (val $Protect) 1))
; # (val $Protect)
  %4 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (+ (val $Protect) 1)
  %5 = add i32 %4, 1
  store i32 %5, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (run X)
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%28, %$11] ; # Prg
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
  %9 = getelementptr i64, i64* %7, i32 1
  %10 = load i64, i64* %9
  %11 = and i64 %10, 15
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$5, label %$3
$5:
  %13 = phi i64 [%10, %$2] ; # Prg
  %14 = and i64 %8, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$7
$8:
  br label %$6
$7:
  %16 = and i64 %8, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$10, label %$9
$10:
  %18 = inttoptr i64 %8 to i64*
  %19 = load i64, i64* %18
  br label %$6
$9:
  %20 = call i64 @evList(i64 %8)
  br label %$6
$6:
  %21 = phi i64 [%8, %$8], [%19, %$10], [%20, %$9] ; # ->
  br label %$4
$3:
  %22 = phi i64 [%10, %$2] ; # Prg
  %23 = and i64 %8, 15
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%22, %$3] ; # Prg
  %26 = call i64 @evList(i64 %8)
  %27 = icmp ne i64 %26, 0
  br label %$11
$11:
  %28 = phi i64 [%22, %$3], [%25, %$12] ; # Prg
  %29 = phi i1 [0, %$3], [%27, %$12] ; # ->
  br label %$2
$4:
  %30 = phi i64 [%13, %$6] ; # Prg
  %31 = phi i64 [%21, %$6] ; # ->
; # (set $Protect (- (val $Protect) 1))
; # (val $Protect)
  %32 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (- (val $Protect) 1)
  %33 = sub i32 %32, 1
  store i32 %33, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  ret i64 %31
}

define i64 @_heap(i64) {
$1:
; # (if (nil? (eval (cadr Exe))) (let (N 1 P (val $Heaps)) (while (se...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
; # (let (N 1 P (val $Heaps)) (while (setq P (val (ofs P HEAP))) (inc...
; # (val $Heaps)
  %15 = load i64, i64* @$Heaps
; # (while (setq P (val (ofs P HEAP))) (inc 'N))
  br label %$10
$10:
  %16 = phi i64 [1, %$7], [%24, %$11] ; # N
  %17 = phi i64 [%15, %$7], [%23, %$11] ; # P
; # (ofs P HEAP)
  %18 = add i64 %17, 1048576
; # (val (ofs P HEAP))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$12
$11:
  %22 = phi i64 [%16, %$10] ; # N
  %23 = phi i64 [%20, %$10] ; # P
; # (inc 'N)
  %24 = add i64 %22, 1
  br label %$10
$12:
  %25 = phi i64 [%16, %$10] ; # N
  %26 = phi i64 [%20, %$10] ; # P
; # (cnt N)
  %27 = shl i64 %25, 4
  %28 = or i64 %27, 2
  br label %$9
$8:
; # (let (N 0 P (val $Avail)) (while P (inc 'N) (setq P (car P))) (cn...
; # (val $Avail)
  %29 = load i64, i64* @$Avail
; # (while P (inc 'N) (setq P (car P)))
  br label %$13
$13:
  %30 = phi i64 [0, %$8], [%35, %$14] ; # N
  %31 = phi i64 [%29, %$8], [%37, %$14] ; # P
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$14, label %$15
$14:
  %33 = phi i64 [%30, %$13] ; # N
  %34 = phi i64 [%31, %$13] ; # P
; # (inc 'N)
  %35 = add i64 %33, 1
; # (car P)
  %36 = inttoptr i64 %34 to i64*
  %37 = load i64, i64* %36
  br label %$13
$15:
  %38 = phi i64 [%30, %$13] ; # N
  %39 = phi i64 [%31, %$13] ; # P
; # (- 20 4)
; # (shr N (- 20 4))
  %40 = lshr i64 %38, 16
; # (cnt (shr N (- 20 4)))
  %41 = shl i64 %40, 4
  %42 = or i64 %41, 2
  br label %$9
$9:
  %43 = phi i64 [%28, %$12], [%42, %$15] ; # ->
  ret i64 %43
}

define i64 @_stack(i64) {
$1:
; # (let (X (cdr Exe) Crt (val $Coroutines)) (if (or (atom X) Crt) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $Coroutines)
  %4 = load i8*, i8** @$Coroutines
; # (if (or (atom X) Crt) (let R (cnt (shr (val $StkSize) 10)) (while...
; # (or (atom X) Crt)
; # (atom X)
  %5 = and i64 %3, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$2, label %$3
$3:
  %7 = phi i8* [%4, %$1] ; # Crt
  %8 = icmp ne i8* %7, null
  br label %$2
$2:
  %9 = phi i8* [%4, %$1], [%7, %$3] ; # Crt
  %10 = phi i1 [1, %$1], [%8, %$3] ; # ->
  br i1 %10, label %$4, label %$5
$4:
  %11 = phi i8* [%9, %$2] ; # Crt
; # (let R (cnt (shr (val $StkSize) 10)) (while Crt (let Crt: (corout...
; # (val $StkSize)
  %12 = load i64, i64* @$StkSize
; # (shr (val $StkSize) 10)
  %13 = lshr i64 %12, 10
; # (cnt (shr (val $StkSize) 10))
  %14 = shl i64 %13, 4
  %15 = or i64 %14, 2
; # (while Crt (let Crt: (coroutine Crt) (when (Crt: tag) (setq R (co...
  br label %$7
$7:
  %16 = phi i8* [%11, %$4], [%32, %$11] ; # Crt
  %17 = phi i64 [%15, %$4], [%29, %$11] ; # R
  %18 = icmp ne i8* %16, null
  br i1 %18, label %$8, label %$9
$8:
  %19 = phi i8* [%16, %$7] ; # Crt
  %20 = phi i64 [%17, %$7] ; # R
; # (let Crt: (coroutine Crt) (when (Crt: tag) (setq R (cons @ R))) (...
; # (when (Crt: tag) (setq R (cons @ R)))
; # (Crt: tag)
  %21 = ptrtoint i8* %19 to i64
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$10, label %$11
$10:
  %25 = phi i8* [%19, %$8] ; # Crt
  %26 = phi i64 [%20, %$8] ; # R
; # (cons @ R)
  %27 = call i64 @cons(i64 %23, i64 %26)
  br label %$11
$11:
  %28 = phi i8* [%19, %$8], [%25, %$10] ; # Crt
  %29 = phi i64 [%20, %$8], [%27, %$10] ; # R
; # (Crt: next)
  %30 = getelementptr i8, i8* %19, i32 8
  %31 = bitcast i8* %30 to i8**
  %32 = load i8*, i8** %31
  br label %$7
$9:
  %33 = phi i8* [%16, %$7] ; # Crt
  %34 = phi i64 [%17, %$7] ; # R
  br label %$6
$5:
  %35 = phi i8* [%9, %$2] ; # Crt
  br label %$6
$6:
  %36 = phi i8* [%33, %$9], [%35, %$5] ; # Crt
  %37 = phi i64 [%34, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$5] ; # ->
  ret i64 %37
}

define i64 @tmDate(i64, i64, i64) {
$1:
; # (if (and (gt0 Y) (gt0 M) (>= 12 M) (gt0 D) (or (>= (i64 (val (ofs...
; # (and (gt0 Y) (gt0 M) (>= 12 M) (gt0 D) (or (>= (i64 (val (ofs $Mo...
; # (gt0 Y)
  %3 = icmp sgt i64 %0, 0
  br i1 %3, label %$3, label %$2
$3:
; # (gt0 M)
  %4 = icmp sgt i64 %1, 0
  br i1 %4, label %$4, label %$2
$4:
; # (>= 12 M)
  %5 = icmp uge i64 12, %1
  br i1 %5, label %$5, label %$2
$5:
; # (gt0 D)
  %6 = icmp sgt i64 %2, 0
  br i1 %6, label %$6, label %$2
$6:
; # (or (>= (i64 (val (ofs $Month M))) D) (and (== D 29) (== M 2) (=0...
; # (ofs $Month M)
  %7 = getelementptr i8, i8* bitcast ([13 x i8]* @$Month to i8*), i64 %1
; # (val (ofs $Month M))
  %8 = load i8, i8* %7
; # (i64 (val (ofs $Month M)))
  %9 = zext i8 %8 to i64
; # (>= (i64 (val (ofs $Month M))) D)
  %10 = icmp uge i64 %9, %2
  br i1 %10, label %$7, label %$8
$8:
; # (and (== D 29) (== M 2) (=0 (% Y 4)) (or (% Y 100) (=0 (% Y 400))...
; # (== D 29)
  %11 = icmp eq i64 %2, 29
  br i1 %11, label %$10, label %$9
$10:
; # (== M 2)
  %12 = icmp eq i64 %1, 2
  br i1 %12, label %$11, label %$9
$11:
; # (% Y 4)
  %13 = urem i64 %0, 4
; # (=0 (% Y 4))
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %$12, label %$9
$12:
; # (or (% Y 100) (=0 (% Y 400)))
; # (% Y 100)
  %15 = urem i64 %0, 100
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$13, label %$14
$14:
; # (% Y 400)
  %17 = urem i64 %0, 400
; # (=0 (% Y 400))
  %18 = icmp eq i64 %17, 0
  br label %$13
$13:
  %19 = phi i1 [1, %$12], [%18, %$14] ; # ->
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [0, %$10], [0, %$11], [%19, %$13] ; # ->
  br label %$7
$7:
  %21 = phi i1 [1, %$6], [%20, %$9] ; # ->
  br label %$2
$2:
  %22 = phi i1 [0, %$1], [0, %$3], [0, %$4], [0, %$5], [%21, %$7] ; # ->
  br i1 %22, label %$15, label %$16
$15:
; # (let N (/ (+ (* Y 12) M -3) 12) (cnt (- (+ (/ (+ (* Y 4404) (* M ...
; # (* Y 12)
  %23 = mul i64 %0, 12
; # (+ (* Y 12) M -3)
  %24 = add i64 %23, %1
  %25 = add i64 %24, -3
; # (/ (+ (* Y 12) M -3) 12)
  %26 = udiv i64 %25, 12
; # (* Y 4404)
  %27 = mul i64 %0, 4404
; # (* M 367)
  %28 = mul i64 %1, 367
; # (+ (* Y 4404) (* M 367) -1094)
  %29 = add i64 %27, %28
  %30 = add i64 %29, -1094
; # (/ (+ (* Y 4404) (* M 367) -1094) 12)
  %31 = udiv i64 %30, 12
; # (/ N 4)
  %32 = udiv i64 %26, 4
; # (/ N 400)
  %33 = udiv i64 %26, 400
; # (+ (/ (+ (* Y 4404) (* M 367) -1094) 12) (/ N 4) (/ N 400) D)
  %34 = add i64 %31, %32
  %35 = add i64 %34, %33
  %36 = add i64 %35, %2
; # (* 2 N)
  %37 = mul i64 2, %26
; # (/ N 100)
  %38 = udiv i64 %26, 100
; # (- (+ (/ (+ (* Y 4404) (* M 367) -1094) 12) (/ N 4) (/ N 400) D) ...
  %39 = sub i64 %36, %37
  %40 = sub i64 %39, %38
; # (cnt (- (+ (/ (+ (* Y 4404) (* M 367) -1094) 12) (/ N 4) (/ N 400...
  %41 = shl i64 %40, 4
  %42 = or i64 %41, 2
  br label %$17
$16:
  br label %$17
$17:
  %43 = phi i64 [%42, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$16] ; # ->
  ret i64 %43
}

define i64 @tmTime(i64, i64, i64) {
$1:
; # (if (and (ge0 H) (ge0 M) (> 60 M) (ge0 S) (> 60 S)) (cnt (+ (* H ...
; # (and (ge0 H) (ge0 M) (> 60 M) (ge0 S) (> 60 S))
; # (ge0 H)
  %3 = icmp sge i64 %0, 0
  br i1 %3, label %$3, label %$2
$3:
; # (ge0 M)
  %4 = icmp sge i64 %1, 0
  br i1 %4, label %$4, label %$2
$4:
; # (> 60 M)
  %5 = icmp ugt i64 60, %1
  br i1 %5, label %$5, label %$2
$5:
; # (ge0 S)
  %6 = icmp sge i64 %2, 0
  br i1 %6, label %$6, label %$2
$6:
; # (> 60 S)
  %7 = icmp ugt i64 60, %2
  br label %$2
$2:
  %8 = phi i1 [0, %$1], [0, %$3], [0, %$4], [0, %$5], [%7, %$6] ; # ->
  br i1 %8, label %$7, label %$8
$7:
; # (* H 3600)
  %9 = mul i64 %0, 3600
; # (* M 60)
  %10 = mul i64 %1, 60
; # (+ (* H 3600) (* M 60) S)
  %11 = add i64 %9, %10
  %12 = add i64 %11, %2
; # (cnt (+ (* H 3600) (* M 60) S))
  %13 = shl i64 %12, 4
  %14 = or i64 %13, 2
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_date(i64) {
$1:
; # (let X (cdr Exe) (cond ((atom X) (let N (getDate) (tmDate (& N (h...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (let N (getDate) (tmDate (& N (hex "FFFF")) (& (s...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
  %6 = phi i64 [%3, %$1] ; # X
; # (let N (getDate) (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex "F...
; # (getDate)
  %7 = call i64 @getDate()
; # (& N (hex "FFFF"))
  %8 = and i64 %7, 65535
; # (shr N 16)
  %9 = lshr i64 %7, 16
; # (& (shr N 16) (hex "FF"))
  %10 = and i64 %9, 255
; # (shr N 24)
  %11 = lshr i64 %7, 24
; # (& (shr N 24) (hex "FF"))
  %12 = and i64 %11, 255
; # (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex "FF")) (& (shr N 24...
  %13 = call i64 @tmDate(i64 %8, i64 %10, i64 %12)
  br label %$2
$3:
  %14 = phi i64 [%3, %$1] ; # X
; # (car X)
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
; # (eval (car X))
  %17 = and i64 %16, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$7, label %$6
$7:
  br label %$5
$6:
  %19 = and i64 %16, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$9, label %$8
$9:
  %21 = inttoptr i64 %16 to i64*
  %22 = load i64, i64* %21
  br label %$5
$8:
  %23 = call i64 @evList(i64 %16)
  br label %$5
$5:
  %24 = phi i64 [%16, %$7], [%22, %$9], [%23, %$8] ; # ->
; # (t? (eval (car X)))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %25, label %$11, label %$10
$11:
  %26 = phi i64 [%14, %$5] ; # X
; # (let N (getGmDate) (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex ...
; # (getGmDate)
  %27 = call i64 @getGmDate()
; # (& N (hex "FFFF"))
  %28 = and i64 %27, 65535
; # (shr N 16)
  %29 = lshr i64 %27, 16
; # (& (shr N 16) (hex "FF"))
  %30 = and i64 %29, 255
; # (shr N 24)
  %31 = lshr i64 %27, 24
; # (& (shr N 24) (hex "FF"))
  %32 = and i64 %31, 255
; # (tmDate (& N (hex "FFFF")) (& (shr N 16) (hex "FF")) (& (shr N 24...
  %33 = call i64 @tmDate(i64 %28, i64 %30, i64 %32)
  br label %$2
$10:
  %34 = phi i64 [%14, %$5] ; # X
; # (nil? @)
  %35 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %35, label %$13, label %$12
$13:
  %36 = phi i64 [%34, %$10] ; # X
  br label %$2
$12:
  %37 = phi i64 [%34, %$10] ; # X
; # (pair @)
  %38 = and i64 %24, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$15, label %$14
$15:
  %40 = phi i64 [%37, %$12] ; # X
; # (let L @ (tmDate (xCnt Exe (++ L)) (xCnt Exe (++ L)) (xCnt Exe (c...
; # (++ L)
  %41 = inttoptr i64 %24 to i64*
  %42 = load i64, i64* %41
  %43 = getelementptr i64, i64* %41, i32 1
  %44 = load i64, i64* %43
; # (xCnt Exe (++ L))
  %45 = call i64 @xCnt(i64 %0, i64 %42)
; # (++ L)
  %46 = inttoptr i64 %44 to i64*
  %47 = load i64, i64* %46
  %48 = getelementptr i64, i64* %46, i32 1
  %49 = load i64, i64* %48
; # (xCnt Exe (++ L))
  %50 = call i64 @xCnt(i64 %0, i64 %47)
; # (car L)
  %51 = inttoptr i64 %49 to i64*
  %52 = load i64, i64* %51
; # (xCnt Exe (car L))
  %53 = call i64 @xCnt(i64 %0, i64 %52)
; # (tmDate (xCnt Exe (++ L)) (xCnt Exe (++ L)) (xCnt Exe (car L)))
  %54 = call i64 @tmDate(i64 %45, i64 %50, i64 %53)
  br label %$2
$14:
  %55 = phi i64 [%37, %$12] ; # X
; # (let N @ (cond ((pair (shift X)) (tmDate (xCnt Exe N) (evCnt Exe ...
; # (cond ((pair (shift X)) (tmDate (xCnt Exe N) (evCnt Exe X) (evCnt...
; # (shift X)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (pair (shift X))
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$18, label %$17
$18:
  %61 = phi i64 [%58, %$14] ; # X
  %62 = phi i64 [%24, %$14] ; # N
; # (xCnt Exe N)
  %63 = call i64 @xCnt(i64 %0, i64 %62)
; # (evCnt Exe X)
  %64 = call i64 @evCnt(i64 %0, i64 %61)
; # (cdr X)
  %65 = inttoptr i64 %61 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (evCnt Exe (cdr X))
  %68 = call i64 @evCnt(i64 %0, i64 %67)
; # (tmDate (xCnt Exe N) (evCnt Exe X) (evCnt Exe (cdr X)))
  %69 = call i64 @tmDate(i64 %63, i64 %64, i64 %68)
  br label %$16
$17:
  %70 = phi i64 [%58, %$14] ; # X
  %71 = phi i64 [%24, %$14] ; # N
; # (xCnt Exe N)
  %72 = call i64 @xCnt(i64 %0, i64 %71)
; # (lt0 (setq N (xCnt Exe N)))
  %73 = icmp slt i64 %72, 0
  br i1 %73, label %$20, label %$19
$20:
  %74 = phi i64 [%70, %$17] ; # X
  %75 = phi i64 [%72, %$17] ; # N
  br label %$16
$19:
  %76 = phi i64 [%70, %$17] ; # X
  %77 = phi i64 [%72, %$17] ; # N
; # (let Y (/ (- (* N 100) 20) 3652425) (setq N (+ N (- Y (/ Y 4))) Y...
; # (* N 100)
  %78 = mul i64 %77, 100
; # (- (* N 100) 20)
  %79 = sub i64 %78, 20
; # (/ (- (* N 100) 20) 3652425)
  %80 = udiv i64 %79, 3652425
; # (/ Y 4)
  %81 = udiv i64 %80, 4
; # (- Y (/ Y 4))
  %82 = sub i64 %80, %81
; # (+ N (- Y (/ Y 4)))
  %83 = add i64 %77, %82
; # (* N 100)
  %84 = mul i64 %83, 100
; # (- (* N 100) 20)
  %85 = sub i64 %84, 20
; # (/ (- (* N 100) 20) 36525)
  %86 = udiv i64 %85, 36525
; # (* Y 36525)
  %87 = mul i64 %86, 36525
; # (/ (* Y 36525) 100)
  %88 = udiv i64 %87, 100
; # (- N (/ (* Y 36525) 100))
  %89 = sub i64 %83, %88
; # (* (- N (/ (* Y 36525) 100)) 10)
  %90 = mul i64 %89, 10
; # (let (M (/ (- N 5) 306) D (/ (+ N (* M -306) 5) 10)) (if (> 10 M)...
; # (- N 5)
  %91 = sub i64 %90, 5
; # (/ (- N 5) 306)
  %92 = udiv i64 %91, 306
; # (* M -306)
  %93 = mul i64 %92, -306
; # (+ N (* M -306) 5)
  %94 = add i64 %90, %93
  %95 = add i64 %94, 5
; # (/ (+ N (* M -306) 5) 10)
  %96 = udiv i64 %95, 10
; # (if (> 10 M) (inc 'M 3) (inc 'Y) (dec 'M 9))
; # (> 10 M)
  %97 = icmp ugt i64 10, %92
  br i1 %97, label %$21, label %$22
$21:
  %98 = phi i64 [%76, %$19] ; # X
  %99 = phi i64 [%90, %$19] ; # N
  %100 = phi i64 [%86, %$19] ; # Y
  %101 = phi i64 [%92, %$19] ; # M
; # (inc 'M 3)
  %102 = add i64 %101, 3
  br label %$23
$22:
  %103 = phi i64 [%76, %$19] ; # X
  %104 = phi i64 [%90, %$19] ; # N
  %105 = phi i64 [%86, %$19] ; # Y
  %106 = phi i64 [%92, %$19] ; # M
; # (inc 'Y)
  %107 = add i64 %105, 1
; # (dec 'M 9)
  %108 = sub i64 %106, 9
  br label %$23
$23:
  %109 = phi i64 [%98, %$21], [%103, %$22] ; # X
  %110 = phi i64 [%99, %$21], [%104, %$22] ; # N
  %111 = phi i64 [%100, %$21], [%107, %$22] ; # Y
  %112 = phi i64 [%102, %$21], [%108, %$22] ; # M
  %113 = phi i64 [%102, %$21], [%108, %$22] ; # ->
; # (cnt Y)
  %114 = shl i64 %111, 4
  %115 = or i64 %114, 2
; # (cnt M)
  %116 = shl i64 %112, 4
  %117 = or i64 %116, 2
; # (cnt D)
  %118 = shl i64 %96, 4
  %119 = or i64 %118, 2
; # (cons (cnt D) $Nil)
  %120 = call i64 @cons(i64 %119, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cnt M) (cons (cnt D) $Nil))
  %121 = call i64 @cons(i64 %117, i64 %120)
; # (cons (cnt Y) (cons (cnt M) (cons (cnt D) $Nil)))
  %122 = call i64 @cons(i64 %115, i64 %121)
  br label %$16
$16:
  %123 = phi i64 [%61, %$18], [%74, %$20], [%109, %$23] ; # X
  %124 = phi i64 [%62, %$18], [%75, %$20], [%110, %$23] ; # N
  %125 = phi i64 [%69, %$18], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$20], [%122, %$23] ; # ->
  br label %$2
$2:
  %126 = phi i64 [%6, %$4], [%26, %$11], [%36, %$13], [%40, %$15], [%123, %$16] ; # X
  %127 = phi i64 [%13, %$4], [%33, %$11], [%24, %$13], [%54, %$15], [%125, %$16] ; # ->
  ret i64 %127
}

define i64 @_time(i64) {
$1:
; # (let X (cdr Exe) (cond ((atom X) (cnt (getTime))) ((t? (eval (car...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (cnt (getTime))) ((t? (eval (car X))) (if (lt0 (g...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
  %6 = phi i64 [%3, %$1] ; # X
; # (getTime)
  %7 = call i64 @getTime()
; # (cnt (getTime))
  %8 = shl i64 %7, 4
  %9 = or i64 %8, 2
  br label %$2
$3:
  %10 = phi i64 [%3, %$1] ; # X
; # (car X)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  br label %$5
$6:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$5
$8:
  %19 = call i64 @evList(i64 %12)
  br label %$5
$5:
  %20 = phi i64 [%12, %$7], [%18, %$9], [%19, %$8] ; # ->
; # (t? (eval (car X)))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %21, label %$11, label %$10
$11:
  %22 = phi i64 [%10, %$5] ; # X
; # (if (lt0 (getGmTime)) $Nil (cnt @))
; # (getGmTime)
  %23 = call i64 @getGmTime()
; # (lt0 (getGmTime))
  %24 = icmp slt i64 %23, 0
  br i1 %24, label %$12, label %$13
$12:
  %25 = phi i64 [%22, %$11] ; # X
  br label %$14
$13:
  %26 = phi i64 [%22, %$11] ; # X
; # (cnt @)
  %27 = shl i64 %23, 4
  %28 = or i64 %27, 2
  br label %$14
$14:
  %29 = phi i64 [%25, %$12], [%26, %$13] ; # X
  %30 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%28, %$13] ; # ->
  br label %$2
$10:
  %31 = phi i64 [%10, %$5] ; # X
; # (nil? @)
  %32 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %32, label %$16, label %$15
$16:
  %33 = phi i64 [%31, %$10] ; # X
  br label %$2
$15:
  %34 = phi i64 [%31, %$10] ; # X
; # (pair @)
  %35 = and i64 %20, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$18, label %$17
$18:
  %37 = phi i64 [%34, %$15] ; # X
; # (let L @ (tmTime (xCnt Exe (++ L)) (xCnt Exe (++ L)) (if (pair L)...
; # (++ L)
  %38 = inttoptr i64 %20 to i64*
  %39 = load i64, i64* %38
  %40 = getelementptr i64, i64* %38, i32 1
  %41 = load i64, i64* %40
; # (xCnt Exe (++ L))
  %42 = call i64 @xCnt(i64 %0, i64 %39)
; # (++ L)
  %43 = inttoptr i64 %41 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (xCnt Exe (++ L))
  %47 = call i64 @xCnt(i64 %0, i64 %44)
; # (if (pair L) (xCnt Exe (car L)) 0)
; # (pair L)
  %48 = and i64 %46, 15
  %49 = icmp eq i64 %48, 0
  br i1 %49, label %$19, label %$20
$19:
  %50 = phi i64 [%37, %$18] ; # X
  %51 = phi i64 [%46, %$18] ; # L
; # (car L)
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
; # (xCnt Exe (car L))
  %54 = call i64 @xCnt(i64 %0, i64 %53)
  br label %$21
$20:
  %55 = phi i64 [%37, %$18] ; # X
  %56 = phi i64 [%46, %$18] ; # L
  br label %$21
$21:
  %57 = phi i64 [%50, %$19], [%55, %$20] ; # X
  %58 = phi i64 [%51, %$19], [%56, %$20] ; # L
  %59 = phi i64 [%54, %$19], [0, %$20] ; # ->
; # (tmTime (xCnt Exe (++ L)) (xCnt Exe (++ L)) (if (pair L) (xCnt Ex...
  %60 = call i64 @tmTime(i64 %42, i64 %47, i64 %59)
  br label %$2
$17:
  %61 = phi i64 [%34, %$15] ; # X
; # (let N @ (cond ((pair (shift X)) (tmTime (xCnt Exe N) (evCnt Exe ...
; # (cond ((pair (shift X)) (tmTime (xCnt Exe N) (evCnt Exe X) (if (p...
; # (shift X)
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (pair (shift X))
  %65 = and i64 %64, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$24, label %$23
$24:
  %67 = phi i64 [%64, %$17] ; # X
  %68 = phi i64 [%20, %$17] ; # N
; # (xCnt Exe N)
  %69 = call i64 @xCnt(i64 %0, i64 %68)
; # (evCnt Exe X)
  %70 = call i64 @evCnt(i64 %0, i64 %67)
; # (if (pair (shift X)) (evCnt Exe X) 0)
; # (shift X)
  %71 = inttoptr i64 %67 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
; # (pair (shift X))
  %74 = and i64 %73, 15
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$25, label %$26
$25:
  %76 = phi i64 [%73, %$24] ; # X
  %77 = phi i64 [%68, %$24] ; # N
; # (evCnt Exe X)
  %78 = call i64 @evCnt(i64 %0, i64 %76)
  br label %$27
$26:
  %79 = phi i64 [%73, %$24] ; # X
  %80 = phi i64 [%68, %$24] ; # N
  br label %$27
$27:
  %81 = phi i64 [%76, %$25], [%79, %$26] ; # X
  %82 = phi i64 [%77, %$25], [%80, %$26] ; # N
  %83 = phi i64 [%78, %$25], [0, %$26] ; # ->
; # (tmTime (xCnt Exe N) (evCnt Exe X) (if (pair (shift X)) (evCnt Ex...
  %84 = call i64 @tmTime(i64 %69, i64 %70, i64 %83)
  br label %$22
$23:
  %85 = phi i64 [%64, %$17] ; # X
  %86 = phi i64 [%20, %$17] ; # N
; # (xCnt Exe N)
  %87 = call i64 @xCnt(i64 %0, i64 %86)
; # (lt0 (setq N (xCnt Exe N)))
  %88 = icmp slt i64 %87, 0
  br i1 %88, label %$29, label %$28
$29:
  %89 = phi i64 [%85, %$23] ; # X
  %90 = phi i64 [%87, %$23] ; # N
  br label %$22
$28:
  %91 = phi i64 [%85, %$23] ; # X
  %92 = phi i64 [%87, %$23] ; # N
; # (/ N 3600)
  %93 = udiv i64 %92, 3600
; # (cnt (/ N 3600))
  %94 = shl i64 %93, 4
  %95 = or i64 %94, 2
; # (/ N 60)
  %96 = udiv i64 %92, 60
; # (% (/ N 60) 60)
  %97 = urem i64 %96, 60
; # (cnt (% (/ N 60) 60))
  %98 = shl i64 %97, 4
  %99 = or i64 %98, 2
; # (% N 60)
  %100 = urem i64 %92, 60
; # (cnt (% N 60))
  %101 = shl i64 %100, 4
  %102 = or i64 %101, 2
; # (cons (cnt (% N 60)) $Nil)
  %103 = call i64 @cons(i64 %102, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cnt (% (/ N 60) 60)) (cons (cnt (% N 60)) $Nil))
  %104 = call i64 @cons(i64 %99, i64 %103)
; # (cons (cnt (/ N 3600)) (cons (cnt (% (/ N 60) 60)) (cons (cnt (% ...
  %105 = call i64 @cons(i64 %95, i64 %104)
  br label %$22
$22:
  %106 = phi i64 [%81, %$27], [%89, %$29], [%91, %$28] ; # X
  %107 = phi i64 [%82, %$27], [%90, %$29], [%92, %$28] ; # N
  %108 = phi i64 [%84, %$27], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$29], [%105, %$28] ; # ->
  br label %$2
$2:
  %109 = phi i64 [%6, %$4], [%29, %$14], [%33, %$16], [%57, %$21], [%106, %$22] ; # X
  %110 = phi i64 [%9, %$4], [%30, %$14], [%20, %$16], [%60, %$21], [%108, %$22] ; # ->
  ret i64 %110
}

define i64 @_usec(i64) {
$1:
; # (if (nil? (eval (cadr Exe))) (- (getUsec YES) (val $USec)) (getUs...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
; # (getUsec YES)
  %15 = call i64 @getUsec(i1 1)
; # (val $USec)
  %16 = load i64, i64* @$USec
; # (- (getUsec YES) (val $USec))
  %17 = sub i64 %15, %16
  br label %$9
$8:
; # (getUsec NO)
  %18 = call i64 @getUsec(i1 0)
  br label %$9
$9:
  %19 = phi i64 [%17, %$7], [%18, %$8] ; # ->
; # (cnt (if (nil? (eval (cadr Exe))) (- (getUsec YES) (val $USec)) (...
  %20 = shl i64 %19, 4
  %21 = or i64 %20, 2
  ret i64 %21
}

define i1 @sharedLib(i64) {
$1:
; # (let (Nm (xName 0 Sym) S (bufString Nm (b8 (bufSize Nm))) P (strc...
; # (xName 0 Sym)
  %1 = call i64 @xName(i64 0, i64 %0)
; # (bufSize Nm)
  %2 = call i64 @bufSize(i64 %1)
; # (b8 (bufSize Nm))
  %3 = alloca i8, i64 %2
; # (bufString Nm (b8 (bufSize Nm)))
  %4 = call i8* @bufString(i64 %1, i8* %3)
; # (strchr S (char ":"))
  %5 = call i8* @strchr(i8* %4, i32 58)
; # (and P (<> P S) (val 2 P) (let N (val $HomeLen) (set P 0) (let (L...
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$3, label %$2
$3:
; # (<> P S)
  %7 = icmp ne i8* %5, %4
  br i1 %7, label %$4, label %$2
$4:
; # (val 2 P)
  %8 = getelementptr i8, i8* %5, i32 1
  %9 = load i8, i8* %8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %$5, label %$2
$5:
; # (let N (val $HomeLen) (set P 0) (let (Len (strlen S) Q (b8 (+ N L...
; # (val $HomeLen)
  %11 = load i64, i64* @$HomeLen
; # (set P 0)
  store i8 0, i8* %5
; # (let (Len (strlen S) Q (b8 (+ N Len (+ 4 3 1)))) (if (strchr S (c...
; # (strlen S)
  %12 = call i64 @strlen(i8* %4)
; # (+ 4 3 1)
; # (+ N Len (+ 4 3 1))
  %13 = add i64 %11, %12
  %14 = add i64 %13, 8
; # (b8 (+ N Len (+ 4 3 1)))
  %15 = alloca i8, i64 %14
; # (if (strchr S (char "/")) (strcpy Q S) (when N (memcpy Q (val $Ho...
; # (strchr S (char "/"))
  %16 = call i8* @strchr(i8* %4, i32 47)
  %17 = icmp ne i8* %16, null
  br i1 %17, label %$6, label %$7
$6:
  %18 = phi i64 [%12, %$5] ; # Len
; # (strcpy Q S)
  %19 = call i8* @strcpy(i8* %15, i8* %4)
  br label %$8
$7:
  %20 = phi i64 [%12, %$5] ; # Len
; # (when N (memcpy Q (val $Home) N))
  %21 = icmp ne i64 %11, 0
  br i1 %21, label %$9, label %$10
$9:
  %22 = phi i64 [%20, %$7] ; # Len
; # (val $Home)
  %23 = load i8*, i8** @$Home
; # (memcpy Q (val $Home) N)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %23, i64 %11, i1 0)
  br label %$10
$10:
  %24 = phi i64 [%20, %$7], [%22, %$9] ; # Len
; # (ofs Q N)
  %25 = getelementptr i8, i8* %15, i64 %11
; # (strcpy (ofs Q N) ($ "lib/"))
  %26 = call i8* @strcpy(i8* %25, i8* bitcast ([5 x i8]* @$23 to i8*))
; # (+ N 4)
  %27 = add i64 %11, 4
; # (ofs Q (+ N 4))
  %28 = getelementptr i8, i8* %15, i64 %27
; # (strcpy (ofs Q (+ N 4)) S)
  %29 = call i8* @strcpy(i8* %28, i8* %4)
; # (+ Len N 4)
  %30 = add i64 %24, %11
  %31 = add i64 %30, 4
  br label %$8
$8:
  %32 = phi i64 [%18, %$6], [%31, %$10] ; # Len
; # (ofs Q Len)
  %33 = getelementptr i8, i8* %15, i64 %32
; # (strcpy (ofs Q Len) ($ ".so"))
  %34 = call i8* @strcpy(i8* %33, i8* bitcast ([4 x i8]* @$24 to i8*))
; # (and (dlOpen Q) (dlsym @ (inc P)) (prog (set Sym (| (i64 @) 2)) Y...
; # (dlOpen Q)
  %35 = call i8* @dlOpen(i8* %15)
  %36 = icmp ne i8* %35, null
  br i1 %36, label %$12, label %$11
$12:
  %37 = phi i64 [%32, %$8] ; # Len
; # (inc P)
  %38 = getelementptr i8, i8* %5, i32 1
; # (dlsym @ (inc P))
  %39 = call i8* @dlsym(i8* %35, i8* %38)
  %40 = icmp ne i8* %39, null
  br i1 %40, label %$13, label %$11
$13:
  %41 = phi i64 [%37, %$12] ; # Len
; # (set Sym (| (i64 @) 2))
; # (i64 @)
  %42 = ptrtoint i8* %39 to i64
; # (| (i64 @) 2)
  %43 = or i64 %42, 2
  %44 = inttoptr i64 %0 to i64*
  store i64 %43, i64* %44
  br label %$11
$11:
  %45 = phi i64 [%32, %$8], [%37, %$12], [%41, %$13] ; # Len
  %46 = phi i1 [0, %$8], [0, %$12], [1, %$13] ; # ->
  br label %$2
$2:
  %47 = phi i1 [0, %$1], [0, %$3], [0, %$4], [%46, %$11] ; # ->
  ret i1 %47
}

define void @mark(i64) {
$1:
; # (let Tos 0 (loop (until (cnt? E) (let (P (any (& E -16)) Q (cdr P...
; # (loop (until (cnt? E) (let (P (any (& E -16)) Q (cdr P)) (? (=0 (...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%85, %$17] ; # E
  %2 = phi i64 [0, %$1], [%86, %$17] ; # Tos
; # (until (cnt? E) (let (P (any (& E -16)) Q (cdr P)) (? (=0 (& Q 1)...
  br label %$3
$3:
  %3 = phi i64 [%1, %$2], [%52, %$7] ; # E
  %4 = phi i64 [%2, %$2], [%48, %$7] ; # Tos
; # (cnt? E)
  %5 = and i64 %3, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$4
$4:
  %7 = phi i64 [%3, %$3] ; # E
  %8 = phi i64 [%4, %$3] ; # Tos
; # (let (P (any (& E -16)) Q (cdr P)) (? (=0 (& Q 1))) (set 2 P (set...
; # (& E -16)
  %9 = and i64 %7, -16
; # (any (& E -16))
; # (cdr P)
  %10 = inttoptr i64 %9 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
; # (? (=0 (& Q 1)))
; # (& Q 1)
  %13 = and i64 %12, 1
; # (=0 (& Q 1))
  %14 = icmp eq i64 %13, 0
  br i1 %14, label %$5, label %$6
$6:
  %15 = phi i64 [%7, %$4] ; # E
  %16 = phi i64 [%8, %$4] ; # Tos
  %17 = phi i64 [%12, %$4] ; # Q
; # (set 2 P (setq Q (& Q -2)))
; # (& Q -2)
  %18 = and i64 %17, -2
  %19 = inttoptr i64 %9 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
; # (? (big? E) (until (cnt? Q) (let N (val (big Q)) (? (=0 (& N 1)))...
; # (big? E)
  %21 = and i64 %15, 4
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$8, label %$7
$8:
  %23 = phi i64 [%15, %$6] ; # E
  %24 = phi i64 [%16, %$6] ; # Tos
  %25 = phi i64 [%18, %$6] ; # Q
; # (until (cnt? Q) (let N (val (big Q)) (? (=0 (& N 1))) (setq Q (se...
  br label %$9
$9:
  %26 = phi i64 [%23, %$8], [%39, %$12] ; # E
  %27 = phi i64 [%24, %$8], [%40, %$12] ; # Tos
  %28 = phi i64 [%25, %$8], [%43, %$12] ; # Q
; # (cnt? Q)
  %29 = and i64 %28, 2
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$11, label %$10
$10:
  %31 = phi i64 [%26, %$9] ; # E
  %32 = phi i64 [%27, %$9] ; # Tos
  %33 = phi i64 [%28, %$9] ; # Q
; # (let N (val (big Q)) (? (=0 (& N 1))) (setq Q (set (big Q) (& N -...
; # (big Q)
  %34 = add i64 %33, 4
; # (val (big Q))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (? (=0 (& N 1)))
; # (& N 1)
  %37 = and i64 %36, 1
; # (=0 (& N 1))
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$11, label %$12
$12:
  %39 = phi i64 [%31, %$10] ; # E
  %40 = phi i64 [%32, %$10] ; # Tos
  %41 = phi i64 [%33, %$10] ; # Q
; # (set (big Q) (& N -2))
; # (big Q)
  %42 = add i64 %41, 4
; # (& N -2)
  %43 = and i64 %36, -2
  %44 = inttoptr i64 %42 to i64*
  store i64 %43, i64* %44
  br label %$9
$11:
  %45 = phi i64 [%26, %$9], [%31, %$10] ; # E
  %46 = phi i64 [%27, %$9], [%32, %$10] ; # Tos
  %47 = phi i64 [%28, %$9], [%33, %$10] ; # Q
  br label %$5
$7:
  %48 = phi i64 [%15, %$6] ; # E
  %49 = phi i64 [%16, %$6] ; # Tos
  %50 = phi i64 [%18, %$6] ; # Q
; # (let X E (setq E (val P)) (set P (| Tos 1)) (setq Tos X))
; # (val P)
  %51 = inttoptr i64 %9 to i64*
  %52 = load i64, i64* %51
; # (set P (| Tos 1))
; # (| Tos 1)
  %53 = or i64 %49, 1
  %54 = inttoptr i64 %9 to i64*
  store i64 %53, i64* %54
  br label %$3
$5:
  %55 = phi i64 [%3, %$3], [%7, %$4], [%45, %$11] ; # E
  %56 = phi i64 [%4, %$3], [%8, %$4], [%46, %$11] ; # Tos
; # (loop (let P (any (& Tos -16)) (unless P (ret)) (let Q (val P) (?...
  br label %$13
$13:
  %57 = phi i64 [%55, %$5], [%79, %$16] ; # E
  %58 = phi i64 [%56, %$5], [%82, %$16] ; # Tos
; # (let P (any (& Tos -16)) (unless P (ret)) (let Q (val P) (? (& Q ...
; # (& Tos -16)
  %59 = and i64 %58, -16
; # (any (& Tos -16))
; # (unless P (ret))
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$15, label %$14
$14:
  %61 = phi i64 [%57, %$13] ; # E
  %62 = phi i64 [%58, %$13] ; # Tos
; # (ret)
  ret void
$15:
  %63 = phi i64 [%57, %$13] ; # E
  %64 = phi i64 [%58, %$13] ; # Tos
; # (let Q (val P) (? (& Q 1) (set P E) (setq E (cdr P)) (set 2 P (& ...
; # (val P)
  %65 = inttoptr i64 %59 to i64*
  %66 = load i64, i64* %65
; # (? (& Q 1) (set P E) (setq E (cdr P)) (set 2 P (& Q -2)))
; # (& Q 1)
  %67 = and i64 %66, 1
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$18, label %$16
$18:
  %69 = phi i64 [%63, %$15] ; # E
  %70 = phi i64 [%64, %$15] ; # Tos
; # (set P E)
  %71 = inttoptr i64 %59 to i64*
  store i64 %69, i64* %71
; # (cdr P)
  %72 = inttoptr i64 %59 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (set 2 P (& Q -2))
; # (& Q -2)
  %75 = and i64 %66, -2
  %76 = inttoptr i64 %59 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  store i64 %75, i64* %77
  br label %$17
$16:
  %78 = phi i64 [%63, %$15] ; # E
  %79 = phi i64 [%64, %$15] ; # Tos
; # (let X Tos (setq Tos (cdr P)) (set 2 P E) (setq E X))
; # (cdr P)
  %80 = inttoptr i64 %59 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
; # (set 2 P E)
  %83 = inttoptr i64 %59 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %78, i64* %84
  br label %$13
$17:
  %85 = phi i64 [%74, %$18] ; # E
  %86 = phi i64 [%70, %$18] ; # Tos
  %87 = phi i64 [%75, %$18] ; # ->
  br label %$2
}

define void @gc() {
$1:
; # (set $DB -ZERO)
  %0 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 136) to i64) to i64*
  store i64 10, i64* %0
; # (let P $Nil (set P (| (val P) 1)) (setq P (ofs P 4)) (loop (set P...
; # (set P (| (val P) 1))
; # (val P)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64) to i64*
  %2 = load i64, i64* %1
; # (| (val P) 1)
  %3 = or i64 %2, 1
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64) to i64*
  store i64 %3, i64* %4
; # (ofs P 4)
  %5 = add i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), 32
; # (loop (set P (| (val P) 1)) (? (== P $LastSym)) (setq P (ofs P 2)...
  br label %$2
$2:
  %6 = phi i64 [%5, %$1], [%13, %$3] ; # P
; # (set P (| (val P) 1))
; # (val P)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (| (val P) 1)
  %9 = or i64 %8, 1
  %10 = inttoptr i64 %6 to i64*
  store i64 %9, i64* %10
; # (? (== P $LastSym))
; # (== P $LastSym)
  %11 = icmp eq i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 6712) to i64)
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i64 [%6, %$2] ; # P
; # (ofs P 2)
  %13 = add i64 %12, 16
  br label %$2
$4:
  %14 = phi i64 [%6, %$2] ; # P
  %15 = phi i64 [0, %$2] ; # ->
; # (let P (val $Heaps) (loop (let C CELLS (loop (set 2 P (| (cdr P) ...
; # (val $Heaps)
  %16 = load i64, i64* @$Heaps
; # (loop (let C CELLS (loop (set 2 P (| (cdr P) 1)) (setq P (ofs P 2...
  br label %$5
$5:
  %17 = phi i64 [%16, %$4], [%37, %$9] ; # P
; # (let C CELLS (loop (set 2 P (| (cdr P) 1)) (setq P (ofs P 2)) (? ...
; # (loop (set 2 P (| (cdr P) 1)) (setq P (ofs P 2)) (? (=0 (dec 'C))...
  br label %$6
$6:
  %18 = phi i64 [%17, %$5], [%29, %$7] ; # P
  %19 = phi i64 [65536, %$5], [%30, %$7] ; # C
; # (set 2 P (| (cdr P) 1))
; # (cdr P)
  %20 = inttoptr i64 %18 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (| (cdr P) 1)
  %23 = or i64 %22, 1
  %24 = inttoptr i64 %18 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
; # (ofs P 2)
  %26 = add i64 %18, 16
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %27 = sub i64 %19, 1
; # (=0 (dec 'C))
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$7
$7:
  %29 = phi i64 [%26, %$6] ; # P
  %30 = phi i64 [%27, %$6] ; # C
  br label %$6
$8:
  %31 = phi i64 [%26, %$6] ; # P
  %32 = phi i64 [%27, %$6] ; # C
  %33 = phi i64 [0, %$6] ; # ->
; # (val P)
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
; # (? (=0 P))
; # (=0 P)
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$10, label %$9
$9:
  %37 = phi i64 [%35, %$8] ; # P
  br label %$5
$10:
  %38 = phi i64 [%35, %$8] ; # P
  %39 = phi i64 [0, %$8] ; # ->
; # (let P (any (gcData)) (loop (mark (val P)) (? (== P $LispEnd)) (s...
; # (i8* $Transient)
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i8*
; # (any (gcData))
  %41 = ptrtoint i8* %40 to i64
; # (loop (mark (val P)) (? (== P $LispEnd)) (setq P (ofs P 1)))
  br label %$11
$11:
  %42 = phi i64 [%41, %$10], [%47, %$12] ; # P
; # (val P)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (mark (val P))
  call void @mark(i64 %44)
; # (? (== P $LispEnd))
; # (== P $LispEnd)
  %45 = icmp eq i64 %42, ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 408) to i64)
  br i1 %45, label %$13, label %$12
$12:
  %46 = phi i64 [%42, %$11] ; # P
; # (ofs P 1)
  %47 = add i64 %46, 8
  br label %$11
$13:
  %48 = phi i64 [%42, %$11] ; # P
  %49 = phi i64 [0, %$11] ; # ->
; # (val $Intern)
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %51 = load i64, i64* %50
; # (mark (val $Intern))
  call void @mark(i64 %51)
; # (let P (val $Link) (while P (mark (val P)) (shift P)))
; # (val $Link)
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %53 = load i64, i64* %52
; # (while P (mark (val P)) (shift P))
  br label %$14
$14:
  %54 = phi i64 [%53, %$13], [%61, %$15] ; # P
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$15, label %$16
$15:
  %56 = phi i64 [%54, %$14] ; # P
; # (val P)
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
; # (mark (val P))
  call void @mark(i64 %58)
; # (shift P)
  %59 = inttoptr i64 %56 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
  br label %$14
$16:
  %62 = phi i64 [%54, %$14] ; # P
; # (let P (val $Bind) (while P (mark (val P)) (mark (val 2 P)) (setq...
; # (val $Bind)
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %64 = load i64, i64* %63
; # (while P (mark (val P)) (mark (val 2 P)) (setq P (val 3 P)))
  br label %$17
$17:
  %65 = phi i64 [%64, %$16], [%75, %$18] ; # P
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$18, label %$19
$18:
  %67 = phi i64 [%65, %$17] ; # P
; # (val P)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (mark (val P))
  call void @mark(i64 %69)
; # (val 2 P)
  %70 = inttoptr i64 %67 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
; # (mark (val 2 P))
  call void @mark(i64 %72)
; # (val 3 P)
  %73 = inttoptr i64 %67 to i64*
  %74 = getelementptr i64, i64* %73, i32 2
  %75 = load i64, i64* %74
  br label %$17
$19:
  %76 = phi i64 [%65, %$17] ; # P
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (when (Ca: t...
; # (val $Catch)
  %77 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (when (Ca: tag) (mark (Ca: tag)))...
  br label %$20
$20:
  %78 = phi i8* [%77, %$19], [%102, %$24] ; # Ca
  %79 = icmp ne i8* %78, null
  br i1 %79, label %$21, label %$22
$21:
  %80 = phi i8* [%78, %$20] ; # Ca
; # (let Ca: (caFrame Ca) (when (Ca: tag) (mark (Ca: tag))) (mark (Ca...
; # (when (Ca: tag) (mark (Ca: tag)))
; # (Ca: tag)
  %81 = getelementptr i8, i8* %80, i32 8
  %82 = ptrtoint i8* %81 to i64
  %83 = inttoptr i64 %82 to i64*
  %84 = load i64, i64* %83
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$23, label %$24
$23:
  %86 = phi i8* [%80, %$21] ; # Ca
; # (Ca: tag)
  %87 = getelementptr i8, i8* %80, i32 8
  %88 = ptrtoint i8* %87 to i64
  %89 = inttoptr i64 %88 to i64*
  %90 = load i64, i64* %89
; # (mark (Ca: tag))
  call void @mark(i64 %90)
  br label %$24
$24:
  %91 = phi i8* [%80, %$21], [%86, %$23] ; # Ca
; # (Ca: fin)
  %92 = getelementptr i8, i8* %80, i32 16
  %93 = ptrtoint i8* %92 to i64
  %94 = inttoptr i64 %93 to i64*
  %95 = load i64, i64* %94
; # (mark (Ca: fin))
  call void @mark(i64 %95)
; # (Ca: (env $Intern any))
  %96 = getelementptr i8, i8* %80, i32 24
  %97 = getelementptr i8, i8* %96, i32 120
  %98 = ptrtoint i8* %97 to i64
  %99 = inttoptr i64 %98 to i64*
  %100 = load i64, i64* %99
; # (mark (Ca: (env $Intern any)))
  call void @mark(i64 %100)
; # (Ca: link)
  %101 = bitcast i8* %80 to i8**
  %102 = load i8*, i8** %101
  br label %$20
$22:
  %103 = phi i8* [%78, %$20] ; # Ca
; # (let Crt (val $Coroutines) (while Crt (let Crt: (coroutine Crt) (...
; # (val $Coroutines)
  %104 = load i8*, i8** @$Coroutines
; # (while Crt (let Crt: (coroutine Crt) (when (and (Crt: tag) (Crt: ...
  br label %$25
$25:
  %105 = phi i8* [%104, %$22], [%189, %$31] ; # Crt
  %106 = icmp ne i8* %105, null
  br i1 %106, label %$26, label %$27
$26:
  %107 = phi i8* [%105, %$25] ; # Crt
; # (let Crt: (coroutine Crt) (when (and (Crt: tag) (Crt: at)) (mark ...
; # (when (and (Crt: tag) (Crt: at)) (mark (Crt: tag)) (mark (Crt: pr...
; # (and (Crt: tag) (Crt: at))
; # (Crt: tag)
  %108 = ptrtoint i8* %107 to i64
  %109 = inttoptr i64 %108 to i64*
  %110 = load i64, i64* %109
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$29, label %$28
$29:
  %112 = phi i8* [%107, %$26] ; # Crt
; # (Crt: at)
  %113 = getelementptr i8, i8* %107, i32 32
  %114 = ptrtoint i8* %113 to i64
  %115 = inttoptr i64 %114 to i64*
  %116 = load i64, i64* %115
  %117 = icmp ne i64 %116, 0
  br label %$28
$28:
  %118 = phi i8* [%107, %$26], [%112, %$29] ; # Crt
  %119 = phi i1 [0, %$26], [%117, %$29] ; # ->
  br i1 %119, label %$30, label %$31
$30:
  %120 = phi i8* [%118, %$28] ; # Crt
; # (Crt: tag)
  %121 = ptrtoint i8* %107 to i64
  %122 = inttoptr i64 %121 to i64*
  %123 = load i64, i64* %122
; # (mark (Crt: tag))
  call void @mark(i64 %123)
; # (Crt: prg)
  %124 = getelementptr i8, i8* %107, i32 16
  %125 = ptrtoint i8* %124 to i64
  %126 = inttoptr i64 %125 to i64*
  %127 = load i64, i64* %126
; # (mark (Crt: prg))
  call void @mark(i64 %127)
; # (Crt: at)
  %128 = getelementptr i8, i8* %107, i32 32
  %129 = ptrtoint i8* %128 to i64
  %130 = inttoptr i64 %129 to i64*
  %131 = load i64, i64* %130
; # (mark (Crt: at))
  call void @mark(i64 %131)
; # (Crt: (env $Intern any))
  %132 = getelementptr i8, i8* %107, i32 40
  %133 = getelementptr i8, i8* %132, i32 120
  %134 = ptrtoint i8* %133 to i64
  %135 = inttoptr i64 %134 to i64*
  %136 = load i64, i64* %135
; # (mark (Crt: (env $Intern any)))
  call void @mark(i64 %136)
; # (let P (Crt: (env $Link any)) (while P (mark (val P)) (shift P)))...
; # (Crt: (env $Link any))
  %137 = getelementptr i8, i8* %107, i32 40
  %138 = ptrtoint i8* %137 to i64
  %139 = inttoptr i64 %138 to i64*
  %140 = load i64, i64* %139
; # (while P (mark (val P)) (shift P))
  br label %$32
$32:
  %141 = phi i8* [%120, %$30], [%144, %$33] ; # Crt
  %142 = phi i64 [%140, %$30], [%150, %$33] ; # P
  %143 = icmp ne i64 %142, 0
  br i1 %143, label %$33, label %$34
$33:
  %144 = phi i8* [%141, %$32] ; # Crt
  %145 = phi i64 [%142, %$32] ; # P
; # (val P)
  %146 = inttoptr i64 %145 to i64*
  %147 = load i64, i64* %146
; # (mark (val P))
  call void @mark(i64 %147)
; # (shift P)
  %148 = inttoptr i64 %145 to i64*
  %149 = getelementptr i64, i64* %148, i32 1
  %150 = load i64, i64* %149
  br label %$32
$34:
  %151 = phi i8* [%141, %$32] ; # Crt
  %152 = phi i64 [%142, %$32] ; # P
; # (let Ca (Crt: (env $Catch)) (while Ca (let Ca: (caFrame Ca) (when...
; # (Crt: (env $Catch))
  %153 = getelementptr i8, i8* %107, i32 40
  %154 = getelementptr i8, i8* %153, i32 24
; # (while Ca (let Ca: (caFrame Ca) (when (Ca: tag) (mark (Ca: tag)))...
  br label %$35
$35:
  %155 = phi i8* [%151, %$34], [%171, %$39] ; # Crt
  %156 = phi i8* [%154, %$34], [%183, %$39] ; # Ca
  %157 = icmp ne i8* %156, null
  br i1 %157, label %$36, label %$37
$36:
  %158 = phi i8* [%155, %$35] ; # Crt
  %159 = phi i8* [%156, %$35] ; # Ca
; # (let Ca: (caFrame Ca) (when (Ca: tag) (mark (Ca: tag))) (mark (Ca...
; # (when (Ca: tag) (mark (Ca: tag)))
; # (Ca: tag)
  %160 = getelementptr i8, i8* %159, i32 8
  %161 = ptrtoint i8* %160 to i64
  %162 = inttoptr i64 %161 to i64*
  %163 = load i64, i64* %162
  %164 = icmp ne i64 %163, 0
  br i1 %164, label %$38, label %$39
$38:
  %165 = phi i8* [%158, %$36] ; # Crt
  %166 = phi i8* [%159, %$36] ; # Ca
; # (Ca: tag)
  %167 = getelementptr i8, i8* %159, i32 8
  %168 = ptrtoint i8* %167 to i64
  %169 = inttoptr i64 %168 to i64*
  %170 = load i64, i64* %169
; # (mark (Ca: tag))
  call void @mark(i64 %170)
  br label %$39
$39:
  %171 = phi i8* [%158, %$36], [%165, %$38] ; # Crt
  %172 = phi i8* [%159, %$36], [%166, %$38] ; # Ca
; # (Ca: fin)
  %173 = getelementptr i8, i8* %159, i32 16
  %174 = ptrtoint i8* %173 to i64
  %175 = inttoptr i64 %174 to i64*
  %176 = load i64, i64* %175
; # (mark (Ca: fin))
  call void @mark(i64 %176)
; # (Ca: (env $Intern any))
  %177 = getelementptr i8, i8* %159, i32 24
  %178 = getelementptr i8, i8* %177, i32 120
  %179 = ptrtoint i8* %178 to i64
  %180 = inttoptr i64 %179 to i64*
  %181 = load i64, i64* %180
; # (mark (Ca: (env $Intern any)))
  call void @mark(i64 %181)
; # (Ca: link)
  %182 = bitcast i8* %159 to i8**
  %183 = load i8*, i8** %182
  br label %$35
$37:
  %184 = phi i8* [%155, %$35] ; # Crt
  %185 = phi i8* [%156, %$35] ; # Ca
; # (Crt: next)
  %186 = getelementptr i8, i8* %107, i32 8
  %187 = bitcast i8* %186 to i8**
  %188 = load i8*, i8** %187
  br label %$31
$31:
  %189 = phi i8* [%118, %$28], [%188, %$37] ; # Crt
  br label %$25
$27:
  %190 = phi i8* [%105, %$25] ; # Crt
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (any (& (cdr P) -...
; # (val $Extern)
  %191 = load i64, i64* @$Extern
; # (loop (loop (let X (any (& (cdr P) -2)) (set 2 P X) (let Y (any (...
  br label %$40
$40:
  %192 = phi i64 [0, %$27], [%309, %$55] ; # Tos
  %193 = phi i64 [%191, %$27], [%310, %$55] ; # P
; # (loop (let X (any (& (cdr P) -2)) (set 2 P X) (let Y (any (& (cdr...
  br label %$41
$41:
  %194 = phi i64 [%192, %$40], [%211, %$42] ; # Tos
  %195 = phi i64 [%193, %$40], [%205, %$42] ; # P
; # (let X (any (& (cdr P) -2)) (set 2 P X) (let Y (any (& (cdr X) -2...
; # (cdr P)
  %196 = inttoptr i64 %195 to i64*
  %197 = getelementptr i64, i64* %196, i32 1
  %198 = load i64, i64* %197
; # (& (cdr P) -2)
  %199 = and i64 %198, -2
; # (any (& (cdr P) -2))
; # (set 2 P X)
  %200 = inttoptr i64 %195 to i64*
  %201 = getelementptr i64, i64* %200, i32 1
  store i64 %199, i64* %201
; # (let Y (any (& (cdr X) -2)) (set 2 X Y) (? (atom Y)) (let Z P (se...
; # (cdr X)
  %202 = inttoptr i64 %199 to i64*
  %203 = getelementptr i64, i64* %202, i32 1
  %204 = load i64, i64* %203
; # (& (cdr X) -2)
  %205 = and i64 %204, -2
; # (any (& (cdr X) -2))
; # (set 2 X Y)
  %206 = inttoptr i64 %199 to i64*
  %207 = getelementptr i64, i64* %206, i32 1
  store i64 %205, i64* %207
; # (? (atom Y))
; # (atom Y)
  %208 = and i64 %205, 15
  %209 = icmp ne i64 %208, 0
  br i1 %209, label %$43, label %$42
$42:
  %210 = phi i64 [%194, %$41] ; # Tos
  %211 = phi i64 [%195, %$41] ; # P
; # (let Z P (setq P Y) (set 2 X Tos) (setq Tos Z))
; # (set 2 X Tos)
  %212 = inttoptr i64 %199 to i64*
  %213 = getelementptr i64, i64* %212, i32 1
  store i64 %210, i64* %213
  br label %$41
$43:
  %214 = phi i64 [%194, %$41] ; # Tos
  %215 = phi i64 [%195, %$41] ; # P
  %216 = phi i64 [0, %$41] ; # ->
; # (loop (let S (val P) (when (& (val S) 1) (let Tail (val (tail S))...
  br label %$44
$44:
  %217 = phi i64 [%214, %$43], [%306, %$61] ; # Tos
  %218 = phi i64 [%215, %$43], [%307, %$61] ; # P
; # (let S (val P) (when (& (val S) 1) (let Tail (val (tail S)) (unle...
; # (val P)
  %219 = inttoptr i64 %218 to i64*
  %220 = load i64, i64* %219
; # (when (& (val S) 1) (let Tail (val (tail S)) (unless (num? Tail) ...
; # (val S)
  %221 = inttoptr i64 %220 to i64*
  %222 = load i64, i64* %221
; # (& (val S) 1)
  %223 = and i64 %222, 1
  %224 = icmp ne i64 %223, 0
  br i1 %224, label %$45, label %$46
$45:
  %225 = phi i64 [%217, %$44] ; # Tos
  %226 = phi i64 [%218, %$44] ; # P
; # (let Tail (val (tail S)) (unless (num? Tail) (setq Tail (& Tail -...
; # (tail S)
  %227 = add i64 %220, -8
; # (val (tail S))
  %228 = inttoptr i64 %227 to i64*
  %229 = load i64, i64* %228
; # (unless (num? Tail) (setq Tail (& Tail -10)) (until (num? (shift ...
; # (num? Tail)
  %230 = and i64 %229, 6
  %231 = icmp ne i64 %230, 0
  br i1 %231, label %$48, label %$47
$47:
  %232 = phi i64 [%225, %$45] ; # Tos
  %233 = phi i64 [%226, %$45] ; # P
  %234 = phi i64 [%229, %$45] ; # Tail
; # (& Tail -10)
  %235 = and i64 %234, -10
; # (until (num? (shift Tail)) (setq Tail (& Tail -2)))
  br label %$49
$49:
  %236 = phi i64 [%232, %$47], [%244, %$50] ; # Tos
  %237 = phi i64 [%233, %$47], [%245, %$50] ; # P
  %238 = phi i64 [%235, %$47], [%247, %$50] ; # Tail
; # (shift Tail)
  %239 = inttoptr i64 %238 to i64*
  %240 = getelementptr i64, i64* %239, i32 1
  %241 = load i64, i64* %240
; # (num? (shift Tail))
  %242 = and i64 %241, 6
  %243 = icmp ne i64 %242, 0
  br i1 %243, label %$51, label %$50
$50:
  %244 = phi i64 [%236, %$49] ; # Tos
  %245 = phi i64 [%237, %$49] ; # P
  %246 = phi i64 [%241, %$49] ; # Tail
; # (& Tail -2)
  %247 = and i64 %246, -2
  br label %$49
$51:
  %248 = phi i64 [%236, %$49] ; # Tos
  %249 = phi i64 [%237, %$49] ; # P
  %250 = phi i64 [%241, %$49] ; # Tail
  br label %$48
$48:
  %251 = phi i64 [%225, %$45], [%248, %$51] ; # Tos
  %252 = phi i64 [%226, %$45], [%249, %$51] ; # P
  %253 = phi i64 [%229, %$45], [%250, %$51] ; # Tail
; # (add Tail Tail)
  %254 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %253, i64 %253)
  %255 = extractvalue {i64, i1} %254, 1
  %256 = extractvalue {i64, i1} %254, 0
; # (when @@ (mark S))
  br i1 %255, label %$52, label %$53
$52:
  %257 = phi i64 [%251, %$48] ; # Tos
  %258 = phi i64 [%252, %$48] ; # P
  %259 = phi i64 [%253, %$48] ; # Tail
; # (mark S)
  call void @mark(i64 %220)
  br label %$53
$53:
  %260 = phi i64 [%251, %$48], [%257, %$52] ; # Tos
  %261 = phi i64 [%252, %$48], [%258, %$52] ; # P
  %262 = phi i64 [%253, %$48], [%259, %$52] ; # Tail
  br label %$46
$46:
  %263 = phi i64 [%217, %$44], [%260, %$53] ; # Tos
  %264 = phi i64 [%218, %$44], [%261, %$53] ; # P
; # (let X (cdr P) (? (pair (car X)) (let Z P (setq P @) (set X Tos) ...
; # (cdr P)
  %265 = inttoptr i64 %264 to i64*
  %266 = getelementptr i64, i64* %265, i32 1
  %267 = load i64, i64* %266
; # (? (pair (car X)) (let Z P (setq P @) (set X Tos) (setq Tos (| Z ...
; # (car X)
  %268 = inttoptr i64 %267 to i64*
  %269 = load i64, i64* %268
; # (pair (car X))
  %270 = and i64 %269, 15
  %271 = icmp eq i64 %270, 0
  br i1 %271, label %$56, label %$54
$56:
  %272 = phi i64 [%263, %$46] ; # Tos
  %273 = phi i64 [%264, %$46] ; # P
; # (let Z P (setq P @) (set X Tos) (setq Tos (| Z 8)))
; # (set X Tos)
  %274 = inttoptr i64 %267 to i64*
  store i64 %272, i64* %274
; # (| Z 8)
  %275 = or i64 %273, 8
  br label %$55
$54:
  %276 = phi i64 [%263, %$46] ; # Tos
  %277 = phi i64 [%264, %$46] ; # P
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$57
$57:
  %278 = phi i64 [%276, %$54], [%304, %$60] ; # Tos
  %279 = phi i64 [%277, %$54], [%299, %$60] ; # P
; # (unless Tos (goto 1))
  %280 = icmp ne i64 %278, 0
  br i1 %280, label %$59, label %$58
$58:
  %281 = phi i64 [%278, %$57] ; # Tos
  %282 = phi i64 [%279, %$57] ; # P
; # (goto 1)
  br label %$-1
$59:
  %283 = phi i64 [%278, %$57] ; # Tos
  %284 = phi i64 [%279, %$57] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set ...
; # (& Tos 8)
  %285 = and i64 %283, 8
; # (=0 (& Tos 8))
  %286 = icmp eq i64 %285, 0
  br i1 %286, label %$62, label %$60
$62:
  %287 = phi i64 [%283, %$59] ; # Tos
  %288 = phi i64 [%284, %$59] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %289 = inttoptr i64 %287 to i64*
  %290 = getelementptr i64, i64* %289, i32 1
  %291 = load i64, i64* %290
; # (cdr Y)
  %292 = inttoptr i64 %291 to i64*
  %293 = getelementptr i64, i64* %292, i32 1
  %294 = load i64, i64* %293
; # (set 2 Y P)
  %295 = inttoptr i64 %291 to i64*
  %296 = getelementptr i64, i64* %295, i32 1
  store i64 %288, i64* %296
  br label %$61
$60:
  %297 = phi i64 [%283, %$59] ; # Tos
  %298 = phi i64 [%284, %$59] ; # P
; # (& Tos -9)
  %299 = and i64 %297, -9
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %300 = inttoptr i64 %299 to i64*
  %301 = getelementptr i64, i64* %300, i32 1
  %302 = load i64, i64* %301
; # (car Y)
  %303 = inttoptr i64 %302 to i64*
  %304 = load i64, i64* %303
; # (set Y P)
  %305 = inttoptr i64 %302 to i64*
  store i64 %298, i64* %305
  br label %$57
$61:
  %306 = phi i64 [%294, %$62] ; # Tos
  %307 = phi i64 [%287, %$62] ; # P
  %308 = phi i64 [%287, %$62] ; # ->
  br label %$44
$55:
  %309 = phi i64 [%275, %$56] ; # Tos
  %310 = phi i64 [%269, %$56] ; # P
  %311 = phi i64 [%275, %$56] ; # ->
  br label %$40
$63:
; # (: 1 (set $DB $Db1) (when (& (val $Db1) 1) (set $Db1 $Nil (tail $...
  br label %$-1
$-1:
; # (set $DB $Db1)
  %312 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 136) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 40) to i64), i64* %312
; # (when (& (val $Db1) 1) (set $Db1 $Nil (tail $Db1) DB1))
; # (val $Db1)
  %313 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 40) to i64) to i64*
  %314 = load i64, i64* %313
; # (& (val $Db1) 1)
  %315 = and i64 %314, 1
  %316 = icmp ne i64 %315, 0
  br i1 %316, label %$64, label %$65
$64:
; # (set $Db1 $Nil (tail $Db1) DB1)
  %317 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 40) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %317
; # (tail $Db1)
  %318 = add i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 40) to i64), -8
  %319 = inttoptr i64 %318 to i64*
  store i64 26, i64* %319
  br label %$65
$65:
; # (let (Tos 0 P (val $Extern)) (: 2 (loop (loop (let X (cdr P) (? (...
; # (val $Extern)
  %320 = load i64, i64* @$Extern
; # (: 2 (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Z P (setq...
  br label %$-2
$-2:
  %321 = phi i64 [0, %$65], [%392, %$77] ; # Tos
  %322 = phi i64 [%320, %$65], [%399, %$77] ; # P
; # (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Z P (setq P @)...
  br label %$66
$66:
  %323 = phi i64 [%321, %$-2], [%524, %$86] ; # Tos
  %324 = phi i64 [%322, %$-2], [%525, %$86] ; # P
; # (loop (let X (cdr P) (? (atom (cdr X))) (let Z P (setq P @) (set ...
  br label %$67
$67:
  %325 = phi i64 [%323, %$66], [%336, %$68] ; # Tos
  %326 = phi i64 [%324, %$66], [%332, %$68] ; # P
; # (let X (cdr P) (? (atom (cdr X))) (let Z P (setq P @) (set 2 X To...
; # (cdr P)
  %327 = inttoptr i64 %326 to i64*
  %328 = getelementptr i64, i64* %327, i32 1
  %329 = load i64, i64* %328
; # (? (atom (cdr X)))
; # (cdr X)
  %330 = inttoptr i64 %329 to i64*
  %331 = getelementptr i64, i64* %330, i32 1
  %332 = load i64, i64* %331
; # (atom (cdr X))
  %333 = and i64 %332, 15
  %334 = icmp ne i64 %333, 0
  br i1 %334, label %$69, label %$68
$68:
  %335 = phi i64 [%325, %$67] ; # Tos
  %336 = phi i64 [%326, %$67] ; # P
; # (let Z P (setq P @) (set 2 X Tos) (setq Tos Z))
; # (set 2 X Tos)
  %337 = inttoptr i64 %329 to i64*
  %338 = getelementptr i64, i64* %337, i32 1
  store i64 %335, i64* %338
  br label %$67
$69:
  %339 = phi i64 [%325, %$67] ; # Tos
  %340 = phi i64 [%326, %$67] ; # P
  %341 = phi i64 [0, %$67] ; # ->
; # (loop (when (& (val (val P)) 1) (set $ExtCnt (- (val $ExtCnt) 1))...
  br label %$70
$70:
  %342 = phi i64 [%339, %$69], [%521, %$92] ; # Tos
  %343 = phi i64 [%340, %$69], [%522, %$92] ; # P
; # (when (& (val (val P)) 1) (set $ExtCnt (- (val $ExtCnt) 1)) (let ...
; # (val P)
  %344 = inttoptr i64 %343 to i64*
  %345 = load i64, i64* %344
; # (val (val P))
  %346 = inttoptr i64 %345 to i64*
  %347 = load i64, i64* %346
; # (& (val (val P)) 1)
  %348 = and i64 %347, 1
  %349 = icmp ne i64 %348, 0
  br i1 %349, label %$71, label %$72
$71:
  %350 = phi i64 [%342, %$70] ; # Tos
  %351 = phi i64 [%343, %$70] ; # P
; # (set $ExtCnt (- (val $ExtCnt) 1))
; # (val $ExtCnt)
  %352 = load i64, i64* @$ExtCnt
; # (- (val $ExtCnt) 1)
  %353 = sub i64 %352, 1
  store i64 %353, i64* @$ExtCnt
; # (let X (cdr P) (when (atom X) (set 2 P (| X 1)) (setq P X) (goto ...
; # (cdr P)
  %354 = inttoptr i64 %351 to i64*
  %355 = getelementptr i64, i64* %354, i32 1
  %356 = load i64, i64* %355
; # (when (atom X) (set 2 P (| X 1)) (setq P X) (goto 4))
; # (atom X)
  %357 = and i64 %356, 15
  %358 = icmp ne i64 %357, 0
  br i1 %358, label %$73, label %$74
$73:
  %359 = phi i64 [%350, %$71] ; # Tos
  %360 = phi i64 [%351, %$71] ; # P
  %361 = phi i64 [%356, %$71] ; # X
; # (set 2 P (| X 1))
; # (| X 1)
  %362 = or i64 %361, 1
  %363 = inttoptr i64 %360 to i64*
  %364 = getelementptr i64, i64* %363, i32 1
  store i64 %362, i64* %364
; # (goto 4)
  br label %$-4
$74:
  %365 = phi i64 [%350, %$71] ; # Tos
  %366 = phi i64 [%351, %$71] ; # P
  %367 = phi i64 [%356, %$71] ; # X
; # (when (atom (car X)) (set 2 P (| X 1)) (setq P (cdr X)) (set 2 X ...
; # (car X)
  %368 = inttoptr i64 %367 to i64*
  %369 = load i64, i64* %368
; # (atom (car X))
  %370 = and i64 %369, 15
  %371 = icmp ne i64 %370, 0
  br i1 %371, label %$75, label %$76
$75:
  %372 = phi i64 [%365, %$74] ; # Tos
  %373 = phi i64 [%366, %$74] ; # P
  %374 = phi i64 [%367, %$74] ; # X
; # (set 2 P (| X 1))
; # (| X 1)
  %375 = or i64 %374, 1
  %376 = inttoptr i64 %373 to i64*
  %377 = getelementptr i64, i64* %376, i32 1
  store i64 %375, i64* %377
; # (cdr X)
  %378 = inttoptr i64 %374 to i64*
  %379 = getelementptr i64, i64* %378, i32 1
  %380 = load i64, i64* %379
; # (set 2 X (| P 1))
; # (| P 1)
  %381 = or i64 %380, 1
  %382 = inttoptr i64 %374 to i64*
  %383 = getelementptr i64, i64* %382, i32 1
  store i64 %381, i64* %383
; # (goto 4)
  br label %$-4
$76:
  %384 = phi i64 [%365, %$74] ; # Tos
  %385 = phi i64 [%366, %$74] ; # P
  %386 = phi i64 [%367, %$74] ; # X
; # (when (atom (cdr X)) (set 2 P (| X 1)) (setq P (car X)) (set 2 X ...
; # (cdr X)
  %387 = inttoptr i64 %386 to i64*
  %388 = getelementptr i64, i64* %387, i32 1
  %389 = load i64, i64* %388
; # (atom (cdr X))
  %390 = and i64 %389, 15
  %391 = icmp ne i64 %390, 0
  br i1 %391, label %$77, label %$78
$77:
  %392 = phi i64 [%384, %$76] ; # Tos
  %393 = phi i64 [%385, %$76] ; # P
  %394 = phi i64 [%386, %$76] ; # X
; # (set 2 P (| X 1))
; # (| X 1)
  %395 = or i64 %394, 1
  %396 = inttoptr i64 %393 to i64*
  %397 = getelementptr i64, i64* %396, i32 1
  store i64 %395, i64* %397
; # (car X)
  %398 = inttoptr i64 %394 to i64*
  %399 = load i64, i64* %398
; # (set 2 X (| (cdr X) 1))
; # (cdr X)
  %400 = inttoptr i64 %394 to i64*
  %401 = getelementptr i64, i64* %400, i32 1
  %402 = load i64, i64* %401
; # (| (cdr X) 1)
  %403 = or i64 %402, 1
  %404 = inttoptr i64 %394 to i64*
  %405 = getelementptr i64, i64* %404, i32 1
  store i64 %403, i64* %405
; # (goto 2)
  br label %$-2
$78:
  %406 = phi i64 [%384, %$76] ; # Tos
  %407 = phi i64 [%385, %$76] ; # P
  %408 = phi i64 [%386, %$76] ; # X
; # (let Y (cdr (shift X)) (when (atom (car Y)) (set P (car X) 2 (cdr...
; # (shift X)
  %409 = inttoptr i64 %408 to i64*
  %410 = getelementptr i64, i64* %409, i32 1
  %411 = load i64, i64* %410
; # (cdr (shift X))
  %412 = inttoptr i64 %411 to i64*
  %413 = getelementptr i64, i64* %412, i32 1
  %414 = load i64, i64* %413
; # (when (atom (car Y)) (set P (car X) 2 (cdr P) (cdr Y)) (goto 3))
; # (car Y)
  %415 = inttoptr i64 %414 to i64*
  %416 = load i64, i64* %415
; # (atom (car Y))
  %417 = and i64 %416, 15
  %418 = icmp ne i64 %417, 0
  br i1 %418, label %$79, label %$80
$79:
  %419 = phi i64 [%406, %$78] ; # Tos
  %420 = phi i64 [%407, %$78] ; # P
  %421 = phi i64 [%411, %$78] ; # X
  %422 = phi i64 [%414, %$78] ; # Y
; # (set P (car X) 2 (cdr P) (cdr Y))
; # (car X)
  %423 = inttoptr i64 %421 to i64*
  %424 = load i64, i64* %423
  %425 = inttoptr i64 %420 to i64*
  store i64 %424, i64* %425
; # (cdr P)
  %426 = inttoptr i64 %420 to i64*
  %427 = getelementptr i64, i64* %426, i32 1
  %428 = load i64, i64* %427
; # (cdr Y)
  %429 = inttoptr i64 %422 to i64*
  %430 = getelementptr i64, i64* %429, i32 1
  %431 = load i64, i64* %430
  %432 = inttoptr i64 %428 to i64*
  %433 = getelementptr i64, i64* %432, i32 1
  store i64 %431, i64* %433
; # (goto 3)
  br label %$-3
$80:
  %434 = phi i64 [%406, %$78] ; # Tos
  %435 = phi i64 [%407, %$78] ; # P
  %436 = phi i64 [%411, %$78] ; # X
  %437 = phi i64 [%414, %$78] ; # Y
; # (car Y)
  %438 = inttoptr i64 %437 to i64*
  %439 = load i64, i64* %438
; # (loop (? (atom (cdr Y)) (set P (car Y) (cdr X) (cdr @))) (setq X ...
  br label %$81
$81:
  %440 = phi i64 [%434, %$80], [%463, %$82] ; # Tos
  %441 = phi i64 [%435, %$80], [%464, %$82] ; # P
  %442 = phi i64 [%436, %$80], [%466, %$82] ; # X
  %443 = phi i64 [%439, %$80], [%468, %$82] ; # Y
; # (? (atom (cdr Y)) (set P (car Y) (cdr X) (cdr @)))
; # (cdr Y)
  %444 = inttoptr i64 %443 to i64*
  %445 = getelementptr i64, i64* %444, i32 1
  %446 = load i64, i64* %445
; # (atom (cdr Y))
  %447 = and i64 %446, 15
  %448 = icmp ne i64 %447, 0
  br i1 %448, label %$84, label %$82
$84:
  %449 = phi i64 [%440, %$81] ; # Tos
  %450 = phi i64 [%441, %$81] ; # P
  %451 = phi i64 [%442, %$81] ; # X
  %452 = phi i64 [%443, %$81] ; # Y
; # (set P (car Y) (cdr X) (cdr @))
; # (car Y)
  %453 = inttoptr i64 %452 to i64*
  %454 = load i64, i64* %453
  %455 = inttoptr i64 %450 to i64*
  store i64 %454, i64* %455
; # (cdr X)
  %456 = inttoptr i64 %451 to i64*
  %457 = getelementptr i64, i64* %456, i32 1
  %458 = load i64, i64* %457
; # (cdr @)
  %459 = inttoptr i64 %446 to i64*
  %460 = getelementptr i64, i64* %459, i32 1
  %461 = load i64, i64* %460
  %462 = inttoptr i64 %458 to i64*
  store i64 %461, i64* %462
  br label %$83
$82:
  %463 = phi i64 [%440, %$81] ; # Tos
  %464 = phi i64 [%441, %$81] ; # P
  %465 = phi i64 [%442, %$81] ; # X
  %466 = phi i64 [%443, %$81] ; # Y
; # (car @)
  %467 = inttoptr i64 %446 to i64*
  %468 = load i64, i64* %467
  br label %$81
$83:
  %469 = phi i64 [%449, %$84] ; # Tos
  %470 = phi i64 [%450, %$84] ; # P
  %471 = phi i64 [%451, %$84] ; # X
  %472 = phi i64 [%452, %$84] ; # Y
  %473 = phi i64 [%461, %$84] ; # ->
  br label %$72
$72:
  %474 = phi i64 [%342, %$70], [%469, %$83] ; # Tos
  %475 = phi i64 [%343, %$70], [%470, %$83] ; # P
; # (: 3 (let X (cdr P) (? (pair (car X)) (let Z P (setq P @) (set X ...
  br label %$-3
$-3:
  %476 = phi i64 [%419, %$79], [%474, %$72] ; # Tos
  %477 = phi i64 [%420, %$79], [%475, %$72] ; # P
; # (let X (cdr P) (? (pair (car X)) (let Z P (setq P @) (set X Tos) ...
; # (cdr P)
  %478 = inttoptr i64 %477 to i64*
  %479 = getelementptr i64, i64* %478, i32 1
  %480 = load i64, i64* %479
; # (? (pair (car X)) (let Z P (setq P @) (set X Tos) (setq Tos (| Z ...
; # (car X)
  %481 = inttoptr i64 %480 to i64*
  %482 = load i64, i64* %481
; # (pair (car X))
  %483 = and i64 %482, 15
  %484 = icmp eq i64 %483, 0
  br i1 %484, label %$87, label %$85
$87:
  %485 = phi i64 [%476, %$-3] ; # Tos
  %486 = phi i64 [%477, %$-3] ; # P
; # (let Z P (setq P @) (set X Tos) (setq Tos (| Z 8)))
; # (set X Tos)
  %487 = inttoptr i64 %480 to i64*
  store i64 %485, i64* %487
; # (| Z 8)
  %488 = or i64 %486, 8
  br label %$86
$85:
  %489 = phi i64 [%476, %$-3] ; # Tos
  %490 = phi i64 [%477, %$-3] ; # P
; # (: 4 (loop (unless Tos (goto 5)) (? (=0 (& Tos 8)) (let (X Tos Y ...
  br label %$-4
$-4:
  %491 = phi i64 [%359, %$73], [%372, %$75], [%489, %$85] ; # Tos
  %492 = phi i64 [%361, %$73], [%380, %$75], [%490, %$85] ; # P
; # (loop (unless Tos (goto 5)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$88
$88:
  %493 = phi i64 [%491, %$-4], [%519, %$91] ; # Tos
  %494 = phi i64 [%492, %$-4], [%514, %$91] ; # P
; # (unless Tos (goto 5))
  %495 = icmp ne i64 %493, 0
  br i1 %495, label %$90, label %$89
$89:
  %496 = phi i64 [%493, %$88] ; # Tos
  %497 = phi i64 [%494, %$88] ; # P
; # (goto 5)
  br label %$-5
$90:
  %498 = phi i64 [%493, %$88] ; # Tos
  %499 = phi i64 [%494, %$88] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set ...
; # (& Tos 8)
  %500 = and i64 %498, 8
; # (=0 (& Tos 8))
  %501 = icmp eq i64 %500, 0
  br i1 %501, label %$93, label %$91
$93:
  %502 = phi i64 [%498, %$90] ; # Tos
  %503 = phi i64 [%499, %$90] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %504 = inttoptr i64 %502 to i64*
  %505 = getelementptr i64, i64* %504, i32 1
  %506 = load i64, i64* %505
; # (cdr Y)
  %507 = inttoptr i64 %506 to i64*
  %508 = getelementptr i64, i64* %507, i32 1
  %509 = load i64, i64* %508
; # (set 2 Y P)
  %510 = inttoptr i64 %506 to i64*
  %511 = getelementptr i64, i64* %510, i32 1
  store i64 %503, i64* %511
  br label %$92
$91:
  %512 = phi i64 [%498, %$90] ; # Tos
  %513 = phi i64 [%499, %$90] ; # P
; # (let (X (& Tos -9) Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq ...
; # (& Tos -9)
  %514 = and i64 %512, -9
; # (cdr X)
  %515 = inttoptr i64 %514 to i64*
  %516 = getelementptr i64, i64* %515, i32 1
  %517 = load i64, i64* %516
; # (car Y)
  %518 = inttoptr i64 %517 to i64*
  %519 = load i64, i64* %518
; # (set Y P)
  %520 = inttoptr i64 %517 to i64*
  store i64 %513, i64* %520
  br label %$88
$92:
  %521 = phi i64 [%509, %$93] ; # Tos
  %522 = phi i64 [%502, %$93] ; # P
  %523 = phi i64 [%502, %$93] ; # ->
  br label %$70
$86:
  %524 = phi i64 [%488, %$87] ; # Tos
  %525 = phi i64 [%482, %$87] ; # P
  %526 = phi i64 [%488, %$87] ; # ->
  br label %$66
$94:
; # (: 5 (set $Extern P))
  br label %$-5
$-5:
  %527 = phi i64 [%496, %$89], [%524, %$94] ; # Tos
  %528 = phi i64 [%497, %$89], [%525, %$94] ; # P
; # (set $Extern P)
  store i64 %528, i64* @$Extern
; # (let Crt (val $Coroutines) (while Crt (let Crt: (coroutine Crt) (...
; # (val $Coroutines)
  %529 = load i8*, i8** @$Coroutines
; # (while Crt (let Crt: (coroutine Crt) (when (and (Crt: tag) (Crt: ...
  br label %$95
$95:
  %530 = phi i8* [%529, %$-5], [%559, %$102] ; # Crt
  %531 = icmp ne i8* %530, null
  br i1 %531, label %$96, label %$97
$96:
  %532 = phi i8* [%530, %$95] ; # Crt
; # (let Crt: (coroutine Crt) (when (and (Crt: tag) (Crt: at) (& (val...
; # (when (and (Crt: tag) (Crt: at) (& (val (Crt: tag)) 1)) (Crt: tag...
; # (and (Crt: tag) (Crt: at) (& (val (Crt: tag)) 1))
; # (Crt: tag)
  %533 = ptrtoint i8* %532 to i64
  %534 = inttoptr i64 %533 to i64*
  %535 = load i64, i64* %534
  %536 = icmp ne i64 %535, 0
  br i1 %536, label %$99, label %$98
$99:
  %537 = phi i8* [%532, %$96] ; # Crt
; # (Crt: at)
  %538 = getelementptr i8, i8* %532, i32 32
  %539 = ptrtoint i8* %538 to i64
  %540 = inttoptr i64 %539 to i64*
  %541 = load i64, i64* %540
  %542 = icmp ne i64 %541, 0
  br i1 %542, label %$100, label %$98
$100:
  %543 = phi i8* [%537, %$99] ; # Crt
; # (Crt: tag)
  %544 = ptrtoint i8* %532 to i64
  %545 = inttoptr i64 %544 to i64*
  %546 = load i64, i64* %545
; # (val (Crt: tag))
  %547 = inttoptr i64 %546 to i64*
  %548 = load i64, i64* %547
; # (& (val (Crt: tag)) 1)
  %549 = and i64 %548, 1
  %550 = icmp ne i64 %549, 0
  br label %$98
$98:
  %551 = phi i8* [%532, %$96], [%537, %$99], [%543, %$100] ; # Crt
  %552 = phi i1 [0, %$96], [0, %$99], [%550, %$100] ; # ->
  br i1 %552, label %$101, label %$102
$101:
  %553 = phi i8* [%551, %$98] ; # Crt
; # (Crt: tag 0)
  %554 = ptrtoint i8* %532 to i64
  %555 = inttoptr i64 %554 to i64*
  store i64 0, i64* %555
  br label %$102
$102:
  %556 = phi i8* [%551, %$98], [%553, %$101] ; # Crt
; # (Crt: next)
  %557 = getelementptr i8, i8* %532, i32 8
  %558 = bitcast i8* %557 to i8**
  %559 = load i8*, i8** %558
  br label %$95
$97:
  %560 = phi i8* [%530, %$95] ; # Crt
; # (let (Avail 0 Heap (val $Heaps) Cnt (val $GcCount)) (ifn Cnt (let...
; # (val $Heaps)
  %561 = load i64, i64* @$Heaps
; # (val $GcCount)
  %562 = load i64, i64* @$GcCount
; # (ifn Cnt (let H (any $Heaps) (loop (let (A Avail P (ofs Heap (- H...
  %563 = icmp ne i64 %562, 0
  br i1 %563, label %$104, label %$103
$103:
  %564 = phi i64 [0, %$97] ; # Avail
  %565 = phi i64 [%561, %$97] ; # Heap
  %566 = phi i64 [%562, %$97] ; # Cnt
; # (let H (any $Heaps) (loop (let (A Avail P (ofs Heap (- HEAP 2))) ...
; # (any $Heaps)
  %567 = ptrtoint i64* @$Heaps to i64
; # (loop (let (A Avail P (ofs Heap (- HEAP 2))) (setq Cnt CELLS) (lo...
  br label %$106
$106:
  %568 = phi i64 [%564, %$103], [%636, %$115] ; # Avail
  %569 = phi i64 [%565, %$103], [%637, %$115] ; # Heap
  %570 = phi i64 [%566, %$103], [%638, %$115] ; # Cnt
  %571 = phi i64 [%567, %$103], [%639, %$115] ; # H
; # (let (A Avail P (ofs Heap (- HEAP 2))) (setq Cnt CELLS) (loop (wh...
; # (- HEAP 2)
; # (ofs Heap (- HEAP 2))
  %572 = add i64 %569, 1048560
; # (loop (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt)...
  br label %$107
$107:
  %573 = phi i64 [%568, %$106], [%596, %$110] ; # Avail
  %574 = phi i64 [%569, %$106], [%597, %$110] ; # Heap
  %575 = phi i64 [65536, %$106], [%598, %$110] ; # Cnt
  %576 = phi i64 [%571, %$106], [%599, %$110] ; # H
  %577 = phi i64 [%572, %$106], [%601, %$110] ; # P
; # (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt))
; # (cdr P)
  %578 = inttoptr i64 %577 to i64*
  %579 = getelementptr i64, i64* %578, i32 1
  %580 = load i64, i64* %579
; # (& (cdr P) 1)
  %581 = and i64 %580, 1
  %582 = icmp ne i64 %581, 0
  br i1 %582, label %$108, label %$109
$108:
  %583 = phi i64 [%573, %$107] ; # Avail
  %584 = phi i64 [%574, %$107] ; # Heap
  %585 = phi i64 [%575, %$107] ; # Cnt
  %586 = phi i64 [%576, %$107] ; # H
  %587 = phi i64 [%577, %$107] ; # P
; # (set P Avail)
  %588 = inttoptr i64 %587 to i64*
  store i64 %583, i64* %588
; # (dec 'Cnt)
  %589 = sub i64 %585, 1
  br label %$109
$109:
  %590 = phi i64 [%573, %$107], [%587, %$108] ; # Avail
  %591 = phi i64 [%574, %$107], [%584, %$108] ; # Heap
  %592 = phi i64 [%575, %$107], [%589, %$108] ; # Cnt
  %593 = phi i64 [%576, %$107], [%586, %$108] ; # H
  %594 = phi i64 [%577, %$107], [%587, %$108] ; # P
; # (? (== P Heap))
; # (== P Heap)
  %595 = icmp eq i64 %594, %591
  br i1 %595, label %$111, label %$110
$110:
  %596 = phi i64 [%590, %$109] ; # Avail
  %597 = phi i64 [%591, %$109] ; # Heap
  %598 = phi i64 [%592, %$109] ; # Cnt
  %599 = phi i64 [%593, %$109] ; # H
  %600 = phi i64 [%594, %$109] ; # P
; # (ofs P -2)
  %601 = add i64 %600, -16
  br label %$107
$111:
  %602 = phi i64 [%590, %$109] ; # Avail
  %603 = phi i64 [%591, %$109] ; # Heap
  %604 = phi i64 [%592, %$109] ; # Cnt
  %605 = phi i64 [%593, %$109] ; # H
  %606 = phi i64 [%594, %$109] ; # P
  %607 = phi i64 [0, %$109] ; # ->
; # (if Cnt (setq Heap (val (setq H (ofs Heap HEAP)))) (setq Avail A ...
  %608 = icmp ne i64 %604, 0
  br i1 %608, label %$112, label %$113
$112:
  %609 = phi i64 [%602, %$111] ; # Avail
  %610 = phi i64 [%603, %$111] ; # Heap
  %611 = phi i64 [%604, %$111] ; # Cnt
  %612 = phi i64 [%605, %$111] ; # H
  %613 = phi i64 [%606, %$111] ; # P
; # (ofs Heap HEAP)
  %614 = add i64 %610, 1048576
; # (val (setq H (ofs Heap HEAP)))
  %615 = inttoptr i64 %614 to i64*
  %616 = load i64, i64* %615
  br label %$114
$113:
  %617 = phi i64 [%602, %$111] ; # Avail
  %618 = phi i64 [%603, %$111] ; # Heap
  %619 = phi i64 [%604, %$111] ; # Cnt
  %620 = phi i64 [%605, %$111] ; # H
  %621 = phi i64 [%606, %$111] ; # P
; # (inc HEAP)
; # (val (inc HEAP) Heap)
  %622 = inttoptr i64 %618 to i64*
  %623 = getelementptr i64, i64* %622, i32 131072
  %624 = load i64, i64* %623
; # (val H)
  %625 = inttoptr i64 %620 to i64*
  %626 = load i64, i64* %625
; # (i8* (val H))
  %627 = inttoptr i64 %626 to i8*
; # (free (i8* (val H)))
  call void @free(i8* %627)
; # (set H Heap)
  %628 = inttoptr i64 %620 to i64*
  store i64 %624, i64* %628
  br label %$114
$114:
  %629 = phi i64 [%609, %$112], [%568, %$113] ; # Avail
  %630 = phi i64 [%616, %$112], [%624, %$113] ; # Heap
  %631 = phi i64 [%611, %$112], [%619, %$113] ; # Cnt
  %632 = phi i64 [%614, %$112], [%620, %$113] ; # H
  %633 = phi i64 [%613, %$112], [%621, %$113] ; # P
  %634 = phi i64 [%616, %$112], [%624, %$113] ; # ->
; # (? (=0 Heap))
; # (=0 Heap)
  %635 = icmp eq i64 %630, 0
  br i1 %635, label %$116, label %$115
$115:
  %636 = phi i64 [%629, %$114] ; # Avail
  %637 = phi i64 [%630, %$114] ; # Heap
  %638 = phi i64 [%631, %$114] ; # Cnt
  %639 = phi i64 [%632, %$114] ; # H
  br label %$106
$116:
  %640 = phi i64 [%629, %$114] ; # Avail
  %641 = phi i64 [%630, %$114] ; # Heap
  %642 = phi i64 [%631, %$114] ; # Cnt
  %643 = phi i64 [%632, %$114] ; # H
  %644 = phi i64 [0, %$114] ; # ->
; # (set $Avail Avail)
  store i64 %640, i64* @$Avail
  br label %$105
$104:
  %645 = phi i64 [0, %$97] ; # Avail
  %646 = phi i64 [%561, %$97] ; # Heap
  %647 = phi i64 [%562, %$97] ; # Cnt
; # (loop (let P (ofs Heap (- HEAP 2)) (loop (when (& (cdr P) 1) (set...
  br label %$117
$117:
  %648 = phi i64 [%645, %$104], [%686, %$123] ; # Avail
  %649 = phi i64 [%646, %$104], [%687, %$123] ; # Heap
  %650 = phi i64 [%647, %$104], [%688, %$123] ; # Cnt
; # (let P (ofs Heap (- HEAP 2)) (loop (when (& (cdr P) 1) (set P Ava...
; # (- HEAP 2)
; # (ofs Heap (- HEAP 2))
  %651 = add i64 %649, 1048560
; # (loop (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt)...
  br label %$118
$118:
  %652 = phi i64 [%648, %$117], [%672, %$121] ; # Avail
  %653 = phi i64 [%649, %$117], [%673, %$121] ; # Heap
  %654 = phi i64 [%650, %$117], [%674, %$121] ; # Cnt
  %655 = phi i64 [%651, %$117], [%676, %$121] ; # P
; # (when (& (cdr P) 1) (set P Avail) (setq Avail P) (dec 'Cnt))
; # (cdr P)
  %656 = inttoptr i64 %655 to i64*
  %657 = getelementptr i64, i64* %656, i32 1
  %658 = load i64, i64* %657
; # (& (cdr P) 1)
  %659 = and i64 %658, 1
  %660 = icmp ne i64 %659, 0
  br i1 %660, label %$119, label %$120
$119:
  %661 = phi i64 [%652, %$118] ; # Avail
  %662 = phi i64 [%653, %$118] ; # Heap
  %663 = phi i64 [%654, %$118] ; # Cnt
  %664 = phi i64 [%655, %$118] ; # P
; # (set P Avail)
  %665 = inttoptr i64 %664 to i64*
  store i64 %661, i64* %665
; # (dec 'Cnt)
  %666 = sub i64 %663, 1
  br label %$120
$120:
  %667 = phi i64 [%652, %$118], [%664, %$119] ; # Avail
  %668 = phi i64 [%653, %$118], [%662, %$119] ; # Heap
  %669 = phi i64 [%654, %$118], [%666, %$119] ; # Cnt
  %670 = phi i64 [%655, %$118], [%664, %$119] ; # P
; # (? (== P Heap))
; # (== P Heap)
  %671 = icmp eq i64 %670, %668
  br i1 %671, label %$122, label %$121
$121:
  %672 = phi i64 [%667, %$120] ; # Avail
  %673 = phi i64 [%668, %$120] ; # Heap
  %674 = phi i64 [%669, %$120] ; # Cnt
  %675 = phi i64 [%670, %$120] ; # P
; # (ofs P -2)
  %676 = add i64 %675, -16
  br label %$118
$122:
  %677 = phi i64 [%667, %$120] ; # Avail
  %678 = phi i64 [%668, %$120] ; # Heap
  %679 = phi i64 [%669, %$120] ; # Cnt
  %680 = phi i64 [%670, %$120] ; # P
  %681 = phi i64 [0, %$120] ; # ->
; # (? (=0 (setq Heap (val (inc HEAP) Heap))))
; # (inc HEAP)
; # (val (inc HEAP) Heap)
  %682 = inttoptr i64 %678 to i64*
  %683 = getelementptr i64, i64* %682, i32 131072
  %684 = load i64, i64* %683
; # (=0 (setq Heap (val (inc HEAP) Heap)))
  %685 = icmp eq i64 %684, 0
  br i1 %685, label %$124, label %$123
$123:
  %686 = phi i64 [%677, %$122] ; # Avail
  %687 = phi i64 [%684, %$122] ; # Heap
  %688 = phi i64 [%679, %$122] ; # Cnt
  br label %$117
$124:
  %689 = phi i64 [%677, %$122] ; # Avail
  %690 = phi i64 [%684, %$122] ; # Heap
  %691 = phi i64 [%679, %$122] ; # Cnt
  %692 = phi i64 [0, %$122] ; # ->
; # (set $Avail Avail)
  store i64 %689, i64* @$Avail
; # (while (ge0 Cnt) (heapAlloc) (dec 'Cnt CELLS))
  br label %$125
$125:
  %693 = phi i64 [%689, %$124], [%697, %$126] ; # Avail
  %694 = phi i64 [%690, %$124], [%698, %$126] ; # Heap
  %695 = phi i64 [%691, %$124], [%700, %$126] ; # Cnt
; # (ge0 Cnt)
  %696 = icmp sge i64 %695, 0
  br i1 %696, label %$126, label %$127
$126:
  %697 = phi i64 [%693, %$125] ; # Avail
  %698 = phi i64 [%694, %$125] ; # Heap
  %699 = phi i64 [%695, %$125] ; # Cnt
; # (heapAlloc)
  call void @heapAlloc()
; # (dec 'Cnt CELLS)
  %700 = sub i64 %699, 65536
  br label %$125
$127:
  %701 = phi i64 [%693, %$125] ; # Avail
  %702 = phi i64 [%694, %$125] ; # Heap
  %703 = phi i64 [%695, %$125] ; # Cnt
  br label %$105
$105:
  %704 = phi i64 [%640, %$116], [%701, %$127] ; # Avail
  %705 = phi i64 [%641, %$116], [%702, %$127] ; # Heap
  %706 = phi i64 [%642, %$116], [%703, %$127] ; # Cnt
  ret void
}

define i64 @_gc(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (set $At $Nil $At2 $Nil) (if ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (set $At $Nil $At2 $Nil)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %15
; # (if (nil? Y) (gc) (set $GcCount (shl (xCnt Exe Y) 16)) (gc) (set ...
; # (nil? Y)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%3, %$2] ; # X
; # (gc)
  call void @gc()
  br label %$9
$8:
  %18 = phi i64 [%3, %$2] ; # X
; # (set $GcCount (shl (xCnt Exe Y) 16))
; # (xCnt Exe Y)
  %19 = call i64 @xCnt(i64 %0, i64 %13)
; # (shl (xCnt Exe Y) 16)
  %20 = shl i64 %19, 16
  store i64 %20, i64* @$GcCount
; # (gc)
  call void @gc()
; # (set $GcCount (if (atom (shift X)) CELLS (shl (evCnt Exe X) 16)))...
; # (if (atom (shift X)) CELLS (shl (evCnt Exe X) 16))
; # (shift X)
  %21 = inttoptr i64 %18 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (atom (shift X))
  %24 = and i64 %23, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$10, label %$11
$10:
  %26 = phi i64 [%23, %$8] ; # X
  br label %$12
$11:
  %27 = phi i64 [%23, %$8] ; # X
; # (evCnt Exe X)
  %28 = call i64 @evCnt(i64 %0, i64 %27)
; # (shl (evCnt Exe X) 16)
  %29 = shl i64 %28, 16
  br label %$12
$12:
  %30 = phi i64 [%26, %$10], [%27, %$11] ; # X
  %31 = phi i64 [65536, %$10], [%29, %$11] ; # ->
  store i64 %31, i64* @$GcCount
  br label %$9
$9:
  %32 = phi i64 [%17, %$7], [%30, %$12] ; # X
  ret i64 %13
}

define i64 @cons(i64, i64) {
$1:
; # (let P (val $Avail) (unless P (save2 Car Cdr (gc)) (setq P (val $...
; # (val $Avail)
  %2 = load i64, i64* @$Avail
; # (unless P (save2 Car Cdr (gc)) (setq P (val $Avail)))
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # P
; # (save2 Car Cdr (gc))
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %0, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = alloca i64, i64 2, align 16
  %13 = ptrtoint i64* %12 to i64
  %14 = inttoptr i64 %13 to i64*
  store i64 %1, i64* %14
  %15 = add i64 %13, 8
  %16 = inttoptr i64 %15 to i64*
  store i64 %6, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %13, i64* %17
; # (gc)
  call void @gc()
  %18 = inttoptr i64 %6 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %21
; # (val $Avail)
  %22 = load i64, i64* @$Avail
  br label %$3
$3:
  %23 = phi i64 [%2, %$1], [%22, %$2] ; # P
; # (set $Avail (car P))
; # (car P)
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  store i64 %25, i64* @$Avail
; # (set P Car)
  %26 = inttoptr i64 %23 to i64*
  store i64 %0, i64* %26
; # (set 2 P Cdr)
  %27 = inttoptr i64 %23 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %1, i64* %28
  ret i64 %23
}

define i64 @cons3(i64, i64, i64, i64) {
$1:
; # (let P (val $Avail) (when P (let Q (val P) (when Q (let R (val Q)...
; # (val $Avail)
  %4 = load i64, i64* @$Avail
; # (when P (let Q (val P) (when Q (let R (val Q) (when R (set $Avail...
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
; # (let Q (val P) (when Q (let R (val Q) (when R (set $Avail (car R)...
; # (val P)
  %6 = inttoptr i64 %4 to i64*
  %7 = load i64, i64* %6
; # (when Q (let R (val Q) (when R (set $Avail (car R)) (set P Car1) ...
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$4, label %$5
$4:
; # (let R (val Q) (when R (set $Avail (car R)) (set P Car1) (set 2 P...
; # (val Q)
  %9 = inttoptr i64 %7 to i64*
  %10 = load i64, i64* %9
; # (when R (set $Avail (car R)) (set P Car1) (set 2 P Cdr1) (set Q C...
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$7
$6:
; # (set $Avail (car R))
; # (car R)
  %12 = inttoptr i64 %10 to i64*
  %13 = load i64, i64* %12
  store i64 %13, i64* @$Avail
; # (set P Car1)
  %14 = inttoptr i64 %4 to i64*
  store i64 %0, i64* %14
; # (set 2 P Cdr1)
  %15 = inttoptr i64 %4 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  store i64 %1, i64* %16
; # (set Q Car2)
  %17 = inttoptr i64 %7 to i64*
  store i64 %2, i64* %17
; # (set 2 Q Cdr2)
  %18 = inttoptr i64 %7 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  store i64 %3, i64* %19
; # (set R P)
  %20 = inttoptr i64 %10 to i64*
  store i64 %4, i64* %20
; # (set 2 R Q)
  %21 = inttoptr i64 %10 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %7, i64* %22
; # (ret R)
  ret i64 %10
$7:
  br label %$5
$5:
  br label %$3
$3:
; # (save2 Car1 Cdr1 (save2 Car2 Cdr2 (gc)))
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %0, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %24 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %27, i64* %29
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %1, i64* %32
  %33 = add i64 %31, 8
  %34 = inttoptr i64 %33 to i64*
  store i64 %24, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %35
; # (save2 Car2 Cdr2 (gc))
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %2, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  %43 = alloca i64, i64 2, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %3, i64* %45
  %46 = add i64 %44, 8
  %47 = inttoptr i64 %46 to i64*
  store i64 %37, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %48
; # (gc)
  call void @gc()
  %49 = inttoptr i64 %37 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %52
  %53 = inttoptr i64 %24 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
; # (let (P (val $Avail) Q (val P) R (val Q)) (set $Avail (car R)) (s...
; # (val $Avail)
  %57 = load i64, i64* @$Avail
; # (val P)
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (val Q)
  %60 = inttoptr i64 %59 to i64*
  %61 = load i64, i64* %60
; # (set $Avail (car R))
; # (car R)
  %62 = inttoptr i64 %61 to i64*
  %63 = load i64, i64* %62
  store i64 %63, i64* @$Avail
; # (set P Car1)
  %64 = inttoptr i64 %57 to i64*
  store i64 %0, i64* %64
; # (set 2 P Cdr1)
  %65 = inttoptr i64 %57 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  store i64 %1, i64* %66
; # (set Q Car2)
  %67 = inttoptr i64 %59 to i64*
  store i64 %2, i64* %67
; # (set 2 Q Cdr2)
  %68 = inttoptr i64 %59 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %3, i64* %69
; # (set R P)
  %70 = inttoptr i64 %61 to i64*
  store i64 %57, i64* %70
; # (set 2 R Q)
  %71 = inttoptr i64 %61 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  store i64 %59, i64* %72
  ret i64 %61
}

define i64 @consSym(i64, i64) {
$1:
; # (let P (val $Avail) (unless P (if Val (save2 Name Val (gc)) (save...
; # (val $Avail)
  %2 = load i64, i64* @$Avail
; # (unless P (if Val (save2 Name Val (gc)) (save Name (gc))) (setq P...
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # P
; # (if Val (save2 Name Val (gc)) (save Name (gc)))
  %5 = icmp ne i64 %1, 0
  br i1 %5, label %$4, label %$5
$4:
  %6 = phi i64 [%4, %$2] ; # P
; # (save2 Name Val (gc))
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %0, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %11 = load i64, i64* %10
  %12 = inttoptr i64 %8 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  store i64 %11, i64* %13
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %1, i64* %16
  %17 = add i64 %15, 8
  %18 = inttoptr i64 %17 to i64*
  store i64 %8, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %19
; # (gc)
  call void @gc()
  %20 = inttoptr i64 %8 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %23
  br label %$6
$5:
  %24 = phi i64 [%4, %$2] ; # P
; # (save Name (gc))
  %25 = alloca i64, i64 2, align 16
  %26 = ptrtoint i64* %25 to i64
  %27 = inttoptr i64 %26 to i64*
  store i64 %0, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %26 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  store i64 %29, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %32
; # (gc)
  call void @gc()
  %33 = inttoptr i64 %26 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %35, i64* %36
  br label %$6
$6:
  %37 = phi i64 [%6, %$4], [%24, %$5] ; # P
; # (val $Avail)
  %38 = load i64, i64* @$Avail
  br label %$3
$3:
  %39 = phi i64 [%2, %$1], [%38, %$6] ; # P
; # (set $Avail (car P))
; # (car P)
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
  store i64 %41, i64* @$Avail
; # (set P Name)
  %42 = inttoptr i64 %39 to i64*
  store i64 %0, i64* %42
; # (let S (sym P) (set S (if Val @ S)) S)
; # (sym P)
  %43 = or i64 %39, 8
; # (set S (if Val @ S))
; # (if Val @ S)
  %44 = icmp ne i64 %1, 0
  br i1 %44, label %$7, label %$8
$7:
  %45 = phi i64 [%39, %$3] ; # P
  br label %$9
$8:
  %46 = phi i64 [%39, %$3] ; # P
  br label %$9
$9:
  %47 = phi i64 [%45, %$7], [%46, %$8] ; # P
  %48 = phi i64 [%1, %$7], [%43, %$8] ; # ->
  %49 = inttoptr i64 %43 to i64*
  store i64 %48, i64* %49
  ret i64 %43
}

define i64 @consStr(i64) {
$1:
; # (if (== Name ZERO) $Nil (consSym Name 0))
; # (== Name ZERO)
  %1 = icmp eq i64 %0, 2
  br i1 %1, label %$2, label %$3
$2:
  br label %$4
$3:
; # (consSym Name 0)
  %2 = call i64 @consSym(i64 %0, i64 0)
  br label %$4
$4:
  %3 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%2, %$3] ; # ->
  ret i64 %3
}

define i64 @consExt(i64) {
$1:
; # (set $ExtCnt (+ (val $ExtCnt) 1))
; # (val $ExtCnt)
  %1 = load i64, i64* @$ExtCnt
; # (+ (val $ExtCnt) 1)
  %2 = add i64 %1, 1
  store i64 %2, i64* @$ExtCnt
; # (sign Name)
  %3 = or i64 %0, 8
; # (consSym (sign Name) $Nil)
  %4 = call i64 @consSym(i64 %3, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  ret i64 %4
}

define i64 @boxNum(i64) {
$1:
; # (let P (val $Avail) (unless P (gc) (setq P (val $Avail))) (set $A...
; # (val $Avail)
  %1 = load i64, i64* @$Avail
; # (unless P (gc) (setq P (val $Avail)))
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i64 [%1, %$1] ; # P
; # (gc)
  call void @gc()
; # (val $Avail)
  %4 = load i64, i64* @$Avail
  br label %$3
$3:
  %5 = phi i64 [%1, %$1], [%4, %$2] ; # P
; # (set $Avail (car P))
; # (car P)
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
  store i64 %7, i64* @$Avail
; # (set P Dig)
  %8 = inttoptr i64 %5 to i64*
  store i64 %0, i64* %8
; # (set 2 P ZERO)
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 2, i64* %10
; # (big P)
  %11 = add i64 %5, 4
  ret i64 %11
}

define i64 @consNum(i64, i64) {
$1:
; # (let P (val $Avail) (unless P (save Big (gc)) (setq P (val $Avail...
; # (val $Avail)
  %2 = load i64, i64* @$Avail
; # (unless P (save Big (gc)) (setq P (val $Avail)))
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i64 [%2, %$1] ; # P
; # (save Big (gc))
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %1, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %12
; # (gc)
  call void @gc()
  %13 = inttoptr i64 %6 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %16
; # (val $Avail)
  %17 = load i64, i64* @$Avail
  br label %$3
$3:
  %18 = phi i64 [%2, %$1], [%17, %$2] ; # P
; # (set $Avail (car P))
; # (car P)
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  store i64 %20, i64* @$Avail
; # (set P Dig)
  %21 = inttoptr i64 %18 to i64*
  store i64 %0, i64* %21
; # (set 2 P Big)
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %1, i64* %23
; # (big P)
  %24 = add i64 %18, 4
  ret i64 %24
}

define i64 @box(i64) {
$1:
; # (if (ge0 N) (box64 N) (sign (box64 (- N))))
; # (ge0 N)
  %1 = icmp sge i64 %0, 0
  br i1 %1, label %$2, label %$3
$2:
; # (box64 N)
  %2 = and i64 %0, 17293822569102704640
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$5, label %$6
$5:
  %4 = call i64 @boxNum(i64 %0)
  br label %$7
$6:
  %5 = shl i64 %0, 4
  %6 = or i64 %5, 2
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%6, %$6] ; # ->
  br label %$4
$3:
; # (- N)
  %8 = sub i64 0, %0
; # (box64 (- N))
  %9 = and i64 %8, 17293822569102704640
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$8, label %$9
$8:
  %11 = call i64 @boxNum(i64 %8)
  br label %$10
$9:
  %12 = shl i64 %8, 4
  %13 = or i64 %12, 2
  br label %$10
$10:
  %14 = phi i64 [%11, %$8], [%13, %$9] ; # ->
; # (sign (box64 (- N)))
  %15 = or i64 %14, 8
  br label %$4
$4:
  %16 = phi i64 [%7, %$7], [%15, %$10] ; # ->
  ret i64 %16
}

define void @divErr(i64) {
$1:
; # (err Exe 0 ($ "Div/0") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([6 x i8]* @$25 to i8*), i8* null)
  unreachable
}

define i8 @symByte(i64*) {
$1:
; # (let C (val P) (unless C (let Nm (val 2 P) (cond ((== Nm ZERO) (r...
; # (val P)
  %1 = load i64, i64* %0
; # (unless C (let Nm (val 2 P) (cond ((== Nm ZERO) (ret (i8 0))) ((c...
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i64 [%1, %$1] ; # C
; # (let Nm (val 2 P) (cond ((== Nm ZERO) (ret (i8 0))) ((cnt? Nm) (s...
; # (val 2 P)
  %4 = getelementptr i64, i64* %0, i32 1
  %5 = load i64, i64* %4
; # (cond ((== Nm ZERO) (ret (i8 0))) ((cnt? Nm) (setq C (int Nm)) (s...
; # (== Nm ZERO)
  %6 = icmp eq i64 %5, 2
  br i1 %6, label %$6, label %$5
$6:
  %7 = phi i64 [%3, %$2] ; # C
; # (i8 0)
; # (ret (i8 0))
  ret i8 0
$5:
  %8 = phi i64 [%3, %$2] ; # C
; # (cnt? Nm)
  %9 = and i64 %5, 2
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$8, label %$7
$8:
  %11 = phi i64 [%8, %$5] ; # C
; # (int Nm)
  %12 = lshr i64 %5, 4
; # (set 2 P ZERO)
  %13 = getelementptr i64, i64* %0, i32 1
  store i64 2, i64* %13
  br label %$4
$7:
  %14 = phi i64 [%8, %$5] ; # C
; # (set P (val (dig Nm)))
; # (dig Nm)
  %15 = add i64 %5, -4
; # (val (dig Nm))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
  store i64 %17, i64* %0
; # (set 2 P (val (big Nm)))
; # (big Nm)
  %18 = add i64 %5, 4
; # (val (big Nm))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = getelementptr i64, i64* %0, i32 1
  store i64 %20, i64* %21
  br label %$4
$4:
  %22 = phi i64 [%12, %$8], [%17, %$7] ; # C
  %23 = phi i64 [2, %$8], [%20, %$7] ; # ->
  br label %$3
$3:
  %24 = phi i64 [%1, %$1], [%22, %$4] ; # C
; # (set P (shr C 8))
; # (shr C 8)
  %25 = lshr i64 %24, 8
  store i64 %25, i64* %0
; # (i8 C)
  %26 = trunc i64 %24 to i8
  ret i8 %26
}

define i32 @symChar(i64*) {
$1:
; # (let C (i32 (symByte P)) (cond ((>= 127 C) C) ((== C (hex "FF")) ...
; # (symByte P)
  %1 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %2 = zext i8 %1 to i32
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (| (shl (if...
; # (>= 127 C)
  %3 = icmp sge i32 127, %2
  br i1 %3, label %$4, label %$3
$4:
  br label %$2
$3:
; # (== C (hex "FF"))
  %4 = icmp eq i32 %2, 255
  br i1 %4, label %$6, label %$5
$6:
; # (i32 TOP)
  br label %$2
$5:
; # (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (hex "10...
; # (& C (hex "20"))
  %5 = and i32 %2, 32
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %$8, label %$7
$7:
; # (& C (hex "1F"))
  %7 = and i32 %2, 31
  br label %$9
$8:
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7")) 6)...
; # (& C (hex "10"))
  %8 = and i32 %2, 16
  %9 = icmp ne i32 %8, 0
  br i1 %9, label %$11, label %$10
$10:
; # (& C (hex "0F"))
  %10 = and i32 %2, 15
  br label %$12
$11:
; # (& C (hex "7"))
  %11 = and i32 %2, 7
; # (shl (& C (hex "7")) 6)
  %12 = shl i32 %11, 6
; # (symByte P)
  %13 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %14 = zext i8 %13 to i32
; # (& (i32 (symByte P)) (hex "3F"))
  %15 = and i32 %14, 63
; # (| (shl (& C (hex "7")) 6) (& (i32 (symByte P)) (hex "3F")))
  %16 = or i32 %12, %15
  br label %$12
$12:
  %17 = phi i32 [%10, %$10], [%16, %$11] ; # ->
; # (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7"...
  %18 = shl i32 %17, 6
; # (symByte P)
  %19 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %20 = zext i8 %19 to i32
; # (& (i32 (symByte P)) (hex "3F"))
  %21 = and i32 %20, 63
; # (| (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex ...
  %22 = or i32 %18, %21
  br label %$9
$9:
  %23 = phi i32 [%7, %$7], [%22, %$12] ; # ->
; # (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (he...
  %24 = shl i32 %23, 6
; # (symByte P)
  %25 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %26 = zext i8 %25 to i32
; # (& (i32 (symByte P)) (hex "3F"))
  %27 = and i32 %26, 63
; # (| (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C ...
  %28 = or i32 %24, %27
  br label %$2
$2:
  %29 = phi i32 [%2, %$4], [1114112, %$6], [%28, %$9] ; # ->
  ret i32 %29
}

define void @byteNum(i8, i64*) {
$1:
; # (let (Cnt (val P) Nm (val 3 P)) (if (cnt? Nm) (cond ((== Cnt 67) ...
; # (val P)
  %2 = load i64, i64* %1
; # (val 3 P)
  %3 = getelementptr i64, i64* %1, i32 2
  %4 = load i64, i64* %3
; # (if (cnt? Nm) (cond ((== Cnt 67) (set 3 P (set 2 P (consNum (shr ...
; # (cnt? Nm)
  %5 = and i64 %4, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$2, label %$3
$2:
; # (cond ((== Cnt 67) (set 3 P (set 2 P (consNum (shr Nm 3) (cnt (i6...
; # (== Cnt 67)
  %7 = icmp eq i64 %2, 67
  br i1 %7, label %$7, label %$6
$7:
; # (set 3 P (set 2 P (consNum (shr Nm 3) (cnt (i64 B)))))
; # (set 2 P (consNum (shr Nm 3) (cnt (i64 B))))
; # (shr Nm 3)
  %8 = lshr i64 %4, 3
; # (i64 B)
  %9 = zext i8 %0 to i64
; # (cnt (i64 B))
  %10 = shl i64 %9, 4
  %11 = or i64 %10, 2
; # (consNum (shr Nm 3) (cnt (i64 B)))
  %12 = call i64 @consNum(i64 %8, i64 %11)
  %13 = getelementptr i64, i64* %1, i32 1
  store i64 %12, i64* %13
  %14 = getelementptr i64, i64* %1, i32 2
  store i64 %12, i64* %14
; # (set P 12)
  store i64 12, i64* %1
  br label %$5
$6:
; # (and (== Cnt 59) (>= B 32))
; # (== Cnt 59)
  %15 = icmp eq i64 %2, 59
  br i1 %15, label %$9, label %$8
$9:
; # (>= B 32)
  %16 = icmp uge i8 %0, 32
  br label %$8
$8:
  %17 = phi i1 [0, %$6], [%16, %$9] ; # ->
  br i1 %17, label %$11, label %$10
$11:
; # (set 3 P (set 2 P (boxNum (| (shr Nm 3) (shl (i64 B) 56)))))
; # (set 2 P (boxNum (| (shr Nm 3) (shl (i64 B) 56))))
; # (shr Nm 3)
  %18 = lshr i64 %4, 3
; # (i64 B)
  %19 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %20 = shl i64 %19, 56
; # (| (shr Nm 3) (shl (i64 B) 56))
  %21 = or i64 %18, %20
; # (boxNum (| (shr Nm 3) (shl (i64 B) 56)))
  %22 = call i64 @boxNum(i64 %21)
  %23 = getelementptr i64, i64* %1, i32 1
  store i64 %22, i64* %23
  %24 = getelementptr i64, i64* %1, i32 2
  store i64 %22, i64* %24
; # (set P 4)
  store i64 4, i64* %1
  br label %$5
$10:
; # (set 3 P (| Nm (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (i64 B)
  %25 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %26 = shl i64 %25, %2
; # (| Nm (shl (i64 B) Cnt))
  %27 = or i64 %4, %26
  %28 = getelementptr i64, i64* %1, i32 2
  store i64 %27, i64* %28
; # (+ Cnt 8)
  %29 = add i64 %2, 8
  store i64 %29, i64* %1
  br label %$5
$5:
  %30 = phi i64 [12, %$7], [4, %$11], [%29, %$10] ; # ->
  br label %$4
$3:
; # (let (Q (val 2 P) N (val (big Q))) (cond ((== Cnt 68) (set 2 P (s...
; # (val 2 P)
  %31 = getelementptr i64, i64* %1, i32 1
  %32 = load i64, i64* %31
; # (big Q)
  %33 = add i64 %32, 4
; # (val (big Q))
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (cond ((== Cnt 68) (set 2 P (set (big Q) (consNum (int N) (cnt (i...
; # (== Cnt 68)
  %36 = icmp eq i64 %2, 68
  br i1 %36, label %$14, label %$13
$14:
; # (set 2 P (set (big Q) (consNum (int N) (cnt (i64 B)))))
; # (set (big Q) (consNum (int N) (cnt (i64 B))))
; # (big Q)
  %37 = add i64 %32, 4
; # (int N)
  %38 = lshr i64 %35, 4
; # (i64 B)
  %39 = zext i8 %0 to i64
; # (cnt (i64 B))
  %40 = shl i64 %39, 4
  %41 = or i64 %40, 2
; # (consNum (int N) (cnt (i64 B)))
  %42 = call i64 @consNum(i64 %38, i64 %41)
  %43 = inttoptr i64 %37 to i64*
  store i64 %42, i64* %43
  %44 = getelementptr i64, i64* %1, i32 1
  store i64 %42, i64* %44
; # (set P 12)
  store i64 12, i64* %1
  br label %$12
$13:
; # (and (== Cnt 60) (>= B 16))
; # (== Cnt 60)
  %45 = icmp eq i64 %2, 60
  br i1 %45, label %$16, label %$15
$16:
; # (>= B 16)
  %46 = icmp uge i8 %0, 16
  br label %$15
$15:
  %47 = phi i1 [0, %$13], [%46, %$16] ; # ->
  br i1 %47, label %$18, label %$17
$18:
; # (set 2 P (set (big Q) (boxNum (| (int N) (shl (i64 B) 56)))))
; # (set (big Q) (boxNum (| (int N) (shl (i64 B) 56))))
; # (big Q)
  %48 = add i64 %32, 4
; # (int N)
  %49 = lshr i64 %35, 4
; # (i64 B)
  %50 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %51 = shl i64 %50, 56
; # (| (int N) (shl (i64 B) 56))
  %52 = or i64 %49, %51
; # (boxNum (| (int N) (shl (i64 B) 56)))
  %53 = call i64 @boxNum(i64 %52)
  %54 = inttoptr i64 %48 to i64*
  store i64 %53, i64* %54
  %55 = getelementptr i64, i64* %1, i32 1
  store i64 %53, i64* %55
; # (set P 4)
  store i64 4, i64* %1
  br label %$12
$17:
; # (set (big Q) (| N (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (big Q)
  %56 = add i64 %32, 4
; # (i64 B)
  %57 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %58 = shl i64 %57, %2
; # (| N (shl (i64 B) Cnt))
  %59 = or i64 %35, %58
  %60 = inttoptr i64 %56 to i64*
  store i64 %59, i64* %60
; # (+ Cnt 8)
  %61 = add i64 %2, 8
  store i64 %61, i64* %1
  br label %$12
$12:
  %62 = phi i64 [12, %$14], [4, %$18], [%61, %$17] ; # ->
  br label %$4
$4:
  %63 = phi i64 [%30, %$5], [%62, %$12] ; # ->
  ret void
}

define void @byteSym(i8, i64*) {
$1:
; # (let (Cnt (val P) Nm (val 3 P)) (if (cnt? Nm) (if (> 60 Cnt) (set...
; # (val P)
  %2 = load i64, i64* %1
; # (val 3 P)
  %3 = getelementptr i64, i64* %1, i32 2
  %4 = load i64, i64* %3
; # (if (cnt? Nm) (if (> 60 Cnt) (set 3 P (| Nm (shl (i64 B) Cnt)) P ...
; # (cnt? Nm)
  %5 = and i64 %4, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$2, label %$3
$2:
; # (if (> 60 Cnt) (set 3 P (| Nm (shl (i64 B) Cnt)) P (+ Cnt 8)) (se...
; # (> 60 Cnt)
  %7 = icmp ugt i64 60, %2
  br i1 %7, label %$5, label %$6
$5:
; # (set 3 P (| Nm (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (i64 B)
  %8 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %9 = shl i64 %8, %2
; # (| Nm (shl (i64 B) Cnt))
  %10 = or i64 %4, %9
  %11 = getelementptr i64, i64* %1, i32 2
  store i64 %10, i64* %11
; # (+ Cnt 8)
  %12 = add i64 %2, 8
  store i64 %12, i64* %1
  br label %$7
$6:
; # (set 3 P (set 2 P (boxNum (| (int Nm) (shl (i64 B) 56)))))
; # (set 2 P (boxNum (| (int Nm) (shl (i64 B) 56))))
; # (int Nm)
  %13 = lshr i64 %4, 4
; # (i64 B)
  %14 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %15 = shl i64 %14, 56
; # (| (int Nm) (shl (i64 B) 56))
  %16 = or i64 %13, %15
; # (boxNum (| (int Nm) (shl (i64 B) 56)))
  %17 = call i64 @boxNum(i64 %16)
  %18 = getelementptr i64, i64* %1, i32 1
  store i64 %17, i64* %18
  %19 = getelementptr i64, i64* %1, i32 2
  store i64 %17, i64* %19
; # (set P 4)
  store i64 4, i64* %1
  br label %$7
$7:
  %20 = phi i64 [%12, %$5], [4, %$6] ; # ->
  br label %$4
$3:
; # (let (Q (val 2 P) N (val (big Q))) (if (> 60 Cnt) (set (big Q) (|...
; # (val 2 P)
  %21 = getelementptr i64, i64* %1, i32 1
  %22 = load i64, i64* %21
; # (big Q)
  %23 = add i64 %22, 4
; # (val (big Q))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
; # (if (> 60 Cnt) (set (big Q) (| N (shl (i64 B) Cnt)) P (+ Cnt 8)) ...
; # (> 60 Cnt)
  %26 = icmp ugt i64 60, %2
  br i1 %26, label %$8, label %$9
$8:
; # (set (big Q) (| N (shl (i64 B) Cnt)) P (+ Cnt 8))
; # (big Q)
  %27 = add i64 %22, 4
; # (i64 B)
  %28 = zext i8 %0 to i64
; # (shl (i64 B) Cnt)
  %29 = shl i64 %28, %2
; # (| N (shl (i64 B) Cnt))
  %30 = or i64 %25, %29
  %31 = inttoptr i64 %27 to i64*
  store i64 %30, i64* %31
; # (+ Cnt 8)
  %32 = add i64 %2, 8
  store i64 %32, i64* %1
  br label %$10
$9:
; # (set 2 P (set (big Q) (boxNum (| (int N) (shl (i64 B) 56)))))
; # (set (big Q) (boxNum (| (int N) (shl (i64 B) 56))))
; # (big Q)
  %33 = add i64 %22, 4
; # (int N)
  %34 = lshr i64 %25, 4
; # (i64 B)
  %35 = zext i8 %0 to i64
; # (shl (i64 B) 56)
  %36 = shl i64 %35, 56
; # (| (int N) (shl (i64 B) 56))
  %37 = or i64 %34, %36
; # (boxNum (| (int N) (shl (i64 B) 56)))
  %38 = call i64 @boxNum(i64 %37)
  %39 = inttoptr i64 %33 to i64*
  store i64 %38, i64* %39
  %40 = getelementptr i64, i64* %1, i32 1
  store i64 %38, i64* %40
; # (set P 4)
  store i64 4, i64* %1
  br label %$10
$10:
  %41 = phi i64 [%32, %$8], [4, %$9] ; # ->
  br label %$4
$4:
  %42 = phi i64 [%20, %$7], [%41, %$10] ; # ->
  ret void
}

define void @charSym(i32, i64*) {
$1:
; # (cond ((>= 127 C) (byteSym (i8 C) P)) ((== TOP C) (byteSym (hex "...
; # (>= 127 C)
  %2 = icmp sge i32 127, %0
  br i1 %2, label %$4, label %$3
$4:
; # (i8 C)
  %3 = trunc i32 %0 to i8
; # (byteSym (i8 C) P)
  call void @byteSym(i8 %3, i64* %1)
  br label %$2
$3:
; # (== TOP C)
  %4 = icmp eq i32 1114112, %0
  br i1 %4, label %$6, label %$5
$6:
; # (byteSym (hex "FF") P)
  call void @byteSym(i8 255, i64* %1)
  br label %$2
$5:
; # (cond ((> (hex "800") C) (byteSym (i8 (| (hex "C0") (& (shr C 6) ...
; # (> (hex "800") C)
  %5 = icmp sgt i32 2048, %0
  br i1 %5, label %$9, label %$8
$9:
; # (shr C 6)
  %6 = lshr i32 %0, 6
; # (& (shr C 6) (hex "1F"))
  %7 = and i32 %6, 31
; # (| (hex "C0") (& (shr C 6) (hex "1F")))
  %8 = or i32 192, %7
; # (i8 (| (hex "C0") (& (shr C 6) (hex "1F"))))
  %9 = trunc i32 %8 to i8
; # (byteSym (i8 (| (hex "C0") (& (shr C 6) (hex "1F")))) P)
  call void @byteSym(i8 %9, i64* %1)
  br label %$7
$8:
; # (> (hex "10000") C)
  %10 = icmp sgt i32 65536, %0
  br i1 %10, label %$11, label %$10
$11:
; # (shr C 12)
  %11 = lshr i32 %0, 12
; # (& (shr C 12) (hex "0F"))
  %12 = and i32 %11, 15
; # (| (hex "E0") (& (shr C 12) (hex "0F")))
  %13 = or i32 224, %12
; # (i8 (| (hex "E0") (& (shr C 12) (hex "0F"))))
  %14 = trunc i32 %13 to i8
; # (byteSym (i8 (| (hex "E0") (& (shr C 12) (hex "0F")))) P)
  call void @byteSym(i8 %14, i64* %1)
; # (shr C 6)
  %15 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %16 = and i32 %15, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %17 = or i32 128, %16
; # (i8 (| (hex "80") (& (shr C 6) (hex "3F"))))
  %18 = trunc i32 %17 to i8
; # (byteSym (i8 (| (hex "80") (& (shr C 6) (hex "3F")))) P)
  call void @byteSym(i8 %18, i64* %1)
  br label %$7
$10:
; # (shr C 18)
  %19 = lshr i32 %0, 18
; # (& (shr C 18) (hex "07"))
  %20 = and i32 %19, 7
; # (| (hex "F0") (& (shr C 18) (hex "07")))
  %21 = or i32 240, %20
; # (i8 (| (hex "F0") (& (shr C 18) (hex "07"))))
  %22 = trunc i32 %21 to i8
; # (byteSym (i8 (| (hex "F0") (& (shr C 18) (hex "07")))) P)
  call void @byteSym(i8 %22, i64* %1)
; # (shr C 12)
  %23 = lshr i32 %0, 12
; # (& (shr C 12) (hex "3F"))
  %24 = and i32 %23, 63
; # (| (hex "80") (& (shr C 12) (hex "3F")))
  %25 = or i32 128, %24
; # (i8 (| (hex "80") (& (shr C 12) (hex "3F"))))
  %26 = trunc i32 %25 to i8
; # (byteSym (i8 (| (hex "80") (& (shr C 12) (hex "3F")))) P)
  call void @byteSym(i8 %26, i64* %1)
; # (shr C 6)
  %27 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %28 = and i32 %27, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %29 = or i32 128, %28
; # (i8 (| (hex "80") (& (shr C 6) (hex "3F"))))
  %30 = trunc i32 %29 to i8
; # (byteSym (i8 (| (hex "80") (& (shr C 6) (hex "3F")))) P)
  call void @byteSym(i8 %30, i64* %1)
  br label %$7
$7:
; # (& C (hex "3F"))
  %31 = and i32 %0, 63
; # (| (hex "80") (& C (hex "3F")))
  %32 = or i32 128, %31
; # (i8 (| (hex "80") (& C (hex "3F"))))
  %33 = trunc i32 %32 to i8
; # (byteSym (i8 (| (hex "80") (& C (hex "3F")))) P)
  call void @byteSym(i8 %33, i64* %1)
  br label %$2
$2:
  ret void
}

define i64 @zapZero(i64) {
$1:
; # (let (P (push N) X P Y P Z T) (until (cnt? (setq Z (val (big N)))...
; # (push N)
  %1 = alloca i64, i64 1
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 %2 to i64*
  store i64 %0, i64* %3
; # (until (cnt? (setq Z (val (big N)))) (when (val (dig N)) (setq X ...
  br label %$2
$2:
  %4 = phi i64 [%0, %$1], [%30, %$6] ; # N
  %5 = phi i64 [%2, %$1], [%25, %$6] ; # X
  %6 = phi i64 [%2, %$1], [%28, %$6] ; # Y
; # (big N)
  %7 = add i64 %4, 4
; # (val (big N))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (cnt? (setq Z (val (big N))))
  %10 = and i64 %9, 2
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i64 [%4, %$2] ; # N
  %13 = phi i64 [%5, %$2] ; # X
  %14 = phi i64 [%6, %$2] ; # Y
  %15 = phi i64 [%9, %$2] ; # Z
; # (when (val (dig N)) (setq X Y))
; # (dig N)
  %16 = add i64 %12, -4
; # (val (dig N))
  %17 = inttoptr i64 %16 to i64*
  %18 = load i64, i64* %17
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$5, label %$6
$5:
  %20 = phi i64 [%12, %$3] ; # N
  %21 = phi i64 [%13, %$3] ; # X
  %22 = phi i64 [%14, %$3] ; # Y
  %23 = phi i64 [%15, %$3] ; # Z
  br label %$6
$6:
  %24 = phi i64 [%12, %$3], [%20, %$5] ; # N
  %25 = phi i64 [%13, %$3], [%22, %$5] ; # X
  %26 = phi i64 [%14, %$3], [%22, %$5] ; # Y
  %27 = phi i64 [%15, %$3], [%23, %$5] ; # Z
; # (big N)
  %28 = add i64 %24, 4
; # (val Y)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  br label %$2
$4:
  %31 = phi i64 [%4, %$2] ; # N
  %32 = phi i64 [%5, %$2] ; # X
  %33 = phi i64 [%6, %$2] ; # Y
  %34 = phi i64 [%9, %$2] ; # Z
; # (when (== Z ZERO) (cond ((setq N (val (dig N))) (unless (& N (hex...
; # (== Z ZERO)
  %35 = icmp eq i64 %34, 2
  br i1 %35, label %$7, label %$8
$7:
  %36 = phi i64 [%31, %$4] ; # N
  %37 = phi i64 [%32, %$4] ; # X
  %38 = phi i64 [%33, %$4] ; # Y
  %39 = phi i64 [%34, %$4] ; # Z
; # (cond ((setq N (val (dig N))) (unless (& N (hex "F000000000000000...
; # (dig N)
  %40 = add i64 %36, -4
; # (val (dig N))
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$11, label %$10
$11:
  %44 = phi i64 [%42, %$7] ; # N
  %45 = phi i64 [%37, %$7] ; # X
  %46 = phi i64 [%38, %$7] ; # Y
  %47 = phi i64 [%39, %$7] ; # Z
; # (unless (& N (hex "F000000000000000")) (set Y (cnt N)))
; # (& N (hex "F000000000000000"))
  %48 = and i64 %44, 17293822569102704640
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$13, label %$12
$12:
  %50 = phi i64 [%44, %$11] ; # N
  %51 = phi i64 [%45, %$11] ; # X
  %52 = phi i64 [%46, %$11] ; # Y
  %53 = phi i64 [%47, %$11] ; # Z
; # (set Y (cnt N))
; # (cnt N)
  %54 = shl i64 %50, 4
  %55 = or i64 %54, 2
  %56 = inttoptr i64 %52 to i64*
  store i64 %55, i64* %56
  br label %$13
$13:
  %57 = phi i64 [%44, %$11], [%50, %$12] ; # N
  %58 = phi i64 [%45, %$11], [%51, %$12] ; # X
  %59 = phi i64 [%46, %$11], [%52, %$12] ; # Y
  %60 = phi i64 [%47, %$11], [%53, %$12] ; # Z
  br label %$9
$10:
  %61 = phi i64 [%42, %$7] ; # N
  %62 = phi i64 [%37, %$7] ; # X
  %63 = phi i64 [%38, %$7] ; # Y
  %64 = phi i64 [%39, %$7] ; # Z
; # (val X)
  %65 = inttoptr i64 %62 to i64*
  %66 = load i64, i64* %65
; # (dig (val X))
  %67 = add i64 %66, -4
; # (val (dig (val X)))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (& (setq N (val (dig (val X)))) (hex "F000000000000000"))
  %70 = and i64 %69, 17293822569102704640
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$15, label %$14
$15:
  %72 = phi i64 [%69, %$10] ; # N
  %73 = phi i64 [%62, %$10] ; # X
  %74 = phi i64 [%63, %$10] ; # Y
  %75 = phi i64 [%64, %$10] ; # Z
; # (set (big (val X)) ZERO)
; # (val X)
  %76 = inttoptr i64 %73 to i64*
  %77 = load i64, i64* %76
; # (big (val X))
  %78 = add i64 %77, 4
  %79 = inttoptr i64 %78 to i64*
  store i64 2, i64* %79
  br label %$9
$14:
  %80 = phi i64 [%69, %$10] ; # N
  %81 = phi i64 [%62, %$10] ; # X
  %82 = phi i64 [%63, %$10] ; # Y
  %83 = phi i64 [%64, %$10] ; # Z
; # (set X (cnt N))
; # (cnt N)
  %84 = shl i64 %80, 4
  %85 = or i64 %84, 2
  %86 = inttoptr i64 %81 to i64*
  store i64 %85, i64* %86
  br label %$9
$9:
  %87 = phi i64 [%57, %$13], [%72, %$15], [%80, %$14] ; # N
  %88 = phi i64 [%58, %$13], [%73, %$15], [%81, %$14] ; # X
  %89 = phi i64 [%59, %$13], [%74, %$15], [%82, %$14] ; # Y
  %90 = phi i64 [%60, %$13], [%75, %$15], [%83, %$14] ; # Z
  br label %$8
$8:
  %91 = phi i64 [%31, %$4], [%87, %$9] ; # N
  %92 = phi i64 [%32, %$4], [%88, %$9] ; # X
  %93 = phi i64 [%33, %$4], [%89, %$9] ; # Y
  %94 = phi i64 [%34, %$4], [%90, %$9] ; # Z
; # (val P)
  %95 = inttoptr i64 %2 to i64*
  %96 = load i64, i64* %95
  ret i64 %96
}

define i64 @twiceBig(i64) {
$1:
; # (let (X N A (val (dig X)) Y (val (big X))) (set (dig X) (shl A 1)...
; # (dig X)
  %1 = add i64 %0, -4
; # (val (dig X))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (big X)
  %4 = add i64 %0, 4
; # (val (big X))
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (set (dig X) (shl A 1))
; # (dig X)
  %7 = add i64 %0, -4
; # (shl A 1)
  %8 = shl i64 %3, 1
  %9 = inttoptr i64 %7 to i64*
  store i64 %8, i64* %9
; # (while (big? Y) (let B (val (dig Y)) (set (dig (setq X Y)) (| (sh...
  br label %$2
$2:
  %10 = phi i64 [%0, %$1], [%17, %$3] ; # X
  %11 = phi i64 [%3, %$1], [%20, %$3] ; # A
  %12 = phi i64 [%6, %$1], [%28, %$3] ; # Y
; # (big? Y)
  %13 = and i64 %12, 4
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$3, label %$4
$3:
  %15 = phi i64 [%10, %$2] ; # X
  %16 = phi i64 [%11, %$2] ; # A
  %17 = phi i64 [%12, %$2] ; # Y
; # (let B (val (dig Y)) (set (dig (setq X Y)) (| (shl B 1) (shl 0 A ...
; # (dig Y)
  %18 = add i64 %17, -4
; # (val (dig Y))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (set (dig (setq X Y)) (| (shl B 1) (shl 0 A 1)))
; # (dig (setq X Y))
  %21 = add i64 %17, -4
; # (shl B 1)
  %22 = shl i64 %20, 1
; # (shl 0 A 1)
  %23 = call i64 @llvm.fshl.i64(i64 0, i64 %16, i64 1)
; # (| (shl B 1) (shl 0 A 1))
  %24 = or i64 %22, %23
  %25 = inttoptr i64 %21 to i64*
  store i64 %24, i64* %25
; # (big Y)
  %26 = add i64 %17, 4
; # (val (big Y))
  %27 = inttoptr i64 %26 to i64*
  %28 = load i64, i64* %27
  br label %$2
$4:
  %29 = phi i64 [%10, %$2] ; # X
  %30 = phi i64 [%11, %$2] ; # A
  %31 = phi i64 [%12, %$2] ; # Y
; # (set (big X) (box64 (| (shl (int Y) 1) (shl 0 A 1))))
; # (big X)
  %32 = add i64 %29, 4
; # (int Y)
  %33 = lshr i64 %31, 4
; # (shl (int Y) 1)
  %34 = shl i64 %33, 1
; # (shl 0 A 1)
  %35 = call i64 @llvm.fshl.i64(i64 0, i64 %30, i64 1)
; # (| (shl (int Y) 1) (shl 0 A 1))
  %36 = or i64 %34, %35
; # (box64 (| (shl (int Y) 1) (shl 0 A 1)))
  %37 = and i64 %36, 17293822569102704640
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$5, label %$6
$5:
  %39 = call i64 @boxNum(i64 %36)
  br label %$7
$6:
  %40 = shl i64 %36, 4
  %41 = or i64 %40, 2
  br label %$7
$7:
  %42 = phi i64 [%39, %$5], [%41, %$6] ; # ->
  %43 = inttoptr i64 %32 to i64*
  store i64 %42, i64* %43
  ret i64 %0
}

define i64 @twice(i64) {
$1:
; # (if (cnt? N) (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6))...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6)))
; # (add N N)
  %3 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %0, i64 %0)
  %4 = extractvalue {i64, i1} %3, 1
  %5 = extractvalue {i64, i1} %3, 0
; # (if @@ (boxNum (shr N 3)) (x| X 6))
  br i1 %4, label %$5, label %$6
$5:
; # (shr N 3)
  %6 = lshr i64 %0, 3
; # (boxNum (shr N 3))
  %7 = call i64 @boxNum(i64 %6)
  br label %$7
$6:
; # (x| X 6)
  %8 = xor i64 %5, 6
  br label %$7
$7:
  %9 = phi i64 [%7, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (twiceBig N)
  %10 = call i64 @twiceBig(i64 %0)
  br label %$4
$4:
  %11 = phi i64 [%9, %$7], [%10, %$3] ; # ->
  ret i64 %11
}

define i64 @half(i64) {
$1:
; # (if (cnt? N) (| (& (shr N 1) -10) 2) (let (X N A (shr (val (dig X...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (shr N 1)
  %3 = lshr i64 %0, 1
; # (& (shr N 1) -10)
  %4 = and i64 %3, -10
; # (| (& (shr N 1) -10) 2)
  %5 = or i64 %4, 2
  br label %$4
$3:
; # (let (X N A (shr (val (dig X)) 1) Y (val (big X))) (if (big? Y) (...
; # (dig X)
  %6 = add i64 %0, -4
; # (val (dig X))
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (shr (val (dig X)) 1)
  %9 = lshr i64 %8, 1
; # (big X)
  %10 = add i64 %0, 4
; # (val (big X))
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (if (big? Y) (let Z (val (big Y)) (loop (let B (val (dig Y)) (set...
; # (big? Y)
  %13 = and i64 %12, 4
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$5, label %$6
$5:
  %15 = phi i64 [%0, %$3] ; # X
  %16 = phi i64 [%9, %$3] ; # A
  %17 = phi i64 [%12, %$3] ; # Y
; # (let Z (val (big Y)) (loop (let B (val (dig Y)) (set (dig X) (| (...
; # (big Y)
  %18 = add i64 %17, 4
; # (val (big Y))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (loop (let B (val (dig Y)) (set (dig X) (| (shr B 0 1) A)) (setq ...
  br label %$8
$8:
  %21 = phi i64 [%15, %$5], [%37, %$9] ; # X
  %22 = phi i64 [%16, %$5], [%36, %$9] ; # A
  %23 = phi i64 [%17, %$5], [%38, %$9] ; # Y
  %24 = phi i64 [%20, %$5], [%41, %$9] ; # Z
; # (let B (val (dig Y)) (set (dig X) (| (shr B 0 1) A)) (setq A (shr...
; # (dig Y)
  %25 = add i64 %23, -4
; # (val (dig Y))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (set (dig X) (| (shr B 0 1) A))
; # (dig X)
  %28 = add i64 %21, -4
; # (shr B 0 1)
  %29 = call i64 @llvm.fshr.i64(i64 %27, i64 0, i64 1)
; # (| (shr B 0 1) A)
  %30 = or i64 %29, %22
  %31 = inttoptr i64 %28 to i64*
  store i64 %30, i64* %31
; # (shr B 1)
  %32 = lshr i64 %27, 1
; # (? (cnt? Z))
; # (cnt? Z)
  %33 = and i64 %24, 2
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$10, label %$9
$9:
  %35 = phi i64 [%21, %$8] ; # X
  %36 = phi i64 [%32, %$8] ; # A
  %37 = phi i64 [%23, %$8] ; # Y
  %38 = phi i64 [%24, %$8] ; # Z
; # (big Z)
  %39 = add i64 %38, 4
; # (val (big Z))
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
  br label %$8
$10:
  %42 = phi i64 [%21, %$8] ; # X
  %43 = phi i64 [%32, %$8] ; # A
  %44 = phi i64 [%23, %$8] ; # Y
  %45 = phi i64 [%24, %$8] ; # Z
  %46 = phi i64 [0, %$8] ; # ->
; # (int Z)
  %47 = lshr i64 %45, 4
; # (shr Z 0 1)
  %48 = call i64 @llvm.fshr.i64(i64 %47, i64 0, i64 1)
; # (| (shr Z 0 1) A)
  %49 = or i64 %48, %43
; # (ifn (or (setq Z (shr Z 1)) (& A (hex "F000000000000000"))) (set ...
; # (or (setq Z (shr Z 1)) (& A (hex "F000000000000000")))
; # (shr Z 1)
  %50 = lshr i64 %47, 1
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$11, label %$12
$12:
  %52 = phi i64 [%42, %$10] ; # X
  %53 = phi i64 [%49, %$10] ; # A
  %54 = phi i64 [%44, %$10] ; # Y
  %55 = phi i64 [%50, %$10] ; # Z
; # (& A (hex "F000000000000000"))
  %56 = and i64 %53, 17293822569102704640
  %57 = icmp ne i64 %56, 0
  br label %$11
$11:
  %58 = phi i64 [%42, %$10], [%52, %$12] ; # X
  %59 = phi i64 [%49, %$10], [%53, %$12] ; # A
  %60 = phi i64 [%44, %$10], [%54, %$12] ; # Y
  %61 = phi i64 [%50, %$10], [%55, %$12] ; # Z
  %62 = phi i1 [1, %$10], [%57, %$12] ; # ->
  br i1 %62, label %$14, label %$13
$13:
  %63 = phi i64 [%58, %$11] ; # X
  %64 = phi i64 [%59, %$11] ; # A
  %65 = phi i64 [%60, %$11] ; # Y
  %66 = phi i64 [%61, %$11] ; # Z
; # (set (big X) (cnt A))
; # (big X)
  %67 = add i64 %63, 4
; # (cnt A)
  %68 = shl i64 %64, 4
  %69 = or i64 %68, 2
  %70 = inttoptr i64 %67 to i64*
  store i64 %69, i64* %70
  br label %$15
$14:
  %71 = phi i64 [%58, %$11] ; # X
  %72 = phi i64 [%59, %$11] ; # A
  %73 = phi i64 [%60, %$11] ; # Y
  %74 = phi i64 [%61, %$11] ; # Z
; # (set (dig Y) A)
; # (dig Y)
  %75 = add i64 %73, -4
  %76 = inttoptr i64 %75 to i64*
  store i64 %72, i64* %76
; # (set (big Y) (cnt Z))
; # (big Y)
  %77 = add i64 %73, 4
; # (cnt Z)
  %78 = shl i64 %74, 4
  %79 = or i64 %78, 2
  %80 = inttoptr i64 %77 to i64*
  store i64 %79, i64* %80
  br label %$15
$15:
  %81 = phi i64 [%63, %$13], [%71, %$14] ; # X
  %82 = phi i64 [%64, %$13], [%72, %$14] ; # A
  %83 = phi i64 [%65, %$13], [%73, %$14] ; # Y
  %84 = phi i64 [%66, %$13], [%74, %$14] ; # Z
  %85 = phi i64 [%69, %$13], [%79, %$14] ; # ->
  br label %$7
$6:
  %86 = phi i64 [%0, %$3] ; # X
  %87 = phi i64 [%9, %$3] ; # A
  %88 = phi i64 [%12, %$3] ; # Y
; # (int Y)
  %89 = lshr i64 %88, 4
; # (shr Y 0 1)
  %90 = call i64 @llvm.fshr.i64(i64 %89, i64 0, i64 1)
; # (| (shr Y 0 1) A)
  %91 = or i64 %90, %87
; # (unless (or (setq Y (shr Y 1)) (& A (hex "F000000000000000"))) (r...
; # (or (setq Y (shr Y 1)) (& A (hex "F000000000000000")))
; # (shr Y 1)
  %92 = lshr i64 %89, 1
  %93 = icmp ne i64 %92, 0
  br i1 %93, label %$16, label %$17
$17:
  %94 = phi i64 [%86, %$6] ; # X
  %95 = phi i64 [%91, %$6] ; # A
  %96 = phi i64 [%92, %$6] ; # Y
; # (& A (hex "F000000000000000"))
  %97 = and i64 %95, 17293822569102704640
  %98 = icmp ne i64 %97, 0
  br label %$16
$16:
  %99 = phi i64 [%86, %$6], [%94, %$17] ; # X
  %100 = phi i64 [%91, %$6], [%95, %$17] ; # A
  %101 = phi i64 [%92, %$6], [%96, %$17] ; # Y
  %102 = phi i1 [1, %$6], [%98, %$17] ; # ->
  br i1 %102, label %$19, label %$18
$18:
  %103 = phi i64 [%99, %$16] ; # X
  %104 = phi i64 [%100, %$16] ; # A
  %105 = phi i64 [%101, %$16] ; # Y
; # (cnt A)
  %106 = shl i64 %104, 4
  %107 = or i64 %106, 2
; # (ret (cnt A))
  ret i64 %107
$19:
  %108 = phi i64 [%99, %$16] ; # X
  %109 = phi i64 [%100, %$16] ; # A
  %110 = phi i64 [%101, %$16] ; # Y
; # (set (dig X) A)
; # (dig X)
  %111 = add i64 %108, -4
  %112 = inttoptr i64 %111 to i64*
  store i64 %109, i64* %112
; # (set (big X) (cnt Y))
; # (big X)
  %113 = add i64 %108, 4
; # (cnt Y)
  %114 = shl i64 %110, 4
  %115 = or i64 %114, 2
  %116 = inttoptr i64 %113 to i64*
  store i64 %115, i64* %116
  br label %$7
$7:
  %117 = phi i64 [%81, %$15], [%108, %$19] ; # X
  %118 = phi i64 [%82, %$15], [%109, %$19] ; # A
  %119 = phi i64 [%83, %$15], [%110, %$19] ; # Y
  %120 = phi i64 [%85, %$15], [%115, %$19] ; # ->
  br label %$4
$4:
  %121 = phi i64 [%5, %$2], [%0, %$7] ; # ->
  ret i64 %121
}

define i64 @tenfold(i64) {
$1:
; # (if (cnt? N) (box64 (* 10 (int N))) (let (X N Lo (mul 10 (val (di...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (int N)
  %3 = lshr i64 %0, 4
; # (* 10 (int N))
  %4 = mul i64 10, %3
; # (box64 (* 10 (int N)))
  %5 = and i64 %4, 17293822569102704640
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$6
$5:
  %7 = call i64 @boxNum(i64 %4)
  br label %$7
$6:
  %8 = shl i64 %4, 4
  %9 = or i64 %8, 2
  br label %$7
$7:
  %10 = phi i64 [%7, %$5], [%9, %$6] ; # ->
  br label %$4
$3:
; # (let (X N Lo (mul 10 (val (dig X))) Hi @@@) (loop (set (dig X) Lo...
; # (dig X)
  %11 = add i64 %0, -4
; # (val (dig X))
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
; # (mul 10 (val (dig X)))
  %14 = zext i64 %13 to i128
  %15 = mul i128 10, %14
  %16 = lshr i128 %15, 64
  %17 = trunc i128 %16 to i64
  %18 = trunc i128 %15 to i64
; # (loop (set (dig X) Lo) (? (cnt? (val (big X))) (set (big X) (box6...
  br label %$8
$8:
  %19 = phi i64 [%0, %$3], [%26, %$9] ; # X
  %20 = phi i64 [%18, %$3], [%56, %$9] ; # Lo
  %21 = phi i64 [%17, %$3], [%58, %$9] ; # Hi
; # (set (dig X) Lo)
; # (dig X)
  %22 = add i64 %19, -4
  %23 = inttoptr i64 %22 to i64*
  store i64 %20, i64* %23
; # (? (cnt? (val (big X))) (set (big X) (box64 (+ Hi (* 10 (int @)))...
; # (big X)
  %24 = add i64 %19, 4
; # (val (big X))
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (cnt? (val (big X)))
  %27 = and i64 %26, 2
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$11, label %$9
$11:
  %29 = phi i64 [%19, %$8] ; # X
  %30 = phi i64 [%20, %$8] ; # Lo
  %31 = phi i64 [%21, %$8] ; # Hi
; # (set (big X) (box64 (+ Hi (* 10 (int @)))))
; # (big X)
  %32 = add i64 %29, 4
; # (int @)
  %33 = lshr i64 %26, 4
; # (* 10 (int @))
  %34 = mul i64 10, %33
; # (+ Hi (* 10 (int @)))
  %35 = add i64 %31, %34
; # (box64 (+ Hi (* 10 (int @))))
  %36 = and i64 %35, 17293822569102704640
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = call i64 @boxNum(i64 %35)
  br label %$14
$13:
  %39 = shl i64 %35, 4
  %40 = or i64 %39, 2
  br label %$14
$14:
  %41 = phi i64 [%38, %$12], [%40, %$13] ; # ->
  %42 = inttoptr i64 %32 to i64*
  store i64 %41, i64* %42
  br label %$10
$9:
  %43 = phi i64 [%19, %$8] ; # X
  %44 = phi i64 [%20, %$8] ; # Lo
  %45 = phi i64 [%21, %$8] ; # Hi
; # (dig X)
  %46 = add i64 %26, -4
; # (val (dig X))
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
; # (mul 10 (val (dig X)))
  %49 = zext i64 %48 to i128
  %50 = mul i128 10, %49
  %51 = lshr i128 %50, 64
  %52 = trunc i128 %51 to i64
  %53 = trunc i128 %50 to i64
; # (add (mul 10 (val (dig X))) Hi)
  %54 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %53, i64 %45)
  %55 = extractvalue {i64, i1} %54, 1
  %56 = extractvalue {i64, i1} %54, 0
; # (+ @@@ @@)
  %57 = zext i1 %55 to i64
  %58 = add i64 %52, %57
  br label %$8
$10:
  %59 = phi i64 [%29, %$14] ; # X
  %60 = phi i64 [%30, %$14] ; # Lo
  %61 = phi i64 [%31, %$14] ; # Hi
  %62 = phi i64 [%41, %$14] ; # ->
  br label %$4
$4:
  %63 = phi i64 [%10, %$7], [%0, %$10] ; # ->
  ret i64 %63
}

define i64 @shlu(i64) {
$1:
; # (if (cnt? N) (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6))...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (let X (add N N) (if @@ (boxNum (shr N 3)) (x| X 6)))
; # (add N N)
  %3 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %0, i64 %0)
  %4 = extractvalue {i64, i1} %3, 1
  %5 = extractvalue {i64, i1} %3, 0
; # (if @@ (boxNum (shr N 3)) (x| X 6))
  br i1 %4, label %$5, label %$6
$5:
; # (shr N 3)
  %6 = lshr i64 %0, 3
; # (boxNum (shr N 3))
  %7 = call i64 @boxNum(i64 %6)
  br label %$7
$6:
; # (x| X 6)
  %8 = xor i64 %5, 6
  br label %$7
$7:
  %9 = phi i64 [%7, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (let (A (val (dig N)) X (boxNum (shl A 1)) Y (val (big N)) R (sav...
; # (dig N)
  %10 = add i64 %0, -4
; # (val (dig N))
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (shl A 1)
  %13 = shl i64 %12, 1
; # (boxNum (shl A 1))
  %14 = call i64 @boxNum(i64 %13)
; # (big N)
  %15 = add i64 %0, 4
; # (val (big N))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (save X)
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %14, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (while (big? Y) (let B (val (dig Y)) (setq X (set (big X) (boxNum...
  br label %$8
$8:
  %26 = phi i64 [%12, %$3], [%36, %$9] ; # A
  %27 = phi i64 [%14, %$3], [%41, %$9] ; # X
  %28 = phi i64 [%17, %$3], [%45, %$9] ; # Y
; # (big? Y)
  %29 = and i64 %28, 4
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$9, label %$10
$9:
  %31 = phi i64 [%26, %$8] ; # A
  %32 = phi i64 [%27, %$8] ; # X
  %33 = phi i64 [%28, %$8] ; # Y
; # (let B (val (dig Y)) (setq X (set (big X) (boxNum (| (shl B 1) (s...
; # (dig Y)
  %34 = add i64 %33, -4
; # (val (dig Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (set (big X) (boxNum (| (shl B 1) (shl 0 A 1))))
; # (big X)
  %37 = add i64 %32, 4
; # (shl B 1)
  %38 = shl i64 %36, 1
; # (shl 0 A 1)
  %39 = call i64 @llvm.fshl.i64(i64 0, i64 %31, i64 1)
; # (| (shl B 1) (shl 0 A 1))
  %40 = or i64 %38, %39
; # (boxNum (| (shl B 1) (shl 0 A 1)))
  %41 = call i64 @boxNum(i64 %40)
  %42 = inttoptr i64 %37 to i64*
  store i64 %41, i64* %42
; # (big Y)
  %43 = add i64 %33, 4
; # (val (big Y))
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
  br label %$8
$10:
  %46 = phi i64 [%26, %$8] ; # A
  %47 = phi i64 [%27, %$8] ; # X
  %48 = phi i64 [%28, %$8] ; # Y
; # (set (big X) (box64 (| (shl (int Y) 1) (shl 0 A 1))))
; # (big X)
  %49 = add i64 %47, 4
; # (int Y)
  %50 = lshr i64 %48, 4
; # (shl (int Y) 1)
  %51 = shl i64 %50, 1
; # (shl 0 A 1)
  %52 = call i64 @llvm.fshl.i64(i64 0, i64 %46, i64 1)
; # (| (shl (int Y) 1) (shl 0 A 1))
  %53 = or i64 %51, %52
; # (box64 (| (shl (int Y) 1) (shl 0 A 1)))
  %54 = and i64 %53, 17293822569102704640
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$11, label %$12
$11:
  %56 = call i64 @boxNum(i64 %53)
  br label %$13
$12:
  %57 = shl i64 %53, 4
  %58 = or i64 %57, 2
  br label %$13
$13:
  %59 = phi i64 [%56, %$11], [%58, %$12] ; # ->
  %60 = inttoptr i64 %49 to i64*
  store i64 %59, i64* %60
; # (drop *Safe)
  %61 = inttoptr i64 %19 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %63, i64* %64
  br label %$4
$4:
  %65 = phi i64 [%9, %$7], [%14, %$13] ; # ->
  ret i64 %65
}

define i64 @shru(i64) {
$1:
; # (if (cnt? N) (| (& (shr N 1) -10) 2) (let A (shr (val (dig N)) 1)...
; # (cnt? N)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i64 [%0, %$1] ; # N
; # (shr N 1)
  %4 = lshr i64 %3, 1
; # (& (shr N 1) -10)
  %5 = and i64 %4, -10
; # (| (& (shr N 1) -10) 2)
  %6 = or i64 %5, 2
  br label %$4
$3:
  %7 = phi i64 [%0, %$1] ; # N
; # (let A (shr (val (dig N)) 1) (if (big? (setq N (val (big N)))) (l...
; # (dig N)
  %8 = add i64 %7, -4
; # (val (dig N))
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (shr (val (dig N)) 1)
  %11 = lshr i64 %10, 1
; # (if (big? (setq N (val (big N)))) (let (B (val (dig N)) P (boxNum...
; # (big N)
  %12 = add i64 %7, 4
; # (val (big N))
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (big? (setq N (val (big N))))
  %15 = and i64 %14, 4
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$5, label %$6
$5:
  %17 = phi i64 [%14, %$3] ; # N
  %18 = phi i64 [%11, %$3] ; # A
; # (let (B (val (dig N)) P (boxNum (| (shr B 0 1) A)) R (save P)) (l...
; # (dig N)
  %19 = add i64 %17, -4
; # (val (dig N))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (shr B 0 1)
  %22 = call i64 @llvm.fshr.i64(i64 %21, i64 0, i64 1)
; # (| (shr B 0 1) A)
  %23 = or i64 %22, %18
; # (boxNum (| (shr B 0 1) A))
  %24 = call i64 @boxNum(i64 %23)
; # (save P)
  %25 = alloca i64, i64 2, align 16
  %26 = ptrtoint i64* %25 to i64
  %27 = inttoptr i64 %26 to i64*
  store i64 %24, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %26 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  store i64 %29, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %32
; # (loop (setq A (shr B 1)) (? (cnt? (setq N (val (big N))))) (setq ...
  br label %$8
$8:
  %33 = phi i64 [%17, %$5], [%43, %$9] ; # N
  %34 = phi i64 [%18, %$5], [%44, %$9] ; # A
  %35 = phi i64 [%21, %$5], [%49, %$9] ; # B
  %36 = phi i64 [%24, %$5], [%53, %$9] ; # P
; # (shr B 1)
  %37 = lshr i64 %35, 1
; # (? (cnt? (setq N (val (big N)))))
; # (big N)
  %38 = add i64 %33, 4
; # (val (big N))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (cnt? (setq N (val (big N))))
  %41 = and i64 %40, 2
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$10, label %$9
$9:
  %43 = phi i64 [%40, %$8] ; # N
  %44 = phi i64 [%37, %$8] ; # A
  %45 = phi i64 [%35, %$8] ; # B
  %46 = phi i64 [%36, %$8] ; # P
; # (dig N)
  %47 = add i64 %43, -4
; # (val (dig N))
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (set (big P) (boxNum (| (shr B 0 1) A)))
; # (big P)
  %50 = add i64 %46, 4
; # (shr B 0 1)
  %51 = call i64 @llvm.fshr.i64(i64 %49, i64 0, i64 1)
; # (| (shr B 0 1) A)
  %52 = or i64 %51, %44
; # (boxNum (| (shr B 0 1) A))
  %53 = call i64 @boxNum(i64 %52)
  %54 = inttoptr i64 %50 to i64*
  store i64 %53, i64* %54
  br label %$8
$10:
  %55 = phi i64 [%40, %$8] ; # N
  %56 = phi i64 [%37, %$8] ; # A
  %57 = phi i64 [%35, %$8] ; # B
  %58 = phi i64 [%36, %$8] ; # P
  %59 = phi i64 [0, %$8] ; # ->
; # (int N)
  %60 = lshr i64 %55, 4
; # (shr N 0 1)
  %61 = call i64 @llvm.fshr.i64(i64 %60, i64 0, i64 1)
; # (| (shr N 0 1) A)
  %62 = or i64 %61, %56
; # (set (big P) (ifn (or (setq N (shr N 1)) (& A (hex "F000000000000...
; # (big P)
  %63 = add i64 %58, 4
; # (ifn (or (setq N (shr N 1)) (& A (hex "F000000000000000"))) (cnt ...
; # (or (setq N (shr N 1)) (& A (hex "F000000000000000")))
; # (shr N 1)
  %64 = lshr i64 %60, 1
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$11, label %$12
$12:
  %66 = phi i64 [%64, %$10] ; # N
  %67 = phi i64 [%62, %$10] ; # A
  %68 = phi i64 [%57, %$10] ; # B
  %69 = phi i64 [%58, %$10] ; # P
; # (& A (hex "F000000000000000"))
  %70 = and i64 %67, 17293822569102704640
  %71 = icmp ne i64 %70, 0
  br label %$11
$11:
  %72 = phi i64 [%64, %$10], [%66, %$12] ; # N
  %73 = phi i64 [%62, %$10], [%67, %$12] ; # A
  %74 = phi i64 [%57, %$10], [%68, %$12] ; # B
  %75 = phi i64 [%58, %$10], [%69, %$12] ; # P
  %76 = phi i1 [1, %$10], [%71, %$12] ; # ->
  br i1 %76, label %$14, label %$13
$13:
  %77 = phi i64 [%72, %$11] ; # N
  %78 = phi i64 [%73, %$11] ; # A
  %79 = phi i64 [%74, %$11] ; # B
  %80 = phi i64 [%75, %$11] ; # P
; # (cnt A)
  %81 = shl i64 %78, 4
  %82 = or i64 %81, 2
  br label %$15
$14:
  %83 = phi i64 [%72, %$11] ; # N
  %84 = phi i64 [%73, %$11] ; # A
  %85 = phi i64 [%74, %$11] ; # B
  %86 = phi i64 [%75, %$11] ; # P
; # (prog1 (boxNum A) (set (big @) (cnt N)))
; # (boxNum A)
  %87 = call i64 @boxNum(i64 %84)
; # (set (big @) (cnt N))
; # (big @)
  %88 = add i64 %87, 4
; # (cnt N)
  %89 = shl i64 %83, 4
  %90 = or i64 %89, 2
  %91 = inttoptr i64 %88 to i64*
  store i64 %90, i64* %91
  br label %$15
$15:
  %92 = phi i64 [%77, %$13], [%83, %$14] ; # N
  %93 = phi i64 [%78, %$13], [%84, %$14] ; # A
  %94 = phi i64 [%79, %$13], [%85, %$14] ; # B
  %95 = phi i64 [%80, %$13], [%86, %$14] ; # P
  %96 = phi i64 [%82, %$13], [%87, %$14] ; # ->
  %97 = inttoptr i64 %63 to i64*
  store i64 %96, i64* %97
; # (drop *Safe)
  %98 = inttoptr i64 %26 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %100, i64* %101
  br label %$7
$6:
  %102 = phi i64 [%14, %$3] ; # N
  %103 = phi i64 [%11, %$3] ; # A
; # (int N)
  %104 = lshr i64 %102, 4
; # (shr N 0 1)
  %105 = call i64 @llvm.fshr.i64(i64 %104, i64 0, i64 1)
; # (| (shr N 0 1) A)
  %106 = or i64 %105, %103
; # (ifn (or (setq N (shr N 1)) (& A (hex "F000000000000000"))) (cnt ...
; # (or (setq N (shr N 1)) (& A (hex "F000000000000000")))
; # (shr N 1)
  %107 = lshr i64 %104, 1
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$16, label %$17
$17:
  %109 = phi i64 [%107, %$6] ; # N
  %110 = phi i64 [%106, %$6] ; # A
; # (& A (hex "F000000000000000"))
  %111 = and i64 %110, 17293822569102704640
  %112 = icmp ne i64 %111, 0
  br label %$16
$16:
  %113 = phi i64 [%107, %$6], [%109, %$17] ; # N
  %114 = phi i64 [%106, %$6], [%110, %$17] ; # A
  %115 = phi i1 [1, %$6], [%112, %$17] ; # ->
  br i1 %115, label %$19, label %$18
$18:
  %116 = phi i64 [%113, %$16] ; # N
  %117 = phi i64 [%114, %$16] ; # A
; # (cnt A)
  %118 = shl i64 %117, 4
  %119 = or i64 %118, 2
  br label %$20
$19:
  %120 = phi i64 [%113, %$16] ; # N
  %121 = phi i64 [%114, %$16] ; # A
; # (prog1 (boxNum A) (set (big @) (cnt N)))
; # (boxNum A)
  %122 = call i64 @boxNum(i64 %121)
; # (set (big @) (cnt N))
; # (big @)
  %123 = add i64 %122, 4
; # (cnt N)
  %124 = shl i64 %120, 4
  %125 = or i64 %124, 2
  %126 = inttoptr i64 %123 to i64*
  store i64 %125, i64* %126
  br label %$20
$20:
  %127 = phi i64 [%116, %$18], [%120, %$19] ; # N
  %128 = phi i64 [%117, %$18], [%121, %$19] ; # A
  %129 = phi i64 [%119, %$18], [%122, %$19] ; # ->
  br label %$7
$7:
  %130 = phi i64 [%92, %$15], [%127, %$20] ; # N
  %131 = phi i64 [%93, %$15], [%128, %$20] ; # A
  %132 = phi i64 [%24, %$15], [%129, %$20] ; # ->
  br label %$4
$4:
  %133 = phi i64 [%3, %$2], [%130, %$7] ; # N
  %134 = phi i64 [%6, %$2], [%132, %$7] ; # ->
  ret i64 %134
}

define i64 @andu(i64, i64) {
$1:
; # (cond ((cnt? A) (& A (if (cnt? B) B (cnt (val (dig B)))))) ((cnt?...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) B (cnt (val (dig B))))
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
  br label %$7
$6:
  %10 = phi i64 [%4, %$4] ; # A
  %11 = phi i64 [%5, %$4] ; # B
; # (dig B)
  %12 = add i64 %11, -4
; # (val (dig B))
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (cnt (val (dig B)))
  %15 = shl i64 %14, 4
  %16 = or i64 %15, 2
  br label %$7
$7:
  %17 = phi i64 [%8, %$5], [%10, %$6] ; # A
  %18 = phi i64 [%9, %$5], [%11, %$6] ; # B
  %19 = phi i64 [%9, %$5], [%16, %$6] ; # ->
; # (& A (if (cnt? B) B (cnt (val (dig B)))))
  %20 = and i64 %4, %19
  br label %$2
$3:
  %21 = phi i64 [%0, %$1] ; # A
  %22 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %23 = and i64 %22, 2
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$9, label %$8
$9:
  %25 = phi i64 [%21, %$3] ; # A
  %26 = phi i64 [%22, %$3] ; # B
; # (dig A)
  %27 = add i64 %25, -4
; # (val (dig A))
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (cnt (val (dig A)))
  %30 = shl i64 %29, 4
  %31 = or i64 %30, 2
; # (& B (cnt (val (dig A))))
  %32 = and i64 %26, %31
  br label %$2
$8:
  %33 = phi i64 [%21, %$3] ; # A
  %34 = phi i64 [%22, %$3] ; # B
; # (let (P (boxNum (& (val (dig A)) (val (dig B)))) R (save P)) (loo...
; # (dig A)
  %35 = add i64 %33, -4
; # (val (dig A))
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
; # (dig B)
  %38 = add i64 %34, -4
; # (val (dig B))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (& (val (dig A)) (val (dig B)))
  %41 = and i64 %37, %40
; # (boxNum (& (val (dig A)) (val (dig B))))
  %42 = call i64 @boxNum(i64 %41)
; # (save P)
  %43 = alloca i64, i64 2, align 16
  %44 = ptrtoint i64* %43 to i64
  %45 = inttoptr i64 %44 to i64*
  store i64 %42, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %47 = load i64, i64* %46
  %48 = inttoptr i64 %44 to i64*
  %49 = getelementptr i64, i64* %48, i32 1
  store i64 %47, i64* %49
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %50
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (set (bi...
  br label %$10
$10:
  %51 = phi i64 [%33, %$8], [%101, %$17] ; # A
  %52 = phi i64 [%34, %$8], [%102, %$17] ; # B
  %53 = phi i64 [%42, %$8], [%112, %$17] ; # P
; # (big A)
  %54 = add i64 %51, 4
; # (val (big A))
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (big B)
  %57 = add i64 %52, 4
; # (val (big B))
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (? (cnt? A) (set (big P) (& A (if (cnt? B) B (cnt (val (dig B))))...
; # (cnt? A)
  %60 = and i64 %56, 2
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$13, label %$11
$13:
  %62 = phi i64 [%56, %$10] ; # A
  %63 = phi i64 [%59, %$10] ; # B
  %64 = phi i64 [%53, %$10] ; # P
; # (set (big P) (& A (if (cnt? B) B (cnt (val (dig B))))))
; # (big P)
  %65 = add i64 %64, 4
; # (if (cnt? B) B (cnt (val (dig B))))
; # (cnt? B)
  %66 = and i64 %63, 2
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$14, label %$15
$14:
  %68 = phi i64 [%62, %$13] ; # A
  %69 = phi i64 [%63, %$13] ; # B
  %70 = phi i64 [%64, %$13] ; # P
  br label %$16
$15:
  %71 = phi i64 [%62, %$13] ; # A
  %72 = phi i64 [%63, %$13] ; # B
  %73 = phi i64 [%64, %$13] ; # P
; # (dig B)
  %74 = add i64 %72, -4
; # (val (dig B))
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
; # (cnt (val (dig B)))
  %77 = shl i64 %76, 4
  %78 = or i64 %77, 2
  br label %$16
$16:
  %79 = phi i64 [%68, %$14], [%71, %$15] ; # A
  %80 = phi i64 [%69, %$14], [%72, %$15] ; # B
  %81 = phi i64 [%70, %$14], [%73, %$15] ; # P
  %82 = phi i64 [%69, %$14], [%78, %$15] ; # ->
; # (& A (if (cnt? B) B (cnt (val (dig B)))))
  %83 = and i64 %62, %82
  %84 = inttoptr i64 %65 to i64*
  store i64 %83, i64* %84
  br label %$12
$11:
  %85 = phi i64 [%56, %$10] ; # A
  %86 = phi i64 [%59, %$10] ; # B
  %87 = phi i64 [%53, %$10] ; # P
; # (? (cnt? B) (set (big P) (& B (cnt (val (dig A))))))
; # (cnt? B)
  %88 = and i64 %86, 2
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$18, label %$17
$18:
  %90 = phi i64 [%85, %$11] ; # A
  %91 = phi i64 [%86, %$11] ; # B
  %92 = phi i64 [%87, %$11] ; # P
; # (set (big P) (& B (cnt (val (dig A)))))
; # (big P)
  %93 = add i64 %92, 4
; # (dig A)
  %94 = add i64 %90, -4
; # (val (dig A))
  %95 = inttoptr i64 %94 to i64*
  %96 = load i64, i64* %95
; # (cnt (val (dig A)))
  %97 = shl i64 %96, 4
  %98 = or i64 %97, 2
; # (& B (cnt (val (dig A))))
  %99 = and i64 %91, %98
  %100 = inttoptr i64 %93 to i64*
  store i64 %99, i64* %100
  br label %$12
$17:
  %101 = phi i64 [%85, %$11] ; # A
  %102 = phi i64 [%86, %$11] ; # B
  %103 = phi i64 [%87, %$11] ; # P
; # (set (big P) (boxNum (& (val (dig A)) (val (dig B)))))
; # (big P)
  %104 = add i64 %103, 4
; # (dig A)
  %105 = add i64 %101, -4
; # (val (dig A))
  %106 = inttoptr i64 %105 to i64*
  %107 = load i64, i64* %106
; # (dig B)
  %108 = add i64 %102, -4
; # (val (dig B))
  %109 = inttoptr i64 %108 to i64*
  %110 = load i64, i64* %109
; # (& (val (dig A)) (val (dig B)))
  %111 = and i64 %107, %110
; # (boxNum (& (val (dig A)) (val (dig B))))
  %112 = call i64 @boxNum(i64 %111)
  %113 = inttoptr i64 %104 to i64*
  store i64 %112, i64* %113
  br label %$10
$12:
  %114 = phi i64 [%79, %$16], [%90, %$18] ; # A
  %115 = phi i64 [%80, %$16], [%91, %$18] ; # B
  %116 = phi i64 [%81, %$16], [%92, %$18] ; # P
  %117 = phi i64 [%83, %$16], [%99, %$18] ; # ->
; # (zapZero R)
  %118 = call i64 @zapZero(i64 %42)
; # (drop *Safe)
  %119 = inttoptr i64 %44 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %121, i64* %122
  br label %$2
$2:
  %123 = phi i64 [%17, %$7], [%25, %$9], [%114, %$12] ; # A
  %124 = phi i64 [%18, %$7], [%26, %$9], [%115, %$12] ; # B
  %125 = phi i64 [%20, %$7], [%32, %$9], [%118, %$12] ; # ->
  ret i64 %125
}

define i64 @oru(i64, i64) {
$1:
; # (cond ((cnt? A) (if (cnt? B) (| A B) (consNum (| (int A) (val (di...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (| A B) (consNum (| (int A) (val (dig B))) (val (big...
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (| A B)
  %10 = or i64 %8, %9
  br label %$7
$6:
  %11 = phi i64 [%4, %$4] ; # A
  %12 = phi i64 [%5, %$4] ; # B
; # (int A)
  %13 = lshr i64 %11, 4
; # (dig B)
  %14 = add i64 %12, -4
; # (val (dig B))
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
; # (| (int A) (val (dig B)))
  %17 = or i64 %13, %16
; # (big B)
  %18 = add i64 %12, 4
; # (val (big B))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (consNum (| (int A) (val (dig B))) (val (big B)))
  %21 = call i64 @consNum(i64 %17, i64 %20)
  br label %$7
$7:
  %22 = phi i64 [%8, %$5], [%11, %$6] ; # A
  %23 = phi i64 [%9, %$5], [%12, %$6] ; # B
  %24 = phi i64 [%10, %$5], [%21, %$6] ; # ->
  br label %$2
$3:
  %25 = phi i64 [%0, %$1] ; # A
  %26 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %27 = and i64 %26, 2
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$9, label %$8
$9:
  %29 = phi i64 [%25, %$3] ; # A
  %30 = phi i64 [%26, %$3] ; # B
; # (int B)
  %31 = lshr i64 %30, 4
; # (dig A)
  %32 = add i64 %29, -4
; # (val (dig A))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (| (int B) (val (dig A)))
  %35 = or i64 %31, %34
; # (big A)
  %36 = add i64 %29, 4
; # (val (big A))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (consNum (| (int B) (val (dig A))) (val (big A)))
  %39 = call i64 @consNum(i64 %35, i64 %38)
  br label %$2
$8:
  %40 = phi i64 [%25, %$3] ; # A
  %41 = phi i64 [%26, %$3] ; # B
; # (let (P (boxNum (| (val (dig A)) (val (dig B)))) R (save P)) (loo...
; # (dig A)
  %42 = add i64 %40, -4
; # (val (dig A))
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (dig B)
  %45 = add i64 %41, -4
; # (val (dig B))
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (| (val (dig A)) (val (dig B)))
  %48 = or i64 %44, %47
; # (boxNum (| (val (dig A)) (val (dig B))))
  %49 = call i64 @boxNum(i64 %48)
; # (save P)
  %50 = alloca i64, i64 2, align 16
  %51 = ptrtoint i64* %50 to i64
  %52 = inttoptr i64 %51 to i64*
  store i64 %49, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %54 = load i64, i64* %53
  %55 = inttoptr i64 %51 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  store i64 %54, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %57
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (set (bi...
  br label %$10
$10:
  %58 = phi i64 [%40, %$8], [%115, %$17] ; # A
  %59 = phi i64 [%41, %$8], [%116, %$17] ; # B
  %60 = phi i64 [%49, %$8], [%126, %$17] ; # P
; # (big A)
  %61 = add i64 %58, 4
; # (val (big A))
  %62 = inttoptr i64 %61 to i64*
  %63 = load i64, i64* %62
; # (big B)
  %64 = add i64 %59, 4
; # (val (big B))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (? (cnt? A) (set (big P) (if (cnt? B) (| A B) (consNum (| (int A)...
; # (cnt? A)
  %67 = and i64 %63, 2
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$13, label %$11
$13:
  %69 = phi i64 [%63, %$10] ; # A
  %70 = phi i64 [%66, %$10] ; # B
  %71 = phi i64 [%60, %$10] ; # P
; # (set (big P) (if (cnt? B) (| A B) (consNum (| (int A) (val (dig B...
; # (big P)
  %72 = add i64 %71, 4
; # (if (cnt? B) (| A B) (consNum (| (int A) (val (dig B))) (val (big...
; # (cnt? B)
  %73 = and i64 %70, 2
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$14, label %$15
$14:
  %75 = phi i64 [%69, %$13] ; # A
  %76 = phi i64 [%70, %$13] ; # B
  %77 = phi i64 [%71, %$13] ; # P
; # (| A B)
  %78 = or i64 %75, %76
  br label %$16
$15:
  %79 = phi i64 [%69, %$13] ; # A
  %80 = phi i64 [%70, %$13] ; # B
  %81 = phi i64 [%71, %$13] ; # P
; # (int A)
  %82 = lshr i64 %79, 4
; # (dig B)
  %83 = add i64 %80, -4
; # (val (dig B))
  %84 = inttoptr i64 %83 to i64*
  %85 = load i64, i64* %84
; # (| (int A) (val (dig B)))
  %86 = or i64 %82, %85
; # (big B)
  %87 = add i64 %80, 4
; # (val (big B))
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (consNum (| (int A) (val (dig B))) (val (big B)))
  %90 = call i64 @consNum(i64 %86, i64 %89)
  br label %$16
$16:
  %91 = phi i64 [%75, %$14], [%79, %$15] ; # A
  %92 = phi i64 [%76, %$14], [%80, %$15] ; # B
  %93 = phi i64 [%77, %$14], [%81, %$15] ; # P
  %94 = phi i64 [%78, %$14], [%90, %$15] ; # ->
  %95 = inttoptr i64 %72 to i64*
  store i64 %94, i64* %95
  br label %$12
$11:
  %96 = phi i64 [%63, %$10] ; # A
  %97 = phi i64 [%66, %$10] ; # B
  %98 = phi i64 [%60, %$10] ; # P
; # (? (cnt? B) (set (big P) (consNum (| (int B) (val (dig A))) (val ...
; # (cnt? B)
  %99 = and i64 %97, 2
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$18, label %$17
$18:
  %101 = phi i64 [%96, %$11] ; # A
  %102 = phi i64 [%97, %$11] ; # B
  %103 = phi i64 [%98, %$11] ; # P
; # (set (big P) (consNum (| (int B) (val (dig A))) (val (big A))))
; # (big P)
  %104 = add i64 %103, 4
; # (int B)
  %105 = lshr i64 %102, 4
; # (dig A)
  %106 = add i64 %101, -4
; # (val (dig A))
  %107 = inttoptr i64 %106 to i64*
  %108 = load i64, i64* %107
; # (| (int B) (val (dig A)))
  %109 = or i64 %105, %108
; # (big A)
  %110 = add i64 %101, 4
; # (val (big A))
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
; # (consNum (| (int B) (val (dig A))) (val (big A)))
  %113 = call i64 @consNum(i64 %109, i64 %112)
  %114 = inttoptr i64 %104 to i64*
  store i64 %113, i64* %114
  br label %$12
$17:
  %115 = phi i64 [%96, %$11] ; # A
  %116 = phi i64 [%97, %$11] ; # B
  %117 = phi i64 [%98, %$11] ; # P
; # (set (big P) (boxNum (| (val (dig A)) (val (dig B)))))
; # (big P)
  %118 = add i64 %117, 4
; # (dig A)
  %119 = add i64 %115, -4
; # (val (dig A))
  %120 = inttoptr i64 %119 to i64*
  %121 = load i64, i64* %120
; # (dig B)
  %122 = add i64 %116, -4
; # (val (dig B))
  %123 = inttoptr i64 %122 to i64*
  %124 = load i64, i64* %123
; # (| (val (dig A)) (val (dig B)))
  %125 = or i64 %121, %124
; # (boxNum (| (val (dig A)) (val (dig B))))
  %126 = call i64 @boxNum(i64 %125)
  %127 = inttoptr i64 %118 to i64*
  store i64 %126, i64* %127
  br label %$10
$12:
  %128 = phi i64 [%91, %$16], [%101, %$18] ; # A
  %129 = phi i64 [%92, %$16], [%102, %$18] ; # B
  %130 = phi i64 [%93, %$16], [%103, %$18] ; # P
  %131 = phi i64 [%94, %$16], [%113, %$18] ; # ->
; # (drop *Safe)
  %132 = inttoptr i64 %51 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
  %135 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %134, i64* %135
  br label %$2
$2:
  %136 = phi i64 [%22, %$7], [%29, %$9], [%128, %$12] ; # A
  %137 = phi i64 [%23, %$7], [%30, %$9], [%129, %$12] ; # B
  %138 = phi i64 [%24, %$7], [%39, %$9], [%49, %$12] ; # ->
  ret i64 %138
}

define i64 @xoru(i64, i64) {
$1:
; # (cond ((cnt? A) (if (cnt? B) (| (x| A B) 2) (zapZero (consNum (x|...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (| (x| A B) 2) (zapZero (consNum (x| (int A) (val (d...
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (x| A B)
  %10 = xor i64 %8, %9
; # (| (x| A B) 2)
  %11 = or i64 %10, 2
  br label %$7
$6:
  %12 = phi i64 [%4, %$4] ; # A
  %13 = phi i64 [%5, %$4] ; # B
; # (int A)
  %14 = lshr i64 %12, 4
; # (dig B)
  %15 = add i64 %13, -4
; # (val (dig B))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (x| (int A) (val (dig B)))
  %18 = xor i64 %14, %17
; # (big B)
  %19 = add i64 %13, 4
; # (val (big B))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (consNum (x| (int A) (val (dig B))) (val (big B)))
  %22 = call i64 @consNum(i64 %18, i64 %21)
; # (zapZero (consNum (x| (int A) (val (dig B))) (val (big B))))
  %23 = call i64 @zapZero(i64 %22)
  br label %$7
$7:
  %24 = phi i64 [%8, %$5], [%12, %$6] ; # A
  %25 = phi i64 [%9, %$5], [%13, %$6] ; # B
  %26 = phi i64 [%11, %$5], [%23, %$6] ; # ->
  br label %$2
$3:
  %27 = phi i64 [%0, %$1] ; # A
  %28 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %29 = and i64 %28, 2
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$9, label %$8
$9:
  %31 = phi i64 [%27, %$3] ; # A
  %32 = phi i64 [%28, %$3] ; # B
; # (int B)
  %33 = lshr i64 %32, 4
; # (dig A)
  %34 = add i64 %31, -4
; # (val (dig A))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (x| (int B) (val (dig A)))
  %37 = xor i64 %33, %36
; # (big A)
  %38 = add i64 %31, 4
; # (val (big A))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (consNum (x| (int B) (val (dig A))) (val (big A)))
  %41 = call i64 @consNum(i64 %37, i64 %40)
; # (zapZero (consNum (x| (int B) (val (dig A))) (val (big A))))
  %42 = call i64 @zapZero(i64 %41)
  br label %$2
$8:
  %43 = phi i64 [%27, %$3] ; # A
  %44 = phi i64 [%28, %$3] ; # B
; # (let (P (boxNum (x| (val (dig A)) (val (dig B)))) R (save P)) (lo...
; # (dig A)
  %45 = add i64 %43, -4
; # (val (dig A))
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (dig B)
  %48 = add i64 %44, -4
; # (val (dig B))
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (x| (val (dig A)) (val (dig B)))
  %51 = xor i64 %47, %50
; # (boxNum (x| (val (dig A)) (val (dig B))))
  %52 = call i64 @boxNum(i64 %51)
; # (save P)
  %53 = alloca i64, i64 2, align 16
  %54 = ptrtoint i64* %53 to i64
  %55 = inttoptr i64 %54 to i64*
  store i64 %52, i64* %55
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = inttoptr i64 %54 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %57, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %60
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (set (bi...
  br label %$10
$10:
  %61 = phi i64 [%43, %$8], [%119, %$17] ; # A
  %62 = phi i64 [%44, %$8], [%120, %$17] ; # B
  %63 = phi i64 [%52, %$8], [%130, %$17] ; # P
; # (big A)
  %64 = add i64 %61, 4
; # (val (big A))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (big B)
  %67 = add i64 %62, 4
; # (val (big B))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (? (cnt? A) (set (big P) (if (cnt? B) (| (x| A B) 2) (consNum (x|...
; # (cnt? A)
  %70 = and i64 %66, 2
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$13, label %$11
$13:
  %72 = phi i64 [%66, %$10] ; # A
  %73 = phi i64 [%69, %$10] ; # B
  %74 = phi i64 [%63, %$10] ; # P
; # (set (big P) (if (cnt? B) (| (x| A B) 2) (consNum (x| (int A) (va...
; # (big P)
  %75 = add i64 %74, 4
; # (if (cnt? B) (| (x| A B) 2) (consNum (x| (int A) (val (dig B))) (...
; # (cnt? B)
  %76 = and i64 %73, 2
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$14, label %$15
$14:
  %78 = phi i64 [%72, %$13] ; # A
  %79 = phi i64 [%73, %$13] ; # B
  %80 = phi i64 [%74, %$13] ; # P
; # (x| A B)
  %81 = xor i64 %78, %79
; # (| (x| A B) 2)
  %82 = or i64 %81, 2
  br label %$16
$15:
  %83 = phi i64 [%72, %$13] ; # A
  %84 = phi i64 [%73, %$13] ; # B
  %85 = phi i64 [%74, %$13] ; # P
; # (int A)
  %86 = lshr i64 %83, 4
; # (dig B)
  %87 = add i64 %84, -4
; # (val (dig B))
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (x| (int A) (val (dig B)))
  %90 = xor i64 %86, %89
; # (big B)
  %91 = add i64 %84, 4
; # (val (big B))
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
; # (consNum (x| (int A) (val (dig B))) (val (big B)))
  %94 = call i64 @consNum(i64 %90, i64 %93)
  br label %$16
$16:
  %95 = phi i64 [%78, %$14], [%83, %$15] ; # A
  %96 = phi i64 [%79, %$14], [%84, %$15] ; # B
  %97 = phi i64 [%80, %$14], [%85, %$15] ; # P
  %98 = phi i64 [%82, %$14], [%94, %$15] ; # ->
  %99 = inttoptr i64 %75 to i64*
  store i64 %98, i64* %99
  br label %$12
$11:
  %100 = phi i64 [%66, %$10] ; # A
  %101 = phi i64 [%69, %$10] ; # B
  %102 = phi i64 [%63, %$10] ; # P
; # (? (cnt? B) (set (big P) (consNum (x| (int B) (val (dig A))) (val...
; # (cnt? B)
  %103 = and i64 %101, 2
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$18, label %$17
$18:
  %105 = phi i64 [%100, %$11] ; # A
  %106 = phi i64 [%101, %$11] ; # B
  %107 = phi i64 [%102, %$11] ; # P
; # (set (big P) (consNum (x| (int B) (val (dig A))) (val (big A))))
; # (big P)
  %108 = add i64 %107, 4
; # (int B)
  %109 = lshr i64 %106, 4
; # (dig A)
  %110 = add i64 %105, -4
; # (val (dig A))
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
; # (x| (int B) (val (dig A)))
  %113 = xor i64 %109, %112
; # (big A)
  %114 = add i64 %105, 4
; # (val (big A))
  %115 = inttoptr i64 %114 to i64*
  %116 = load i64, i64* %115
; # (consNum (x| (int B) (val (dig A))) (val (big A)))
  %117 = call i64 @consNum(i64 %113, i64 %116)
  %118 = inttoptr i64 %108 to i64*
  store i64 %117, i64* %118
  br label %$12
$17:
  %119 = phi i64 [%100, %$11] ; # A
  %120 = phi i64 [%101, %$11] ; # B
  %121 = phi i64 [%102, %$11] ; # P
; # (set (big P) (boxNum (x| (val (dig A)) (val (dig B)))))
; # (big P)
  %122 = add i64 %121, 4
; # (dig A)
  %123 = add i64 %119, -4
; # (val (dig A))
  %124 = inttoptr i64 %123 to i64*
  %125 = load i64, i64* %124
; # (dig B)
  %126 = add i64 %120, -4
; # (val (dig B))
  %127 = inttoptr i64 %126 to i64*
  %128 = load i64, i64* %127
; # (x| (val (dig A)) (val (dig B)))
  %129 = xor i64 %125, %128
; # (boxNum (x| (val (dig A)) (val (dig B))))
  %130 = call i64 @boxNum(i64 %129)
  %131 = inttoptr i64 %122 to i64*
  store i64 %130, i64* %131
  br label %$10
$12:
  %132 = phi i64 [%95, %$16], [%105, %$18] ; # A
  %133 = phi i64 [%96, %$16], [%106, %$18] ; # B
  %134 = phi i64 [%97, %$16], [%107, %$18] ; # P
  %135 = phi i64 [%98, %$16], [%117, %$18] ; # ->
; # (zapZero R)
  %136 = call i64 @zapZero(i64 %52)
; # (drop *Safe)
  %137 = inttoptr i64 %54 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %139, i64* %140
  br label %$2
$2:
  %141 = phi i64 [%24, %$7], [%31, %$9], [%132, %$12] ; # A
  %142 = phi i64 [%25, %$7], [%32, %$9], [%133, %$12] ; # B
  %143 = phi i64 [%26, %$7], [%42, %$9], [%136, %$12] ; # ->
  ret i64 %143
}

define i64 @addu(i64, i64) {
$1:
; # (cond ((cnt? A) (if (cnt? B) (box64 (+ (int A) (int B))) (xchg 'A...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (box64 (+ (int A) (int B))) (xchg 'A 'B) (goto 1))
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (int A)
  %10 = lshr i64 %8, 4
; # (int B)
  %11 = lshr i64 %9, 4
; # (+ (int A) (int B))
  %12 = add i64 %10, %11
; # (box64 (+ (int A) (int B)))
  %13 = and i64 %12, 17293822569102704640
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$9
$8:
  %15 = call i64 @boxNum(i64 %12)
  br label %$10
$9:
  %16 = shl i64 %12, 4
  %17 = or i64 %16, 2
  br label %$10
$10:
  %18 = phi i64 [%15, %$8], [%17, %$9] ; # ->
  br label %$7
$6:
  %19 = phi i64 [%4, %$4] ; # A
  %20 = phi i64 [%5, %$4] ; # B
; # (xchg 'A 'B)
; # (goto 1)
  br label %$-1
$7:
  %21 = phi i64 [%8, %$10] ; # A
  %22 = phi i64 [%9, %$10] ; # B
  %23 = phi i64 [%18, %$10] ; # ->
  br label %$2
$3:
  %24 = phi i64 [%0, %$1] ; # A
  %25 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %26 = and i64 %25, 2
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$12, label %$11
$12:
  %28 = phi i64 [%24, %$3] ; # A
  %29 = phi i64 [%25, %$3] ; # B
; # (: 1 (let N (val (big A)) (setq B (add (int B) (val (dig A)))) (i...
  br label %$-1
$-1:
  %30 = phi i64 [%20, %$6], [%28, %$12] ; # A
  %31 = phi i64 [%19, %$6], [%29, %$12] ; # B
; # (let N (val (big A)) (setq B (add (int B) (val (dig A)))) (ifn @@...
; # (big A)
  %32 = add i64 %30, 4
; # (val (big A))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (int B)
  %35 = lshr i64 %31, 4
; # (dig A)
  %36 = add i64 %30, -4
; # (val (dig A))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (add (int B) (val (dig A)))
  %39 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %35, i64 %38)
  %40 = extractvalue {i64, i1} %39, 1
  %41 = extractvalue {i64, i1} %39, 0
; # (ifn @@ (consNum B N) (let R (save (setq B (consNum B N))) (loop ...
  br i1 %40, label %$14, label %$13
$13:
  %42 = phi i64 [%30, %$-1] ; # A
  %43 = phi i64 [%41, %$-1] ; # B
  %44 = phi i64 [%34, %$-1] ; # N
; # (consNum B N)
  %45 = call i64 @consNum(i64 %43, i64 %44)
  br label %$15
$14:
  %46 = phi i64 [%30, %$-1] ; # A
  %47 = phi i64 [%41, %$-1] ; # B
  %48 = phi i64 [%34, %$-1] ; # N
; # (let R (save (setq B (consNum B N))) (loop (? (cnt? N) (setq N (a...
; # (consNum B N)
  %49 = call i64 @consNum(i64 %47, i64 %48)
; # (save (setq B (consNum B N)))
  %50 = alloca i64, i64 2, align 16
  %51 = ptrtoint i64* %50 to i64
  %52 = inttoptr i64 %51 to i64*
  store i64 %49, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %54 = load i64, i64* %53
  %55 = inttoptr i64 %51 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  store i64 %54, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %57
; # (loop (? (cnt? N) (setq N (add N (hex "10"))) (set (big B) (ifn @...
  br label %$16
$16:
  %58 = phi i64 [%46, %$14], [%104, %$23] ; # A
  %59 = phi i64 [%49, %$14], [%109, %$23] ; # B
  %60 = phi i64 [%48, %$14], [%106, %$23] ; # N
; # (? (cnt? N) (setq N (add N (hex "10"))) (set (big B) (ifn @@ N (b...
; # (cnt? N)
  %61 = and i64 %60, 2
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$17
$19:
  %63 = phi i64 [%58, %$16] ; # A
  %64 = phi i64 [%59, %$16] ; # B
  %65 = phi i64 [%60, %$16] ; # N
; # (add N (hex "10"))
  %66 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %65, i64 16)
  %67 = extractvalue {i64, i1} %66, 1
  %68 = extractvalue {i64, i1} %66, 0
; # (set (big B) (ifn @@ N (boxNum (| (int N) (hex "1000000000000000"...
; # (big B)
  %69 = add i64 %64, 4
; # (ifn @@ N (boxNum (| (int N) (hex "1000000000000000"))))
  br i1 %67, label %$21, label %$20
$20:
  %70 = phi i64 [%63, %$19] ; # A
  %71 = phi i64 [%64, %$19] ; # B
  %72 = phi i64 [%68, %$19] ; # N
  br label %$22
$21:
  %73 = phi i64 [%63, %$19] ; # A
  %74 = phi i64 [%64, %$19] ; # B
  %75 = phi i64 [%68, %$19] ; # N
; # (int N)
  %76 = lshr i64 %75, 4
; # (| (int N) (hex "1000000000000000"))
  %77 = or i64 %76, 1152921504606846976
; # (boxNum (| (int N) (hex "1000000000000000")))
  %78 = call i64 @boxNum(i64 %77)
  br label %$22
$22:
  %79 = phi i64 [%70, %$20], [%73, %$21] ; # A
  %80 = phi i64 [%71, %$20], [%74, %$21] ; # B
  %81 = phi i64 [%72, %$20], [%75, %$21] ; # N
  %82 = phi i64 [%72, %$20], [%78, %$21] ; # ->
  %83 = inttoptr i64 %69 to i64*
  store i64 %82, i64* %83
  br label %$18
$17:
  %84 = phi i64 [%58, %$16] ; # A
  %85 = phi i64 [%59, %$16] ; # B
  %86 = phi i64 [%60, %$16] ; # N
; # (let D (val (dig N)) (setq N (val (big N)) D (add D 1)) (? (not @...
; # (dig N)
  %87 = add i64 %86, -4
; # (val (dig N))
  %88 = inttoptr i64 %87 to i64*
  %89 = load i64, i64* %88
; # (big N)
  %90 = add i64 %86, 4
; # (val (big N))
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (add D 1)
  %93 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %89, i64 1)
  %94 = extractvalue {i64, i1} %93, 1
  %95 = extractvalue {i64, i1} %93, 0
; # (? (not @@) (set (big B) (consNum D N)))
; # (not @@)
  %96 = icmp eq i1 %94, 0
  br i1 %96, label %$24, label %$23
$24:
  %97 = phi i64 [%84, %$17] ; # A
  %98 = phi i64 [%85, %$17] ; # B
  %99 = phi i64 [%92, %$17] ; # N
  %100 = phi i64 [%95, %$17] ; # D
; # (set (big B) (consNum D N))
; # (big B)
  %101 = add i64 %98, 4
; # (consNum D N)
  %102 = call i64 @consNum(i64 %100, i64 %99)
  %103 = inttoptr i64 %101 to i64*
  store i64 %102, i64* %103
  br label %$18
$23:
  %104 = phi i64 [%84, %$17] ; # A
  %105 = phi i64 [%85, %$17] ; # B
  %106 = phi i64 [%92, %$17] ; # N
  %107 = phi i64 [%95, %$17] ; # D
; # (set (big B) (consNum D N))
; # (big B)
  %108 = add i64 %105, 4
; # (consNum D N)
  %109 = call i64 @consNum(i64 %107, i64 %106)
  %110 = inttoptr i64 %108 to i64*
  store i64 %109, i64* %110
  br label %$16
$18:
  %111 = phi i64 [%79, %$22], [%97, %$24] ; # A
  %112 = phi i64 [%80, %$22], [%98, %$24] ; # B
  %113 = phi i64 [%81, %$22], [%99, %$24] ; # N
  %114 = phi i64 [%82, %$22], [%102, %$24] ; # ->
; # (drop *Safe)
  %115 = inttoptr i64 %51 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  %117 = load i64, i64* %116
  %118 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %117, i64* %118
  br label %$15
$15:
  %119 = phi i64 [%42, %$13], [%111, %$18] ; # A
  %120 = phi i64 [%43, %$13], [%112, %$18] ; # B
  %121 = phi i64 [%44, %$13], [%113, %$18] ; # N
  %122 = phi i64 [%45, %$13], [%49, %$18] ; # ->
  br label %$2
$11:
  %123 = phi i64 [%24, %$3] ; # A
  %124 = phi i64 [%25, %$3] ; # B
; # (let (N (add (val (dig A)) (val (dig B))) C @@ P (boxNum N) R (sa...
; # (dig A)
  %125 = add i64 %123, -4
; # (val (dig A))
  %126 = inttoptr i64 %125 to i64*
  %127 = load i64, i64* %126
; # (dig B)
  %128 = add i64 %124, -4
; # (val (dig B))
  %129 = inttoptr i64 %128 to i64*
  %130 = load i64, i64* %129
; # (add (val (dig A)) (val (dig B)))
  %131 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %127, i64 %130)
  %132 = extractvalue {i64, i1} %131, 1
  %133 = extractvalue {i64, i1} %131, 0
; # (boxNum N)
  %134 = call i64 @boxNum(i64 %133)
; # (save P)
  %135 = alloca i64, i64 2, align 16
  %136 = ptrtoint i64* %135 to i64
  %137 = inttoptr i64 %136 to i64*
  store i64 %134, i64* %137
  %138 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %139 = load i64, i64* %138
  %140 = inttoptr i64 %136 to i64*
  %141 = getelementptr i64, i64* %140, i32 1
  store i64 %139, i64* %141
  %142 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %136, i64* %142
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? A) (if (cnt...
  br label %$25
$25:
  %143 = phi i64 [%123, %$11], [%278, %$35] ; # A
  %144 = phi i64 [%124, %$11], [%279, %$35] ; # B
  %145 = phi i64 [%133, %$11], [%296, %$35] ; # N
  %146 = phi i1 [%132, %$11], [%295, %$35] ; # C
  %147 = phi i64 [%134, %$11], [%298, %$35] ; # P
; # (big A)
  %148 = add i64 %143, 4
; # (val (big A))
  %149 = inttoptr i64 %148 to i64*
  %150 = load i64, i64* %149
; # (big B)
  %151 = add i64 %144, 4
; # (val (big B))
  %152 = inttoptr i64 %151 to i64*
  %153 = load i64, i64* %152
; # (? (cnt? A) (if (cnt? B) (set (big P) (box64 (add (int A) (int B)...
; # (cnt? A)
  %154 = and i64 %150, 2
  %155 = icmp ne i64 %154, 0
  br i1 %155, label %$28, label %$26
$28:
  %156 = phi i64 [%150, %$25] ; # A
  %157 = phi i64 [%153, %$25] ; # B
  %158 = phi i64 [%145, %$25] ; # N
  %159 = phi i1 [%146, %$25] ; # C
  %160 = phi i64 [%147, %$25] ; # P
; # (if (cnt? B) (set (big P) (box64 (add (int A) (int B) C))) (xchg ...
; # (cnt? B)
  %161 = and i64 %157, 2
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$29, label %$30
$29:
  %163 = phi i64 [%156, %$28] ; # A
  %164 = phi i64 [%157, %$28] ; # B
  %165 = phi i64 [%158, %$28] ; # N
  %166 = phi i1 [%159, %$28] ; # C
  %167 = phi i64 [%160, %$28] ; # P
; # (set (big P) (box64 (add (int A) (int B) C)))
; # (big P)
  %168 = add i64 %167, 4
; # (int A)
  %169 = lshr i64 %163, 4
; # (int B)
  %170 = lshr i64 %164, 4
; # (add (int A) (int B) C)
  %171 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %169, i64 %170)
  %172 = extractvalue {i64, i1} %171, 1
  %173 = extractvalue {i64, i1} %171, 0
  %174 = zext i1 %166 to i64
  %175 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %173, i64 %174)
  %176 = extractvalue {i64, i1} %175, 1
  %177 = or i1 %172, %176
  %178 = extractvalue {i64, i1} %175, 0
; # (box64 (add (int A) (int B) C))
  %179 = and i64 %178, 17293822569102704640
  %180 = icmp ne i64 %179, 0
  br i1 %180, label %$32, label %$33
$32:
  %181 = call i64 @boxNum(i64 %178)
  br label %$34
$33:
  %182 = shl i64 %178, 4
  %183 = or i64 %182, 2
  br label %$34
$34:
  %184 = phi i64 [%181, %$32], [%183, %$33] ; # ->
  %185 = inttoptr i64 %168 to i64*
  store i64 %184, i64* %185
  br label %$31
$30:
  %186 = phi i64 [%156, %$28] ; # A
  %187 = phi i64 [%157, %$28] ; # B
  %188 = phi i64 [%158, %$28] ; # N
  %189 = phi i1 [%159, %$28] ; # C
  %190 = phi i64 [%160, %$28] ; # P
; # (xchg 'A 'B)
; # (goto 2)
  br label %$-2
$31:
  %191 = phi i64 [%163, %$34] ; # A
  %192 = phi i64 [%164, %$34] ; # B
  %193 = phi i64 [%165, %$34] ; # N
  %194 = phi i1 [%166, %$34] ; # C
  %195 = phi i64 [%167, %$34] ; # P
  %196 = phi i64 [%184, %$34] ; # ->
  br label %$27
$26:
  %197 = phi i64 [%150, %$25] ; # A
  %198 = phi i64 [%153, %$25] ; # B
  %199 = phi i64 [%145, %$25] ; # N
  %200 = phi i1 [%146, %$25] ; # C
  %201 = phi i64 [%147, %$25] ; # P
; # (? (cnt? B) (: 2 (setq N (add (int B) (val (dig A)) C) C @@) (loo...
; # (cnt? B)
  %202 = and i64 %198, 2
  %203 = icmp ne i64 %202, 0
  br i1 %203, label %$36, label %$35
$36:
  %204 = phi i64 [%197, %$26] ; # A
  %205 = phi i64 [%198, %$26] ; # B
  %206 = phi i64 [%199, %$26] ; # N
  %207 = phi i1 [%200, %$26] ; # C
  %208 = phi i64 [%201, %$26] ; # P
; # (: 2 (setq N (add (int B) (val (dig A)) C) C @@) (loop (setq P (s...
  br label %$-2
$-2:
  %209 = phi i64 [%187, %$30], [%204, %$36] ; # A
  %210 = phi i64 [%186, %$30], [%205, %$36] ; # B
  %211 = phi i64 [%188, %$30], [%206, %$36] ; # N
  %212 = phi i1 [%189, %$30], [%207, %$36] ; # C
  %213 = phi i64 [%190, %$30], [%208, %$36] ; # P
; # (int B)
  %214 = lshr i64 %210, 4
; # (dig A)
  %215 = add i64 %209, -4
; # (val (dig A))
  %216 = inttoptr i64 %215 to i64*
  %217 = load i64, i64* %216
; # (add (int B) (val (dig A)) C)
  %218 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %214, i64 %217)
  %219 = extractvalue {i64, i1} %218, 1
  %220 = extractvalue {i64, i1} %218, 0
  %221 = zext i1 %212 to i64
  %222 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %220, i64 %221)
  %223 = extractvalue {i64, i1} %222, 1
  %224 = or i1 %219, %223
  %225 = extractvalue {i64, i1} %222, 0
; # (loop (setq P (set (big P) (consNum N (setq A (val (big A)))))) (...
  br label %$37
$37:
  %226 = phi i64 [%209, %$-2], [%261, %$40] ; # A
  %227 = phi i64 [%210, %$-2], [%262, %$40] ; # B
  %228 = phi i64 [%225, %$-2], [%271, %$40] ; # N
  %229 = phi i1 [%224, %$-2], [%270, %$40] ; # C
  %230 = phi i64 [%213, %$-2], [%265, %$40] ; # P
; # (set (big P) (consNum N (setq A (val (big A)))))
; # (big P)
  %231 = add i64 %230, 4
; # (big A)
  %232 = add i64 %226, 4
; # (val (big A))
  %233 = inttoptr i64 %232 to i64*
  %234 = load i64, i64* %233
; # (consNum N (setq A (val (big A))))
  %235 = call i64 @consNum(i64 %228, i64 %234)
  %236 = inttoptr i64 %231 to i64*
  store i64 %235, i64* %236
; # (? (not C))
; # (not C)
  %237 = icmp eq i1 %229, 0
  br i1 %237, label %$39, label %$38
$38:
  %238 = phi i64 [%234, %$37] ; # A
  %239 = phi i64 [%227, %$37] ; # B
  %240 = phi i64 [%228, %$37] ; # N
  %241 = phi i1 [%229, %$37] ; # C
  %242 = phi i64 [%235, %$37] ; # P
; # (? (cnt? A) (set (big P) (box64 (+ (int A) C))))
; # (cnt? A)
  %243 = and i64 %238, 2
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$41, label %$40
$41:
  %245 = phi i64 [%238, %$38] ; # A
  %246 = phi i64 [%239, %$38] ; # B
  %247 = phi i64 [%240, %$38] ; # N
  %248 = phi i1 [%241, %$38] ; # C
  %249 = phi i64 [%242, %$38] ; # P
; # (set (big P) (box64 (+ (int A) C)))
; # (big P)
  %250 = add i64 %249, 4
; # (int A)
  %251 = lshr i64 %245, 4
; # (+ (int A) C)
  %252 = zext i1 %248 to i64
  %253 = add i64 %251, %252
; # (box64 (+ (int A) C))
  %254 = and i64 %253, 17293822569102704640
  %255 = icmp ne i64 %254, 0
  br i1 %255, label %$42, label %$43
$42:
  %256 = call i64 @boxNum(i64 %253)
  br label %$44
$43:
  %257 = shl i64 %253, 4
  %258 = or i64 %257, 2
  br label %$44
$44:
  %259 = phi i64 [%256, %$42], [%258, %$43] ; # ->
  %260 = inttoptr i64 %250 to i64*
  store i64 %259, i64* %260
  br label %$39
$40:
  %261 = phi i64 [%238, %$38] ; # A
  %262 = phi i64 [%239, %$38] ; # B
  %263 = phi i64 [%240, %$38] ; # N
  %264 = phi i1 [%241, %$38] ; # C
  %265 = phi i64 [%242, %$38] ; # P
; # (dig A)
  %266 = add i64 %261, -4
; # (val (dig A))
  %267 = inttoptr i64 %266 to i64*
  %268 = load i64, i64* %267
; # (add (val (dig A)) 1)
  %269 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %268, i64 1)
  %270 = extractvalue {i64, i1} %269, 1
  %271 = extractvalue {i64, i1} %269, 0
  br label %$37
$39:
  %272 = phi i64 [%234, %$37], [%245, %$44] ; # A
  %273 = phi i64 [%227, %$37], [%246, %$44] ; # B
  %274 = phi i64 [%228, %$37], [%247, %$44] ; # N
  %275 = phi i1 [%229, %$37], [%248, %$44] ; # C
  %276 = phi i64 [%235, %$37], [%249, %$44] ; # P
  %277 = phi i64 [0, %$37], [%259, %$44] ; # ->
  br label %$27
$35:
  %278 = phi i64 [%197, %$26] ; # A
  %279 = phi i64 [%198, %$26] ; # B
  %280 = phi i64 [%199, %$26] ; # N
  %281 = phi i1 [%200, %$26] ; # C
  %282 = phi i64 [%201, %$26] ; # P
; # (dig A)
  %283 = add i64 %278, -4
; # (val (dig A))
  %284 = inttoptr i64 %283 to i64*
  %285 = load i64, i64* %284
; # (dig B)
  %286 = add i64 %279, -4
; # (val (dig B))
  %287 = inttoptr i64 %286 to i64*
  %288 = load i64, i64* %287
; # (add (val (dig A)) (val (dig B)) C)
  %289 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %285, i64 %288)
  %290 = extractvalue {i64, i1} %289, 1
  %291 = extractvalue {i64, i1} %289, 0
  %292 = zext i1 %281 to i64
  %293 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %291, i64 %292)
  %294 = extractvalue {i64, i1} %293, 1
  %295 = or i1 %290, %294
  %296 = extractvalue {i64, i1} %293, 0
; # (set (big P) (boxNum N))
; # (big P)
  %297 = add i64 %282, 4
; # (boxNum N)
  %298 = call i64 @boxNum(i64 %296)
  %299 = inttoptr i64 %297 to i64*
  store i64 %298, i64* %299
  br label %$25
$27:
  %300 = phi i64 [%191, %$31], [%272, %$39] ; # A
  %301 = phi i64 [%192, %$31], [%273, %$39] ; # B
  %302 = phi i64 [%193, %$31], [%274, %$39] ; # N
  %303 = phi i1 [%194, %$31], [%275, %$39] ; # C
  %304 = phi i64 [%195, %$31], [%276, %$39] ; # P
  %305 = phi i64 [%196, %$31], [%277, %$39] ; # ->
; # (drop *Safe)
  %306 = inttoptr i64 %136 to i64*
  %307 = getelementptr i64, i64* %306, i32 1
  %308 = load i64, i64* %307
  %309 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %308, i64* %309
  br label %$2
$2:
  %310 = phi i64 [%21, %$7], [%119, %$15], [%300, %$27] ; # A
  %311 = phi i64 [%22, %$7], [%120, %$15], [%301, %$27] ; # B
  %312 = phi i64 [%23, %$7], [%122, %$15], [%134, %$27] ; # ->
  ret i64 %312
}

define i64 @sub1(i64, i64) {
$1:
; # (dig B)
  %2 = add i64 %0, -4
; # (val (dig B))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (int N)
  %5 = lshr i64 %1, 4
; # (sub (val (dig B)) (int N))
  %6 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %4, i64 %5)
  %7 = extractvalue {i64, i1} %6, 1
  %8 = extractvalue {i64, i1} %6, 0
; # (big B)
  %9 = add i64 %0, 4
; # (val (big B))
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
; # (nond (@@ (if (== B ZERO) (box64 N) (consNum N B))) ((big? B) (se...
  br i1 %7, label %$3, label %$4
$4:
  %12 = phi i64 [%11, %$1] ; # B
  %13 = phi i64 [%8, %$1] ; # N
; # (if (== B ZERO) (box64 N) (consNum N B))
; # (== B ZERO)
  %14 = icmp eq i64 %12, 2
  br i1 %14, label %$5, label %$6
$5:
  %15 = phi i64 [%12, %$4] ; # B
  %16 = phi i64 [%13, %$4] ; # N
; # (box64 N)
  %17 = and i64 %16, 17293822569102704640
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$8, label %$9
$8:
  %19 = call i64 @boxNum(i64 %16)
  br label %$10
$9:
  %20 = shl i64 %16, 4
  %21 = or i64 %20, 2
  br label %$10
$10:
  %22 = phi i64 [%19, %$8], [%21, %$9] ; # ->
  br label %$7
$6:
  %23 = phi i64 [%12, %$4] ; # B
  %24 = phi i64 [%13, %$4] ; # N
; # (consNum N B)
  %25 = call i64 @consNum(i64 %24, i64 %23)
  br label %$7
$7:
  %26 = phi i64 [%15, %$10], [%23, %$6] ; # B
  %27 = phi i64 [%16, %$10], [%24, %$6] ; # N
  %28 = phi i64 [%22, %$10], [%25, %$6] ; # ->
  br label %$2
$3:
  %29 = phi i64 [%11, %$1] ; # B
  %30 = phi i64 [%8, %$1] ; # N
; # (big? B)
  %31 = and i64 %29, 4
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$12
$12:
  %33 = phi i64 [%29, %$3] ; # B
  %34 = phi i64 [%30, %$3] ; # N
; # (sub B (hex "10"))
  %35 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %33, i64 16)
  %36 = extractvalue {i64, i1} %35, 1
  %37 = extractvalue {i64, i1} %35, 0
; # (if @@ (sign (cnt (- N))) (zapZero (consNum N B)))
  br i1 %36, label %$13, label %$14
$13:
  %38 = phi i64 [%37, %$12] ; # B
  %39 = phi i64 [%34, %$12] ; # N
; # (- N)
  %40 = sub i64 0, %39
; # (cnt (- N))
  %41 = shl i64 %40, 4
  %42 = or i64 %41, 2
; # (sign (cnt (- N)))
  %43 = or i64 %42, 8
  br label %$15
$14:
  %44 = phi i64 [%37, %$12] ; # B
  %45 = phi i64 [%34, %$12] ; # N
; # (consNum N B)
  %46 = call i64 @consNum(i64 %45, i64 %44)
; # (zapZero (consNum N B))
  %47 = call i64 @zapZero(i64 %46)
  br label %$15
$15:
  %48 = phi i64 [%38, %$13], [%44, %$14] ; # B
  %49 = phi i64 [%39, %$13], [%45, %$14] ; # N
  %50 = phi i64 [%43, %$13], [%47, %$14] ; # ->
  br label %$2
$11:
  %51 = phi i64 [%29, %$3] ; # B
  %52 = phi i64 [%30, %$3] ; # N
; # (let (P (boxNum N B) R (save P)) (loop (setq N (sub (val (dig B))...
; # (boxNum N B)
  %53 = call i64 @boxNum(i64 %52)
; # (save P)
  %54 = alloca i64, i64 2, align 16
  %55 = ptrtoint i64* %54 to i64
  %56 = inttoptr i64 %55 to i64*
  store i64 %53, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %58 = load i64, i64* %57
  %59 = inttoptr i64 %55 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  store i64 %58, i64* %60
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %61
; # (loop (setq N (sub (val (dig B)) 1) B (val (big B))) (? (not @@) ...
  br label %$16
$16:
  %62 = phi i64 [%51, %$11], [%97, %$20] ; # B
  %63 = phi i64 [%52, %$11], [%98, %$20] ; # N
  %64 = phi i64 [%53, %$11], [%99, %$20] ; # P
; # (dig B)
  %65 = add i64 %62, -4
; # (val (dig B))
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
; # (sub (val (dig B)) 1)
  %68 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %67, i64 1)
  %69 = extractvalue {i64, i1} %68, 1
  %70 = extractvalue {i64, i1} %68, 0
; # (big B)
  %71 = add i64 %62, 4
; # (val (big B))
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
; # (? (not @@) (set (big P) (consNum N B)))
; # (not @@)
  %74 = icmp eq i1 %69, 0
  br i1 %74, label %$19, label %$17
$19:
  %75 = phi i64 [%73, %$16] ; # B
  %76 = phi i64 [%70, %$16] ; # N
  %77 = phi i64 [%64, %$16] ; # P
; # (set (big P) (consNum N B))
; # (big P)
  %78 = add i64 %77, 4
; # (consNum N B)
  %79 = call i64 @consNum(i64 %76, i64 %75)
  %80 = inttoptr i64 %78 to i64*
  store i64 %79, i64* %80
  br label %$18
$17:
  %81 = phi i64 [%73, %$16] ; # B
  %82 = phi i64 [%70, %$16] ; # N
  %83 = phi i64 [%64, %$16] ; # P
; # (set (big P) (consNum N B))
; # (big P)
  %84 = add i64 %83, 4
; # (consNum N B)
  %85 = call i64 @consNum(i64 %82, i64 %81)
  %86 = inttoptr i64 %84 to i64*
  store i64 %85, i64* %86
; # (? (cnt? B) (set (big P) (sub B (hex "10"))))
; # (cnt? B)
  %87 = and i64 %81, 2
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$21, label %$20
$21:
  %89 = phi i64 [%81, %$17] ; # B
  %90 = phi i64 [%82, %$17] ; # N
  %91 = phi i64 [%85, %$17] ; # P
; # (set (big P) (sub B (hex "10")))
; # (big P)
  %92 = add i64 %91, 4
; # (sub B (hex "10"))
  %93 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %89, i64 16)
  %94 = extractvalue {i64, i1} %93, 1
  %95 = extractvalue {i64, i1} %93, 0
  %96 = inttoptr i64 %92 to i64*
  store i64 %95, i64* %96
  br label %$18
$20:
  %97 = phi i64 [%81, %$17] ; # B
  %98 = phi i64 [%82, %$17] ; # N
  %99 = phi i64 [%85, %$17] ; # P
  br label %$16
$18:
  %100 = phi i64 [%75, %$19], [%89, %$21] ; # B
  %101 = phi i64 [%76, %$19], [%90, %$21] ; # N
  %102 = phi i64 [%77, %$19], [%91, %$21] ; # P
  %103 = phi i64 [%79, %$19], [%95, %$21] ; # ->
; # (zapZero R)
  %104 = call i64 @zapZero(i64 %53)
; # (drop *Safe)
  %105 = inttoptr i64 %55 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %108
  br label %$2
$2:
  %109 = phi i64 [%26, %$7], [%48, %$15], [%100, %$18] ; # B
  %110 = phi i64 [%27, %$7], [%49, %$15], [%101, %$18] ; # N
  %111 = phi i64 [%28, %$7], [%50, %$15], [%104, %$18] ; # ->
  ret i64 %111
}

define i64 @subu(i64, i64) {
$1:
; # (cond ((cnt? A) (if (cnt? B) (let N (sub A (& B -3)) (if @@ (+ (x...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) (let N (sub A (& B -3)) (if @@ (+ (x| N -16) (hex "1...
; # (cnt? B)
  %6 = and i64 %5, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$4] ; # A
  %9 = phi i64 [%5, %$4] ; # B
; # (let N (sub A (& B -3)) (if @@ (+ (x| N -16) (hex "18")) N))
; # (& B -3)
  %10 = and i64 %9, -3
; # (sub A (& B -3))
  %11 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %8, i64 %10)
  %12 = extractvalue {i64, i1} %11, 1
  %13 = extractvalue {i64, i1} %11, 0
; # (if @@ (+ (x| N -16) (hex "18")) N)
  br i1 %12, label %$8, label %$9
$8:
  %14 = phi i64 [%8, %$5] ; # A
  %15 = phi i64 [%9, %$5] ; # B
; # (x| N -16)
  %16 = xor i64 %13, -16
; # (+ (x| N -16) (hex "18"))
  %17 = add i64 %16, 24
  br label %$10
$9:
  %18 = phi i64 [%8, %$5] ; # A
  %19 = phi i64 [%9, %$5] ; # B
  br label %$10
$10:
  %20 = phi i64 [%14, %$8], [%18, %$9] ; # A
  %21 = phi i64 [%15, %$8], [%19, %$9] ; # B
  %22 = phi i64 [%17, %$8], [%13, %$9] ; # ->
  br label %$7
$6:
  %23 = phi i64 [%4, %$4] ; # A
  %24 = phi i64 [%5, %$4] ; # B
; # (sub1 B A)
  %25 = call i64 @sub1(i64 %24, i64 %23)
; # (neg (sub1 B A))
  %26 = icmp eq i64 %25, 2
  br i1 %26, label %$11, label %$12
$11:
  br label %$13
$12:
  %27 = xor i64 %25, 8
  br label %$13
$13:
  %28 = phi i64 [%25, %$11], [%27, %$12] ; # ->
  br label %$7
$7:
  %29 = phi i64 [%20, %$10], [%23, %$13] ; # A
  %30 = phi i64 [%21, %$10], [%24, %$13] ; # B
  %31 = phi i64 [%22, %$10], [%28, %$13] ; # ->
  br label %$2
$3:
  %32 = phi i64 [%0, %$1] ; # A
  %33 = phi i64 [%1, %$1] ; # B
; # (cnt? B)
  %34 = and i64 %33, 2
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = phi i64 [%32, %$3] ; # A
  %37 = phi i64 [%33, %$3] ; # B
; # (sub1 A B)
  %38 = call i64 @sub1(i64 %36, i64 %37)
  br label %$2
$14:
  %39 = phi i64 [%32, %$3] ; # A
  %40 = phi i64 [%33, %$3] ; # B
; # (let (N (sub (val (dig A)) (val (dig B))) C @@ P (boxNum N) R (sa...
; # (dig A)
  %41 = add i64 %39, -4
; # (val (dig A))
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
; # (dig B)
  %44 = add i64 %40, -4
; # (val (dig B))
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (sub (val (dig A)) (val (dig B)))
  %47 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %43, i64 %46)
  %48 = extractvalue {i64, i1} %47, 1
  %49 = extractvalue {i64, i1} %47, 0
; # (boxNum N)
  %50 = call i64 @boxNum(i64 %49)
; # (save P)
  %51 = alloca i64, i64 2, align 16
  %52 = ptrtoint i64* %51 to i64
  %53 = inttoptr i64 %52 to i64*
  store i64 %50, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = inttoptr i64 %52 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  store i64 %55, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %58
; # (loop (setq A (val (big A)) B (val (big B))) (? (cnt? B) (setq B ...
  br label %$16
$16:
  %59 = phi i64 [%39, %$14], [%177, %$25] ; # A
  %60 = phi i64 [%40, %$14], [%178, %$25] ; # B
  %61 = phi i64 [%49, %$14], [%195, %$25] ; # N
  %62 = phi i1 [%48, %$14], [%194, %$25] ; # C
  %63 = phi i64 [%50, %$14], [%197, %$25] ; # P
; # (big A)
  %64 = add i64 %59, 4
; # (val (big A))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (big B)
  %67 = add i64 %60, 4
; # (val (big B))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (? (cnt? B) (setq B (int B)) (until (cnt? A) (setq N (sub (val (d...
; # (cnt? B)
  %70 = and i64 %69, 2
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$19, label %$17
$19:
  %72 = phi i64 [%66, %$16] ; # A
  %73 = phi i64 [%69, %$16] ; # B
  %74 = phi i64 [%61, %$16] ; # N
  %75 = phi i1 [%62, %$16] ; # C
  %76 = phi i64 [%63, %$16] ; # P
; # (int B)
  %77 = lshr i64 %73, 4
; # (until (cnt? A) (setq N (sub (val (dig A)) B C) C @@ A (val (big ...
  br label %$20
$20:
  %78 = phi i64 [%72, %$19], [%117, %$24] ; # A
  %79 = phi i64 [%77, %$19], [0, %$24] ; # B
  %80 = phi i64 [%74, %$19], [%119, %$24] ; # N
  %81 = phi i1 [%75, %$19], [%120, %$24] ; # C
  %82 = phi i64 [%76, %$19], [%121, %$24] ; # P
; # (cnt? A)
  %83 = and i64 %78, 2
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$22, label %$21
$21:
  %85 = phi i64 [%78, %$20] ; # A
  %86 = phi i64 [%79, %$20] ; # B
  %87 = phi i64 [%80, %$20] ; # N
  %88 = phi i1 [%81, %$20] ; # C
  %89 = phi i64 [%82, %$20] ; # P
; # (dig A)
  %90 = add i64 %85, -4
; # (val (dig A))
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (sub (val (dig A)) B C)
  %93 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %92, i64 %86)
  %94 = extractvalue {i64, i1} %93, 1
  %95 = extractvalue {i64, i1} %93, 0
  %96 = zext i1 %88 to i64
  %97 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %95, i64 %96)
  %98 = extractvalue {i64, i1} %97, 1
  %99 = or i1 %94, %98
  %100 = extractvalue {i64, i1} %97, 0
; # (big A)
  %101 = add i64 %85, 4
; # (val (big A))
  %102 = inttoptr i64 %101 to i64*
  %103 = load i64, i64* %102
; # (set (big P) (consNum N A))
; # (big P)
  %104 = add i64 %89, 4
; # (consNum N A)
  %105 = call i64 @consNum(i64 %100, i64 %103)
  %106 = inttoptr i64 %104 to i64*
  store i64 %105, i64* %106
; # (unless C (ret (zapZero R)))
  br i1 %99, label %$24, label %$23
$23:
  %107 = phi i64 [%103, %$21] ; # A
  %108 = phi i64 [%86, %$21] ; # B
  %109 = phi i64 [%100, %$21] ; # N
  %110 = phi i1 [%99, %$21] ; # C
  %111 = phi i64 [%105, %$21] ; # P
; # (zapZero R)
  %112 = call i64 @zapZero(i64 %50)
; # (ret (zapZero R))
; # (drop *Safe)
  %113 = inttoptr i64 %52 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  %115 = load i64, i64* %114
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %115, i64* %116
  ret i64 %112
$24:
  %117 = phi i64 [%103, %$21] ; # A
  %118 = phi i64 [%86, %$21] ; # B
  %119 = phi i64 [%100, %$21] ; # N
  %120 = phi i1 [%99, %$21] ; # C
  %121 = phi i64 [%105, %$21] ; # P
  br label %$20
$22:
  %122 = phi i64 [%78, %$20] ; # A
  %123 = phi i64 [%79, %$20] ; # B
  %124 = phi i64 [%80, %$20] ; # N
  %125 = phi i1 [%81, %$20] ; # C
  %126 = phi i64 [%82, %$20] ; # P
; # (int A)
  %127 = lshr i64 %122, 4
  br label %$18
$17:
  %128 = phi i64 [%66, %$16] ; # A
  %129 = phi i64 [%69, %$16] ; # B
  %130 = phi i64 [%61, %$16] ; # N
  %131 = phi i1 [%62, %$16] ; # C
  %132 = phi i64 [%63, %$16] ; # P
; # (? (cnt? A) (setq A (int A)) (loop (setq N (sub A (val (dig B)) C...
; # (cnt? A)
  %133 = and i64 %128, 2
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$26, label %$25
$26:
  %135 = phi i64 [%128, %$17] ; # A
  %136 = phi i64 [%129, %$17] ; # B
  %137 = phi i64 [%130, %$17] ; # N
  %138 = phi i1 [%131, %$17] ; # C
  %139 = phi i64 [%132, %$17] ; # P
; # (int A)
  %140 = lshr i64 %135, 4
; # (loop (setq N (sub A (val (dig B)) C) C @@ P (set (big P) (boxNum...
  br label %$27
$27:
  %141 = phi i64 [%140, %$26], [%165, %$28] ; # A
  %142 = phi i64 [%136, %$26], [%166, %$28] ; # B
  %143 = phi i64 [%137, %$26], [%167, %$28] ; # N
  %144 = phi i1 [%138, %$26], [%168, %$28] ; # C
  %145 = phi i64 [%139, %$26], [%169, %$28] ; # P
; # (dig B)
  %146 = add i64 %142, -4
; # (val (dig B))
  %147 = inttoptr i64 %146 to i64*
  %148 = load i64, i64* %147
; # (sub A (val (dig B)) C)
  %149 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %141, i64 %148)
  %150 = extractvalue {i64, i1} %149, 1
  %151 = extractvalue {i64, i1} %149, 0
  %152 = zext i1 %144 to i64
  %153 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %151, i64 %152)
  %154 = extractvalue {i64, i1} %153, 1
  %155 = or i1 %150, %154
  %156 = extractvalue {i64, i1} %153, 0
; # (set (big P) (boxNum N))
; # (big P)
  %157 = add i64 %145, 4
; # (boxNum N)
  %158 = call i64 @boxNum(i64 %156)
  %159 = inttoptr i64 %157 to i64*
  store i64 %158, i64* %159
; # (? (cnt? (setq B (val (big B)))))
; # (big B)
  %160 = add i64 %142, 4
; # (val (big B))
  %161 = inttoptr i64 %160 to i64*
  %162 = load i64, i64* %161
; # (cnt? (setq B (val (big B))))
  %163 = and i64 %162, 2
  %164 = icmp ne i64 %163, 0
  br i1 %164, label %$29, label %$28
$28:
  %165 = phi i64 [0, %$27] ; # A
  %166 = phi i64 [%162, %$27] ; # B
  %167 = phi i64 [%156, %$27] ; # N
  %168 = phi i1 [%155, %$27] ; # C
  %169 = phi i64 [%158, %$27] ; # P
  br label %$27
$29:
  %170 = phi i64 [0, %$27] ; # A
  %171 = phi i64 [%162, %$27] ; # B
  %172 = phi i64 [%156, %$27] ; # N
  %173 = phi i1 [%155, %$27] ; # C
  %174 = phi i64 [%158, %$27] ; # P
  %175 = phi i64 [0, %$27] ; # ->
; # (int B)
  %176 = lshr i64 %171, 4
  br label %$18
$25:
  %177 = phi i64 [%128, %$17] ; # A
  %178 = phi i64 [%129, %$17] ; # B
  %179 = phi i64 [%130, %$17] ; # N
  %180 = phi i1 [%131, %$17] ; # C
  %181 = phi i64 [%132, %$17] ; # P
; # (dig A)
  %182 = add i64 %177, -4
; # (val (dig A))
  %183 = inttoptr i64 %182 to i64*
  %184 = load i64, i64* %183
; # (dig B)
  %185 = add i64 %178, -4
; # (val (dig B))
  %186 = inttoptr i64 %185 to i64*
  %187 = load i64, i64* %186
; # (sub (val (dig A)) (val (dig B)) C)
  %188 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %184, i64 %187)
  %189 = extractvalue {i64, i1} %188, 1
  %190 = extractvalue {i64, i1} %188, 0
  %191 = zext i1 %180 to i64
  %192 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %190, i64 %191)
  %193 = extractvalue {i64, i1} %192, 1
  %194 = or i1 %189, %193
  %195 = extractvalue {i64, i1} %192, 0
; # (set (big P) (boxNum N))
; # (big P)
  %196 = add i64 %181, 4
; # (boxNum N)
  %197 = call i64 @boxNum(i64 %195)
  %198 = inttoptr i64 %196 to i64*
  store i64 %197, i64* %198
  br label %$16
$18:
  %199 = phi i64 [%127, %$22], [%170, %$29] ; # A
  %200 = phi i64 [%123, %$22], [%176, %$29] ; # B
  %201 = phi i64 [%124, %$22], [%172, %$29] ; # N
  %202 = phi i1 [%125, %$22], [%173, %$29] ; # C
  %203 = phi i64 [%126, %$22], [%174, %$29] ; # P
  %204 = phi i64 [%127, %$22], [%176, %$29] ; # ->
; # (set (big P) (cnt (sub A B C)))
; # (big P)
  %205 = add i64 %203, 4
; # (sub A B C)
  %206 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %199, i64 %200)
  %207 = extractvalue {i64, i1} %206, 1
  %208 = extractvalue {i64, i1} %206, 0
  %209 = zext i1 %202 to i64
  %210 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %208, i64 %209)
  %211 = extractvalue {i64, i1} %210, 1
  %212 = or i1 %207, %211
  %213 = extractvalue {i64, i1} %210, 0
; # (cnt (sub A B C))
  %214 = shl i64 %213, 4
  %215 = or i64 %214, 2
  %216 = inttoptr i64 %205 to i64*
  store i64 %215, i64* %216
; # (ifn @@ (zapZero R) (let Q R (loop (set (dig Q) (x| (val (dig Q))...
  br i1 %212, label %$31, label %$30
$30:
  %217 = phi i64 [%199, %$18] ; # A
  %218 = phi i64 [%200, %$18] ; # B
  %219 = phi i64 [%201, %$18] ; # N
  %220 = phi i1 [%202, %$18] ; # C
  %221 = phi i64 [%203, %$18] ; # P
; # (zapZero R)
  %222 = call i64 @zapZero(i64 %50)
  br label %$32
$31:
  %223 = phi i64 [%199, %$18] ; # A
  %224 = phi i64 [%200, %$18] ; # B
  %225 = phi i64 [%201, %$18] ; # N
  %226 = phi i1 [%202, %$18] ; # C
  %227 = phi i64 [%203, %$18] ; # P
; # (let Q R (loop (set (dig Q) (x| (val (dig Q)) -1)) (? (cnt? (setq...
; # (loop (set (dig Q) (x| (val (dig Q)) -1)) (? (cnt? (setq N (val (...
  br label %$33
$33:
  %228 = phi i64 [%223, %$31], [%245, %$34] ; # A
  %229 = phi i64 [%224, %$31], [%246, %$34] ; # B
  %230 = phi i64 [%225, %$31], [%247, %$34] ; # N
  %231 = phi i1 [%226, %$31], [%248, %$34] ; # C
  %232 = phi i64 [%227, %$31], [%249, %$34] ; # P
  %233 = phi i64 [%50, %$31], [%247, %$34] ; # Q
; # (set (dig Q) (x| (val (dig Q)) -1))
; # (dig Q)
  %234 = add i64 %233, -4
; # (dig Q)
  %235 = add i64 %233, -4
; # (val (dig Q))
  %236 = inttoptr i64 %235 to i64*
  %237 = load i64, i64* %236
; # (x| (val (dig Q)) -1)
  %238 = xor i64 %237, -1
  %239 = inttoptr i64 %234 to i64*
  store i64 %238, i64* %239
; # (? (cnt? (setq N (val (big Q)))))
; # (big Q)
  %240 = add i64 %233, 4
; # (val (big Q))
  %241 = inttoptr i64 %240 to i64*
  %242 = load i64, i64* %241
; # (cnt? (setq N (val (big Q))))
  %243 = and i64 %242, 2
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$35, label %$34
$34:
  %245 = phi i64 [%228, %$33] ; # A
  %246 = phi i64 [%229, %$33] ; # B
  %247 = phi i64 [%242, %$33] ; # N
  %248 = phi i1 [%231, %$33] ; # C
  %249 = phi i64 [%232, %$33] ; # P
  %250 = phi i64 [%233, %$33] ; # Q
  br label %$33
$35:
  %251 = phi i64 [%228, %$33] ; # A
  %252 = phi i64 [%229, %$33] ; # B
  %253 = phi i64 [%242, %$33] ; # N
  %254 = phi i1 [%231, %$33] ; # C
  %255 = phi i64 [%232, %$33] ; # P
  %256 = phi i64 [%233, %$33] ; # Q
  %257 = phi i64 [0, %$33] ; # ->
; # (set (big Q) (x| N -16))
; # (big Q)
  %258 = add i64 %256, 4
; # (x| N -16)
  %259 = xor i64 %253, -16
  %260 = inttoptr i64 %258 to i64*
  store i64 %259, i64* %260
; # (let Q R (loop (set (dig Q) (add (val (dig Q)) 1)) (unless @@ (go...
; # (loop (set (dig Q) (add (val (dig Q)) 1)) (unless @@ (goto 9)) (?...
  br label %$36
$36:
  %261 = phi i64 [%251, %$35], [%292, %$39] ; # A
  %262 = phi i64 [%252, %$35], [%293, %$39] ; # B
  %263 = phi i64 [%253, %$35], [%294, %$39] ; # N
  %264 = phi i1 [%254, %$35], [%295, %$39] ; # C
  %265 = phi i64 [%255, %$35], [%296, %$39] ; # P
  %266 = phi i64 [%50, %$35], [%294, %$39] ; # Q
; # (set (dig Q) (add (val (dig Q)) 1))
; # (dig Q)
  %267 = add i64 %266, -4
; # (dig Q)
  %268 = add i64 %266, -4
; # (val (dig Q))
  %269 = inttoptr i64 %268 to i64*
  %270 = load i64, i64* %269
; # (add (val (dig Q)) 1)
  %271 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %270, i64 1)
  %272 = extractvalue {i64, i1} %271, 1
  %273 = extractvalue {i64, i1} %271, 0
  %274 = inttoptr i64 %267 to i64*
  store i64 %273, i64* %274
; # (unless @@ (goto 9))
  br i1 %272, label %$38, label %$37
$37:
  %275 = phi i64 [%261, %$36] ; # A
  %276 = phi i64 [%262, %$36] ; # B
  %277 = phi i64 [%263, %$36] ; # N
  %278 = phi i1 [%264, %$36] ; # C
  %279 = phi i64 [%265, %$36] ; # P
  %280 = phi i64 [%266, %$36] ; # Q
; # (goto 9)
  br label %$-9
$38:
  %281 = phi i64 [%261, %$36] ; # A
  %282 = phi i64 [%262, %$36] ; # B
  %283 = phi i64 [%263, %$36] ; # N
  %284 = phi i1 [%264, %$36] ; # C
  %285 = phi i64 [%265, %$36] ; # P
  %286 = phi i64 [%266, %$36] ; # Q
; # (? (cnt? (setq N (val (big Q)))))
; # (big Q)
  %287 = add i64 %286, 4
; # (val (big Q))
  %288 = inttoptr i64 %287 to i64*
  %289 = load i64, i64* %288
; # (cnt? (setq N (val (big Q))))
  %290 = and i64 %289, 2
  %291 = icmp ne i64 %290, 0
  br i1 %291, label %$40, label %$39
$39:
  %292 = phi i64 [%281, %$38] ; # A
  %293 = phi i64 [%282, %$38] ; # B
  %294 = phi i64 [%289, %$38] ; # N
  %295 = phi i1 [%284, %$38] ; # C
  %296 = phi i64 [%285, %$38] ; # P
  %297 = phi i64 [%286, %$38] ; # Q
  br label %$36
$40:
  %298 = phi i64 [%281, %$38] ; # A
  %299 = phi i64 [%282, %$38] ; # B
  %300 = phi i64 [%289, %$38] ; # N
  %301 = phi i1 [%284, %$38] ; # C
  %302 = phi i64 [%285, %$38] ; # P
  %303 = phi i64 [%286, %$38] ; # Q
  %304 = phi i64 [0, %$38] ; # ->
; # (set (big Q) (+ N (hex "10")))
; # (big Q)
  %305 = add i64 %303, 4
; # (+ N (hex "10"))
  %306 = add i64 %300, 16
  %307 = inttoptr i64 %305 to i64*
  store i64 %306, i64* %307
; # (: 9 (sign (zapZero R)))
  br label %$-9
$-9:
  %308 = phi i64 [%275, %$37], [%298, %$40] ; # A
  %309 = phi i64 [%276, %$37], [%299, %$40] ; # B
  %310 = phi i64 [%277, %$37], [%300, %$40] ; # N
  %311 = phi i1 [%278, %$37], [%301, %$40] ; # C
  %312 = phi i64 [%279, %$37], [%302, %$40] ; # P
; # (zapZero R)
  %313 = call i64 @zapZero(i64 %50)
; # (sign (zapZero R))
  %314 = or i64 %313, 8
  br label %$32
$32:
  %315 = phi i64 [%217, %$30], [%308, %$-9] ; # A
  %316 = phi i64 [%218, %$30], [%309, %$-9] ; # B
  %317 = phi i64 [%219, %$30], [%310, %$-9] ; # N
  %318 = phi i1 [%220, %$30], [%311, %$-9] ; # C
  %319 = phi i64 [%221, %$30], [%312, %$-9] ; # P
  %320 = phi i64 [%222, %$30], [%314, %$-9] ; # ->
; # (drop *Safe)
  %321 = inttoptr i64 %52 to i64*
  %322 = getelementptr i64, i64* %321, i32 1
  %323 = load i64, i64* %322
  %324 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %323, i64* %324
  br label %$2
$2:
  %325 = phi i64 [%29, %$7], [%36, %$15], [%315, %$32] ; # A
  %326 = phi i64 [%30, %$7], [%37, %$15], [%316, %$32] ; # B
  %327 = phi i64 [%31, %$7], [%38, %$15], [%320, %$32] ; # ->
  ret i64 %327
}

define i64 @mulu(i64, i64) {
$1:
; # (cond ((== A ZERO) A) ((cnt? A) (setq A (int A)) (if (cnt? B) (le...
; # (== A ZERO)
  %2 = icmp eq i64 %0, 2
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # A
  %4 = phi i64 [%1, %$1] ; # B
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # A
  %6 = phi i64 [%1, %$1] ; # B
; # (cnt? A)
  %7 = and i64 %5, 2
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i64 [%5, %$3] ; # A
  %10 = phi i64 [%6, %$3] ; # B
; # (int A)
  %11 = lshr i64 %9, 4
; # (if (cnt? B) (let N (mul A (int B)) (if (or @@@ (& N (hex "F00000...
; # (cnt? B)
  %12 = and i64 %10, 2
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$7, label %$8
$7:
  %14 = phi i64 [%11, %$6] ; # A
  %15 = phi i64 [%10, %$6] ; # B
; # (let N (mul A (int B)) (if (or @@@ (& N (hex "F000000000000000"))...
; # (int B)
  %16 = lshr i64 %15, 4
; # (mul A (int B))
  %17 = zext i64 %14 to i128
  %18 = zext i64 %16 to i128
  %19 = mul i128 %17, %18
  %20 = lshr i128 %19, 64
  %21 = trunc i128 %20 to i64
  %22 = trunc i128 %19 to i64
; # (if (or @@@ (& N (hex "F000000000000000"))) (consNum N (cnt @@@))...
; # (or @@@ (& N (hex "F000000000000000")))
  %23 = icmp ne i64 %21, 0
  br i1 %23, label %$10, label %$11
$11:
  %24 = phi i64 [%14, %$7] ; # A
  %25 = phi i64 [%15, %$7] ; # B
; # (& N (hex "F000000000000000"))
  %26 = and i64 %22, 17293822569102704640
  %27 = icmp ne i64 %26, 0
  br label %$10
$10:
  %28 = phi i64 [%14, %$7], [%24, %$11] ; # A
  %29 = phi i64 [%15, %$7], [%25, %$11] ; # B
  %30 = phi i1 [1, %$7], [%27, %$11] ; # ->
  br i1 %30, label %$12, label %$13
$12:
  %31 = phi i64 [%28, %$10] ; # A
  %32 = phi i64 [%29, %$10] ; # B
; # (cnt @@@)
  %33 = shl i64 %21, 4
  %34 = or i64 %33, 2
; # (consNum N (cnt @@@))
  %35 = call i64 @consNum(i64 %22, i64 %34)
  br label %$14
$13:
  %36 = phi i64 [%28, %$10] ; # A
  %37 = phi i64 [%29, %$10] ; # B
; # (cnt N)
  %38 = shl i64 %22, 4
  %39 = or i64 %38, 2
  br label %$14
$14:
  %40 = phi i64 [%31, %$12], [%36, %$13] ; # A
  %41 = phi i64 [%32, %$12], [%37, %$13] ; # B
  %42 = phi i64 [%35, %$12], [%39, %$13] ; # ->
  br label %$9
$8:
  %43 = phi i64 [%11, %$6] ; # A
  %44 = phi i64 [%10, %$6] ; # B
; # (: 1 (let (Lo (mul A (val (dig B))) Hi @@@ P (boxNum Lo) R (save ...
  br label %$-1
$-1:
  %45 = phi i64 [%43, %$8], [%169, %$26] ; # A
  %46 = phi i64 [%44, %$8], [%167, %$26] ; # B
; # (let (Lo (mul A (val (dig B))) Hi @@@ P (boxNum Lo) R (save P)) (...
; # (dig B)
  %47 = add i64 %46, -4
; # (val (dig B))
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (mul A (val (dig B)))
  %50 = zext i64 %45 to i128
  %51 = zext i64 %49 to i128
  %52 = mul i128 %50, %51
  %53 = lshr i128 %52, 64
  %54 = trunc i128 %53 to i64
  %55 = trunc i128 %52 to i64
; # (boxNum Lo)
  %56 = call i64 @boxNum(i64 %55)
; # (save P)
  %57 = alloca i64, i64 2, align 16
  %58 = ptrtoint i64* %57 to i64
  %59 = inttoptr i64 %58 to i64*
  store i64 %56, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %61 = load i64, i64* %60
  %62 = inttoptr i64 %58 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 %61, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %64
; # (while (big? (setq B (val (big B)))) (setq Lo (add (mul A (val (d...
  br label %$15
$15:
  %65 = phi i64 [%45, %$-1], [%75, %$16] ; # A
  %66 = phi i64 [%46, %$-1], [%76, %$16] ; # B
  %67 = phi i64 [%55, %$-1], [%91, %$16] ; # Lo
  %68 = phi i64 [%54, %$-1], [%93, %$16] ; # Hi
  %69 = phi i64 [%56, %$-1], [%95, %$16] ; # P
; # (big B)
  %70 = add i64 %66, 4
; # (val (big B))
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
; # (big? (setq B (val (big B))))
  %73 = and i64 %72, 4
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$16, label %$17
$16:
  %75 = phi i64 [%65, %$15] ; # A
  %76 = phi i64 [%72, %$15] ; # B
  %77 = phi i64 [%67, %$15] ; # Lo
  %78 = phi i64 [%68, %$15] ; # Hi
  %79 = phi i64 [%69, %$15] ; # P
; # (dig B)
  %80 = add i64 %76, -4
; # (val (dig B))
  %81 = inttoptr i64 %80 to i64*
  %82 = load i64, i64* %81
; # (mul A (val (dig B)))
  %83 = zext i64 %75 to i128
  %84 = zext i64 %82 to i128
  %85 = mul i128 %83, %84
  %86 = lshr i128 %85, 64
  %87 = trunc i128 %86 to i64
  %88 = trunc i128 %85 to i64
; # (add (mul A (val (dig B))) Hi)
  %89 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %88, i64 %78)
  %90 = extractvalue {i64, i1} %89, 1
  %91 = extractvalue {i64, i1} %89, 0
; # (+ @@@ @@)
  %92 = zext i1 %90 to i64
  %93 = add i64 %87, %92
; # (set (big P) (boxNum Lo))
; # (big P)
  %94 = add i64 %79, 4
; # (boxNum Lo)
  %95 = call i64 @boxNum(i64 %91)
  %96 = inttoptr i64 %94 to i64*
  store i64 %95, i64* %96
  br label %$15
$17:
  %97 = phi i64 [%65, %$15] ; # A
  %98 = phi i64 [%72, %$15] ; # B
  %99 = phi i64 [%67, %$15] ; # Lo
  %100 = phi i64 [%68, %$15] ; # Hi
  %101 = phi i64 [%69, %$15] ; # P
; # (int B)
  %102 = lshr i64 %98, 4
; # (mul A (int B))
  %103 = zext i64 %97 to i128
  %104 = zext i64 %102 to i128
  %105 = mul i128 %103, %104
  %106 = lshr i128 %105, 64
  %107 = trunc i128 %106 to i64
  %108 = trunc i128 %105 to i64
; # (add (mul A (int B)) Hi)
  %109 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %108, i64 %100)
  %110 = extractvalue {i64, i1} %109, 1
  %111 = extractvalue {i64, i1} %109, 0
; # (+ @@@ @@)
  %112 = zext i1 %110 to i64
  %113 = add i64 %107, %112
; # (set (big P) (if (or Hi (& Lo (hex "F000000000000000"))) (consNum...
; # (big P)
  %114 = add i64 %101, 4
; # (if (or Hi (& Lo (hex "F000000000000000"))) (consNum Lo (cnt Hi))...
; # (or Hi (& Lo (hex "F000000000000000")))
  %115 = icmp ne i64 %113, 0
  br i1 %115, label %$18, label %$19
$19:
  %116 = phi i64 [%97, %$17] ; # A
  %117 = phi i64 [%98, %$17] ; # B
  %118 = phi i64 [%111, %$17] ; # Lo
  %119 = phi i64 [%113, %$17] ; # Hi
  %120 = phi i64 [%101, %$17] ; # P
; # (& Lo (hex "F000000000000000"))
  %121 = and i64 %118, 17293822569102704640
  %122 = icmp ne i64 %121, 0
  br label %$18
$18:
  %123 = phi i64 [%97, %$17], [%116, %$19] ; # A
  %124 = phi i64 [%98, %$17], [%117, %$19] ; # B
  %125 = phi i64 [%111, %$17], [%118, %$19] ; # Lo
  %126 = phi i64 [%113, %$17], [%119, %$19] ; # Hi
  %127 = phi i64 [%101, %$17], [%120, %$19] ; # P
  %128 = phi i1 [1, %$17], [%122, %$19] ; # ->
  br i1 %128, label %$20, label %$21
$20:
  %129 = phi i64 [%123, %$18] ; # A
  %130 = phi i64 [%124, %$18] ; # B
  %131 = phi i64 [%125, %$18] ; # Lo
  %132 = phi i64 [%126, %$18] ; # Hi
  %133 = phi i64 [%127, %$18] ; # P
; # (cnt Hi)
  %134 = shl i64 %132, 4
  %135 = or i64 %134, 2
; # (consNum Lo (cnt Hi))
  %136 = call i64 @consNum(i64 %131, i64 %135)
  br label %$22
$21:
  %137 = phi i64 [%123, %$18] ; # A
  %138 = phi i64 [%124, %$18] ; # B
  %139 = phi i64 [%125, %$18] ; # Lo
  %140 = phi i64 [%126, %$18] ; # Hi
  %141 = phi i64 [%127, %$18] ; # P
; # (cnt Lo)
  %142 = shl i64 %139, 4
  %143 = or i64 %142, 2
  br label %$22
$22:
  %144 = phi i64 [%129, %$20], [%137, %$21] ; # A
  %145 = phi i64 [%130, %$20], [%138, %$21] ; # B
  %146 = phi i64 [%131, %$20], [%139, %$21] ; # Lo
  %147 = phi i64 [%132, %$20], [%140, %$21] ; # Hi
  %148 = phi i64 [%133, %$20], [%141, %$21] ; # P
  %149 = phi i64 [%136, %$20], [%143, %$21] ; # ->
  %150 = inttoptr i64 %114 to i64*
  store i64 %149, i64* %150
; # (drop *Safe)
  %151 = inttoptr i64 %58 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  %154 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %153, i64* %154
  br label %$9
$9:
  %155 = phi i64 [%40, %$14], [%144, %$22] ; # A
  %156 = phi i64 [%41, %$14], [%145, %$22] ; # B
  %157 = phi i64 [%42, %$14], [%56, %$22] ; # ->
  br label %$2
$5:
  %158 = phi i64 [%5, %$3] ; # A
  %159 = phi i64 [%6, %$3] ; # B
; # (== B ZERO)
  %160 = icmp eq i64 %159, 2
  br i1 %160, label %$24, label %$23
$24:
  %161 = phi i64 [%158, %$5] ; # A
  %162 = phi i64 [%159, %$5] ; # B
  br label %$2
$23:
  %163 = phi i64 [%158, %$5] ; # A
  %164 = phi i64 [%159, %$5] ; # B
; # (cnt? B)
  %165 = and i64 %164, 2
  %166 = icmp ne i64 %165, 0
  br i1 %166, label %$26, label %$25
$26:
  %167 = phi i64 [%163, %$23] ; # A
  %168 = phi i64 [%164, %$23] ; # B
; # (int B)
  %169 = lshr i64 %168, 4
; # (xchg 'A 'B)
; # (goto 1)
  br label %$-1
$25:
  %170 = phi i64 [%163, %$23] ; # A
  %171 = phi i64 [%164, %$23] ; # B
; # (let (P (boxNum 0) R (save P)) (loop (let (X A Q P Lo (add (mul (...
; # (boxNum 0)
  %172 = call i64 @boxNum(i64 0)
; # (save P)
  %173 = alloca i64, i64 2, align 16
  %174 = ptrtoint i64* %173 to i64
  %175 = inttoptr i64 %174 to i64*
  store i64 %172, i64* %175
  %176 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %177 = load i64, i64* %176
  %178 = inttoptr i64 %174 to i64*
  %179 = getelementptr i64, i64* %178, i32 1
  store i64 %177, i64* %179
  %180 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %174, i64* %180
; # (loop (let (X A Q P Lo (add (mul (val (dig X)) (val (dig B))) (va...
  br label %$27
$27:
  %181 = phi i64 [%170, %$25], [%368, %$39] ; # A
  %182 = phi i64 [%171, %$25], [%369, %$39] ; # B
  %183 = phi i64 [%172, %$25], [%370, %$39] ; # P
; # (let (X A Q P Lo (add (mul (val (dig X)) (val (dig B))) (val (dig...
; # (dig X)
  %184 = add i64 %181, -4
; # (val (dig X))
  %185 = inttoptr i64 %184 to i64*
  %186 = load i64, i64* %185
; # (dig B)
  %187 = add i64 %182, -4
; # (val (dig B))
  %188 = inttoptr i64 %187 to i64*
  %189 = load i64, i64* %188
; # (mul (val (dig X)) (val (dig B)))
  %190 = zext i64 %186 to i128
  %191 = zext i64 %189 to i128
  %192 = mul i128 %190, %191
  %193 = lshr i128 %192, 64
  %194 = trunc i128 %193 to i64
  %195 = trunc i128 %192 to i64
; # (dig Q)
  %196 = add i64 %183, -4
; # (val (dig Q))
  %197 = inttoptr i64 %196 to i64*
  %198 = load i64, i64* %197
; # (add (mul (val (dig X)) (val (dig B))) (val (dig Q)))
  %199 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %195, i64 %198)
  %200 = extractvalue {i64, i1} %199, 1
  %201 = extractvalue {i64, i1} %199, 0
; # (+ @@@ @@)
  %202 = zext i1 %200 to i64
  %203 = add i64 %194, %202
; # (loop (set (dig Q) Lo) (setq Q (if (cnt? (val (big Q))) (set (big...
  br label %$28
$28:
  %204 = phi i64 [%181, %$27], [%248, %$32] ; # A
  %205 = phi i64 [%182, %$27], [%249, %$32] ; # B
  %206 = phi i64 [%183, %$27], [%250, %$32] ; # P
  %207 = phi i64 [%181, %$27], [%251, %$32] ; # X
  %208 = phi i64 [%183, %$27], [%252, %$32] ; # Q
  %209 = phi i64 [%201, %$27], [%277, %$32] ; # Lo
  %210 = phi i64 [%203, %$27], [%279, %$32] ; # Hi
; # (set (dig Q) Lo)
; # (dig Q)
  %211 = add i64 %208, -4
  %212 = inttoptr i64 %211 to i64*
  store i64 %209, i64* %212
; # (if (cnt? (val (big Q))) (set (big Q) (boxNum 0)) @)
; # (big Q)
  %213 = add i64 %208, 4
; # (val (big Q))
  %214 = inttoptr i64 %213 to i64*
  %215 = load i64, i64* %214
; # (cnt? (val (big Q)))
  %216 = and i64 %215, 2
  %217 = icmp ne i64 %216, 0
  br i1 %217, label %$29, label %$30
$29:
  %218 = phi i64 [%204, %$28] ; # A
  %219 = phi i64 [%205, %$28] ; # B
  %220 = phi i64 [%206, %$28] ; # P
  %221 = phi i64 [%207, %$28] ; # X
  %222 = phi i64 [%208, %$28] ; # Q
  %223 = phi i64 [%209, %$28] ; # Lo
  %224 = phi i64 [%210, %$28] ; # Hi
; # (set (big Q) (boxNum 0))
; # (big Q)
  %225 = add i64 %222, 4
; # (boxNum 0)
  %226 = call i64 @boxNum(i64 0)
  %227 = inttoptr i64 %225 to i64*
  store i64 %226, i64* %227
  br label %$31
$30:
  %228 = phi i64 [%204, %$28] ; # A
  %229 = phi i64 [%205, %$28] ; # B
  %230 = phi i64 [%206, %$28] ; # P
  %231 = phi i64 [%207, %$28] ; # X
  %232 = phi i64 [%208, %$28] ; # Q
  %233 = phi i64 [%209, %$28] ; # Lo
  %234 = phi i64 [%210, %$28] ; # Hi
  br label %$31
$31:
  %235 = phi i64 [%218, %$29], [%228, %$30] ; # A
  %236 = phi i64 [%219, %$29], [%229, %$30] ; # B
  %237 = phi i64 [%220, %$29], [%230, %$30] ; # P
  %238 = phi i64 [%221, %$29], [%231, %$30] ; # X
  %239 = phi i64 [%222, %$29], [%232, %$30] ; # Q
  %240 = phi i64 [%223, %$29], [%233, %$30] ; # Lo
  %241 = phi i64 [%224, %$29], [%234, %$30] ; # Hi
  %242 = phi i64 [%226, %$29], [%215, %$30] ; # ->
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %243 = add i64 %238, 4
; # (val (big X))
  %244 = inttoptr i64 %243 to i64*
  %245 = load i64, i64* %244
; # (cnt? (setq X (val (big X))))
  %246 = and i64 %245, 2
  %247 = icmp ne i64 %246, 0
  br i1 %247, label %$33, label %$32
$32:
  %248 = phi i64 [%235, %$31] ; # A
  %249 = phi i64 [%236, %$31] ; # B
  %250 = phi i64 [%237, %$31] ; # P
  %251 = phi i64 [%245, %$31] ; # X
  %252 = phi i64 [%242, %$31] ; # Q
  %253 = phi i64 [%240, %$31] ; # Lo
  %254 = phi i64 [%241, %$31] ; # Hi
; # (dig X)
  %255 = add i64 %251, -4
; # (val (dig X))
  %256 = inttoptr i64 %255 to i64*
  %257 = load i64, i64* %256
; # (dig B)
  %258 = add i64 %249, -4
; # (val (dig B))
  %259 = inttoptr i64 %258 to i64*
  %260 = load i64, i64* %259
; # (mulAddHiLo (val (dig X)) (val (dig B)) Q)
  %261 = zext i64 %257 to i128
  %262 = zext i64 %260 to i128
  %263 = mul i128 %261, %262
  %264 = lshr i128 %263, 64
  %265 = trunc i128 %264 to i64
  %266 = trunc i128 %263 to i64
  %267 = add i64 %252, -4
  %268 = inttoptr i64 %267 to i64*
  %269 = load i64, i64* %268
  %270 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %266, i64 %269)
  %271 = extractvalue {i64, i1} %270, 1
  %272 = extractvalue {i64, i1} %270, 0
  %273 = zext i1 %271 to i64
  %274 = add i64 %265, %273
  %275 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %272, i64 %254)
  %276 = extractvalue {i64, i1} %275, 1
  %277 = extractvalue {i64, i1} %275, 0
  %278 = zext i1 %276 to i64
  %279 = add i64 %274, %278
  br label %$28
$33:
  %280 = phi i64 [%235, %$31] ; # A
  %281 = phi i64 [%236, %$31] ; # B
  %282 = phi i64 [%237, %$31] ; # P
  %283 = phi i64 [%245, %$31] ; # X
  %284 = phi i64 [%242, %$31] ; # Q
  %285 = phi i64 [%240, %$31] ; # Lo
  %286 = phi i64 [%241, %$31] ; # Hi
  %287 = phi i64 [0, %$31] ; # ->
; # (int X)
  %288 = lshr i64 %283, 4
; # (dig B)
  %289 = add i64 %281, -4
; # (val (dig B))
  %290 = inttoptr i64 %289 to i64*
  %291 = load i64, i64* %290
; # (mulAddHiLo (int X) (val (dig B)) Q)
  %292 = zext i64 %288 to i128
  %293 = zext i64 %291 to i128
  %294 = mul i128 %292, %293
  %295 = lshr i128 %294, 64
  %296 = trunc i128 %295 to i64
  %297 = trunc i128 %294 to i64
  %298 = add i64 %284, -4
  %299 = inttoptr i64 %298 to i64*
  %300 = load i64, i64* %299
  %301 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %297, i64 %300)
  %302 = extractvalue {i64, i1} %301, 1
  %303 = extractvalue {i64, i1} %301, 0
  %304 = zext i1 %302 to i64
  %305 = add i64 %296, %304
  %306 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %303, i64 %286)
  %307 = extractvalue {i64, i1} %306, 1
  %308 = extractvalue {i64, i1} %306, 0
  %309 = zext i1 %307 to i64
  %310 = add i64 %305, %309
; # (set (dig Q) Lo)
; # (dig Q)
  %311 = add i64 %284, -4
  %312 = inttoptr i64 %311 to i64*
  store i64 %308, i64* %312
; # (when Hi (if (cnt? (val (big Q))) (set (big Q) (boxNum Hi)) (set ...
  %313 = icmp ne i64 %310, 0
  br i1 %313, label %$34, label %$35
$34:
  %314 = phi i64 [%280, %$33] ; # A
  %315 = phi i64 [%281, %$33] ; # B
  %316 = phi i64 [%282, %$33] ; # P
  %317 = phi i64 [%283, %$33] ; # X
  %318 = phi i64 [%284, %$33] ; # Q
  %319 = phi i64 [%308, %$33] ; # Lo
  %320 = phi i64 [%310, %$33] ; # Hi
; # (if (cnt? (val (big Q))) (set (big Q) (boxNum Hi)) (set (big @) H...
; # (big Q)
  %321 = add i64 %318, 4
; # (val (big Q))
  %322 = inttoptr i64 %321 to i64*
  %323 = load i64, i64* %322
; # (cnt? (val (big Q)))
  %324 = and i64 %323, 2
  %325 = icmp ne i64 %324, 0
  br i1 %325, label %$36, label %$37
$36:
  %326 = phi i64 [%314, %$34] ; # A
  %327 = phi i64 [%315, %$34] ; # B
  %328 = phi i64 [%316, %$34] ; # P
  %329 = phi i64 [%317, %$34] ; # X
  %330 = phi i64 [%318, %$34] ; # Q
  %331 = phi i64 [%319, %$34] ; # Lo
  %332 = phi i64 [%320, %$34] ; # Hi
; # (set (big Q) (boxNum Hi))
; # (big Q)
  %333 = add i64 %330, 4
; # (boxNum Hi)
  %334 = call i64 @boxNum(i64 %332)
  %335 = inttoptr i64 %333 to i64*
  store i64 %334, i64* %335
  br label %$38
$37:
  %336 = phi i64 [%314, %$34] ; # A
  %337 = phi i64 [%315, %$34] ; # B
  %338 = phi i64 [%316, %$34] ; # P
  %339 = phi i64 [%317, %$34] ; # X
  %340 = phi i64 [%318, %$34] ; # Q
  %341 = phi i64 [%319, %$34] ; # Lo
  %342 = phi i64 [%320, %$34] ; # Hi
; # (set (big @) Hi)
; # (big @)
  %343 = add i64 %323, 4
  %344 = inttoptr i64 %343 to i64*
  store i64 %342, i64* %344
  br label %$38
$38:
  %345 = phi i64 [%326, %$36], [%336, %$37] ; # A
  %346 = phi i64 [%327, %$36], [%337, %$37] ; # B
  %347 = phi i64 [%328, %$36], [%338, %$37] ; # P
  %348 = phi i64 [%329, %$36], [%339, %$37] ; # X
  %349 = phi i64 [%330, %$36], [%340, %$37] ; # Q
  %350 = phi i64 [%331, %$36], [%341, %$37] ; # Lo
  %351 = phi i64 [%332, %$36], [%342, %$37] ; # Hi
  %352 = phi i64 [%334, %$36], [%342, %$37] ; # ->
  br label %$35
$35:
  %353 = phi i64 [%280, %$33], [%345, %$38] ; # A
  %354 = phi i64 [%281, %$33], [%346, %$38] ; # B
  %355 = phi i64 [%282, %$33], [%347, %$38] ; # P
  %356 = phi i64 [%283, %$33], [%348, %$38] ; # X
  %357 = phi i64 [%284, %$33], [%349, %$38] ; # Q
  %358 = phi i64 [%308, %$33], [%350, %$38] ; # Lo
  %359 = phi i64 [%310, %$33], [%351, %$38] ; # Hi
; # (big P)
  %360 = add i64 %355, 4
; # (val (big P))
  %361 = inttoptr i64 %360 to i64*
  %362 = load i64, i64* %361
; # (? (cnt? (setq B (val (big B)))))
; # (big B)
  %363 = add i64 %354, 4
; # (val (big B))
  %364 = inttoptr i64 %363 to i64*
  %365 = load i64, i64* %364
; # (cnt? (setq B (val (big B))))
  %366 = and i64 %365, 2
  %367 = icmp ne i64 %366, 0
  br i1 %367, label %$40, label %$39
$39:
  %368 = phi i64 [%353, %$35] ; # A
  %369 = phi i64 [%365, %$35] ; # B
  %370 = phi i64 [%362, %$35] ; # P
  br label %$27
$40:
  %371 = phi i64 [%353, %$35] ; # A
  %372 = phi i64 [%365, %$35] ; # B
  %373 = phi i64 [%362, %$35] ; # P
  %374 = phi i64 [0, %$35] ; # ->
; # (int B)
  %375 = lshr i64 %372, 4
; # (let (Lo (add (mul (val (dig A)) B) (val (dig P))) Hi (+ @@@ @@))...
; # (dig A)
  %376 = add i64 %371, -4
; # (val (dig A))
  %377 = inttoptr i64 %376 to i64*
  %378 = load i64, i64* %377
; # (mul (val (dig A)) B)
  %379 = zext i64 %378 to i128
  %380 = zext i64 %375 to i128
  %381 = mul i128 %379, %380
  %382 = lshr i128 %381, 64
  %383 = trunc i128 %382 to i64
  %384 = trunc i128 %381 to i64
; # (dig P)
  %385 = add i64 %373, -4
; # (val (dig P))
  %386 = inttoptr i64 %385 to i64*
  %387 = load i64, i64* %386
; # (add (mul (val (dig A)) B) (val (dig P)))
  %388 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %384, i64 %387)
  %389 = extractvalue {i64, i1} %388, 1
  %390 = extractvalue {i64, i1} %388, 0
; # (+ @@@ @@)
  %391 = zext i1 %389 to i64
  %392 = add i64 %383, %391
; # (loop (set (dig P) Lo) (setq P (if (cnt? (val (big P))) (set (big...
  br label %$41
$41:
  %393 = phi i64 [%371, %$40], [%429, %$45] ; # A
  %394 = phi i64 [%375, %$40], [%430, %$45] ; # B
  %395 = phi i64 [%373, %$40], [%431, %$45] ; # P
  %396 = phi i64 [%390, %$40], [%453, %$45] ; # Lo
  %397 = phi i64 [%392, %$40], [%455, %$45] ; # Hi
; # (set (dig P) Lo)
; # (dig P)
  %398 = add i64 %395, -4
  %399 = inttoptr i64 %398 to i64*
  store i64 %396, i64* %399
; # (if (cnt? (val (big P))) (set (big P) (boxNum 0)) @)
; # (big P)
  %400 = add i64 %395, 4
; # (val (big P))
  %401 = inttoptr i64 %400 to i64*
  %402 = load i64, i64* %401
; # (cnt? (val (big P)))
  %403 = and i64 %402, 2
  %404 = icmp ne i64 %403, 0
  br i1 %404, label %$42, label %$43
$42:
  %405 = phi i64 [%393, %$41] ; # A
  %406 = phi i64 [%394, %$41] ; # B
  %407 = phi i64 [%395, %$41] ; # P
  %408 = phi i64 [%396, %$41] ; # Lo
  %409 = phi i64 [%397, %$41] ; # Hi
; # (set (big P) (boxNum 0))
; # (big P)
  %410 = add i64 %407, 4
; # (boxNum 0)
  %411 = call i64 @boxNum(i64 0)
  %412 = inttoptr i64 %410 to i64*
  store i64 %411, i64* %412
  br label %$44
$43:
  %413 = phi i64 [%393, %$41] ; # A
  %414 = phi i64 [%394, %$41] ; # B
  %415 = phi i64 [%395, %$41] ; # P
  %416 = phi i64 [%396, %$41] ; # Lo
  %417 = phi i64 [%397, %$41] ; # Hi
  br label %$44
$44:
  %418 = phi i64 [%405, %$42], [%413, %$43] ; # A
  %419 = phi i64 [%406, %$42], [%414, %$43] ; # B
  %420 = phi i64 [%407, %$42], [%415, %$43] ; # P
  %421 = phi i64 [%408, %$42], [%416, %$43] ; # Lo
  %422 = phi i64 [%409, %$42], [%417, %$43] ; # Hi
  %423 = phi i64 [%411, %$42], [%402, %$43] ; # ->
; # (? (cnt? (setq A (val (big A)))))
; # (big A)
  %424 = add i64 %418, 4
; # (val (big A))
  %425 = inttoptr i64 %424 to i64*
  %426 = load i64, i64* %425
; # (cnt? (setq A (val (big A))))
  %427 = and i64 %426, 2
  %428 = icmp ne i64 %427, 0
  br i1 %428, label %$46, label %$45
$45:
  %429 = phi i64 [%426, %$44] ; # A
  %430 = phi i64 [%419, %$44] ; # B
  %431 = phi i64 [%423, %$44] ; # P
  %432 = phi i64 [%421, %$44] ; # Lo
  %433 = phi i64 [%422, %$44] ; # Hi
; # (dig A)
  %434 = add i64 %429, -4
; # (val (dig A))
  %435 = inttoptr i64 %434 to i64*
  %436 = load i64, i64* %435
; # (mulAddHiLo (val (dig A)) B P)
  %437 = zext i64 %436 to i128
  %438 = zext i64 %430 to i128
  %439 = mul i128 %437, %438
  %440 = lshr i128 %439, 64
  %441 = trunc i128 %440 to i64
  %442 = trunc i128 %439 to i64
  %443 = add i64 %431, -4
  %444 = inttoptr i64 %443 to i64*
  %445 = load i64, i64* %444
  %446 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %442, i64 %445)
  %447 = extractvalue {i64, i1} %446, 1
  %448 = extractvalue {i64, i1} %446, 0
  %449 = zext i1 %447 to i64
  %450 = add i64 %441, %449
  %451 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %448, i64 %433)
  %452 = extractvalue {i64, i1} %451, 1
  %453 = extractvalue {i64, i1} %451, 0
  %454 = zext i1 %452 to i64
  %455 = add i64 %450, %454
  br label %$41
$46:
  %456 = phi i64 [%426, %$44] ; # A
  %457 = phi i64 [%419, %$44] ; # B
  %458 = phi i64 [%423, %$44] ; # P
  %459 = phi i64 [%421, %$44] ; # Lo
  %460 = phi i64 [%422, %$44] ; # Hi
  %461 = phi i64 [0, %$44] ; # ->
; # (int A)
  %462 = lshr i64 %456, 4
; # (mulAddHiLo (int A) B P)
  %463 = zext i64 %462 to i128
  %464 = zext i64 %457 to i128
  %465 = mul i128 %463, %464
  %466 = lshr i128 %465, 64
  %467 = trunc i128 %466 to i64
  %468 = trunc i128 %465 to i64
  %469 = add i64 %458, -4
  %470 = inttoptr i64 %469 to i64*
  %471 = load i64, i64* %470
  %472 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %468, i64 %471)
  %473 = extractvalue {i64, i1} %472, 1
  %474 = extractvalue {i64, i1} %472, 0
  %475 = zext i1 %473 to i64
  %476 = add i64 %467, %475
  %477 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %474, i64 %460)
  %478 = extractvalue {i64, i1} %477, 1
  %479 = extractvalue {i64, i1} %477, 0
  %480 = zext i1 %478 to i64
  %481 = add i64 %476, %480
; # (set (dig P) Lo)
; # (dig P)
  %482 = add i64 %458, -4
  %483 = inttoptr i64 %482 to i64*
  store i64 %479, i64* %483
; # (when Hi (if (cnt? (val (big P))) (set (big P) (boxNum Hi)) (set ...
  %484 = icmp ne i64 %481, 0
  br i1 %484, label %$47, label %$48
$47:
  %485 = phi i64 [%456, %$46] ; # A
  %486 = phi i64 [%457, %$46] ; # B
  %487 = phi i64 [%458, %$46] ; # P
  %488 = phi i64 [%479, %$46] ; # Lo
  %489 = phi i64 [%481, %$46] ; # Hi
; # (if (cnt? (val (big P))) (set (big P) (boxNum Hi)) (set (big @) H...
; # (big P)
  %490 = add i64 %487, 4
; # (val (big P))
  %491 = inttoptr i64 %490 to i64*
  %492 = load i64, i64* %491
; # (cnt? (val (big P)))
  %493 = and i64 %492, 2
  %494 = icmp ne i64 %493, 0
  br i1 %494, label %$49, label %$50
$49:
  %495 = phi i64 [%485, %$47] ; # A
  %496 = phi i64 [%486, %$47] ; # B
  %497 = phi i64 [%487, %$47] ; # P
  %498 = phi i64 [%488, %$47] ; # Lo
  %499 = phi i64 [%489, %$47] ; # Hi
; # (set (big P) (boxNum Hi))
; # (big P)
  %500 = add i64 %497, 4
; # (boxNum Hi)
  %501 = call i64 @boxNum(i64 %499)
  %502 = inttoptr i64 %500 to i64*
  store i64 %501, i64* %502
  br label %$51
$50:
  %503 = phi i64 [%485, %$47] ; # A
  %504 = phi i64 [%486, %$47] ; # B
  %505 = phi i64 [%487, %$47] ; # P
  %506 = phi i64 [%488, %$47] ; # Lo
  %507 = phi i64 [%489, %$47] ; # Hi
; # (set (big @) Hi)
; # (big @)
  %508 = add i64 %492, 4
  %509 = inttoptr i64 %508 to i64*
  store i64 %507, i64* %509
  br label %$51
$51:
  %510 = phi i64 [%495, %$49], [%503, %$50] ; # A
  %511 = phi i64 [%496, %$49], [%504, %$50] ; # B
  %512 = phi i64 [%497, %$49], [%505, %$50] ; # P
  %513 = phi i64 [%498, %$49], [%506, %$50] ; # Lo
  %514 = phi i64 [%499, %$49], [%507, %$50] ; # Hi
  %515 = phi i64 [%501, %$49], [%507, %$50] ; # ->
  br label %$48
$48:
  %516 = phi i64 [%456, %$46], [%510, %$51] ; # A
  %517 = phi i64 [%457, %$46], [%511, %$51] ; # B
  %518 = phi i64 [%458, %$46], [%512, %$51] ; # P
  %519 = phi i64 [%479, %$46], [%513, %$51] ; # Lo
  %520 = phi i64 [%481, %$46], [%514, %$51] ; # Hi
; # (zapZero R)
  %521 = call i64 @zapZero(i64 %172)
; # (drop *Safe)
  %522 = inttoptr i64 %174 to i64*
  %523 = getelementptr i64, i64* %522, i32 1
  %524 = load i64, i64* %523
  %525 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %524, i64* %525
  br label %$2
$2:
  %526 = phi i64 [%3, %$4], [%155, %$9], [%161, %$24], [%516, %$48] ; # A
  %527 = phi i64 [%4, %$4], [%156, %$9], [%162, %$24], [%517, %$48] ; # B
  %528 = phi i64 [%3, %$4], [%157, %$9], [%162, %$24], [%521, %$48] ; # ->
  ret i64 %528
}

define i64 @div1(i64, i64, i1) {
$1:
; # (let (R (save ZERO) P (boxNum (val (dig A))) U (link (push P NIL)...
; # (save ZERO)
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 2, i64* %5
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %4 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %10
; # (dig A)
  %11 = add i64 %0, -4
; # (val (dig A))
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
; # (boxNum (val (dig A)))
  %14 = call i64 @boxNum(i64 %13)
; # (push P NIL)
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %14, i64* %17
; # (link (push P NIL))
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = inttoptr i64 %16 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  store i64 %19, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %22
; # (push B NIL)
  %23 = alloca i64, i64 2, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %1, i64* %25
; # (link (push B NIL))
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %24 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %27, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %30
; # (while (big? (setq A (val (big A)))) (setq P (set (big P) (boxNum...
  br label %$2
$2:
  %31 = phi i64 [%0, %$1], [%44, %$3] ; # A
  %32 = phi i64 [%1, %$1], [%45, %$3] ; # B
  %33 = phi i64 [2, %$1], [%46, %$3] ; # R
  %34 = phi i64 [%14, %$1], [%56, %$3] ; # P
  %35 = phi i64 [0, %$1], [%48, %$3] ; # V2
  %36 = phi i64 [0, %$1], [%58, %$3] ; # M
  %37 = phi i64 [1, %$1], [%50, %$3] ; # N
  %38 = phi i64 [0, %$1], [%51, %$3] ; # D
; # (big A)
  %39 = add i64 %31, 4
; # (val (big A))
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
; # (big? (setq A (val (big A))))
  %42 = and i64 %41, 4
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$3, label %$4
$3:
  %44 = phi i64 [%41, %$2] ; # A
  %45 = phi i64 [%32, %$2] ; # B
  %46 = phi i64 [%33, %$2] ; # R
  %47 = phi i64 [%34, %$2] ; # P
  %48 = phi i64 [%35, %$2] ; # V2
  %49 = phi i64 [%36, %$2] ; # M
  %50 = phi i64 [%37, %$2] ; # N
  %51 = phi i64 [%38, %$2] ; # D
; # (set (big P) (boxNum (val (dig A))))
; # (big P)
  %52 = add i64 %47, 4
; # (dig A)
  %53 = add i64 %44, -4
; # (val (dig A))
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (boxNum (val (dig A)))
  %56 = call i64 @boxNum(i64 %55)
  %57 = inttoptr i64 %52 to i64*
  store i64 %56, i64* %57
; # (inc 'M)
  %58 = add i64 %49, 1
  br label %$2
$4:
  %59 = phi i64 [%41, %$2] ; # A
  %60 = phi i64 [%32, %$2] ; # B
  %61 = phi i64 [%33, %$2] ; # R
  %62 = phi i64 [%34, %$2] ; # P
  %63 = phi i64 [%35, %$2] ; # V2
  %64 = phi i64 [%36, %$2] ; # M
  %65 = phi i64 [%37, %$2] ; # N
  %66 = phi i64 [%38, %$2] ; # D
; # (unless (== A ZERO) (setq P (set (big P) (boxNum (int A)))) (inc ...
; # (== A ZERO)
  %67 = icmp eq i64 %59, 2
  br i1 %67, label %$6, label %$5
$5:
  %68 = phi i64 [%59, %$4] ; # A
  %69 = phi i64 [%60, %$4] ; # B
  %70 = phi i64 [%61, %$4] ; # R
  %71 = phi i64 [%62, %$4] ; # P
  %72 = phi i64 [%63, %$4] ; # V2
  %73 = phi i64 [%64, %$4] ; # M
  %74 = phi i64 [%65, %$4] ; # N
  %75 = phi i64 [%66, %$4] ; # D
; # (set (big P) (boxNum (int A)))
; # (big P)
  %76 = add i64 %71, 4
; # (int A)
  %77 = lshr i64 %68, 4
; # (boxNum (int A))
  %78 = call i64 @boxNum(i64 %77)
  %79 = inttoptr i64 %76 to i64*
  store i64 %78, i64* %79
; # (inc 'M)
  %80 = add i64 %73, 1
  br label %$6
$6:
  %81 = phi i64 [%59, %$4], [%68, %$5] ; # A
  %82 = phi i64 [%60, %$4], [%69, %$5] ; # B
  %83 = phi i64 [%61, %$4], [%70, %$5] ; # R
  %84 = phi i64 [%62, %$4], [%78, %$5] ; # P
  %85 = phi i64 [%63, %$4], [%72, %$5] ; # V2
  %86 = phi i64 [%64, %$4], [%80, %$5] ; # M
  %87 = phi i64 [%65, %$4], [%74, %$5] ; # N
  %88 = phi i64 [%66, %$4], [%75, %$5] ; # D
; # (if (cnt? B) (setq Q (set V (boxNum (int B)))) (setq Q (set V (bo...
; # (cnt? B)
  %89 = and i64 %82, 2
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$7, label %$8
$7:
  %91 = phi i64 [%81, %$6] ; # A
  %92 = phi i64 [%82, %$6] ; # B
  %93 = phi i64 [%83, %$6] ; # R
  %94 = phi i64 [%84, %$6] ; # P
  %95 = phi i64 [%85, %$6] ; # V2
  %96 = phi i64 [%86, %$6] ; # M
  %97 = phi i64 [%87, %$6] ; # N
  %98 = phi i64 [%88, %$6] ; # D
; # (set V (boxNum (int B)))
; # (int B)
  %99 = lshr i64 %92, 4
; # (boxNum (int B))
  %100 = call i64 @boxNum(i64 %99)
  %101 = inttoptr i64 %24 to i64*
  store i64 %100, i64* %101
  br label %$9
$8:
  %102 = phi i64 [%81, %$6] ; # A
  %103 = phi i64 [%82, %$6] ; # B
  %104 = phi i64 [%83, %$6] ; # R
  %105 = phi i64 [%84, %$6] ; # P
  %106 = phi i64 [%85, %$6] ; # V2
  %107 = phi i64 [%86, %$6] ; # M
  %108 = phi i64 [%87, %$6] ; # N
  %109 = phi i64 [%88, %$6] ; # D
; # (set V (boxNum (val (dig B))))
; # (dig B)
  %110 = add i64 %103, -4
; # (val (dig B))
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
; # (boxNum (val (dig B)))
  %113 = call i64 @boxNum(i64 %112)
  %114 = inttoptr i64 %24 to i64*
  store i64 %113, i64* %114
; # (while (big? (setq B (val (big B)))) (setq V2 Q Q (set (big Q) (b...
  br label %$10
$10:
  %115 = phi i64 [%102, %$8], [%129, %$11] ; # A
  %116 = phi i64 [%103, %$8], [%130, %$11] ; # B
  %117 = phi i64 [%104, %$8], [%131, %$11] ; # R
  %118 = phi i64 [%105, %$8], [%132, %$11] ; # P
  %119 = phi i64 [%106, %$8], [%137, %$11] ; # V2
  %120 = phi i64 [%107, %$8], [%144, %$11] ; # M
  %121 = phi i64 [%108, %$8], [%145, %$11] ; # N
  %122 = phi i64 [%109, %$8], [%136, %$11] ; # D
  %123 = phi i64 [%113, %$8], [%142, %$11] ; # Q
; # (big B)
  %124 = add i64 %116, 4
; # (val (big B))
  %125 = inttoptr i64 %124 to i64*
  %126 = load i64, i64* %125
; # (big? (setq B (val (big B))))
  %127 = and i64 %126, 4
  %128 = icmp ne i64 %127, 0
  br i1 %128, label %$11, label %$12
$11:
  %129 = phi i64 [%115, %$10] ; # A
  %130 = phi i64 [%126, %$10] ; # B
  %131 = phi i64 [%117, %$10] ; # R
  %132 = phi i64 [%118, %$10] ; # P
  %133 = phi i64 [%119, %$10] ; # V2
  %134 = phi i64 [%120, %$10] ; # M
  %135 = phi i64 [%121, %$10] ; # N
  %136 = phi i64 [%122, %$10] ; # D
  %137 = phi i64 [%123, %$10] ; # Q
; # (set (big Q) (boxNum (val (dig B))))
; # (big Q)
  %138 = add i64 %137, 4
; # (dig B)
  %139 = add i64 %130, -4
; # (val (dig B))
  %140 = inttoptr i64 %139 to i64*
  %141 = load i64, i64* %140
; # (boxNum (val (dig B)))
  %142 = call i64 @boxNum(i64 %141)
  %143 = inttoptr i64 %138 to i64*
  store i64 %142, i64* %143
; # (dec 'M)
  %144 = sub i64 %134, 1
; # (inc 'N)
  %145 = add i64 %135, 1
  br label %$10
$12:
  %146 = phi i64 [%115, %$10] ; # A
  %147 = phi i64 [%126, %$10] ; # B
  %148 = phi i64 [%117, %$10] ; # R
  %149 = phi i64 [%118, %$10] ; # P
  %150 = phi i64 [%119, %$10] ; # V2
  %151 = phi i64 [%120, %$10] ; # M
  %152 = phi i64 [%121, %$10] ; # N
  %153 = phi i64 [%122, %$10] ; # D
  %154 = phi i64 [%123, %$10] ; # Q
; # (unless (== B ZERO) (setq V2 Q Q (set (big Q) (boxNum (int B)))) ...
; # (== B ZERO)
  %155 = icmp eq i64 %147, 2
  br i1 %155, label %$14, label %$13
$13:
  %156 = phi i64 [%146, %$12] ; # A
  %157 = phi i64 [%147, %$12] ; # B
  %158 = phi i64 [%148, %$12] ; # R
  %159 = phi i64 [%149, %$12] ; # P
  %160 = phi i64 [%150, %$12] ; # V2
  %161 = phi i64 [%151, %$12] ; # M
  %162 = phi i64 [%152, %$12] ; # N
  %163 = phi i64 [%153, %$12] ; # D
  %164 = phi i64 [%154, %$12] ; # Q
; # (set (big Q) (boxNum (int B)))
; # (big Q)
  %165 = add i64 %164, 4
; # (int B)
  %166 = lshr i64 %157, 4
; # (boxNum (int B))
  %167 = call i64 @boxNum(i64 %166)
  %168 = inttoptr i64 %165 to i64*
  store i64 %167, i64* %168
; # (dec 'M)
  %169 = sub i64 %161, 1
; # (inc 'N)
  %170 = add i64 %162, 1
  br label %$14
$14:
  %171 = phi i64 [%146, %$12], [%156, %$13] ; # A
  %172 = phi i64 [%147, %$12], [%157, %$13] ; # B
  %173 = phi i64 [%148, %$12], [%158, %$13] ; # R
  %174 = phi i64 [%149, %$12], [%159, %$13] ; # P
  %175 = phi i64 [%150, %$12], [%164, %$13] ; # V2
  %176 = phi i64 [%151, %$12], [%169, %$13] ; # M
  %177 = phi i64 [%152, %$12], [%170, %$13] ; # N
  %178 = phi i64 [%153, %$12], [%163, %$13] ; # D
  %179 = phi i64 [%154, %$12], [%167, %$13] ; # Q
; # (when (lt0 M) (ret (if Rem (zapZero (val U)) ZERO)))
; # (lt0 M)
  %180 = icmp slt i64 %176, 0
  br i1 %180, label %$15, label %$16
$15:
  %181 = phi i64 [%171, %$14] ; # A
  %182 = phi i64 [%172, %$14] ; # B
  %183 = phi i64 [%173, %$14] ; # R
  %184 = phi i64 [%174, %$14] ; # P
  %185 = phi i64 [%175, %$14] ; # V2
  %186 = phi i64 [%176, %$14] ; # M
  %187 = phi i64 [%177, %$14] ; # N
  %188 = phi i64 [%178, %$14] ; # D
  %189 = phi i64 [%179, %$14] ; # Q
; # (if Rem (zapZero (val U)) ZERO)
  br i1 %2, label %$17, label %$18
$17:
  %190 = phi i64 [%181, %$15] ; # A
  %191 = phi i64 [%182, %$15] ; # B
  %192 = phi i64 [%183, %$15] ; # R
  %193 = phi i64 [%184, %$15] ; # P
  %194 = phi i64 [%185, %$15] ; # V2
  %195 = phi i64 [%186, %$15] ; # M
  %196 = phi i64 [%187, %$15] ; # N
  %197 = phi i64 [%188, %$15] ; # D
  %198 = phi i64 [%189, %$15] ; # Q
; # (val U)
  %199 = inttoptr i64 %16 to i64*
  %200 = load i64, i64* %199
; # (zapZero (val U))
  %201 = call i64 @zapZero(i64 %200)
  br label %$19
$18:
  %202 = phi i64 [%181, %$15] ; # A
  %203 = phi i64 [%182, %$15] ; # B
  %204 = phi i64 [%183, %$15] ; # R
  %205 = phi i64 [%184, %$15] ; # P
  %206 = phi i64 [%185, %$15] ; # V2
  %207 = phi i64 [%186, %$15] ; # M
  %208 = phi i64 [%187, %$15] ; # N
  %209 = phi i64 [%188, %$15] ; # D
  %210 = phi i64 [%189, %$15] ; # Q
  br label %$19
$19:
  %211 = phi i64 [%190, %$17], [%202, %$18] ; # A
  %212 = phi i64 [%191, %$17], [%203, %$18] ; # B
  %213 = phi i64 [%192, %$17], [%204, %$18] ; # R
  %214 = phi i64 [%193, %$17], [%205, %$18] ; # P
  %215 = phi i64 [%194, %$17], [%206, %$18] ; # V2
  %216 = phi i64 [%195, %$17], [%207, %$18] ; # M
  %217 = phi i64 [%196, %$17], [%208, %$18] ; # N
  %218 = phi i64 [%197, %$17], [%209, %$18] ; # D
  %219 = phi i64 [%198, %$17], [%210, %$18] ; # Q
  %220 = phi i64 [%201, %$17], [2, %$18] ; # ->
; # (ret (if Rem (zapZero (val U)) ZERO))
; # (drop *Safe)
  %221 = inttoptr i64 %4 to i64*
  %222 = getelementptr i64, i64* %221, i32 1
  %223 = load i64, i64* %222
  %224 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %223, i64* %224
  ret i64 %220
$16:
  %225 = phi i64 [%171, %$14] ; # A
  %226 = phi i64 [%172, %$14] ; # B
  %227 = phi i64 [%173, %$14] ; # R
  %228 = phi i64 [%174, %$14] ; # P
  %229 = phi i64 [%175, %$14] ; # V2
  %230 = phi i64 [%176, %$14] ; # M
  %231 = phi i64 [%177, %$14] ; # N
  %232 = phi i64 [%178, %$14] ; # D
  %233 = phi i64 [%179, %$14] ; # Q
  br label %$9
$9:
  %234 = phi i64 [%91, %$7], [%225, %$16] ; # A
  %235 = phi i64 [%92, %$7], [%226, %$16] ; # B
  %236 = phi i64 [%93, %$7], [%227, %$16] ; # R
  %237 = phi i64 [%94, %$7], [%228, %$16] ; # P
  %238 = phi i64 [%95, %$7], [%229, %$16] ; # V2
  %239 = phi i64 [%96, %$7], [%230, %$16] ; # M
  %240 = phi i64 [%97, %$7], [%231, %$16] ; # N
  %241 = phi i64 [%98, %$7], [%232, %$16] ; # D
  %242 = phi i64 [%100, %$7], [%233, %$16] ; # Q
; # (set (big P) (boxNum 0))
; # (big P)
  %243 = add i64 %237, 4
; # (boxNum 0)
  %244 = call i64 @boxNum(i64 0)
  %245 = inttoptr i64 %243 to i64*
  store i64 %244, i64* %245
; # (while (ge0 (val (dig Q))) (twiceBig (val U)) (twiceBig (val V)) ...
  br label %$20
$20:
  %246 = phi i64 [%234, %$9], [%259, %$21] ; # A
  %247 = phi i64 [%235, %$9], [%260, %$21] ; # B
  %248 = phi i64 [%236, %$9], [%261, %$21] ; # R
  %249 = phi i64 [%237, %$9], [%262, %$21] ; # P
  %250 = phi i64 [%238, %$9], [%263, %$21] ; # V2
  %251 = phi i64 [%239, %$9], [%264, %$21] ; # M
  %252 = phi i64 [%240, %$9], [%265, %$21] ; # N
  %253 = phi i64 [%241, %$9], [%274, %$21] ; # D
  %254 = phi i64 [%242, %$9], [%267, %$21] ; # Q
; # (dig Q)
  %255 = add i64 %254, -4
; # (val (dig Q))
  %256 = inttoptr i64 %255 to i64*
  %257 = load i64, i64* %256
; # (ge0 (val (dig Q)))
  %258 = icmp sge i64 %257, 0
  br i1 %258, label %$21, label %$22
$21:
  %259 = phi i64 [%246, %$20] ; # A
  %260 = phi i64 [%247, %$20] ; # B
  %261 = phi i64 [%248, %$20] ; # R
  %262 = phi i64 [%249, %$20] ; # P
  %263 = phi i64 [%250, %$20] ; # V2
  %264 = phi i64 [%251, %$20] ; # M
  %265 = phi i64 [%252, %$20] ; # N
  %266 = phi i64 [%253, %$20] ; # D
  %267 = phi i64 [%254, %$20] ; # Q
; # (val U)
  %268 = inttoptr i64 %16 to i64*
  %269 = load i64, i64* %268
; # (twiceBig (val U))
  %270 = call i64 @twiceBig(i64 %269)
; # (val V)
  %271 = inttoptr i64 %24 to i64*
  %272 = load i64, i64* %271
; # (twiceBig (val V))
  %273 = call i64 @twiceBig(i64 %272)
; # (inc 'D)
  %274 = add i64 %266, 1
  br label %$20
$22:
  %275 = phi i64 [%246, %$20] ; # A
  %276 = phi i64 [%247, %$20] ; # B
  %277 = phi i64 [%248, %$20] ; # R
  %278 = phi i64 [%249, %$20] ; # P
  %279 = phi i64 [%250, %$20] ; # V2
  %280 = phi i64 [%251, %$20] ; # M
  %281 = phi i64 [%252, %$20] ; # N
  %282 = phi i64 [%253, %$20] ; # D
  %283 = phi i64 [%254, %$20] ; # Q
; # (dig Q)
  %284 = add i64 %283, -4
; # (val (dig Q))
  %285 = inttoptr i64 %284 to i64*
  %286 = load i64, i64* %285
; # (when V2 (setq V2 (val (dig V2))))
  %287 = icmp ne i64 %279, 0
  br i1 %287, label %$23, label %$24
$23:
  %288 = phi i64 [%275, %$22] ; # A
  %289 = phi i64 [%276, %$22] ; # B
  %290 = phi i64 [%277, %$22] ; # R
  %291 = phi i64 [%278, %$22] ; # P
  %292 = phi i64 [%286, %$22] ; # V1
  %293 = phi i64 [%279, %$22] ; # V2
  %294 = phi i64 [%280, %$22] ; # M
  %295 = phi i64 [%281, %$22] ; # N
  %296 = phi i64 [%282, %$22] ; # D
  %297 = phi i64 [%283, %$22] ; # Q
; # (dig V2)
  %298 = add i64 %293, -4
; # (val (dig V2))
  %299 = inttoptr i64 %298 to i64*
  %300 = load i64, i64* %299
  br label %$24
$24:
  %301 = phi i64 [%275, %$22], [%288, %$23] ; # A
  %302 = phi i64 [%276, %$22], [%289, %$23] ; # B
  %303 = phi i64 [%277, %$22], [%290, %$23] ; # R
  %304 = phi i64 [%278, %$22], [%291, %$23] ; # P
  %305 = phi i64 [%286, %$22], [%292, %$23] ; # V1
  %306 = phi i64 [%279, %$22], [%300, %$23] ; # V2
  %307 = phi i64 [%280, %$22], [%294, %$23] ; # M
  %308 = phi i64 [%281, %$22], [%295, %$23] ; # N
  %309 = phi i64 [%282, %$22], [%296, %$23] ; # D
  %310 = phi i64 [%283, %$22], [%297, %$23] ; # Q
; # (loop (let (X (val U) U1 0 U2 0 U3 T) (let I M (while (ge0 (dec '...
  br label %$25
$25:
  %311 = phi i64 [%301, %$24], [%1016, %$56] ; # A
  %312 = phi i64 [%302, %$24], [%1017, %$56] ; # B
  %313 = phi i64 [%303, %$24], [%1018, %$56] ; # R
  %314 = phi i64 [%304, %$24], [%1019, %$56] ; # P
  %315 = phi i64 [%305, %$24], [%1020, %$56] ; # V1
  %316 = phi i64 [%306, %$24], [%1021, %$56] ; # V2
  %317 = phi i64 [%307, %$24], [%1022, %$56] ; # M
  %318 = phi i64 [%308, %$24], [%1023, %$56] ; # N
  %319 = phi i64 [%309, %$24], [%1024, %$56] ; # D
  %320 = phi i64 [%310, %$24], [%1025, %$56] ; # Q
; # (let (X (val U) U1 0 U2 0 U3 T) (let I M (while (ge0 (dec 'I)) (s...
; # (val U)
  %321 = inttoptr i64 %16 to i64*
  %322 = load i64, i64* %321
; # (let I M (while (ge0 (dec 'I)) (setq X (val (big X)))))
; # (while (ge0 (dec 'I)) (setq X (val (big X))))
  br label %$26
$26:
  %323 = phi i64 [%311, %$25], [%339, %$27] ; # A
  %324 = phi i64 [%312, %$25], [%340, %$27] ; # B
  %325 = phi i64 [%313, %$25], [%341, %$27] ; # R
  %326 = phi i64 [%314, %$25], [%342, %$27] ; # P
  %327 = phi i64 [%315, %$25], [%343, %$27] ; # V1
  %328 = phi i64 [%316, %$25], [%344, %$27] ; # V2
  %329 = phi i64 [%317, %$25], [%345, %$27] ; # M
  %330 = phi i64 [%318, %$25], [%346, %$27] ; # N
  %331 = phi i64 [%319, %$25], [%347, %$27] ; # D
  %332 = phi i64 [%320, %$25], [%348, %$27] ; # Q
  %333 = phi i64 [%322, %$25], [%355, %$27] ; # X
  %334 = phi i64 [0, %$25], [%350, %$27] ; # U1
  %335 = phi i64 [0, %$25], [%351, %$27] ; # U2
  %336 = phi i64 [%317, %$25], [%352, %$27] ; # I
; # (dec 'I)
  %337 = sub i64 %336, 1
; # (ge0 (dec 'I))
  %338 = icmp sge i64 %337, 0
  br i1 %338, label %$27, label %$28
$27:
  %339 = phi i64 [%323, %$26] ; # A
  %340 = phi i64 [%324, %$26] ; # B
  %341 = phi i64 [%325, %$26] ; # R
  %342 = phi i64 [%326, %$26] ; # P
  %343 = phi i64 [%327, %$26] ; # V1
  %344 = phi i64 [%328, %$26] ; # V2
  %345 = phi i64 [%329, %$26] ; # M
  %346 = phi i64 [%330, %$26] ; # N
  %347 = phi i64 [%331, %$26] ; # D
  %348 = phi i64 [%332, %$26] ; # Q
  %349 = phi i64 [%333, %$26] ; # X
  %350 = phi i64 [%334, %$26] ; # U1
  %351 = phi i64 [%335, %$26] ; # U2
  %352 = phi i64 [%337, %$26] ; # I
; # (big X)
  %353 = add i64 %349, 4
; # (val (big X))
  %354 = inttoptr i64 %353 to i64*
  %355 = load i64, i64* %354
  br label %$26
$28:
  %356 = phi i64 [%323, %$26] ; # A
  %357 = phi i64 [%324, %$26] ; # B
  %358 = phi i64 [%325, %$26] ; # R
  %359 = phi i64 [%326, %$26] ; # P
  %360 = phi i64 [%327, %$26] ; # V1
  %361 = phi i64 [%328, %$26] ; # V2
  %362 = phi i64 [%329, %$26] ; # M
  %363 = phi i64 [%330, %$26] ; # N
  %364 = phi i64 [%331, %$26] ; # D
  %365 = phi i64 [%332, %$26] ; # Q
  %366 = phi i64 [%333, %$26] ; # X
  %367 = phi i64 [%334, %$26] ; # U1
  %368 = phi i64 [%335, %$26] ; # U2
  %369 = phi i64 [%337, %$26] ; # I
; # (let (I N Y X) (loop (setq U3 U2 U2 U1 U1 (val (dig Y)) Y (val (b...
; # (loop (setq U3 U2 U2 U1 U1 (val (dig Y)) Y (val (big Y))) (? (lt0...
  br label %$29
$29:
  %370 = phi i64 [%356, %$28], [%393, %$30] ; # A
  %371 = phi i64 [%357, %$28], [%394, %$30] ; # B
  %372 = phi i64 [%358, %$28], [%395, %$30] ; # R
  %373 = phi i64 [%359, %$28], [%396, %$30] ; # P
  %374 = phi i64 [%360, %$28], [%397, %$30] ; # V1
  %375 = phi i64 [%361, %$28], [%398, %$30] ; # V2
  %376 = phi i64 [%362, %$28], [%399, %$30] ; # M
  %377 = phi i64 [%363, %$28], [%400, %$30] ; # N
  %378 = phi i64 [%364, %$28], [%401, %$30] ; # D
  %379 = phi i64 [%365, %$28], [%402, %$30] ; # Q
  %380 = phi i64 [%366, %$28], [%403, %$30] ; # X
  %381 = phi i64 [%367, %$28], [%404, %$30] ; # U1
  %382 = phi i64 [%368, %$28], [%405, %$30] ; # U2
  %383 = phi i64 [%363, %$28], [%407, %$30] ; # I
  %384 = phi i64 [%366, %$28], [%408, %$30] ; # Y
; # (dig Y)
  %385 = add i64 %384, -4
; # (val (dig Y))
  %386 = inttoptr i64 %385 to i64*
  %387 = load i64, i64* %386
; # (big Y)
  %388 = add i64 %384, 4
; # (val (big Y))
  %389 = inttoptr i64 %388 to i64*
  %390 = load i64, i64* %389
; # (? (lt0 (dec 'I)))
; # (dec 'I)
  %391 = sub i64 %383, 1
; # (lt0 (dec 'I))
  %392 = icmp slt i64 %391, 0
  br i1 %392, label %$31, label %$30
$30:
  %393 = phi i64 [%370, %$29] ; # A
  %394 = phi i64 [%371, %$29] ; # B
  %395 = phi i64 [%372, %$29] ; # R
  %396 = phi i64 [%373, %$29] ; # P
  %397 = phi i64 [%374, %$29] ; # V1
  %398 = phi i64 [%375, %$29] ; # V2
  %399 = phi i64 [%376, %$29] ; # M
  %400 = phi i64 [%377, %$29] ; # N
  %401 = phi i64 [%378, %$29] ; # D
  %402 = phi i64 [%379, %$29] ; # Q
  %403 = phi i64 [%380, %$29] ; # X
  %404 = phi i64 [%387, %$29] ; # U1
  %405 = phi i64 [%381, %$29] ; # U2
  %406 = phi i64 [%382, %$29] ; # U3
  %407 = phi i64 [%391, %$29] ; # I
  %408 = phi i64 [%390, %$29] ; # Y
  br label %$29
$31:
  %409 = phi i64 [%370, %$29] ; # A
  %410 = phi i64 [%371, %$29] ; # B
  %411 = phi i64 [%372, %$29] ; # R
  %412 = phi i64 [%373, %$29] ; # P
  %413 = phi i64 [%374, %$29] ; # V1
  %414 = phi i64 [%375, %$29] ; # V2
  %415 = phi i64 [%376, %$29] ; # M
  %416 = phi i64 [%377, %$29] ; # N
  %417 = phi i64 [%378, %$29] ; # D
  %418 = phi i64 [%379, %$29] ; # Q
  %419 = phi i64 [%380, %$29] ; # X
  %420 = phi i64 [%387, %$29] ; # U1
  %421 = phi i64 [%381, %$29] ; # U2
  %422 = phi i64 [%382, %$29] ; # U3
  %423 = phi i64 [%391, %$29] ; # I
  %424 = phi i64 [%390, %$29] ; # Y
  %425 = phi i64 [0, %$29] ; # ->
; # (let (Hi U1 Lo U2) (setq Q (if (== U1 V1) -1 (div Hi Lo V1))) (se...
; # (if (== U1 V1) -1 (div Hi Lo V1))
; # (== U1 V1)
  %426 = icmp eq i64 %420, %413
  br i1 %426, label %$32, label %$33
$32:
  %427 = phi i64 [%409, %$31] ; # A
  %428 = phi i64 [%410, %$31] ; # B
  %429 = phi i64 [%411, %$31] ; # R
  %430 = phi i64 [%412, %$31] ; # P
  %431 = phi i64 [%413, %$31] ; # V1
  %432 = phi i64 [%414, %$31] ; # V2
  %433 = phi i64 [%415, %$31] ; # M
  %434 = phi i64 [%416, %$31] ; # N
  %435 = phi i64 [%417, %$31] ; # D
  %436 = phi i64 [%418, %$31] ; # Q
  %437 = phi i64 [%419, %$31] ; # X
  %438 = phi i64 [%420, %$31] ; # U1
  %439 = phi i64 [%421, %$31] ; # U2
  %440 = phi i64 [%422, %$31] ; # U3
  %441 = phi i64 [%420, %$31] ; # Hi
  %442 = phi i64 [%421, %$31] ; # Lo
  br label %$34
$33:
  %443 = phi i64 [%409, %$31] ; # A
  %444 = phi i64 [%410, %$31] ; # B
  %445 = phi i64 [%411, %$31] ; # R
  %446 = phi i64 [%412, %$31] ; # P
  %447 = phi i64 [%413, %$31] ; # V1
  %448 = phi i64 [%414, %$31] ; # V2
  %449 = phi i64 [%415, %$31] ; # M
  %450 = phi i64 [%416, %$31] ; # N
  %451 = phi i64 [%417, %$31] ; # D
  %452 = phi i64 [%418, %$31] ; # Q
  %453 = phi i64 [%419, %$31] ; # X
  %454 = phi i64 [%420, %$31] ; # U1
  %455 = phi i64 [%421, %$31] ; # U2
  %456 = phi i64 [%422, %$31] ; # U3
  %457 = phi i64 [%420, %$31] ; # Hi
  %458 = phi i64 [%421, %$31] ; # Lo
; # (div Hi Lo V1)
  %459 = zext i64 %457 to i128
  %460 = shl i128 %459, 64
  %461 = zext i64 %458 to i128
  %462 = or i128 %460, %461
  %463 = zext i64 %447 to i128
  %464 = urem i128 %462, %463
  %465 = trunc i128 %464 to i64
  %466 = udiv i128 %462, %463
  %467 = trunc i128 %466 to i64
  br label %$34
$34:
  %468 = phi i64 [%427, %$32], [%443, %$33] ; # A
  %469 = phi i64 [%428, %$32], [%444, %$33] ; # B
  %470 = phi i64 [%429, %$32], [%445, %$33] ; # R
  %471 = phi i64 [%430, %$32], [%446, %$33] ; # P
  %472 = phi i64 [%431, %$32], [%447, %$33] ; # V1
  %473 = phi i64 [%432, %$32], [%448, %$33] ; # V2
  %474 = phi i64 [%433, %$32], [%449, %$33] ; # M
  %475 = phi i64 [%434, %$32], [%450, %$33] ; # N
  %476 = phi i64 [%435, %$32], [%451, %$33] ; # D
  %477 = phi i64 [%436, %$32], [%452, %$33] ; # Q
  %478 = phi i64 [%437, %$32], [%453, %$33] ; # X
  %479 = phi i64 [%438, %$32], [%454, %$33] ; # U1
  %480 = phi i64 [%439, %$32], [%455, %$33] ; # U2
  %481 = phi i64 [%440, %$32], [%456, %$33] ; # U3
  %482 = phi i64 [%441, %$32], [%457, %$33] ; # Hi
  %483 = phi i64 [%442, %$32], [%458, %$33] ; # Lo
  %484 = phi i64 [-1, %$32], [%467, %$33] ; # ->
; # (mul Q V1)
  %485 = zext i64 %484 to i128
  %486 = zext i64 %472 to i128
  %487 = mul i128 %485, %486
  %488 = lshr i128 %487, 64
  %489 = trunc i128 %488 to i64
  %490 = trunc i128 %487 to i64
; # (sub Lo (mul Q V1))
  %491 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %483, i64 %490)
  %492 = extractvalue {i64, i1} %491, 1
  %493 = extractvalue {i64, i1} %491, 0
; # (sub Hi @@@ @@)
  %494 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %482, i64 %489)
  %495 = extractvalue {i64, i1} %494, 1
  %496 = extractvalue {i64, i1} %494, 0
  %497 = zext i1 %492 to i64
  %498 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %496, i64 %497)
  %499 = extractvalue {i64, i1} %498, 1
  %500 = or i1 %495, %499
  %501 = extractvalue {i64, i1} %498, 0
; # (until Hi (let L (mul Q V2) (? (> Lo @@@)) (? (and (== Lo @@@) (>...
  br label %$35
$35:
  %502 = phi i64 [%468, %$34], [%593, %$41] ; # A
  %503 = phi i64 [%469, %$34], [%594, %$41] ; # B
  %504 = phi i64 [%470, %$34], [%595, %$41] ; # R
  %505 = phi i64 [%471, %$34], [%596, %$41] ; # P
  %506 = phi i64 [%472, %$34], [%597, %$41] ; # V1
  %507 = phi i64 [%473, %$34], [%598, %$41] ; # V2
  %508 = phi i64 [%474, %$34], [%599, %$41] ; # M
  %509 = phi i64 [%475, %$34], [%600, %$41] ; # N
  %510 = phi i64 [%476, %$34], [%601, %$41] ; # D
  %511 = phi i64 [%484, %$34], [%609, %$41] ; # Q
  %512 = phi i64 [%478, %$34], [%603, %$41] ; # X
  %513 = phi i64 [%479, %$34], [%604, %$41] ; # U1
  %514 = phi i64 [%480, %$34], [%605, %$41] ; # U2
  %515 = phi i64 [%481, %$34], [%606, %$41] ; # U3
  %516 = phi i64 [%501, %$34], [%614, %$41] ; # Hi
  %517 = phi i64 [%493, %$34], [%612, %$41] ; # Lo
  %518 = icmp ne i64 %516, 0
  br i1 %518, label %$37, label %$36
$36:
  %519 = phi i64 [%502, %$35] ; # A
  %520 = phi i64 [%503, %$35] ; # B
  %521 = phi i64 [%504, %$35] ; # R
  %522 = phi i64 [%505, %$35] ; # P
  %523 = phi i64 [%506, %$35] ; # V1
  %524 = phi i64 [%507, %$35] ; # V2
  %525 = phi i64 [%508, %$35] ; # M
  %526 = phi i64 [%509, %$35] ; # N
  %527 = phi i64 [%510, %$35] ; # D
  %528 = phi i64 [%511, %$35] ; # Q
  %529 = phi i64 [%512, %$35] ; # X
  %530 = phi i64 [%513, %$35] ; # U1
  %531 = phi i64 [%514, %$35] ; # U2
  %532 = phi i64 [%515, %$35] ; # U3
  %533 = phi i64 [%516, %$35] ; # Hi
  %534 = phi i64 [%517, %$35] ; # Lo
; # (let L (mul Q V2) (? (> Lo @@@)) (? (and (== Lo @@@) (>= U3 L))))...
; # (mul Q V2)
  %535 = zext i64 %528 to i128
  %536 = zext i64 %524 to i128
  %537 = mul i128 %535, %536
  %538 = lshr i128 %537, 64
  %539 = trunc i128 %538 to i64
  %540 = trunc i128 %537 to i64
; # (? (> Lo @@@))
; # (> Lo @@@)
  %541 = icmp ugt i64 %534, %539
  br i1 %541, label %$37, label %$38
$38:
  %542 = phi i64 [%519, %$36] ; # A
  %543 = phi i64 [%520, %$36] ; # B
  %544 = phi i64 [%521, %$36] ; # R
  %545 = phi i64 [%522, %$36] ; # P
  %546 = phi i64 [%523, %$36] ; # V1
  %547 = phi i64 [%524, %$36] ; # V2
  %548 = phi i64 [%525, %$36] ; # M
  %549 = phi i64 [%526, %$36] ; # N
  %550 = phi i64 [%527, %$36] ; # D
  %551 = phi i64 [%528, %$36] ; # Q
  %552 = phi i64 [%529, %$36] ; # X
  %553 = phi i64 [%530, %$36] ; # U1
  %554 = phi i64 [%531, %$36] ; # U2
  %555 = phi i64 [%532, %$36] ; # U3
  %556 = phi i64 [%533, %$36] ; # Hi
  %557 = phi i64 [%534, %$36] ; # Lo
; # (? (and (== Lo @@@) (>= U3 L)))
; # (and (== Lo @@@) (>= U3 L))
; # (== Lo @@@)
  %558 = icmp eq i64 %557, %539
  br i1 %558, label %$40, label %$39
$40:
  %559 = phi i64 [%542, %$38] ; # A
  %560 = phi i64 [%543, %$38] ; # B
  %561 = phi i64 [%544, %$38] ; # R
  %562 = phi i64 [%545, %$38] ; # P
  %563 = phi i64 [%546, %$38] ; # V1
  %564 = phi i64 [%547, %$38] ; # V2
  %565 = phi i64 [%548, %$38] ; # M
  %566 = phi i64 [%549, %$38] ; # N
  %567 = phi i64 [%550, %$38] ; # D
  %568 = phi i64 [%551, %$38] ; # Q
  %569 = phi i64 [%552, %$38] ; # X
  %570 = phi i64 [%553, %$38] ; # U1
  %571 = phi i64 [%554, %$38] ; # U2
  %572 = phi i64 [%555, %$38] ; # U3
  %573 = phi i64 [%556, %$38] ; # Hi
  %574 = phi i64 [%557, %$38] ; # Lo
; # (>= U3 L)
  %575 = icmp uge i64 %572, %540
  br label %$39
$39:
  %576 = phi i64 [%542, %$38], [%559, %$40] ; # A
  %577 = phi i64 [%543, %$38], [%560, %$40] ; # B
  %578 = phi i64 [%544, %$38], [%561, %$40] ; # R
  %579 = phi i64 [%545, %$38], [%562, %$40] ; # P
  %580 = phi i64 [%546, %$38], [%563, %$40] ; # V1
  %581 = phi i64 [%547, %$38], [%564, %$40] ; # V2
  %582 = phi i64 [%548, %$38], [%565, %$40] ; # M
  %583 = phi i64 [%549, %$38], [%566, %$40] ; # N
  %584 = phi i64 [%550, %$38], [%567, %$40] ; # D
  %585 = phi i64 [%551, %$38], [%568, %$40] ; # Q
  %586 = phi i64 [%552, %$38], [%569, %$40] ; # X
  %587 = phi i64 [%553, %$38], [%570, %$40] ; # U1
  %588 = phi i64 [%554, %$38], [%571, %$40] ; # U2
  %589 = phi i64 [%555, %$38], [%572, %$40] ; # U3
  %590 = phi i64 [%556, %$38], [%573, %$40] ; # Hi
  %591 = phi i64 [%557, %$38], [%574, %$40] ; # Lo
  %592 = phi i1 [0, %$38], [%575, %$40] ; # ->
  br i1 %592, label %$37, label %$41
$41:
  %593 = phi i64 [%576, %$39] ; # A
  %594 = phi i64 [%577, %$39] ; # B
  %595 = phi i64 [%578, %$39] ; # R
  %596 = phi i64 [%579, %$39] ; # P
  %597 = phi i64 [%580, %$39] ; # V1
  %598 = phi i64 [%581, %$39] ; # V2
  %599 = phi i64 [%582, %$39] ; # M
  %600 = phi i64 [%583, %$39] ; # N
  %601 = phi i64 [%584, %$39] ; # D
  %602 = phi i64 [%585, %$39] ; # Q
  %603 = phi i64 [%586, %$39] ; # X
  %604 = phi i64 [%587, %$39] ; # U1
  %605 = phi i64 [%588, %$39] ; # U2
  %606 = phi i64 [%589, %$39] ; # U3
  %607 = phi i64 [%590, %$39] ; # Hi
  %608 = phi i64 [%591, %$39] ; # Lo
; # (dec 'Q)
  %609 = sub i64 %602, 1
; # (add Lo V1)
  %610 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %608, i64 %597)
  %611 = extractvalue {i64, i1} %610, 1
  %612 = extractvalue {i64, i1} %610, 0
; # (+ Hi @@)
  %613 = zext i1 %611 to i64
  %614 = add i64 %607, %613
  br label %$35
$37:
  %615 = phi i64 [%502, %$35], [%519, %$36], [%576, %$39] ; # A
  %616 = phi i64 [%503, %$35], [%520, %$36], [%577, %$39] ; # B
  %617 = phi i64 [%504, %$35], [%521, %$36], [%578, %$39] ; # R
  %618 = phi i64 [%505, %$35], [%522, %$36], [%579, %$39] ; # P
  %619 = phi i64 [%506, %$35], [%523, %$36], [%580, %$39] ; # V1
  %620 = phi i64 [%507, %$35], [%524, %$36], [%581, %$39] ; # V2
  %621 = phi i64 [%508, %$35], [%525, %$36], [%582, %$39] ; # M
  %622 = phi i64 [%509, %$35], [%526, %$36], [%583, %$39] ; # N
  %623 = phi i64 [%510, %$35], [%527, %$36], [%584, %$39] ; # D
  %624 = phi i64 [%511, %$35], [%528, %$36], [%585, %$39] ; # Q
  %625 = phi i64 [%512, %$35], [%529, %$36], [%586, %$39] ; # X
  %626 = phi i64 [%513, %$35], [%530, %$36], [%587, %$39] ; # U1
  %627 = phi i64 [%514, %$35], [%531, %$36], [%588, %$39] ; # U2
  %628 = phi i64 [%515, %$35], [%532, %$36], [%589, %$39] ; # U3
  %629 = phi i64 [%516, %$35], [%533, %$36], [%590, %$39] ; # Hi
  %630 = phi i64 [%517, %$35], [%534, %$36], [%591, %$39] ; # Lo
; # (let (Z X Y (val V)) (set (dig Z) (sub (val (dig Z)) (mul Q (val ...
; # (val V)
  %631 = inttoptr i64 %24 to i64*
  %632 = load i64, i64* %631
; # (set (dig Z) (sub (val (dig Z)) (mul Q (val (dig Y)))))
; # (dig Z)
  %633 = add i64 %625, -4
; # (dig Z)
  %634 = add i64 %625, -4
; # (val (dig Z))
  %635 = inttoptr i64 %634 to i64*
  %636 = load i64, i64* %635
; # (dig Y)
  %637 = add i64 %632, -4
; # (val (dig Y))
  %638 = inttoptr i64 %637 to i64*
  %639 = load i64, i64* %638
; # (mul Q (val (dig Y)))
  %640 = zext i64 %624 to i128
  %641 = zext i64 %639 to i128
  %642 = mul i128 %640, %641
  %643 = lshr i128 %642, 64
  %644 = trunc i128 %643 to i64
  %645 = trunc i128 %642 to i64
; # (sub (val (dig Z)) (mul Q (val (dig Y))))
  %646 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %636, i64 %645)
  %647 = extractvalue {i64, i1} %646, 1
  %648 = extractvalue {i64, i1} %646, 0
  %649 = inttoptr i64 %633 to i64*
  store i64 %648, i64* %649
; # (+ @@@ @@)
  %650 = zext i1 %647 to i64
  %651 = add i64 %644, %650
; # (while (big? (setq Y (val (big Y)))) (setq Z (val (big Z))) (set ...
  br label %$42
$42:
  %652 = phi i64 [%615, %$37], [%675, %$43] ; # A
  %653 = phi i64 [%616, %$37], [%676, %$43] ; # B
  %654 = phi i64 [%617, %$37], [%677, %$43] ; # R
  %655 = phi i64 [%618, %$37], [%678, %$43] ; # P
  %656 = phi i64 [%619, %$37], [%679, %$43] ; # V1
  %657 = phi i64 [%620, %$37], [%680, %$43] ; # V2
  %658 = phi i64 [%621, %$37], [%681, %$43] ; # M
  %659 = phi i64 [%622, %$37], [%682, %$43] ; # N
  %660 = phi i64 [%623, %$37], [%683, %$43] ; # D
  %661 = phi i64 [%624, %$37], [%684, %$43] ; # Q
  %662 = phi i64 [%625, %$37], [%685, %$43] ; # X
  %663 = phi i64 [%626, %$37], [%686, %$43] ; # U1
  %664 = phi i64 [%627, %$37], [%687, %$43] ; # U2
  %665 = phi i64 [%628, %$37], [%688, %$43] ; # U3
  %666 = phi i64 [%651, %$37], [%732, %$43] ; # Hi
  %667 = phi i64 [%630, %$37], [%690, %$43] ; # Lo
  %668 = phi i64 [%625, %$37], [%695, %$43] ; # Z
  %669 = phi i64 [%632, %$37], [%692, %$43] ; # Y
; # (big Y)
  %670 = add i64 %669, 4
; # (val (big Y))
  %671 = inttoptr i64 %670 to i64*
  %672 = load i64, i64* %671
; # (big? (setq Y (val (big Y))))
  %673 = and i64 %672, 4
  %674 = icmp ne i64 %673, 0
  br i1 %674, label %$43, label %$44
$43:
  %675 = phi i64 [%652, %$42] ; # A
  %676 = phi i64 [%653, %$42] ; # B
  %677 = phi i64 [%654, %$42] ; # R
  %678 = phi i64 [%655, %$42] ; # P
  %679 = phi i64 [%656, %$42] ; # V1
  %680 = phi i64 [%657, %$42] ; # V2
  %681 = phi i64 [%658, %$42] ; # M
  %682 = phi i64 [%659, %$42] ; # N
  %683 = phi i64 [%660, %$42] ; # D
  %684 = phi i64 [%661, %$42] ; # Q
  %685 = phi i64 [%662, %$42] ; # X
  %686 = phi i64 [%663, %$42] ; # U1
  %687 = phi i64 [%664, %$42] ; # U2
  %688 = phi i64 [%665, %$42] ; # U3
  %689 = phi i64 [%666, %$42] ; # Hi
  %690 = phi i64 [%667, %$42] ; # Lo
  %691 = phi i64 [%668, %$42] ; # Z
  %692 = phi i64 [%672, %$42] ; # Y
; # (big Z)
  %693 = add i64 %691, 4
; # (val (big Z))
  %694 = inttoptr i64 %693 to i64*
  %695 = load i64, i64* %694
; # (set (dig Z) (sub (val (dig Z)) Hi))
; # (dig Z)
  %696 = add i64 %695, -4
; # (dig Z)
  %697 = add i64 %695, -4
; # (val (dig Z))
  %698 = inttoptr i64 %697 to i64*
  %699 = load i64, i64* %698
; # (sub (val (dig Z)) Hi)
  %700 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %699, i64 %689)
  %701 = extractvalue {i64, i1} %700, 1
  %702 = extractvalue {i64, i1} %700, 0
  %703 = inttoptr i64 %696 to i64*
  store i64 %702, i64* %703
; # (- Hi Hi @@)
  %704 = sub i64 %689, %689
  %705 = zext i1 %701 to i64
  %706 = sub i64 %704, %705
; # (set (dig Z) (sub (val (dig Z)) (mul Q (val (dig Y)))))
; # (dig Z)
  %707 = add i64 %695, -4
; # (dig Z)
  %708 = add i64 %695, -4
; # (val (dig Z))
  %709 = inttoptr i64 %708 to i64*
  %710 = load i64, i64* %709
; # (dig Y)
  %711 = add i64 %692, -4
; # (val (dig Y))
  %712 = inttoptr i64 %711 to i64*
  %713 = load i64, i64* %712
; # (mul Q (val (dig Y)))
  %714 = zext i64 %684 to i128
  %715 = zext i64 %713 to i128
  %716 = mul i128 %714, %715
  %717 = lshr i128 %716, 64
  %718 = trunc i128 %717 to i64
  %719 = trunc i128 %716 to i64
; # (sub (val (dig Z)) (mul Q (val (dig Y))))
  %720 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %710, i64 %719)
  %721 = extractvalue {i64, i1} %720, 1
  %722 = extractvalue {i64, i1} %720, 0
  %723 = inttoptr i64 %707 to i64*
  store i64 %722, i64* %723
; # (sub Hi @@@ @@)
  %724 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %706, i64 %718)
  %725 = extractvalue {i64, i1} %724, 1
  %726 = extractvalue {i64, i1} %724, 0
  %727 = zext i1 %721 to i64
  %728 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %726, i64 %727)
  %729 = extractvalue {i64, i1} %728, 1
  %730 = or i1 %725, %729
  %731 = extractvalue {i64, i1} %728, 0
; # (- (sub Hi @@@ @@))
  %732 = sub i64 0, %731
  br label %$42
$44:
  %733 = phi i64 [%652, %$42] ; # A
  %734 = phi i64 [%653, %$42] ; # B
  %735 = phi i64 [%654, %$42] ; # R
  %736 = phi i64 [%655, %$42] ; # P
  %737 = phi i64 [%656, %$42] ; # V1
  %738 = phi i64 [%657, %$42] ; # V2
  %739 = phi i64 [%658, %$42] ; # M
  %740 = phi i64 [%659, %$42] ; # N
  %741 = phi i64 [%660, %$42] ; # D
  %742 = phi i64 [%661, %$42] ; # Q
  %743 = phi i64 [%662, %$42] ; # X
  %744 = phi i64 [%663, %$42] ; # U1
  %745 = phi i64 [%664, %$42] ; # U2
  %746 = phi i64 [%665, %$42] ; # U3
  %747 = phi i64 [%666, %$42] ; # Hi
  %748 = phi i64 [%667, %$42] ; # Lo
  %749 = phi i64 [%668, %$42] ; # Z
  %750 = phi i64 [%672, %$42] ; # Y
; # (when Hi (setq Z (val (big Z))) (set (dig Z) (sub (val (dig Z)) H...
  %751 = icmp ne i64 %747, 0
  br i1 %751, label %$45, label %$46
$45:
  %752 = phi i64 [%733, %$44] ; # A
  %753 = phi i64 [%734, %$44] ; # B
  %754 = phi i64 [%735, %$44] ; # R
  %755 = phi i64 [%736, %$44] ; # P
  %756 = phi i64 [%737, %$44] ; # V1
  %757 = phi i64 [%738, %$44] ; # V2
  %758 = phi i64 [%739, %$44] ; # M
  %759 = phi i64 [%740, %$44] ; # N
  %760 = phi i64 [%741, %$44] ; # D
  %761 = phi i64 [%742, %$44] ; # Q
  %762 = phi i64 [%743, %$44] ; # X
  %763 = phi i64 [%744, %$44] ; # U1
  %764 = phi i64 [%745, %$44] ; # U2
  %765 = phi i64 [%746, %$44] ; # U3
  %766 = phi i64 [%747, %$44] ; # Hi
  %767 = phi i64 [%748, %$44] ; # Lo
  %768 = phi i64 [%749, %$44] ; # Z
  %769 = phi i64 [%750, %$44] ; # Y
; # (big Z)
  %770 = add i64 %768, 4
; # (val (big Z))
  %771 = inttoptr i64 %770 to i64*
  %772 = load i64, i64* %771
; # (set (dig Z) (sub (val (dig Z)) Hi))
; # (dig Z)
  %773 = add i64 %772, -4
; # (dig Z)
  %774 = add i64 %772, -4
; # (val (dig Z))
  %775 = inttoptr i64 %774 to i64*
  %776 = load i64, i64* %775
; # (sub (val (dig Z)) Hi)
  %777 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %776, i64 %766)
  %778 = extractvalue {i64, i1} %777, 1
  %779 = extractvalue {i64, i1} %777, 0
  %780 = inttoptr i64 %773 to i64*
  store i64 %779, i64* %780
; # (when @@ (dec 'Q) (when (or Rem M) (setq Y (val V)) (set (dig X) ...
  br i1 %778, label %$47, label %$48
$47:
  %781 = phi i64 [%752, %$45] ; # A
  %782 = phi i64 [%753, %$45] ; # B
  %783 = phi i64 [%754, %$45] ; # R
  %784 = phi i64 [%755, %$45] ; # P
  %785 = phi i64 [%756, %$45] ; # V1
  %786 = phi i64 [%757, %$45] ; # V2
  %787 = phi i64 [%758, %$45] ; # M
  %788 = phi i64 [%759, %$45] ; # N
  %789 = phi i64 [%760, %$45] ; # D
  %790 = phi i64 [%761, %$45] ; # Q
  %791 = phi i64 [%762, %$45] ; # X
  %792 = phi i64 [%763, %$45] ; # U1
  %793 = phi i64 [%764, %$45] ; # U2
  %794 = phi i64 [%765, %$45] ; # U3
  %795 = phi i64 [%766, %$45] ; # Hi
  %796 = phi i64 [%767, %$45] ; # Lo
  %797 = phi i64 [%772, %$45] ; # Z
  %798 = phi i64 [%769, %$45] ; # Y
; # (dec 'Q)
  %799 = sub i64 %790, 1
; # (when (or Rem M) (setq Y (val V)) (set (dig X) (add (val (dig X))...
; # (or Rem M)
  br i1 %2, label %$49, label %$50
$50:
  %800 = phi i64 [%781, %$47] ; # A
  %801 = phi i64 [%782, %$47] ; # B
  %802 = phi i64 [%783, %$47] ; # R
  %803 = phi i64 [%784, %$47] ; # P
  %804 = phi i64 [%785, %$47] ; # V1
  %805 = phi i64 [%786, %$47] ; # V2
  %806 = phi i64 [%787, %$47] ; # M
  %807 = phi i64 [%788, %$47] ; # N
  %808 = phi i64 [%789, %$47] ; # D
  %809 = phi i64 [%799, %$47] ; # Q
  %810 = phi i64 [%791, %$47] ; # X
  %811 = phi i64 [%792, %$47] ; # U1
  %812 = phi i64 [%793, %$47] ; # U2
  %813 = phi i64 [%794, %$47] ; # U3
  %814 = phi i64 [%795, %$47] ; # Hi
  %815 = phi i64 [%796, %$47] ; # Lo
  %816 = phi i64 [%797, %$47] ; # Z
  %817 = phi i64 [%798, %$47] ; # Y
  %818 = icmp ne i64 %806, 0
  br label %$49
$49:
  %819 = phi i64 [%781, %$47], [%800, %$50] ; # A
  %820 = phi i64 [%782, %$47], [%801, %$50] ; # B
  %821 = phi i64 [%783, %$47], [%802, %$50] ; # R
  %822 = phi i64 [%784, %$47], [%803, %$50] ; # P
  %823 = phi i64 [%785, %$47], [%804, %$50] ; # V1
  %824 = phi i64 [%786, %$47], [%805, %$50] ; # V2
  %825 = phi i64 [%787, %$47], [%806, %$50] ; # M
  %826 = phi i64 [%788, %$47], [%807, %$50] ; # N
  %827 = phi i64 [%789, %$47], [%808, %$50] ; # D
  %828 = phi i64 [%799, %$47], [%809, %$50] ; # Q
  %829 = phi i64 [%791, %$47], [%810, %$50] ; # X
  %830 = phi i64 [%792, %$47], [%811, %$50] ; # U1
  %831 = phi i64 [%793, %$47], [%812, %$50] ; # U2
  %832 = phi i64 [%794, %$47], [%813, %$50] ; # U3
  %833 = phi i64 [%795, %$47], [%814, %$50] ; # Hi
  %834 = phi i64 [%796, %$47], [%815, %$50] ; # Lo
  %835 = phi i64 [%797, %$47], [%816, %$50] ; # Z
  %836 = phi i64 [%798, %$47], [%817, %$50] ; # Y
  %837 = phi i1 [1, %$47], [%818, %$50] ; # ->
  br i1 %837, label %$51, label %$52
$51:
  %838 = phi i64 [%819, %$49] ; # A
  %839 = phi i64 [%820, %$49] ; # B
  %840 = phi i64 [%821, %$49] ; # R
  %841 = phi i64 [%822, %$49] ; # P
  %842 = phi i64 [%823, %$49] ; # V1
  %843 = phi i64 [%824, %$49] ; # V2
  %844 = phi i64 [%825, %$49] ; # M
  %845 = phi i64 [%826, %$49] ; # N
  %846 = phi i64 [%827, %$49] ; # D
  %847 = phi i64 [%828, %$49] ; # Q
  %848 = phi i64 [%829, %$49] ; # X
  %849 = phi i64 [%830, %$49] ; # U1
  %850 = phi i64 [%831, %$49] ; # U2
  %851 = phi i64 [%832, %$49] ; # U3
  %852 = phi i64 [%833, %$49] ; # Hi
  %853 = phi i64 [%834, %$49] ; # Lo
  %854 = phi i64 [%835, %$49] ; # Z
  %855 = phi i64 [%836, %$49] ; # Y
; # (val V)
  %856 = inttoptr i64 %24 to i64*
  %857 = load i64, i64* %856
; # (set (dig X) (add (val (dig X)) (val (dig Y))))
; # (dig X)
  %858 = add i64 %848, -4
; # (dig X)
  %859 = add i64 %848, -4
; # (val (dig X))
  %860 = inttoptr i64 %859 to i64*
  %861 = load i64, i64* %860
; # (dig Y)
  %862 = add i64 %857, -4
; # (val (dig Y))
  %863 = inttoptr i64 %862 to i64*
  %864 = load i64, i64* %863
; # (add (val (dig X)) (val (dig Y)))
  %865 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %861, i64 %864)
  %866 = extractvalue {i64, i1} %865, 1
  %867 = extractvalue {i64, i1} %865, 0
  %868 = inttoptr i64 %858 to i64*
  store i64 %867, i64* %868
; # (let C @@ (loop (setq X (val (big X))) (? (cnt? (setq Y (val (big...
; # (loop (setq X (val (big X))) (? (cnt? (setq Y (val (big Y))))) (s...
  br label %$53
$53:
  %869 = phi i64 [%838, %$51], [%896, %$54] ; # A
  %870 = phi i64 [%839, %$51], [%897, %$54] ; # B
  %871 = phi i64 [%840, %$51], [%898, %$54] ; # R
  %872 = phi i64 [%841, %$51], [%899, %$54] ; # P
  %873 = phi i64 [%842, %$51], [%900, %$54] ; # V1
  %874 = phi i64 [%843, %$51], [%901, %$54] ; # V2
  %875 = phi i64 [%844, %$51], [%902, %$54] ; # M
  %876 = phi i64 [%845, %$51], [%903, %$54] ; # N
  %877 = phi i64 [%846, %$51], [%904, %$54] ; # D
  %878 = phi i64 [%847, %$51], [%905, %$54] ; # Q
  %879 = phi i64 [%848, %$51], [%906, %$54] ; # X
  %880 = phi i64 [%849, %$51], [%907, %$54] ; # U1
  %881 = phi i64 [%850, %$51], [%908, %$54] ; # U2
  %882 = phi i64 [%851, %$51], [%909, %$54] ; # U3
  %883 = phi i64 [%852, %$51], [%910, %$54] ; # Hi
  %884 = phi i64 [%853, %$51], [%911, %$54] ; # Lo
  %885 = phi i64 [%854, %$51], [%912, %$54] ; # Z
  %886 = phi i64 [%857, %$51], [%913, %$54] ; # Y
  %887 = phi i1 [%866, %$51], [%928, %$54] ; # C
; # (big X)
  %888 = add i64 %879, 4
; # (val (big X))
  %889 = inttoptr i64 %888 to i64*
  %890 = load i64, i64* %889
; # (? (cnt? (setq Y (val (big Y)))))
; # (big Y)
  %891 = add i64 %886, 4
; # (val (big Y))
  %892 = inttoptr i64 %891 to i64*
  %893 = load i64, i64* %892
; # (cnt? (setq Y (val (big Y))))
  %894 = and i64 %893, 2
  %895 = icmp ne i64 %894, 0
  br i1 %895, label %$55, label %$54
$54:
  %896 = phi i64 [%869, %$53] ; # A
  %897 = phi i64 [%870, %$53] ; # B
  %898 = phi i64 [%871, %$53] ; # R
  %899 = phi i64 [%872, %$53] ; # P
  %900 = phi i64 [%873, %$53] ; # V1
  %901 = phi i64 [%874, %$53] ; # V2
  %902 = phi i64 [%875, %$53] ; # M
  %903 = phi i64 [%876, %$53] ; # N
  %904 = phi i64 [%877, %$53] ; # D
  %905 = phi i64 [%878, %$53] ; # Q
  %906 = phi i64 [%890, %$53] ; # X
  %907 = phi i64 [%880, %$53] ; # U1
  %908 = phi i64 [%881, %$53] ; # U2
  %909 = phi i64 [%882, %$53] ; # U3
  %910 = phi i64 [%883, %$53] ; # Hi
  %911 = phi i64 [%884, %$53] ; # Lo
  %912 = phi i64 [%885, %$53] ; # Z
  %913 = phi i64 [%893, %$53] ; # Y
  %914 = phi i1 [%887, %$53] ; # C
; # (set (dig X) (add (val (dig X)) (val (dig Y)) C))
; # (dig X)
  %915 = add i64 %906, -4
; # (dig X)
  %916 = add i64 %906, -4
; # (val (dig X))
  %917 = inttoptr i64 %916 to i64*
  %918 = load i64, i64* %917
; # (dig Y)
  %919 = add i64 %913, -4
; # (val (dig Y))
  %920 = inttoptr i64 %919 to i64*
  %921 = load i64, i64* %920
; # (add (val (dig X)) (val (dig Y)) C)
  %922 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %918, i64 %921)
  %923 = extractvalue {i64, i1} %922, 1
  %924 = extractvalue {i64, i1} %922, 0
  %925 = zext i1 %914 to i64
  %926 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %924, i64 %925)
  %927 = extractvalue {i64, i1} %926, 1
  %928 = or i1 %923, %927
  %929 = extractvalue {i64, i1} %926, 0
  %930 = inttoptr i64 %915 to i64*
  store i64 %929, i64* %930
  br label %$53
$55:
  %931 = phi i64 [%869, %$53] ; # A
  %932 = phi i64 [%870, %$53] ; # B
  %933 = phi i64 [%871, %$53] ; # R
  %934 = phi i64 [%872, %$53] ; # P
  %935 = phi i64 [%873, %$53] ; # V1
  %936 = phi i64 [%874, %$53] ; # V2
  %937 = phi i64 [%875, %$53] ; # M
  %938 = phi i64 [%876, %$53] ; # N
  %939 = phi i64 [%877, %$53] ; # D
  %940 = phi i64 [%878, %$53] ; # Q
  %941 = phi i64 [%890, %$53] ; # X
  %942 = phi i64 [%880, %$53] ; # U1
  %943 = phi i64 [%881, %$53] ; # U2
  %944 = phi i64 [%882, %$53] ; # U3
  %945 = phi i64 [%883, %$53] ; # Hi
  %946 = phi i64 [%884, %$53] ; # Lo
  %947 = phi i64 [%885, %$53] ; # Z
  %948 = phi i64 [%893, %$53] ; # Y
  %949 = phi i1 [%887, %$53] ; # C
  %950 = phi i64 [0, %$53] ; # ->
; # (set (dig X) (+ (val (dig X)) C))
; # (dig X)
  %951 = add i64 %941, -4
; # (dig X)
  %952 = add i64 %941, -4
; # (val (dig X))
  %953 = inttoptr i64 %952 to i64*
  %954 = load i64, i64* %953
; # (+ (val (dig X)) C)
  %955 = zext i1 %949 to i64
  %956 = add i64 %954, %955
  %957 = inttoptr i64 %951 to i64*
  store i64 %956, i64* %957
  br label %$52
$52:
  %958 = phi i64 [%819, %$49], [%931, %$55] ; # A
  %959 = phi i64 [%820, %$49], [%932, %$55] ; # B
  %960 = phi i64 [%821, %$49], [%933, %$55] ; # R
  %961 = phi i64 [%822, %$49], [%934, %$55] ; # P
  %962 = phi i64 [%823, %$49], [%935, %$55] ; # V1
  %963 = phi i64 [%824, %$49], [%936, %$55] ; # V2
  %964 = phi i64 [%825, %$49], [%937, %$55] ; # M
  %965 = phi i64 [%826, %$49], [%938, %$55] ; # N
  %966 = phi i64 [%827, %$49], [%939, %$55] ; # D
  %967 = phi i64 [%828, %$49], [%940, %$55] ; # Q
  %968 = phi i64 [%829, %$49], [%941, %$55] ; # X
  %969 = phi i64 [%830, %$49], [%942, %$55] ; # U1
  %970 = phi i64 [%831, %$49], [%943, %$55] ; # U2
  %971 = phi i64 [%832, %$49], [%944, %$55] ; # U3
  %972 = phi i64 [%833, %$49], [%945, %$55] ; # Hi
  %973 = phi i64 [%834, %$49], [%946, %$55] ; # Lo
  %974 = phi i64 [%835, %$49], [%947, %$55] ; # Z
  %975 = phi i64 [%836, %$49], [%948, %$55] ; # Y
  br label %$48
$48:
  %976 = phi i64 [%752, %$45], [%958, %$52] ; # A
  %977 = phi i64 [%753, %$45], [%959, %$52] ; # B
  %978 = phi i64 [%754, %$45], [%960, %$52] ; # R
  %979 = phi i64 [%755, %$45], [%961, %$52] ; # P
  %980 = phi i64 [%756, %$45], [%962, %$52] ; # V1
  %981 = phi i64 [%757, %$45], [%963, %$52] ; # V2
  %982 = phi i64 [%758, %$45], [%964, %$52] ; # M
  %983 = phi i64 [%759, %$45], [%965, %$52] ; # N
  %984 = phi i64 [%760, %$45], [%966, %$52] ; # D
  %985 = phi i64 [%761, %$45], [%967, %$52] ; # Q
  %986 = phi i64 [%762, %$45], [%968, %$52] ; # X
  %987 = phi i64 [%763, %$45], [%969, %$52] ; # U1
  %988 = phi i64 [%764, %$45], [%970, %$52] ; # U2
  %989 = phi i64 [%765, %$45], [%971, %$52] ; # U3
  %990 = phi i64 [%766, %$45], [%972, %$52] ; # Hi
  %991 = phi i64 [%767, %$45], [%973, %$52] ; # Lo
  %992 = phi i64 [%772, %$45], [%974, %$52] ; # Z
  %993 = phi i64 [%769, %$45], [%975, %$52] ; # Y
  br label %$46
$46:
  %994 = phi i64 [%733, %$44], [%976, %$48] ; # A
  %995 = phi i64 [%734, %$44], [%977, %$48] ; # B
  %996 = phi i64 [%735, %$44], [%978, %$48] ; # R
  %997 = phi i64 [%736, %$44], [%979, %$48] ; # P
  %998 = phi i64 [%737, %$44], [%980, %$48] ; # V1
  %999 = phi i64 [%738, %$44], [%981, %$48] ; # V2
  %1000 = phi i64 [%739, %$44], [%982, %$48] ; # M
  %1001 = phi i64 [%740, %$44], [%983, %$48] ; # N
  %1002 = phi i64 [%741, %$44], [%984, %$48] ; # D
  %1003 = phi i64 [%742, %$44], [%985, %$48] ; # Q
  %1004 = phi i64 [%743, %$44], [%986, %$48] ; # X
  %1005 = phi i64 [%744, %$44], [%987, %$48] ; # U1
  %1006 = phi i64 [%745, %$44], [%988, %$48] ; # U2
  %1007 = phi i64 [%746, %$44], [%989, %$48] ; # U3
  %1008 = phi i64 [%747, %$44], [%990, %$48] ; # Hi
  %1009 = phi i64 [%748, %$44], [%991, %$48] ; # Lo
  %1010 = phi i64 [%749, %$44], [%992, %$48] ; # Z
  %1011 = phi i64 [%750, %$44], [%993, %$48] ; # Y
; # (consNum Q R)
  %1012 = call i64 @consNum(i64 %1003, i64 %996)
; # (safe (consNum Q R))
  %1013 = inttoptr i64 %4 to i64*
  store i64 %1012, i64* %1013
; # (? (lt0 (dec 'M)))
; # (dec 'M)
  %1014 = sub i64 %1000, 1
; # (lt0 (dec 'M))
  %1015 = icmp slt i64 %1014, 0
  br i1 %1015, label %$57, label %$56
$56:
  %1016 = phi i64 [%994, %$46] ; # A
  %1017 = phi i64 [%995, %$46] ; # B
  %1018 = phi i64 [%1012, %$46] ; # R
  %1019 = phi i64 [%997, %$46] ; # P
  %1020 = phi i64 [%998, %$46] ; # V1
  %1021 = phi i64 [%999, %$46] ; # V2
  %1022 = phi i64 [%1014, %$46] ; # M
  %1023 = phi i64 [%1001, %$46] ; # N
  %1024 = phi i64 [%1002, %$46] ; # D
  %1025 = phi i64 [%1003, %$46] ; # Q
  br label %$25
$57:
  %1026 = phi i64 [%994, %$46] ; # A
  %1027 = phi i64 [%995, %$46] ; # B
  %1028 = phi i64 [%1012, %$46] ; # R
  %1029 = phi i64 [%997, %$46] ; # P
  %1030 = phi i64 [%998, %$46] ; # V1
  %1031 = phi i64 [%999, %$46] ; # V2
  %1032 = phi i64 [%1014, %$46] ; # M
  %1033 = phi i64 [%1001, %$46] ; # N
  %1034 = phi i64 [%1002, %$46] ; # D
  %1035 = phi i64 [%1003, %$46] ; # Q
  %1036 = phi i64 [0, %$46] ; # ->
; # (ifn Rem (zapZero R) (setq A (zapZero (val U))) (while D (setq A ...
  br i1 %2, label %$59, label %$58
$58:
  %1037 = phi i64 [%1026, %$57] ; # A
  %1038 = phi i64 [%1027, %$57] ; # B
  %1039 = phi i64 [%1028, %$57] ; # R
  %1040 = phi i64 [%1029, %$57] ; # P
  %1041 = phi i64 [%1030, %$57] ; # V1
  %1042 = phi i64 [%1031, %$57] ; # V2
  %1043 = phi i64 [%1032, %$57] ; # M
  %1044 = phi i64 [%1033, %$57] ; # N
  %1045 = phi i64 [%1034, %$57] ; # D
  %1046 = phi i64 [%1035, %$57] ; # Q
; # (zapZero R)
  %1047 = call i64 @zapZero(i64 %1039)
  br label %$60
$59:
  %1048 = phi i64 [%1026, %$57] ; # A
  %1049 = phi i64 [%1027, %$57] ; # B
  %1050 = phi i64 [%1028, %$57] ; # R
  %1051 = phi i64 [%1029, %$57] ; # P
  %1052 = phi i64 [%1030, %$57] ; # V1
  %1053 = phi i64 [%1031, %$57] ; # V2
  %1054 = phi i64 [%1032, %$57] ; # M
  %1055 = phi i64 [%1033, %$57] ; # N
  %1056 = phi i64 [%1034, %$57] ; # D
  %1057 = phi i64 [%1035, %$57] ; # Q
; # (val U)
  %1058 = inttoptr i64 %16 to i64*
  %1059 = load i64, i64* %1058
; # (zapZero (val U))
  %1060 = call i64 @zapZero(i64 %1059)
; # (while D (setq A (half A)) (dec 'D))
  br label %$61
$61:
  %1061 = phi i64 [%1060, %$59], [%1082, %$62] ; # A
  %1062 = phi i64 [%1049, %$59], [%1073, %$62] ; # B
  %1063 = phi i64 [%1050, %$59], [%1074, %$62] ; # R
  %1064 = phi i64 [%1051, %$59], [%1075, %$62] ; # P
  %1065 = phi i64 [%1052, %$59], [%1076, %$62] ; # V1
  %1066 = phi i64 [%1053, %$59], [%1077, %$62] ; # V2
  %1067 = phi i64 [%1054, %$59], [%1078, %$62] ; # M
  %1068 = phi i64 [%1055, %$59], [%1079, %$62] ; # N
  %1069 = phi i64 [%1056, %$59], [%1083, %$62] ; # D
  %1070 = phi i64 [%1057, %$59], [%1081, %$62] ; # Q
  %1071 = icmp ne i64 %1069, 0
  br i1 %1071, label %$62, label %$63
$62:
  %1072 = phi i64 [%1061, %$61] ; # A
  %1073 = phi i64 [%1062, %$61] ; # B
  %1074 = phi i64 [%1063, %$61] ; # R
  %1075 = phi i64 [%1064, %$61] ; # P
  %1076 = phi i64 [%1065, %$61] ; # V1
  %1077 = phi i64 [%1066, %$61] ; # V2
  %1078 = phi i64 [%1067, %$61] ; # M
  %1079 = phi i64 [%1068, %$61] ; # N
  %1080 = phi i64 [%1069, %$61] ; # D
  %1081 = phi i64 [%1070, %$61] ; # Q
; # (half A)
  %1082 = call i64 @half(i64 %1072)
; # (dec 'D)
  %1083 = sub i64 %1080, 1
  br label %$61
$63:
  %1084 = phi i64 [%1061, %$61] ; # A
  %1085 = phi i64 [%1062, %$61] ; # B
  %1086 = phi i64 [%1063, %$61] ; # R
  %1087 = phi i64 [%1064, %$61] ; # P
  %1088 = phi i64 [%1065, %$61] ; # V1
  %1089 = phi i64 [%1066, %$61] ; # V2
  %1090 = phi i64 [%1067, %$61] ; # M
  %1091 = phi i64 [%1068, %$61] ; # N
  %1092 = phi i64 [%1069, %$61] ; # D
  %1093 = phi i64 [%1070, %$61] ; # Q
  br label %$60
$60:
  %1094 = phi i64 [%1037, %$58], [%1084, %$63] ; # A
  %1095 = phi i64 [%1038, %$58], [%1085, %$63] ; # B
  %1096 = phi i64 [%1039, %$58], [%1086, %$63] ; # R
  %1097 = phi i64 [%1040, %$58], [%1087, %$63] ; # P
  %1098 = phi i64 [%1041, %$58], [%1088, %$63] ; # V1
  %1099 = phi i64 [%1042, %$58], [%1089, %$63] ; # V2
  %1100 = phi i64 [%1043, %$58], [%1090, %$63] ; # M
  %1101 = phi i64 [%1044, %$58], [%1091, %$63] ; # N
  %1102 = phi i64 [%1045, %$58], [%1092, %$63] ; # D
  %1103 = phi i64 [%1046, %$58], [%1093, %$63] ; # Q
  %1104 = phi i64 [%1047, %$58], [%1084, %$63] ; # ->
; # (drop *Safe)
  %1105 = inttoptr i64 %4 to i64*
  %1106 = getelementptr i64, i64* %1105, i32 1
  %1107 = load i64, i64* %1106
  %1108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %1107, i64* %1108
  ret i64 %1104
}

define i64 @divu(i64, i64) {
$1:
; # (cond ((big? A) (div1 A B NO)) ((big? B) ZERO) (T (cnt (/ (int A)...
; # (big? A)
  %2 = and i64 %0, 4
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
; # (div1 A B NO)
  %4 = call i64 @div1(i64 %0, i64 %1, i1 0)
  br label %$2
$3:
; # (big? B)
  %5 = and i64 %1, 4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  br label %$2
$5:
; # (int A)
  %7 = lshr i64 %0, 4
; # (int B)
  %8 = lshr i64 %1, 4
; # (/ (int A) (int B))
  %9 = udiv i64 %7, %8
; # (cnt (/ (int A) (int B)))
  %10 = shl i64 %9, 4
  %11 = or i64 %10, 2
  br label %$2
$2:
  %12 = phi i64 [%4, %$4], [2, %$6], [%11, %$5] ; # ->
  ret i64 %12
}

define i64 @remu(i64, i64) {
$1:
; # (cond ((big? A) (div1 A B YES)) ((big? B) A) (T (cnt (% (int A) (...
; # (big? A)
  %2 = and i64 %0, 4
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
; # (div1 A B YES)
  %4 = call i64 @div1(i64 %0, i64 %1, i1 1)
  br label %$2
$3:
; # (big? B)
  %5 = and i64 %1, 4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  br label %$2
$5:
; # (int A)
  %7 = lshr i64 %0, 4
; # (int B)
  %8 = lshr i64 %1, 4
; # (% (int A) (int B))
  %9 = urem i64 %7, %8
; # (cnt (% (int A) (int B)))
  %10 = shl i64 %9, 4
  %11 = or i64 %10, 2
  br label %$2
$2:
  %12 = phi i64 [%4, %$4], [%0, %$6], [%11, %$5] ; # ->
  ret i64 %12
}

define i64 @incs(i64) {
$1:
; # (if (sign? A) (neg (subu (pos A) ONE)) (addu A ONE))
; # (sign? A)
  %1 = and i64 %0, 8
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (pos A)
  %3 = and i64 %0, -9
; # (subu (pos A) ONE)
  %4 = call i64 @subu(i64 %3, i64 18)
; # (neg (subu (pos A) ONE))
  %5 = icmp eq i64 %4, 2
  br i1 %5, label %$5, label %$6
$5:
  br label %$7
$6:
  %6 = xor i64 %4, 8
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%6, %$6] ; # ->
  br label %$4
$3:
; # (addu A ONE)
  %8 = call i64 @addu(i64 %0, i64 18)
  br label %$4
$4:
  %9 = phi i64 [%7, %$7], [%8, %$3] ; # ->
  ret i64 %9
}

define i64 @decs(i64) {
$1:
; # (if (sign? A) (neg (addu (pos A) ONE)) (subu A ONE))
; # (sign? A)
  %1 = and i64 %0, 8
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (pos A)
  %3 = and i64 %0, -9
; # (addu (pos A) ONE)
  %4 = call i64 @addu(i64 %3, i64 18)
; # (neg (addu (pos A) ONE))
  %5 = icmp eq i64 %4, 2
  br i1 %5, label %$5, label %$6
$5:
  br label %$7
$6:
  %6 = xor i64 %4, 8
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%6, %$6] ; # ->
  br label %$4
$3:
; # (subu A ONE)
  %8 = call i64 @subu(i64 %0, i64 18)
  br label %$4
$4:
  %9 = phi i64 [%7, %$7], [%8, %$3] ; # ->
  ret i64 %9
}

define i64 @adds(i64, i64) {
$1:
; # (ifn (sign? A) (ifn (sign? B) (addu A B) (subu A (pos B))) (neg (...
; # (sign? A)
  %2 = and i64 %0, 8
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (ifn (sign? B) (addu A B) (subu A (pos B)))
; # (sign? B)
  %4 = and i64 %1, 8
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$6, label %$5
$5:
; # (addu A B)
  %6 = call i64 @addu(i64 %0, i64 %1)
  br label %$7
$6:
; # (pos B)
  %7 = and i64 %1, -9
; # (subu A (pos B))
  %8 = call i64 @subu(i64 %0, i64 %7)
  br label %$7
$7:
  %9 = phi i64 [%6, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (ifn (sign? B) (subu (pos A) B) (addu (pos A) (pos B)))
; # (sign? B)
  %10 = and i64 %1, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$9, label %$8
$8:
; # (pos A)
  %12 = and i64 %0, -9
; # (subu (pos A) B)
  %13 = call i64 @subu(i64 %12, i64 %1)
  br label %$10
$9:
; # (pos A)
  %14 = and i64 %0, -9
; # (pos B)
  %15 = and i64 %1, -9
; # (addu (pos A) (pos B))
  %16 = call i64 @addu(i64 %14, i64 %15)
  br label %$10
$10:
  %17 = phi i64 [%13, %$8], [%16, %$9] ; # ->
; # (neg (ifn (sign? B) (subu (pos A) B) (addu (pos A) (pos B))))
  %18 = icmp eq i64 %17, 2
  br i1 %18, label %$11, label %$12
$11:
  br label %$13
$12:
  %19 = xor i64 %17, 8
  br label %$13
$13:
  %20 = phi i64 [%17, %$11], [%19, %$12] ; # ->
  br label %$4
$4:
  %21 = phi i64 [%9, %$7], [%20, %$13] ; # ->
  ret i64 %21
}

define i64 @subs(i64, i64) {
$1:
; # (ifn (sign? A) (ifn (sign? B) (subu A B) (addu A (pos B))) (neg (...
; # (sign? A)
  %2 = and i64 %0, 8
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (ifn (sign? B) (subu A B) (addu A (pos B)))
; # (sign? B)
  %4 = and i64 %1, 8
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$6, label %$5
$5:
; # (subu A B)
  %6 = call i64 @subu(i64 %0, i64 %1)
  br label %$7
$6:
; # (pos B)
  %7 = and i64 %1, -9
; # (addu A (pos B))
  %8 = call i64 @addu(i64 %0, i64 %7)
  br label %$7
$7:
  %9 = phi i64 [%6, %$5], [%8, %$6] ; # ->
  br label %$4
$3:
; # (ifn (sign? B) (addu (pos A) B) (subu (pos A) (pos B)))
; # (sign? B)
  %10 = and i64 %1, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$9, label %$8
$8:
; # (pos A)
  %12 = and i64 %0, -9
; # (addu (pos A) B)
  %13 = call i64 @addu(i64 %12, i64 %1)
  br label %$10
$9:
; # (pos A)
  %14 = and i64 %0, -9
; # (pos B)
  %15 = and i64 %1, -9
; # (subu (pos A) (pos B))
  %16 = call i64 @subu(i64 %14, i64 %15)
  br label %$10
$10:
  %17 = phi i64 [%13, %$8], [%16, %$9] ; # ->
; # (neg (ifn (sign? B) (addu (pos A) B) (subu (pos A) (pos B))))
  %18 = icmp eq i64 %17, 2
  br i1 %18, label %$11, label %$12
$11:
  br label %$13
$12:
  %19 = xor i64 %17, 8
  br label %$13
$13:
  %20 = phi i64 [%17, %$11], [%19, %$12] ; # ->
  br label %$4
$4:
  %21 = phi i64 [%9, %$7], [%20, %$13] ; # ->
  ret i64 %21
}

define i64 @cmpu(i64, i64) {
$1:
; # (if (cnt? A) (cond ((or (big? B) (> B A)) -1) ((== B A) 0) (T 1))...
; # (cnt? A)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # A
  %5 = phi i64 [%1, %$1] ; # B
; # (cond ((or (big? B) (> B A)) -1) ((== B A) 0) (T 1))
; # (or (big? B) (> B A))
; # (big? B)
  %6 = and i64 %5, 4
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$7
$7:
  %8 = phi i64 [%4, %$2] ; # A
  %9 = phi i64 [%5, %$2] ; # B
; # (> B A)
  %10 = icmp ugt i64 %9, %8
  br label %$6
$6:
  %11 = phi i64 [%4, %$2], [%8, %$7] ; # A
  %12 = phi i64 [%5, %$2], [%9, %$7] ; # B
  %13 = phi i1 [1, %$2], [%10, %$7] ; # ->
  br i1 %13, label %$9, label %$8
$9:
  %14 = phi i64 [%11, %$6] ; # A
  %15 = phi i64 [%12, %$6] ; # B
  br label %$5
$8:
  %16 = phi i64 [%11, %$6] ; # A
  %17 = phi i64 [%12, %$6] ; # B
; # (== B A)
  %18 = icmp eq i64 %17, %16
  br i1 %18, label %$11, label %$10
$11:
  %19 = phi i64 [%16, %$8] ; # A
  %20 = phi i64 [%17, %$8] ; # B
  br label %$5
$10:
  %21 = phi i64 [%16, %$8] ; # A
  %22 = phi i64 [%17, %$8] ; # B
  br label %$5
$5:
  %23 = phi i64 [%14, %$9], [%19, %$11], [%21, %$10] ; # A
  %24 = phi i64 [%15, %$9], [%20, %$11], [%22, %$10] ; # B
  %25 = phi i64 [-1, %$9], [0, %$11], [1, %$10] ; # ->
  br label %$4
$3:
  %26 = phi i64 [%0, %$1] ; # A
  %27 = phi i64 [%1, %$1] ; # B
; # (if (cnt? B) 1 (let (X 0 Y 0) (prog1 (loop (let (C (val (big A)) ...
; # (cnt? B)
  %28 = and i64 %27, 2
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$13
$12:
  %30 = phi i64 [%26, %$3] ; # A
  %31 = phi i64 [%27, %$3] ; # B
  br label %$14
$13:
  %32 = phi i64 [%26, %$3] ; # A
  %33 = phi i64 [%27, %$3] ; # B
; # (let (X 0 Y 0) (prog1 (loop (let (C (val (big A)) D (val (big B))...
; # (prog1 (loop (let (C (val (big A)) D (val (big B))) (? (== C D) (...
; # (loop (let (C (val (big A)) D (val (big B))) (? (== C D) (loop (s...
  br label %$15
$15:
  %34 = phi i64 [%32, %$13], [%199, %$36] ; # A
  %35 = phi i64 [%33, %$13], [%200, %$36] ; # B
  %36 = phi i64 [0, %$13], [%195, %$36] ; # X
  %37 = phi i64 [0, %$13], [%196, %$36] ; # Y
; # (let (C (val (big A)) D (val (big B))) (? (== C D) (loop (setq C ...
; # (big A)
  %38 = add i64 %34, 4
; # (val (big A))
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (big B)
  %41 = add i64 %35, 4
; # (val (big B))
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
; # (? (== C D) (loop (setq C (val (dig A)) D (val (dig B))) (? (> D ...
; # (== C D)
  %44 = icmp eq i64 %40, %43
  br i1 %44, label %$18, label %$16
$18:
  %45 = phi i64 [%34, %$15] ; # A
  %46 = phi i64 [%35, %$15] ; # B
  %47 = phi i64 [%36, %$15] ; # X
  %48 = phi i64 [%37, %$15] ; # Y
  %49 = phi i64 [%40, %$15] ; # C
  %50 = phi i64 [%43, %$15] ; # D
; # (loop (setq C (val (dig A)) D (val (dig B))) (? (> D C) -1) (? (>...
  br label %$19
$19:
  %51 = phi i64 [%45, %$18], [%98, %$25] ; # A
  %52 = phi i64 [%46, %$18], [%99, %$25] ; # B
  %53 = phi i64 [%47, %$18], [%104, %$25] ; # X
  %54 = phi i64 [%48, %$18], [%109, %$25] ; # Y
  %55 = phi i64 [%49, %$18], [%100, %$25] ; # C
  %56 = phi i64 [%50, %$18], [%101, %$25] ; # D
; # (dig A)
  %57 = add i64 %51, -4
; # (val (dig A))
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (dig B)
  %60 = add i64 %52, -4
; # (val (dig B))
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (? (> D C) -1)
; # (> D C)
  %63 = icmp ugt i64 %62, %59
  br i1 %63, label %$22, label %$20
$22:
  %64 = phi i64 [%51, %$19] ; # A
  %65 = phi i64 [%52, %$19] ; # B
  %66 = phi i64 [%53, %$19] ; # X
  %67 = phi i64 [%54, %$19] ; # Y
  %68 = phi i64 [%59, %$19] ; # C
  %69 = phi i64 [%62, %$19] ; # D
  br label %$21
$20:
  %70 = phi i64 [%51, %$19] ; # A
  %71 = phi i64 [%52, %$19] ; # B
  %72 = phi i64 [%53, %$19] ; # X
  %73 = phi i64 [%54, %$19] ; # Y
  %74 = phi i64 [%59, %$19] ; # C
  %75 = phi i64 [%62, %$19] ; # D
; # (? (> C D) 1)
; # (> C D)
  %76 = icmp ugt i64 %74, %75
  br i1 %76, label %$24, label %$23
$24:
  %77 = phi i64 [%70, %$20] ; # A
  %78 = phi i64 [%71, %$20] ; # B
  %79 = phi i64 [%72, %$20] ; # X
  %80 = phi i64 [%73, %$20] ; # Y
  %81 = phi i64 [%74, %$20] ; # C
  %82 = phi i64 [%75, %$20] ; # D
  br label %$21
$23:
  %83 = phi i64 [%70, %$20] ; # A
  %84 = phi i64 [%71, %$20] ; # B
  %85 = phi i64 [%72, %$20] ; # X
  %86 = phi i64 [%73, %$20] ; # Y
  %87 = phi i64 [%74, %$20] ; # C
  %88 = phi i64 [%75, %$20] ; # D
; # (? (=0 X) 0)
; # (=0 X)
  %89 = icmp eq i64 %85, 0
  br i1 %89, label %$26, label %$25
$26:
  %90 = phi i64 [%83, %$23] ; # A
  %91 = phi i64 [%84, %$23] ; # B
  %92 = phi i64 [%85, %$23] ; # X
  %93 = phi i64 [%86, %$23] ; # Y
  %94 = phi i64 [%87, %$23] ; # C
  %95 = phi i64 [%88, %$23] ; # D
  br label %$21
$25:
  %96 = phi i64 [%83, %$23] ; # A
  %97 = phi i64 [%84, %$23] ; # B
  %98 = phi i64 [%85, %$23] ; # X
  %99 = phi i64 [%86, %$23] ; # Y
  %100 = phi i64 [%87, %$23] ; # C
  %101 = phi i64 [%88, %$23] ; # D
; # (let Z (val (big X)) (set (big X) A) (setq A X X Z))
; # (big X)
  %102 = add i64 %98, 4
; # (val (big X))
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
; # (set (big X) A)
; # (big X)
  %105 = add i64 %98, 4
  %106 = inttoptr i64 %105 to i64*
  store i64 %96, i64* %106
; # (let Z (val (big Y)) (set (big Y) B) (setq B Y Y Z))
; # (big Y)
  %107 = add i64 %99, 4
; # (val (big Y))
  %108 = inttoptr i64 %107 to i64*
  %109 = load i64, i64* %108
; # (set (big Y) B)
; # (big Y)
  %110 = add i64 %99, 4
  %111 = inttoptr i64 %110 to i64*
  store i64 %97, i64* %111
  br label %$19
$21:
  %112 = phi i64 [%64, %$22], [%77, %$24], [%90, %$26] ; # A
  %113 = phi i64 [%65, %$22], [%78, %$24], [%91, %$26] ; # B
  %114 = phi i64 [%66, %$22], [%79, %$24], [%92, %$26] ; # X
  %115 = phi i64 [%67, %$22], [%80, %$24], [%93, %$26] ; # Y
  %116 = phi i64 [%68, %$22], [%81, %$24], [%94, %$26] ; # C
  %117 = phi i64 [%69, %$22], [%82, %$24], [%95, %$26] ; # D
  %118 = phi i64 [-1, %$22], [1, %$24], [0, %$26] ; # ->
  br label %$17
$16:
  %119 = phi i64 [%34, %$15] ; # A
  %120 = phi i64 [%35, %$15] ; # B
  %121 = phi i64 [%36, %$15] ; # X
  %122 = phi i64 [%37, %$15] ; # Y
  %123 = phi i64 [%40, %$15] ; # C
  %124 = phi i64 [%43, %$15] ; # D
; # (? (cnt? C) (cond ((or (big? D) (> D C)) -1) ((== D C) 0) (T 1)))...
; # (cnt? C)
  %125 = and i64 %123, 2
  %126 = icmp ne i64 %125, 0
  br i1 %126, label %$28, label %$27
$28:
  %127 = phi i64 [%119, %$16] ; # A
  %128 = phi i64 [%120, %$16] ; # B
  %129 = phi i64 [%121, %$16] ; # X
  %130 = phi i64 [%122, %$16] ; # Y
  %131 = phi i64 [%123, %$16] ; # C
  %132 = phi i64 [%124, %$16] ; # D
; # (cond ((or (big? D) (> D C)) -1) ((== D C) 0) (T 1))
; # (or (big? D) (> D C))
; # (big? D)
  %133 = and i64 %132, 4
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$30, label %$31
$31:
  %135 = phi i64 [%127, %$28] ; # A
  %136 = phi i64 [%128, %$28] ; # B
  %137 = phi i64 [%129, %$28] ; # X
  %138 = phi i64 [%130, %$28] ; # Y
  %139 = phi i64 [%131, %$28] ; # C
  %140 = phi i64 [%132, %$28] ; # D
; # (> D C)
  %141 = icmp ugt i64 %140, %139
  br label %$30
$30:
  %142 = phi i64 [%127, %$28], [%135, %$31] ; # A
  %143 = phi i64 [%128, %$28], [%136, %$31] ; # B
  %144 = phi i64 [%129, %$28], [%137, %$31] ; # X
  %145 = phi i64 [%130, %$28], [%138, %$31] ; # Y
  %146 = phi i64 [%131, %$28], [%139, %$31] ; # C
  %147 = phi i64 [%132, %$28], [%140, %$31] ; # D
  %148 = phi i1 [1, %$28], [%141, %$31] ; # ->
  br i1 %148, label %$33, label %$32
$33:
  %149 = phi i64 [%142, %$30] ; # A
  %150 = phi i64 [%143, %$30] ; # B
  %151 = phi i64 [%144, %$30] ; # X
  %152 = phi i64 [%145, %$30] ; # Y
  %153 = phi i64 [%146, %$30] ; # C
  %154 = phi i64 [%147, %$30] ; # D
  br label %$29
$32:
  %155 = phi i64 [%142, %$30] ; # A
  %156 = phi i64 [%143, %$30] ; # B
  %157 = phi i64 [%144, %$30] ; # X
  %158 = phi i64 [%145, %$30] ; # Y
  %159 = phi i64 [%146, %$30] ; # C
  %160 = phi i64 [%147, %$30] ; # D
; # (== D C)
  %161 = icmp eq i64 %160, %159
  br i1 %161, label %$35, label %$34
$35:
  %162 = phi i64 [%155, %$32] ; # A
  %163 = phi i64 [%156, %$32] ; # B
  %164 = phi i64 [%157, %$32] ; # X
  %165 = phi i64 [%158, %$32] ; # Y
  %166 = phi i64 [%159, %$32] ; # C
  %167 = phi i64 [%160, %$32] ; # D
  br label %$29
$34:
  %168 = phi i64 [%155, %$32] ; # A
  %169 = phi i64 [%156, %$32] ; # B
  %170 = phi i64 [%157, %$32] ; # X
  %171 = phi i64 [%158, %$32] ; # Y
  %172 = phi i64 [%159, %$32] ; # C
  %173 = phi i64 [%160, %$32] ; # D
  br label %$29
$29:
  %174 = phi i64 [%149, %$33], [%162, %$35], [%168, %$34] ; # A
  %175 = phi i64 [%150, %$33], [%163, %$35], [%169, %$34] ; # B
  %176 = phi i64 [%151, %$33], [%164, %$35], [%170, %$34] ; # X
  %177 = phi i64 [%152, %$33], [%165, %$35], [%171, %$34] ; # Y
  %178 = phi i64 [%153, %$33], [%166, %$35], [%172, %$34] ; # C
  %179 = phi i64 [%154, %$33], [%167, %$35], [%173, %$34] ; # D
  %180 = phi i64 [-1, %$33], [0, %$35], [1, %$34] ; # ->
  br label %$17
$27:
  %181 = phi i64 [%119, %$16] ; # A
  %182 = phi i64 [%120, %$16] ; # B
  %183 = phi i64 [%121, %$16] ; # X
  %184 = phi i64 [%122, %$16] ; # Y
  %185 = phi i64 [%123, %$16] ; # C
  %186 = phi i64 [%124, %$16] ; # D
; # (? (cnt? D) 1)
; # (cnt? D)
  %187 = and i64 %186, 2
  %188 = icmp ne i64 %187, 0
  br i1 %188, label %$37, label %$36
$37:
  %189 = phi i64 [%181, %$27] ; # A
  %190 = phi i64 [%182, %$27] ; # B
  %191 = phi i64 [%183, %$27] ; # X
  %192 = phi i64 [%184, %$27] ; # Y
  %193 = phi i64 [%185, %$27] ; # C
  %194 = phi i64 [%186, %$27] ; # D
  br label %$17
$36:
  %195 = phi i64 [%181, %$27] ; # A
  %196 = phi i64 [%182, %$27] ; # B
  %197 = phi i64 [%183, %$27] ; # X
  %198 = phi i64 [%184, %$27] ; # Y
  %199 = phi i64 [%185, %$27] ; # C
  %200 = phi i64 [%186, %$27] ; # D
; # (set (big A) X)
; # (big A)
  %201 = add i64 %195, 4
  %202 = inttoptr i64 %201 to i64*
  store i64 %197, i64* %202
; # (set (big B) Y)
; # (big B)
  %203 = add i64 %196, 4
  %204 = inttoptr i64 %203 to i64*
  store i64 %198, i64* %204
  br label %$15
$17:
  %205 = phi i64 [%112, %$21], [%174, %$29], [%189, %$37] ; # A
  %206 = phi i64 [%113, %$21], [%175, %$29], [%190, %$37] ; # B
  %207 = phi i64 [%114, %$21], [%176, %$29], [%191, %$37] ; # X
  %208 = phi i64 [%115, %$21], [%177, %$29], [%192, %$37] ; # Y
  %209 = phi i64 [%118, %$21], [%180, %$29], [1, %$37] ; # ->
; # (while X (let Z (val (big X)) (set (big X) A) (setq A X X Z)) (le...
  br label %$38
$38:
  %210 = phi i64 [%205, %$17], [%217, %$39] ; # A
  %211 = phi i64 [%206, %$17], [%218, %$39] ; # B
  %212 = phi i64 [%207, %$17], [%221, %$39] ; # X
  %213 = phi i64 [%208, %$17], [%226, %$39] ; # Y
  %214 = icmp ne i64 %212, 0
  br i1 %214, label %$39, label %$40
$39:
  %215 = phi i64 [%210, %$38] ; # A
  %216 = phi i64 [%211, %$38] ; # B
  %217 = phi i64 [%212, %$38] ; # X
  %218 = phi i64 [%213, %$38] ; # Y
; # (let Z (val (big X)) (set (big X) A) (setq A X X Z))
; # (big X)
  %219 = add i64 %217, 4
; # (val (big X))
  %220 = inttoptr i64 %219 to i64*
  %221 = load i64, i64* %220
; # (set (big X) A)
; # (big X)
  %222 = add i64 %217, 4
  %223 = inttoptr i64 %222 to i64*
  store i64 %215, i64* %223
; # (let Z (val (big Y)) (set (big Y) B) (setq B Y Y Z))
; # (big Y)
  %224 = add i64 %218, 4
; # (val (big Y))
  %225 = inttoptr i64 %224 to i64*
  %226 = load i64, i64* %225
; # (set (big Y) B)
; # (big Y)
  %227 = add i64 %218, 4
  %228 = inttoptr i64 %227 to i64*
  store i64 %216, i64* %228
  br label %$38
$40:
  %229 = phi i64 [%210, %$38] ; # A
  %230 = phi i64 [%211, %$38] ; # B
  %231 = phi i64 [%212, %$38] ; # X
  %232 = phi i64 [%213, %$38] ; # Y
  br label %$14
$14:
  %233 = phi i64 [%30, %$12], [%229, %$40] ; # A
  %234 = phi i64 [%31, %$12], [%230, %$40] ; # B
  %235 = phi i64 [1, %$12], [%209, %$40] ; # ->
  br label %$4
$4:
  %236 = phi i64 [%23, %$5], [%233, %$14] ; # A
  %237 = phi i64 [%24, %$5], [%234, %$14] ; # B
  %238 = phi i64 [%25, %$5], [%235, %$14] ; # ->
  ret i64 %238
}

define i64 @cmpNum(i64, i64) {
$1:
; # (ifn (sign? A) (ifn (sign? B) (cmpu A B) 1) (ifn (sign? B) -1 (cm...
; # (sign? A)
  %2 = and i64 %0, 8
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (ifn (sign? B) (cmpu A B) 1)
; # (sign? B)
  %4 = and i64 %1, 8
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$6, label %$5
$5:
; # (cmpu A B)
  %6 = call i64 @cmpu(i64 %0, i64 %1)
  br label %$7
$6:
  br label %$7
$7:
  %7 = phi i64 [%6, %$5], [1, %$6] ; # ->
  br label %$4
$3:
; # (ifn (sign? B) -1 (cmpu (pos B) (pos A)))
; # (sign? B)
  %8 = and i64 %1, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$9, label %$8
$8:
  br label %$10
$9:
; # (pos B)
  %10 = and i64 %1, -9
; # (pos A)
  %11 = and i64 %0, -9
; # (cmpu (pos B) (pos A))
  %12 = call i64 @cmpu(i64 %10, i64 %11)
  br label %$10
$10:
  %13 = phi i64 [-1, %$8], [%12, %$9] ; # ->
  br label %$4
$4:
  %14 = phi i64 [%7, %$7], [%13, %$10] ; # ->
  ret i64 %14
}

define i64 @symToNum(i64, i64, i8, i8) {
$1:
; # (let (P (push 0 Name) Num (push ZERO NIL) Sign NO Frac NO B T) (u...
; # (push 0 Name)
  %4 = alloca i64, i64 2, align 16
  store i64 0, i64* %4
  %5 = getelementptr i64, i64* %4, i32 1
  store i64 %0, i64* %5
; # (push ZERO NIL)
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 2, i64* %8
; # (until (> (setq B (symByte P)) (char " ")) (unless B (ret 0)))
  br label %$2
$2:
  %9 = phi i64 [%1, %$1], [%26, %$6] ; # Scl
  %10 = phi i64 [%7, %$1], [%27, %$6] ; # Num
  %11 = phi i1 [0, %$1], [%28, %$6] ; # Sign
  %12 = phi i1 [0, %$1], [%29, %$6] ; # Frac
; # (symByte P)
  %13 = call i8 @symByte(i64* %4)
; # (> (setq B (symByte P)) (char " "))
  %14 = icmp ugt i8 %13, 32
  br i1 %14, label %$4, label %$3
$3:
  %15 = phi i64 [%9, %$2] ; # Scl
  %16 = phi i64 [%10, %$2] ; # Num
  %17 = phi i1 [%11, %$2] ; # Sign
  %18 = phi i1 [%12, %$2] ; # Frac
  %19 = phi i8 [%13, %$2] ; # B
; # (unless B (ret 0))
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %$6, label %$5
$5:
  %21 = phi i64 [%15, %$3] ; # Scl
  %22 = phi i64 [%16, %$3] ; # Num
  %23 = phi i1 [%17, %$3] ; # Sign
  %24 = phi i1 [%18, %$3] ; # Frac
  %25 = phi i8 [%19, %$3] ; # B
; # (ret 0)
  ret i64 0
$6:
  %26 = phi i64 [%15, %$3] ; # Scl
  %27 = phi i64 [%16, %$3] ; # Num
  %28 = phi i1 [%17, %$3] ; # Sign
  %29 = phi i1 [%18, %$3] ; # Frac
  %30 = phi i8 [%19, %$3] ; # B
  br label %$2
$4:
  %31 = phi i64 [%9, %$2] ; # Scl
  %32 = phi i64 [%10, %$2] ; # Num
  %33 = phi i1 [%11, %$2] ; # Sign
  %34 = phi i1 [%12, %$2] ; # Frac
  %35 = phi i8 [%13, %$2] ; # B
; # (cond ((== B (char "+")) (goto 1)) ((== B (char "-")) (setq Sign ...
; # (== B (char "+"))
  %36 = icmp eq i8 %35, 43
  br i1 %36, label %$9, label %$8
$9:
  %37 = phi i64 [%31, %$4] ; # Scl
  %38 = phi i64 [%32, %$4] ; # Num
  %39 = phi i1 [%33, %$4] ; # Sign
  %40 = phi i1 [%34, %$4] ; # Frac
  %41 = phi i8 [%35, %$4] ; # B
; # (goto 1)
  br label %$-1
$8:
  %42 = phi i64 [%31, %$4] ; # Scl
  %43 = phi i64 [%32, %$4] ; # Num
  %44 = phi i1 [%33, %$4] ; # Sign
  %45 = phi i1 [%34, %$4] ; # Frac
  %46 = phi i8 [%35, %$4] ; # B
; # (== B (char "-"))
  %47 = icmp eq i8 %46, 45
  br i1 %47, label %$11, label %$10
$11:
  %48 = phi i64 [%42, %$8] ; # Scl
  %49 = phi i64 [%43, %$8] ; # Num
  %50 = phi i1 [%44, %$8] ; # Sign
  %51 = phi i1 [%45, %$8] ; # Frac
  %52 = phi i8 [%46, %$8] ; # B
; # (: 1 (unless (setq B (symByte P)) (ret 0)))
  br label %$-1
$-1:
  %53 = phi i64 [%37, %$9], [%48, %$11] ; # Scl
  %54 = phi i64 [%38, %$9], [%49, %$11] ; # Num
  %55 = phi i1 [%39, %$9], [1, %$11] ; # Sign
  %56 = phi i1 [%40, %$9], [%51, %$11] ; # Frac
  %57 = phi i8 [%41, %$9], [%52, %$11] ; # B
; # (unless (setq B (symByte P)) (ret 0))
; # (symByte P)
  %58 = call i8 @symByte(i64* %4)
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %$13, label %$12
$12:
  %60 = phi i64 [%53, %$-1] ; # Scl
  %61 = phi i64 [%54, %$-1] ; # Num
  %62 = phi i1 [%55, %$-1] ; # Sign
  %63 = phi i1 [%56, %$-1] ; # Frac
  %64 = phi i8 [%58, %$-1] ; # B
; # (ret 0)
  ret i64 0
$13:
  %65 = phi i64 [%53, %$-1] ; # Scl
  %66 = phi i64 [%54, %$-1] ; # Num
  %67 = phi i1 [%55, %$-1] ; # Sign
  %68 = phi i1 [%56, %$-1] ; # Frac
  %69 = phi i8 [%58, %$-1] ; # B
  br label %$7
$10:
  %70 = phi i64 [%42, %$8] ; # Scl
  %71 = phi i64 [%43, %$8] ; # Num
  %72 = phi i1 [%44, %$8] ; # Sign
  %73 = phi i1 [%45, %$8] ; # Frac
  %74 = phi i8 [%46, %$8] ; # B
  br label %$7
$7:
  %75 = phi i64 [%65, %$13], [%70, %$10] ; # Scl
  %76 = phi i64 [%66, %$13], [%71, %$10] ; # Num
  %77 = phi i1 [%67, %$13], [%72, %$10] ; # Sign
  %78 = phi i1 [%68, %$13], [%73, %$10] ; # Frac
  %79 = phi i8 [%69, %$13], [%74, %$10] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %80 = sub i8 %79, 48
; # (> (dec 'B (char "0")) 9)
  %81 = icmp ugt i8 %80, 9
  br i1 %81, label %$14, label %$15
$14:
  %82 = phi i64 [%75, %$7] ; # Scl
  %83 = phi i64 [%76, %$7] ; # Num
  %84 = phi i1 [%77, %$7] ; # Sign
  %85 = phi i1 [%78, %$7] ; # Frac
  %86 = phi i8 [%80, %$7] ; # B
; # (ret 0)
  ret i64 0
$15:
  %87 = phi i64 [%75, %$7] ; # Scl
  %88 = phi i64 [%76, %$7] ; # Num
  %89 = phi i1 [%77, %$7] ; # Sign
  %90 = phi i1 [%78, %$7] ; # Frac
  %91 = phi i8 [%80, %$7] ; # B
; # (set (link Num T) (cnt (i64 B)))
; # (link Num T)
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %88 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %88, i64* %96
; # (i64 B)
  %97 = zext i8 %91 to i64
; # (cnt (i64 B))
  %98 = shl i64 %97, 4
  %99 = or i64 %98, 2
  %100 = inttoptr i64 %88 to i64*
  store i64 %99, i64* %100
; # (while (setq B (symByte P)) (? (and Frac (=0 Scl)) (when (> (dec ...
  br label %$16
$16:
  %101 = phi i64 [%87, %$15], [%270, %$32] ; # Scl
  %102 = phi i64 [%88, %$15], [%271, %$32] ; # Num
  %103 = phi i1 [%89, %$15], [%272, %$32] ; # Sign
  %104 = phi i1 [%90, %$15], [%273, %$32] ; # Frac
  %105 = phi i8 [%91, %$15], [%274, %$32] ; # B
; # (symByte P)
  %106 = call i8 @symByte(i64* %4)
  %107 = icmp ne i8 %106, 0
  br i1 %107, label %$17, label %$18
$17:
  %108 = phi i64 [%101, %$16] ; # Scl
  %109 = phi i64 [%102, %$16] ; # Num
  %110 = phi i1 [%103, %$16] ; # Sign
  %111 = phi i1 [%104, %$16] ; # Frac
  %112 = phi i8 [%106, %$16] ; # B
; # (? (and Frac (=0 Scl)) (when (> (dec 'B (char "0")) 9) (ret 0)) (...
; # (and Frac (=0 Scl))
  br i1 %111, label %$20, label %$19
$20:
  %113 = phi i64 [%108, %$17] ; # Scl
  %114 = phi i64 [%109, %$17] ; # Num
  %115 = phi i1 [%110, %$17] ; # Sign
  %116 = phi i1 [%111, %$17] ; # Frac
  %117 = phi i8 [%112, %$17] ; # B
; # (=0 Scl)
  %118 = icmp eq i64 %113, 0
  br label %$19
$19:
  %119 = phi i64 [%108, %$17], [%113, %$20] ; # Scl
  %120 = phi i64 [%109, %$17], [%114, %$20] ; # Num
  %121 = phi i1 [%110, %$17], [%115, %$20] ; # Sign
  %122 = phi i1 [%111, %$17], [%116, %$20] ; # Frac
  %123 = phi i8 [%112, %$17], [%117, %$20] ; # B
  %124 = phi i1 [0, %$17], [%118, %$20] ; # ->
  br i1 %124, label %$22, label %$21
$22:
  %125 = phi i64 [%119, %$19] ; # Scl
  %126 = phi i64 [%120, %$19] ; # Num
  %127 = phi i1 [%121, %$19] ; # Sign
  %128 = phi i1 [%122, %$19] ; # Frac
  %129 = phi i8 [%123, %$19] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %130 = sub i8 %129, 48
; # (> (dec 'B (char "0")) 9)
  %131 = icmp ugt i8 %130, 9
  br i1 %131, label %$23, label %$24
$23:
  %132 = phi i64 [%125, %$22] ; # Scl
  %133 = phi i64 [%126, %$22] ; # Num
  %134 = phi i1 [%127, %$22] ; # Sign
  %135 = phi i1 [%128, %$22] ; # Frac
  %136 = phi i8 [%130, %$22] ; # B
; # (ret 0)
; # (drop *Safe)
  %137 = inttoptr i64 %88 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %139, i64* %140
  ret i64 0
$24:
  %141 = phi i64 [%125, %$22] ; # Scl
  %142 = phi i64 [%126, %$22] ; # Num
  %143 = phi i1 [%127, %$22] ; # Sign
  %144 = phi i1 [%128, %$22] ; # Frac
  %145 = phi i8 [%130, %$22] ; # B
; # (when (>= B 5) (set Num (addu (val Num) ONE)))
; # (>= B 5)
  %146 = icmp uge i8 %145, 5
  br i1 %146, label %$25, label %$26
$25:
  %147 = phi i64 [%141, %$24] ; # Scl
  %148 = phi i64 [%142, %$24] ; # Num
  %149 = phi i1 [%143, %$24] ; # Sign
  %150 = phi i1 [%144, %$24] ; # Frac
  %151 = phi i8 [%145, %$24] ; # B
; # (set Num (addu (val Num) ONE))
; # (val Num)
  %152 = inttoptr i64 %148 to i64*
  %153 = load i64, i64* %152
; # (addu (val Num) ONE)
  %154 = call i64 @addu(i64 %153, i64 18)
  %155 = inttoptr i64 %148 to i64*
  store i64 %154, i64* %155
  br label %$26
$26:
  %156 = phi i64 [%141, %$24], [%147, %$25] ; # Scl
  %157 = phi i64 [%142, %$24], [%148, %$25] ; # Num
  %158 = phi i1 [%143, %$24], [%149, %$25] ; # Sign
  %159 = phi i1 [%144, %$24], [%150, %$25] ; # Frac
  %160 = phi i8 [%145, %$24], [%151, %$25] ; # B
; # (while (setq B (symByte P)) (when (> (dec 'B (char "0")) 9) (ret ...
  br label %$27
$27:
  %161 = phi i64 [%156, %$26], [%184, %$31] ; # Scl
  %162 = phi i64 [%157, %$26], [%185, %$31] ; # Num
  %163 = phi i1 [%158, %$26], [%186, %$31] ; # Sign
  %164 = phi i1 [%159, %$26], [%187, %$31] ; # Frac
  %165 = phi i8 [%160, %$26], [%188, %$31] ; # B
; # (symByte P)
  %166 = call i8 @symByte(i64* %4)
  %167 = icmp ne i8 %166, 0
  br i1 %167, label %$28, label %$29
$28:
  %168 = phi i64 [%161, %$27] ; # Scl
  %169 = phi i64 [%162, %$27] ; # Num
  %170 = phi i1 [%163, %$27] ; # Sign
  %171 = phi i1 [%164, %$27] ; # Frac
  %172 = phi i8 [%166, %$27] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %173 = sub i8 %172, 48
; # (> (dec 'B (char "0")) 9)
  %174 = icmp ugt i8 %173, 9
  br i1 %174, label %$30, label %$31
$30:
  %175 = phi i64 [%168, %$28] ; # Scl
  %176 = phi i64 [%169, %$28] ; # Num
  %177 = phi i1 [%170, %$28] ; # Sign
  %178 = phi i1 [%171, %$28] ; # Frac
  %179 = phi i8 [%173, %$28] ; # B
; # (ret 0)
; # (drop *Safe)
  %180 = inttoptr i64 %88 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %182, i64* %183
  ret i64 0
$31:
  %184 = phi i64 [%168, %$28] ; # Scl
  %185 = phi i64 [%169, %$28] ; # Num
  %186 = phi i1 [%170, %$28] ; # Sign
  %187 = phi i1 [%171, %$28] ; # Frac
  %188 = phi i8 [%173, %$28] ; # B
  br label %$27
$29:
  %189 = phi i64 [%161, %$27] ; # Scl
  %190 = phi i64 [%162, %$27] ; # Num
  %191 = phi i1 [%163, %$27] ; # Sign
  %192 = phi i1 [%164, %$27] ; # Frac
  %193 = phi i8 [%166, %$27] ; # B
  br label %$18
$21:
  %194 = phi i64 [%119, %$19] ; # Scl
  %195 = phi i64 [%120, %$19] ; # Num
  %196 = phi i1 [%121, %$19] ; # Sign
  %197 = phi i1 [%122, %$19] ; # Frac
  %198 = phi i8 [%123, %$19] ; # B
; # (cond ((== B Sep) (when Frac (ret 0)) (setq Frac YES)) ((<> B Ign...
; # (== B Sep)
  %199 = icmp eq i8 %198, %2
  br i1 %199, label %$34, label %$33
$34:
  %200 = phi i64 [%194, %$21] ; # Scl
  %201 = phi i64 [%195, %$21] ; # Num
  %202 = phi i1 [%196, %$21] ; # Sign
  %203 = phi i1 [%197, %$21] ; # Frac
  %204 = phi i8 [%198, %$21] ; # B
; # (when Frac (ret 0))
  br i1 %203, label %$35, label %$36
$35:
  %205 = phi i64 [%200, %$34] ; # Scl
  %206 = phi i64 [%201, %$34] ; # Num
  %207 = phi i1 [%202, %$34] ; # Sign
  %208 = phi i1 [%203, %$34] ; # Frac
  %209 = phi i8 [%204, %$34] ; # B
; # (ret 0)
; # (drop *Safe)
  %210 = inttoptr i64 %88 to i64*
  %211 = getelementptr i64, i64* %210, i32 1
  %212 = load i64, i64* %211
  %213 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %212, i64* %213
  ret i64 0
$36:
  %214 = phi i64 [%200, %$34] ; # Scl
  %215 = phi i64 [%201, %$34] ; # Num
  %216 = phi i1 [%202, %$34] ; # Sign
  %217 = phi i1 [%203, %$34] ; # Frac
  %218 = phi i8 [%204, %$34] ; # B
  br label %$32
$33:
  %219 = phi i64 [%194, %$21] ; # Scl
  %220 = phi i64 [%195, %$21] ; # Num
  %221 = phi i1 [%196, %$21] ; # Sign
  %222 = phi i1 [%197, %$21] ; # Frac
  %223 = phi i8 [%198, %$21] ; # B
; # (<> B Ign)
  %224 = icmp ne i8 %223, %3
  br i1 %224, label %$38, label %$37
$38:
  %225 = phi i64 [%219, %$33] ; # Scl
  %226 = phi i64 [%220, %$33] ; # Num
  %227 = phi i1 [%221, %$33] ; # Sign
  %228 = phi i1 [%222, %$33] ; # Frac
  %229 = phi i8 [%223, %$33] ; # B
; # (when (> (dec 'B (char "0")) 9) (ret 0))
; # (dec 'B (char "0"))
  %230 = sub i8 %229, 48
; # (> (dec 'B (char "0")) 9)
  %231 = icmp ugt i8 %230, 9
  br i1 %231, label %$39, label %$40
$39:
  %232 = phi i64 [%225, %$38] ; # Scl
  %233 = phi i64 [%226, %$38] ; # Num
  %234 = phi i1 [%227, %$38] ; # Sign
  %235 = phi i1 [%228, %$38] ; # Frac
  %236 = phi i8 [%230, %$38] ; # B
; # (ret 0)
; # (drop *Safe)
  %237 = inttoptr i64 %88 to i64*
  %238 = getelementptr i64, i64* %237, i32 1
  %239 = load i64, i64* %238
  %240 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %239, i64* %240
  ret i64 0
$40:
  %241 = phi i64 [%225, %$38] ; # Scl
  %242 = phi i64 [%226, %$38] ; # Num
  %243 = phi i1 [%227, %$38] ; # Sign
  %244 = phi i1 [%228, %$38] ; # Frac
  %245 = phi i8 [%230, %$38] ; # B
; # (set Num (addu (tenfold (val Num)) (cnt (i64 B))))
; # (val Num)
  %246 = inttoptr i64 %242 to i64*
  %247 = load i64, i64* %246
; # (tenfold (val Num))
  %248 = call i64 @tenfold(i64 %247)
; # (i64 B)
  %249 = zext i8 %245 to i64
; # (cnt (i64 B))
  %250 = shl i64 %249, 4
  %251 = or i64 %250, 2
; # (addu (tenfold (val Num)) (cnt (i64 B)))
  %252 = call i64 @addu(i64 %248, i64 %251)
  %253 = inttoptr i64 %242 to i64*
  store i64 %252, i64* %253
; # (when Frac (dec 'Scl))
  br i1 %244, label %$41, label %$42
$41:
  %254 = phi i64 [%241, %$40] ; # Scl
  %255 = phi i64 [%242, %$40] ; # Num
  %256 = phi i1 [%243, %$40] ; # Sign
  %257 = phi i1 [%244, %$40] ; # Frac
  %258 = phi i8 [%245, %$40] ; # B
; # (dec 'Scl)
  %259 = sub i64 %254, 1
  br label %$42
$42:
  %260 = phi i64 [%241, %$40], [%259, %$41] ; # Scl
  %261 = phi i64 [%242, %$40], [%255, %$41] ; # Num
  %262 = phi i1 [%243, %$40], [%256, %$41] ; # Sign
  %263 = phi i1 [%244, %$40], [%257, %$41] ; # Frac
  %264 = phi i8 [%245, %$40], [%258, %$41] ; # B
  br label %$32
$37:
  %265 = phi i64 [%219, %$33] ; # Scl
  %266 = phi i64 [%220, %$33] ; # Num
  %267 = phi i1 [%221, %$33] ; # Sign
  %268 = phi i1 [%222, %$33] ; # Frac
  %269 = phi i8 [%223, %$33] ; # B
  br label %$32
$32:
  %270 = phi i64 [%214, %$36], [%260, %$42], [%265, %$37] ; # Scl
  %271 = phi i64 [%215, %$36], [%261, %$42], [%266, %$37] ; # Num
  %272 = phi i1 [%216, %$36], [%262, %$42], [%267, %$37] ; # Sign
  %273 = phi i1 [1, %$36], [%263, %$42], [%268, %$37] ; # Frac
  %274 = phi i8 [%218, %$36], [%264, %$42], [%269, %$37] ; # B
  br label %$16
$18:
  %275 = phi i64 [%101, %$16], [%189, %$29] ; # Scl
  %276 = phi i64 [%102, %$16], [%190, %$29] ; # Num
  %277 = phi i1 [%103, %$16], [%191, %$29] ; # Sign
  %278 = phi i1 [%104, %$16], [%192, %$29] ; # Frac
  %279 = phi i8 [%106, %$16], [%193, %$29] ; # B
; # (when Frac (while (ge0 (dec 'Scl)) (set Num (tenfold (val Num))))...
  br i1 %278, label %$43, label %$44
$43:
  %280 = phi i64 [%275, %$18] ; # Scl
  %281 = phi i64 [%276, %$18] ; # Num
  %282 = phi i1 [%277, %$18] ; # Sign
  %283 = phi i1 [%278, %$18] ; # Frac
  %284 = phi i8 [%279, %$18] ; # B
; # (while (ge0 (dec 'Scl)) (set Num (tenfold (val Num))))
  br label %$45
$45:
  %285 = phi i64 [%280, %$43], [%292, %$46] ; # Scl
  %286 = phi i64 [%281, %$43], [%293, %$46] ; # Num
  %287 = phi i1 [%282, %$43], [%294, %$46] ; # Sign
  %288 = phi i1 [%283, %$43], [%295, %$46] ; # Frac
  %289 = phi i8 [%284, %$43], [%296, %$46] ; # B
; # (dec 'Scl)
  %290 = sub i64 %285, 1
; # (ge0 (dec 'Scl))
  %291 = icmp sge i64 %290, 0
  br i1 %291, label %$46, label %$47
$46:
  %292 = phi i64 [%290, %$45] ; # Scl
  %293 = phi i64 [%286, %$45] ; # Num
  %294 = phi i1 [%287, %$45] ; # Sign
  %295 = phi i1 [%288, %$45] ; # Frac
  %296 = phi i8 [%289, %$45] ; # B
; # (set Num (tenfold (val Num)))
; # (val Num)
  %297 = inttoptr i64 %293 to i64*
  %298 = load i64, i64* %297
; # (tenfold (val Num))
  %299 = call i64 @tenfold(i64 %298)
  %300 = inttoptr i64 %293 to i64*
  store i64 %299, i64* %300
  br label %$45
$47:
  %301 = phi i64 [%290, %$45] ; # Scl
  %302 = phi i64 [%286, %$45] ; # Num
  %303 = phi i1 [%287, %$45] ; # Sign
  %304 = phi i1 [%288, %$45] ; # Frac
  %305 = phi i8 [%289, %$45] ; # B
  br label %$44
$44:
  %306 = phi i64 [%275, %$18], [%301, %$47] ; # Scl
  %307 = phi i64 [%276, %$18], [%302, %$47] ; # Num
  %308 = phi i1 [%277, %$18], [%303, %$47] ; # Sign
  %309 = phi i1 [%278, %$18], [%304, %$47] ; # Frac
  %310 = phi i8 [%279, %$18], [%305, %$47] ; # B
; # (val Num)
  %311 = inttoptr i64 %307 to i64*
  %312 = load i64, i64* %311
; # (if Sign (neg Num) Num)
  br i1 %308, label %$48, label %$49
$48:
  %313 = phi i64 [%306, %$44] ; # Scl
  %314 = phi i64 [%312, %$44] ; # Num
  %315 = phi i1 [%308, %$44] ; # Sign
  %316 = phi i1 [%309, %$44] ; # Frac
  %317 = phi i8 [%310, %$44] ; # B
; # (neg Num)
  %318 = icmp eq i64 %314, 2
  br i1 %318, label %$51, label %$52
$51:
  br label %$53
$52:
  %319 = xor i64 %314, 8
  br label %$53
$53:
  %320 = phi i64 [%314, %$51], [%319, %$52] ; # ->
  br label %$50
$49:
  %321 = phi i64 [%306, %$44] ; # Scl
  %322 = phi i64 [%312, %$44] ; # Num
  %323 = phi i1 [%308, %$44] ; # Sign
  %324 = phi i1 [%309, %$44] ; # Frac
  %325 = phi i8 [%310, %$44] ; # B
  br label %$50
$50:
  %326 = phi i64 [%313, %$53], [%321, %$49] ; # Scl
  %327 = phi i64 [%314, %$53], [%322, %$49] ; # Num
  %328 = phi i1 [%315, %$53], [%323, %$49] ; # Sign
  %329 = phi i1 [%316, %$53], [%324, %$49] ; # Frac
  %330 = phi i8 [%317, %$53], [%325, %$49] ; # B
  %331 = phi i64 [%320, %$53], [%322, %$49] ; # ->
; # (drop *Safe)
  %332 = inttoptr i64 %88 to i64*
  %333 = getelementptr i64, i64* %332, i32 1
  %334 = load i64, i64* %333
  %335 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %334, i64* %335
  ret i64 %331
}

define i64 @fmtWord(i64, i64, i8, i8, i64*) {
$1:
; # (when (> N 9) (setq Scl (fmtWord (/ N 10) Scl Sep Ign P)) (cond (...
; # (> N 9)
  %5 = icmp ugt i64 %0, 9
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%0, %$1] ; # N
  %7 = phi i64 [%1, %$1] ; # Scl
; # (/ N 10)
  %8 = udiv i64 %6, 10
; # (fmtWord (/ N 10) Scl Sep Ign P)
  %9 = call i64 @fmtWord(i64 %8, i64 %7, i8 %2, i8 %3, i64* %4)
; # (cond ((=0 Scl) (byteSym Sep P)) ((and Ign (gt0 Scl) (=0 (% Scl 3...
; # (=0 Scl)
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$6, label %$5
$6:
  %11 = phi i64 [%6, %$2] ; # N
  %12 = phi i64 [%9, %$2] ; # Scl
; # (byteSym Sep P)
  call void @byteSym(i8 %2, i64* %4)
  br label %$4
$5:
  %13 = phi i64 [%6, %$2] ; # N
  %14 = phi i64 [%9, %$2] ; # Scl
; # (and Ign (gt0 Scl) (=0 (% Scl 3)))
  %15 = icmp ne i8 %3, 0
  br i1 %15, label %$8, label %$7
$8:
  %16 = phi i64 [%13, %$5] ; # N
  %17 = phi i64 [%14, %$5] ; # Scl
; # (gt0 Scl)
  %18 = icmp sgt i64 %17, 0
  br i1 %18, label %$9, label %$7
$9:
  %19 = phi i64 [%16, %$8] ; # N
  %20 = phi i64 [%17, %$8] ; # Scl
; # (% Scl 3)
  %21 = urem i64 %20, 3
; # (=0 (% Scl 3))
  %22 = icmp eq i64 %21, 0
  br label %$7
$7:
  %23 = phi i64 [%13, %$5], [%16, %$8], [%19, %$9] ; # N
  %24 = phi i64 [%14, %$5], [%17, %$8], [%20, %$9] ; # Scl
  %25 = phi i1 [0, %$5], [0, %$8], [%22, %$9] ; # ->
  br i1 %25, label %$11, label %$10
$11:
  %26 = phi i64 [%23, %$7] ; # N
  %27 = phi i64 [%24, %$7] ; # Scl
; # (byteSym Ign P)
  call void @byteSym(i8 %3, i64* %4)
  br label %$4
$10:
  %28 = phi i64 [%23, %$7] ; # N
  %29 = phi i64 [%24, %$7] ; # Scl
  br label %$4
$4:
  %30 = phi i64 [%11, %$6], [%26, %$11], [%28, %$10] ; # N
  %31 = phi i64 [%12, %$6], [%27, %$11], [%29, %$10] ; # Scl
; # (dec 'Scl)
  %32 = sub i64 %31, 1
; # (% N 10)
  %33 = urem i64 %30, 10
  br label %$3
$3:
  %34 = phi i64 [%0, %$1], [%33, %$4] ; # N
  %35 = phi i64 [%1, %$1], [%32, %$4] ; # Scl
; # (i8 N)
  %36 = trunc i64 %34 to i8
; # (+ (i8 N) (char "0"))
  %37 = add i8 %36, 48
; # (byteSym (+ (i8 N) (char "0")) P)
  call void @byteSym(i8 %37, i64* %4)
  ret i64 %35
}

define i64 @fmtNum(i64, i64, i8, i8, i64*) {
$1:
; # (let (Sign (sign? Num) Len (+ 19 17)) (let N (setq Num (& Num -9)...
; # (sign? Num)
  %5 = and i64 %0, 8
  %6 = icmp ne i64 %5, 0
; # (+ 19 17)
; # (let N (setq Num (& Num -9)) (until (cnt? N) (inc 'Len 20) (setq ...
; # (& Num -9)
  %7 = and i64 %0, -9
; # (until (cnt? N) (inc 'Len 20) (setq N (val (big N))))
  br label %$2
$2:
  %8 = phi i64 [%7, %$1], [%14, %$3] ; # Num
  %9 = phi i64 [%1, %$1], [%15, %$3] ; # Scl
  %10 = phi i64 [36, %$1], [%18, %$3] ; # Len
  %11 = phi i64 [%7, %$1], [%21, %$3] ; # N
; # (cnt? N)
  %12 = and i64 %11, 2
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$4, label %$3
$3:
  %14 = phi i64 [%8, %$2] ; # Num
  %15 = phi i64 [%9, %$2] ; # Scl
  %16 = phi i64 [%10, %$2] ; # Len
  %17 = phi i64 [%11, %$2] ; # N
; # (inc 'Len 20)
  %18 = add i64 %16, 20
; # (big N)
  %19 = add i64 %17, 4
; # (val (big N))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
  br label %$2
$4:
  %22 = phi i64 [%8, %$2] ; # Num
  %23 = phi i64 [%9, %$2] ; # Scl
  %24 = phi i64 [%10, %$2] ; # Len
  %25 = phi i64 [%11, %$2] ; # N
; # (/ Len 18)
  %26 = udiv i64 %24, 18
; # (let (Acc (b64 Len) TopA Acc) (let (Inc (b64 Len) TopI Inc) (set ...
; # (b64 Len)
  %27 = alloca i64, i64 %26
; # (let (Inc (b64 Len) TopI Inc) (set Acc 0 Inc 1) (loop (let (Dig N...
; # (b64 Len)
  %28 = alloca i64, i64 %26
; # (set Acc 0 Inc 1)
  store i64 0, i64* %27
  store i64 1, i64* %28
; # (loop (let (Dig Num Mask 16) (when (big? Num) (setq Dig (val (dig...
  br label %$5
$5:
  %29 = phi i64 [%22, %$4], [%306, %$31] ; # Num
  %30 = phi i64 [%23, %$4], [%300, %$31] ; # Scl
  %31 = phi i64 [%26, %$4], [%301, %$31] ; # Len
  %32 = phi i64* [%27, %$4], [%302, %$31] ; # TopA
  %33 = phi i64* [%28, %$4], [%303, %$31] ; # TopI
; # (let (Dig Num Mask 16) (when (big? Num) (setq Dig (val (dig Num))...
; # (when (big? Num) (setq Dig (val (dig Num)) Mask 1))
; # (big? Num)
  %34 = and i64 %29, 4
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$6, label %$7
$6:
  %36 = phi i64 [%29, %$5] ; # Num
  %37 = phi i64 [%30, %$5] ; # Scl
  %38 = phi i64 [%31, %$5] ; # Len
  %39 = phi i64* [%32, %$5] ; # TopA
  %40 = phi i64* [%33, %$5] ; # TopI
  %41 = phi i64 [%29, %$5] ; # Dig
  %42 = phi i64 [16, %$5] ; # Mask
; # (dig Num)
  %43 = add i64 %36, -4
; # (val (dig Num))
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
  br label %$7
$7:
  %46 = phi i64 [%29, %$5], [%36, %$6] ; # Num
  %47 = phi i64 [%30, %$5], [%37, %$6] ; # Scl
  %48 = phi i64 [%31, %$5], [%38, %$6] ; # Len
  %49 = phi i64* [%32, %$5], [%39, %$6] ; # TopA
  %50 = phi i64* [%33, %$5], [%40, %$6] ; # TopI
  %51 = phi i64 [%29, %$5], [%45, %$6] ; # Dig
  %52 = phi i64 [16, %$5], [1, %$6] ; # Mask
; # (loop (when (& Dig Mask) (let (A Acc I Inc C 0) (loop (let N (+ (...
  br label %$8
$8:
  %53 = phi i64 [%46, %$7], [%282, %$29] ; # Num
  %54 = phi i64 [%47, %$7], [%283, %$29] ; # Scl
  %55 = phi i64 [%48, %$7], [%284, %$29] ; # Len
  %56 = phi i64* [%49, %$7], [%285, %$29] ; # TopA
  %57 = phi i64* [%50, %$7], [%286, %$29] ; # TopI
  %58 = phi i64 [%51, %$7], [%287, %$29] ; # Dig
  %59 = phi i64 [%52, %$7], [%288, %$29] ; # Mask
; # (when (& Dig Mask) (let (A Acc I Inc C 0) (loop (let N (+ (val A)...
; # (& Dig Mask)
  %60 = and i64 %58, %59
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$9, label %$10
$9:
  %62 = phi i64 [%53, %$8] ; # Num
  %63 = phi i64 [%54, %$8] ; # Scl
  %64 = phi i64 [%55, %$8] ; # Len
  %65 = phi i64* [%56, %$8] ; # TopA
  %66 = phi i64* [%57, %$8] ; # TopI
  %67 = phi i64 [%58, %$8] ; # Dig
  %68 = phi i64 [%59, %$8] ; # Mask
; # (let (A Acc I Inc C 0) (loop (let N (+ (val A) (val I) C) (setq C...
; # (loop (let N (+ (val A) (val I) C) (setq C (if (> 100000000000000...
  br label %$11
$11:
  %69 = phi i64 [%62, %$9], [%144, %$18] ; # Num
  %70 = phi i64 [%63, %$9], [%145, %$18] ; # Scl
  %71 = phi i64 [%64, %$9], [%146, %$18] ; # Len
  %72 = phi i64* [%65, %$9], [%147, %$18] ; # TopA
  %73 = phi i64* [%66, %$9], [%148, %$18] ; # TopI
  %74 = phi i64 [%67, %$9], [%149, %$18] ; # Dig
  %75 = phi i64 [%68, %$9], [%150, %$18] ; # Mask
  %76 = phi i64* [%27, %$9], [%151, %$18] ; # A
  %77 = phi i64* [%28, %$9], [%152, %$18] ; # I
  %78 = phi i64 [0, %$9], [%153, %$18] ; # C
; # (let N (+ (val A) (val I) C) (setq C (if (> 1000000000000000000 N...
; # (val A)
  %79 = load i64, i64* %76
; # (val I)
  %80 = load i64, i64* %77
; # (+ (val A) (val I) C)
  %81 = add i64 %79, %80
  %82 = add i64 %81, %78
; # (if (> 1000000000000000000 N) 0 (dec 'N 1000000000000000000) 1)
; # (> 1000000000000000000 N)
  %83 = icmp ugt i64 1000000000000000000, %82
  br i1 %83, label %$12, label %$13
$12:
  %84 = phi i64 [%69, %$11] ; # Num
  %85 = phi i64 [%70, %$11] ; # Scl
  %86 = phi i64 [%71, %$11] ; # Len
  %87 = phi i64* [%72, %$11] ; # TopA
  %88 = phi i64* [%73, %$11] ; # TopI
  %89 = phi i64 [%74, %$11] ; # Dig
  %90 = phi i64 [%75, %$11] ; # Mask
  %91 = phi i64* [%76, %$11] ; # A
  %92 = phi i64* [%77, %$11] ; # I
  %93 = phi i64 [%78, %$11] ; # C
  %94 = phi i64 [%82, %$11] ; # N
  br label %$14
$13:
  %95 = phi i64 [%69, %$11] ; # Num
  %96 = phi i64 [%70, %$11] ; # Scl
  %97 = phi i64 [%71, %$11] ; # Len
  %98 = phi i64* [%72, %$11] ; # TopA
  %99 = phi i64* [%73, %$11] ; # TopI
  %100 = phi i64 [%74, %$11] ; # Dig
  %101 = phi i64 [%75, %$11] ; # Mask
  %102 = phi i64* [%76, %$11] ; # A
  %103 = phi i64* [%77, %$11] ; # I
  %104 = phi i64 [%78, %$11] ; # C
  %105 = phi i64 [%82, %$11] ; # N
; # (dec 'N 1000000000000000000)
  %106 = sub i64 %105, 1000000000000000000
  br label %$14
$14:
  %107 = phi i64 [%84, %$12], [%95, %$13] ; # Num
  %108 = phi i64 [%85, %$12], [%96, %$13] ; # Scl
  %109 = phi i64 [%86, %$12], [%97, %$13] ; # Len
  %110 = phi i64* [%87, %$12], [%98, %$13] ; # TopA
  %111 = phi i64* [%88, %$12], [%99, %$13] ; # TopI
  %112 = phi i64 [%89, %$12], [%100, %$13] ; # Dig
  %113 = phi i64 [%90, %$12], [%101, %$13] ; # Mask
  %114 = phi i64* [%91, %$12], [%102, %$13] ; # A
  %115 = phi i64* [%92, %$12], [%103, %$13] ; # I
  %116 = phi i64 [%93, %$12], [%104, %$13] ; # C
  %117 = phi i64 [%94, %$12], [%106, %$13] ; # N
  %118 = phi i64 [0, %$12], [1, %$13] ; # ->
; # (set A N)
  store i64 %117, i64* %114
; # (? (> (inc 'I) TopI))
; # (inc 'I)
  %119 = getelementptr i64, i64* %115, i32 1
; # (> (inc 'I) TopI)
  %120 = icmp ugt i64* %119, %111
  br i1 %120, label %$16, label %$15
$15:
  %121 = phi i64 [%107, %$14] ; # Num
  %122 = phi i64 [%108, %$14] ; # Scl
  %123 = phi i64 [%109, %$14] ; # Len
  %124 = phi i64* [%110, %$14] ; # TopA
  %125 = phi i64* [%111, %$14] ; # TopI
  %126 = phi i64 [%112, %$14] ; # Dig
  %127 = phi i64 [%113, %$14] ; # Mask
  %128 = phi i64* [%114, %$14] ; # A
  %129 = phi i64* [%119, %$14] ; # I
  %130 = phi i64 [%118, %$14] ; # C
; # (when (> (inc 'A) TopA) (inc 'TopA) (set A 0))
; # (inc 'A)
  %131 = getelementptr i64, i64* %128, i32 1
; # (> (inc 'A) TopA)
  %132 = icmp ugt i64* %131, %124
  br i1 %132, label %$17, label %$18
$17:
  %133 = phi i64 [%121, %$15] ; # Num
  %134 = phi i64 [%122, %$15] ; # Scl
  %135 = phi i64 [%123, %$15] ; # Len
  %136 = phi i64* [%124, %$15] ; # TopA
  %137 = phi i64* [%125, %$15] ; # TopI
  %138 = phi i64 [%126, %$15] ; # Dig
  %139 = phi i64 [%127, %$15] ; # Mask
  %140 = phi i64* [%131, %$15] ; # A
  %141 = phi i64* [%129, %$15] ; # I
  %142 = phi i64 [%130, %$15] ; # C
; # (inc 'TopA)
  %143 = getelementptr i64, i64* %136, i32 1
; # (set A 0)
  store i64 0, i64* %140
  br label %$18
$18:
  %144 = phi i64 [%121, %$15], [%133, %$17] ; # Num
  %145 = phi i64 [%122, %$15], [%134, %$17] ; # Scl
  %146 = phi i64 [%123, %$15], [%135, %$17] ; # Len
  %147 = phi i64* [%124, %$15], [%143, %$17] ; # TopA
  %148 = phi i64* [%125, %$15], [%137, %$17] ; # TopI
  %149 = phi i64 [%126, %$15], [%138, %$17] ; # Dig
  %150 = phi i64 [%127, %$15], [%139, %$17] ; # Mask
  %151 = phi i64* [%131, %$15], [%140, %$17] ; # A
  %152 = phi i64* [%129, %$15], [%141, %$17] ; # I
  %153 = phi i64 [%130, %$15], [%142, %$17] ; # C
  br label %$11
$16:
  %154 = phi i64 [%107, %$14] ; # Num
  %155 = phi i64 [%108, %$14] ; # Scl
  %156 = phi i64 [%109, %$14] ; # Len
  %157 = phi i64* [%110, %$14] ; # TopA
  %158 = phi i64* [%111, %$14] ; # TopI
  %159 = phi i64 [%112, %$14] ; # Dig
  %160 = phi i64 [%113, %$14] ; # Mask
  %161 = phi i64* [%114, %$14] ; # A
  %162 = phi i64* [%119, %$14] ; # I
  %163 = phi i64 [%118, %$14] ; # C
  %164 = phi i64 [0, %$14] ; # ->
; # (when C (set (inc 'TopA) 1))
  %165 = icmp ne i64 %163, 0
  br i1 %165, label %$19, label %$20
$19:
  %166 = phi i64 [%154, %$16] ; # Num
  %167 = phi i64 [%155, %$16] ; # Scl
  %168 = phi i64 [%156, %$16] ; # Len
  %169 = phi i64* [%157, %$16] ; # TopA
  %170 = phi i64* [%158, %$16] ; # TopI
  %171 = phi i64 [%159, %$16] ; # Dig
  %172 = phi i64 [%160, %$16] ; # Mask
  %173 = phi i64* [%161, %$16] ; # A
  %174 = phi i64* [%162, %$16] ; # I
  %175 = phi i64 [%163, %$16] ; # C
; # (set (inc 'TopA) 1)
; # (inc 'TopA)
  %176 = getelementptr i64, i64* %169, i32 1
  store i64 1, i64* %176
  br label %$20
$20:
  %177 = phi i64 [%154, %$16], [%166, %$19] ; # Num
  %178 = phi i64 [%155, %$16], [%167, %$19] ; # Scl
  %179 = phi i64 [%156, %$16], [%168, %$19] ; # Len
  %180 = phi i64* [%157, %$16], [%176, %$19] ; # TopA
  %181 = phi i64* [%158, %$16], [%170, %$19] ; # TopI
  %182 = phi i64 [%159, %$16], [%171, %$19] ; # Dig
  %183 = phi i64 [%160, %$16], [%172, %$19] ; # Mask
  %184 = phi i64* [%161, %$16], [%173, %$19] ; # A
  %185 = phi i64* [%162, %$16], [%174, %$19] ; # I
  %186 = phi i64 [%163, %$16], [%175, %$19] ; # C
  br label %$10
$10:
  %187 = phi i64 [%53, %$8], [%177, %$20] ; # Num
  %188 = phi i64 [%54, %$8], [%178, %$20] ; # Scl
  %189 = phi i64 [%55, %$8], [%179, %$20] ; # Len
  %190 = phi i64* [%56, %$8], [%180, %$20] ; # TopA
  %191 = phi i64* [%57, %$8], [%181, %$20] ; # TopI
  %192 = phi i64 [%58, %$8], [%182, %$20] ; # Dig
  %193 = phi i64 [%59, %$8], [%183, %$20] ; # Mask
; # (let (I Inc C 0) (loop (let N (val I) (setq C (if (> 100000000000...
; # (loop (let N (val I) (setq C (if (> 1000000000000000000 (setq N (...
  br label %$21
$21:
  %194 = phi i64 [%187, %$10], [%241, %$25] ; # Num
  %195 = phi i64 [%188, %$10], [%242, %$25] ; # Scl
  %196 = phi i64 [%189, %$10], [%243, %$25] ; # Len
  %197 = phi i64* [%190, %$10], [%244, %$25] ; # TopA
  %198 = phi i64* [%191, %$10], [%245, %$25] ; # TopI
  %199 = phi i64 [%192, %$10], [%246, %$25] ; # Dig
  %200 = phi i64 [%193, %$10], [%247, %$25] ; # Mask
  %201 = phi i64* [%28, %$10], [%248, %$25] ; # I
  %202 = phi i64 [0, %$10], [%249, %$25] ; # C
; # (let N (val I) (setq C (if (> 1000000000000000000 (setq N (+ N N ...
; # (val I)
  %203 = load i64, i64* %201
; # (if (> 1000000000000000000 (setq N (+ N N C))) 0 (dec 'N 10000000...
; # (+ N N C)
  %204 = add i64 %203, %203
  %205 = add i64 %204, %202
; # (> 1000000000000000000 (setq N (+ N N C)))
  %206 = icmp ugt i64 1000000000000000000, %205
  br i1 %206, label %$22, label %$23
$22:
  %207 = phi i64 [%194, %$21] ; # Num
  %208 = phi i64 [%195, %$21] ; # Scl
  %209 = phi i64 [%196, %$21] ; # Len
  %210 = phi i64* [%197, %$21] ; # TopA
  %211 = phi i64* [%198, %$21] ; # TopI
  %212 = phi i64 [%199, %$21] ; # Dig
  %213 = phi i64 [%200, %$21] ; # Mask
  %214 = phi i64* [%201, %$21] ; # I
  %215 = phi i64 [%202, %$21] ; # C
  %216 = phi i64 [%205, %$21] ; # N
  br label %$24
$23:
  %217 = phi i64 [%194, %$21] ; # Num
  %218 = phi i64 [%195, %$21] ; # Scl
  %219 = phi i64 [%196, %$21] ; # Len
  %220 = phi i64* [%197, %$21] ; # TopA
  %221 = phi i64* [%198, %$21] ; # TopI
  %222 = phi i64 [%199, %$21] ; # Dig
  %223 = phi i64 [%200, %$21] ; # Mask
  %224 = phi i64* [%201, %$21] ; # I
  %225 = phi i64 [%202, %$21] ; # C
  %226 = phi i64 [%205, %$21] ; # N
; # (dec 'N 1000000000000000000)
  %227 = sub i64 %226, 1000000000000000000
  br label %$24
$24:
  %228 = phi i64 [%207, %$22], [%217, %$23] ; # Num
  %229 = phi i64 [%208, %$22], [%218, %$23] ; # Scl
  %230 = phi i64 [%209, %$22], [%219, %$23] ; # Len
  %231 = phi i64* [%210, %$22], [%220, %$23] ; # TopA
  %232 = phi i64* [%211, %$22], [%221, %$23] ; # TopI
  %233 = phi i64 [%212, %$22], [%222, %$23] ; # Dig
  %234 = phi i64 [%213, %$22], [%223, %$23] ; # Mask
  %235 = phi i64* [%214, %$22], [%224, %$23] ; # I
  %236 = phi i64 [%215, %$22], [%225, %$23] ; # C
  %237 = phi i64 [%216, %$22], [%227, %$23] ; # N
  %238 = phi i64 [0, %$22], [1, %$23] ; # ->
; # (set I N)
  store i64 %237, i64* %235
; # (? (> (inc 'I) TopI))
; # (inc 'I)
  %239 = getelementptr i64, i64* %235, i32 1
; # (> (inc 'I) TopI)
  %240 = icmp ugt i64* %239, %232
  br i1 %240, label %$26, label %$25
$25:
  %241 = phi i64 [%228, %$24] ; # Num
  %242 = phi i64 [%229, %$24] ; # Scl
  %243 = phi i64 [%230, %$24] ; # Len
  %244 = phi i64* [%231, %$24] ; # TopA
  %245 = phi i64* [%232, %$24] ; # TopI
  %246 = phi i64 [%233, %$24] ; # Dig
  %247 = phi i64 [%234, %$24] ; # Mask
  %248 = phi i64* [%239, %$24] ; # I
  %249 = phi i64 [%238, %$24] ; # C
  br label %$21
$26:
  %250 = phi i64 [%228, %$24] ; # Num
  %251 = phi i64 [%229, %$24] ; # Scl
  %252 = phi i64 [%230, %$24] ; # Len
  %253 = phi i64* [%231, %$24] ; # TopA
  %254 = phi i64* [%232, %$24] ; # TopI
  %255 = phi i64 [%233, %$24] ; # Dig
  %256 = phi i64 [%234, %$24] ; # Mask
  %257 = phi i64* [%239, %$24] ; # I
  %258 = phi i64 [%238, %$24] ; # C
  %259 = phi i64 [0, %$24] ; # ->
; # (when C (inc 'TopI) (set I 1))
  %260 = icmp ne i64 %258, 0
  br i1 %260, label %$27, label %$28
$27:
  %261 = phi i64 [%250, %$26] ; # Num
  %262 = phi i64 [%251, %$26] ; # Scl
  %263 = phi i64 [%252, %$26] ; # Len
  %264 = phi i64* [%253, %$26] ; # TopA
  %265 = phi i64* [%254, %$26] ; # TopI
  %266 = phi i64 [%255, %$26] ; # Dig
  %267 = phi i64 [%256, %$26] ; # Mask
  %268 = phi i64* [%257, %$26] ; # I
  %269 = phi i64 [%258, %$26] ; # C
; # (inc 'TopI)
  %270 = getelementptr i64, i64* %265, i32 1
; # (set I 1)
  store i64 1, i64* %268
  br label %$28
$28:
  %271 = phi i64 [%250, %$26], [%261, %$27] ; # Num
  %272 = phi i64 [%251, %$26], [%262, %$27] ; # Scl
  %273 = phi i64 [%252, %$26], [%263, %$27] ; # Len
  %274 = phi i64* [%253, %$26], [%264, %$27] ; # TopA
  %275 = phi i64* [%254, %$26], [%270, %$27] ; # TopI
  %276 = phi i64 [%255, %$26], [%266, %$27] ; # Dig
  %277 = phi i64 [%256, %$26], [%267, %$27] ; # Mask
  %278 = phi i64* [%257, %$26], [%268, %$27] ; # I
  %279 = phi i64 [%258, %$26], [%269, %$27] ; # C
; # (? (=0 (setq Mask (shl Mask 1))))
; # (shl Mask 1)
  %280 = shl i64 %277, 1
; # (=0 (setq Mask (shl Mask 1)))
  %281 = icmp eq i64 %280, 0
  br i1 %281, label %$30, label %$29
$29:
  %282 = phi i64 [%271, %$28] ; # Num
  %283 = phi i64 [%272, %$28] ; # Scl
  %284 = phi i64 [%273, %$28] ; # Len
  %285 = phi i64* [%274, %$28] ; # TopA
  %286 = phi i64* [%275, %$28] ; # TopI
  %287 = phi i64 [%276, %$28] ; # Dig
  %288 = phi i64 [%280, %$28] ; # Mask
  br label %$8
$30:
  %289 = phi i64 [%271, %$28] ; # Num
  %290 = phi i64 [%272, %$28] ; # Scl
  %291 = phi i64 [%273, %$28] ; # Len
  %292 = phi i64* [%274, %$28] ; # TopA
  %293 = phi i64* [%275, %$28] ; # TopI
  %294 = phi i64 [%276, %$28] ; # Dig
  %295 = phi i64 [%280, %$28] ; # Mask
  %296 = phi i64 [0, %$28] ; # ->
; # (? (cnt? Num))
; # (cnt? Num)
  %297 = and i64 %289, 2
  %298 = icmp ne i64 %297, 0
  br i1 %298, label %$32, label %$31
$31:
  %299 = phi i64 [%289, %$30] ; # Num
  %300 = phi i64 [%290, %$30] ; # Scl
  %301 = phi i64 [%291, %$30] ; # Len
  %302 = phi i64* [%292, %$30] ; # TopA
  %303 = phi i64* [%293, %$30] ; # TopI
; # (big Num)
  %304 = add i64 %299, 4
; # (val (big Num))
  %305 = inttoptr i64 %304 to i64*
  %306 = load i64, i64* %305
  br label %$5
$32:
  %307 = phi i64 [%289, %$30] ; # Num
  %308 = phi i64 [%290, %$30] ; # Scl
  %309 = phi i64 [%291, %$30] ; # Len
  %310 = phi i64* [%292, %$30] ; # TopA
  %311 = phi i64* [%293, %$30] ; # TopI
  %312 = phi i64 [0, %$30] ; # ->
; # (cond ((ge0 Scl) (when Sign (byteSym (char "-") P)) (let N (* (sh...
; # (ge0 Scl)
  %313 = icmp sge i64 %308, 0
  br i1 %313, label %$35, label %$34
$35:
  %314 = phi i64 [%307, %$32] ; # Num
  %315 = phi i64 [%308, %$32] ; # Scl
  %316 = phi i64 [%309, %$32] ; # Len
  %317 = phi i64* [%310, %$32] ; # TopA
; # (when Sign (byteSym (char "-") P))
  br i1 %6, label %$36, label %$37
$36:
  %318 = phi i64 [%314, %$35] ; # Num
  %319 = phi i64 [%315, %$35] ; # Scl
  %320 = phi i64 [%316, %$35] ; # Len
  %321 = phi i64* [%317, %$35] ; # TopA
; # (byteSym (char "-") P)
  call void @byteSym(i8 45, i64* %4)
  br label %$37
$37:
  %322 = phi i64 [%314, %$35], [%318, %$36] ; # Num
  %323 = phi i64 [%315, %$35], [%319, %$36] ; # Scl
  %324 = phi i64 [%316, %$35], [%320, %$36] ; # Len
  %325 = phi i64* [%317, %$35], [%321, %$36] ; # TopA
; # (let N (* (shr (- TopA Acc) 3) 18) (let D (val TopA) (while (setq...
; # (- TopA Acc)
  %326 = ptrtoint i64* %325 to i64
  %327 = ptrtoint i64* %27 to i64
  %328 = sub i64 %326, %327
; # (shr (- TopA Acc) 3)
  %329 = lshr i64 %328, 3
; # (* (shr (- TopA Acc) 3) 18)
  %330 = mul i64 %329, 18
; # (let D (val TopA) (while (setq D (/ D 10)) (inc 'N)))
; # (val TopA)
  %331 = load i64, i64* %325
; # (while (setq D (/ D 10)) (inc 'N))
  br label %$38
$38:
  %332 = phi i64 [%322, %$37], [%340, %$39] ; # Num
  %333 = phi i64 [%323, %$37], [%341, %$39] ; # Scl
  %334 = phi i64 [%324, %$37], [%342, %$39] ; # Len
  %335 = phi i64* [%325, %$37], [%343, %$39] ; # TopA
  %336 = phi i64 [%330, %$37], [%346, %$39] ; # N
  %337 = phi i64 [%331, %$37], [%345, %$39] ; # D
; # (/ D 10)
  %338 = udiv i64 %337, 10
  %339 = icmp ne i64 %338, 0
  br i1 %339, label %$39, label %$40
$39:
  %340 = phi i64 [%332, %$38] ; # Num
  %341 = phi i64 [%333, %$38] ; # Scl
  %342 = phi i64 [%334, %$38] ; # Len
  %343 = phi i64* [%335, %$38] ; # TopA
  %344 = phi i64 [%336, %$38] ; # N
  %345 = phi i64 [%338, %$38] ; # D
; # (inc 'N)
  %346 = add i64 %344, 1
  br label %$38
$40:
  %347 = phi i64 [%332, %$38] ; # Num
  %348 = phi i64 [%333, %$38] ; # Scl
  %349 = phi i64 [%334, %$38] ; # Len
  %350 = phi i64* [%335, %$38] ; # TopA
  %351 = phi i64 [%336, %$38] ; # N
  %352 = phi i64 [%338, %$38] ; # D
; # (when (lt0 (setq Scl (- N Scl))) (byteSym (char "0") P) (byteSym ...
; # (- N Scl)
  %353 = sub i64 %351, %348
; # (lt0 (setq Scl (- N Scl)))
  %354 = icmp slt i64 %353, 0
  br i1 %354, label %$41, label %$42
$41:
  %355 = phi i64 [%347, %$40] ; # Num
  %356 = phi i64 [%353, %$40] ; # Scl
  %357 = phi i64 [%349, %$40] ; # Len
  %358 = phi i64* [%350, %$40] ; # TopA
  %359 = phi i64 [%351, %$40] ; # N
; # (byteSym (char "0") P)
  call void @byteSym(i8 48, i64* %4)
; # (byteSym Sep P)
  call void @byteSym(i8 %2, i64* %4)
; # (while (> -1 Scl) (inc 'Scl) (byteSym (char "0") P))
  br label %$43
$43:
  %360 = phi i64 [%355, %$41], [%366, %$44] ; # Num
  %361 = phi i64 [%356, %$41], [%371, %$44] ; # Scl
  %362 = phi i64 [%357, %$41], [%368, %$44] ; # Len
  %363 = phi i64* [%358, %$41], [%369, %$44] ; # TopA
  %364 = phi i64 [%359, %$41], [%370, %$44] ; # N
; # (> -1 Scl)
  %365 = icmp ugt i64 -1, %361
  br i1 %365, label %$44, label %$45
$44:
  %366 = phi i64 [%360, %$43] ; # Num
  %367 = phi i64 [%361, %$43] ; # Scl
  %368 = phi i64 [%362, %$43] ; # Len
  %369 = phi i64* [%363, %$43] ; # TopA
  %370 = phi i64 [%364, %$43] ; # N
; # (inc 'Scl)
  %371 = add i64 %367, 1
; # (byteSym (char "0") P)
  call void @byteSym(i8 48, i64* %4)
  br label %$43
$45:
  %372 = phi i64 [%360, %$43] ; # Num
  %373 = phi i64 [%361, %$43] ; # Scl
  %374 = phi i64 [%362, %$43] ; # Len
  %375 = phi i64* [%363, %$43] ; # TopA
  %376 = phi i64 [%364, %$43] ; # N
  br label %$42
$42:
  %377 = phi i64 [%347, %$40], [%372, %$45] ; # Num
  %378 = phi i64 [%353, %$40], [%373, %$45] ; # Scl
  %379 = phi i64 [%349, %$40], [%374, %$45] ; # Len
  %380 = phi i64* [%350, %$40], [%375, %$45] ; # TopA
  %381 = phi i64 [%351, %$40], [%376, %$45] ; # N
; # (val TopA)
  %382 = load i64, i64* %380
; # (fmtWord (val TopA) Scl Sep Ign P)
  %383 = call i64 @fmtWord(i64 %382, i64 %378, i8 %2, i8 %3, i64* %4)
; # (while (>= (dec 'TopA) Acc) (let (N (val TopA) D 1000000000000000...
  br label %$46
$46:
  %384 = phi i64 [%377, %$42], [%468, %$59] ; # Num
  %385 = phi i64 [%383, %$42], [%469, %$59] ; # Scl
  %386 = phi i64 [%379, %$42], [%470, %$59] ; # Len
  %387 = phi i64* [%380, %$42], [%471, %$59] ; # TopA
; # (dec 'TopA)
  %388 = getelementptr i64, i64* %387, i32 -1
; # (>= (dec 'TopA) Acc)
  %389 = icmp uge i64* %388, %27
  br i1 %389, label %$47, label %$48
$47:
  %390 = phi i64 [%384, %$46] ; # Num
  %391 = phi i64 [%385, %$46] ; # Scl
  %392 = phi i64 [%386, %$46] ; # Len
  %393 = phi i64* [%388, %$46] ; # TopA
; # (let (N (val TopA) D 100000000000000000) (loop (cond ((=0 Scl) (b...
; # (val TopA)
  %394 = load i64, i64* %393
; # (loop (cond ((=0 Scl) (byteSym Sep P)) ((and Ign (gt0 Scl) (=0 (%...
  br label %$49
$49:
  %395 = phi i64 [%390, %$47], [%462, %$58] ; # Num
  %396 = phi i64 [%391, %$47], [%463, %$58] ; # Scl
  %397 = phi i64 [%392, %$47], [%464, %$58] ; # Len
  %398 = phi i64* [%393, %$47], [%465, %$58] ; # TopA
  %399 = phi i64 [%394, %$47], [%466, %$58] ; # N
  %400 = phi i64 [100000000000000000, %$47], [%467, %$58] ; # D
; # (cond ((=0 Scl) (byteSym Sep P)) ((and Ign (gt0 Scl) (=0 (% Scl 3...
; # (=0 Scl)
  %401 = icmp eq i64 %396, 0
  br i1 %401, label %$52, label %$51
$52:
  %402 = phi i64 [%395, %$49] ; # Num
  %403 = phi i64 [%396, %$49] ; # Scl
  %404 = phi i64 [%397, %$49] ; # Len
  %405 = phi i64* [%398, %$49] ; # TopA
  %406 = phi i64 [%399, %$49] ; # N
  %407 = phi i64 [%400, %$49] ; # D
; # (byteSym Sep P)
  call void @byteSym(i8 %2, i64* %4)
  br label %$50
$51:
  %408 = phi i64 [%395, %$49] ; # Num
  %409 = phi i64 [%396, %$49] ; # Scl
  %410 = phi i64 [%397, %$49] ; # Len
  %411 = phi i64* [%398, %$49] ; # TopA
  %412 = phi i64 [%399, %$49] ; # N
  %413 = phi i64 [%400, %$49] ; # D
; # (and Ign (gt0 Scl) (=0 (% Scl 3)))
  %414 = icmp ne i8 %3, 0
  br i1 %414, label %$54, label %$53
$54:
  %415 = phi i64 [%408, %$51] ; # Num
  %416 = phi i64 [%409, %$51] ; # Scl
  %417 = phi i64 [%410, %$51] ; # Len
  %418 = phi i64* [%411, %$51] ; # TopA
  %419 = phi i64 [%412, %$51] ; # N
  %420 = phi i64 [%413, %$51] ; # D
; # (gt0 Scl)
  %421 = icmp sgt i64 %416, 0
  br i1 %421, label %$55, label %$53
$55:
  %422 = phi i64 [%415, %$54] ; # Num
  %423 = phi i64 [%416, %$54] ; # Scl
  %424 = phi i64 [%417, %$54] ; # Len
  %425 = phi i64* [%418, %$54] ; # TopA
  %426 = phi i64 [%419, %$54] ; # N
  %427 = phi i64 [%420, %$54] ; # D
; # (% Scl 3)
  %428 = urem i64 %423, 3
; # (=0 (% Scl 3))
  %429 = icmp eq i64 %428, 0
  br label %$53
$53:
  %430 = phi i64 [%408, %$51], [%415, %$54], [%422, %$55] ; # Num
  %431 = phi i64 [%409, %$51], [%416, %$54], [%423, %$55] ; # Scl
  %432 = phi i64 [%410, %$51], [%417, %$54], [%424, %$55] ; # Len
  %433 = phi i64* [%411, %$51], [%418, %$54], [%425, %$55] ; # TopA
  %434 = phi i64 [%412, %$51], [%419, %$54], [%426, %$55] ; # N
  %435 = phi i64 [%413, %$51], [%420, %$54], [%427, %$55] ; # D
  %436 = phi i1 [0, %$51], [0, %$54], [%429, %$55] ; # ->
  br i1 %436, label %$57, label %$56
$57:
  %437 = phi i64 [%430, %$53] ; # Num
  %438 = phi i64 [%431, %$53] ; # Scl
  %439 = phi i64 [%432, %$53] ; # Len
  %440 = phi i64* [%433, %$53] ; # TopA
  %441 = phi i64 [%434, %$53] ; # N
  %442 = phi i64 [%435, %$53] ; # D
; # (byteSym Ign P)
  call void @byteSym(i8 %3, i64* %4)
  br label %$50
$56:
  %443 = phi i64 [%430, %$53] ; # Num
  %444 = phi i64 [%431, %$53] ; # Scl
  %445 = phi i64 [%432, %$53] ; # Len
  %446 = phi i64* [%433, %$53] ; # TopA
  %447 = phi i64 [%434, %$53] ; # N
  %448 = phi i64 [%435, %$53] ; # D
  br label %$50
$50:
  %449 = phi i64 [%402, %$52], [%437, %$57], [%443, %$56] ; # Num
  %450 = phi i64 [%403, %$52], [%438, %$57], [%444, %$56] ; # Scl
  %451 = phi i64 [%404, %$52], [%439, %$57], [%445, %$56] ; # Len
  %452 = phi i64* [%405, %$52], [%440, %$57], [%446, %$56] ; # TopA
  %453 = phi i64 [%406, %$52], [%441, %$57], [%447, %$56] ; # N
  %454 = phi i64 [%407, %$52], [%442, %$57], [%448, %$56] ; # D
; # (dec 'Scl)
  %455 = sub i64 %450, 1
; # (/ N D)
  %456 = udiv i64 %453, %454
; # (i8 (/ N D))
  %457 = trunc i64 %456 to i8
; # (+ (i8 (/ N D)) (char "0"))
  %458 = add i8 %457, 48
; # (byteSym (+ (i8 (/ N D)) (char "0")) P)
  call void @byteSym(i8 %458, i64* %4)
; # (% N D)
  %459 = urem i64 %453, %454
; # (? (== 1 (setq D (/ D 10))))
; # (/ D 10)
  %460 = udiv i64 %454, 10
; # (== 1 (setq D (/ D 10)))
  %461 = icmp eq i64 1, %460
  br i1 %461, label %$59, label %$58
$58:
  %462 = phi i64 [%449, %$50] ; # Num
  %463 = phi i64 [%455, %$50] ; # Scl
  %464 = phi i64 [%451, %$50] ; # Len
  %465 = phi i64* [%452, %$50] ; # TopA
  %466 = phi i64 [%459, %$50] ; # N
  %467 = phi i64 [%460, %$50] ; # D
  br label %$49
$59:
  %468 = phi i64 [%449, %$50] ; # Num
  %469 = phi i64 [%455, %$50] ; # Scl
  %470 = phi i64 [%451, %$50] ; # Len
  %471 = phi i64* [%452, %$50] ; # TopA
  %472 = phi i64 [%459, %$50] ; # N
  %473 = phi i64 [%460, %$50] ; # D
  %474 = phi i64 [0, %$50] ; # ->
; # (i8 N)
  %475 = trunc i64 %472 to i8
; # (+ (i8 N) (char "0"))
  %476 = add i8 %475, 48
; # (byteSym (+ (i8 N) (char "0")) P)
  call void @byteSym(i8 %476, i64* %4)
  br label %$46
$48:
  %477 = phi i64 [%384, %$46] ; # Num
  %478 = phi i64 [%385, %$46] ; # Scl
  %479 = phi i64 [%386, %$46] ; # Len
  %480 = phi i64* [%388, %$46] ; # TopA
  br label %$33
$34:
  %481 = phi i64 [%307, %$32] ; # Num
  %482 = phi i64 [%308, %$32] ; # Scl
  %483 = phi i64 [%309, %$32] ; # Len
  %484 = phi i64* [%310, %$32] ; # TopA
; # (== Scl -1)
  %485 = icmp eq i64 %482, -1
  br i1 %485, label %$61, label %$60
$61:
  %486 = phi i64 [%481, %$34] ; # Num
  %487 = phi i64 [%482, %$34] ; # Scl
  %488 = phi i64 [%483, %$34] ; # Len
  %489 = phi i64* [%484, %$34] ; # TopA
; # (when Sign (call $Put (char "-")))
  br i1 %6, label %$62, label %$63
$62:
  %490 = phi i64 [%486, %$61] ; # Num
  %491 = phi i64 [%487, %$61] ; # Scl
  %492 = phi i64 [%488, %$61] ; # Len
  %493 = phi i64* [%489, %$61] ; # TopA
; # (call $Put (char "-"))
  %494 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %494(i8 45)
  br label %$63
$63:
  %495 = phi i64 [%486, %$61], [%490, %$62] ; # Num
  %496 = phi i64 [%487, %$61], [%491, %$62] ; # Scl
  %497 = phi i64 [%488, %$61], [%492, %$62] ; # Len
  %498 = phi i64* [%489, %$61], [%493, %$62] ; # TopA
; # (val TopA)
  %499 = load i64, i64* %498
; # (outWord (val TopA))
  call void @outWord(i64 %499)
; # (while (>= (dec 'TopA) Acc) (let (N (val TopA) D 1000000000000000...
  br label %$64
$64:
  %500 = phi i64 [%495, %$63], [%530, %$69] ; # Num
  %501 = phi i64 [%496, %$63], [%531, %$69] ; # Scl
  %502 = phi i64 [%497, %$63], [%532, %$69] ; # Len
  %503 = phi i64* [%498, %$63], [%533, %$69] ; # TopA
; # (dec 'TopA)
  %504 = getelementptr i64, i64* %503, i32 -1
; # (>= (dec 'TopA) Acc)
  %505 = icmp uge i64* %504, %27
  br i1 %505, label %$65, label %$66
$65:
  %506 = phi i64 [%500, %$64] ; # Num
  %507 = phi i64 [%501, %$64] ; # Scl
  %508 = phi i64 [%502, %$64] ; # Len
  %509 = phi i64* [%504, %$64] ; # TopA
; # (let (N (val TopA) D 100000000000000000) (loop (call $Put (+ (i8 ...
; # (val TopA)
  %510 = load i64, i64* %509
; # (loop (call $Put (+ (i8 (/ N D)) (char "0"))) (setq N (% N D)) (?...
  br label %$67
$67:
  %511 = phi i64 [%506, %$65], [%524, %$68] ; # Num
  %512 = phi i64 [%507, %$65], [%525, %$68] ; # Scl
  %513 = phi i64 [%508, %$65], [%526, %$68] ; # Len
  %514 = phi i64* [%509, %$65], [%527, %$68] ; # TopA
  %515 = phi i64 [%510, %$65], [%528, %$68] ; # N
  %516 = phi i64 [100000000000000000, %$65], [%529, %$68] ; # D
; # (/ N D)
  %517 = udiv i64 %515, %516
; # (i8 (/ N D))
  %518 = trunc i64 %517 to i8
; # (+ (i8 (/ N D)) (char "0"))
  %519 = add i8 %518, 48
; # (call $Put (+ (i8 (/ N D)) (char "0")))
  %520 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %520(i8 %519)
; # (% N D)
  %521 = urem i64 %515, %516
; # (? (== 1 (setq D (/ D 10))))
; # (/ D 10)
  %522 = udiv i64 %516, 10
; # (== 1 (setq D (/ D 10)))
  %523 = icmp eq i64 1, %522
  br i1 %523, label %$69, label %$68
$68:
  %524 = phi i64 [%511, %$67] ; # Num
  %525 = phi i64 [%512, %$67] ; # Scl
  %526 = phi i64 [%513, %$67] ; # Len
  %527 = phi i64* [%514, %$67] ; # TopA
  %528 = phi i64 [%521, %$67] ; # N
  %529 = phi i64 [%522, %$67] ; # D
  br label %$67
$69:
  %530 = phi i64 [%511, %$67] ; # Num
  %531 = phi i64 [%512, %$67] ; # Scl
  %532 = phi i64 [%513, %$67] ; # Len
  %533 = phi i64* [%514, %$67] ; # TopA
  %534 = phi i64 [%521, %$67] ; # N
  %535 = phi i64 [%522, %$67] ; # D
  %536 = phi i64 [0, %$67] ; # ->
; # (i8 N)
  %537 = trunc i64 %534 to i8
; # (+ (i8 N) (char "0"))
  %538 = add i8 %537, 48
; # (call $Put (+ (i8 N) (char "0")))
  %539 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %539(i8 %538)
  br label %$64
$66:
  %540 = phi i64 [%500, %$64] ; # Num
  %541 = phi i64 [%501, %$64] ; # Scl
  %542 = phi i64 [%502, %$64] ; # Len
  %543 = phi i64* [%504, %$64] ; # TopA
  br label %$33
$60:
  %544 = phi i64 [%481, %$34] ; # Num
  %545 = phi i64 [%482, %$34] ; # Scl
  %546 = phi i64 [%483, %$34] ; # Len
  %547 = phi i64* [%484, %$34] ; # TopA
; # (let (N (* (shr (- TopA Acc) 3) 18) D (val TopA)) (loop (inc 'N) ...
; # (- TopA Acc)
  %548 = ptrtoint i64* %547 to i64
  %549 = ptrtoint i64* %27 to i64
  %550 = sub i64 %548, %549
; # (shr (- TopA Acc) 3)
  %551 = lshr i64 %550, 3
; # (* (shr (- TopA Acc) 3) 18)
  %552 = mul i64 %551, 18
; # (val TopA)
  %553 = load i64, i64* %547
; # (loop (inc 'N) (? (=0 (setq D (/ D 10)))))
  br label %$70
$70:
  %554 = phi i64 [%544, %$60], [%563, %$71] ; # Num
  %555 = phi i64 [%545, %$60], [%564, %$71] ; # Scl
  %556 = phi i64 [%546, %$60], [%565, %$71] ; # Len
  %557 = phi i64* [%547, %$60], [%566, %$71] ; # TopA
  %558 = phi i64 [%552, %$60], [%567, %$71] ; # N
  %559 = phi i64 [%553, %$60], [%568, %$71] ; # D
; # (inc 'N)
  %560 = add i64 %558, 1
; # (? (=0 (setq D (/ D 10))))
; # (/ D 10)
  %561 = udiv i64 %559, 10
; # (=0 (setq D (/ D 10)))
  %562 = icmp eq i64 %561, 0
  br i1 %562, label %$72, label %$71
$71:
  %563 = phi i64 [%554, %$70] ; # Num
  %564 = phi i64 [%555, %$70] ; # Scl
  %565 = phi i64 [%556, %$70] ; # Len
  %566 = phi i64* [%557, %$70] ; # TopA
  %567 = phi i64 [%560, %$70] ; # N
  %568 = phi i64 [%561, %$70] ; # D
  br label %$70
$72:
  %569 = phi i64 [%554, %$70] ; # Num
  %570 = phi i64 [%555, %$70] ; # Scl
  %571 = phi i64 [%556, %$70] ; # Len
  %572 = phi i64* [%557, %$70] ; # TopA
  %573 = phi i64 [%560, %$70] ; # N
  %574 = phi i64 [%561, %$70] ; # D
  %575 = phi i64 [0, %$70] ; # ->
; # (when Sign (inc 'N))
  br i1 %6, label %$73, label %$74
$73:
  %576 = phi i64 [%569, %$72] ; # Num
  %577 = phi i64 [%570, %$72] ; # Scl
  %578 = phi i64 [%571, %$72] ; # Len
  %579 = phi i64* [%572, %$72] ; # TopA
  %580 = phi i64 [%573, %$72] ; # N
  %581 = phi i64 [%574, %$72] ; # D
; # (inc 'N)
  %582 = add i64 %580, 1
  br label %$74
$74:
  %583 = phi i64 [%569, %$72], [%576, %$73] ; # Num
  %584 = phi i64 [%570, %$72], [%577, %$73] ; # Scl
  %585 = phi i64 [%571, %$72], [%578, %$73] ; # Len
  %586 = phi i64* [%572, %$72], [%579, %$73] ; # TopA
  %587 = phi i64 [%573, %$72], [%582, %$73] ; # N
  %588 = phi i64 [%574, %$72], [%581, %$73] ; # D
; # (cnt N)
  %589 = shl i64 %587, 4
  %590 = or i64 %589, 2
  br label %$33
$33:
  %591 = phi i64 [%477, %$48], [%540, %$66], [%583, %$74] ; # Num
  %592 = phi i64 [%478, %$48], [%541, %$66], [%584, %$74] ; # Scl
  %593 = phi i64 [%479, %$48], [%542, %$66], [%585, %$74] ; # Len
  %594 = phi i64* [%480, %$48], [%543, %$66], [%586, %$74] ; # TopA
  %595 = phi i64 [0, %$48], [0, %$66], [%590, %$74] ; # ->
  ret i64 %595
}

define i64 @_format(i64) {
$1:
; # (let (X (cdr Exe) A (save (eval (++ X))) Y (eval (++ X)) Scl (if ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (if (nil? Y) 0 (xCnt Exe Y))
; # (nil? Y)
  %36 = icmp eq i64 %35, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %36, label %$12, label %$13
$12:
  %37 = phi i64 [%27, %$7] ; # X
  br label %$14
$13:
  %38 = phi i64 [%27, %$7] ; # X
; # (xCnt Exe Y)
  %39 = call i64 @xCnt(i64 %0, i64 %35)
  br label %$14
$14:
  %40 = phi i64 [%37, %$12], [%38, %$13] ; # X
  %41 = phi i64 [0, %$12], [%39, %$13] ; # ->
; # (i8 (char "."))
; # (i8 0)
; # (when (pair X) (setq Sep (firstByte (needSymb Exe (eval (++ X))))...
; # (pair X)
  %42 = and i64 %40, 15
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %$15, label %$16
$15:
  %44 = phi i64 [%40, %$14] ; # X
  %45 = phi i8 [46, %$14] ; # Sep
  %46 = phi i8 [0, %$14] ; # Ign
; # (++ X)
  %47 = inttoptr i64 %44 to i64*
  %48 = load i64, i64* %47
  %49 = getelementptr i64, i64* %47, i32 1
  %50 = load i64, i64* %49
; # (eval (++ X))
  %51 = and i64 %48, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$19, label %$18
$19:
  br label %$17
$18:
  %53 = and i64 %48, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$21, label %$20
$21:
  %55 = inttoptr i64 %48 to i64*
  %56 = load i64, i64* %55
  br label %$17
$20:
  %57 = call i64 @evList(i64 %48)
  br label %$17
$17:
  %58 = phi i64 [%48, %$19], [%56, %$21], [%57, %$20] ; # ->
; # (needSymb Exe (eval (++ X)))
  %59 = xor i64 %58, 8
  %60 = and i64 %59, 14
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %$23, label %$22
$22:
  call void @symErr(i64 %0, i64 %58)
  unreachable
$23:
; # (firstByte (needSymb Exe (eval (++ X))))
  %62 = call i8 @firstByte(i64 %58)
; # (when (pair X) (setq Ign (firstByte (needSymb Exe (eval (car X)))...
; # (pair X)
  %63 = and i64 %50, 15
  %64 = icmp eq i64 %63, 0
  br i1 %64, label %$24, label %$25
$24:
  %65 = phi i64 [%50, %$23] ; # X
  %66 = phi i8 [%62, %$23] ; # Sep
  %67 = phi i8 [%46, %$23] ; # Ign
; # (car X)
  %68 = inttoptr i64 %65 to i64*
  %69 = load i64, i64* %68
; # (eval (car X))
  %70 = and i64 %69, 6
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$28, label %$27
$28:
  br label %$26
$27:
  %72 = and i64 %69, 8
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$30, label %$29
$30:
  %74 = inttoptr i64 %69 to i64*
  %75 = load i64, i64* %74
  br label %$26
$29:
  %76 = call i64 @evList(i64 %69)
  br label %$26
$26:
  %77 = phi i64 [%69, %$28], [%75, %$30], [%76, %$29] ; # ->
; # (needSymb Exe (eval (car X)))
  %78 = xor i64 %77, 8
  %79 = and i64 %78, 14
  %80 = icmp eq i64 %79, 0
  br i1 %80, label %$32, label %$31
$31:
  call void @symErr(i64 %0, i64 %77)
  unreachable
$32:
; # (firstByte (needSymb Exe (eval (car X))))
  %81 = call i8 @firstByte(i64 %77)
  br label %$25
$25:
  %82 = phi i64 [%50, %$23], [%65, %$32] ; # X
  %83 = phi i8 [%62, %$23], [%66, %$32] ; # Sep
  %84 = phi i8 [%46, %$23], [%81, %$32] ; # Ign
  br label %$16
$16:
  %85 = phi i64 [%40, %$14], [%82, %$25] ; # X
  %86 = phi i8 [46, %$14], [%83, %$25] ; # Sep
  %87 = phi i8 [0, %$14], [%84, %$25] ; # Ign
; # (cond ((num? A) (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (fm...
; # (num? A)
  %88 = and i64 %15, 6
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$35, label %$34
$35:
  %90 = phi i64 [%85, %$16] ; # X
  %91 = phi i8 [%86, %$16] ; # Sep
  %92 = phi i8 [%87, %$16] ; # Ign
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (fmtNum A Scl Sep I...
; # (push 4 NIL ZERO NIL)
  %93 = alloca i64, i64 4, align 16
  store i64 4, i64* %93
  %94 = getelementptr i64, i64* %93, i32 2
  store i64 2, i64* %94
; # (ofs P 2)
  %95 = getelementptr i64, i64* %93, i32 2
; # (link (ofs P 2))
  %96 = ptrtoint i64* %95 to i64
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %98 = load i64, i64* %97
  %99 = inttoptr i64 %96 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  store i64 %98, i64* %100
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %96, i64* %101
; # (fmtNum A Scl Sep Ign P)
  %102 = call i64 @fmtNum(i64 %15, i64 %41, i8 %91, i8 %92, i64* %93)
; # (val 3 P)
  %103 = getelementptr i64, i64* %93, i32 2
  %104 = load i64, i64* %103
; # (consStr (val 3 P))
  %105 = call i64 @consStr(i64 %104)
  br label %$33
$34:
  %106 = phi i64 [%85, %$16] ; # X
  %107 = phi i8 [%86, %$16] ; # Sep
  %108 = phi i8 [%87, %$16] ; # Ign
; # (sym? A)
  %109 = and i64 %15, 8
  %110 = icmp ne i64 %109, 0
  br i1 %110, label %$37, label %$36
$37:
  %111 = phi i64 [%106, %$34] ; # X
  %112 = phi i8 [%107, %$34] ; # Sep
  %113 = phi i8 [%108, %$34] ; # Ign
; # (cond ((sym? (val (tail A))) $Nil) ((=0 (symToNum (name @) Scl Se...
; # (tail A)
  %114 = add i64 %15, -8
; # (val (tail A))
  %115 = inttoptr i64 %114 to i64*
  %116 = load i64, i64* %115
; # (sym? (val (tail A)))
  %117 = and i64 %116, 8
  %118 = icmp ne i64 %117, 0
  br i1 %118, label %$40, label %$39
$40:
  %119 = phi i64 [%111, %$37] ; # X
  %120 = phi i8 [%112, %$37] ; # Sep
  %121 = phi i8 [%113, %$37] ; # Ign
  br label %$38
$39:
  %122 = phi i64 [%111, %$37] ; # X
  %123 = phi i8 [%112, %$37] ; # Sep
  %124 = phi i8 [%113, %$37] ; # Ign
; # (name @)
  br label %$41
$41:
  %125 = phi i64 [%116, %$39], [%131, %$42] ; # Tail
  %126 = and i64 %125, 6
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$43, label %$42
$42:
  %128 = phi i64 [%125, %$41] ; # Tail
  %129 = inttoptr i64 %128 to i64*
  %130 = getelementptr i64, i64* %129, i32 1
  %131 = load i64, i64* %130
  br label %$41
$43:
  %132 = phi i64 [%125, %$41] ; # Tail
; # (symToNum (name @) Scl Sep Ign)
  %133 = call i64 @symToNum(i64 %132, i64 %41, i8 %123, i8 %124)
; # (=0 (symToNum (name @) Scl Sep Ign))
  %134 = icmp eq i64 %133, 0
  br i1 %134, label %$45, label %$44
$45:
  %135 = phi i64 [%122, %$43] ; # X
  %136 = phi i8 [%123, %$43] ; # Sep
  %137 = phi i8 [%124, %$43] ; # Ign
  br label %$38
$44:
  %138 = phi i64 [%122, %$43] ; # X
  %139 = phi i8 [%123, %$43] ; # Sep
  %140 = phi i8 [%124, %$43] ; # Ign
  br label %$38
$38:
  %141 = phi i64 [%119, %$40], [%135, %$45], [%138, %$44] ; # X
  %142 = phi i8 [%120, %$40], [%136, %$45], [%139, %$44] ; # Sep
  %143 = phi i8 [%121, %$40], [%137, %$45], [%140, %$44] ; # Ign
  %144 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$40], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$45], [%133, %$44] ; # ->
  br label %$33
$36:
  %145 = phi i64 [%106, %$34] ; # X
  %146 = phi i8 [%107, %$34] ; # Sep
  %147 = phi i8 [%108, %$34] ; # Ign
; # (if (symToNum (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (pack...
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (pack A P) (val 3 P...
; # (push 4 NIL ZERO NIL)
  %148 = alloca i64, i64 4, align 16
  store i64 4, i64* %148
  %149 = getelementptr i64, i64* %148, i32 2
  store i64 2, i64* %149
; # (ofs P 2)
  %150 = getelementptr i64, i64* %148, i32 2
; # (link (ofs P 2))
  %151 = ptrtoint i64* %150 to i64
  %152 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %153 = load i64, i64* %152
  %154 = inttoptr i64 %151 to i64*
  %155 = getelementptr i64, i64* %154, i32 1
  store i64 %153, i64* %155
  %156 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %151, i64* %156
; # (pack A P)
  call void @pack(i64 %15, i64* %148)
; # (val 3 P)
  %157 = getelementptr i64, i64* %148, i32 2
  %158 = load i64, i64* %157
; # (symToNum (let P (push 4 NIL ZERO NIL) (link (ofs P 2)) (pack A P...
  %159 = call i64 @symToNum(i64 %158, i64 %41, i8 %146, i8 %147)
  %160 = icmp ne i64 %159, 0
  br i1 %160, label %$46, label %$47
$46:
  %161 = phi i64 [%145, %$36] ; # X
  %162 = phi i8 [%146, %$36] ; # Sep
  %163 = phi i8 [%147, %$36] ; # Ign
  br label %$48
$47:
  %164 = phi i64 [%145, %$36] ; # X
  %165 = phi i8 [%146, %$36] ; # Sep
  %166 = phi i8 [%147, %$36] ; # Ign
  br label %$48
$48:
  %167 = phi i64 [%161, %$46], [%164, %$47] ; # X
  %168 = phi i8 [%162, %$46], [%165, %$47] ; # Sep
  %169 = phi i8 [%163, %$46], [%166, %$47] ; # Ign
  %170 = phi i64 [%159, %$46], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$47] ; # ->
  br label %$33
$33:
  %171 = phi i64 [%90, %$35], [%141, %$38], [%167, %$48] ; # X
  %172 = phi i8 [%91, %$35], [%142, %$38], [%168, %$48] ; # Sep
  %173 = phi i8 [%92, %$35], [%143, %$38], [%169, %$48] ; # Ign
  %174 = phi i64 [%105, %$35], [%144, %$38], [%170, %$48] ; # ->
; # (drop *Safe)
  %175 = inttoptr i64 %17 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  %177 = load i64, i64* %176
  %178 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %177, i64* %178
  ret i64 %174
}

define i64 @_add(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (needN...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (needNum Exe @) NIL)) (loop (? (at...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let R (link (push (needNum Exe @) NIL)) (loop (? (atom (shift X)...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (push (needNum Exe @) NIL)
  %27 = alloca i64, i64 2, align 16
  %28 = ptrtoint i64* %27 to i64
  %29 = inttoptr i64 %28 to i64*
  store i64 %13, i64* %29
; # (link (push (needNum Exe @) NIL))
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %31 = load i64, i64* %30
  %32 = inttoptr i64 %28 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %31, i64* %33
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %34
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %35 = phi i64 [%16, %$11], [%57, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
; # (atom (shift X))
  %39 = and i64 %38, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$15, label %$13
$15:
  %41 = phi i64 [%38, %$12] ; # X
; # (val R)
  %42 = inttoptr i64 %28 to i64*
  %43 = load i64, i64* %42
  br label %$14
$13:
  %44 = phi i64 [%38, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (eval (car X))
  %47 = and i64 %46, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$18, label %$17
$18:
  br label %$16
$17:
  %49 = and i64 %46, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$20, label %$19
$20:
  %51 = inttoptr i64 %46 to i64*
  %52 = load i64, i64* %51
  br label %$16
$19:
  %53 = call i64 @evList(i64 %46)
  br label %$16
$16:
  %54 = phi i64 [%46, %$18], [%52, %$20], [%53, %$19] ; # ->
; # (nil? (eval (car X)))
  %55 = icmp eq i64 %54, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %55, label %$22, label %$21
$22:
  %56 = phi i64 [%44, %$16] ; # X
  br label %$14
$21:
  %57 = phi i64 [%44, %$16] ; # X
; # (needNum Exe @)
  %58 = and i64 %54, 6
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %54)
  unreachable
$24:
; # (safe (needNum Exe @))
  %60 = inttoptr i64 %18 to i64*
  store i64 %54, i64* %60
; # (set R (adds (val R) @))
; # (val R)
  %61 = inttoptr i64 %28 to i64*
  %62 = load i64, i64* %61
; # (adds (val R) @)
  %63 = call i64 @adds(i64 %62, i64 %54)
  %64 = inttoptr i64 %28 to i64*
  store i64 %63, i64* %64
  br label %$12
$14:
  %65 = phi i64 [%41, %$15], [%56, %$22] ; # X
  %66 = phi i64 [%43, %$15], [%54, %$22] ; # ->
  %67 = inttoptr i64 %18 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %69, i64* %70
  br label %$9
$9:
  %71 = phi i64 [%15, %$7], [%65, %$14] ; # X
  %72 = phi i64 [%13, %$7], [%66, %$14] ; # ->
  ret i64 %72
}

define i64 @_sub(i64) {
$1:
; # (let (X (cdr Exe) N (eval (++ X))) (if (nil? N) N (needNum Exe N)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (if (nil? N) N (needNum Exe N) (if (atom X) (neg N) (save -ZERO (...
; # (nil? N)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
  br label %$9
$8:
  %18 = phi i64 [%7, %$2] ; # X
; # (needNum Exe N)
  %19 = and i64 %15, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$11:
; # (if (atom X) (neg N) (save -ZERO (let R (link (push N NIL)) (loop...
; # (atom X)
  %21 = and i64 %18, 15
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$12, label %$13
$12:
  %23 = phi i64 [%18, %$11] ; # X
; # (neg N)
  %24 = icmp eq i64 %15, 2
  br i1 %24, label %$15, label %$16
$15:
  br label %$17
$16:
  %25 = xor i64 %15, 8
  br label %$17
$17:
  %26 = phi i64 [%15, %$15], [%25, %$16] ; # ->
  br label %$14
$13:
  %27 = phi i64 [%18, %$11] ; # X
; # (save -ZERO (let R (link (push N NIL)) (loop (? (nil? (eval (++ X...
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 10, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (let R (link (push N NIL)) (loop (? (nil? (eval (++ X))) @) (safe...
; # (push N NIL)
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %15, i64* %38
; # (link (push N NIL))
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %43
; # (loop (? (nil? (eval (++ X))) @) (safe (needNum Exe @)) (set R (s...
  br label %$18
$18:
  %44 = phi i64 [%27, %$13], [%72, %$29] ; # X
; # (? (nil? (eval (++ X))) @)
; # (++ X)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
  %47 = getelementptr i64, i64* %45, i32 1
  %48 = load i64, i64* %47
; # (eval (++ X))
  %49 = and i64 %46, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$21, label %$20
$21:
  br label %$19
$20:
  %51 = and i64 %46, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$23, label %$22
$23:
  %53 = inttoptr i64 %46 to i64*
  %54 = load i64, i64* %53
  br label %$19
$22:
  %55 = call i64 @evList(i64 %46)
  br label %$19
$19:
  %56 = phi i64 [%46, %$21], [%54, %$23], [%55, %$22] ; # ->
; # (nil? (eval (++ X)))
  %57 = icmp eq i64 %56, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %57, label %$26, label %$24
$26:
  %58 = phi i64 [%48, %$19] ; # X
  br label %$25
$24:
  %59 = phi i64 [%48, %$19] ; # X
; # (needNum Exe @)
  %60 = and i64 %56, 6
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$28, label %$27
$27:
  call void @numErr(i64 %0, i64 %56)
  unreachable
$28:
; # (safe (needNum Exe @))
  %62 = inttoptr i64 %29 to i64*
  store i64 %56, i64* %62
; # (set R (subs (val R) @))
; # (val R)
  %63 = inttoptr i64 %37 to i64*
  %64 = load i64, i64* %63
; # (subs (val R) @)
  %65 = call i64 @subs(i64 %64, i64 %56)
  %66 = inttoptr i64 %37 to i64*
  store i64 %65, i64* %66
; # (? (atom X) (val R))
; # (atom X)
  %67 = and i64 %59, 15
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$30, label %$29
$30:
  %69 = phi i64 [%59, %$28] ; # X
; # (val R)
  %70 = inttoptr i64 %37 to i64*
  %71 = load i64, i64* %70
  br label %$25
$29:
  %72 = phi i64 [%59, %$28] ; # X
  br label %$18
$25:
  %73 = phi i64 [%58, %$26], [%69, %$30] ; # X
  %74 = phi i64 [%56, %$26], [%71, %$30] ; # ->
  %75 = inttoptr i64 %29 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %78
  br label %$14
$14:
  %79 = phi i64 [%23, %$17], [%73, %$25] ; # X
  %80 = phi i64 [%26, %$17], [%74, %$25] ; # ->
  br label %$9
$9:
  %81 = phi i64 [%17, %$7], [%79, %$14] ; # X
  %82 = phi i64 [%15, %$7], [%80, %$14] ; # ->
  ret i64 %82
}

define i64 @_inc(i64) {
$1:
; # (let X (cdr Exe) (cond ((nil? (eval (car X))) @) ((num? @) (incs ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((nil? (eval (car X))) @) ((num? @) (incs @)) (T (let Y (sa...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%3, %$3] ; # X
  br label %$2
$8:
  %16 = phi i64 [%3, %$3] ; # X
; # (num? @)
  %17 = and i64 %13, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
  %19 = phi i64 [%16, %$8] ; # X
; # (incs @)
  %20 = call i64 @incs(i64 %13)
  br label %$2
$10:
  %21 = phi i64 [%16, %$8] ; # X
; # (let Y (save (chkVar Exe @)) (when (and (sym? Y) (sym? (val (tail...
; # (chkVar Exe @)
  %22 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %22, label %$13, label %$12
$13:
  %23 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %13
  br label %$12
$12:
  %24 = phi i1 [0, %$10], [%23, %$13] ; # ->
  br i1 %24, label %$14, label %$15
$14:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$15:
; # (save (chkVar Exe @))
  %25 = alloca i64, i64 2, align 16
  %26 = ptrtoint i64* %25 to i64
  %27 = inttoptr i64 %26 to i64*
  store i64 %13, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %26 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  store i64 %29, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %32
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %33 = and i64 %13, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$17, label %$16
$17:
  %35 = phi i64 [%21, %$15] ; # X
; # (tail Y)
  %36 = add i64 %13, -8
; # (val (tail Y))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (sym? (val (tail Y)))
  %39 = and i64 %38, 8
  %40 = icmp ne i64 %39, 0
  br label %$16
$16:
  %41 = phi i64 [%21, %$15], [%35, %$17] ; # X
  %42 = phi i1 [0, %$15], [%40, %$17] ; # ->
  br i1 %42, label %$18, label %$19
$18:
  %43 = phi i64 [%41, %$16] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$19
$19:
  %44 = phi i64 [%41, %$16], [%43, %$18] ; # X
; # (if (atom (shift X)) (if (nil? (val Y)) @ (set Y (incs (needNum E...
; # (shift X)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (atom (shift X))
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$20, label %$21
$20:
  %50 = phi i64 [%47, %$19] ; # X
; # (if (nil? (val Y)) @ (set Y (incs (needNum Exe @))))
; # (val Y)
  %51 = inttoptr i64 %13 to i64*
  %52 = load i64, i64* %51
; # (nil? (val Y))
  %53 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %53, label %$23, label %$24
$23:
  %54 = phi i64 [%50, %$20] ; # X
  br label %$25
$24:
  %55 = phi i64 [%50, %$20] ; # X
; # (set Y (incs (needNum Exe @)))
; # (needNum Exe @)
  %56 = and i64 %52, 6
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$27, label %$26
$26:
  call void @numErr(i64 %0, i64 %52)
  unreachable
$27:
; # (incs (needNum Exe @))
  %58 = call i64 @incs(i64 %52)
  %59 = inttoptr i64 %13 to i64*
  store i64 %58, i64* %59
  br label %$25
$25:
  %60 = phi i64 [%54, %$23], [%55, %$27] ; # X
  %61 = phi i64 [%52, %$23], [%58, %$27] ; # ->
  br label %$22
$21:
  %62 = phi i64 [%47, %$19] ; # X
; # (let (D (save (eval (car X))) N (val Y)) (cond ((nil? N) N) ((nil...
; # (car X)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$30, label %$29
$30:
  br label %$28
$29:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$32, label %$31
$32:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$28
$31:
  %71 = call i64 @evList(i64 %64)
  br label %$28
$28:
  %72 = phi i64 [%64, %$30], [%70, %$32], [%71, %$31] ; # ->
; # (save (eval (car X)))
  %73 = alloca i64, i64 2, align 16
  %74 = ptrtoint i64* %73 to i64
  %75 = inttoptr i64 %74 to i64*
  store i64 %72, i64* %75
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %74 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %77, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %74, i64* %80
; # (val Y)
  %81 = inttoptr i64 %13 to i64*
  %82 = load i64, i64* %81
; # (cond ((nil? N) N) ((nil? D) D) (T (set Y (adds (needNum Exe N) (...
; # (nil? N)
  %83 = icmp eq i64 %82, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %83, label %$35, label %$34
$35:
  %84 = phi i64 [%62, %$28] ; # X
  br label %$33
$34:
  %85 = phi i64 [%62, %$28] ; # X
; # (nil? D)
  %86 = icmp eq i64 %72, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %86, label %$37, label %$36
$37:
  %87 = phi i64 [%85, %$34] ; # X
  br label %$33
$36:
  %88 = phi i64 [%85, %$34] ; # X
; # (set Y (adds (needNum Exe N) (needNum Exe D)))
; # (needNum Exe N)
  %89 = and i64 %82, 6
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$39, label %$38
$38:
  call void @numErr(i64 %0, i64 %82)
  unreachable
$39:
; # (needNum Exe D)
  %91 = and i64 %72, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$41, label %$40
$40:
  call void @numErr(i64 %0, i64 %72)
  unreachable
$41:
; # (adds (needNum Exe N) (needNum Exe D))
  %93 = call i64 @adds(i64 %82, i64 %72)
  %94 = inttoptr i64 %13 to i64*
  store i64 %93, i64* %94
  br label %$33
$33:
  %95 = phi i64 [%84, %$35], [%87, %$37], [%88, %$41] ; # X
  %96 = phi i64 [%82, %$35], [%72, %$37], [%93, %$41] ; # ->
  br label %$22
$22:
  %97 = phi i64 [%60, %$25], [%95, %$33] ; # X
  %98 = phi i64 [%61, %$25], [%96, %$33] ; # ->
; # (drop *Safe)
  %99 = inttoptr i64 %26 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %101, i64* %102
  br label %$2
$2:
  %103 = phi i64 [%15, %$9], [%19, %$11], [%97, %$22] ; # X
  %104 = phi i64 [%13, %$9], [%20, %$11], [%98, %$22] ; # ->
  ret i64 %104
}

define i64 @_dec(i64) {
$1:
; # (let X (cdr Exe) (cond ((nil? (eval (car X))) @) ((num? @) (decs ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((nil? (eval (car X))) @) ((num? @) (decs @)) (T (let Y (sa...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%3, %$3] ; # X
  br label %$2
$8:
  %16 = phi i64 [%3, %$3] ; # X
; # (num? @)
  %17 = and i64 %13, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
  %19 = phi i64 [%16, %$8] ; # X
; # (decs @)
  %20 = call i64 @decs(i64 %13)
  br label %$2
$10:
  %21 = phi i64 [%16, %$8] ; # X
; # (let Y (save (chkVar Exe @)) (when (and (sym? Y) (sym? (val (tail...
; # (chkVar Exe @)
  %22 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %22, label %$13, label %$12
$13:
  %23 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %13
  br label %$12
$12:
  %24 = phi i1 [0, %$10], [%23, %$13] ; # ->
  br i1 %24, label %$14, label %$15
$14:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$15:
; # (save (chkVar Exe @))
  %25 = alloca i64, i64 2, align 16
  %26 = ptrtoint i64* %25 to i64
  %27 = inttoptr i64 %26 to i64*
  store i64 %13, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %26 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  store i64 %29, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %32
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %33 = and i64 %13, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$17, label %$16
$17:
  %35 = phi i64 [%21, %$15] ; # X
; # (tail Y)
  %36 = add i64 %13, -8
; # (val (tail Y))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (sym? (val (tail Y)))
  %39 = and i64 %38, 8
  %40 = icmp ne i64 %39, 0
  br label %$16
$16:
  %41 = phi i64 [%21, %$15], [%35, %$17] ; # X
  %42 = phi i1 [0, %$15], [%40, %$17] ; # ->
  br i1 %42, label %$18, label %$19
$18:
  %43 = phi i64 [%41, %$16] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$19
$19:
  %44 = phi i64 [%41, %$16], [%43, %$18] ; # X
; # (if (atom (shift X)) (if (nil? (val Y)) @ (set Y (decs (needNum E...
; # (shift X)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (atom (shift X))
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$20, label %$21
$20:
  %50 = phi i64 [%47, %$19] ; # X
; # (if (nil? (val Y)) @ (set Y (decs (needNum Exe @))))
; # (val Y)
  %51 = inttoptr i64 %13 to i64*
  %52 = load i64, i64* %51
; # (nil? (val Y))
  %53 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %53, label %$23, label %$24
$23:
  %54 = phi i64 [%50, %$20] ; # X
  br label %$25
$24:
  %55 = phi i64 [%50, %$20] ; # X
; # (set Y (decs (needNum Exe @)))
; # (needNum Exe @)
  %56 = and i64 %52, 6
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$27, label %$26
$26:
  call void @numErr(i64 %0, i64 %52)
  unreachable
$27:
; # (decs (needNum Exe @))
  %58 = call i64 @decs(i64 %52)
  %59 = inttoptr i64 %13 to i64*
  store i64 %58, i64* %59
  br label %$25
$25:
  %60 = phi i64 [%54, %$23], [%55, %$27] ; # X
  %61 = phi i64 [%52, %$23], [%58, %$27] ; # ->
  br label %$22
$21:
  %62 = phi i64 [%47, %$19] ; # X
; # (let (D (save (eval (car X))) N (val Y)) (cond ((nil? N) N) ((nil...
; # (car X)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$30, label %$29
$30:
  br label %$28
$29:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$32, label %$31
$32:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$28
$31:
  %71 = call i64 @evList(i64 %64)
  br label %$28
$28:
  %72 = phi i64 [%64, %$30], [%70, %$32], [%71, %$31] ; # ->
; # (save (eval (car X)))
  %73 = alloca i64, i64 2, align 16
  %74 = ptrtoint i64* %73 to i64
  %75 = inttoptr i64 %74 to i64*
  store i64 %72, i64* %75
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %74 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %77, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %74, i64* %80
; # (val Y)
  %81 = inttoptr i64 %13 to i64*
  %82 = load i64, i64* %81
; # (cond ((nil? N) N) ((nil? D) D) (T (set Y (subs (needNum Exe N) (...
; # (nil? N)
  %83 = icmp eq i64 %82, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %83, label %$35, label %$34
$35:
  %84 = phi i64 [%62, %$28] ; # X
  br label %$33
$34:
  %85 = phi i64 [%62, %$28] ; # X
; # (nil? D)
  %86 = icmp eq i64 %72, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %86, label %$37, label %$36
$37:
  %87 = phi i64 [%85, %$34] ; # X
  br label %$33
$36:
  %88 = phi i64 [%85, %$34] ; # X
; # (set Y (subs (needNum Exe N) (needNum Exe D)))
; # (needNum Exe N)
  %89 = and i64 %82, 6
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$39, label %$38
$38:
  call void @numErr(i64 %0, i64 %82)
  unreachable
$39:
; # (needNum Exe D)
  %91 = and i64 %72, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$41, label %$40
$40:
  call void @numErr(i64 %0, i64 %72)
  unreachable
$41:
; # (subs (needNum Exe N) (needNum Exe D))
  %93 = call i64 @subs(i64 %82, i64 %72)
  %94 = inttoptr i64 %13 to i64*
  store i64 %93, i64* %94
  br label %$33
$33:
  %95 = phi i64 [%84, %$35], [%87, %$37], [%88, %$41] ; # X
  %96 = phi i64 [%82, %$35], [%72, %$37], [%93, %$41] ; # ->
  br label %$22
$22:
  %97 = phi i64 [%60, %$25], [%95, %$33] ; # X
  %98 = phi i64 [%61, %$25], [%96, %$33] ; # ->
; # (drop *Safe)
  %99 = inttoptr i64 %26 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %101, i64* %102
  br label %$2
$2:
  %103 = phi i64 [%15, %$9], [%19, %$11], [%97, %$22] ; # X
  %104 = phi i64 [%13, %$9], [%20, %$11], [%98, %$22] ; # ->
  ret i64 %104
}

define i64 @_mul(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (loop (? (atom (shift X)) (let N (val R) (if Sign (neg N) N))) (l...
  br label %$12
$12:
  %38 = phi i64 [%16, %$11], [%87, %$32] ; # X
  %39 = phi i1 [%28, %$11], [%88, %$32] ; # Sign
; # (? (atom (shift X)) (let N (val R) (if Sign (neg N) N)))
; # (shift X)
  %40 = inttoptr i64 %38 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
; # (atom (shift X))
  %43 = and i64 %42, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$13
$15:
  %45 = phi i64 [%42, %$12] ; # X
  %46 = phi i1 [%39, %$12] ; # Sign
; # (let N (val R) (if Sign (neg N) N))
; # (val R)
  %47 = inttoptr i64 %31 to i64*
  %48 = load i64, i64* %47
; # (if Sign (neg N) N)
  br i1 %46, label %$16, label %$17
$16:
  %49 = phi i64 [%45, %$15] ; # X
  %50 = phi i1 [%46, %$15] ; # Sign
; # (neg N)
  %51 = icmp eq i64 %48, 2
  br i1 %51, label %$19, label %$20
$19:
  br label %$21
$20:
  %52 = xor i64 %48, 8
  br label %$21
$21:
  %53 = phi i64 [%48, %$19], [%52, %$20] ; # ->
  br label %$18
$17:
  %54 = phi i64 [%45, %$15] ; # X
  %55 = phi i1 [%46, %$15] ; # Sign
  br label %$18
$18:
  %56 = phi i64 [%49, %$21], [%54, %$17] ; # X
  %57 = phi i1 [%50, %$21], [%55, %$17] ; # Sign
  %58 = phi i64 [%53, %$21], [%48, %$17] ; # ->
  br label %$14
$13:
  %59 = phi i64 [%42, %$12] ; # X
  %60 = phi i1 [%39, %$12] ; # Sign
; # (let N (eval (car X)) (? (nil? N) N) (when (sign? (needNum Exe N)...
; # (car X)
  %61 = inttoptr i64 %59 to i64*
  %62 = load i64, i64* %61
; # (eval (car X))
  %63 = and i64 %62, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$24, label %$23
$24:
  br label %$22
$23:
  %65 = and i64 %62, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$26, label %$25
$26:
  %67 = inttoptr i64 %62 to i64*
  %68 = load i64, i64* %67
  br label %$22
$25:
  %69 = call i64 @evList(i64 %62)
  br label %$22
$22:
  %70 = phi i64 [%62, %$24], [%68, %$26], [%69, %$25] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %71, label %$28, label %$27
$28:
  %72 = phi i64 [%59, %$22] ; # X
  %73 = phi i1 [%60, %$22] ; # Sign
  %74 = phi i64 [%70, %$22] ; # N
  br label %$14
$27:
  %75 = phi i64 [%59, %$22] ; # X
  %76 = phi i1 [%60, %$22] ; # Sign
  %77 = phi i64 [%70, %$22] ; # N
; # (when (sign? (needNum Exe N)) (setq Sign (not Sign) N (pos N)))
; # (needNum Exe N)
  %78 = and i64 %77, 6
  %79 = icmp ne i64 %78, 0
  br i1 %79, label %$30, label %$29
$29:
  call void @numErr(i64 %0, i64 %77)
  unreachable
$30:
; # (sign? (needNum Exe N))
  %80 = and i64 %77, 8
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$31, label %$32
$31:
  %82 = phi i64 [%75, %$30] ; # X
  %83 = phi i1 [%76, %$30] ; # Sign
  %84 = phi i64 [%77, %$30] ; # N
; # (not Sign)
  %85 = icmp eq i1 %83, 0
; # (pos N)
  %86 = and i64 %84, -9
  br label %$32
$32:
  %87 = phi i64 [%75, %$30], [%82, %$31] ; # X
  %88 = phi i1 [%76, %$30], [%85, %$31] ; # Sign
  %89 = phi i64 [%77, %$30], [%86, %$31] ; # N
; # (safe N)
  %90 = inttoptr i64 %18 to i64*
  store i64 %89, i64* %90
; # (set R (mulu (val R) N))
; # (val R)
  %91 = inttoptr i64 %31 to i64*
  %92 = load i64, i64* %91
; # (mulu (val R) N)
  %93 = call i64 @mulu(i64 %92, i64 %89)
  %94 = inttoptr i64 %31 to i64*
  store i64 %93, i64* %94
  br label %$12
$14:
  %95 = phi i64 [%56, %$18], [%72, %$28] ; # X
  %96 = phi i1 [%57, %$18], [%73, %$28] ; # Sign
  %97 = phi i64 [%58, %$18], [%74, %$28] ; # ->
  %98 = inttoptr i64 %18 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %100, i64* %101
  br label %$9
$9:
  %102 = phi i64 [%15, %$7], [%95, %$14] ; # X
  %103 = phi i64 [%13, %$7], [%97, %$14] ; # ->
  ret i64 %103
}

define i64 @_mulDiv(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (shift X)
  %38 = inttoptr i64 %16 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (loop (let N (eval (car X)) (? (nil? N) N) (when (sign? (needNum ...
  br label %$12
$12:
  %41 = phi i64 [%40, %$11], [%115, %$25] ; # X
  %42 = phi i1 [%28, %$11], [%116, %$25] ; # Sign
; # (let N (eval (car X)) (? (nil? N) N) (when (sign? (needNum Exe N)...
; # (car X)
  %43 = inttoptr i64 %41 to i64*
  %44 = load i64, i64* %43
; # (eval (car X))
  %45 = and i64 %44, 6
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$15, label %$14
$15:
  br label %$13
$14:
  %47 = and i64 %44, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$17, label %$16
$17:
  %49 = inttoptr i64 %44 to i64*
  %50 = load i64, i64* %49
  br label %$13
$16:
  %51 = call i64 @evList(i64 %44)
  br label %$13
$13:
  %52 = phi i64 [%44, %$15], [%50, %$17], [%51, %$16] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %53 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %53, label %$20, label %$18
$20:
  %54 = phi i64 [%41, %$13] ; # X
  %55 = phi i1 [%42, %$13] ; # Sign
  %56 = phi i64 [%52, %$13] ; # N
  br label %$19
$18:
  %57 = phi i64 [%41, %$13] ; # X
  %58 = phi i1 [%42, %$13] ; # Sign
  %59 = phi i64 [%52, %$13] ; # N
; # (when (sign? (needNum Exe N)) (setq Sign (not Sign) N (pos N)))
; # (needNum Exe N)
  %60 = and i64 %59, 6
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$22, label %$21
$21:
  call void @numErr(i64 %0, i64 %59)
  unreachable
$22:
; # (sign? (needNum Exe N))
  %62 = and i64 %59, 8
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$23, label %$24
$23:
  %64 = phi i64 [%57, %$22] ; # X
  %65 = phi i1 [%58, %$22] ; # Sign
  %66 = phi i64 [%59, %$22] ; # N
; # (not Sign)
  %67 = icmp eq i1 %65, 0
; # (pos N)
  %68 = and i64 %66, -9
  br label %$24
$24:
  %69 = phi i64 [%57, %$22], [%64, %$23] ; # X
  %70 = phi i1 [%58, %$22], [%67, %$23] ; # Sign
  %71 = phi i64 [%59, %$22], [%68, %$23] ; # N
; # (safe N)
  %72 = inttoptr i64 %18 to i64*
  store i64 %71, i64* %72
; # (? (atom (shift X)) (when (== N ZERO) (divErr Exe)) (let Half (sa...
; # (shift X)
  %73 = inttoptr i64 %69 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
; # (atom (shift X))
  %76 = and i64 %75, 15
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$26, label %$25
$26:
  %78 = phi i64 [%75, %$24] ; # X
  %79 = phi i1 [%70, %$24] ; # Sign
  %80 = phi i64 [%71, %$24] ; # N
; # (when (== N ZERO) (divErr Exe))
; # (== N ZERO)
  %81 = icmp eq i64 %80, 2
  br i1 %81, label %$27, label %$28
$27:
  %82 = phi i64 [%78, %$26] ; # X
  %83 = phi i1 [%79, %$26] ; # Sign
  %84 = phi i64 [%80, %$26] ; # N
; # (divErr Exe)
  call void @divErr(i64 %0)
  unreachable
$28:
  %85 = phi i64 [%78, %$26] ; # X
  %86 = phi i1 [%79, %$26] ; # Sign
  %87 = phi i64 [%80, %$26] ; # N
; # (let Half (save (shru N)) (setq N (divu (set R (addu (val R) Half...
; # (shru N)
  %88 = call i64 @shru(i64 %87)
; # (save (shru N))
  %89 = alloca i64, i64 2, align 16
  %90 = ptrtoint i64* %89 to i64
  %91 = inttoptr i64 %90 to i64*
  store i64 %88, i64* %91
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %90 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %90, i64* %96
; # (set R (addu (val R) Half))
; # (val R)
  %97 = inttoptr i64 %31 to i64*
  %98 = load i64, i64* %97
; # (addu (val R) Half)
  %99 = call i64 @addu(i64 %98, i64 %88)
  %100 = inttoptr i64 %31 to i64*
  store i64 %99, i64* %100
; # (divu (set R (addu (val R) Half)) N)
  %101 = call i64 @divu(i64 %99, i64 %87)
; # (if Sign (neg N) N)
  br i1 %86, label %$29, label %$30
$29:
  %102 = phi i64 [%85, %$28] ; # X
  %103 = phi i1 [%86, %$28] ; # Sign
  %104 = phi i64 [%101, %$28] ; # N
; # (neg N)
  %105 = icmp eq i64 %104, 2
  br i1 %105, label %$32, label %$33
$32:
  br label %$34
$33:
  %106 = xor i64 %104, 8
  br label %$34
$34:
  %107 = phi i64 [%104, %$32], [%106, %$33] ; # ->
  br label %$31
$30:
  %108 = phi i64 [%85, %$28] ; # X
  %109 = phi i1 [%86, %$28] ; # Sign
  %110 = phi i64 [%101, %$28] ; # N
  br label %$31
$31:
  %111 = phi i64 [%102, %$34], [%108, %$30] ; # X
  %112 = phi i1 [%103, %$34], [%109, %$30] ; # Sign
  %113 = phi i64 [%104, %$34], [%110, %$30] ; # N
  %114 = phi i64 [%107, %$34], [%110, %$30] ; # ->
  br label %$19
$25:
  %115 = phi i64 [%75, %$24] ; # X
  %116 = phi i1 [%70, %$24] ; # Sign
  %117 = phi i64 [%71, %$24] ; # N
; # (set R (mulu (val R) N))
; # (val R)
  %118 = inttoptr i64 %31 to i64*
  %119 = load i64, i64* %118
; # (mulu (val R) N)
  %120 = call i64 @mulu(i64 %119, i64 %117)
  %121 = inttoptr i64 %31 to i64*
  store i64 %120, i64* %121
  br label %$12
$19:
  %122 = phi i64 [%54, %$20], [%111, %$31] ; # X
  %123 = phi i1 [%55, %$20], [%112, %$31] ; # Sign
  %124 = phi i64 [%56, %$20], [%114, %$31] ; # ->
  %125 = inttoptr i64 %18 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
  %128 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %127, i64* %128
  br label %$9
$9:
  %129 = phi i64 [%15, %$7], [%122, %$19] ; # X
  %130 = phi i64 [%13, %$7], [%124, %$19] ; # ->
  ret i64 %130
}

define i64 @_div(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (loop (? (atom (shift X)) (let N (val R) (if Sign (neg N) N))) (l...
  br label %$12
$12:
  %38 = phi i64 [%16, %$11], [%94, %$34] ; # X
  %39 = phi i1 [%28, %$11], [%95, %$34] ; # Sign
; # (? (atom (shift X)) (let N (val R) (if Sign (neg N) N)))
; # (shift X)
  %40 = inttoptr i64 %38 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
; # (atom (shift X))
  %43 = and i64 %42, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$13
$15:
  %45 = phi i64 [%42, %$12] ; # X
  %46 = phi i1 [%39, %$12] ; # Sign
; # (let N (val R) (if Sign (neg N) N))
; # (val R)
  %47 = inttoptr i64 %31 to i64*
  %48 = load i64, i64* %47
; # (if Sign (neg N) N)
  br i1 %46, label %$16, label %$17
$16:
  %49 = phi i64 [%45, %$15] ; # X
  %50 = phi i1 [%46, %$15] ; # Sign
; # (neg N)
  %51 = icmp eq i64 %48, 2
  br i1 %51, label %$19, label %$20
$19:
  br label %$21
$20:
  %52 = xor i64 %48, 8
  br label %$21
$21:
  %53 = phi i64 [%48, %$19], [%52, %$20] ; # ->
  br label %$18
$17:
  %54 = phi i64 [%45, %$15] ; # X
  %55 = phi i1 [%46, %$15] ; # Sign
  br label %$18
$18:
  %56 = phi i64 [%49, %$21], [%54, %$17] ; # X
  %57 = phi i1 [%50, %$21], [%55, %$17] ; # Sign
  %58 = phi i64 [%53, %$21], [%48, %$17] ; # ->
  br label %$14
$13:
  %59 = phi i64 [%42, %$12] ; # X
  %60 = phi i1 [%39, %$12] ; # Sign
; # (let N (eval (car X)) (? (nil? N) N) (when (== N ZERO) (divErr Ex...
; # (car X)
  %61 = inttoptr i64 %59 to i64*
  %62 = load i64, i64* %61
; # (eval (car X))
  %63 = and i64 %62, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$24, label %$23
$24:
  br label %$22
$23:
  %65 = and i64 %62, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$26, label %$25
$26:
  %67 = inttoptr i64 %62 to i64*
  %68 = load i64, i64* %67
  br label %$22
$25:
  %69 = call i64 @evList(i64 %62)
  br label %$22
$22:
  %70 = phi i64 [%62, %$24], [%68, %$26], [%69, %$25] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %71, label %$28, label %$27
$28:
  %72 = phi i64 [%59, %$22] ; # X
  %73 = phi i1 [%60, %$22] ; # Sign
  %74 = phi i64 [%70, %$22] ; # N
  br label %$14
$27:
  %75 = phi i64 [%59, %$22] ; # X
  %76 = phi i1 [%60, %$22] ; # Sign
  %77 = phi i64 [%70, %$22] ; # N
; # (when (== N ZERO) (divErr Exe))
; # (== N ZERO)
  %78 = icmp eq i64 %77, 2
  br i1 %78, label %$29, label %$30
$29:
  %79 = phi i64 [%75, %$27] ; # X
  %80 = phi i1 [%76, %$27] ; # Sign
  %81 = phi i64 [%77, %$27] ; # N
; # (divErr Exe)
  call void @divErr(i64 %0)
  unreachable
$30:
  %82 = phi i64 [%75, %$27] ; # X
  %83 = phi i1 [%76, %$27] ; # Sign
  %84 = phi i64 [%77, %$27] ; # N
; # (when (sign? (needNum Exe N)) (setq Sign (not Sign) N (pos N)))
; # (needNum Exe N)
  %85 = and i64 %84, 6
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$32, label %$31
$31:
  call void @numErr(i64 %0, i64 %84)
  unreachable
$32:
; # (sign? (needNum Exe N))
  %87 = and i64 %84, 8
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$33, label %$34
$33:
  %89 = phi i64 [%82, %$32] ; # X
  %90 = phi i1 [%83, %$32] ; # Sign
  %91 = phi i64 [%84, %$32] ; # N
; # (not Sign)
  %92 = icmp eq i1 %90, 0
; # (pos N)
  %93 = and i64 %91, -9
  br label %$34
$34:
  %94 = phi i64 [%82, %$32], [%89, %$33] ; # X
  %95 = phi i1 [%83, %$32], [%92, %$33] ; # Sign
  %96 = phi i64 [%84, %$32], [%93, %$33] ; # N
; # (safe N)
  %97 = inttoptr i64 %18 to i64*
  store i64 %96, i64* %97
; # (set R (divu (val R) N))
; # (val R)
  %98 = inttoptr i64 %31 to i64*
  %99 = load i64, i64* %98
; # (divu (val R) N)
  %100 = call i64 @divu(i64 %99, i64 %96)
  %101 = inttoptr i64 %31 to i64*
  store i64 %100, i64* %101
  br label %$12
$14:
  %102 = phi i64 [%56, %$18], [%72, %$28] ; # X
  %103 = phi i1 [%57, %$18], [%73, %$28] ; # Sign
  %104 = phi i64 [%58, %$18], [%74, %$28] ; # ->
  %105 = inttoptr i64 %18 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %108
  br label %$9
$9:
  %109 = phi i64 [%15, %$7], [%102, %$14] ; # X
  %110 = phi i64 [%13, %$7], [%104, %$14] ; # ->
  ret i64 %110
}

define i64 @_rem(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let (Si...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let (Sign (sign? (needNu...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let (Sign (sign? (needNum Exe @)) R (link (push (pos...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let (Sign (sign? (needNum Exe @)) R (link (push (pos @) NIL))) (...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %27 = and i64 %13, 8
  %28 = icmp ne i64 %27, 0
; # (pos @)
  %29 = and i64 %13, -9
; # (push (pos @) NIL)
  %30 = alloca i64, i64 2, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 %29, i64* %32
; # (link (push (pos @) NIL))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %31 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %31, i64* %37
; # (loop (? (atom (shift X)) (let N (val R) (if Sign (neg N) N))) (l...
  br label %$12
$12:
  %38 = phi i64 [%16, %$11], [%70, %$32] ; # X
; # (? (atom (shift X)) (let N (val R) (if Sign (neg N) N)))
; # (shift X)
  %39 = inttoptr i64 %38 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  %41 = load i64, i64* %40
; # (atom (shift X))
  %42 = and i64 %41, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$15, label %$13
$15:
  %44 = phi i64 [%41, %$12] ; # X
; # (let N (val R) (if Sign (neg N) N))
; # (val R)
  %45 = inttoptr i64 %31 to i64*
  %46 = load i64, i64* %45
; # (if Sign (neg N) N)
  br i1 %28, label %$16, label %$17
$16:
  %47 = phi i64 [%44, %$15] ; # X
; # (neg N)
  %48 = icmp eq i64 %46, 2
  br i1 %48, label %$19, label %$20
$19:
  br label %$21
$20:
  %49 = xor i64 %46, 8
  br label %$21
$21:
  %50 = phi i64 [%46, %$19], [%49, %$20] ; # ->
  br label %$18
$17:
  %51 = phi i64 [%44, %$15] ; # X
  br label %$18
$18:
  %52 = phi i64 [%47, %$21], [%51, %$17] ; # X
  %53 = phi i64 [%50, %$21], [%46, %$17] ; # ->
  br label %$14
$13:
  %54 = phi i64 [%41, %$12] ; # X
; # (let N (eval (car X)) (? (nil? N) N) (when (== N ZERO) (divErr Ex...
; # (car X)
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (eval (car X))
  %57 = and i64 %56, 6
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$24, label %$23
$24:
  br label %$22
$23:
  %59 = and i64 %56, 8
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$26, label %$25
$26:
  %61 = inttoptr i64 %56 to i64*
  %62 = load i64, i64* %61
  br label %$22
$25:
  %63 = call i64 @evList(i64 %56)
  br label %$22
$22:
  %64 = phi i64 [%56, %$24], [%62, %$26], [%63, %$25] ; # ->
; # (? (nil? N) N)
; # (nil? N)
  %65 = icmp eq i64 %64, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %65, label %$28, label %$27
$28:
  %66 = phi i64 [%54, %$22] ; # X
  br label %$14
$27:
  %67 = phi i64 [%54, %$22] ; # X
; # (when (== N ZERO) (divErr Exe))
; # (== N ZERO)
  %68 = icmp eq i64 %64, 2
  br i1 %68, label %$29, label %$30
$29:
  %69 = phi i64 [%67, %$27] ; # X
; # (divErr Exe)
  call void @divErr(i64 %0)
  unreachable
$30:
  %70 = phi i64 [%67, %$27] ; # X
; # (set R (remu (val R) (safe (pos (needNum Exe N)))))
; # (val R)
  %71 = inttoptr i64 %31 to i64*
  %72 = load i64, i64* %71
; # (needNum Exe N)
  %73 = and i64 %64, 6
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$32, label %$31
$31:
  call void @numErr(i64 %0, i64 %64)
  unreachable
$32:
; # (pos (needNum Exe N))
  %75 = and i64 %64, -9
; # (safe (pos (needNum Exe N)))
  %76 = inttoptr i64 %18 to i64*
  store i64 %75, i64* %76
; # (remu (val R) (safe (pos (needNum Exe N))))
  %77 = call i64 @remu(i64 %72, i64 %75)
  %78 = inttoptr i64 %31 to i64*
  store i64 %77, i64* %78
  br label %$12
$14:
  %79 = phi i64 [%52, %$18], [%66, %$28] ; # X
  %80 = phi i64 [%53, %$18], [%64, %$28] ; # ->
  %81 = inttoptr i64 %18 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  br label %$9
$9:
  %85 = phi i64 [%15, %$7], [%79, %$14] ; # X
  %86 = phi i64 [%13, %$7], [%80, %$14] ; # ->
  ret i64 %86
}

define i64 @_shr(i64) {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) Y (eval (cadr X))) (if (or (=0 ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (cadr X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (cadr X))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (if (or (=0 N) (nil? Y) (== ZERO (needNum Exe Y))) Y (let Sign (s...
; # (or (=0 N) (nil? Y) (== ZERO (needNum Exe Y)))
; # (=0 N)
  %18 = icmp eq i64 %4, 0
  br i1 %18, label %$7, label %$8
$8:
  %19 = phi i64 [%4, %$2] ; # N
  %20 = phi i64 [%17, %$2] ; # Y
; # (nil? Y)
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$7, label %$9
$9:
  %22 = phi i64 [%19, %$8] ; # N
  %23 = phi i64 [%20, %$8] ; # Y
; # (needNum Exe Y)
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %23)
  unreachable
$11:
; # (== ZERO (needNum Exe Y))
  %26 = icmp eq i64 2, %23
  br label %$7
$7:
  %27 = phi i64 [%4, %$2], [%19, %$8], [%22, %$11] ; # N
  %28 = phi i64 [%17, %$2], [%20, %$8], [%23, %$11] ; # Y
  %29 = phi i1 [1, %$2], [1, %$8], [%26, %$11] ; # ->
  br i1 %29, label %$12, label %$13
$12:
  %30 = phi i64 [%27, %$7] ; # N
  %31 = phi i64 [%28, %$7] ; # Y
  br label %$14
$13:
  %32 = phi i64 [%27, %$7] ; # N
  %33 = phi i64 [%28, %$7] ; # Y
; # (let Sign (sign? Y) (setq Y (save (pos Y))) (cond ((gt0 N) (while...
; # (sign? Y)
  %34 = and i64 %33, 8
  %35 = icmp ne i64 %34, 0
; # (pos Y)
  %36 = and i64 %33, -9
; # (save (pos Y))
  %37 = alloca i64, i64 2, align 16
  %38 = ptrtoint i64* %37 to i64
  %39 = inttoptr i64 %38 to i64*
  store i64 %36, i64* %39
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = inttoptr i64 %38 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  store i64 %41, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %38, i64* %44
; # (cond ((gt0 N) (while (and (big? Y) (>= N 64)) (setq Y (val (big ...
; # (gt0 N)
  %45 = icmp sgt i64 %32, 0
  br i1 %45, label %$17, label %$16
$17:
  %46 = phi i64 [%32, %$13] ; # N
  %47 = phi i64 [%36, %$13] ; # Y
; # (while (and (big? Y) (>= N 64)) (setq Y (val (big Y))) (unless (d...
  br label %$18
$18:
  %48 = phi i64 [%46, %$17], [%67, %$24] ; # N
  %49 = phi i64 [%47, %$17], [%68, %$24] ; # Y
; # (and (big? Y) (>= N 64))
; # (big? Y)
  %50 = and i64 %49, 4
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = phi i64 [%48, %$18] ; # N
  %53 = phi i64 [%49, %$18] ; # Y
; # (>= N 64)
  %54 = icmp uge i64 %52, 64
  br label %$19
$19:
  %55 = phi i64 [%48, %$18], [%52, %$20] ; # N
  %56 = phi i64 [%49, %$18], [%53, %$20] ; # Y
  %57 = phi i1 [0, %$18], [%54, %$20] ; # ->
  br i1 %57, label %$21, label %$22
$21:
  %58 = phi i64 [%55, %$19] ; # N
  %59 = phi i64 [%56, %$19] ; # Y
; # (big Y)
  %60 = add i64 %59, 4
; # (val (big Y))
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (unless (dec 'N 64) (goto 9))
; # (dec 'N 64)
  %63 = sub i64 %58, 64
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$24, label %$23
$23:
  %65 = phi i64 [%63, %$21] ; # N
  %66 = phi i64 [%62, %$21] ; # Y
; # (goto 9)
  br label %$-9
$24:
  %67 = phi i64 [%63, %$21] ; # N
  %68 = phi i64 [%62, %$21] ; # Y
  br label %$18
$22:
  %69 = phi i64 [%55, %$19] ; # N
  %70 = phi i64 [%56, %$19] ; # Y
; # (shru Y)
  %71 = call i64 @shru(i64 %70)
; # (safe (shru Y))
  %72 = inttoptr i64 %38 to i64*
  store i64 %71, i64* %72
; # (while (dec 'N) (setq Y (half Y)))
  br label %$25
$25:
  %73 = phi i64 [%69, %$22], [%77, %$26] ; # N
  %74 = phi i64 [%71, %$22], [%79, %$26] ; # Y
; # (dec 'N)
  %75 = sub i64 %73, 1
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$26, label %$27
$26:
  %77 = phi i64 [%75, %$25] ; # N
  %78 = phi i64 [%74, %$25] ; # Y
; # (half Y)
  %79 = call i64 @half(i64 %78)
  br label %$25
$27:
  %80 = phi i64 [%75, %$25] ; # N
  %81 = phi i64 [%74, %$25] ; # Y
  br label %$15
$16:
  %82 = phi i64 [%32, %$13] ; # N
  %83 = phi i64 [%36, %$13] ; # Y
; # (while (>= -64 N) (setq Y (safe (consNum 0 Y))) (unless (inc 'N 6...
  br label %$28
$28:
  %84 = phi i64 [%82, %$16], [%95, %$32] ; # N
  %85 = phi i64 [%83, %$16], [%96, %$32] ; # Y
; # (>= -64 N)
  %86 = icmp uge i64 -64, %84
  br i1 %86, label %$29, label %$30
$29:
  %87 = phi i64 [%84, %$28] ; # N
  %88 = phi i64 [%85, %$28] ; # Y
; # (consNum 0 Y)
  %89 = call i64 @consNum(i64 0, i64 %88)
; # (safe (consNum 0 Y))
  %90 = inttoptr i64 %38 to i64*
  store i64 %89, i64* %90
; # (unless (inc 'N 64) (goto 9))
; # (inc 'N 64)
  %91 = add i64 %87, 64
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$32, label %$31
$31:
  %93 = phi i64 [%91, %$29] ; # N
  %94 = phi i64 [%89, %$29] ; # Y
; # (goto 9)
  br label %$-9
$32:
  %95 = phi i64 [%91, %$29] ; # N
  %96 = phi i64 [%89, %$29] ; # Y
  br label %$28
$30:
  %97 = phi i64 [%84, %$28] ; # N
  %98 = phi i64 [%85, %$28] ; # Y
; # (shlu Y)
  %99 = call i64 @shlu(i64 %98)
; # (safe (shlu Y))
  %100 = inttoptr i64 %38 to i64*
  store i64 %99, i64* %100
; # (while (inc 'N) (setq Y (safe (twice Y))))
  br label %$33
$33:
  %101 = phi i64 [%97, %$30], [%105, %$34] ; # N
  %102 = phi i64 [%99, %$30], [%107, %$34] ; # Y
; # (inc 'N)
  %103 = add i64 %101, 1
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$34, label %$35
$34:
  %105 = phi i64 [%103, %$33] ; # N
  %106 = phi i64 [%102, %$33] ; # Y
; # (twice Y)
  %107 = call i64 @twice(i64 %106)
; # (safe (twice Y))
  %108 = inttoptr i64 %38 to i64*
  store i64 %107, i64* %108
  br label %$33
$35:
  %109 = phi i64 [%103, %$33] ; # N
  %110 = phi i64 [%102, %$33] ; # Y
  br label %$15
$15:
  %111 = phi i64 [%80, %$27], [%109, %$35] ; # N
  %112 = phi i64 [%81, %$27], [%110, %$35] ; # Y
; # (: 9 (if Sign (neg Y) Y))
  br label %$-9
$-9:
  %113 = phi i64 [%65, %$23], [%93, %$31], [%111, %$15] ; # N
  %114 = phi i64 [%66, %$23], [%94, %$31], [%112, %$15] ; # Y
; # (if Sign (neg Y) Y)
  br i1 %35, label %$36, label %$37
$36:
  %115 = phi i64 [%113, %$-9] ; # N
  %116 = phi i64 [%114, %$-9] ; # Y
; # (neg Y)
  %117 = icmp eq i64 %116, 2
  br i1 %117, label %$39, label %$40
$39:
  br label %$41
$40:
  %118 = xor i64 %116, 8
  br label %$41
$41:
  %119 = phi i64 [%116, %$39], [%118, %$40] ; # ->
  br label %$38
$37:
  %120 = phi i64 [%113, %$-9] ; # N
  %121 = phi i64 [%114, %$-9] ; # Y
  br label %$38
$38:
  %122 = phi i64 [%115, %$41], [%120, %$37] ; # N
  %123 = phi i64 [%116, %$41], [%121, %$37] ; # Y
  %124 = phi i64 [%119, %$41], [%121, %$37] ; # ->
; # (drop *Safe)
  %125 = inttoptr i64 %38 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
  %128 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %127, i64* %128
  br label %$14
$14:
  %129 = phi i64 [%30, %$12], [%122, %$38] ; # N
  %130 = phi i64 [%31, %$12], [%123, %$38] ; # Y
  %131 = phi i64 [%31, %$12], [%124, %$38] ; # ->
  ret i64 %131
}

define i64 @_lt0(i64) {
$1:
; # (if (and (num? (eval (cadr Exe))) (sign? @)) @ $Nil)
; # (and (num? (eval (cadr Exe))) (sign? @))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (sign? @)
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br label %$2
$2:
  %18 = phi i1 [0, %$3], [%17, %$8] ; # ->
  br i1 %18, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %19 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %19
}

define i64 @_le0(i64) {
$1:
; # (if (and (num? (eval (cadr Exe))) (or (== @ ZERO) (sign? @))) @ $...
; # (and (num? (eval (cadr Exe))) (or (== @ ZERO) (sign? @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (or (== @ ZERO) (sign? @))
; # (== @ ZERO)
  %16 = icmp eq i64 %13, 2
  br i1 %16, label %$9, label %$10
$10:
; # (sign? @)
  %17 = and i64 %13, 8
  %18 = icmp ne i64 %17, 0
  br label %$9
$9:
  %19 = phi i1 [1, %$8], [%18, %$10] ; # ->
  br label %$2
$2:
  %20 = phi i1 [0, %$3], [%19, %$9] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  br label %$13
$12:
  br label %$13
$13:
  %21 = phi i64 [%13, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %21
}

define i64 @_ge0(i64) {
$1:
; # (if (and (num? (eval (cadr Exe))) (not (sign? @))) @ $Nil)
; # (and (num? (eval (cadr Exe))) (not (sign? @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (sign? @)
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
; # (not (sign? @))
  %18 = icmp eq i1 %17, 0
  br label %$2
$2:
  %19 = phi i1 [0, %$3], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_gt0(i64) {
$1:
; # (if (and (num? (eval (cadr Exe))) (<> @ ZERO) (not (sign? @))) @ ...
; # (and (num? (eval (cadr Exe))) (<> @ ZERO) (not (sign? @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$8, label %$2
$8:
; # (<> @ ZERO)
  %16 = icmp ne i64 %13, 2
  br i1 %16, label %$9, label %$2
$9:
; # (sign? @)
  %17 = and i64 %13, 8
  %18 = icmp ne i64 %17, 0
; # (not (sign? @))
  %19 = icmp eq i1 %18, 0
  br label %$2
$2:
  %20 = phi i1 [0, %$3], [0, %$8], [%19, %$9] ; # ->
  br i1 %20, label %$10, label %$11
$10:
  br label %$12
$11:
  br label %$12
$12:
  %21 = phi i64 [%13, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  ret i64 %21
}

define i64 @_abs(i64) {
$1:
; # (if (nil? (eval (cadr Exe))) @ (pos (needNum Exe @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (needNum Exe @)
  %15 = and i64 %13, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %17 = and i64 %13, -9
  br label %$9
$9:
  %18 = phi i64 [%13, %$7], [%17, %$11] ; # ->
  ret i64 %18
}

define i64 @_bitQ(i64) {
$1:
; # (let (X (cdr Exe) N (save (pos (needNum Exe (eval (++ X)))))) (lo...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (pos (needNum Exe (eval (++ X))))
  %18 = and i64 %15, -9
; # (save (pos (needNum Exe (eval (++ X)))))
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %18, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (loop (? (atom X) N) (let Y (eval (++ X)) (? (nil? Y) Y) (setq Y ...
  br label %$9
$9:
  %27 = phi i64 [%7, %$8], [%110, %$31] ; # X
; # (? (atom X) N)
; # (atom X)
  %28 = and i64 %27, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$10
$12:
  %30 = phi i64 [%27, %$9] ; # X
  br label %$11
$10:
  %31 = phi i64 [%27, %$9] ; # X
; # (let Y (eval (++ X)) (? (nil? Y) Y) (setq Y (pos (needNum Exe Y))...
; # (++ X)
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
  %34 = getelementptr i64, i64* %32, i32 1
  %35 = load i64, i64* %34
; # (eval (++ X))
  %36 = and i64 %33, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$15, label %$14
$15:
  br label %$13
$14:
  %38 = and i64 %33, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$17, label %$16
$17:
  %40 = inttoptr i64 %33 to i64*
  %41 = load i64, i64* %40
  br label %$13
$16:
  %42 = call i64 @evList(i64 %33)
  br label %$13
$13:
  %43 = phi i64 [%33, %$15], [%41, %$17], [%42, %$16] ; # ->
; # (? (nil? Y) Y)
; # (nil? Y)
  %44 = icmp eq i64 %43, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %44, label %$19, label %$18
$19:
  %45 = phi i64 [%35, %$13] ; # X
  %46 = phi i64 [%43, %$13] ; # Y
  br label %$11
$18:
  %47 = phi i64 [%35, %$13] ; # X
  %48 = phi i64 [%43, %$13] ; # Y
; # (needNum Exe Y)
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$21, label %$20
$20:
  call void @numErr(i64 %0, i64 %48)
  unreachable
$21:
; # (pos (needNum Exe Y))
  %51 = and i64 %48, -9
; # (let Z N (while (big? Z) (unless (big? Y) (ret $Nil)) (let (A (va...
; # (while (big? Z) (unless (big? Y) (ret $Nil)) (let (A (val (dig Y)...
  br label %$22
$22:
  %52 = phi i64 [%47, %$21], [%87, %$28] ; # X
  %53 = phi i64 [%51, %$21], [%74, %$28] ; # Y
  %54 = phi i64 [%18, %$21], [%77, %$28] ; # Z
; # (big? Z)
  %55 = and i64 %54, 4
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$23, label %$24
$23:
  %57 = phi i64 [%52, %$22] ; # X
  %58 = phi i64 [%53, %$22] ; # Y
  %59 = phi i64 [%54, %$22] ; # Z
; # (unless (big? Y) (ret $Nil))
; # (big? Y)
  %60 = and i64 %58, 4
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$26, label %$25
$25:
  %62 = phi i64 [%57, %$23] ; # X
  %63 = phi i64 [%58, %$23] ; # Y
  %64 = phi i64 [%59, %$23] ; # Z
; # (ret $Nil)
; # (drop *Safe)
  %65 = inttoptr i64 %20 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %68
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$26:
  %69 = phi i64 [%57, %$23] ; # X
  %70 = phi i64 [%58, %$23] ; # Y
  %71 = phi i64 [%59, %$23] ; # Z
; # (let (A (val (dig Y)) B (val (dig Z))) (unless (== B (& A B)) (re...
; # (dig Y)
  %72 = add i64 %70, -4
; # (val (dig Y))
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
; # (dig Z)
  %75 = add i64 %71, -4
; # (val (dig Z))
  %76 = inttoptr i64 %75 to i64*
  %77 = load i64, i64* %76
; # (unless (== B (& A B)) (ret $Nil))
; # (& A B)
  %78 = and i64 %74, %77
; # (== B (& A B))
  %79 = icmp eq i64 %77, %78
  br i1 %79, label %$28, label %$27
$27:
  %80 = phi i64 [%69, %$26] ; # X
  %81 = phi i64 [%70, %$26] ; # Y
  %82 = phi i64 [%71, %$26] ; # Z
; # (ret $Nil)
; # (drop *Safe)
  %83 = inttoptr i64 %20 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  %85 = load i64, i64* %84
  %86 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %85, i64* %86
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$28:
  %87 = phi i64 [%69, %$26] ; # X
  %88 = phi i64 [%70, %$26] ; # Y
  %89 = phi i64 [%71, %$26] ; # Z
  br label %$22
$24:
  %90 = phi i64 [%52, %$22] ; # X
  %91 = phi i64 [%53, %$22] ; # Y
  %92 = phi i64 [%54, %$22] ; # Z
; # (when (big? Y) (setq Z (int Z) Y (val (dig Y))))
; # (big? Y)
  %93 = and i64 %91, 4
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$29, label %$30
$29:
  %95 = phi i64 [%90, %$24] ; # X
  %96 = phi i64 [%91, %$24] ; # Y
  %97 = phi i64 [%92, %$24] ; # Z
; # (int Z)
  %98 = lshr i64 %97, 4
; # (dig Y)
  %99 = add i64 %96, -4
; # (val (dig Y))
  %100 = inttoptr i64 %99 to i64*
  %101 = load i64, i64* %100
  br label %$30
$30:
  %102 = phi i64 [%90, %$24], [%95, %$29] ; # X
  %103 = phi i64 [%91, %$24], [%101, %$29] ; # Y
  %104 = phi i64 [%92, %$24], [%98, %$29] ; # Z
; # (? (<> Z (& Y Z)) $Nil)
; # (& Y Z)
  %105 = and i64 %103, %104
; # (<> Z (& Y Z))
  %106 = icmp ne i64 %104, %105
  br i1 %106, label %$32, label %$31
$32:
  %107 = phi i64 [%102, %$30] ; # X
  %108 = phi i64 [%103, %$30] ; # Y
  %109 = phi i64 [%104, %$30] ; # Z
  br label %$11
$31:
  %110 = phi i64 [%102, %$30] ; # X
  %111 = phi i64 [%103, %$30] ; # Y
  %112 = phi i64 [%104, %$30] ; # Z
  br label %$9
$11:
  %113 = phi i64 [%30, %$12], [%45, %$19], [%107, %$32] ; # X
  %114 = phi i64 [%18, %$12], [%46, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$32] ; # ->
; # (drop *Safe)
  %115 = inttoptr i64 %20 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  %117 = load i64, i64* %116
  %118 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %117, i64* %118
  ret i64 %114
}

define i64 @_bitAnd(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (pos (...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (pos (needNum Exe @)) NIL)) (loop ...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let R (link (push (pos (needNum Exe @)) NIL)) (loop (? (atom (sh...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %27 = and i64 %13, -9
; # (push (pos (needNum Exe @)) NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
; # (link (push (pos (needNum Exe @)) NIL))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %36 = phi i64 [%16, %$11], [%58, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (atom (shift X))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$15, label %$13
$15:
  %42 = phi i64 [%39, %$12] ; # X
; # (val R)
  %43 = inttoptr i64 %29 to i64*
  %44 = load i64, i64* %43
  br label %$14
$13:
  %45 = phi i64 [%39, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$17
$18:
  br label %$16
$17:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$16
$19:
  %54 = call i64 @evList(i64 %47)
  br label %$16
$16:
  %55 = phi i64 [%47, %$18], [%53, %$20], [%54, %$19] ; # ->
; # (nil? (eval (car X)))
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%45, %$16] ; # X
  br label %$14
$21:
  %58 = phi i64 [%45, %$16] ; # X
; # (needNum Exe @)
  %59 = and i64 %55, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %55)
  unreachable
$24:
; # (safe (needNum Exe @))
  %61 = inttoptr i64 %18 to i64*
  store i64 %55, i64* %61
; # (set R (andu (val R) (pos @)))
; # (val R)
  %62 = inttoptr i64 %29 to i64*
  %63 = load i64, i64* %62
; # (pos @)
  %64 = and i64 %55, -9
; # (andu (val R) (pos @))
  %65 = call i64 @andu(i64 %63, i64 %64)
  %66 = inttoptr i64 %29 to i64*
  store i64 %65, i64* %66
  br label %$12
$14:
  %67 = phi i64 [%42, %$15], [%57, %$22] ; # X
  %68 = phi i64 [%44, %$15], [%55, %$22] ; # ->
  %69 = inttoptr i64 %18 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  br label %$9
$9:
  %73 = phi i64 [%15, %$7], [%67, %$14] ; # X
  %74 = phi i64 [%13, %$7], [%68, %$14] ; # ->
  ret i64 %74
}

define i64 @_bitOr(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (pos (...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (pos (needNum Exe @)) NIL)) (loop ...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let R (link (push (pos (needNum Exe @)) NIL)) (loop (? (atom (sh...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %27 = and i64 %13, -9
; # (push (pos (needNum Exe @)) NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
; # (link (push (pos (needNum Exe @)) NIL))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %36 = phi i64 [%16, %$11], [%58, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (atom (shift X))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$15, label %$13
$15:
  %42 = phi i64 [%39, %$12] ; # X
; # (val R)
  %43 = inttoptr i64 %29 to i64*
  %44 = load i64, i64* %43
  br label %$14
$13:
  %45 = phi i64 [%39, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$17
$18:
  br label %$16
$17:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$16
$19:
  %54 = call i64 @evList(i64 %47)
  br label %$16
$16:
  %55 = phi i64 [%47, %$18], [%53, %$20], [%54, %$19] ; # ->
; # (nil? (eval (car X)))
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%45, %$16] ; # X
  br label %$14
$21:
  %58 = phi i64 [%45, %$16] ; # X
; # (needNum Exe @)
  %59 = and i64 %55, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %55)
  unreachable
$24:
; # (safe (needNum Exe @))
  %61 = inttoptr i64 %18 to i64*
  store i64 %55, i64* %61
; # (set R (oru (val R) (pos @)))
; # (val R)
  %62 = inttoptr i64 %29 to i64*
  %63 = load i64, i64* %62
; # (pos @)
  %64 = and i64 %55, -9
; # (oru (val R) (pos @))
  %65 = call i64 @oru(i64 %63, i64 %64)
  %66 = inttoptr i64 %29 to i64*
  store i64 %65, i64* %66
  br label %$12
$14:
  %67 = phi i64 [%42, %$15], [%57, %$22] ; # X
  %68 = phi i64 [%44, %$15], [%55, %$22] ; # ->
  %69 = inttoptr i64 %18 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  br label %$9
$9:
  %73 = phi i64 [%15, %$7], [%67, %$14] ; # X
  %74 = phi i64 [%13, %$7], [%68, %$14] ; # ->
  ret i64 %74
}

define i64 @_bitXor(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (save -ZERO (let R (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (save -ZERO (let R (link (push (pos (...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %16 = phi i64 [%3, %$2] ; # X
; # (save -ZERO (let R (link (push (pos (needNum Exe @)) NIL)) (loop ...
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 10, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (let R (link (push (pos (needNum Exe @)) NIL)) (loop (? (atom (sh...
; # (needNum Exe @)
  %25 = and i64 %13, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (pos (needNum Exe @))
  %27 = and i64 %13, -9
; # (push (pos (needNum Exe @)) NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
; # (link (push (pos (needNum Exe @)) NIL))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (loop (? (atom (shift X)) (val R)) (? (nil? (eval (car X))) @) (s...
  br label %$12
$12:
  %36 = phi i64 [%16, %$11], [%58, %$24] ; # X
; # (? (atom (shift X)) (val R))
; # (shift X)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (atom (shift X))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$15, label %$13
$15:
  %42 = phi i64 [%39, %$12] ; # X
; # (val R)
  %43 = inttoptr i64 %29 to i64*
  %44 = load i64, i64* %43
  br label %$14
$13:
  %45 = phi i64 [%39, %$12] ; # X
; # (? (nil? (eval (car X))) @)
; # (car X)
  %46 = inttoptr i64 %45 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$17
$18:
  br label %$16
$17:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$20:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$16
$19:
  %54 = call i64 @evList(i64 %47)
  br label %$16
$16:
  %55 = phi i64 [%47, %$18], [%53, %$20], [%54, %$19] ; # ->
; # (nil? (eval (car X)))
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%45, %$16] ; # X
  br label %$14
$21:
  %58 = phi i64 [%45, %$16] ; # X
; # (needNum Exe @)
  %59 = and i64 %55, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$23:
  call void @numErr(i64 %0, i64 %55)
  unreachable
$24:
; # (safe (needNum Exe @))
  %61 = inttoptr i64 %18 to i64*
  store i64 %55, i64* %61
; # (set R (xoru (val R) (pos @)))
; # (val R)
  %62 = inttoptr i64 %29 to i64*
  %63 = load i64, i64* %62
; # (pos @)
  %64 = and i64 %55, -9
; # (xoru (val R) (pos @))
  %65 = call i64 @xoru(i64 %63, i64 %64)
  %66 = inttoptr i64 %29 to i64*
  store i64 %65, i64* %66
  br label %$12
$14:
  %67 = phi i64 [%42, %$15], [%57, %$22] ; # X
  %68 = phi i64 [%44, %$15], [%55, %$22] ; # ->
  %69 = inttoptr i64 %18 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  br label %$9
$9:
  %73 = phi i64 [%15, %$7], [%67, %$14] ; # X
  %74 = phi i64 [%13, %$7], [%68, %$14] ; # ->
  ret i64 %74
}

define i64 @_sqrt(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (when (sign? (needNu...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (when (sign? (needNum Exe @)) (argErr...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (when (sign? (needNum Exe @)) (argErr Exe @))
; # (needNum Exe @)
  %15 = and i64 %13, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$10
$10:
  call void @numErr(i64 %0, i64 %13)
  unreachable
$11:
; # (sign? (needNum Exe @))
  %17 = and i64 %13, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$12, label %$13
$12:
; # (argErr Exe @)
  call void @argErr(i64 %0, i64 %13)
  unreachable
$13:
; # (let (Y (save @) Z (save (eval (cadr X)))) (when (num? Z) (setq Y...
; # (save @)
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %13, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (cadr X)
  %27 = inttoptr i64 %3 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (cadr X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$16, label %$15
$16:
  br label %$14
$15:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$18, label %$17
$18:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$14
$17:
  %38 = call i64 @evList(i64 %31)
  br label %$14
$14:
  %39 = phi i64 [%31, %$16], [%37, %$18], [%38, %$17] ; # ->
; # (save (eval (cadr X)))
  %40 = alloca i64, i64 2, align 16
  %41 = ptrtoint i64* %40 to i64
  %42 = inttoptr i64 %41 to i64*
  store i64 %39, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %44 = load i64, i64* %43
  %45 = inttoptr i64 %41 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  store i64 %44, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %41, i64* %47
; # (when (num? Z) (setq Y (safe (mulu Y Z))))
; # (num? Z)
  %48 = and i64 %39, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$19, label %$20
$19:
  %50 = phi i64 [%13, %$14] ; # Y
; # (mulu Y Z)
  %51 = call i64 @mulu(i64 %50, i64 %39)
; # (safe (mulu Y Z))
  %52 = inttoptr i64 %20 to i64*
  store i64 %51, i64* %52
  br label %$20
$20:
  %53 = phi i64 [%13, %$14], [%51, %$19] ; # Y
; # (prog1 (if (cnt? Y) (let (M (hex "400000000000000") R 0) (setq Y ...
; # (if (cnt? Y) (let (M (hex "400000000000000") R 0) (setq Y (int Y)...
; # (cnt? Y)
  %54 = and i64 %53, 2
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$21, label %$22
$21:
  %56 = phi i64 [%53, %$20] ; # Y
; # (let (M (hex "400000000000000") R 0) (setq Y (int Y)) (loop (let ...
; # (int Y)
  %57 = lshr i64 %56, 4
; # (loop (let N (+ R M) (when (>= Y N) (dec 'Y N) (setq R (+ N M))))...
  br label %$24
$24:
  %58 = phi i64 [%57, %$21], [%74, %$27] ; # Y
  %59 = phi i64 [288230376151711744, %$21], [%75, %$27] ; # M
  %60 = phi i64 [0, %$21], [%76, %$27] ; # R
; # (let N (+ R M) (when (>= Y N) (dec 'Y N) (setq R (+ N M))))
; # (+ R M)
  %61 = add i64 %60, %59
; # (when (>= Y N) (dec 'Y N) (setq R (+ N M)))
; # (>= Y N)
  %62 = icmp uge i64 %58, %61
  br i1 %62, label %$25, label %$26
$25:
  %63 = phi i64 [%58, %$24] ; # Y
  %64 = phi i64 [%59, %$24] ; # M
  %65 = phi i64 [%60, %$24] ; # R
; # (dec 'Y N)
  %66 = sub i64 %63, %61
; # (+ N M)
  %67 = add i64 %61, %64
  br label %$26
$26:
  %68 = phi i64 [%58, %$24], [%66, %$25] ; # Y
  %69 = phi i64 [%59, %$24], [%64, %$25] ; # M
  %70 = phi i64 [%60, %$24], [%67, %$25] ; # R
; # (shr R 1)
  %71 = lshr i64 %70, 1
; # (? (=0 (setq M (shr M 2))))
; # (shr M 2)
  %72 = lshr i64 %69, 2
; # (=0 (setq M (shr M 2)))
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %$28, label %$27
$27:
  %74 = phi i64 [%68, %$26] ; # Y
  %75 = phi i64 [%72, %$26] ; # M
  %76 = phi i64 [%71, %$26] ; # R
  br label %$24
$28:
  %77 = phi i64 [%68, %$26] ; # Y
  %78 = phi i64 [%72, %$26] ; # M
  %79 = phi i64 [%71, %$26] ; # R
  %80 = phi i64 [0, %$26] ; # ->
; # (or (nil? Z) (>= R Y) (inc 'R))
; # (nil? Z)
  %81 = icmp eq i64 %39, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %81, label %$29, label %$30
$30:
  %82 = phi i64 [%77, %$28] ; # Y
  %83 = phi i64 [%78, %$28] ; # M
  %84 = phi i64 [%79, %$28] ; # R
; # (>= R Y)
  %85 = icmp uge i64 %84, %82
  br i1 %85, label %$29, label %$31
$31:
  %86 = phi i64 [%82, %$30] ; # Y
  %87 = phi i64 [%83, %$30] ; # M
  %88 = phi i64 [%84, %$30] ; # R
; # (inc 'R)
  %89 = add i64 %88, 1
  %90 = icmp ne i64 %89, 0
  br label %$29
$29:
  %91 = phi i64 [%77, %$28], [%82, %$30], [%86, %$31] ; # Y
  %92 = phi i64 [%78, %$28], [%83, %$30], [%87, %$31] ; # M
  %93 = phi i64 [%79, %$28], [%84, %$30], [%89, %$31] ; # R
  %94 = phi i1 [1, %$28], [1, %$30], [%90, %$31] ; # ->
; # (cnt R)
  %95 = shl i64 %93, 4
  %96 = or i64 %95, 2
  br label %$23
$22:
  %97 = phi i64 [%53, %$20] ; # Y
; # (let (M (consNum 0 ONE) M* (link (push M NIL)) R (link (push ZERO...
; # (consNum 0 ONE)
  %98 = call i64 @consNum(i64 0, i64 18)
; # (push M NIL)
  %99 = alloca i64, i64 2, align 16
  %100 = ptrtoint i64* %99 to i64
  %101 = inttoptr i64 %100 to i64*
  store i64 %98, i64* %101
; # (link (push M NIL))
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %103 = load i64, i64* %102
  %104 = inttoptr i64 %100 to i64*
  %105 = getelementptr i64, i64* %104, i32 1
  store i64 %103, i64* %105
  %106 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %100, i64* %106
; # (push ZERO NIL)
  %107 = alloca i64, i64 2, align 16
  %108 = ptrtoint i64* %107 to i64
  %109 = inttoptr i64 %108 to i64*
  store i64 2, i64* %109
; # (link (push ZERO NIL))
  %110 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %111 = load i64, i64* %110
  %112 = inttoptr i64 %108 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  store i64 %111, i64* %113
  %114 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %108, i64* %114
; # (dig Y)
  %115 = add i64 %97, -4
; # (val (dig Y))
  %116 = inttoptr i64 %115 to i64*
  %117 = load i64, i64* %116
; # (boxNum (val (dig Y)))
  %118 = call i64 @boxNum(i64 %117)
; # (push C NIL)
  %119 = alloca i64, i64 2, align 16
  %120 = ptrtoint i64* %119 to i64
  %121 = inttoptr i64 %120 to i64*
  store i64 %118, i64* %121
; # (link (push C NIL))
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %123 = load i64, i64* %122
  %124 = inttoptr i64 %120 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  store i64 %123, i64* %125
  %126 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %120, i64* %126
; # (while (big? (setq Y (val (big Y)))) (setq C (set (big C) (boxNum...
  br label %$32
$32:
  %127 = phi i64 [%97, %$22], [%136, %$33] ; # Y
  %128 = phi i64 [%98, %$22], [%146, %$33] ; # M
  %129 = phi i64 [%108, %$22], [%138, %$33] ; # R
  %130 = phi i64 [%118, %$22], [%144, %$33] ; # C
; # (big Y)
  %131 = add i64 %127, 4
; # (val (big Y))
  %132 = inttoptr i64 %131 to i64*
  %133 = load i64, i64* %132
; # (big? (setq Y (val (big Y))))
  %134 = and i64 %133, 4
  %135 = icmp ne i64 %134, 0
  br i1 %135, label %$33, label %$34
$33:
  %136 = phi i64 [%133, %$32] ; # Y
  %137 = phi i64 [%128, %$32] ; # M
  %138 = phi i64 [%129, %$32] ; # R
  %139 = phi i64 [%130, %$32] ; # C
; # (set (big C) (boxNum (val (dig Y))))
; # (big C)
  %140 = add i64 %139, 4
; # (dig Y)
  %141 = add i64 %136, -4
; # (val (dig Y))
  %142 = inttoptr i64 %141 to i64*
  %143 = load i64, i64* %142
; # (boxNum (val (dig Y)))
  %144 = call i64 @boxNum(i64 %143)
  %145 = inttoptr i64 %140 to i64*
  store i64 %144, i64* %145
; # (set M* (consNum 0 M))
; # (consNum 0 M)
  %146 = call i64 @consNum(i64 0, i64 %137)
  %147 = inttoptr i64 %100 to i64*
  store i64 %146, i64* %147
  br label %$32
$34:
  %148 = phi i64 [%133, %$32] ; # Y
  %149 = phi i64 [%128, %$32] ; # M
  %150 = phi i64 [%129, %$32] ; # R
  %151 = phi i64 [%130, %$32] ; # C
; # (set (big C) Y)
; # (big C)
  %152 = add i64 %151, 4
  %153 = inttoptr i64 %152 to i64*
  store i64 %148, i64* %153
; # (val C*)
  %154 = inttoptr i64 %120 to i64*
  %155 = load i64, i64* %154
; # (safe (val C*))
  %156 = inttoptr i64 %20 to i64*
  store i64 %155, i64* %156
; # (while (le0 (cmpu M Y)) (twiceBig M) (twiceBig M))
  br label %$35
$35:
  %157 = phi i64 [%155, %$34], [%163, %$36] ; # Y
  %158 = phi i64 [%149, %$34], [%164, %$36] ; # M
  %159 = phi i64 [%150, %$34], [%165, %$36] ; # R
  %160 = phi i64 [%151, %$34], [%166, %$36] ; # C
; # (cmpu M Y)
  %161 = call i64 @cmpu(i64 %158, i64 %157)
; # (le0 (cmpu M Y))
  %162 = icmp sle i64 %161, 0
  br i1 %162, label %$36, label %$37
$36:
  %163 = phi i64 [%157, %$35] ; # Y
  %164 = phi i64 [%158, %$35] ; # M
  %165 = phi i64 [%159, %$35] ; # R
  %166 = phi i64 [%160, %$35] ; # C
; # (twiceBig M)
  %167 = call i64 @twiceBig(i64 %164)
; # (twiceBig M)
  %168 = call i64 @twiceBig(i64 %164)
  br label %$35
$37:
  %169 = phi i64 [%157, %$35] ; # Y
  %170 = phi i64 [%158, %$35] ; # M
  %171 = phi i64 [%159, %$35] ; # R
  %172 = phi i64 [%160, %$35] ; # C
; # (loop (let N (set C* (addu (val R) M)) (when (ge0 (cmpu Y N)) (se...
  br label %$38
$38:
  %173 = phi i64 [%169, %$37], [%203, %$41] ; # Y
  %174 = phi i64 [%170, %$37], [%204, %$41] ; # M
  %175 = phi i64 [%171, %$37], [%205, %$41] ; # R
  %176 = phi i64 [%172, %$37], [%206, %$41] ; # C
; # (let N (set C* (addu (val R) M)) (when (ge0 (cmpu Y N)) (setq Y (...
; # (set C* (addu (val R) M))
; # (val R)
  %177 = inttoptr i64 %175 to i64*
  %178 = load i64, i64* %177
; # (addu (val R) M)
  %179 = call i64 @addu(i64 %178, i64 %174)
  %180 = inttoptr i64 %120 to i64*
  store i64 %179, i64* %180
; # (when (ge0 (cmpu Y N)) (setq Y (safe (subu Y N))) (set R (addu N ...
; # (cmpu Y N)
  %181 = call i64 @cmpu(i64 %173, i64 %179)
; # (ge0 (cmpu Y N))
  %182 = icmp sge i64 %181, 0
  br i1 %182, label %$39, label %$40
$39:
  %183 = phi i64 [%173, %$38] ; # Y
  %184 = phi i64 [%174, %$38] ; # M
  %185 = phi i64 [%175, %$38] ; # R
  %186 = phi i64 [%176, %$38] ; # C
; # (subu Y N)
  %187 = call i64 @subu(i64 %183, i64 %179)
; # (safe (subu Y N))
  %188 = inttoptr i64 %20 to i64*
  store i64 %187, i64* %188
; # (set R (addu N M))
; # (addu N M)
  %189 = call i64 @addu(i64 %179, i64 %184)
  %190 = inttoptr i64 %185 to i64*
  store i64 %189, i64* %190
  br label %$40
$40:
  %191 = phi i64 [%173, %$38], [%187, %$39] ; # Y
  %192 = phi i64 [%174, %$38], [%184, %$39] ; # M
  %193 = phi i64 [%175, %$38], [%185, %$39] ; # R
  %194 = phi i64 [%176, %$38], [%186, %$39] ; # C
; # (set R (half (val R)))
; # (val R)
  %195 = inttoptr i64 %193 to i64*
  %196 = load i64, i64* %195
; # (half (val R))
  %197 = call i64 @half(i64 %196)
  %198 = inttoptr i64 %193 to i64*
  store i64 %197, i64* %198
; # (? (== ZERO (setq M (set M* (half (half M))))))
; # (set M* (half (half M)))
; # (half M)
  %199 = call i64 @half(i64 %192)
; # (half (half M))
  %200 = call i64 @half(i64 %199)
  %201 = inttoptr i64 %100 to i64*
  store i64 %200, i64* %201
; # (== ZERO (setq M (set M* (half (half M)))))
  %202 = icmp eq i64 2, %200
  br i1 %202, label %$42, label %$41
$41:
  %203 = phi i64 [%191, %$40] ; # Y
  %204 = phi i64 [%200, %$40] ; # M
  %205 = phi i64 [%193, %$40] ; # R
  %206 = phi i64 [%194, %$40] ; # C
  br label %$38
$42:
  %207 = phi i64 [%191, %$40] ; # Y
  %208 = phi i64 [%200, %$40] ; # M
  %209 = phi i64 [%193, %$40] ; # R
  %210 = phi i64 [%194, %$40] ; # C
  %211 = phi i64 [0, %$40] ; # ->
; # (val R)
  %212 = inttoptr i64 %209 to i64*
  %213 = load i64, i64* %212
; # (if (or (nil? Z) (ge0 (cmpu R Y))) R (addu R ONE))
; # (or (nil? Z) (ge0 (cmpu R Y)))
; # (nil? Z)
  %214 = icmp eq i64 %39, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %214, label %$43, label %$44
$44:
  %215 = phi i64 [%207, %$42] ; # Y
  %216 = phi i64 [%208, %$42] ; # M
  %217 = phi i64 [%213, %$42] ; # R
  %218 = phi i64 [%210, %$42] ; # C
; # (cmpu R Y)
  %219 = call i64 @cmpu(i64 %217, i64 %215)
; # (ge0 (cmpu R Y))
  %220 = icmp sge i64 %219, 0
  br label %$43
$43:
  %221 = phi i64 [%207, %$42], [%215, %$44] ; # Y
  %222 = phi i64 [%208, %$42], [%216, %$44] ; # M
  %223 = phi i64 [%213, %$42], [%217, %$44] ; # R
  %224 = phi i64 [%210, %$42], [%218, %$44] ; # C
  %225 = phi i1 [1, %$42], [%220, %$44] ; # ->
  br i1 %225, label %$45, label %$46
$45:
  %226 = phi i64 [%221, %$43] ; # Y
  %227 = phi i64 [%222, %$43] ; # M
  %228 = phi i64 [%223, %$43] ; # R
  %229 = phi i64 [%224, %$43] ; # C
  br label %$47
$46:
  %230 = phi i64 [%221, %$43] ; # Y
  %231 = phi i64 [%222, %$43] ; # M
  %232 = phi i64 [%223, %$43] ; # R
  %233 = phi i64 [%224, %$43] ; # C
; # (addu R ONE)
  %234 = call i64 @addu(i64 %232, i64 18)
  br label %$47
$47:
  %235 = phi i64 [%226, %$45], [%230, %$46] ; # Y
  %236 = phi i64 [%227, %$45], [%231, %$46] ; # M
  %237 = phi i64 [%228, %$45], [%232, %$46] ; # R
  %238 = phi i64 [%229, %$45], [%233, %$46] ; # C
  %239 = phi i64 [%228, %$45], [%234, %$46] ; # ->
  br label %$23
$23:
  %240 = phi i64 [%91, %$29], [%235, %$47] ; # Y
  %241 = phi i64 [%96, %$29], [%239, %$47] ; # ->
; # (drop *Safe)
  %242 = inttoptr i64 %20 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
  %245 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %244, i64* %245
  br label %$9
$9:
  %246 = phi i64 [%13, %$7], [%241, %$23] ; # ->
  ret i64 %246
}

define i64 @initSeed(i64) {
$1:
; # (let C 0 (while (pair X) (inc 'C (initSeed (++ X)))) (unless (nil...
; # (while (pair X) (inc 'C (initSeed (++ X))))
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%10, %$3] ; # X
  %2 = phi i64 [0, %$1], [%12, %$3] ; # C
; # (pair X)
  %3 = and i64 %1, 15
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$3, label %$4
$3:
  %5 = phi i64 [%1, %$2] ; # X
  %6 = phi i64 [%2, %$2] ; # C
; # (++ X)
  %7 = inttoptr i64 %5 to i64*
  %8 = load i64, i64* %7
  %9 = getelementptr i64, i64* %7, i32 1
  %10 = load i64, i64* %9
; # (initSeed (++ X))
  %11 = call i64 @initSeed(i64 %8)
; # (inc 'C (initSeed (++ X)))
  %12 = add i64 %6, %11
  br label %$2
$4:
  %13 = phi i64 [%1, %$2] ; # X
  %14 = phi i64 [%2, %$2] ; # C
; # (unless (nil? X) (unless (num? X) (setq X (name (& (val (tail X))...
; # (nil? X)
  %15 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$6, label %$5
$5:
  %16 = phi i64 [%13, %$4] ; # X
  %17 = phi i64 [%14, %$4] ; # C
; # (unless (num? X) (setq X (name (& (val (tail X)) -9))))
; # (num? X)
  %18 = and i64 %16, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$7:
  %20 = phi i64 [%16, %$5] ; # X
  %21 = phi i64 [%17, %$5] ; # C
; # (tail X)
  %22 = add i64 %20, -8
; # (val (tail X))
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (& (val (tail X)) -9)
  %25 = and i64 %24, -9
; # (name (& (val (tail X)) -9))
  br label %$9
$9:
  %26 = phi i64 [%25, %$7], [%32, %$10] ; # Tail
  %27 = and i64 %26, 6
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$11, label %$10
$10:
  %29 = phi i64 [%26, %$9] ; # Tail
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  br label %$9
$11:
  %33 = phi i64 [%26, %$9] ; # Tail
  br label %$8
$8:
  %34 = phi i64 [%16, %$5], [%33, %$11] ; # X
  %35 = phi i64 [%17, %$5], [%21, %$11] ; # C
; # (if (cnt? X) (inc 'C (shr X 3)) (when (sign? X) (inc 'C) (setq X ...
; # (cnt? X)
  %36 = and i64 %34, 2
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = phi i64 [%34, %$8] ; # X
  %39 = phi i64 [%35, %$8] ; # C
; # (shr X 3)
  %40 = lshr i64 %38, 3
; # (inc 'C (shr X 3))
  %41 = add i64 %39, %40
  br label %$14
$13:
  %42 = phi i64 [%34, %$8] ; # X
  %43 = phi i64 [%35, %$8] ; # C
; # (when (sign? X) (inc 'C) (setq X (pos X)))
; # (sign? X)
  %44 = and i64 %42, 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$15, label %$16
$15:
  %46 = phi i64 [%42, %$13] ; # X
  %47 = phi i64 [%43, %$13] ; # C
; # (inc 'C)
  %48 = add i64 %47, 1
; # (pos X)
  %49 = and i64 %46, -9
  br label %$16
$16:
  %50 = phi i64 [%42, %$13], [%49, %$15] ; # X
  %51 = phi i64 [%43, %$13], [%48, %$15] ; # C
; # (loop (inc 'C (val (dig X))) (? (cnt? (setq X (val (big X))))))
  br label %$17
$17:
  %52 = phi i64 [%50, %$16], [%63, %$18] ; # X
  %53 = phi i64 [%51, %$16], [%64, %$18] ; # C
; # (dig X)
  %54 = add i64 %52, -4
; # (val (dig X))
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (inc 'C (val (dig X)))
  %57 = add i64 %53, %56
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %58 = add i64 %52, 4
; # (val (big X))
  %59 = inttoptr i64 %58 to i64*
  %60 = load i64, i64* %59
; # (cnt? (setq X (val (big X))))
  %61 = and i64 %60, 2
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$18
$18:
  %63 = phi i64 [%60, %$17] ; # X
  %64 = phi i64 [%57, %$17] ; # C
  br label %$17
$19:
  %65 = phi i64 [%60, %$17] ; # X
  %66 = phi i64 [%57, %$17] ; # C
  %67 = phi i64 [0, %$17] ; # ->
; # (int X)
  %68 = lshr i64 %65, 4
; # (inc 'C (int X))
  %69 = add i64 %66, %68
  br label %$14
$14:
  %70 = phi i64 [%38, %$12], [%65, %$19] ; # X
  %71 = phi i64 [%41, %$12], [%69, %$19] ; # C
  %72 = phi i64 [%41, %$12], [%69, %$19] ; # ->
  br label %$6
$6:
  %73 = phi i64 [%13, %$4], [%70, %$14] ; # X
  %74 = phi i64 [%14, %$4], [%71, %$14] ; # C
  ret i64 %74
}

define i64 @_seed(i64) {
$1:
; # (let N (mul 6364136223846793005 (initSeed (eval (cadr Exe)))) (se...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (initSeed (eval (cadr Exe)))
  %14 = call i64 @initSeed(i64 %13)
; # (mul 6364136223846793005 (initSeed (eval (cadr Exe))))
  %15 = zext i64 %14 to i128
  %16 = mul i128 6364136223846793005, %15
  %17 = lshr i128 %16, 64
  %18 = trunc i128 %17 to i64
  %19 = trunc i128 %16 to i64
; # (set $SeedL N $SeedH @@@)
  store i64 %19, i64* @$SeedL
  store i64 %18, i64* @$SeedH
; # (- 32 3)
; # (shr N (- 32 3))
  %20 = lshr i64 %19, 29
; # (& (shr N (- 32 3)) -8)
  %21 = and i64 %20, -8
; # (| (& (shr N (- 32 3)) -8) 2)
  %22 = or i64 %21, 2
  ret i64 %22
}

define i64 @_hash(i64) {
$1:
; # (let (N (initSeed (eval (cadr Exe))) C 64 R 0) (loop (when (& (x|...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (initSeed (eval (cadr Exe)))
  %14 = call i64 @initSeed(i64 %13)
; # (loop (when (& (x| N R) 1) (setq R (x| R (hex "14002")))) (setq N...
  br label %$7
$7:
  %15 = phi i64 [%14, %$2], [%32, %$10] ; # N
  %16 = phi i64 [64, %$2], [%33, %$10] ; # C
  %17 = phi i64 [0, %$2], [%34, %$10] ; # R
; # (when (& (x| N R) 1) (setq R (x| R (hex "14002"))))
; # (x| N R)
  %18 = xor i64 %15, %17
; # (& (x| N R) 1)
  %19 = and i64 %18, 1
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$8, label %$9
$8:
  %21 = phi i64 [%15, %$7] ; # N
  %22 = phi i64 [%16, %$7] ; # C
  %23 = phi i64 [%17, %$7] ; # R
; # (x| R (hex "14002"))
  %24 = xor i64 %23, 81922
  br label %$9
$9:
  %25 = phi i64 [%15, %$7], [%21, %$8] ; # N
  %26 = phi i64 [%16, %$7], [%22, %$8] ; # C
  %27 = phi i64 [%17, %$7], [%24, %$8] ; # R
; # (shr N 1)
  %28 = lshr i64 %25, 1
; # (shr R 1)
  %29 = lshr i64 %27, 1
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %30 = sub i64 %26, 1
; # (=0 (dec 'C))
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$11, label %$10
$10:
  %32 = phi i64 [%28, %$9] ; # N
  %33 = phi i64 [%30, %$9] ; # C
  %34 = phi i64 [%29, %$9] ; # R
  br label %$7
$11:
  %35 = phi i64 [%28, %$9] ; # N
  %36 = phi i64 [%30, %$9] ; # C
  %37 = phi i64 [%29, %$9] ; # R
  %38 = phi i64 [0, %$9] ; # ->
; # (inc R)
  %39 = add i64 %37, 1
; # (cnt (inc R))
  %40 = shl i64 %39, 4
  %41 = or i64 %40, 2
  ret i64 %41
}

define i64 @_rand(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X)) N (add (mul 6364136223846793005...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (val $SeedL)
  %16 = load i64, i64* @$SeedL
; # (mul 6364136223846793005 (val $SeedL))
  %17 = zext i64 %16 to i128
  %18 = mul i128 6364136223846793005, %17
  %19 = lshr i128 %18, 64
  %20 = trunc i128 %19 to i64
  %21 = trunc i128 %18 to i64
; # (add (mul 6364136223846793005 (val $SeedL)) 1)
  %22 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %21, i64 1)
  %23 = extractvalue {i64, i1} %22, 1
  %24 = extractvalue {i64, i1} %22, 0
; # (set $SeedL N $SeedH (+ @@@ @@))
  store i64 %24, i64* @$SeedL
; # (+ @@@ @@)
  %25 = zext i1 %23 to i64
  %26 = add i64 %20, %25
  store i64 %26, i64* @$SeedH
; # (cond ((nil? Y) (| (& (shr N (- 32 3)) -8) 2)) ((t? Y) (add N N) ...
; # (nil? Y)
  %27 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %27, label %$9, label %$8
$9:
  %28 = phi i64 [%24, %$2] ; # N
; # (- 32 3)
; # (shr N (- 32 3))
  %29 = lshr i64 %28, 29
; # (& (shr N (- 32 3)) -8)
  %30 = and i64 %29, -8
; # (| (& (shr N (- 32 3)) -8) 2)
  %31 = or i64 %30, 2
  br label %$7
$8:
  %32 = phi i64 [%24, %$2] ; # N
; # (t? Y)
  %33 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %33, label %$11, label %$10
$11:
  %34 = phi i64 [%32, %$8] ; # N
; # (add N N)
  %35 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %34, i64 %34)
  %36 = extractvalue {i64, i1} %35, 1
  %37 = extractvalue {i64, i1} %35, 0
; # (if @@ Y $Nil)
  br i1 %36, label %$12, label %$13
$12:
  %38 = phi i64 [%34, %$11] ; # N
  br label %$14
$13:
  %39 = phi i64 [%34, %$11] ; # N
  br label %$14
$14:
  %40 = phi i64 [%38, %$12], [%39, %$13] ; # N
  %41 = phi i64 [%15, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13] ; # ->
  br label %$7
$10:
  %42 = phi i64 [%32, %$8] ; # N
; # (let (A (xCnt Exe Y) B (inc (evCnt Exe X))) (setq N (+ (% (shr (v...
; # (xCnt Exe Y)
  %43 = call i64 @xCnt(i64 %0, i64 %15)
; # (evCnt Exe X)
  %44 = call i64 @evCnt(i64 %0, i64 %7)
; # (inc (evCnt Exe X))
  %45 = add i64 %44, 1
; # (val $SeedH)
  %46 = load i64, i64* @$SeedH
; # (val $SeedL)
  %47 = load i64, i64* @$SeedL
; # (shr (val $SeedH) (val $SeedL) 32)
  %48 = call i64 @llvm.fshr.i64(i64 %46, i64 %47, i64 32)
; # (- B A)
  %49 = sub i64 %45, %43
; # (% (shr (val $SeedH) (val $SeedL) 32) (- B A))
  %50 = urem i64 %48, %49
; # (+ (% (shr (val $SeedH) (val $SeedL) 32) (- B A)) A)
  %51 = add i64 %50, %43
; # (if (lt0 N) (sign (cnt (- N))) (cnt N))
; # (lt0 N)
  %52 = icmp slt i64 %51, 0
  br i1 %52, label %$15, label %$16
$15:
  %53 = phi i64 [%51, %$10] ; # N
; # (- N)
  %54 = sub i64 0, %53
; # (cnt (- N))
  %55 = shl i64 %54, 4
  %56 = or i64 %55, 2
; # (sign (cnt (- N)))
  %57 = or i64 %56, 8
  br label %$17
$16:
  %58 = phi i64 [%51, %$10] ; # N
; # (cnt N)
  %59 = shl i64 %58, 4
  %60 = or i64 %59, 2
  br label %$17
$17:
  %61 = phi i64 [%53, %$15], [%58, %$16] ; # N
  %62 = phi i64 [%57, %$15], [%60, %$16] ; # ->
  br label %$7
$7:
  %63 = phi i64 [%28, %$9], [%40, %$14], [%61, %$17] ; # N
  %64 = phi i64 [%31, %$9], [%41, %$14], [%62, %$17] ; # ->
  ret i64 %64
}

define i64 @bufSize(i64) {
$1:
; # (let N 1 (while (big? Nm) (inc 'N 8) (setq Nm (val (big Nm)))) (s...
; # (while (big? Nm) (inc 'N 8) (setq Nm (val (big Nm))))
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%10, %$3] ; # Nm
  %2 = phi i64 [1, %$1], [%7, %$3] ; # N
; # (big? Nm)
  %3 = and i64 %1, 4
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$3, label %$4
$3:
  %5 = phi i64 [%1, %$2] ; # Nm
  %6 = phi i64 [%2, %$2] ; # N
; # (inc 'N 8)
  %7 = add i64 %6, 8
; # (big Nm)
  %8 = add i64 %5, 4
; # (val (big Nm))
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  br label %$2
$4:
  %11 = phi i64 [%1, %$2] ; # Nm
  %12 = phi i64 [%2, %$2] ; # N
; # (int Nm)
  %13 = lshr i64 %11, 4
; # (while Nm (inc 'N) (setq Nm (shr Nm 8)))
  br label %$5
$5:
  %14 = phi i64 [%13, %$4], [%20, %$6] ; # Nm
  %15 = phi i64 [%12, %$4], [%19, %$6] ; # N
  %16 = icmp ne i64 %14, 0
  br i1 %16, label %$6, label %$7
$6:
  %17 = phi i64 [%14, %$5] ; # Nm
  %18 = phi i64 [%15, %$5] ; # N
; # (inc 'N)
  %19 = add i64 %18, 1
; # (shr Nm 8)
  %20 = lshr i64 %17, 8
  br label %$5
$7:
  %21 = phi i64 [%14, %$5] ; # Nm
  %22 = phi i64 [%15, %$5] ; # N
  ret i64 %22
}

define i64 @pathSize(i64) {
$1:
; # (let (Len (bufSize Nm) N (if (cnt? Nm) (int @) (val (dig @))) B (...
; # (bufSize Nm)
  %1 = call i64 @bufSize(i64 %0)
; # (if (cnt? Nm) (int @) (val (dig @)))
; # (cnt? Nm)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (int @)
  %4 = lshr i64 %0, 4
  br label %$4
$3:
; # (dig @)
  %5 = add i64 %0, -4
; # (val (dig @))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
  br label %$4
$4:
  %8 = phi i64 [%4, %$2], [%7, %$3] ; # ->
; # (i8 N)
  %9 = trunc i64 %8 to i8
; # (if (or (== B (char "@")) (and (== B (char "+")) (== (i8 (shr N 8...
; # (or (== B (char "@")) (and (== B (char "+")) (== (i8 (shr N 8)) (...
; # (== B (char "@"))
  %10 = icmp eq i8 %9, 64
  br i1 %10, label %$5, label %$6
$6:
; # (and (== B (char "+")) (== (i8 (shr N 8)) (char "@")))
; # (== B (char "+"))
  %11 = icmp eq i8 %9, 43
  br i1 %11, label %$8, label %$7
$8:
; # (shr N 8)
  %12 = lshr i64 %8, 8
; # (i8 (shr N 8))
  %13 = trunc i64 %12 to i8
; # (== (i8 (shr N 8)) (char "@"))
  %14 = icmp eq i8 %13, 64
  br label %$7
$7:
  %15 = phi i1 [0, %$6], [%14, %$8] ; # ->
  br label %$5
$5:
  %16 = phi i1 [1, %$4], [%15, %$7] ; # ->
  br i1 %16, label %$9, label %$10
$9:
; # (val $HomeLen)
  %17 = load i64, i64* @$HomeLen
; # (dec Len)
  %18 = sub i64 %1, 1
; # (+ (val $HomeLen) (dec Len))
  %19 = add i64 %17, %18
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%19, %$9], [%1, %$10] ; # ->
  ret i64 %20
}

define i8* @bufString(i64, i8*) {
$1:
; # (let Q (push 0 Nm) (prog1 P (while (set P (symByte Q)) (inc 'P)))...
; # (push 0 Nm)
  %2 = alloca i64, i64 2, align 16
  store i64 0, i64* %2
  %3 = getelementptr i64, i64* %2, i32 1
  store i64 %0, i64* %3
; # (prog1 P (while (set P (symByte Q)) (inc 'P)))
; # (while (set P (symByte Q)) (inc 'P))
  br label %$2
$2:
  %4 = phi i8* [%1, %$1], [%8, %$3] ; # P
; # (set P (symByte Q))
; # (symByte Q)
  %5 = call i8 @symByte(i64* %2)
  store i8 %5, i8* %4
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %$3, label %$4
$3:
  %7 = phi i8* [%4, %$2] ; # P
; # (inc 'P)
  %8 = getelementptr i8, i8* %7, i32 1
  br label %$2
$4:
  %9 = phi i8* [%4, %$2] ; # P
  ret i8* %1
}

define i8* @pathString(i64, i8*) {
$1:
; # (let (Q (push 0 Nm) B (symByte Q)) (prog1 P (when (== B (char "+"...
; # (push 0 Nm)
  %2 = alloca i64, i64 2, align 16
  store i64 0, i64* %2
  %3 = getelementptr i64, i64* %2, i32 1
  store i64 %0, i64* %3
; # (symByte Q)
  %4 = call i8 @symByte(i64* %2)
; # (prog1 P (when (== B (char "+")) (set P B) (inc 'P) (setq B (symB...
; # (when (== B (char "+")) (set P B) (inc 'P) (setq B (symByte Q)))
; # (== B (char "+"))
  %5 = icmp eq i8 %4, 43
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i8* [%1, %$1] ; # P
  %7 = phi i8 [%4, %$1] ; # B
; # (set P B)
  store i8 %7, i8* %6
; # (inc 'P)
  %8 = getelementptr i8, i8* %6, i32 1
; # (symByte Q)
  %9 = call i8 @symByte(i64* %2)
  br label %$3
$3:
  %10 = phi i8* [%1, %$1], [%8, %$2] ; # P
  %11 = phi i8 [%4, %$1], [%9, %$2] ; # B
; # (if (== B (char "@")) (when (val $HomeLen) (memcpy P (val $Home) ...
; # (== B (char "@"))
  %12 = icmp eq i8 %11, 64
  br i1 %12, label %$4, label %$5
$4:
  %13 = phi i8* [%10, %$3] ; # P
  %14 = phi i8 [%11, %$3] ; # B
; # (when (val $HomeLen) (memcpy P (val $Home) @) (inc 'P @))
; # (val $HomeLen)
  %15 = load i64, i64* @$HomeLen
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i8* [%13, %$4] ; # P
  %18 = phi i8 [%14, %$4] ; # B
; # (val $Home)
  %19 = load i8*, i8** @$Home
; # (memcpy P (val $Home) @)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %19, i64 %15, i1 0)
; # (inc 'P @)
  %20 = getelementptr i8, i8* %17, i64 %15
  br label %$8
$8:
  %21 = phi i8* [%13, %$4], [%20, %$7] ; # P
  %22 = phi i8 [%14, %$4], [%18, %$7] ; # B
  br label %$6
$5:
  %23 = phi i8* [%10, %$3] ; # P
  %24 = phi i8 [%11, %$3] ; # B
; # (set P B)
  store i8 %24, i8* %23
; # (inc 'P)
  %25 = getelementptr i8, i8* %23, i32 1
  br label %$6
$6:
  %26 = phi i8* [%21, %$8], [%25, %$5] ; # P
  %27 = phi i8 [%22, %$8], [%24, %$5] ; # B
; # (while (set P (symByte Q)) (inc 'P))
  br label %$9
$9:
  %28 = phi i8* [%26, %$6], [%34, %$10] ; # P
  %29 = phi i8 [%27, %$6], [%33, %$10] ; # B
; # (set P (symByte Q))
; # (symByte Q)
  %30 = call i8 @symByte(i64* %2)
  store i8 %30, i8* %28
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %$10, label %$11
$10:
  %32 = phi i8* [%28, %$9] ; # P
  %33 = phi i8 [%29, %$9] ; # B
; # (inc 'P)
  %34 = getelementptr i8, i8* %32, i32 1
  br label %$9
$11:
  %35 = phi i8* [%28, %$9] ; # P
  %36 = phi i8 [%29, %$9] ; # B
  ret i8* %1
}

define i64 @mkChar(i32) {
$1:
; # (cond ((>= 127 C) (i64 C)) ((== TOP C) (hex "FF")) ((> (hex "800"...
; # (>= 127 C)
  %1 = icmp sge i32 127, %0
  br i1 %1, label %$4, label %$3
$4:
; # (i64 C)
  %2 = sext i32 %0 to i64
  br label %$2
$3:
; # (== TOP C)
  %3 = icmp eq i32 1114112, %0
  br i1 %3, label %$6, label %$5
$6:
  br label %$2
$5:
; # (> (hex "800") C)
  %4 = icmp sgt i32 2048, %0
  br i1 %4, label %$8, label %$7
$8:
; # (shr C 6)
  %5 = lshr i32 %0, 6
; # (& (shr C 6) (hex "1F"))
  %6 = and i32 %5, 31
; # (| (hex "C0") (& (shr C 6) (hex "1F")))
  %7 = or i32 192, %6
; # (& C (hex "3F"))
  %8 = and i32 %0, 63
; # (| (hex "80") (& C (hex "3F")))
  %9 = or i32 128, %8
; # (shl (| (hex "80") (& C (hex "3F"))) 8)
  %10 = shl i32 %9, 8
; # (| (| (hex "C0") (& (shr C 6) (hex "1F"))) (shl (| (hex "80") (& ...
  %11 = or i32 %7, %10
; # (i64 (| (| (hex "C0") (& (shr C 6) (hex "1F"))) (shl (| (hex "80"...
  %12 = sext i32 %11 to i64
  br label %$2
$7:
; # (> (hex "10000") C)
  %13 = icmp sgt i32 65536, %0
  br i1 %13, label %$10, label %$9
$10:
; # (shr C 12)
  %14 = lshr i32 %0, 12
; # (& (shr C 12) (hex "0F"))
  %15 = and i32 %14, 15
; # (| (hex "E0") (& (shr C 12) (hex "0F")))
  %16 = or i32 224, %15
; # (shr C 6)
  %17 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %18 = and i32 %17, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %19 = or i32 128, %18
; # (shl (| (hex "80") (& (shr C 6) (hex "3F"))) 8)
  %20 = shl i32 %19, 8
; # (| (| (hex "E0") (& (shr C 12) (hex "0F"))) (shl (| (hex "80") (&...
  %21 = or i32 %16, %20
; # (& C (hex "3F"))
  %22 = and i32 %0, 63
; # (| (hex "80") (& C (hex "3F")))
  %23 = or i32 128, %22
; # (shl (| (hex "80") (& C (hex "3F"))) 16)
  %24 = shl i32 %23, 16
; # (| (| (| (hex "E0") (& (shr C 12) (hex "0F"))) (shl (| (hex "80")...
  %25 = or i32 %21, %24
; # (i64 (| (| (| (hex "E0") (& (shr C 12) (hex "0F"))) (shl (| (hex ...
  %26 = sext i32 %25 to i64
  br label %$2
$9:
; # (shr C 18)
  %27 = lshr i32 %0, 18
; # (& (shr C 18) (hex "07"))
  %28 = and i32 %27, 7
; # (| (hex "F0") (& (shr C 18) (hex "07")))
  %29 = or i32 240, %28
; # (shr C 12)
  %30 = lshr i32 %0, 12
; # (& (shr C 12) (hex "3F"))
  %31 = and i32 %30, 63
; # (| (hex "80") (& (shr C 12) (hex "3F")))
  %32 = or i32 128, %31
; # (shl (| (hex "80") (& (shr C 12) (hex "3F"))) 8)
  %33 = shl i32 %32, 8
; # (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (hex "80") (&...
  %34 = or i32 %29, %33
; # (shr C 6)
  %35 = lshr i32 %0, 6
; # (& (shr C 6) (hex "3F"))
  %36 = and i32 %35, 63
; # (| (hex "80") (& (shr C 6) (hex "3F")))
  %37 = or i32 128, %36
; # (shl (| (hex "80") (& (shr C 6) (hex "3F"))) 16)
  %38 = shl i32 %37, 16
; # (| (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (hex "80")...
  %39 = or i32 %34, %38
; # (i64 (| (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (hex ...
  %40 = sext i32 %39 to i64
; # (i64 C)
  %41 = sext i32 %0 to i64
; # (& (i64 C) (hex "3F"))
  %42 = and i64 %41, 63
; # (| (hex "80") (& (i64 C) (hex "3F")))
  %43 = or i64 128, %42
; # (shl (| (hex "80") (& (i64 C) (hex "3F"))) 24)
  %44 = shl i64 %43, 24
; # (| (i64 (| (| (| (hex "F0") (& (shr C 18) (hex "07"))) (shl (| (h...
  %45 = or i64 %40, %44
  br label %$2
$2:
  %46 = phi i64 [%2, %$4], [255, %$6], [%12, %$8], [%26, %$10], [%45, %$9] ; # ->
; # (cnt (cond ((>= 127 C) (i64 C)) ((== TOP C) (hex "FF")) ((> (hex ...
  %47 = shl i64 %46, 4
  %48 = or i64 %47, 2
; # (consStr (cnt (cond ((>= 127 C) (i64 C)) ((== TOP C) (hex "FF")) ...
  %49 = call i64 @consStr(i64 %48)
  ret i64 %49
}

define i64 @mkStr(i8*) {
$1:
; # (if Str (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (while (v...
  %1 = icmp ne i8* %0, null
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i8* [%0, %$1] ; # Str
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (while (val Str) ...
; # (push 4 NIL ZERO NIL)
  %3 = alloca i64, i64 4, align 16
  store i64 4, i64* %3
  %4 = getelementptr i64, i64* %3, i32 2
  store i64 2, i64* %4
; # (ofs P 2)
  %5 = getelementptr i64, i64* %3, i32 2
; # (link (ofs P 2) T)
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %6 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %11
; # (while (val Str) (byteSym @ P) (inc 'Str))
  br label %$5
$5:
  %12 = phi i8* [%2, %$2], [%16, %$6] ; # Str
; # (val Str)
  %13 = load i8, i8* %12
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %$6, label %$7
$6:
  %15 = phi i8* [%12, %$5] ; # Str
; # (byteSym @ P)
  call void @byteSym(i8 %13, i64* %3)
; # (inc 'Str)
  %16 = getelementptr i8, i8* %15, i32 1
  br label %$5
$7:
  %17 = phi i8* [%12, %$5] ; # Str
; # (val 3 P)
  %18 = getelementptr i64, i64* %3, i32 2
  %19 = load i64, i64* %18
; # (consStr (val 3 P))
  %20 = call i64 @consStr(i64 %19)
; # (drop *Safe)
  %21 = inttoptr i64 %6 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %23, i64* %24
  br label %$4
$3:
  %25 = phi i8* [%0, %$1] ; # Str
  br label %$4
$4:
  %26 = phi i8* [%17, %$7], [%25, %$3] ; # Str
  %27 = phi i64 [%20, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %27
}

define i64 @mkStrE(i8*, i8*) {
$1:
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (loop (? (== Str ...
; # (push 4 NIL ZERO NIL)
  %2 = alloca i64, i64 4, align 16
  store i64 4, i64* %2
  %3 = getelementptr i64, i64* %2, i32 2
  store i64 2, i64* %3
; # (ofs P 2)
  %4 = getelementptr i64, i64* %2, i32 2
; # (link (ofs P 2) T)
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %5 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %10
; # (loop (? (== Str End)) (? (=0 (val Str))) (byteSym @ P) (inc 'Str...
  br label %$2
$2:
  %11 = phi i8* [%0, %$1], [%17, %$5] ; # Str
; # (? (== Str End))
; # (== Str End)
  %12 = icmp eq i8* %11, %1
  br i1 %12, label %$4, label %$3
$3:
  %13 = phi i8* [%11, %$2] ; # Str
; # (? (=0 (val Str)))
; # (val Str)
  %14 = load i8, i8* %13
; # (=0 (val Str))
  %15 = icmp eq i8 %14, 0
  br i1 %15, label %$4, label %$5
$5:
  %16 = phi i8* [%13, %$3] ; # Str
; # (byteSym @ P)
  call void @byteSym(i8 %14, i64* %2)
; # (inc 'Str)
  %17 = getelementptr i8, i8* %16, i32 1
  br label %$2
$4:
  %18 = phi i8* [%11, %$2], [%13, %$3] ; # Str
  %19 = phi i64 [0, %$2], [0, %$3] ; # ->
; # (val 3 P)
  %20 = getelementptr i64, i64* %2, i32 2
  %21 = load i64, i64* %20
; # (consStr (val 3 P))
  %22 = call i64 @consStr(i64 %21)
; # (drop *Safe)
  %23 = inttoptr i64 %5 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %26
  ret i64 %22
}

define i8 @firstByte(i64) {
$1:
; # (cond ((sym? (val (tail Sym))) 0) ((cnt? (name @)) (int @)) (T (v...
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (sym? (val (tail Sym)))
  %4 = and i64 %3, 8
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
  br label %$2
$3:
; # (name @)
  br label %$5
$5:
  %6 = phi i64 [%3, %$3], [%12, %$6] ; # Tail
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$7, label %$6
$6:
  %9 = phi i64 [%6, %$5] ; # Tail
  %10 = inttoptr i64 %9 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
  br label %$5
$7:
  %13 = phi i64 [%6, %$5] ; # Tail
; # (cnt? (name @))
  %14 = and i64 %13, 2
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
; # (int @)
  %16 = lshr i64 %13, 4
  br label %$2
$8:
; # (dig @)
  %17 = add i64 %13, -4
; # (val (dig @))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  br label %$2
$2:
  %20 = phi i64 [0, %$4], [%16, %$9], [%19, %$8] ; # ->
; # (i8 (cond ((sym? (val (tail Sym))) 0) ((cnt? (name @)) (int @)) (...
  %21 = trunc i64 %20 to i8
  ret i8 %21
}

define i32 @firstChar(i64) {
$1:
; # (cond ((nil? Sym) 0) ((sym? (val (tail Sym))) 0) (T (symChar (pus...
; # (nil? Sym)
  %1 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (tail Sym)
  %2 = add i64 %0, -8
; # (val (tail Sym))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (sym? (val (tail Sym)))
  %5 = and i64 %4, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$6, label %$5
$6:
  br label %$2
$5:
; # (name @)
  br label %$7
$7:
  %7 = phi i64 [%4, %$5], [%13, %$8] ; # Tail
  %8 = and i64 %7, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$9, label %$8
$8:
  %10 = phi i64 [%7, %$7] ; # Tail
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  br label %$7
$9:
  %14 = phi i64 [%7, %$7] ; # Tail
; # (push 0 (name @))
  %15 = alloca i64, i64 2, align 16
  store i64 0, i64* %15
  %16 = getelementptr i64, i64* %15, i32 1
  store i64 %14, i64* %16
; # (symChar (push 0 (name @)))
  %17 = call i32 @symChar(i64* %15)
  br label %$2
$2:
  %18 = phi i32 [0, %$4], [0, %$6], [%17, %$9] ; # ->
  ret i32 %18
}

define i1 @isBlank(i64) {
$1:
; # (or (nil? X) (and (symb? X) (not (sym? (val (tail X)))) (let P (p...
; # (nil? X)
  %1 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %1, label %$2, label %$3
$3:
; # (and (symb? X) (not (sym? (val (tail X)))) (let P (push 0 (name @...
; # (symb? X)
  %2 = xor i64 %0, 8
  %3 = and i64 %2, 14
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$5, label %$4
$5:
; # (tail X)
  %5 = add i64 %0, -8
; # (val (tail X))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (sym? (val (tail X)))
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
; # (not (sym? (val (tail X))))
  %10 = icmp eq i1 %9, 0
  br i1 %10, label %$6, label %$4
$6:
; # (let P (push 0 (name @)) (loop (? (=0 (symByte P)) YES) (? (> @ 3...
; # (name @)
  br label %$7
$7:
  %11 = phi i64 [%7, %$6], [%17, %$8] ; # Tail
  %12 = and i64 %11, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$9, label %$8
$8:
  %14 = phi i64 [%11, %$7] ; # Tail
  %15 = inttoptr i64 %14 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  br label %$7
$9:
  %18 = phi i64 [%11, %$7] ; # Tail
; # (push 0 (name @))
  %19 = alloca i64, i64 2, align 16
  store i64 0, i64* %19
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
; # (loop (? (=0 (symByte P)) YES) (? (> @ 32) NO))
  br label %$10
$10:
; # (? (=0 (symByte P)) YES)
; # (symByte P)
  %21 = call i8 @symByte(i64* %19)
; # (=0 (symByte P))
  %22 = icmp eq i8 %21, 0
  br i1 %22, label %$13, label %$11
$13:
  br label %$12
$11:
; # (? (> @ 32) NO)
; # (> @ 32)
  %23 = icmp ugt i8 %21, 32
  br i1 %23, label %$15, label %$14
$15:
  br label %$12
$14:
  br label %$10
$12:
  %24 = phi i1 [1, %$13], [0, %$15] ; # ->
  br label %$4
$4:
  %25 = phi i1 [0, %$3], [0, %$5], [%24, %$12] ; # ->
  br label %$2
$2:
  %26 = phi i1 [1, %$1], [%25, %$4] ; # ->
  ret i1 %26
}

define i64 @extNm(i32, i64) {
$1:
; # (& Obj (hex "FFFFF"))
  %2 = and i64 %1, 1048575
; # (& File (hex "FF"))
  %3 = and i32 %0, 255
; # (i64 (& File (hex "FF")))
  %4 = sext i32 %3 to i64
; # (shl (i64 (& File (hex "FF"))) 20)
  %5 = shl i64 %4, 20
; # (shr Obj 20)
  %6 = lshr i64 %1, 20
; # (& (setq Obj (shr Obj 20)) (hex "FFF"))
  %7 = and i64 %6, 4095
; # (shl (& (setq Obj (shr Obj 20)) (hex "FFF")) 28)
  %8 = shl i64 %7, 28
; # (shr File 8)
  %9 = lshr i32 %0, 8
; # (i64 (shr File 8))
  %10 = sext i32 %9 to i64
; # (shl (i64 (shr File 8)) 40)
  %11 = shl i64 %10, 40
; # (shr Obj 12)
  %12 = lshr i64 %6, 12
; # (shl (shr Obj 12) 48)
  %13 = shl i64 %12, 48
; # (| (shl (i64 (shr File 8)) 40) (shl (shr Obj 12) 48))
  %14 = or i64 %11, %13
; # (| (shl (& (setq Obj (shr Obj 20)) (hex "FFF")) 28) (| (shl (i64 ...
  %15 = or i64 %8, %14
; # (| (shl (i64 (& File (hex "FF"))) 20) (| (shl (& (setq Obj (shr O...
  %16 = or i64 %5, %15
; # (| (& Obj (hex "FFFFF")) (| (shl (i64 (& File (hex "FF"))) 20) (|...
  %17 = or i64 %2, %16
; # (cnt (| (& Obj (hex "FFFFF")) (| (shl (i64 (& File (hex "FF"))) 2...
  %18 = shl i64 %17, 4
  %19 = or i64 %18, 2
  ret i64 %19
}

define i32 @objFile(i64) {
$1:
; # (shr Name 24)
  %1 = lshr i64 %0, 24
; # (i32 (setq Name (shr Name 24)))
  %2 = trunc i64 %1 to i32
; # (& (i32 (setq Name (shr Name 24))) (hex "FF"))
  %3 = and i32 %2, 255
; # (shr Name 12)
  %4 = lshr i64 %1, 12
; # (i32 (shr Name 12))
  %5 = trunc i64 %4 to i32
; # (& (i32 (shr Name 12)) (hex "FF00"))
  %6 = and i32 %5, 65280
; # (| (& (i32 (setq Name (shr Name 24))) (hex "FF")) (& (i32 (shr Na...
  %7 = or i32 %3, %6
  ret i32 %7
}

define i64 @objId(i64) {
$1:
; # (shr Name 4)
  %1 = lshr i64 %0, 4
; # (& (setq Name (shr Name 4)) (hex "FFFFF"))
  %2 = and i64 %1, 1048575
; # (shr Name 8)
  %3 = lshr i64 %1, 8
; # (& (setq Name (shr Name 8)) (hex "FFF00000"))
  %4 = and i64 %3, 4293918720
; # (| (& (setq Name (shr Name 4)) (hex "FFFFF")) (& (setq Name (shr ...
  %5 = or i64 %2, %4
; # (shr Name 8)
  %6 = lshr i64 %3, 8
; # (& (shr Name 8) (hex "3FF00000000"))
  %7 = and i64 %6, 4393751543808
; # (| (| (& (setq Name (shr Name 4)) (hex "FFFFF")) (& (setq Name (s...
  %8 = or i64 %5, %7
  ret i64 %8
}

define void @packAO(i32, i64*) {
$1:
; # (when (> File 15) (packAO (shr File 4) P))
; # (> File 15)
  %2 = icmp sgt i32 %0, 15
  br i1 %2, label %$2, label %$3
$2:
; # (shr File 4)
  %3 = lshr i32 %0, 4
; # (packAO (shr File 4) P)
  call void @packAO(i32 %3, i64* %1)
  br label %$3
$3:
; # (i8 File)
  %4 = trunc i32 %0 to i8
; # (& (i8 File) 15)
  %5 = and i8 %4, 15
; # (+ (& (i8 File) 15) (char "@"))
  %6 = add i8 %5, 64
; # (byteSym (+ (& (i8 File) 15) (char "@")) P)
  call void @byteSym(i8 %6, i64* %1)
  ret void
}

define void @packOct(i64, i64*) {
$1:
; # (when (> Obj 7) (packOct (shr Obj 3) P))
; # (> Obj 7)
  %2 = icmp ugt i64 %0, 7
  br i1 %2, label %$2, label %$3
$2:
; # (shr Obj 3)
  %3 = lshr i64 %0, 3
; # (packOct (shr Obj 3) P)
  call void @packOct(i64 %3, i64* %1)
  br label %$3
$3:
; # (i8 Obj)
  %4 = trunc i64 %0 to i8
; # (& (i8 Obj) 7)
  %5 = and i8 %4, 7
; # (+ (& (i8 Obj) 7) (char "0"))
  %6 = add i8 %5, 48
; # (byteSym (+ (& (i8 Obj) 7) (char "0")) P)
  call void @byteSym(i8 %6, i64* %1)
  ret void
}

define void @packExtNm(i64, i64*) {
$1:
; # (when (objFile Name) (packAO @ P))
; # (objFile Name)
  %2 = call i32 @objFile(i64 %0)
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (packAO @ P)
  call void @packAO(i32 %2, i64* %1)
  br label %$3
$3:
; # (objId Name)
  %4 = call i64 @objId(i64 %0)
; # (packOct (objId Name) P)
  call void @packOct(i64 %4, i64* %1)
  ret void
}

define void @pack(i64, i64*) {
$1:
; # (when (pair X) (stkChk 0) (loop (pack (++ X) P) (? (atom X))))
; # (pair X)
  %2 = and i64 %0, 15
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # X
; # (stkChk 0)
  %5 = load i8*, i8** @$StkLimit
  %6 = call i8* @llvm.stacksave()
  %7 = icmp ugt i8* %5, %6
  br i1 %7, label %$4, label %$5
$4:
  call void @stkErr(i64 0)
  unreachable
$5:
; # (loop (pack (++ X) P) (? (atom X)))
  br label %$6
$6:
  %8 = phi i64 [%4, %$5], [%15, %$7] ; # X
; # (++ X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
; # (pack (++ X) P)
  call void @pack(i64 %10, i64* %1)
; # (? (atom X))
; # (atom X)
  %13 = and i64 %12, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$7:
  %15 = phi i64 [%12, %$6] ; # X
  br label %$6
$8:
  %16 = phi i64 [%12, %$6] ; # X
  %17 = phi i64 [0, %$6] ; # ->
  br label %$3
$3:
  %18 = phi i64 [%0, %$1], [%16, %$8] ; # X
; # (cond ((nil? X)) ((num? X) (fmtNum X 0 0 0 P)) ((sym? (val (tail ...
; # (nil? X)
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %19, label %$9, label %$10
$10:
  %20 = phi i64 [%18, %$3] ; # X
; # (num? X)
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$12, label %$11
$12:
  %23 = phi i64 [%20, %$10] ; # X
; # (fmtNum X 0 0 0 P)
  %24 = call i64 @fmtNum(i64 %23, i64 0, i8 0, i8 0, i64* %1)
  br label %$9
$11:
  %25 = phi i64 [%20, %$10] ; # X
; # (tail X)
  %26 = add i64 %25, -8
; # (val (tail X))
  %27 = inttoptr i64 %26 to i64*
  %28 = load i64, i64* %27
; # (sym? (val (tail X)))
  %29 = and i64 %28, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%25, %$11] ; # X
; # (byteSym (char "{") P)
  call void @byteSym(i8 123, i64* %1)
; # (name @)
  br label %$15
$15:
  %32 = phi i64 [%28, %$14], [%38, %$16] ; # Tail
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$17, label %$16
$16:
  %35 = phi i64 [%32, %$15] ; # Tail
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  br label %$15
$17:
  %39 = phi i64 [%32, %$15] ; # Tail
; # (& (name @) -9)
  %40 = and i64 %39, -9
; # (packExtNm (& (name @) -9) P)
  call void @packExtNm(i64 %40, i64* %1)
; # (byteSym (char "}") P)
  call void @byteSym(i8 125, i64* %1)
  br label %$9
$13:
  %41 = phi i64 [%25, %$11] ; # X
; # (let Q (push 0 (name @)) (while (symByte Q) (byteSym @ P)))
; # (name @)
  br label %$18
$18:
  %42 = phi i64 [%28, %$13], [%48, %$19] ; # Tail
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$20, label %$19
$19:
  %45 = phi i64 [%42, %$18] ; # Tail
  %46 = inttoptr i64 %45 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
  br label %$18
$20:
  %49 = phi i64 [%42, %$18] ; # Tail
; # (push 0 (name @))
  %50 = alloca i64, i64 2, align 16
  store i64 0, i64* %50
  %51 = getelementptr i64, i64* %50, i32 1
  store i64 %49, i64* %51
; # (while (symByte Q) (byteSym @ P))
  br label %$21
$21:
  %52 = phi i64 [%41, %$20], [%55, %$22] ; # X
; # (symByte Q)
  %53 = call i8 @symByte(i64* %50)
  %54 = icmp ne i8 %53, 0
  br i1 %54, label %$22, label %$23
$22:
  %55 = phi i64 [%52, %$21] ; # X
; # (byteSym @ P)
  call void @byteSym(i8 %53, i64* %1)
  br label %$21
$23:
  %56 = phi i64 [%52, %$21] ; # X
  br label %$9
$9:
  %57 = phi i64 [%18, %$3], [%23, %$12], [%31, %$17], [%56, %$23] ; # X
  ret void
}

define i64 @chopExtNm(i64) {
$1:
; # (let (R (link (push $Nil NIL)) N (objId Name)) (loop (let A (+ (&...
; # (push $Nil NIL)
  %1 = alloca i64, i64 2, align 16
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 %2 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %3
; # (link (push $Nil NIL))
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = inttoptr i64 %2 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  store i64 %5, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %2, i64* %8
; # (objId Name)
  %9 = call i64 @objId(i64 %0)
; # (loop (let A (+ (& N 7) (char "0")) (when (setq N (shr N 3)) (set...
  br label %$2
$2:
  %10 = phi i64 [%9, %$1], [%42, %$7] ; # N
; # (let A (+ (& N 7) (char "0")) (when (setq N (shr N 3)) (setq A (|...
; # (& N 7)
  %11 = and i64 %10, 7
; # (+ (& N 7) (char "0"))
  %12 = add i64 %11, 48
; # (when (setq N (shr N 3)) (setq A (| (shl A 8) (+ (& N 7) (char "0...
; # (shr N 3)
  %13 = lshr i64 %10, 3
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$3, label %$4
$3:
  %15 = phi i64 [%13, %$2] ; # N
  %16 = phi i64 [%12, %$2] ; # A
; # (shl A 8)
  %17 = shl i64 %16, 8
; # (& N 7)
  %18 = and i64 %15, 7
; # (+ (& N 7) (char "0"))
  %19 = add i64 %18, 48
; # (| (shl A 8) (+ (& N 7) (char "0")))
  %20 = or i64 %17, %19
; # (when (setq N (shr N 3)) (setq A (| (shl A 8) (+ (& N 7) (char "0...
; # (shr N 3)
  %21 = lshr i64 %15, 3
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$5, label %$6
$5:
  %23 = phi i64 [%21, %$3] ; # N
  %24 = phi i64 [%20, %$3] ; # A
; # (shl A 8)
  %25 = shl i64 %24, 8
; # (& N 7)
  %26 = and i64 %23, 7
; # (+ (& N 7) (char "0"))
  %27 = add i64 %26, 48
; # (| (shl A 8) (+ (& N 7) (char "0")))
  %28 = or i64 %25, %27
  br label %$6
$6:
  %29 = phi i64 [%21, %$3], [%23, %$5] ; # N
  %30 = phi i64 [%20, %$3], [%28, %$5] ; # A
  br label %$4
$4:
  %31 = phi i64 [%13, %$2], [%29, %$6] ; # N
  %32 = phi i64 [%12, %$2], [%30, %$6] ; # A
; # (set R (cons (consSym (cnt A) 0) (val R)))
; # (cnt A)
  %33 = shl i64 %32, 4
  %34 = or i64 %33, 2
; # (consSym (cnt A) 0)
  %35 = call i64 @consSym(i64 %34, i64 0)
; # (val R)
  %36 = inttoptr i64 %2 to i64*
  %37 = load i64, i64* %36
; # (cons (consSym (cnt A) 0) (val R))
  %38 = call i64 @cons(i64 %35, i64 %37)
  %39 = inttoptr i64 %2 to i64*
  store i64 %38, i64* %39
; # (? (=0 (setq N (shr N 3))))
; # (shr N 3)
  %40 = lshr i64 %31, 3
; # (=0 (setq N (shr N 3)))
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %$8, label %$7
$7:
  %42 = phi i64 [%40, %$4] ; # N
  br label %$2
$8:
  %43 = phi i64 [%40, %$4] ; # N
  %44 = phi i64 [0, %$4] ; # ->
; # (when (setq N (objFile Name)) (let F (i32 0) (loop (setq F (| F (...
; # (objFile Name)
  %45 = call i32 @objFile(i64 %0)
  %46 = icmp ne i32 %45, 0
  br i1 %46, label %$9, label %$10
$9:
  %47 = phi i32 [%45, %$8] ; # N
; # (let F (i32 0) (loop (setq F (| F (+ (& N 15) (char "@")))) (? (=...
; # (i32 0)
; # (loop (setq F (| F (+ (& N 15) (char "@")))) (? (=0 (setq N (shr ...
  br label %$11
$11:
  %48 = phi i32 [%47, %$9], [%55, %$12] ; # N
  %49 = phi i32 [0, %$9], [%57, %$12] ; # F
; # (& N 15)
  %50 = and i32 %48, 15
; # (+ (& N 15) (char "@"))
  %51 = add i32 %50, 64
; # (| F (+ (& N 15) (char "@")))
  %52 = or i32 %49, %51
; # (? (=0 (setq N (shr N 4))))
; # (shr N 4)
  %53 = lshr i32 %48, 4
; # (=0 (setq N (shr N 4)))
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %$13, label %$12
$12:
  %55 = phi i32 [%53, %$11] ; # N
  %56 = phi i32 [%52, %$11] ; # F
; # (shl F 8)
  %57 = shl i32 %56, 8
  br label %$11
$13:
  %58 = phi i32 [%53, %$11] ; # N
  %59 = phi i32 [%52, %$11] ; # F
  %60 = phi i64 [0, %$11] ; # ->
; # (set R (cons (consStr (cnt (i64 F))) (val R)))
; # (i64 F)
  %61 = sext i32 %59 to i64
; # (cnt (i64 F))
  %62 = shl i64 %61, 4
  %63 = or i64 %62, 2
; # (consStr (cnt (i64 F)))
  %64 = call i64 @consStr(i64 %63)
; # (val R)
  %65 = inttoptr i64 %2 to i64*
  %66 = load i64, i64* %65
; # (cons (consStr (cnt (i64 F))) (val R))
  %67 = call i64 @cons(i64 %64, i64 %66)
  %68 = inttoptr i64 %2 to i64*
  store i64 %67, i64* %68
  br label %$10
$10:
  %69 = phi i32 [%45, %$8], [%58, %$13] ; # N
; # (pop R)
  %70 = inttoptr i64 %2 to i64*
  %71 = load i64, i64* %70
  %72 = inttoptr i64 %2 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %74, i64* %75
  ret i64 %71
}

define i64 @cmpLong(i64, i64) {
$1:
; # (loop (? (sub (val (dig X)) (val (dig Y))) (if @@ -1 1)) (setq X ...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%60, %$18] ; # X
  %3 = phi i64 [%1, %$1], [%61, %$18] ; # Y
; # (? (sub (val (dig X)) (val (dig Y))) (if @@ -1 1))
; # (dig X)
  %4 = add i64 %2, -4
; # (val (dig X))
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (dig Y)
  %7 = add i64 %3, -4
; # (val (dig Y))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (sub (val (dig X)) (val (dig Y)))
  %10 = call {i64, i1} @llvm.usub.with.overflow.i64(i64 %6, i64 %9)
  %11 = extractvalue {i64, i1} %10, 1
  %12 = extractvalue {i64, i1} %10, 0
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$5, label %$3
$5:
  %14 = phi i64 [%2, %$2] ; # X
  %15 = phi i64 [%3, %$2] ; # Y
; # (if @@ -1 1)
  br i1 %11, label %$6, label %$7
$6:
  %16 = phi i64 [%14, %$5] ; # X
  %17 = phi i64 [%15, %$5] ; # Y
  br label %$8
$7:
  %18 = phi i64 [%14, %$5] ; # X
  %19 = phi i64 [%15, %$5] ; # Y
  br label %$8
$8:
  %20 = phi i64 [%16, %$6], [%18, %$7] ; # X
  %21 = phi i64 [%17, %$6], [%19, %$7] ; # Y
  %22 = phi i64 [-1, %$6], [1, %$7] ; # ->
  br label %$4
$3:
  %23 = phi i64 [%2, %$2] ; # X
  %24 = phi i64 [%3, %$2] ; # Y
; # (big X)
  %25 = add i64 %23, 4
; # (val (big X))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (big Y)
  %28 = add i64 %24, 4
; # (val (big Y))
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (? (cnt? X) (cond ((big? Y) -1) ((== Y X) 0) ((> Y X) -1) (T 1)))...
; # (cnt? X)
  %31 = and i64 %27, 2
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$10, label %$9
$10:
  %33 = phi i64 [%27, %$3] ; # X
  %34 = phi i64 [%30, %$3] ; # Y
; # (cond ((big? Y) -1) ((== Y X) 0) ((> Y X) -1) (T 1))
; # (big? Y)
  %35 = and i64 %34, 4
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  %37 = phi i64 [%33, %$10] ; # X
  %38 = phi i64 [%34, %$10] ; # Y
  br label %$11
$12:
  %39 = phi i64 [%33, %$10] ; # X
  %40 = phi i64 [%34, %$10] ; # Y
; # (== Y X)
  %41 = icmp eq i64 %40, %39
  br i1 %41, label %$15, label %$14
$15:
  %42 = phi i64 [%39, %$12] ; # X
  %43 = phi i64 [%40, %$12] ; # Y
  br label %$11
$14:
  %44 = phi i64 [%39, %$12] ; # X
  %45 = phi i64 [%40, %$12] ; # Y
; # (> Y X)
  %46 = icmp ugt i64 %45, %44
  br i1 %46, label %$17, label %$16
$17:
  %47 = phi i64 [%44, %$14] ; # X
  %48 = phi i64 [%45, %$14] ; # Y
  br label %$11
$16:
  %49 = phi i64 [%44, %$14] ; # X
  %50 = phi i64 [%45, %$14] ; # Y
  br label %$11
$11:
  %51 = phi i64 [%37, %$13], [%42, %$15], [%47, %$17], [%49, %$16] ; # X
  %52 = phi i64 [%38, %$13], [%43, %$15], [%48, %$17], [%50, %$16] ; # Y
  %53 = phi i64 [-1, %$13], [0, %$15], [-1, %$17], [1, %$16] ; # ->
  br label %$4
$9:
  %54 = phi i64 [%27, %$3] ; # X
  %55 = phi i64 [%30, %$3] ; # Y
; # (? (cnt? Y) 1)
; # (cnt? Y)
  %56 = and i64 %55, 2
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$19, label %$18
$19:
  %58 = phi i64 [%54, %$9] ; # X
  %59 = phi i64 [%55, %$9] ; # Y
  br label %$4
$18:
  %60 = phi i64 [%54, %$9] ; # X
  %61 = phi i64 [%55, %$9] ; # Y
  br label %$2
$4:
  %62 = phi i64 [%20, %$8], [%51, %$11], [%58, %$19] ; # X
  %63 = phi i64 [%21, %$8], [%52, %$11], [%59, %$19] ; # Y
  %64 = phi i64 [%22, %$8], [%53, %$11], [1, %$19] ; # ->
  ret i64 %64
}

define i64 @isIntern(i64, i64) {
$1:
; # (if (cnt? Name) (let X (car Tree) (loop (? (atom X) 0) (let (S (c...
; # (cnt? Name)
  %2 = and i64 %0, 2
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (let X (car Tree) (loop (? (atom X) 0) (let (S (car X) Nm (name (...
; # (car Tree)
  %4 = inttoptr i64 %1 to i64*
  %5 = load i64, i64* %4
; # (loop (? (atom X) 0) (let (S (car X) Nm (name (val (tail S)))) (?...
  br label %$5
$5:
  %6 = phi i64 [%5, %$2], [%42, %$16] ; # X
; # (? (atom X) 0)
; # (atom X)
  %7 = and i64 %6, 15
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$8, label %$6
$8:
  %9 = phi i64 [%6, %$5] ; # X
  br label %$7
$6:
  %10 = phi i64 [%6, %$5] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) S) (set...
; # (car X)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (tail S)
  %13 = add i64 %12, -8
; # (val (tail S))
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
; # (name (val (tail S)))
  br label %$9
$9:
  %16 = phi i64 [%15, %$6], [%22, %$10] ; # Tail
  %17 = and i64 %16, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$10:
  %19 = phi i64 [%16, %$9] ; # Tail
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
  br label %$9
$11:
  %23 = phi i64 [%16, %$9] ; # Tail
; # (? (== Name Nm) S)
; # (== Name Nm)
  %24 = icmp eq i64 %0, %23
  br i1 %24, label %$13, label %$12
$13:
  %25 = phi i64 [%10, %$11] ; # X
  br label %$7
$12:
  %26 = phi i64 [%10, %$11] ; # X
; # (if (> Name Nm) (cddr X) (cadr X))
; # (> Name Nm)
  %27 = icmp ugt i64 %0, %23
  br i1 %27, label %$14, label %$15
$14:
  %28 = phi i64 [%26, %$12] ; # X
; # (cddr X)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
  br label %$16
$15:
  %35 = phi i64 [%26, %$12] ; # X
; # (cadr X)
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  br label %$16
$16:
  %41 = phi i64 [%28, %$14], [%35, %$15] ; # X
  %42 = phi i64 [%34, %$14], [%40, %$15] ; # ->
  br label %$5
$7:
  %43 = phi i64 [%9, %$8], [%25, %$13] ; # X
  %44 = phi i64 [0, %$8], [%12, %$13] ; # ->
  br label %$4
$3:
; # (let X (cdr Tree) (loop (? (atom X) 0) (let (S (car X) Nm (name (...
; # (cdr Tree)
  %45 = inttoptr i64 %1 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (loop (? (atom X) 0) (let (S (car X) Nm (name (val (tail S)))) (?...
  br label %$17
$17:
  %48 = phi i64 [%47, %$3], [%85, %$28] ; # X
; # (? (atom X) 0)
; # (atom X)
  %49 = and i64 %48, 15
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$20, label %$18
$20:
  %51 = phi i64 [%48, %$17] ; # X
  br label %$19
$18:
  %52 = phi i64 [%48, %$17] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (=0 (cmpLong Nm Name...
; # (car X)
  %53 = inttoptr i64 %52 to i64*
  %54 = load i64, i64* %53
; # (tail S)
  %55 = add i64 %54, -8
; # (val (tail S))
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
; # (name (val (tail S)))
  br label %$21
$21:
  %58 = phi i64 [%57, %$18], [%64, %$22] ; # Tail
  %59 = and i64 %58, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$23, label %$22
$22:
  %61 = phi i64 [%58, %$21] ; # Tail
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  br label %$21
$23:
  %65 = phi i64 [%58, %$21] ; # Tail
; # (? (=0 (cmpLong Nm Name)) S)
; # (cmpLong Nm Name)
  %66 = call i64 @cmpLong(i64 %65, i64 %0)
; # (=0 (cmpLong Nm Name))
  %67 = icmp eq i64 %66, 0
  br i1 %67, label %$25, label %$24
$25:
  %68 = phi i64 [%52, %$23] ; # X
  br label %$19
$24:
  %69 = phi i64 [%52, %$23] ; # X
; # (if (lt0 @) (cddr X) (cadr X))
; # (lt0 @)
  %70 = icmp slt i64 %66, 0
  br i1 %70, label %$26, label %$27
$26:
  %71 = phi i64 [%69, %$24] ; # X
; # (cddr X)
  %72 = inttoptr i64 %71 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
  %75 = inttoptr i64 %74 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
  br label %$28
$27:
  %78 = phi i64 [%69, %$24] ; # X
; # (cadr X)
  %79 = inttoptr i64 %78 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %81 to i64*
  %83 = load i64, i64* %82
  br label %$28
$28:
  %84 = phi i64 [%71, %$26], [%78, %$27] ; # X
  %85 = phi i64 [%77, %$26], [%83, %$27] ; # ->
  br label %$17
$19:
  %86 = phi i64 [%51, %$20], [%68, %$25] ; # X
  %87 = phi i64 [0, %$20], [%54, %$25] ; # ->
  br label %$4
$4:
  %88 = phi i64 [%44, %$7], [%87, %$19] ; # ->
  ret i64 %88
}

define i64 @isLstIntern(i64, i64) {
$1:
; # (loop (? (atom Lst) 0) (? (isIntern Name (cdar (car Lst))) @) (sh...
  br label %$2
$2:
  %2 = phi i64 [%1, %$1], [%20, %$6] ; # Lst
; # (? (atom Lst) 0)
; # (atom Lst)
  %3 = and i64 %2, 15
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$5, label %$3
$5:
  %5 = phi i64 [%2, %$2] ; # Lst
  br label %$4
$3:
  %6 = phi i64 [%2, %$2] ; # Lst
; # (? (isIntern Name (cdar (car Lst))) @)
; # (car Lst)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (cdar (car Lst))
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
; # (isIntern Name (cdar (car Lst)))
  %14 = call i64 @isIntern(i64 %0, i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  %16 = phi i64 [%6, %$3] ; # Lst
  br label %$4
$6:
  %17 = phi i64 [%6, %$3] ; # Lst
; # (shift Lst)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  br label %$2
$4:
  %21 = phi i64 [%5, %$5], [%16, %$7] ; # Lst
  %22 = phi i64 [0, %$5], [%14, %$7] ; # ->
  ret i64 %22
}

define i64 @intern(i64, i64, i64, i64, i64) {
$1:
; # (if (cnt? Name) (let X (car Tree) (if (pair X) (loop (let (S (car...
; # (cnt? Name)
  %5 = and i64 %2, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$2, label %$3
$2:
; # (let X (car Tree) (if (pair X) (loop (let (S (car X) Nm (name (va...
; # (car Tree)
  %7 = inttoptr i64 %3 to i64*
  %8 = load i64, i64* %7
; # (if (pair X) (loop (let (S (car X) Nm (name (val (tail S)))) (? (...
; # (pair X)
  %9 = and i64 %8, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$5, label %$6
$5:
  %11 = phi i64 [%8, %$2] ; # X
; # (loop (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) S...
  br label %$8
$8:
  %12 = phi i64 [%11, %$5], [%152, %$15] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) S) (let...
; # (car X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (tail S)
  %15 = add i64 %14, -8
; # (val (tail S))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (name (val (tail S)))
  br label %$9
$9:
  %18 = phi i64 [%17, %$8], [%24, %$10] ; # Tail
  %19 = and i64 %18, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$11, label %$10
$10:
  %21 = phi i64 [%18, %$9] ; # Tail
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  br label %$9
$11:
  %25 = phi i64 [%18, %$9] ; # Tail
; # (? (== Name Nm) S)
; # (== Name Nm)
  %26 = icmp eq i64 %2, %25
  br i1 %26, label %$14, label %$12
$14:
  %27 = phi i64 [%12, %$11] ; # X
  br label %$13
$12:
  %28 = phi i64 [%12, %$11] ; # X
; # (let Y (cdr X) (cond ((> Name Nm) (? (atom Y) (internRight Sym Va...
; # (cdr X)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (cond ((> Name Nm) (? (atom Y) (internRight Sym Val Name X More))...
; # (> Name Nm)
  %32 = icmp ugt i64 %2, %25
  br i1 %32, label %$17, label %$16
$17:
  %33 = phi i64 [%28, %$12] ; # X
  %34 = phi i64 [%31, %$12] ; # Y
; # (? (atom Y) (internRight Sym Val Name X More))
; # (atom Y)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$19, label %$18
$19:
  %37 = phi i64 [%33, %$17] ; # X
  %38 = phi i64 [%34, %$17] ; # Y
; # (internRight Sym Val Name X More)
  %39 = call i64 @isLstIntern(i64 %2, i64 %4)
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$21, label %$20
$21:
  %41 = phi i64 [%0, %$19] ; # Sym
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$22, label %$23
$23:
  %43 = phi i64 [%41, %$21] ; # Sym
  %44 = icmp eq i64 %39, %43
  br label %$22
$22:
  %45 = phi i64 [%41, %$21], [%43, %$23] ; # Sym
  %46 = phi i1 [1, %$21], [%44, %$23] ; # ->
  br label %$20
$20:
  %47 = phi i64 [%0, %$19], [%45, %$22] ; # Sym
  %48 = phi i1 [0, %$19], [%46, %$22] ; # ->
  br i1 %48, label %$24, label %$25
$24:
  %49 = phi i64 [%47, %$20] ; # Sym
  br label %$26
$25:
  %50 = phi i64 [%47, %$20] ; # Sym
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$28, label %$27
$27:
  %52 = phi i64 [%50, %$25] ; # Sym
  %53 = call i64 @consSym(i64 %2, i64 %1)
  br label %$28
$28:
  %54 = phi i64 [%50, %$25], [%53, %$27] ; # Sym
  %55 = call i64 @cons(i64 %54, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %56 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 %55)
  %57 = inttoptr i64 %37 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
  br label %$26
$26:
  %59 = phi i64 [%49, %$24], [%54, %$28] ; # Sym
  %60 = phi i64 [%39, %$24], [%54, %$28] ; # ->
  br label %$13
$18:
  %61 = phi i64 [%33, %$17] ; # X
  %62 = phi i64 [%34, %$17] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (intern2 Sym Val Name X More)...
; # (cdr (setq X Y))
  %63 = inttoptr i64 %62 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  %65 = load i64, i64* %64
; # (atom (setq Y (cdr (setq X Y))))
  %66 = and i64 %65, 15
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$30, label %$29
$30:
  %68 = phi i64 [%62, %$18] ; # X
  %69 = phi i64 [%65, %$18] ; # Y
; # (intern2 Sym Val Name X More)
  %70 = call i64 @isLstIntern(i64 %2, i64 %4)
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$32, label %$31
$32:
  %72 = phi i64 [%0, %$30] ; # Sym
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %$33, label %$34
$34:
  %74 = phi i64 [%72, %$32] ; # Sym
  %75 = icmp eq i64 %70, %74
  br label %$33
$33:
  %76 = phi i64 [%72, %$32], [%74, %$34] ; # Sym
  %77 = phi i1 [1, %$32], [%75, %$34] ; # ->
  br label %$31
$31:
  %78 = phi i64 [%0, %$30], [%76, %$33] ; # Sym
  %79 = phi i1 [0, %$30], [%77, %$33] ; # ->
  br i1 %79, label %$35, label %$36
$35:
  %80 = phi i64 [%78, %$31] ; # Sym
  br label %$37
$36:
  %81 = phi i64 [%78, %$31] ; # Sym
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$39, label %$38
$38:
  %83 = phi i64 [%81, %$36] ; # Sym
  %84 = call i64 @consSym(i64 %2, i64 %1)
  br label %$39
$39:
  %85 = phi i64 [%81, %$36], [%84, %$38] ; # Sym
  %86 = call i64 @cons(i64 %85, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %87 = inttoptr i64 %68 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  store i64 %86, i64* %88
  br label %$37
$37:
  %89 = phi i64 [%80, %$35], [%85, %$39] ; # Sym
  %90 = phi i64 [%70, %$35], [%85, %$39] ; # ->
  br label %$13
$29:
  %91 = phi i64 [%62, %$18] ; # X
  %92 = phi i64 [%65, %$18] ; # Y
  br label %$15
$16:
  %93 = phi i64 [%28, %$12] ; # X
  %94 = phi i64 [%31, %$12] ; # Y
; # (? (atom Y) (internLeft Sym Val Name X More))
; # (atom Y)
  %95 = and i64 %94, 15
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$41, label %$40
$41:
  %97 = phi i64 [%93, %$16] ; # X
  %98 = phi i64 [%94, %$16] ; # Y
; # (internLeft Sym Val Name X More)
  %99 = call i64 @isLstIntern(i64 %2, i64 %4)
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$43, label %$42
$43:
  %101 = phi i64 [%0, %$41] ; # Sym
  %102 = icmp eq i64 %101, 0
  br i1 %102, label %$44, label %$45
$45:
  %103 = phi i64 [%101, %$43] ; # Sym
  %104 = icmp eq i64 %99, %103
  br label %$44
$44:
  %105 = phi i64 [%101, %$43], [%103, %$45] ; # Sym
  %106 = phi i1 [1, %$43], [%104, %$45] ; # ->
  br label %$42
$42:
  %107 = phi i64 [%0, %$41], [%105, %$44] ; # Sym
  %108 = phi i1 [0, %$41], [%106, %$44] ; # ->
  br i1 %108, label %$46, label %$47
$46:
  %109 = phi i64 [%107, %$42] ; # Sym
  br label %$48
$47:
  %110 = phi i64 [%107, %$42] ; # Sym
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$50, label %$49
$49:
  %112 = phi i64 [%110, %$47] ; # Sym
  %113 = call i64 @consSym(i64 %2, i64 %1)
  br label %$50
$50:
  %114 = phi i64 [%110, %$47], [%113, %$49] ; # Sym
  %115 = call i64 @cons(i64 %114, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %116 = call i64 @cons(i64 %115, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %117 = inttoptr i64 %97 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  store i64 %116, i64* %118
  br label %$48
$48:
  %119 = phi i64 [%109, %$46], [%114, %$50] ; # Sym
  %120 = phi i64 [%99, %$46], [%114, %$50] ; # ->
  br label %$13
$40:
  %121 = phi i64 [%93, %$16] ; # X
  %122 = phi i64 [%94, %$16] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (intern1 Sym Val Name X More)...
; # (car (setq X Y))
  %123 = inttoptr i64 %122 to i64*
  %124 = load i64, i64* %123
; # (atom (setq Y (car (setq X Y))))
  %125 = and i64 %124, 15
  %126 = icmp ne i64 %125, 0
  br i1 %126, label %$52, label %$51
$52:
  %127 = phi i64 [%122, %$40] ; # X
  %128 = phi i64 [%124, %$40] ; # Y
; # (intern1 Sym Val Name X More)
  %129 = call i64 @isLstIntern(i64 %2, i64 %4)
  %130 = icmp ne i64 %129, 0
  br i1 %130, label %$54, label %$53
$54:
  %131 = phi i64 [%0, %$52] ; # Sym
  %132 = icmp eq i64 %131, 0
  br i1 %132, label %$55, label %$56
$56:
  %133 = phi i64 [%131, %$54] ; # Sym
  %134 = icmp eq i64 %129, %133
  br label %$55
$55:
  %135 = phi i64 [%131, %$54], [%133, %$56] ; # Sym
  %136 = phi i1 [1, %$54], [%134, %$56] ; # ->
  br label %$53
$53:
  %137 = phi i64 [%0, %$52], [%135, %$55] ; # Sym
  %138 = phi i1 [0, %$52], [%136, %$55] ; # ->
  br i1 %138, label %$57, label %$58
$57:
  %139 = phi i64 [%137, %$53] ; # Sym
  br label %$59
$58:
  %140 = phi i64 [%137, %$53] ; # Sym
  %141 = icmp ne i64 %140, 0
  br i1 %141, label %$61, label %$60
$60:
  %142 = phi i64 [%140, %$58] ; # Sym
  %143 = call i64 @consSym(i64 %2, i64 %1)
  br label %$61
$61:
  %144 = phi i64 [%140, %$58], [%143, %$60] ; # Sym
  %145 = call i64 @cons(i64 %144, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %146 = inttoptr i64 %127 to i64*
  store i64 %145, i64* %146
  br label %$59
$59:
  %147 = phi i64 [%139, %$57], [%144, %$61] ; # Sym
  %148 = phi i64 [%129, %$57], [%144, %$61] ; # ->
  br label %$13
$51:
  %149 = phi i64 [%122, %$40] ; # X
  %150 = phi i64 [%124, %$40] ; # Y
  br label %$15
$15:
  %151 = phi i64 [%91, %$29], [%149, %$51] ; # X
  %152 = phi i64 [%92, %$29], [%150, %$51] ; # Y
  br label %$8
$13:
  %153 = phi i64 [%27, %$14], [%37, %$26], [%68, %$37], [%97, %$48], [%127, %$59] ; # X
  %154 = phi i64 [%14, %$14], [%60, %$26], [%90, %$37], [%120, %$48], [%148, %$59] ; # ->
  br label %$7
$6:
  %155 = phi i64 [%8, %$2] ; # X
; # (intern1 Sym Val Name Tree More)
  %156 = call i64 @isLstIntern(i64 %2, i64 %4)
  %157 = icmp ne i64 %156, 0
  br i1 %157, label %$63, label %$62
$63:
  %158 = phi i64 [%0, %$6] ; # Sym
  %159 = icmp eq i64 %158, 0
  br i1 %159, label %$64, label %$65
$65:
  %160 = phi i64 [%158, %$63] ; # Sym
  %161 = icmp eq i64 %156, %160
  br label %$64
$64:
  %162 = phi i64 [%158, %$63], [%160, %$65] ; # Sym
  %163 = phi i1 [1, %$63], [%161, %$65] ; # ->
  br label %$62
$62:
  %164 = phi i64 [%0, %$6], [%162, %$64] ; # Sym
  %165 = phi i1 [0, %$6], [%163, %$64] ; # ->
  br i1 %165, label %$66, label %$67
$66:
  %166 = phi i64 [%164, %$62] ; # Sym
  br label %$68
$67:
  %167 = phi i64 [%164, %$62] ; # Sym
  %168 = icmp ne i64 %167, 0
  br i1 %168, label %$70, label %$69
$69:
  %169 = phi i64 [%167, %$67] ; # Sym
  %170 = call i64 @consSym(i64 %2, i64 %1)
  br label %$70
$70:
  %171 = phi i64 [%167, %$67], [%170, %$69] ; # Sym
  %172 = call i64 @cons(i64 %171, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %173 = inttoptr i64 %3 to i64*
  store i64 %172, i64* %173
  br label %$68
$68:
  %174 = phi i64 [%166, %$66], [%171, %$70] ; # Sym
  %175 = phi i64 [%156, %$66], [%171, %$70] ; # ->
  br label %$7
$7:
  %176 = phi i64 [%153, %$13], [%155, %$68] ; # X
  %177 = phi i64 [%154, %$13], [%175, %$68] ; # ->
  br label %$4
$3:
; # (let X (cdr Tree) (if (pair X) (loop (let (S (car X) Nm (name (va...
; # (cdr Tree)
  %178 = inttoptr i64 %3 to i64*
  %179 = getelementptr i64, i64* %178, i32 1
  %180 = load i64, i64* %179
; # (if (pair X) (loop (let (S (car X) Nm (name (val (tail S)))) (? (...
; # (pair X)
  %181 = and i64 %180, 15
  %182 = icmp eq i64 %181, 0
  br i1 %182, label %$71, label %$72
$71:
  %183 = phi i64 [%180, %$3] ; # X
; # (loop (let (S (car X) Nm (name (val (tail S)))) (? (=0 (cmpLong N...
  br label %$74
$74:
  %184 = phi i64 [%183, %$71], [%325, %$81] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (=0 (cmpLong Nm Name...
; # (car X)
  %185 = inttoptr i64 %184 to i64*
  %186 = load i64, i64* %185
; # (tail S)
  %187 = add i64 %186, -8
; # (val (tail S))
  %188 = inttoptr i64 %187 to i64*
  %189 = load i64, i64* %188
; # (name (val (tail S)))
  br label %$75
$75:
  %190 = phi i64 [%189, %$74], [%196, %$76] ; # Tail
  %191 = and i64 %190, 6
  %192 = icmp ne i64 %191, 0
  br i1 %192, label %$77, label %$76
$76:
  %193 = phi i64 [%190, %$75] ; # Tail
  %194 = inttoptr i64 %193 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
  br label %$75
$77:
  %197 = phi i64 [%190, %$75] ; # Tail
; # (? (=0 (cmpLong Nm Name)) S)
; # (cmpLong Nm Name)
  %198 = call i64 @cmpLong(i64 %197, i64 %2)
; # (=0 (cmpLong Nm Name))
  %199 = icmp eq i64 %198, 0
  br i1 %199, label %$80, label %$78
$80:
  %200 = phi i64 [%184, %$77] ; # X
  br label %$79
$78:
  %201 = phi i64 [%184, %$77] ; # X
; # (let Y (cdr X) (cond ((lt0 @) (? (atom Y) (internRight Sym Val Na...
; # (cdr X)
  %202 = inttoptr i64 %201 to i64*
  %203 = getelementptr i64, i64* %202, i32 1
  %204 = load i64, i64* %203
; # (cond ((lt0 @) (? (atom Y) (internRight Sym Val Name X More)) (? ...
; # (lt0 @)
  %205 = icmp slt i64 %198, 0
  br i1 %205, label %$83, label %$82
$83:
  %206 = phi i64 [%201, %$78] ; # X
  %207 = phi i64 [%204, %$78] ; # Y
; # (? (atom Y) (internRight Sym Val Name X More))
; # (atom Y)
  %208 = and i64 %207, 15
  %209 = icmp ne i64 %208, 0
  br i1 %209, label %$85, label %$84
$85:
  %210 = phi i64 [%206, %$83] ; # X
  %211 = phi i64 [%207, %$83] ; # Y
; # (internRight Sym Val Name X More)
  %212 = call i64 @isLstIntern(i64 %2, i64 %4)
  %213 = icmp ne i64 %212, 0
  br i1 %213, label %$87, label %$86
$87:
  %214 = phi i64 [%0, %$85] ; # Sym
  %215 = icmp eq i64 %214, 0
  br i1 %215, label %$88, label %$89
$89:
  %216 = phi i64 [%214, %$87] ; # Sym
  %217 = icmp eq i64 %212, %216
  br label %$88
$88:
  %218 = phi i64 [%214, %$87], [%216, %$89] ; # Sym
  %219 = phi i1 [1, %$87], [%217, %$89] ; # ->
  br label %$86
$86:
  %220 = phi i64 [%0, %$85], [%218, %$88] ; # Sym
  %221 = phi i1 [0, %$85], [%219, %$88] ; # ->
  br i1 %221, label %$90, label %$91
$90:
  %222 = phi i64 [%220, %$86] ; # Sym
  br label %$92
$91:
  %223 = phi i64 [%220, %$86] ; # Sym
  %224 = icmp ne i64 %223, 0
  br i1 %224, label %$94, label %$93
$93:
  %225 = phi i64 [%223, %$91] ; # Sym
  %226 = call i64 @consSym(i64 %2, i64 %1)
  br label %$94
$94:
  %227 = phi i64 [%223, %$91], [%226, %$93] ; # Sym
  %228 = call i64 @cons(i64 %227, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %229 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 %228)
  %230 = inttoptr i64 %210 to i64*
  %231 = getelementptr i64, i64* %230, i32 1
  store i64 %229, i64* %231
  br label %$92
$92:
  %232 = phi i64 [%222, %$90], [%227, %$94] ; # Sym
  %233 = phi i64 [%212, %$90], [%227, %$94] ; # ->
  br label %$79
$84:
  %234 = phi i64 [%206, %$83] ; # X
  %235 = phi i64 [%207, %$83] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (intern2 Sym Val Name X More)...
; # (cdr (setq X Y))
  %236 = inttoptr i64 %235 to i64*
  %237 = getelementptr i64, i64* %236, i32 1
  %238 = load i64, i64* %237
; # (atom (setq Y (cdr (setq X Y))))
  %239 = and i64 %238, 15
  %240 = icmp ne i64 %239, 0
  br i1 %240, label %$96, label %$95
$96:
  %241 = phi i64 [%235, %$84] ; # X
  %242 = phi i64 [%238, %$84] ; # Y
; # (intern2 Sym Val Name X More)
  %243 = call i64 @isLstIntern(i64 %2, i64 %4)
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$98, label %$97
$98:
  %245 = phi i64 [%0, %$96] ; # Sym
  %246 = icmp eq i64 %245, 0
  br i1 %246, label %$99, label %$100
$100:
  %247 = phi i64 [%245, %$98] ; # Sym
  %248 = icmp eq i64 %243, %247
  br label %$99
$99:
  %249 = phi i64 [%245, %$98], [%247, %$100] ; # Sym
  %250 = phi i1 [1, %$98], [%248, %$100] ; # ->
  br label %$97
$97:
  %251 = phi i64 [%0, %$96], [%249, %$99] ; # Sym
  %252 = phi i1 [0, %$96], [%250, %$99] ; # ->
  br i1 %252, label %$101, label %$102
$101:
  %253 = phi i64 [%251, %$97] ; # Sym
  br label %$103
$102:
  %254 = phi i64 [%251, %$97] ; # Sym
  %255 = icmp ne i64 %254, 0
  br i1 %255, label %$105, label %$104
$104:
  %256 = phi i64 [%254, %$102] ; # Sym
  %257 = call i64 @consSym(i64 %2, i64 %1)
  br label %$105
$105:
  %258 = phi i64 [%254, %$102], [%257, %$104] ; # Sym
  %259 = call i64 @cons(i64 %258, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %260 = inttoptr i64 %241 to i64*
  %261 = getelementptr i64, i64* %260, i32 1
  store i64 %259, i64* %261
  br label %$103
$103:
  %262 = phi i64 [%253, %$101], [%258, %$105] ; # Sym
  %263 = phi i64 [%243, %$101], [%258, %$105] ; # ->
  br label %$79
$95:
  %264 = phi i64 [%235, %$84] ; # X
  %265 = phi i64 [%238, %$84] ; # Y
  br label %$81
$82:
  %266 = phi i64 [%201, %$78] ; # X
  %267 = phi i64 [%204, %$78] ; # Y
; # (? (atom Y) (internLeft Sym Val Name X More))
; # (atom Y)
  %268 = and i64 %267, 15
  %269 = icmp ne i64 %268, 0
  br i1 %269, label %$107, label %$106
$107:
  %270 = phi i64 [%266, %$82] ; # X
  %271 = phi i64 [%267, %$82] ; # Y
; # (internLeft Sym Val Name X More)
  %272 = call i64 @isLstIntern(i64 %2, i64 %4)
  %273 = icmp ne i64 %272, 0
  br i1 %273, label %$109, label %$108
$109:
  %274 = phi i64 [%0, %$107] ; # Sym
  %275 = icmp eq i64 %274, 0
  br i1 %275, label %$110, label %$111
$111:
  %276 = phi i64 [%274, %$109] ; # Sym
  %277 = icmp eq i64 %272, %276
  br label %$110
$110:
  %278 = phi i64 [%274, %$109], [%276, %$111] ; # Sym
  %279 = phi i1 [1, %$109], [%277, %$111] ; # ->
  br label %$108
$108:
  %280 = phi i64 [%0, %$107], [%278, %$110] ; # Sym
  %281 = phi i1 [0, %$107], [%279, %$110] ; # ->
  br i1 %281, label %$112, label %$113
$112:
  %282 = phi i64 [%280, %$108] ; # Sym
  br label %$114
$113:
  %283 = phi i64 [%280, %$108] ; # Sym
  %284 = icmp ne i64 %283, 0
  br i1 %284, label %$116, label %$115
$115:
  %285 = phi i64 [%283, %$113] ; # Sym
  %286 = call i64 @consSym(i64 %2, i64 %1)
  br label %$116
$116:
  %287 = phi i64 [%283, %$113], [%286, %$115] ; # Sym
  %288 = call i64 @cons(i64 %287, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %289 = call i64 @cons(i64 %288, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %290 = inttoptr i64 %270 to i64*
  %291 = getelementptr i64, i64* %290, i32 1
  store i64 %289, i64* %291
  br label %$114
$114:
  %292 = phi i64 [%282, %$112], [%287, %$116] ; # Sym
  %293 = phi i64 [%272, %$112], [%287, %$116] ; # ->
  br label %$79
$106:
  %294 = phi i64 [%266, %$82] ; # X
  %295 = phi i64 [%267, %$82] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (intern1 Sym Val Name X More)...
; # (car (setq X Y))
  %296 = inttoptr i64 %295 to i64*
  %297 = load i64, i64* %296
; # (atom (setq Y (car (setq X Y))))
  %298 = and i64 %297, 15
  %299 = icmp ne i64 %298, 0
  br i1 %299, label %$118, label %$117
$118:
  %300 = phi i64 [%295, %$106] ; # X
  %301 = phi i64 [%297, %$106] ; # Y
; # (intern1 Sym Val Name X More)
  %302 = call i64 @isLstIntern(i64 %2, i64 %4)
  %303 = icmp ne i64 %302, 0
  br i1 %303, label %$120, label %$119
$120:
  %304 = phi i64 [%0, %$118] ; # Sym
  %305 = icmp eq i64 %304, 0
  br i1 %305, label %$121, label %$122
$122:
  %306 = phi i64 [%304, %$120] ; # Sym
  %307 = icmp eq i64 %302, %306
  br label %$121
$121:
  %308 = phi i64 [%304, %$120], [%306, %$122] ; # Sym
  %309 = phi i1 [1, %$120], [%307, %$122] ; # ->
  br label %$119
$119:
  %310 = phi i64 [%0, %$118], [%308, %$121] ; # Sym
  %311 = phi i1 [0, %$118], [%309, %$121] ; # ->
  br i1 %311, label %$123, label %$124
$123:
  %312 = phi i64 [%310, %$119] ; # Sym
  br label %$125
$124:
  %313 = phi i64 [%310, %$119] ; # Sym
  %314 = icmp ne i64 %313, 0
  br i1 %314, label %$127, label %$126
$126:
  %315 = phi i64 [%313, %$124] ; # Sym
  %316 = call i64 @consSym(i64 %2, i64 %1)
  br label %$127
$127:
  %317 = phi i64 [%313, %$124], [%316, %$126] ; # Sym
  %318 = call i64 @cons(i64 %317, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %319 = inttoptr i64 %300 to i64*
  store i64 %318, i64* %319
  br label %$125
$125:
  %320 = phi i64 [%312, %$123], [%317, %$127] ; # Sym
  %321 = phi i64 [%302, %$123], [%317, %$127] ; # ->
  br label %$79
$117:
  %322 = phi i64 [%295, %$106] ; # X
  %323 = phi i64 [%297, %$106] ; # Y
  br label %$81
$81:
  %324 = phi i64 [%264, %$95], [%322, %$117] ; # X
  %325 = phi i64 [%265, %$95], [%323, %$117] ; # Y
  br label %$74
$79:
  %326 = phi i64 [%200, %$80], [%210, %$92], [%241, %$103], [%270, %$114], [%300, %$125] ; # X
  %327 = phi i64 [%186, %$80], [%233, %$92], [%263, %$103], [%293, %$114], [%321, %$125] ; # ->
  br label %$73
$72:
  %328 = phi i64 [%180, %$3] ; # X
; # (intern2 Sym Val Name Tree More)
  %329 = call i64 @isLstIntern(i64 %2, i64 %4)
  %330 = icmp ne i64 %329, 0
  br i1 %330, label %$129, label %$128
$129:
  %331 = phi i64 [%0, %$72] ; # Sym
  %332 = icmp eq i64 %331, 0
  br i1 %332, label %$130, label %$131
$131:
  %333 = phi i64 [%331, %$129] ; # Sym
  %334 = icmp eq i64 %329, %333
  br label %$130
$130:
  %335 = phi i64 [%331, %$129], [%333, %$131] ; # Sym
  %336 = phi i1 [1, %$129], [%334, %$131] ; # ->
  br label %$128
$128:
  %337 = phi i64 [%0, %$72], [%335, %$130] ; # Sym
  %338 = phi i1 [0, %$72], [%336, %$130] ; # ->
  br i1 %338, label %$132, label %$133
$132:
  %339 = phi i64 [%337, %$128] ; # Sym
  br label %$134
$133:
  %340 = phi i64 [%337, %$128] ; # Sym
  %341 = icmp ne i64 %340, 0
  br i1 %341, label %$136, label %$135
$135:
  %342 = phi i64 [%340, %$133] ; # Sym
  %343 = call i64 @consSym(i64 %2, i64 %1)
  br label %$136
$136:
  %344 = phi i64 [%340, %$133], [%343, %$135] ; # Sym
  %345 = call i64 @cons(i64 %344, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %346 = inttoptr i64 %3 to i64*
  %347 = getelementptr i64, i64* %346, i32 1
  store i64 %345, i64* %347
  br label %$134
$134:
  %348 = phi i64 [%339, %$132], [%344, %$136] ; # Sym
  %349 = phi i64 [%329, %$132], [%344, %$136] ; # ->
  br label %$73
$73:
  %350 = phi i64 [%326, %$79], [%328, %$134] ; # X
  %351 = phi i64 [%327, %$79], [%349, %$134] ; # ->
  br label %$4
$4:
  %352 = phi i64 [%177, %$7], [%351, %$73] ; # ->
  ret i64 %352
}

define i64 @requestSym(i64) {
$1:
; # (val $Intern)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %2 = load i64, i64* %1
; # (car (val $Intern))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (cdar (car (val $Intern)))
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = inttoptr i64 %6 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
; # (val $Intern)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %11 = load i64, i64* %10
; # (cdr (val $Intern))
  %12 = inttoptr i64 %11 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  %14 = load i64, i64* %13
; # (intern 0 $Nil Name (cdar (car (val $Intern))) (cdr (val $Intern)...
  %15 = call i64 @intern(i64 0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 %0, i64 %9, i64 %14)
  ret i64 %15
}

define i64 @extern(i64) {
$1:
; # (let (X (val $Extern) C 0 Sym T) (loop (inc 'C) (setq Sym (car X)...
; # (val $Extern)
  %1 = load i64, i64* @$Extern
; # (loop (inc 'C) (setq Sym (car X)) (let Nm (& (name (& (val (tail ...
  br label %$2
$2:
  %2 = phi i64 [%1, %$1], [%101, %$8] ; # X
  %3 = phi i64 [0, %$1], [%99, %$8] ; # C
; # (inc 'C)
  %4 = add i64 %3, 1
; # (car X)
  %5 = inttoptr i64 %2 to i64*
  %6 = load i64, i64* %5
; # (let Nm (& (name (& (val (tail Sym)) -9)) (hex "3FFFFFFFFFFFFFF7"...
; # (tail Sym)
  %7 = add i64 %6, -8
; # (val (tail Sym))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (& (val (tail Sym)) -9)
  %10 = and i64 %9, -9
; # (name (& (val (tail Sym)) -9))
  br label %$3
$3:
  %11 = phi i64 [%10, %$2], [%17, %$4] ; # Tail
  %12 = and i64 %11, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$5, label %$4
$4:
  %14 = phi i64 [%11, %$3] ; # Tail
  %15 = inttoptr i64 %14 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  br label %$3
$5:
  %18 = phi i64 [%11, %$3] ; # Tail
; # (& (name (& (val (tail Sym)) -9)) (hex "3FFFFFFFFFFFFFF7"))
  %19 = and i64 %18, 4611686018427387895
; # (? (== Nm Name))
; # (== Nm Name)
  %20 = icmp eq i64 %19, %0
  br i1 %20, label %$7, label %$6
$6:
  %21 = phi i64 [%2, %$5] ; # X
  %22 = phi i64 [%4, %$5] ; # C
  %23 = phi i64 [%6, %$5] ; # Sym
; # (let Y (cdr X) (cond ((> Name Nm) (? (atom Y) (set 2 X (cons $Nil...
; # (cdr X)
  %24 = inttoptr i64 %21 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (cond ((> Name Nm) (? (atom Y) (set 2 X (cons $Nil (cons (setq Sy...
; # (> Name Nm)
  %27 = icmp ugt i64 %0, %19
  br i1 %27, label %$10, label %$9
$10:
  %28 = phi i64 [%21, %$6] ; # X
  %29 = phi i64 [%22, %$6] ; # C
  %30 = phi i64 [%23, %$6] ; # Sym
  %31 = phi i64 [%26, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons $Nil (cons (setq Sym (consExt Name)) $...
; # (atom Y)
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = phi i64 [%28, %$10] ; # X
  %35 = phi i64 [%29, %$10] ; # C
  %36 = phi i64 [%30, %$10] ; # Sym
  %37 = phi i64 [%31, %$10] ; # Y
; # (set 2 X (cons $Nil (cons (setq Sym (consExt Name)) $Nil)))
; # (consExt Name)
  %38 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %39 = call i64 @cons(i64 %38, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Nil (cons (setq Sym (consExt Name)) $Nil))
  %40 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 %39)
  %41 = inttoptr i64 %34 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  br label %$7
$11:
  %43 = phi i64 [%28, %$10] ; # X
  %44 = phi i64 [%29, %$10] ; # C
  %45 = phi i64 [%30, %$10] ; # Sym
  %46 = phi i64 [%31, %$10] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (set 2 X (cons (setq Sym (con...
; # (cdr (setq X Y))
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
; # (atom (setq Y (cdr (setq X Y))))
  %50 = and i64 %49, 15
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$14, label %$13
$14:
  %52 = phi i64 [%46, %$11] ; # X
  %53 = phi i64 [%44, %$11] ; # C
  %54 = phi i64 [%45, %$11] ; # Sym
  %55 = phi i64 [%49, %$11] ; # Y
; # (set 2 X (cons (setq Sym (consExt Name)) $Nil))
; # (consExt Name)
  %56 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %57 = call i64 @cons(i64 %56, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %58 = inttoptr i64 %52 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %57, i64* %59
  br label %$7
$13:
  %60 = phi i64 [%46, %$11] ; # X
  %61 = phi i64 [%44, %$11] ; # C
  %62 = phi i64 [%45, %$11] ; # Sym
  %63 = phi i64 [%49, %$11] ; # Y
  br label %$8
$9:
  %64 = phi i64 [%21, %$6] ; # X
  %65 = phi i64 [%22, %$6] ; # C
  %66 = phi i64 [%23, %$6] ; # Sym
  %67 = phi i64 [%26, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons (cons (setq Sym (consExt Name)) $Nil) ...
; # (atom Y)
  %68 = and i64 %67, 15
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$16, label %$15
$16:
  %70 = phi i64 [%64, %$9] ; # X
  %71 = phi i64 [%65, %$9] ; # C
  %72 = phi i64 [%66, %$9] ; # Sym
  %73 = phi i64 [%67, %$9] ; # Y
; # (set 2 X (cons (cons (setq Sym (consExt Name)) $Nil) $Nil))
; # (consExt Name)
  %74 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %75 = call i64 @cons(i64 %74, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cons (setq Sym (consExt Name)) $Nil) $Nil)
  %76 = call i64 @cons(i64 %75, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %77 = inttoptr i64 %70 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  br label %$7
$15:
  %79 = phi i64 [%64, %$9] ; # X
  %80 = phi i64 [%65, %$9] ; # C
  %81 = phi i64 [%66, %$9] ; # Sym
  %82 = phi i64 [%67, %$9] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (set X (cons (setq Sym (consE...
; # (car (setq X Y))
  %83 = inttoptr i64 %82 to i64*
  %84 = load i64, i64* %83
; # (atom (setq Y (car (setq X Y))))
  %85 = and i64 %84, 15
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$18, label %$17
$18:
  %87 = phi i64 [%82, %$15] ; # X
  %88 = phi i64 [%80, %$15] ; # C
  %89 = phi i64 [%81, %$15] ; # Sym
  %90 = phi i64 [%84, %$15] ; # Y
; # (set X (cons (setq Sym (consExt Name)) $Nil))
; # (consExt Name)
  %91 = call i64 @consExt(i64 %0)
; # (cons (setq Sym (consExt Name)) $Nil)
  %92 = call i64 @cons(i64 %91, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %93 = inttoptr i64 %87 to i64*
  store i64 %92, i64* %93
  br label %$7
$17:
  %94 = phi i64 [%82, %$15] ; # X
  %95 = phi i64 [%80, %$15] ; # C
  %96 = phi i64 [%81, %$15] ; # Sym
  %97 = phi i64 [%84, %$15] ; # Y
  br label %$8
$8:
  %98 = phi i64 [%60, %$13], [%94, %$17] ; # X
  %99 = phi i64 [%61, %$13], [%95, %$17] ; # C
  %100 = phi i64 [%62, %$13], [%96, %$17] ; # Sym
  %101 = phi i64 [%63, %$13], [%97, %$17] ; # Y
  br label %$2
$7:
  %102 = phi i64 [%2, %$5], [%34, %$12], [%52, %$14], [%70, %$16], [%87, %$18] ; # X
  %103 = phi i64 [%4, %$5], [%35, %$12], [%53, %$14], [%71, %$16], [%88, %$18] ; # C
  %104 = phi i64 [%6, %$5], [%38, %$12], [%56, %$14], [%74, %$16], [%91, %$18] ; # Sym
  %105 = phi i64 [0, %$5], [%40, %$12], [%57, %$14], [%76, %$16], [%92, %$18] ; # ->
; # (shr C 1)
  %106 = lshr i64 %103, 1
; # (when (> (shl 1 C) (val $ExtCnt)) (setq X (val $Extern)) (let N (...
; # (shl 1 C)
  %107 = shl i64 1, %106
; # (val $ExtCnt)
  %108 = load i64, i64* @$ExtCnt
; # (> (shl 1 C) (val $ExtCnt))
  %109 = icmp ugt i64 %107, %108
  br i1 %109, label %$19, label %$20
$19:
  %110 = phi i64 [%102, %$7] ; # X
  %111 = phi i64 [%106, %$7] ; # C
  %112 = phi i64 [%104, %$7] ; # Sym
; # (val $Extern)
  %113 = load i64, i64* @$Extern
; # (let N (val $ExtSkip) (if (> (inc 'N) C) (set $ExtSkip 0) (set $E...
; # (val $ExtSkip)
  %114 = load i64, i64* @$ExtSkip
; # (if (> (inc 'N) C) (set $ExtSkip 0) (set $ExtSkip N) (loop (setq ...
; # (inc 'N)
  %115 = add i64 %114, 1
; # (> (inc 'N) C)
  %116 = icmp ugt i64 %115, %111
  br i1 %116, label %$21, label %$22
$21:
  %117 = phi i64 [%113, %$19] ; # X
  %118 = phi i64 [%111, %$19] ; # C
  %119 = phi i64 [%112, %$19] ; # Sym
  %120 = phi i64 [%115, %$19] ; # N
; # (set $ExtSkip 0)
  store i64 0, i64* @$ExtSkip
  br label %$23
$22:
  %121 = phi i64 [%113, %$19] ; # X
  %122 = phi i64 [%111, %$19] ; # C
  %123 = phi i64 [%112, %$19] ; # Sym
  %124 = phi i64 [%115, %$19] ; # N
; # (set $ExtSkip N)
  store i64 %124, i64* @$ExtSkip
; # (loop (setq X (if (> Name (& (name (& (val (tail (++ X))) -9)) (h...
  br label %$24
$24:
  %125 = phi i64 [%121, %$22], [%167, %$31] ; # X
  %126 = phi i64 [%122, %$22], [%168, %$31] ; # C
  %127 = phi i64 [%123, %$22], [%169, %$31] ; # Sym
  %128 = phi i64 [%124, %$22], [%170, %$31] ; # N
; # (if (> Name (& (name (& (val (tail (++ X))) -9)) (hex "3FFFFFFFFF...
; # (++ X)
  %129 = inttoptr i64 %125 to i64*
  %130 = load i64, i64* %129
  %131 = getelementptr i64, i64* %129, i32 1
  %132 = load i64, i64* %131
; # (tail (++ X))
  %133 = add i64 %130, -8
; # (val (tail (++ X)))
  %134 = inttoptr i64 %133 to i64*
  %135 = load i64, i64* %134
; # (& (val (tail (++ X))) -9)
  %136 = and i64 %135, -9
; # (name (& (val (tail (++ X))) -9))
  br label %$25
$25:
  %137 = phi i64 [%136, %$24], [%143, %$26] ; # Tail
  %138 = and i64 %137, 6
  %139 = icmp ne i64 %138, 0
  br i1 %139, label %$27, label %$26
$26:
  %140 = phi i64 [%137, %$25] ; # Tail
  %141 = inttoptr i64 %140 to i64*
  %142 = getelementptr i64, i64* %141, i32 1
  %143 = load i64, i64* %142
  br label %$25
$27:
  %144 = phi i64 [%137, %$25] ; # Tail
; # (& (name (& (val (tail (++ X))) -9)) (hex "3FFFFFFFFFFFFFF7"))
  %145 = and i64 %144, 4611686018427387895
; # (> Name (& (name (& (val (tail (++ X))) -9)) (hex "3FFFFFFFFFFFFF...
  %146 = icmp ugt i64 %0, %145
  br i1 %146, label %$28, label %$29
$28:
  %147 = phi i64 [%132, %$27] ; # X
  %148 = phi i64 [%126, %$27] ; # C
  %149 = phi i64 [%127, %$27] ; # Sym
  %150 = phi i64 [%128, %$27] ; # N
; # (cdr X)
  %151 = inttoptr i64 %147 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  br label %$30
$29:
  %154 = phi i64 [%132, %$27] ; # X
  %155 = phi i64 [%126, %$27] ; # C
  %156 = phi i64 [%127, %$27] ; # Sym
  %157 = phi i64 [%128, %$27] ; # N
; # (car X)
  %158 = inttoptr i64 %154 to i64*
  %159 = load i64, i64* %158
  br label %$30
$30:
  %160 = phi i64 [%147, %$28], [%154, %$29] ; # X
  %161 = phi i64 [%148, %$28], [%155, %$29] ; # C
  %162 = phi i64 [%149, %$28], [%156, %$29] ; # Sym
  %163 = phi i64 [%150, %$28], [%157, %$29] ; # N
  %164 = phi i64 [%153, %$28], [%159, %$29] ; # ->
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %165 = sub i64 %161, 1
; # (=0 (dec 'C))
  %166 = icmp eq i64 %165, 0
  br i1 %166, label %$32, label %$31
$31:
  %167 = phi i64 [%164, %$30] ; # X
  %168 = phi i64 [%165, %$30] ; # C
  %169 = phi i64 [%162, %$30] ; # Sym
  %170 = phi i64 [%163, %$30] ; # N
  br label %$24
$32:
  %171 = phi i64 [%164, %$30] ; # X
  %172 = phi i64 [%165, %$30] ; # C
  %173 = phi i64 [%162, %$30] ; # Sym
  %174 = phi i64 [%163, %$30] ; # N
  %175 = phi i64 [0, %$30] ; # ->
  br label %$23
$23:
  %176 = phi i64 [%117, %$21], [%171, %$32] ; # X
  %177 = phi i64 [%118, %$21], [%172, %$32] ; # C
  %178 = phi i64 [%119, %$21], [%173, %$32] ; # Sym
  %179 = phi i64 [%120, %$21], [%174, %$32] ; # N
  %180 = phi i64 [0, %$21], [%175, %$32] ; # ->
; # (loop (let (Nm (& (name (& (val (tail (car X))) -9)) (hex "3FFFFF...
  br label %$33
$33:
  %181 = phi i64 [%176, %$23], [%282, %$41] ; # X
  %182 = phi i64 [%177, %$23], [%283, %$41] ; # C
  %183 = phi i64 [%178, %$23], [%284, %$41] ; # Sym
; # (let (Nm (& (name (& (val (tail (car X))) -9)) (hex "3FFFFFFFFFFF...
; # (car X)
  %184 = inttoptr i64 %181 to i64*
  %185 = load i64, i64* %184
; # (tail (car X))
  %186 = add i64 %185, -8
; # (val (tail (car X)))
  %187 = inttoptr i64 %186 to i64*
  %188 = load i64, i64* %187
; # (& (val (tail (car X))) -9)
  %189 = and i64 %188, -9
; # (name (& (val (tail (car X))) -9))
  br label %$34
$34:
  %190 = phi i64 [%189, %$33], [%196, %$35] ; # Tail
  %191 = and i64 %190, 6
  %192 = icmp ne i64 %191, 0
  br i1 %192, label %$36, label %$35
$35:
  %193 = phi i64 [%190, %$34] ; # Tail
  %194 = inttoptr i64 %193 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
  br label %$34
$36:
  %197 = phi i64 [%190, %$34] ; # Tail
; # (& (name (& (val (tail (car X))) -9)) (hex "3FFFFFFFFFFFFFF7"))
  %198 = and i64 %197, 4611686018427387895
; # (cdr X)
  %199 = inttoptr i64 %181 to i64*
  %200 = getelementptr i64, i64* %199, i32 1
  %201 = load i64, i64* %200
; # (? (== Nm Name))
; # (== Nm Name)
  %202 = icmp eq i64 %198, %0
  br i1 %202, label %$38, label %$37
$37:
  %203 = phi i64 [%181, %$36] ; # X
  %204 = phi i64 [%182, %$36] ; # C
  %205 = phi i64 [%183, %$36] ; # Sym
; # (if (> Name Nm) (let Z (cdr Y) (? (atom (cdr Z))) (xchg Z X) (set...
; # (> Name Nm)
  %206 = icmp ugt i64 %0, %198
  br i1 %206, label %$39, label %$40
$39:
  %207 = phi i64 [%203, %$37] ; # X
  %208 = phi i64 [%204, %$37] ; # C
  %209 = phi i64 [%205, %$37] ; # Sym
; # (let Z (cdr Y) (? (atom (cdr Z))) (xchg Z X) (setq Z (cdr Z) X (c...
; # (cdr Y)
  %210 = inttoptr i64 %201 to i64*
  %211 = getelementptr i64, i64* %210, i32 1
  %212 = load i64, i64* %211
; # (? (atom (cdr Z)))
; # (cdr Z)
  %213 = inttoptr i64 %212 to i64*
  %214 = getelementptr i64, i64* %213, i32 1
  %215 = load i64, i64* %214
; # (atom (cdr Z))
  %216 = and i64 %215, 15
  %217 = icmp ne i64 %216, 0
  br i1 %217, label %$38, label %$42
$42:
  %218 = phi i64 [%207, %$39] ; # X
  %219 = phi i64 [%208, %$39] ; # C
  %220 = phi i64 [%209, %$39] ; # Sym
  %221 = phi i64 [%212, %$39] ; # Z
; # (xchg Z X)
  %222 = inttoptr i64 %221 to i64*
  %223 = load i64, i64* %222
  %224 = inttoptr i64 %218 to i64*
  %225 = load i64, i64* %224
  store i64 %225, i64* %222
  store i64 %223, i64* %224
; # (cdr Z)
  %226 = inttoptr i64 %221 to i64*
  %227 = getelementptr i64, i64* %226, i32 1
  %228 = load i64, i64* %227
; # (cdr Z)
  %229 = inttoptr i64 %228 to i64*
  %230 = getelementptr i64, i64* %229, i32 1
  %231 = load i64, i64* %230
; # (set 2 Z (val Z) Z (val Y) Y (cdr Y) 2 Y X)
; # (val Z)
  %232 = inttoptr i64 %228 to i64*
  %233 = load i64, i64* %232
  %234 = inttoptr i64 %228 to i64*
  %235 = getelementptr i64, i64* %234, i32 1
  store i64 %233, i64* %235
; # (val Y)
  %236 = inttoptr i64 %201 to i64*
  %237 = load i64, i64* %236
  %238 = inttoptr i64 %228 to i64*
  store i64 %237, i64* %238
; # (cdr Y)
  %239 = inttoptr i64 %201 to i64*
  %240 = getelementptr i64, i64* %239, i32 1
  %241 = load i64, i64* %240
  %242 = inttoptr i64 %201 to i64*
  store i64 %241, i64* %242
  %243 = inttoptr i64 %201 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  store i64 %231, i64* %244
  br label %$41
$40:
  %245 = phi i64 [%203, %$37] ; # X
  %246 = phi i64 [%204, %$37] ; # C
  %247 = phi i64 [%205, %$37] ; # Sym
; # (let Z (car Y) (? (atom (cdr Z))) (xchg Z X) (setq Z (cdr Z) X (v...
; # (car Y)
  %248 = inttoptr i64 %201 to i64*
  %249 = load i64, i64* %248
; # (? (atom (cdr Z)))
; # (cdr Z)
  %250 = inttoptr i64 %249 to i64*
  %251 = getelementptr i64, i64* %250, i32 1
  %252 = load i64, i64* %251
; # (atom (cdr Z))
  %253 = and i64 %252, 15
  %254 = icmp ne i64 %253, 0
  br i1 %254, label %$38, label %$43
$43:
  %255 = phi i64 [%245, %$40] ; # X
  %256 = phi i64 [%246, %$40] ; # C
  %257 = phi i64 [%247, %$40] ; # Sym
  %258 = phi i64 [%249, %$40] ; # Z
; # (xchg Z X)
  %259 = inttoptr i64 %258 to i64*
  %260 = load i64, i64* %259
  %261 = inttoptr i64 %255 to i64*
  %262 = load i64, i64* %261
  store i64 %262, i64* %259
  store i64 %260, i64* %261
; # (cdr Z)
  %263 = inttoptr i64 %258 to i64*
  %264 = getelementptr i64, i64* %263, i32 1
  %265 = load i64, i64* %264
; # (val Z)
  %266 = inttoptr i64 %265 to i64*
  %267 = load i64, i64* %266
; # (set Z (cdr Z) 2 Z (cdr Y) 2 Y (val Y) Y X)
; # (cdr Z)
  %268 = inttoptr i64 %265 to i64*
  %269 = getelementptr i64, i64* %268, i32 1
  %270 = load i64, i64* %269
  %271 = inttoptr i64 %265 to i64*
  store i64 %270, i64* %271
; # (cdr Y)
  %272 = inttoptr i64 %201 to i64*
  %273 = getelementptr i64, i64* %272, i32 1
  %274 = load i64, i64* %273
  %275 = inttoptr i64 %265 to i64*
  %276 = getelementptr i64, i64* %275, i32 1
  store i64 %274, i64* %276
; # (val Y)
  %277 = inttoptr i64 %201 to i64*
  %278 = load i64, i64* %277
  %279 = inttoptr i64 %201 to i64*
  %280 = getelementptr i64, i64* %279, i32 1
  store i64 %278, i64* %280
  %281 = inttoptr i64 %201 to i64*
  store i64 %267, i64* %281
  br label %$41
$41:
  %282 = phi i64 [%231, %$42], [%267, %$43] ; # X
  %283 = phi i64 [%219, %$42], [%256, %$43] ; # C
  %284 = phi i64 [%220, %$42], [%257, %$43] ; # Sym
  %285 = phi i64 [%231, %$42], [%267, %$43] ; # ->
  br label %$33
$38:
  %286 = phi i64 [%181, %$36], [%207, %$39], [%245, %$40] ; # X
  %287 = phi i64 [%182, %$36], [%208, %$39], [%246, %$40] ; # C
  %288 = phi i64 [%183, %$36], [%209, %$39], [%247, %$40] ; # Sym
  %289 = phi i64 [0, %$36], [0, %$39], [0, %$40] ; # ->
  br label %$20
$20:
  %290 = phi i64 [%102, %$7], [%286, %$38] ; # X
  %291 = phi i64 [%106, %$7], [%287, %$38] ; # C
  %292 = phi i64 [%104, %$7], [%288, %$38] ; # Sym
  ret i64 %292
}

define void @delNode(i64, i64) {
$1:
; # (let Y (cdr X) (cond ((atom (car Y)) (set P (cdr Y))) ((atom (cdr...
; # (cdr X)
  %2 = inttoptr i64 %0 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (cond ((atom (car Y)) (set P (cdr Y))) ((atom (cdr Y)) (set P (ca...
; # (car Y)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (atom (car Y))
  %7 = and i64 %6, 15
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$4, label %$3
$4:
  %9 = phi i64 [%1, %$1] ; # P
  %10 = phi i64 [%4, %$1] ; # Y
; # (set P (cdr Y))
; # (cdr Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  %14 = inttoptr i64 %9 to i64*
  store i64 %13, i64* %14
  br label %$2
$3:
  %15 = phi i64 [%1, %$1] ; # P
  %16 = phi i64 [%4, %$1] ; # Y
; # (cdr Y)
  %17 = inttoptr i64 %16 to i64*
  %18 = getelementptr i64, i64* %17, i32 1
  %19 = load i64, i64* %18
; # (atom (cdr Y))
  %20 = and i64 %19, 15
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$6, label %$5
$6:
  %22 = phi i64 [%15, %$3] ; # P
  %23 = phi i64 [%16, %$3] ; # Y
; # (set P (car Y))
; # (car Y)
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  store i64 %25, i64* %26
  br label %$2
$5:
  %27 = phi i64 [%15, %$3] ; # P
  %28 = phi i64 [%16, %$3] ; # Y
; # (shift Y)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (cdr (shift Y))
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (car (setq P (cdr (shift Y))))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (atom (car (setq P (cdr (shift Y)))))
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$8, label %$7
$8:
  %39 = phi i64 [%34, %$5] ; # P
  %40 = phi i64 [%31, %$5] ; # Y
; # (set X (car Y) 2 (cdr X) (cdr P))
; # (car Y)
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = inttoptr i64 %0 to i64*
  store i64 %42, i64* %43
; # (cdr X)
  %44 = inttoptr i64 %0 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (cdr P)
  %47 = inttoptr i64 %39 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 %46 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  store i64 %49, i64* %51
  br label %$2
$7:
  %52 = phi i64 [%34, %$5] ; # P
  %53 = phi i64 [%31, %$5] ; # Y
; # (car P)
  %54 = inttoptr i64 %52 to i64*
  %55 = load i64, i64* %54
; # (loop (let Z (cdr P) (? (atom (car Z)) (set X (car P) (cdr Y) (cd...
  br label %$9
$9:
  %56 = phi i64 [%55, %$7], [%80, %$10] ; # P
  %57 = phi i64 [%53, %$7], [%77, %$10] ; # Y
; # (let Z (cdr P) (? (atom (car Z)) (set X (car P) (cdr Y) (cdr Z)))...
; # (cdr P)
  %58 = inttoptr i64 %56 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
; # (? (atom (car Z)) (set X (car P) (cdr Y) (cdr Z)))
; # (car Z)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (atom (car Z))
  %63 = and i64 %62, 15
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$12, label %$10
$12:
  %65 = phi i64 [%56, %$9] ; # P
  %66 = phi i64 [%57, %$9] ; # Y
; # (set X (car P) (cdr Y) (cdr Z))
; # (car P)
  %67 = inttoptr i64 %65 to i64*
  %68 = load i64, i64* %67
  %69 = inttoptr i64 %0 to i64*
  store i64 %68, i64* %69
; # (cdr Y)
  %70 = inttoptr i64 %66 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
; # (cdr Z)
  %73 = inttoptr i64 %60 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
  %76 = inttoptr i64 %72 to i64*
  store i64 %75, i64* %76
  br label %$11
$10:
  %77 = phi i64 [%56, %$9] ; # P
  %78 = phi i64 [%57, %$9] ; # Y
; # (car Z)
  %79 = inttoptr i64 %60 to i64*
  %80 = load i64, i64* %79
  br label %$9
$11:
  %81 = phi i64 [%65, %$12] ; # P
  %82 = phi i64 [%66, %$12] ; # Y
  %83 = phi i64 [%75, %$12] ; # ->
  br label %$2
$2:
  %84 = phi i64 [%9, %$4], [%22, %$6], [%39, %$8], [%81, %$11] ; # P
  %85 = phi i64 [%10, %$4], [%23, %$6], [%40, %$8], [%82, %$11] ; # Y
  %86 = phi i64 [%13, %$4], [%25, %$6], [%49, %$8], [%83, %$11] ; # ->
  ret void
}

define void @unintern(i64, i64, i64) {
$1:
; # (if (cnt? Name) (loop (let X (car P) (? (atom X)) (let (S (car X)...
; # (cnt? Name)
  %3 = and i64 %1, 2
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%2, %$1] ; # P
; # (loop (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (...
  br label %$5
$5:
  %6 = phi i64 [%5, %$2], [%51, %$18] ; # P
; # (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (tail S...
; # (car P)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (? (atom X))
; # (atom X)
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$6:
  %11 = phi i64 [%6, %$5] ; # P
  %12 = phi i64 [%8, %$5] ; # X
; # (let (S (car X) Nm (name (val (tail S)))) (? (== Name Nm) (when (...
; # (car X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (tail S)
  %15 = add i64 %14, -8
; # (val (tail S))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (name (val (tail S)))
  br label %$8
$8:
  %18 = phi i64 [%17, %$6], [%24, %$9] ; # Tail
  %19 = and i64 %18, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$9
$9:
  %21 = phi i64 [%18, %$8] ; # Tail
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  br label %$8
$10:
  %25 = phi i64 [%18, %$8] ; # Tail
; # (? (== Name Nm) (when (== S Sym) (delNode X P)))
; # (== Name Nm)
  %26 = icmp eq i64 %1, %25
  br i1 %26, label %$12, label %$11
$12:
  %27 = phi i64 [%11, %$10] ; # P
  %28 = phi i64 [%12, %$10] ; # X
; # (when (== S Sym) (delNode X P))
; # (== S Sym)
  %29 = icmp eq i64 %14, %0
  br i1 %29, label %$13, label %$14
$13:
  %30 = phi i64 [%27, %$12] ; # P
  %31 = phi i64 [%28, %$12] ; # X
; # (delNode X P)
  call void @delNode(i64 %31, i64 %30)
  br label %$14
$14:
  %32 = phi i64 [%27, %$12], [%30, %$13] ; # P
  %33 = phi i64 [%28, %$12], [%31, %$13] ; # X
  br label %$7
$11:
  %34 = phi i64 [%11, %$10] ; # P
  %35 = phi i64 [%12, %$10] ; # X
; # (? (atom (shift X)))
; # (shift X)
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
; # (atom (shift X))
  %39 = and i64 %38, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$7, label %$15
$15:
  %41 = phi i64 [%34, %$11] ; # P
  %42 = phi i64 [%38, %$11] ; # X
; # (if (> Name Nm) (ofs X 1) X)
; # (> Name Nm)
  %43 = icmp ugt i64 %1, %25
  br i1 %43, label %$16, label %$17
$16:
  %44 = phi i64 [%41, %$15] ; # P
  %45 = phi i64 [%42, %$15] ; # X
; # (ofs X 1)
  %46 = add i64 %45, 8
  br label %$18
$17:
  %47 = phi i64 [%41, %$15] ; # P
  %48 = phi i64 [%42, %$15] ; # X
  br label %$18
$18:
  %49 = phi i64 [%44, %$16], [%47, %$17] ; # P
  %50 = phi i64 [%45, %$16], [%48, %$17] ; # X
  %51 = phi i64 [%46, %$16], [%48, %$17] ; # ->
  br label %$5
$7:
  %52 = phi i64 [%6, %$5], [%32, %$14], [%34, %$11] ; # P
  br label %$4
$3:
  %53 = phi i64 [%2, %$1] ; # P
; # (ofs P 1)
  %54 = add i64 %53, 8
; # (loop (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (...
  br label %$19
$19:
  %55 = phi i64 [%54, %$3], [%101, %$32] ; # P
; # (let X (car P) (? (atom X)) (let (S (car X) Nm (name (val (tail S...
; # (car P)
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
; # (? (atom X))
; # (atom X)
  %58 = and i64 %57, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$21, label %$20
$20:
  %60 = phi i64 [%55, %$19] ; # P
  %61 = phi i64 [%57, %$19] ; # X
; # (let (S (car X) Nm (name (val (tail S))) I (cmpLong Nm Name)) (? ...
; # (car X)
  %62 = inttoptr i64 %61 to i64*
  %63 = load i64, i64* %62
; # (tail S)
  %64 = add i64 %63, -8
; # (val (tail S))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (name (val (tail S)))
  br label %$22
$22:
  %67 = phi i64 [%66, %$20], [%73, %$23] ; # Tail
  %68 = and i64 %67, 6
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$24, label %$23
$23:
  %70 = phi i64 [%67, %$22] ; # Tail
  %71 = inttoptr i64 %70 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
  br label %$22
$24:
  %74 = phi i64 [%67, %$22] ; # Tail
; # (cmpLong Nm Name)
  %75 = call i64 @cmpLong(i64 %74, i64 %1)
; # (? (=0 I) (when (== S Sym) (delNode X P)))
; # (=0 I)
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %$26, label %$25
$26:
  %77 = phi i64 [%60, %$24] ; # P
  %78 = phi i64 [%61, %$24] ; # X
; # (when (== S Sym) (delNode X P))
; # (== S Sym)
  %79 = icmp eq i64 %63, %0
  br i1 %79, label %$27, label %$28
$27:
  %80 = phi i64 [%77, %$26] ; # P
  %81 = phi i64 [%78, %$26] ; # X
; # (delNode X P)
  call void @delNode(i64 %81, i64 %80)
  br label %$28
$28:
  %82 = phi i64 [%77, %$26], [%80, %$27] ; # P
  %83 = phi i64 [%78, %$26], [%81, %$27] ; # X
  br label %$21
$25:
  %84 = phi i64 [%60, %$24] ; # P
  %85 = phi i64 [%61, %$24] ; # X
; # (? (atom (shift X)))
; # (shift X)
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
; # (atom (shift X))
  %89 = and i64 %88, 15
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$21, label %$29
$29:
  %91 = phi i64 [%84, %$25] ; # P
  %92 = phi i64 [%88, %$25] ; # X
; # (if (lt0 I) (ofs X 1) X)
; # (lt0 I)
  %93 = icmp slt i64 %75, 0
  br i1 %93, label %$30, label %$31
$30:
  %94 = phi i64 [%91, %$29] ; # P
  %95 = phi i64 [%92, %$29] ; # X
; # (ofs X 1)
  %96 = add i64 %95, 8
  br label %$32
$31:
  %97 = phi i64 [%91, %$29] ; # P
  %98 = phi i64 [%92, %$29] ; # X
  br label %$32
$32:
  %99 = phi i64 [%94, %$30], [%97, %$31] ; # P
  %100 = phi i64 [%95, %$30], [%98, %$31] ; # X
  %101 = phi i64 [%96, %$30], [%98, %$31] ; # ->
  br label %$19
$21:
  %102 = phi i64 [%55, %$19], [%82, %$28], [%84, %$25] ; # P
  br label %$4
$4:
  %103 = phi i64 [%52, %$7], [%102, %$21] ; # P
  ret void
}

define i64 @_name(i64) {
$1:
; # (let Tail (val (tail (needSymb Exe (eval (cadr Exe))))) (if (sym?...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (tail (needSymb Exe (eval (cadr Exe))))
  %17 = add i64 %13, -8
; # (val (tail (needSymb Exe (eval (cadr Exe)))))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (if (sym? Tail) (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (...
; # (sym? Tail)
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$10
$9:
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (packExtNm (& (na...
; # (push 4 NIL ZERO NIL)
  %22 = alloca i64, i64 4, align 16
  store i64 4, i64* %22
  %23 = getelementptr i64, i64* %22, i32 2
  store i64 2, i64* %23
; # (ofs P 2)
  %24 = getelementptr i64, i64* %22, i32 2
; # (link (ofs P 2) T)
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %25 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %27, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %30
; # (name Tail)
  br label %$12
$12:
  %31 = phi i64 [%19, %$9], [%37, %$13] ; # Tail
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$14, label %$13
$13:
  %34 = phi i64 [%31, %$12] ; # Tail
  %35 = inttoptr i64 %34 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
  br label %$12
$14:
  %38 = phi i64 [%31, %$12] ; # Tail
; # (& (name Tail) -9)
  %39 = and i64 %38, -9
; # (packExtNm (& (name Tail) -9) P)
  call void @packExtNm(i64 %39, i64* %22)
; # (val 3 P)
  %40 = getelementptr i64, i64* %22, i32 2
  %41 = load i64, i64* %40
; # (consStr (val 3 P))
  %42 = call i64 @consStr(i64 %41)
; # (drop *Safe)
  %43 = inttoptr i64 %25 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %46
  br label %$11
$10:
; # (name Tail)
  br label %$15
$15:
  %47 = phi i64 [%19, %$10], [%53, %$16] ; # Tail
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$17, label %$16
$16:
  %50 = phi i64 [%47, %$15] ; # Tail
  %51 = inttoptr i64 %50 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  br label %$15
$17:
  %54 = phi i64 [%47, %$15] ; # Tail
; # (consStr (name Tail))
  %55 = call i64 @consStr(i64 %54)
  br label %$11
$11:
  %56 = phi i64 [%42, %$14], [%55, %$17] ; # ->
  ret i64 %56
}

define i64 @_nsp(i64) {
$1:
; # (let Sym (needSymb Exe (eval (cadr Exe))) (if (sym? (val (tail Sy...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (if (sym? (val (tail Sym))) $Nil (let (Nm (name @) Lst (val $Inte...
; # (tail Sym)
  %17 = add i64 %13, -8
; # (val (tail Sym))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail Sym)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (Nm (name @) Lst (val $Intern)) (loop (? (atom Lst) $Nil) (l...
; # (name @)
  br label %$12
$12:
  %22 = phi i64 [%19, %$10], [%28, %$13] ; # Tail
  %23 = and i64 %22, 6
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$14, label %$13
$13:
  %25 = phi i64 [%22, %$12] ; # Tail
  %26 = inttoptr i64 %25 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  br label %$12
$14:
  %29 = phi i64 [%22, %$12] ; # Tail
; # (val $Intern)
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %31 = load i64, i64* %30
; # (loop (? (atom Lst) $Nil) (let Nsp (car Lst) (? (== Sym (isIntern...
  br label %$15
$15:
  %32 = phi i64 [%31, %$14], [%50, %$19] ; # Lst
; # (? (atom Lst) $Nil)
; # (atom Lst)
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$18, label %$16
$18:
  %35 = phi i64 [%32, %$15] ; # Lst
  br label %$17
$16:
  %36 = phi i64 [%32, %$15] ; # Lst
; # (let Nsp (car Lst) (? (== Sym (isIntern Nm (cdar Nsp))) Nsp))
; # (car Lst)
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (? (== Sym (isIntern Nm (cdar Nsp))) Nsp)
; # (cdar Nsp)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %40 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (isIntern Nm (cdar Nsp))
  %44 = call i64 @isIntern(i64 %29, i64 %43)
; # (== Sym (isIntern Nm (cdar Nsp)))
  %45 = icmp eq i64 %13, %44
  br i1 %45, label %$20, label %$19
$20:
  %46 = phi i64 [%36, %$16] ; # Lst
  br label %$17
$19:
  %47 = phi i64 [%36, %$16] ; # Lst
; # (shift Lst)
  %48 = inttoptr i64 %47 to i64*
  %49 = getelementptr i64, i64* %48, i32 1
  %50 = load i64, i64* %49
  br label %$15
$17:
  %51 = phi i64 [%35, %$18], [%46, %$20] ; # Lst
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$18], [%38, %$20] ; # ->
  br label %$11
$11:
  %53 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%52, %$17] ; # ->
  ret i64 %53
}

define i64 @_spQ(i64) {
$1:
; # (if (isBlank (eval (cadr Exe))) $T $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (isBlank (eval (cadr Exe)))
  %14 = call i1 @isBlank(i64 %13)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_patQ(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (== (firstChar X) (ch...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (== (firstChar X) (char "@"))) X $Nil)
; # (and (symb? X) (== (firstChar X) (char "@")))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (firstChar X)
  %17 = call i32 @firstChar(i64 %13)
; # (== (firstChar X) (char "@"))
  %18 = icmp eq i32 %17, 64
  br label %$7
$7:
  %19 = phi i1 [0, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_funQ(i64) {
$1:
; # (if (funq (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (funq (eval (cadr Exe)))
  %14 = call i64 @funq(i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_getd(i64) {
$1:
; # (let (X (eval (cadr Exe)) V T) (cond ((not (symb? X)) $Nil) ((fun...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((not (symb? X)) $Nil) ((funq (setq V (val X))) V) ((and (n...
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  br label %$7
$8:
; # (val X)
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
; # (funq (setq V (val X)))
  %20 = call i64 @funq(i64 %19)
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$10
$11:
  %22 = phi i64 [%19, %$8] ; # V
  br label %$7
$10:
  %23 = phi i64 [%19, %$8] ; # V
; # (and (nil? V) (sharedLib X))
; # (nil? V)
  %24 = icmp eq i64 %23, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %24, label %$13, label %$12
$13:
  %25 = phi i64 [%23, %$10] ; # V
; # (sharedLib X)
  %26 = call i1 @sharedLib(i64 %13)
  br label %$12
$12:
  %27 = phi i64 [%23, %$10], [%25, %$13] ; # V
  %28 = phi i1 [0, %$10], [%26, %$13] ; # ->
  br i1 %28, label %$15, label %$14
$15:
  %29 = phi i64 [%27, %$12] ; # V
; # (val X)
  %30 = inttoptr i64 %13 to i64*
  %31 = load i64, i64* %30
  br label %$7
$14:
  %32 = phi i64 [%27, %$12] ; # V
  br label %$7
$7:
  %33 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%22, %$11], [%31, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$14] ; # ->
  ret i64 %33
}

define i64 @consTree(i64, i64) {
$1:
; # (if (atom P) P (let (Q (link (push P NIL)) Tos (link (push -ZERO ...
; # (atom P)
  %2 = and i64 %0, 15
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # P
  %5 = phi i64 [%1, %$1] ; # Lst
  br label %$4
$3:
  %6 = phi i64 [%0, %$1] ; # P
  %7 = phi i64 [%1, %$1] ; # Lst
; # (let (Q (link (push P NIL)) Tos (link (push -ZERO NIL))) (loop (l...
; # (push P NIL)
  %8 = alloca i64, i64 2, align 16
  %9 = ptrtoint i64* %8 to i64
  %10 = inttoptr i64 %9 to i64*
  store i64 %6, i64* %10
; # (link (push P NIL))
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %12 = load i64, i64* %11
  %13 = inttoptr i64 %9 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  store i64 %12, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %9, i64* %15
; # (push -ZERO NIL)
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 10, i64* %18
; # (link (push -ZERO NIL))
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @)...
  br label %$5
$5:
  %24 = phi i64 [%6, %$3], [%114, %$11] ; # P
  %25 = phi i64 [%7, %$3], [%115, %$11] ; # Lst
; # (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set ...
  br label %$6
$6:
  %26 = phi i64 [%24, %$5], [%33, %$7] ; # P
  %27 = phi i64 [%25, %$5], [%37, %$7] ; # Lst
; # (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set 2 X (v...
; # (cdr P)
  %28 = inttoptr i64 %26 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (? (atom (cdr X)))
; # (cdr X)
  %31 = inttoptr i64 %30 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
; # (atom (cdr X))
  %34 = and i64 %33, 15
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$8, label %$7
$7:
  %36 = phi i64 [%26, %$6] ; # P
  %37 = phi i64 [%27, %$6] ; # Lst
; # (let Y P (setq P @) (set 2 X (val Tos)) (set Tos Y))
; # (set 2 X (val Tos))
; # (val Tos)
  %38 = inttoptr i64 %17 to i64*
  %39 = load i64, i64* %38
  %40 = inttoptr i64 %30 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  store i64 %39, i64* %41
; # (set Tos Y)
  %42 = inttoptr i64 %17 to i64*
  store i64 %36, i64* %42
  br label %$6
$8:
  %43 = phi i64 [%26, %$6] ; # P
  %44 = phi i64 [%27, %$6] ; # Lst
  %45 = phi i64 [0, %$6] ; # ->
; # (set Q P)
  %46 = inttoptr i64 %9 to i64*
  store i64 %43, i64* %46
; # (loop (setq Lst (cons (car P) Lst)) (let X (cdr P) (? (pair (car ...
  br label %$9
$9:
  %47 = phi i64 [%43, %$8], [%111, %$17] ; # P
  %48 = phi i64 [%44, %$8], [%112, %$17] ; # Lst
; # (car P)
  %49 = inttoptr i64 %47 to i64*
  %50 = load i64, i64* %49
; # (cons (car P) Lst)
  %51 = call i64 @cons(i64 %50, i64 %48)
; # (let X (cdr P) (? (pair (car X)) (let Y P (setq P @) (set X (val ...
; # (cdr P)
  %52 = inttoptr i64 %47 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (? (pair (car X)) (let Y P (setq P @) (set X (val Tos)) (set Tos ...
; # (car X)
  %55 = inttoptr i64 %54 to i64*
  %56 = load i64, i64* %55
; # (pair (car X))
  %57 = and i64 %56, 15
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %$12, label %$10
$12:
  %59 = phi i64 [%47, %$9] ; # P
  %60 = phi i64 [%51, %$9] ; # Lst
; # (let Y P (setq P @) (set X (val Tos)) (set Tos (| Y 8)) (set Q P)...
; # (set X (val Tos))
; # (val Tos)
  %61 = inttoptr i64 %17 to i64*
  %62 = load i64, i64* %61
  %63 = inttoptr i64 %54 to i64*
  store i64 %62, i64* %63
; # (set Tos (| Y 8))
; # (| Y 8)
  %64 = or i64 %59, 8
  %65 = inttoptr i64 %17 to i64*
  store i64 %64, i64* %65
; # (set Q P)
  %66 = inttoptr i64 %9 to i64*
  store i64 %56, i64* %66
  br label %$11
$10:
  %67 = phi i64 [%47, %$9] ; # P
  %68 = phi i64 [%51, %$9] ; # Lst
; # (loop (let X (val Tos) (when (== -ZERO X) (drop Q) (ret Lst)) (? ...
  br label %$13
$13:
  %69 = phi i64 [%67, %$10], [%102, %$16] ; # P
  %70 = phi i64 [%68, %$10], [%100, %$16] ; # Lst
; # (let X (val Tos) (when (== -ZERO X) (drop Q) (ret Lst)) (? (=0 (&...
; # (val Tos)
  %71 = inttoptr i64 %17 to i64*
  %72 = load i64, i64* %71
; # (when (== -ZERO X) (drop Q) (ret Lst))
; # (== -ZERO X)
  %73 = icmp eq i64 10, %72
  br i1 %73, label %$14, label %$15
$14:
  %74 = phi i64 [%69, %$13] ; # P
  %75 = phi i64 [%70, %$13] ; # Lst
  %76 = phi i64 [%72, %$13] ; # X
; # (drop Q)
  %77 = inttoptr i64 %9 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  %79 = load i64, i64* %78
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %79, i64* %80
; # (ret Lst)
  ret i64 %75
$15:
  %81 = phi i64 [%69, %$13] ; # P
  %82 = phi i64 [%70, %$13] ; # Lst
  %83 = phi i64 [%72, %$13] ; # X
; # (? (=0 (& X 8)) (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (set...
; # (& X 8)
  %84 = and i64 %83, 8
; # (=0 (& X 8))
  %85 = icmp eq i64 %84, 0
  br i1 %85, label %$18, label %$16
$18:
  %86 = phi i64 [%81, %$15] ; # P
  %87 = phi i64 [%82, %$15] ; # Lst
  %88 = phi i64 [%83, %$15] ; # X
; # (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (setq P X) (set Q P)...
; # (cdr X)
  %89 = inttoptr i64 %88 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  %91 = load i64, i64* %90
; # (set Tos (cdr Y))
; # (cdr Y)
  %92 = inttoptr i64 %91 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
  %95 = inttoptr i64 %17 to i64*
  store i64 %94, i64* %95
; # (set 2 Y P)
  %96 = inttoptr i64 %91 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  store i64 %86, i64* %97
; # (set Q P)
  %98 = inttoptr i64 %9 to i64*
  store i64 %88, i64* %98
  br label %$17
$16:
  %99 = phi i64 [%81, %$15] ; # P
  %100 = phi i64 [%82, %$15] ; # Lst
  %101 = phi i64 [%83, %$15] ; # X
; # (& X -9)
  %102 = and i64 %101, -9
; # (let Y (cdr X) (set Tos (car Y)) (set Y P) (setq P X) (set Q P))
; # (cdr X)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
; # (set Tos (car Y))
; # (car Y)
  %106 = inttoptr i64 %105 to i64*
  %107 = load i64, i64* %106
  %108 = inttoptr i64 %17 to i64*
  store i64 %107, i64* %108
; # (set Y P)
  %109 = inttoptr i64 %105 to i64*
  store i64 %99, i64* %109
; # (set Q P)
  %110 = inttoptr i64 %9 to i64*
  store i64 %102, i64* %110
  br label %$13
$17:
  %111 = phi i64 [%88, %$18] ; # P
  %112 = phi i64 [%87, %$18] ; # Lst
  %113 = phi i64 [%88, %$18] ; # ->
  br label %$9
$11:
  %114 = phi i64 [%56, %$12] ; # P
  %115 = phi i64 [%60, %$12] ; # Lst
  %116 = phi i64 [%56, %$12] ; # ->
  br label %$5
$4:
  %117 = phi i64 [%4, %$2] ; # P
  %118 = phi i64 [%5, %$2] ; # Lst
  %119 = phi i64 [%4, %$2] ; # ->
  ret i64 %119
}

define i64 @_all(i64) {
$1:
; # (let X (eval (cadr Exe)) (cond ((nil? X) (let Y (val $Intern) (lo...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((nil? X) (let Y (val $Intern) (loop (let Z (cdar (++ Y)) (...
; # (nil? X)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%13, %$2] ; # X
; # (let Y (val $Intern) (loop (let Z (cdar (++ Y)) (setq X (consTree...
; # (val $Intern)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %17 = load i64, i64* %16
; # (loop (let Z (cdar (++ Y)) (setq X (consTree (car Z) (consTree (c...
  br label %$10
$10:
  %18 = phi i64 [%15, %$9], [%40, %$11] ; # X
  %19 = phi i64 [%17, %$9], [%41, %$11] ; # Y
; # (let Z (cdar (++ Y)) (setq X (consTree (car Z) (consTree (cdr Z) ...
; # (++ Y)
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
  %22 = getelementptr i64, i64* %20, i32 1
  %23 = load i64, i64* %22
; # (cdar (++ Y))
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %25 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (car Z)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (cdr Z)
  %31 = inttoptr i64 %28 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
; # (consTree (cdr Z) X)
  %34 = call i64 @consTree(i64 %33, i64 %18)
; # (consTree (car Z) (consTree (cdr Z) X))
  %35 = call i64 @consTree(i64 %30, i64 %34)
; # (? (atom Y) X)
; # (atom Y)
  %36 = and i64 %23, 15
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$13, label %$11
$13:
  %38 = phi i64 [%35, %$10] ; # X
  %39 = phi i64 [%23, %$10] ; # Y
  br label %$12
$11:
  %40 = phi i64 [%35, %$10] ; # X
  %41 = phi i64 [%23, %$10] ; # Y
  br label %$10
$12:
  %42 = phi i64 [%38, %$13] ; # X
  %43 = phi i64 [%39, %$13] ; # Y
  %44 = phi i64 [%38, %$13] ; # ->
  br label %$7
$8:
  %45 = phi i64 [%13, %$2] ; # X
; # (== $T X)
  %46 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %45
  br i1 %46, label %$15, label %$14
$15:
  %47 = phi i64 [%45, %$8] ; # X
; # (val $Transient)
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %49 = load i64, i64* %48
; # (val 2 $Transient)
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
; # (consTree (val 2 $Transient) $Nil)
  %53 = call i64 @consTree(i64 %52, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (consTree (val $Transient) (consTree (val 2 $Transient) $Nil))
  %54 = call i64 @consTree(i64 %49, i64 %53)
  br label %$7
$14:
  %55 = phi i64 [%45, %$8] ; # X
; # (num? X)
  %56 = and i64 %55, 6
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$17, label %$16
$17:
  %58 = phi i64 [%55, %$14] ; # X
; # (val $Extern)
  %59 = load i64, i64* @$Extern
; # (consTree (val $Extern) $Nil)
  %60 = call i64 @consTree(i64 %59, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$7
$16:
  %61 = phi i64 [%55, %$14] ; # X
; # (sym? X)
  %62 = and i64 %61, 8
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$19, label %$18
$19:
  %64 = phi i64 [%61, %$16] ; # X
; # (let Y (cdar X) (if (pair Y) (consTree (car Y) (consTree (cdr Y) ...
; # (cdar X)
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = inttoptr i64 %66 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
; # (if (pair Y) (consTree (car Y) (consTree (cdr Y) $Nil)) $Nil)
; # (pair Y)
  %70 = and i64 %69, 15
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %$20, label %$21
$20:
  %72 = phi i64 [%64, %$19] ; # X
; # (car Y)
  %73 = inttoptr i64 %69 to i64*
  %74 = load i64, i64* %73
; # (cdr Y)
  %75 = inttoptr i64 %69 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
; # (consTree (cdr Y) $Nil)
  %78 = call i64 @consTree(i64 %77, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (consTree (car Y) (consTree (cdr Y) $Nil))
  %79 = call i64 @consTree(i64 %74, i64 %78)
  br label %$22
$21:
  %80 = phi i64 [%64, %$19] ; # X
  br label %$22
$22:
  %81 = phi i64 [%72, %$20], [%80, %$21] ; # X
  %82 = phi i64 [%79, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
  br label %$7
$18:
  %83 = phi i64 [%61, %$16] ; # X
; # (car X)
  %84 = inttoptr i64 %83 to i64*
  %85 = load i64, i64* %84
; # (nil? (car X))
  %86 = icmp eq i64 %85, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %86, label %$24, label %$23
$24:
  %87 = phi i64 [%83, %$18] ; # X
; # (let Y (val (car (val $Intern))) (if (nil? (cdr X)) (val Y) (val ...
; # (val $Intern)
  %88 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %89 = load i64, i64* %88
; # (car (val $Intern))
  %90 = inttoptr i64 %89 to i64*
  %91 = load i64, i64* %90
; # (val (car (val $Intern)))
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
; # (if (nil? (cdr X)) (val Y) (val 2 Y))
; # (cdr X)
  %94 = inttoptr i64 %87 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
; # (nil? (cdr X))
  %97 = icmp eq i64 %96, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %97, label %$25, label %$26
$25:
  %98 = phi i64 [%87, %$24] ; # X
; # (val Y)
  %99 = inttoptr i64 %93 to i64*
  %100 = load i64, i64* %99
  br label %$27
$26:
  %101 = phi i64 [%87, %$24] ; # X
; # (val 2 Y)
  %102 = inttoptr i64 %93 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  br label %$27
$27:
  %105 = phi i64 [%98, %$25], [%101, %$26] ; # X
  %106 = phi i64 [%100, %$25], [%104, %$26] ; # ->
  br label %$7
$23:
  %107 = phi i64 [%83, %$18] ; # X
; # (car X)
  %108 = inttoptr i64 %107 to i64*
  %109 = load i64, i64* %108
; # (== $T (car X))
  %110 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %109
  br i1 %110, label %$29, label %$28
$29:
  %111 = phi i64 [%107, %$23] ; # X
; # (if (nil? (cdr X)) (val $Transient) (val 2 $Transient))
; # (cdr X)
  %112 = inttoptr i64 %111 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  %114 = load i64, i64* %113
; # (nil? (cdr X))
  %115 = icmp eq i64 %114, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %115, label %$30, label %$31
$30:
  %116 = phi i64 [%111, %$29] ; # X
; # (val $Transient)
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %118 = load i64, i64* %117
  br label %$32
$31:
  %119 = phi i64 [%111, %$29] ; # X
; # (val 2 $Transient)
  %120 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  %122 = load i64, i64* %121
  br label %$32
$32:
  %123 = phi i64 [%116, %$30], [%119, %$31] ; # X
  %124 = phi i64 [%118, %$30], [%122, %$31] ; # ->
  br label %$7
$28:
  %125 = phi i64 [%107, %$23] ; # X
; # (val $Extern)
  %126 = load i64, i64* @$Extern
  br label %$7
$7:
  %127 = phi i64 [%42, %$12], [%47, %$15], [%58, %$17], [%81, %$22], [%105, %$27], [%123, %$32], [%125, %$28] ; # X
  %128 = phi i64 [%44, %$12], [%54, %$15], [%60, %$17], [%82, %$22], [%106, %$27], [%124, %$32], [%126, %$28] ; # ->
  ret i64 %128
}

define i64 @_symbols(i64) {
$1:
; # (let X (cdr Exe) (if (atom X) (val $Intern) (let Y (eval (++ X)) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom X) (val $Intern) (let Y (eval (++ X)) (if (pair Y) (let...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
; # (val $Intern)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %8 = load i64, i64* %7
  br label %$4
$3:
  %9 = phi i64 [%3, %$1] ; # X
; # (let Y (eval (++ X)) (if (pair Y) (let L Y (loop (needNsp Exe (ne...
; # (++ X)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (eval (++ X))
  %14 = and i64 %11, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  br label %$5
$6:
  %16 = and i64 %11, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = inttoptr i64 %11 to i64*
  %19 = load i64, i64* %18
  br label %$5
$8:
  %20 = call i64 @evList(i64 %11)
  br label %$5
$5:
  %21 = phi i64 [%11, %$7], [%19, %$9], [%20, %$8] ; # ->
; # (if (pair Y) (let L Y (loop (needNsp Exe (needSymb Exe (++ L))) (...
; # (pair Y)
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$10, label %$11
$10:
  %24 = phi i64 [%13, %$5] ; # X
  %25 = phi i64 [%21, %$5] ; # Y
; # (let L Y (loop (needNsp Exe (needSymb Exe (++ L))) (? (atom L))) ...
; # (loop (needNsp Exe (needSymb Exe (++ L))) (? (atom L)))
  br label %$13
$13:
  %26 = phi i64 [%24, %$10], [%46, %$20] ; # X
  %27 = phi i64 [%25, %$10], [%47, %$20] ; # Y
  %28 = phi i64 [%25, %$10], [%48, %$20] ; # L
; # (++ L)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  %31 = getelementptr i64, i64* %29, i32 1
  %32 = load i64, i64* %31
; # (needSymb Exe (++ L))
  %33 = xor i64 %30, 8
  %34 = and i64 %33, 14
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$15, label %$14
$14:
  call void @symErr(i64 %0, i64 %30)
  unreachable
$15:
; # (needNsp Exe (needSymb Exe (++ L)))
  %36 = inttoptr i64 %30 to i64*
  %37 = load i64, i64* %36
  %38 = and i64 %37, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$17, label %$16
$17:
  %40 = inttoptr i64 %37 to i64*
  %41 = load i64, i64* %40
  %42 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 56) to i64), %41
  br label %$16
$16:
  %43 = phi i1 [0, %$15], [%42, %$17] ; # ->
  br i1 %43, label %$19, label %$18
$18:
  call void @symNspErr(i64 0, i64 %30)
  unreachable
$19:
; # (? (atom L))
; # (atom L)
  %44 = and i64 %32, 15
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$21, label %$20
$20:
  %46 = phi i64 [%26, %$19] ; # X
  %47 = phi i64 [%27, %$19] ; # Y
  %48 = phi i64 [%32, %$19] ; # L
  br label %$13
$21:
  %49 = phi i64 [%26, %$19] ; # X
  %50 = phi i64 [%27, %$19] ; # Y
  %51 = phi i64 [%32, %$19] ; # L
  %52 = phi i64 [0, %$19] ; # ->
; # (if (atom X) (prog1 (val $Intern) (set $Intern Y)) (let Z (save (...
; # (atom X)
  %53 = and i64 %49, 15
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$22, label %$23
$22:
  %55 = phi i64 [%49, %$21] ; # X
  %56 = phi i64 [%50, %$21] ; # Y
  %57 = phi i64 [%51, %$21] ; # L
; # (prog1 (val $Intern) (set $Intern Y))
; # (val $Intern)
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %59 = load i64, i64* %58
; # (set $Intern Y)
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %56, i64* %60
  br label %$24
$23:
  %61 = phi i64 [%49, %$21] ; # X
  %62 = phi i64 [%50, %$21] ; # Y
  %63 = phi i64 [%51, %$21] ; # L
; # (let Z (save (val $Intern)) (set $Intern Y) (prog1 (run X) (set $...
; # (val $Intern)
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %65 = load i64, i64* %64
; # (save (val $Intern))
  %66 = alloca i64, i64 2, align 16
  %67 = ptrtoint i64* %66 to i64
  %68 = inttoptr i64 %67 to i64*
  store i64 %65, i64* %68
  %69 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %70 = load i64, i64* %69
  %71 = inttoptr i64 %67 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  store i64 %70, i64* %72
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %73
; # (set $Intern Y)
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %62, i64* %74
; # (prog1 (run X) (set $Intern Z))
; # (run X)
  br label %$25
$25:
  %75 = phi i64 [%61, %$23], [%97, %$34] ; # Prg
  %76 = inttoptr i64 %75 to i64*
  %77 = load i64, i64* %76
  %78 = getelementptr i64, i64* %76, i32 1
  %79 = load i64, i64* %78
  %80 = and i64 %79, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$28, label %$26
$28:
  %82 = phi i64 [%79, %$25] ; # Prg
  %83 = and i64 %77, 6
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$31, label %$30
$31:
  br label %$29
$30:
  %85 = and i64 %77, 8
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$33, label %$32
$33:
  %87 = inttoptr i64 %77 to i64*
  %88 = load i64, i64* %87
  br label %$29
$32:
  %89 = call i64 @evList(i64 %77)
  br label %$29
$29:
  %90 = phi i64 [%77, %$31], [%88, %$33], [%89, %$32] ; # ->
  br label %$27
$26:
  %91 = phi i64 [%79, %$25] ; # Prg
  %92 = and i64 %77, 15
  %93 = icmp eq i64 %92, 0
  br i1 %93, label %$35, label %$34
$35:
  %94 = phi i64 [%91, %$26] ; # Prg
  %95 = call i64 @evList(i64 %77)
  %96 = icmp ne i64 %95, 0
  br label %$34
$34:
  %97 = phi i64 [%91, %$26], [%94, %$35] ; # Prg
  %98 = phi i1 [0, %$26], [%96, %$35] ; # ->
  br label %$25
$27:
  %99 = phi i64 [%82, %$29] ; # Prg
  %100 = phi i64 [%90, %$29] ; # ->
; # (set $Intern Z)
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %65, i64* %101
; # (drop *Safe)
  %102 = inttoptr i64 %67 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %104, i64* %105
  br label %$24
$24:
  %106 = phi i64 [%55, %$22], [%61, %$27] ; # X
  %107 = phi i64 [%56, %$22], [%62, %$27] ; # Y
  %108 = phi i64 [%57, %$22], [%63, %$27] ; # L
  %109 = phi i64 [%59, %$22], [%100, %$27] ; # ->
  br label %$12
$11:
  %110 = phi i64 [%13, %$5] ; # X
  %111 = phi i64 [%21, %$5] ; # Y
; # (if (or (nil? (val (needSymb Exe Y))) (== @ Y)) (set (chkVar Exe ...
; # (or (nil? (val (needSymb Exe Y))) (== @ Y))
; # (needSymb Exe Y)
  %112 = xor i64 %111, 8
  %113 = and i64 %112, 14
  %114 = icmp eq i64 %113, 0
  br i1 %114, label %$38, label %$37
$37:
  call void @symErr(i64 %0, i64 %111)
  unreachable
$38:
; # (val (needSymb Exe Y))
  %115 = inttoptr i64 %111 to i64*
  %116 = load i64, i64* %115
; # (nil? (val (needSymb Exe Y)))
  %117 = icmp eq i64 %116, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %117, label %$36, label %$39
$39:
  %118 = phi i64 [%110, %$38] ; # X
  %119 = phi i64 [%111, %$38] ; # Y
; # (== @ Y)
  %120 = icmp eq i64 %116, %119
  br label %$36
$36:
  %121 = phi i64 [%110, %$38], [%118, %$39] ; # X
  %122 = phi i64 [%111, %$38], [%119, %$39] ; # Y
  %123 = phi i1 [1, %$38], [%120, %$39] ; # ->
  br i1 %123, label %$40, label %$41
$40:
  %124 = phi i64 [%121, %$36] ; # X
  %125 = phi i64 [%122, %$36] ; # Y
; # (set (chkVar Exe Y) (cons $Tilde (cons $Nil $Nil)))
; # (chkVar Exe Y)
  %126 = icmp uge i64 %125, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %126, label %$44, label %$43
$44:
  %127 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %125
  br label %$43
$43:
  %128 = phi i1 [0, %$40], [%127, %$44] ; # ->
  br i1 %128, label %$45, label %$46
$45:
  call void @protErr(i64 %0, i64 %125)
  unreachable
$46:
; # (cons $Nil $Nil)
  %129 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Tilde (cons $Nil $Nil))
  %130 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 56) to i64), i64 %129)
  %131 = inttoptr i64 %125 to i64*
  store i64 %130, i64* %131
  br label %$42
$41:
  %132 = phi i64 [%121, %$36] ; # X
  %133 = phi i64 [%122, %$36] ; # Y
; # (needNsp Exe Y)
  %134 = inttoptr i64 %133 to i64*
  %135 = load i64, i64* %134
  %136 = and i64 %135, 15
  %137 = icmp eq i64 %136, 0
  br i1 %137, label %$48, label %$47
$48:
  %138 = inttoptr i64 %135 to i64*
  %139 = load i64, i64* %138
  %140 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 56) to i64), %139
  br label %$47
$47:
  %141 = phi i1 [0, %$41], [%140, %$48] ; # ->
  br i1 %141, label %$50, label %$49
$49:
  call void @symNspErr(i64 0, i64 %133)
  unreachable
$50:
  br label %$42
$42:
  %142 = phi i64 [%124, %$46], [%132, %$50] ; # X
  %143 = phi i64 [%125, %$46], [%133, %$50] ; # Y
  %144 = phi i64 [%130, %$46], [%133, %$50] ; # ->
; # (let R (setq Y (save (cons Y $Nil))) (while (pair X) (setq Y (set...
; # (cons Y $Nil)
  %145 = call i64 @cons(i64 %143, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons Y $Nil))
  %146 = alloca i64, i64 2, align 16
  %147 = ptrtoint i64* %146 to i64
  %148 = inttoptr i64 %147 to i64*
  store i64 %145, i64* %148
  %149 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %150 = load i64, i64* %149
  %151 = inttoptr i64 %147 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  store i64 %150, i64* %152
  %153 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %147, i64* %153
; # (while (pair X) (setq Y (set 2 Y (cons (needNsp Exe (needSymb Exe...
  br label %$51
$51:
  %154 = phi i64 [%142, %$42], [%163, %$64] ; # X
  %155 = phi i64 [%145, %$42], [%183, %$64] ; # Y
; # (pair X)
  %156 = and i64 %154, 15
  %157 = icmp eq i64 %156, 0
  br i1 %157, label %$52, label %$53
$52:
  %158 = phi i64 [%154, %$51] ; # X
  %159 = phi i64 [%155, %$51] ; # Y
; # (set 2 Y (cons (needNsp Exe (needSymb Exe (eval (++ X)))) $Nil))
; # (++ X)
  %160 = inttoptr i64 %158 to i64*
  %161 = load i64, i64* %160
  %162 = getelementptr i64, i64* %160, i32 1
  %163 = load i64, i64* %162
; # (eval (++ X))
  %164 = and i64 %161, 6
  %165 = icmp ne i64 %164, 0
  br i1 %165, label %$56, label %$55
$56:
  br label %$54
$55:
  %166 = and i64 %161, 8
  %167 = icmp ne i64 %166, 0
  br i1 %167, label %$58, label %$57
$58:
  %168 = inttoptr i64 %161 to i64*
  %169 = load i64, i64* %168
  br label %$54
$57:
  %170 = call i64 @evList(i64 %161)
  br label %$54
$54:
  %171 = phi i64 [%161, %$56], [%169, %$58], [%170, %$57] ; # ->
; # (needSymb Exe (eval (++ X)))
  %172 = xor i64 %171, 8
  %173 = and i64 %172, 14
  %174 = icmp eq i64 %173, 0
  br i1 %174, label %$60, label %$59
$59:
  call void @symErr(i64 %0, i64 %171)
  unreachable
$60:
; # (needNsp Exe (needSymb Exe (eval (++ X))))
  %175 = inttoptr i64 %171 to i64*
  %176 = load i64, i64* %175
  %177 = and i64 %176, 15
  %178 = icmp eq i64 %177, 0
  br i1 %178, label %$62, label %$61
$62:
  %179 = inttoptr i64 %176 to i64*
  %180 = load i64, i64* %179
  %181 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 56) to i64), %180
  br label %$61
$61:
  %182 = phi i1 [0, %$60], [%181, %$62] ; # ->
  br i1 %182, label %$64, label %$63
$63:
  call void @symNspErr(i64 0, i64 %171)
  unreachable
$64:
; # (cons (needNsp Exe (needSymb Exe (eval (++ X)))) $Nil)
  %183 = call i64 @cons(i64 %171, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %184 = inttoptr i64 %159 to i64*
  %185 = getelementptr i64, i64* %184, i32 1
  store i64 %183, i64* %185
  br label %$51
$53:
  %186 = phi i64 [%154, %$51] ; # X
  %187 = phi i64 [%155, %$51] ; # Y
; # (prog1 (val $Intern) (set $Intern R))
; # (val $Intern)
  %188 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %189 = load i64, i64* %188
; # (set $Intern R)
  %190 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %145, i64* %190
; # (drop *Safe)
  %191 = inttoptr i64 %147 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
  %194 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %193, i64* %194
  br label %$12
$12:
  %195 = phi i64 [%106, %$24], [%186, %$53] ; # X
  %196 = phi i64 [%107, %$24], [%187, %$53] ; # Y
  %197 = phi i64 [%109, %$24], [%189, %$53] ; # ->
  br label %$4
$4:
  %198 = phi i64 [%6, %$2], [%195, %$12] ; # X
  %199 = phi i64 [%8, %$2], [%197, %$12] ; # ->
  ret i64 %199
}

define i64 @_intern(i64) {
$1:
; # (let (X (cdr Exe) Sym (save (needSymb Exe (eval (++ X))))) (cond ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needSymb Exe (eval (++ X)))
  %16 = xor i64 %15, 8
  %17 = and i64 %16, 14
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %15)
  unreachable
$8:
; # (save (needSymb Exe (eval (++ X))))
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %15, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (cond ((sym? (val (tail Sym))) $Nil) ((== (name @) ZERO) $Nil) (T...
; # (tail Sym)
  %27 = add i64 %15, -8
; # (val (tail Sym))
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (sym? (val (tail Sym)))
  %30 = and i64 %29, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  br label %$9
$10:
; # (name @)
  br label %$12
$12:
  %32 = phi i64 [%29, %$10], [%38, %$13] ; # Tail
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$14, label %$13
$13:
  %35 = phi i64 [%32, %$12] ; # Tail
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  br label %$12
$14:
  %39 = phi i64 [%32, %$12] ; # Tail
; # (== (name @) ZERO)
  %40 = icmp eq i64 %39, 2
  br i1 %40, label %$16, label %$15
$16:
  br label %$9
$15:
; # (let (Nm @ L (val $Intern) F (nil? (eval (car X)))) (intern (if F...
; # (val $Intern)
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %42 = load i64, i64* %41
; # (car X)
  %43 = inttoptr i64 %7 to i64*
  %44 = load i64, i64* %43
; # (eval (car X))
  %45 = and i64 %44, 6
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$19, label %$18
$19:
  br label %$17
$18:
  %47 = and i64 %44, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$21, label %$20
$21:
  %49 = inttoptr i64 %44 to i64*
  %50 = load i64, i64* %49
  br label %$17
$20:
  %51 = call i64 @evList(i64 %44)
  br label %$17
$17:
  %52 = phi i64 [%44, %$19], [%50, %$21], [%51, %$20] ; # ->
; # (nil? (eval (car X)))
  %53 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (if F 0 Sym)
  br i1 %53, label %$22, label %$23
$22:
  br label %$24
$23:
  br label %$24
$24:
  %54 = phi i64 [0, %$22], [%15, %$23] ; # ->
; # (car L)
  %55 = inttoptr i64 %42 to i64*
  %56 = load i64, i64* %55
; # (cdar (car L))
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
  %59 = inttoptr i64 %58 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
; # (if F (cdr L) $Nil)
  br i1 %53, label %$25, label %$26
$25:
; # (cdr L)
  %62 = inttoptr i64 %42 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  br label %$27
$26:
  br label %$27
$27:
  %65 = phi i64 [%64, %$25], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$26] ; # ->
; # (intern (if F 0 Sym) 0 Nm (cdar (car L)) (if F (cdr L) $Nil))
  %66 = call i64 @intern(i64 %54, i64 0, i64 %39, i64 %61, i64 %65)
  br label %$9
$9:
  %67 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%66, %$27] ; # ->
; # (drop *Safe)
  %68 = inttoptr i64 %20 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %71
  ret i64 %67
}

define i64 @_boxQ(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (not (sym? (val (tail...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (not (sym? (val (tail X)))) (== ZERO (name @))...
; # (and (symb? X) (not (sym? (val (tail X)))) (== ZERO (name @)))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (tail X)
  %17 = add i64 %13, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
; # (not (sym? (val (tail X))))
  %22 = icmp eq i1 %21, 0
  br i1 %22, label %$9, label %$7
$9:
; # (name @)
  br label %$10
$10:
  %23 = phi i64 [%19, %$9], [%29, %$11] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$12, label %$11
$11:
  %26 = phi i64 [%23, %$10] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$10
$12:
  %30 = phi i64 [%23, %$10] ; # Tail
; # (== ZERO (name @))
  %31 = icmp eq i64 2, %30
  br label %$7
$7:
  %32 = phi i1 [0, %$2], [0, %$8], [%31, %$12] ; # ->
  br i1 %32, label %$13, label %$14
$13:
  br label %$15
$14:
  br label %$15
$15:
  %33 = phi i64 [%13, %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$14] ; # ->
  ret i64 %33
}

define i64 @_strQ(i64) {
$1:
; # (let X (eval (cadr Exe)) (cond ((not (symb? X)) $Nil) ((or (sym? ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((not (symb? X)) $Nil) ((or (sym? (val (tail X))) (== X (is...
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  br label %$7
$8:
; # (or (sym? (val (tail X))) (== X (isLstIntern (name @) (val $Inter...
; # (tail X)
  %18 = add i64 %13, -8
; # (val (tail X))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (sym? (val (tail X)))
  %21 = and i64 %20, 8
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$10, label %$11
$11:
; # (name @)
  br label %$12
$12:
  %23 = phi i64 [%20, %$11], [%29, %$13] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$14, label %$13
$13:
  %26 = phi i64 [%23, %$12] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$12
$14:
  %30 = phi i64 [%23, %$12] ; # Tail
; # (val $Intern)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %32 = load i64, i64* %31
; # (isLstIntern (name @) (val $Intern))
  %33 = call i64 @isLstIntern(i64 %30, i64 %32)
; # (== X (isLstIntern (name @) (val $Intern)))
  %34 = icmp eq i64 %13, %33
  br label %$10
$10:
  %35 = phi i1 [1, %$8], [%34, %$14] ; # ->
  br i1 %35, label %$16, label %$15
$16:
  br label %$7
$15:
  br label %$7
$7:
  %36 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%13, %$15] ; # ->
  ret i64 %36
}

define i64 @_zap(i64) {
$1:
; # (let Sym (needSymb Exe (eval (cadr Exe))) (if (sym? (val (tail Sy...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (if (sym? (val (tail Sym))) (dbZap Sym) (unintern Sym (name @) (c...
; # (tail Sym)
  %17 = add i64 %13, -8
; # (val (tail Sym))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail Sym)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$10
$9:
; # (dbZap Sym)
  call void @dbZap(i64 %13)
  br label %$11
$10:
; # (name @)
  br label %$12
$12:
  %22 = phi i64 [%19, %$10], [%28, %$13] ; # Tail
  %23 = and i64 %22, 6
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$14, label %$13
$13:
  %25 = phi i64 [%22, %$12] ; # Tail
  %26 = inttoptr i64 %25 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  br label %$12
$14:
  %29 = phi i64 [%22, %$12] ; # Tail
; # (val $Intern)
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %31 = load i64, i64* %30
; # (car (val $Intern))
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (cdar (car (val $Intern)))
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %35 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
; # (unintern Sym (name @) (cdar (car (val $Intern))))
  call void @unintern(i64 %13, i64 %29, i64 %38)
  br label %$11
$11:
  ret i64 %13
}

define i64 @_chop(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (or (pair X) (nil? X)) X (let Tail (...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (pair X) (nil? X)) X (let Tail (val (tail (xSym X))) (if ...
; # (or (pair X) (nil? X))
; # (pair X)
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
; # (nil? X)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let Tail (val (tail (xSym X))) (if (sym? Tail) (chopExtNm (name ...
; # (xSym X)
  %18 = call i64 @xSym(i64 %13)
; # (tail (xSym X))
  %19 = add i64 %18, -8
; # (val (tail (xSym X)))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (if (sym? Tail) (chopExtNm (name (& Tail -9))) (let (P (push 0 (n...
; # (sym? Tail)
  %22 = and i64 %21, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$13
$12:
; # (& Tail -9)
  %24 = and i64 %21, -9
; # (name (& Tail -9))
  br label %$15
$15:
  %25 = phi i64 [%24, %$12], [%31, %$16] ; # Tail
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$17, label %$16
$16:
  %28 = phi i64 [%25, %$15] ; # Tail
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  br label %$15
$17:
  %32 = phi i64 [%25, %$15] ; # Tail
; # (chopExtNm (name (& Tail -9)))
  %33 = call i64 @chopExtNm(i64 %32)
  br label %$14
$13:
; # (let (P (push 0 (name Tail)) C (symChar P)) (if C (save Tail (let...
; # (name Tail)
  br label %$18
$18:
  %34 = phi i64 [%21, %$13], [%40, %$19] ; # Tail
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$20, label %$19
$19:
  %37 = phi i64 [%34, %$18] ; # Tail
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  br label %$18
$20:
  %41 = phi i64 [%34, %$18] ; # Tail
; # (push 0 (name Tail))
  %42 = alloca i64, i64 2, align 16
  store i64 0, i64* %42
  %43 = getelementptr i64, i64* %42, i32 1
  store i64 %41, i64* %43
; # (symChar P)
  %44 = call i32 @symChar(i64* %42)
; # (if C (save Tail (let (Y (cons (mkChar C) $Nil) R (save Y)) (whil...
  %45 = icmp ne i32 %44, 0
  br i1 %45, label %$21, label %$22
$21:
  %46 = phi i32 [%44, %$20] ; # C
; # (save Tail (let (Y (cons (mkChar C) $Nil) R (save Y)) (while (set...
  %47 = alloca i64, i64 2, align 16
  %48 = ptrtoint i64* %47 to i64
  %49 = inttoptr i64 %48 to i64*
  store i64 %21, i64* %49
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %48 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  store i64 %51, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %54
; # (let (Y (cons (mkChar C) $Nil) R (save Y)) (while (setq C (symCha...
; # (mkChar C)
  %55 = call i64 @mkChar(i32 %46)
; # (cons (mkChar C) $Nil)
  %56 = call i64 @cons(i64 %55, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %57 = alloca i64, i64 2, align 16
  %58 = ptrtoint i64* %57 to i64
  %59 = inttoptr i64 %58 to i64*
  store i64 %56, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %61 = load i64, i64* %60
  %62 = inttoptr i64 %58 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 %61, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %64
; # (while (setq C (symChar P)) (setq Y (set 2 Y (cons (mkChar C) $Ni...
  br label %$24
$24:
  %65 = phi i32 [%46, %$21], [%69, %$25] ; # C
  %66 = phi i64 [%56, %$21], [%72, %$25] ; # Y
; # (symChar P)
  %67 = call i32 @symChar(i64* %42)
  %68 = icmp ne i32 %67, 0
  br i1 %68, label %$25, label %$26
$25:
  %69 = phi i32 [%67, %$24] ; # C
  %70 = phi i64 [%66, %$24] ; # Y
; # (set 2 Y (cons (mkChar C) $Nil))
; # (mkChar C)
  %71 = call i64 @mkChar(i32 %69)
; # (cons (mkChar C) $Nil)
  %72 = call i64 @cons(i64 %71, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  br label %$24
$26:
  %75 = phi i32 [%67, %$24] ; # C
  %76 = phi i64 [%66, %$24] ; # Y
  %77 = inttoptr i64 %48 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  %79 = load i64, i64* %78
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %79, i64* %80
  br label %$23
$22:
  %81 = phi i32 [%44, %$20] ; # C
  br label %$23
$23:
  %82 = phi i32 [%75, %$26], [%81, %$22] ; # C
  %83 = phi i64 [%56, %$26], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
  br label %$14
$14:
  %84 = phi i64 [%33, %$17], [%83, %$23] ; # ->
  br label %$11
$11:
  %85 = phi i64 [%13, %$9], [%84, %$14] ; # ->
  ret i64 %85
}

define i64 @_pack(i64) {
$1:
; # (save -ZERO (let (X (cdr Exe) P (push 4 NIL ZERO NIL)) (link (ofs...
  %1 = alloca i64, i64 2, align 16
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 %2 to i64*
  store i64 10, i64* %3
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = inttoptr i64 %2 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  store i64 %5, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %2, i64* %8
; # (let (X (cdr Exe) P (push 4 NIL ZERO NIL)) (link (ofs P 2)) (whil...
; # (cdr Exe)
  %9 = inttoptr i64 %0 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (push 4 NIL ZERO NIL)
  %12 = alloca i64, i64 4, align 16
  store i64 4, i64* %12
  %13 = getelementptr i64, i64* %12, i32 2
  store i64 2, i64* %13
; # (ofs P 2)
  %14 = getelementptr i64, i64* %12, i32 2
; # (link (ofs P 2))
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %15 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  store i64 %17, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %20
; # (while (pair X) (pack (safe (eval (++ X))) P))
  br label %$2
$2:
  %21 = phi i64 [%11, %$1], [%28, %$5] ; # X
; # (pair X)
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$3, label %$4
$3:
  %24 = phi i64 [%21, %$2] ; # X
; # (++ X)
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
  %27 = getelementptr i64, i64* %25, i32 1
  %28 = load i64, i64* %27
; # (eval (++ X))
  %29 = and i64 %26, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$7, label %$6
$7:
  br label %$5
$6:
  %31 = and i64 %26, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  %33 = inttoptr i64 %26 to i64*
  %34 = load i64, i64* %33
  br label %$5
$8:
  %35 = call i64 @evList(i64 %26)
  br label %$5
$5:
  %36 = phi i64 [%26, %$7], [%34, %$9], [%35, %$8] ; # ->
; # (safe (eval (++ X)))
  %37 = inttoptr i64 %2 to i64*
  store i64 %36, i64* %37
; # (pack (safe (eval (++ X))) P)
  call void @pack(i64 %36, i64* %12)
  br label %$2
$4:
  %38 = phi i64 [%21, %$2] ; # X
; # (val 3 P)
  %39 = getelementptr i64, i64* %12, i32 2
  %40 = load i64, i64* %39
; # (consStr (val 3 P))
  %41 = call i64 @consStr(i64 %40)
  %42 = inttoptr i64 %2 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %44, i64* %45
  ret i64 %41
}

define i64 @_glue(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (++ X))) P...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %35, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %43
; # (push 4 NIL ZERO NIL)
  %44 = alloca i64, i64 4, align 16
  store i64 4, i64* %44
  %45 = getelementptr i64, i64* %44, i32 2
  store i64 2, i64* %45
; # (ofs P 2)
  %46 = getelementptr i64, i64* %44, i32 2
; # (link (ofs P 2))
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %49 = load i64, i64* %48
  %50 = inttoptr i64 %47 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  store i64 %49, i64* %51
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %52
; # (when (pair Z) (loop (pack (++ Z) P) (? (atom Z)) (pack Y P)))
; # (pair Z)
  %53 = and i64 %35, 15
  %54 = icmp eq i64 %53, 0
  br i1 %54, label %$12, label %$13
$12:
  %55 = phi i64 [%35, %$7] ; # Z
; # (loop (pack (++ Z) P) (? (atom Z)) (pack Y P))
  br label %$14
$14:
  %56 = phi i64 [%55, %$12], [%63, %$15] ; # Z
; # (++ Z)
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
  %59 = getelementptr i64, i64* %57, i32 1
  %60 = load i64, i64* %59
; # (pack (++ Z) P)
  call void @pack(i64 %58, i64* %44)
; # (? (atom Z))
; # (atom Z)
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$16, label %$15
$15:
  %63 = phi i64 [%60, %$14] ; # Z
; # (pack Y P)
  call void @pack(i64 %15, i64* %44)
  br label %$14
$16:
  %64 = phi i64 [%60, %$14] ; # Z
  %65 = phi i64 [0, %$14] ; # ->
  br label %$13
$13:
  %66 = phi i64 [%35, %$7], [%64, %$16] ; # Z
; # (val 3 P)
  %67 = getelementptr i64, i64* %44, i32 2
  %68 = load i64, i64* %67
; # (consStr (val 3 P))
  %69 = call i64 @consStr(i64 %68)
; # (drop *Safe)
  %70 = inttoptr i64 %17 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %72, i64* %73
  ret i64 %69
}

define i64 @_text(i64) {
$1:
; # (let (X (cdr Exe) Y (evSym X)) (if (nil? Y) Y (let (P (push 0 (xN...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (if (nil? Y) Y (let (P (push 0 (xName Exe Y) NIL) Q (link (ofs P ...
; # (nil? Y)
  %5 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
  br label %$4
$3:
  %7 = phi i64 [%3, %$1] ; # X
; # (let (P (push 0 (xName Exe Y) NIL) Q (link (ofs P 1) T) R (push 4...
; # (xName Exe Y)
  %8 = call i64 @xName(i64 %0, i64 %4)
; # (push 0 (xName Exe Y) NIL)
  %9 = alloca i64, i64 3, align 16
  store i64 0, i64* %9
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
; # (ofs P 1)
  %11 = getelementptr i64, i64* %9, i32 1
; # (link (ofs P 1) T)
  %12 = ptrtoint i64* %11 to i64
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %14 = load i64, i64* %13
  %15 = inttoptr i64 %12 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  store i64 %14, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %12, i64* %17
; # (push 4 NIL ZERO NIL)
  %18 = alloca i64, i64 4, align 16
  store i64 4, i64* %18
  %19 = getelementptr i64, i64* %18, i32 2
  store i64 2, i64* %19
; # (ofs R 2)
  %20 = getelementptr i64, i64* %18, i32 2
; # (link (ofs R 2))
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %21 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %26
; # (while (pair (shift X)) (setq A (link (push (eval (car X)) NIL)))...
  br label %$5
$5:
  %27 = phi i64 [%7, %$3], [%35, %$8] ; # X
  %28 = phi i64 [%21, %$3], [%49, %$8] ; # A
  %29 = phi i64 [0, %$3], [%56, %$8] ; # N
; # (shift X)
  %30 = inttoptr i64 %27 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (pair (shift X))
  %33 = and i64 %32, 15
  %34 = icmp eq i64 %33, 0
  br i1 %34, label %$6, label %$7
$6:
  %35 = phi i64 [%32, %$5] ; # X
  %36 = phi i64 [%28, %$5] ; # A
  %37 = phi i64 [%29, %$5] ; # N
; # (car X)
  %38 = inttoptr i64 %35 to i64*
  %39 = load i64, i64* %38
; # (eval (car X))
  %40 = and i64 %39, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$10, label %$9
$10:
  br label %$8
$9:
  %42 = and i64 %39, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$12, label %$11
$12:
  %44 = inttoptr i64 %39 to i64*
  %45 = load i64, i64* %44
  br label %$8
$11:
  %46 = call i64 @evList(i64 %39)
  br label %$8
$8:
  %47 = phi i64 [%39, %$10], [%45, %$12], [%46, %$11] ; # ->
; # (push (eval (car X)) NIL)
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %47, i64* %50
; # (link (push (eval (car X)) NIL))
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %52 = load i64, i64* %51
  %53 = inttoptr i64 %49 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  store i64 %52, i64* %54
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %55
; # (inc 'N)
  %56 = add i64 %37, 1
  br label %$5
$7:
  %57 = phi i64 [%32, %$5] ; # X
  %58 = phi i64 [%28, %$5] ; # A
  %59 = phi i64 [%29, %$5] ; # N
; # (while (setq C (symByte P)) (cond ((<> C (char "@")) (byteSym C R...
  br label %$13
$13:
  %60 = phi i64 [%57, %$7], [%141, %$16] ; # X
  %61 = phi i64 [%58, %$7], [%142, %$16] ; # A
  %62 = phi i64 [%59, %$7], [%143, %$16] ; # N
; # (symByte P)
  %63 = call i8 @symByte(i64* %9)
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %$14, label %$15
$14:
  %65 = phi i64 [%60, %$13] ; # X
  %66 = phi i64 [%61, %$13] ; # A
  %67 = phi i64 [%62, %$13] ; # N
  %68 = phi i8 [%63, %$13] ; # C
; # (cond ((<> C (char "@")) (byteSym C R)) ((== (setq C (symByte P))...
; # (<> C (char "@"))
  %69 = icmp ne i8 %68, 64
  br i1 %69, label %$18, label %$17
$18:
  %70 = phi i64 [%65, %$14] ; # X
  %71 = phi i64 [%66, %$14] ; # A
  %72 = phi i64 [%67, %$14] ; # N
  %73 = phi i8 [%68, %$14] ; # C
; # (byteSym C R)
  call void @byteSym(i8 %73, i64* %18)
  br label %$16
$17:
  %74 = phi i64 [%65, %$14] ; # X
  %75 = phi i64 [%66, %$14] ; # A
  %76 = phi i64 [%67, %$14] ; # N
  %77 = phi i8 [%68, %$14] ; # C
; # (symByte P)
  %78 = call i8 @symByte(i64* %9)
; # (== (setq C (symByte P)) (char "@"))
  %79 = icmp eq i8 %78, 64
  br i1 %79, label %$20, label %$19
$20:
  %80 = phi i64 [%74, %$17] ; # X
  %81 = phi i64 [%75, %$17] ; # A
  %82 = phi i64 [%76, %$17] ; # N
  %83 = phi i8 [%78, %$17] ; # C
; # (byteSym C R)
  call void @byteSym(i8 %83, i64* %18)
  br label %$16
$19:
  %84 = phi i64 [%74, %$17] ; # X
  %85 = phi i64 [%75, %$17] ; # A
  %86 = phi i64 [%76, %$17] ; # N
  %87 = phi i8 [%78, %$17] ; # C
; # (dec 'C (char "0"))
  %88 = sub i8 %87, 48
; # (gt0 (dec 'C (char "0")))
  %89 = icmp sgt i8 %88, 0
  br i1 %89, label %$22, label %$21
$22:
  %90 = phi i64 [%84, %$19] ; # X
  %91 = phi i64 [%85, %$19] ; # A
  %92 = phi i64 [%86, %$19] ; # N
  %93 = phi i8 [%88, %$19] ; # C
; # (when (> C 9) (dec 'C 7))
; # (> C 9)
  %94 = icmp ugt i8 %93, 9
  br i1 %94, label %$23, label %$24
$23:
  %95 = phi i64 [%90, %$22] ; # X
  %96 = phi i64 [%91, %$22] ; # A
  %97 = phi i64 [%92, %$22] ; # N
  %98 = phi i8 [%93, %$22] ; # C
; # (dec 'C 7)
  %99 = sub i8 %98, 7
  br label %$24
$24:
  %100 = phi i64 [%90, %$22], [%95, %$23] ; # X
  %101 = phi i64 [%91, %$22], [%96, %$23] ; # A
  %102 = phi i64 [%92, %$22], [%97, %$23] ; # N
  %103 = phi i8 [%93, %$22], [%99, %$23] ; # C
; # (when (ge0 (setq C (- N (i64 C)))) (let I A (while (ge0 (dec 'C))...
; # (i64 C)
  %104 = zext i8 %103 to i64
; # (- N (i64 C))
  %105 = sub i64 %102, %104
; # (ge0 (setq C (- N (i64 C))))
  %106 = icmp sge i64 %105, 0
  br i1 %106, label %$25, label %$26
$25:
  %107 = phi i64 [%100, %$24] ; # X
  %108 = phi i64 [%101, %$24] ; # A
  %109 = phi i64 [%102, %$24] ; # N
  %110 = phi i64 [%105, %$24] ; # C
; # (let I A (while (ge0 (dec 'C)) (shift I)) (pack (val I) R))
; # (while (ge0 (dec 'C)) (shift I))
  br label %$27
$27:
  %111 = phi i64 [%107, %$25], [%118, %$28] ; # X
  %112 = phi i64 [%108, %$25], [%119, %$28] ; # A
  %113 = phi i64 [%109, %$25], [%120, %$28] ; # N
  %114 = phi i64 [%110, %$25], [%121, %$28] ; # C
  %115 = phi i64 [%108, %$25], [%125, %$28] ; # I
; # (dec 'C)
  %116 = sub i64 %114, 1
; # (ge0 (dec 'C))
  %117 = icmp sge i64 %116, 0
  br i1 %117, label %$28, label %$29
$28:
  %118 = phi i64 [%111, %$27] ; # X
  %119 = phi i64 [%112, %$27] ; # A
  %120 = phi i64 [%113, %$27] ; # N
  %121 = phi i64 [%116, %$27] ; # C
  %122 = phi i64 [%115, %$27] ; # I
; # (shift I)
  %123 = inttoptr i64 %122 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  br label %$27
$29:
  %126 = phi i64 [%111, %$27] ; # X
  %127 = phi i64 [%112, %$27] ; # A
  %128 = phi i64 [%113, %$27] ; # N
  %129 = phi i64 [%116, %$27] ; # C
  %130 = phi i64 [%115, %$27] ; # I
; # (val I)
  %131 = inttoptr i64 %130 to i64*
  %132 = load i64, i64* %131
; # (pack (val I) R)
  call void @pack(i64 %132, i64* %18)
  br label %$26
$26:
  %133 = phi i64 [%100, %$24], [%126, %$29] ; # X
  %134 = phi i64 [%101, %$24], [%127, %$29] ; # A
  %135 = phi i64 [%102, %$24], [%128, %$29] ; # N
  %136 = phi i64 [%105, %$24], [%129, %$29] ; # C
  br label %$16
$21:
  %137 = phi i64 [%84, %$19] ; # X
  %138 = phi i64 [%85, %$19] ; # A
  %139 = phi i64 [%86, %$19] ; # N
  %140 = phi i8 [%88, %$19] ; # C
  br label %$16
$16:
  %141 = phi i64 [%70, %$18], [%80, %$20], [%133, %$26], [%137, %$21] ; # X
  %142 = phi i64 [%71, %$18], [%81, %$20], [%134, %$26], [%138, %$21] ; # A
  %143 = phi i64 [%72, %$18], [%82, %$20], [%135, %$26], [%139, %$21] ; # N
  br label %$13
$15:
  %144 = phi i64 [%60, %$13] ; # X
  %145 = phi i64 [%61, %$13] ; # A
  %146 = phi i64 [%62, %$13] ; # N
  %147 = phi i8 [%63, %$13] ; # C
; # (val 3 R)
  %148 = getelementptr i64, i64* %18, i32 2
  %149 = load i64, i64* %148
; # (consStr (val 3 R))
  %150 = call i64 @consStr(i64 %149)
; # (drop *Safe)
  %151 = inttoptr i64 %12 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  %154 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %153, i64* %154
  br label %$4
$4:
  %155 = phi i64 [%6, %$2], [%144, %$15] ; # X
  %156 = phi i64 [%4, %$2], [%150, %$15] ; # ->
  ret i64 %156
}

define i1 @preStr(i64, i8, i64*) {
$1:
; # (let (Q (push 0 (i64 Nm)) C (symByte Q)) (loop (? (<> B C) NO) (?...
; # (i64 Nm)
; # (push 0 (i64 Nm))
  %3 = alloca i64, i64 2, align 16
  store i64 0, i64* %3
  %4 = getelementptr i64, i64* %3, i32 1
  store i64 %0, i64* %4
; # (symByte Q)
  %5 = call i8 @symByte(i64* %3)
; # (loop (? (<> B C) NO) (? (=0 (setq C (symByte Q))) YES) (? (=0 (s...
  br label %$2
$2:
  %6 = phi i8 [%1, %$1], [%23, %$8] ; # B
  %7 = phi i8 [%5, %$1], [%24, %$8] ; # C
; # (? (<> B C) NO)
; # (<> B C)
  %8 = icmp ne i8 %6, %7
  br i1 %8, label %$5, label %$3
$5:
  %9 = phi i8 [%6, %$2] ; # B
  %10 = phi i8 [%7, %$2] ; # C
  br label %$4
$3:
  %11 = phi i8 [%6, %$2] ; # B
  %12 = phi i8 [%7, %$2] ; # C
; # (? (=0 (setq C (symByte Q))) YES)
; # (symByte Q)
  %13 = call i8 @symByte(i64* %3)
; # (=0 (setq C (symByte Q)))
  %14 = icmp eq i8 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  %15 = phi i8 [%11, %$3] ; # B
  %16 = phi i8 [%13, %$3] ; # C
  br label %$4
$6:
  %17 = phi i8 [%11, %$3] ; # B
  %18 = phi i8 [%13, %$3] ; # C
; # (? (=0 (setq B (symByte P))) NO)
; # (symByte P)
  %19 = call i8 @symByte(i64* %2)
; # (=0 (setq B (symByte P)))
  %20 = icmp eq i8 %19, 0
  br i1 %20, label %$9, label %$8
$9:
  %21 = phi i8 [%19, %$6] ; # B
  %22 = phi i8 [%18, %$6] ; # C
  br label %$4
$8:
  %23 = phi i8 [%19, %$6] ; # B
  %24 = phi i8 [%18, %$6] ; # C
  br label %$2
$4:
  %25 = phi i8 [%9, %$5], [%15, %$7], [%21, %$9] ; # B
  %26 = phi i8 [%10, %$5], [%16, %$7], [%22, %$9] ; # C
  %27 = phi i1 [0, %$5], [1, %$7], [0, %$9] ; # ->
  ret i1 %27
}

define i1 @subStr(i64, i64) {
$1:
; # (or (nil? X) (== ZERO (setq X (xName 0 X))) (let (P (push 0 (xNam...
; # (nil? X)
  %2 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %2, label %$2, label %$3
$3:
  %3 = phi i64 [%0, %$1] ; # X
; # (xName 0 X)
  %4 = call i64 @xName(i64 0, i64 %3)
; # (== ZERO (setq X (xName 0 X)))
  %5 = icmp eq i64 2, %4
  br i1 %5, label %$2, label %$4
$4:
  %6 = phi i64 [%4, %$3] ; # X
; # (let (P (push 0 (xName 0 Y)) B T) (loop (? (=0 (setq B (symByte P...
; # (xName 0 Y)
  %7 = call i64 @xName(i64 0, i64 %1)
; # (push 0 (xName 0 Y))
  %8 = alloca i64, i64 2, align 16
  store i64 0, i64* %8
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
; # (loop (? (=0 (setq B (symByte P))) NO) (let (Cnt (val P) Nm (val ...
  br label %$5
$5:
  %10 = phi i64 [%6, %$4], [%23, %$9] ; # X
; # (? (=0 (setq B (symByte P))) NO)
; # (symByte P)
  %11 = call i8 @symByte(i64* %8)
; # (=0 (setq B (symByte P)))
  %12 = icmp eq i8 %11, 0
  br i1 %12, label %$8, label %$6
$8:
  %13 = phi i64 [%10, %$5] ; # X
  %14 = phi i8 [%11, %$5] ; # B
  br label %$7
$6:
  %15 = phi i64 [%10, %$5] ; # X
  %16 = phi i8 [%11, %$5] ; # B
; # (let (Cnt (val P) Nm (val 2 P)) (? (preStr X B P) YES) (set P Cnt...
; # (val P)
  %17 = load i64, i64* %8
; # (val 2 P)
  %18 = getelementptr i64, i64* %8, i32 1
  %19 = load i64, i64* %18
; # (? (preStr X B P) YES)
; # (preStr X B P)
  %20 = call i1 @preStr(i64 %15, i8 %16, i64* %8)
  br i1 %20, label %$10, label %$9
$10:
  %21 = phi i64 [%15, %$6] ; # X
  %22 = phi i8 [%16, %$6] ; # B
  br label %$7
$9:
  %23 = phi i64 [%15, %$6] ; # X
  %24 = phi i8 [%16, %$6] ; # B
; # (set P Cnt 2 P Nm)
  store i64 %17, i64* %8
  %25 = getelementptr i64, i64* %8, i32 1
  store i64 %19, i64* %25
  br label %$5
$7:
  %26 = phi i64 [%13, %$8], [%21, %$10] ; # X
  %27 = phi i8 [%14, %$8], [%22, %$10] ; # B
  %28 = phi i1 [0, %$8], [1, %$10] ; # ->
  br label %$2
$2:
  %29 = phi i64 [%0, %$1], [%4, %$3], [%26, %$7] ; # X
  %30 = phi i1 [1, %$1], [1, %$3], [%28, %$7] ; # ->
  ret i1 %30
}

define i64 @_preQ(i64) {
$1:
; # (let (X (cdr Exe) Y (save (evSym X)) Z (evSym (shift X))) (cond (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (save (evSym X))
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %4, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %12
; # (shift X)
  %13 = inttoptr i64 %3 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (evSym (shift X))
  %16 = call i64 @evSym(i64 %15)
; # (cond ((nil? Y) Z) ((== ZERO (setq Y (xName Exe Y))) Z) (T (let P...
; # (nil? Y)
  %17 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %17, label %$4, label %$3
$4:
  %18 = phi i64 [%4, %$1] ; # Y
  br label %$2
$3:
  %19 = phi i64 [%4, %$1] ; # Y
; # (xName Exe Y)
  %20 = call i64 @xName(i64 %0, i64 %19)
; # (== ZERO (setq Y (xName Exe Y)))
  %21 = icmp eq i64 2, %20
  br i1 %21, label %$6, label %$5
$6:
  %22 = phi i64 [%20, %$3] ; # Y
  br label %$2
$5:
  %23 = phi i64 [%20, %$3] ; # Y
; # (let P (push 0 (xName Exe Z)) (cond ((=0 (symByte P)) $Nil) ((pre...
; # (xName Exe Z)
  %24 = call i64 @xName(i64 %0, i64 %16)
; # (push 0 (xName Exe Z))
  %25 = alloca i64, i64 2, align 16
  store i64 0, i64* %25
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
; # (cond ((=0 (symByte P)) $Nil) ((preStr Y @ P) Z) (T $Nil))
; # (symByte P)
  %27 = call i8 @symByte(i64* %25)
; # (=0 (symByte P))
  %28 = icmp eq i8 %27, 0
  br i1 %28, label %$9, label %$8
$9:
  %29 = phi i64 [%23, %$5] ; # Y
  br label %$7
$8:
  %30 = phi i64 [%23, %$5] ; # Y
; # (preStr Y @ P)
  %31 = call i1 @preStr(i64 %30, i8 %27, i64* %25)
  br i1 %31, label %$11, label %$10
$11:
  %32 = phi i64 [%30, %$8] ; # Y
  br label %$7
$10:
  %33 = phi i64 [%30, %$8] ; # Y
  br label %$7
$7:
  %34 = phi i64 [%29, %$9], [%32, %$11], [%33, %$10] ; # Y
  %35 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%16, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  br label %$2
$2:
  %36 = phi i64 [%18, %$4], [%22, %$6], [%34, %$7] ; # Y
  %37 = phi i64 [%16, %$4], [%16, %$6], [%35, %$7] ; # ->
; # (drop *Safe)
  %38 = inttoptr i64 %6 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  ret i64 %37
}

define i64 @_subQ(i64) {
$1:
; # (let (X (cdr Exe) Y (save (evSym X)) Z (evSym (shift X))) (if (su...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (save (evSym X))
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %4, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %12
; # (shift X)
  %13 = inttoptr i64 %3 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (evSym (shift X))
  %16 = call i64 @evSym(i64 %15)
; # (if (subStr Y Z) Z $Nil)
; # (subStr Y Z)
  %17 = call i1 @subStr(i64 %4, i64 %16)
  br i1 %17, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %18 = phi i64 [%16, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
; # (drop *Safe)
  %19 = inttoptr i64 %6 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %22
  ret i64 %18
}

define i64 @_val(i64) {
$1:
; # (let V (needVar Exe (eval (cadr Exe))) (when (and (sym? V) (sym? ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needVar Exe (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
; # (when (and (sym? V) (sym? (val (tail V)))) (dbFetch Exe V))
; # (and (sym? V) (sym? (val (tail V))))
; # (sym? V)
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$10, label %$9
$10:
; # (tail V)
  %18 = add i64 %13, -8
; # (val (tail V))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (sym? (val (tail V)))
  %21 = and i64 %20, 8
  %22 = icmp ne i64 %21, 0
  br label %$9
$9:
  %23 = phi i1 [0, %$8], [%22, %$10] ; # ->
  br i1 %23, label %$11, label %$12
$11:
; # (dbFetch Exe V)
  call void @dbFetch(i64 %0, i64 %13)
  br label %$12
$12:
; # (val V)
  %24 = inttoptr i64 %13 to i64*
  %25 = load i64, i64* %24
  ret i64 %25
}

define i64 @_set(i64) {
$1:
; # (save -ZERO (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (...
  %1 = alloca i64, i64 2, align 16
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 %2 to i64*
  store i64 10, i64* %3
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = inttoptr i64 %2 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  store i64 %5, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %2, i64* %8
; # (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (eval (++ X))...
; # (cdr Exe)
  %9 = inttoptr i64 %0 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (loop (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sy...
  br label %$2
$2:
  %12 = phi i64 [%11, %$1], [%59, %$23] ; # X
; # (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sym? Y) ...
; # (++ X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
  %15 = getelementptr i64, i64* %13, i32 1
  %16 = load i64, i64* %15
; # (eval (++ X))
  %17 = and i64 %14, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %14, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %14 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %14)
  br label %$3
$3:
  %24 = phi i64 [%14, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$8, label %$9
$8:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$9:
  %27 = icmp uge i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %27, label %$11, label %$10
$11:
  %28 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %24
  br label %$10
$10:
  %29 = phi i1 [0, %$9], [%28, %$11] ; # ->
  br i1 %29, label %$12, label %$13
$12:
  call void @protErr(i64 %0, i64 %24)
  unreachable
$13:
; # (safe (needChkVar Exe (eval (++ X))))
  %30 = inttoptr i64 %2 to i64*
  store i64 %24, i64* %30
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %31 = and i64 %24, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = phi i64 [%16, %$13] ; # X
; # (tail Y)
  %34 = add i64 %24, -8
; # (val (tail Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (sym? (val (tail Y)))
  %37 = and i64 %36, 8
  %38 = icmp ne i64 %37, 0
  br label %$14
$14:
  %39 = phi i64 [%16, %$13], [%33, %$15] ; # X
  %40 = phi i1 [0, %$13], [%38, %$15] ; # ->
  br i1 %40, label %$16, label %$17
$16:
  %41 = phi i64 [%39, %$14] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %24)
  br label %$17
$17:
  %42 = phi i64 [%39, %$14], [%41, %$16] ; # X
; # (let Z (eval (++ X)) (set Y Z) (? (atom X) Z))
; # (++ X)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (eval (++ X))
  %47 = and i64 %44, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$20, label %$19
$20:
  br label %$18
$19:
  %49 = and i64 %44, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  %51 = inttoptr i64 %44 to i64*
  %52 = load i64, i64* %51
  br label %$18
$21:
  %53 = call i64 @evList(i64 %44)
  br label %$18
$18:
  %54 = phi i64 [%44, %$20], [%52, %$22], [%53, %$21] ; # ->
; # (set Y Z)
  %55 = inttoptr i64 %24 to i64*
  store i64 %54, i64* %55
; # (? (atom X) Z)
; # (atom X)
  %56 = and i64 %46, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$25, label %$23
$25:
  %58 = phi i64 [%46, %$18] ; # X
  br label %$24
$23:
  %59 = phi i64 [%46, %$18] ; # X
  br label %$2
$24:
  %60 = phi i64 [%58, %$25] ; # X
  %61 = phi i64 [%54, %$25] ; # ->
  %62 = inttoptr i64 %2 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  %65 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %64, i64* %65
  ret i64 %61
}

define i64 @_setq(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (set (needChkVar Exe (++ X)) (eval ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (set (needChkVar Exe (++ X)) (eval (++ X))) (? (atom...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%30, %$14] ; # X
; # (let Y (set (needChkVar Exe (++ X)) (eval (++ X))) (? (atom X) Y)...
; # (set (needChkVar Exe (++ X)) (eval (++ X)))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
; # (++ X)
  %14 = inttoptr i64 %8 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
; # (eval (++ X))
  %18 = and i64 %15, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
  br label %$9
$10:
  %20 = and i64 %15, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  %22 = inttoptr i64 %15 to i64*
  %23 = load i64, i64* %22
  br label %$9
$12:
  %24 = call i64 @evList(i64 %15)
  br label %$9
$9:
  %25 = phi i64 [%15, %$11], [%23, %$13], [%24, %$12] ; # ->
  %26 = inttoptr i64 %6 to i64*
  store i64 %25, i64* %26
; # (? (atom X) Y)
; # (atom X)
  %27 = and i64 %17, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$16, label %$14
$16:
  %29 = phi i64 [%17, %$9] ; # X
  br label %$15
$14:
  %30 = phi i64 [%17, %$9] ; # X
  br label %$2
$15:
  %31 = phi i64 [%29, %$16] ; # X
  %32 = phi i64 [%25, %$16] ; # ->
  ret i64 %32
}

define i64 @_swap(i64) {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
; # (tail Y)
  %31 = add i64 %15, -8
; # (val (tail Y))
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (sym? (val (tail Y)))
  %34 = and i64 %33, 8
  %35 = icmp ne i64 %34, 0
  br label %$13
$13:
  %36 = phi i1 [0, %$12], [%35, %$14] ; # ->
  br i1 %36, label %$15, label %$16
$15:
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
; # (let (Z (eval (car X)) V (val Y)) (set Y Z) V)
; # (car X)
  %37 = inttoptr i64 %7 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$19, label %$18
$19:
  br label %$17
$18:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$21, label %$20
$21:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$17
$20:
  %45 = call i64 @evList(i64 %38)
  br label %$17
$17:
  %46 = phi i64 [%38, %$19], [%44, %$21], [%45, %$20] ; # ->
; # (val Y)
  %47 = inttoptr i64 %15 to i64*
  %48 = load i64, i64* %47
; # (set Y Z)
  %49 = inttoptr i64 %15 to i64*
  store i64 %46, i64* %49
; # (drop *Safe)
  %50 = inttoptr i64 %22 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %48
}

define i64 @_xchg(i64) {
$1:
; # (save -ZERO (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (...
  %1 = alloca i64, i64 2, align 16
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 %2 to i64*
  store i64 10, i64* %3
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = inttoptr i64 %2 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  store i64 %5, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %2, i64* %8
; # (let X (cdr Exe) (loop (let Y (safe (needChkVar Exe (eval (++ X))...
; # (cdr Exe)
  %9 = inttoptr i64 %0 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (loop (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sy...
  br label %$2
$2:
  %12 = phi i64 [%11, %$1], [%84, %$33] ; # X
; # (let Y (safe (needChkVar Exe (eval (++ X)))) (when (and (sym? Y) ...
; # (++ X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
  %15 = getelementptr i64, i64* %13, i32 1
  %16 = load i64, i64* %15
; # (eval (++ X))
  %17 = and i64 %14, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %14, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %14 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %14)
  br label %$3
$3:
  %24 = phi i64 [%14, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$8, label %$9
$8:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$9:
  %27 = icmp uge i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %27, label %$11, label %$10
$11:
  %28 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %24
  br label %$10
$10:
  %29 = phi i1 [0, %$9], [%28, %$11] ; # ->
  br i1 %29, label %$12, label %$13
$12:
  call void @protErr(i64 %0, i64 %24)
  unreachable
$13:
; # (safe (needChkVar Exe (eval (++ X))))
  %30 = inttoptr i64 %2 to i64*
  store i64 %24, i64* %30
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %31 = and i64 %24, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = phi i64 [%16, %$13] ; # X
; # (tail Y)
  %34 = add i64 %24, -8
; # (val (tail Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (sym? (val (tail Y)))
  %37 = and i64 %36, 8
  %38 = icmp ne i64 %37, 0
  br label %$14
$14:
  %39 = phi i64 [%16, %$13], [%33, %$15] ; # X
  %40 = phi i1 [0, %$13], [%38, %$15] ; # ->
  br i1 %40, label %$16, label %$17
$16:
  %41 = phi i64 [%39, %$14] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %24)
  br label %$17
$17:
  %42 = phi i64 [%39, %$14], [%41, %$16] ; # X
; # (let Z (needChkVar Exe (eval (++ X))) (when (and (sym? Z) (sym? (...
; # (++ X)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (eval (++ X))
  %47 = and i64 %44, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$20, label %$19
$20:
  br label %$18
$19:
  %49 = and i64 %44, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  %51 = inttoptr i64 %44 to i64*
  %52 = load i64, i64* %51
  br label %$18
$21:
  %53 = call i64 @evList(i64 %44)
  br label %$18
$18:
  %54 = phi i64 [%44, %$20], [%52, %$22], [%53, %$21] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %55 = and i64 %54, 6
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$23, label %$24
$23:
  call void @varErr(i64 %0, i64 %54)
  unreachable
$24:
  %57 = icmp uge i64 %54, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %57, label %$26, label %$25
$26:
  %58 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %54
  br label %$25
$25:
  %59 = phi i1 [0, %$24], [%58, %$26] ; # ->
  br i1 %59, label %$27, label %$28
$27:
  call void @protErr(i64 %0, i64 %54)
  unreachable
$28:
; # (when (and (sym? Z) (sym? (val (tail Z)))) (dbTouch Exe Z))
; # (and (sym? Z) (sym? (val (tail Z))))
; # (sym? Z)
  %60 = and i64 %54, 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$30, label %$29
$30:
  %62 = phi i64 [%46, %$28] ; # X
  %63 = phi i64 [%54, %$28] ; # Z
; # (tail Z)
  %64 = add i64 %63, -8
; # (val (tail Z))
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (sym? (val (tail Z)))
  %67 = and i64 %66, 8
  %68 = icmp ne i64 %67, 0
  br label %$29
$29:
  %69 = phi i64 [%46, %$28], [%62, %$30] ; # X
  %70 = phi i64 [%54, %$28], [%63, %$30] ; # Z
  %71 = phi i1 [0, %$28], [%68, %$30] ; # ->
  br i1 %71, label %$31, label %$32
$31:
  %72 = phi i64 [%69, %$29] ; # X
  %73 = phi i64 [%70, %$29] ; # Z
; # (dbTouch Exe Z)
  call void @dbTouch(i64 %0, i64 %73)
  br label %$32
$32:
  %74 = phi i64 [%69, %$29], [%72, %$31] ; # X
  %75 = phi i64 [%70, %$29], [%73, %$31] ; # Z
; # (xchg Y Z)
  %76 = inttoptr i64 %24 to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %75 to i64*
  %79 = load i64, i64* %78
  store i64 %79, i64* %76
  store i64 %77, i64* %78
; # (? (atom X) Z)
; # (atom X)
  %80 = and i64 %74, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$35, label %$33
$35:
  %82 = phi i64 [%74, %$32] ; # X
  %83 = phi i64 [%77, %$32] ; # Z
  br label %$34
$33:
  %84 = phi i64 [%74, %$32] ; # X
  %85 = phi i64 [%77, %$32] ; # Z
  br label %$2
$34:
  %86 = phi i64 [%82, %$35] ; # X
  %87 = phi i64 [%83, %$35] ; # ->
  %88 = inttoptr i64 %2 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %90, i64* %91
  ret i64 %87
}

define i64 @_on(i64) {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) $T) (? (atom ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) $T) (? (atom X) $T))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) $T)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), i64* %14
; # (? (atom X) $T)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$11] ; # ->
  ret i64 %20
}

define i64 @_off(i64) {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) $Nil) (? (ato...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) $Nil) (? (atom X) $Nil))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) $Nil)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %14
; # (? (atom X) $Nil)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  ret i64 %20
}

define i64 @_onOff(i64) {
$1:
; # (let X (cdr Exe) (loop (let (Y (needChkVar Exe (++ X)) Z (if (nil...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let (Y (needChkVar Exe (++ X)) Z (if (nil? (val Y)) $T $Ni...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%25, %$12] ; # X
; # (let (Y (needChkVar Exe (++ X)) Z (if (nil? (val Y)) $T $Nil)) (s...
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
; # (if (nil? (val Y)) $T $Nil)
; # (val Y)
  %14 = inttoptr i64 %6 to i64*
  %15 = load i64, i64* %14
; # (nil? (val Y))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$10
$9:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$11
$10:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$11
$11:
  %19 = phi i64 [%17, %$9], [%18, %$10] ; # X
  %20 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
; # (set Y Z)
  %21 = inttoptr i64 %6 to i64*
  store i64 %20, i64* %21
; # (? (atom X) Z)
; # (atom X)
  %22 = and i64 %19, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$12
$14:
  %24 = phi i64 [%19, %$11] ; # X
  br label %$13
$12:
  %25 = phi i64 [%19, %$11] ; # X
  br label %$2
$13:
  %26 = phi i64 [%24, %$14] ; # X
  %27 = phi i64 [%20, %$14] ; # ->
  ret i64 %27
}

define i64 @_zero(i64) {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) ZERO) (? (ato...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) ZERO) (? (atom X) ZERO))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) ZERO)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 2, i64* %14
; # (? (atom X) ZERO)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [2, %$11] ; # ->
  ret i64 %20
}

define i64 @_one(i64) {
$1:
; # (let X (cdr Exe) (loop (set (needChkVar Exe (++ X)) ONE) (? (atom...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (set (needChkVar Exe (++ X)) ONE) (? (atom X) ONE))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%18, %$9] ; # X
; # (set (needChkVar Exe (++ X)) ONE)
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
  %14 = inttoptr i64 %6 to i64*
  store i64 18, i64* %14
; # (? (atom X) ONE)
; # (atom X)
  %15 = and i64 %8, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$11, label %$9
$11:
  %17 = phi i64 [%8, %$8] ; # X
  br label %$10
$9:
  %18 = phi i64 [%8, %$8] ; # X
  br label %$2
$10:
  %19 = phi i64 [%17, %$11] ; # X
  %20 = phi i64 [18, %$11] ; # ->
  ret i64 %20
}

define i64 @_default(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (needChkVar Exe (++ X)) (when (nil?...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (needChkVar Exe (++ X)) (when (nil? (val Y)) (set Y ...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%38, %$16] ; # X
; # (let Y (needChkVar Exe (++ X)) (when (nil? (val Y)) (set Y (eval ...
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (needChkVar Exe (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  call void @varErr(i64 %0, i64 %6)
  unreachable
$4:
  %11 = icmp uge i64 %6, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %11, label %$6, label %$5
$6:
  %12 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %6
  br label %$5
$5:
  %13 = phi i1 [0, %$4], [%12, %$6] ; # ->
  br i1 %13, label %$7, label %$8
$7:
  call void @protErr(i64 %0, i64 %6)
  unreachable
$8:
; # (when (nil? (val Y)) (set Y (eval (car X))))
; # (val Y)
  %14 = inttoptr i64 %6 to i64*
  %15 = load i64, i64* %14
; # (nil? (val Y))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$10
$9:
  %17 = phi i64 [%8, %$8] ; # X
; # (set Y (eval (car X)))
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (eval (car X))
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  br label %$11
$12:
  %22 = and i64 %19, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$15, label %$14
$15:
  %24 = inttoptr i64 %19 to i64*
  %25 = load i64, i64* %24
  br label %$11
$14:
  %26 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %27 = phi i64 [%19, %$13], [%25, %$15], [%26, %$14] ; # ->
  %28 = inttoptr i64 %6 to i64*
  store i64 %27, i64* %28
  br label %$10
$10:
  %29 = phi i64 [%8, %$8], [%17, %$11] ; # X
; # (? (atom (shift X)) (val Y))
; # (shift X)
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (atom (shift X))
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$18, label %$16
$18:
  %35 = phi i64 [%32, %$10] ; # X
; # (val Y)
  %36 = inttoptr i64 %6 to i64*
  %37 = load i64, i64* %36
  br label %$17
$16:
  %38 = phi i64 [%32, %$10] ; # X
  br label %$2
$17:
  %39 = phi i64 [%35, %$18] ; # X
  %40 = phi i64 [%37, %$18] ; # ->
  ret i64 %40
}

define i64 @_push(i64) {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (loop (let Z (eval (++ X)) (set Y (cons Z (val Y))) (? (atom X) Z...
  br label %$17
$17:
  %41 = phi i64 [%40, %$16], [%61, %$23] ; # X
; # (let Z (eval (++ X)) (set Y (cons Z (val Y))) (? (atom X) Z))
; # (++ X)
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
; # (eval (++ X))
  %46 = and i64 %43, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$20, label %$19
$20:
  br label %$18
$19:
  %48 = and i64 %43, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$22, label %$21
$22:
  %50 = inttoptr i64 %43 to i64*
  %51 = load i64, i64* %50
  br label %$18
$21:
  %52 = call i64 @evList(i64 %43)
  br label %$18
$18:
  %53 = phi i64 [%43, %$20], [%51, %$22], [%52, %$21] ; # ->
; # (set Y (cons Z (val Y)))
; # (val Y)
  %54 = inttoptr i64 %15 to i64*
  %55 = load i64, i64* %54
; # (cons Z (val Y))
  %56 = call i64 @cons(i64 %53, i64 %55)
  %57 = inttoptr i64 %15 to i64*
  store i64 %56, i64* %57
; # (? (atom X) Z)
; # (atom X)
  %58 = and i64 %45, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$25, label %$23
$25:
  %60 = phi i64 [%45, %$18] ; # X
  br label %$24
$23:
  %61 = phi i64 [%45, %$18] ; # X
  br label %$17
$24:
  %62 = phi i64 [%60, %$25] ; # X
  %63 = phi i64 [%53, %$25] ; # ->
; # (drop *Safe)
  %64 = inttoptr i64 %22 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  %66 = load i64, i64* %65
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %66, i64* %67
  ret i64 %63
}

define i64 @_push1(i64) {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (loop (let (Z (eval (++ X)) V (val Y)) (unless (member Z V) (set ...
  br label %$17
$17:
  %41 = phi i64 [%40, %$16], [%78, %$31] ; # X
; # (let (Z (eval (++ X)) V (val Y)) (unless (member Z V) (set Y (con...
; # (++ X)
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
; # (eval (++ X))
  %46 = and i64 %43, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$20, label %$19
$20:
  br label %$18
$19:
  %48 = and i64 %43, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$22, label %$21
$22:
  %50 = inttoptr i64 %43 to i64*
  %51 = load i64, i64* %50
  br label %$18
$21:
  %52 = call i64 @evList(i64 %43)
  br label %$18
$18:
  %53 = phi i64 [%43, %$20], [%51, %$22], [%52, %$21] ; # ->
; # (val Y)
  %54 = inttoptr i64 %15 to i64*
  %55 = load i64, i64* %54
; # (unless (member Z V) (set Y (cons Z V)))
; # (member Z V)
  br label %$23
$23:
  %56 = phi i64 [%55, %$18], [%68, %$27] ; # L
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$26, label %$24
$26:
  %59 = phi i64 [%56, %$23] ; # L
  br label %$25
$24:
  %60 = phi i64 [%56, %$23] ; # L
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  %63 = call i1 @equal(i64 %53, i64 %62)
  br i1 %63, label %$28, label %$27
$28:
  %64 = phi i64 [%60, %$24] ; # L
  br label %$25
$27:
  %65 = phi i64 [%60, %$24] ; # L
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
  br label %$23
$25:
  %69 = phi i64 [%59, %$26], [%64, %$28] ; # L
  %70 = phi i1 [0, %$26], [1, %$28] ; # ->
  br i1 %70, label %$30, label %$29
$29:
  %71 = phi i64 [%45, %$25] ; # X
; # (set Y (cons Z V))
; # (cons Z V)
  %72 = call i64 @cons(i64 %53, i64 %55)
  %73 = inttoptr i64 %15 to i64*
  store i64 %72, i64* %73
  br label %$30
$30:
  %74 = phi i64 [%45, %$25], [%71, %$29] ; # X
; # (? (atom X) Z)
; # (atom X)
  %75 = and i64 %74, 15
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$33, label %$31
$33:
  %77 = phi i64 [%74, %$30] ; # X
  br label %$32
$31:
  %78 = phi i64 [%74, %$30] ; # X
  br label %$17
$32:
  %79 = phi i64 [%77, %$33] ; # X
  %80 = phi i64 [%53, %$33] ; # ->
; # (drop *Safe)
  %81 = inttoptr i64 %22 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_push1q(i64) {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (loop (let (Z (eval (++ X)) V (val Y)) (unless (memq Z V) (set Y ...
  br label %$17
$17:
  %41 = phi i64 [%40, %$16], [%78, %$31] ; # X
; # (let (Z (eval (++ X)) V (val Y)) (unless (memq Z V) (set Y (cons ...
; # (++ X)
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
; # (eval (++ X))
  %46 = and i64 %43, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$20, label %$19
$20:
  br label %$18
$19:
  %48 = and i64 %43, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$22, label %$21
$22:
  %50 = inttoptr i64 %43 to i64*
  %51 = load i64, i64* %50
  br label %$18
$21:
  %52 = call i64 @evList(i64 %43)
  br label %$18
$18:
  %53 = phi i64 [%43, %$20], [%51, %$22], [%52, %$21] ; # ->
; # (val Y)
  %54 = inttoptr i64 %15 to i64*
  %55 = load i64, i64* %54
; # (unless (memq Z V) (set Y (cons Z V)))
; # (memq Z V)
  br label %$23
$23:
  %56 = phi i64 [%55, %$18], [%68, %$27] ; # L
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$26, label %$24
$26:
  %59 = phi i64 [%56, %$23] ; # L
  br label %$25
$24:
  %60 = phi i64 [%56, %$23] ; # L
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  %63 = icmp eq i64 %53, %62
  br i1 %63, label %$28, label %$27
$28:
  %64 = phi i64 [%60, %$24] ; # L
  br label %$25
$27:
  %65 = phi i64 [%60, %$24] ; # L
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
  br label %$23
$25:
  %69 = phi i64 [%59, %$26], [%64, %$28] ; # L
  %70 = phi i1 [0, %$26], [1, %$28] ; # ->
  br i1 %70, label %$30, label %$29
$29:
  %71 = phi i64 [%45, %$25] ; # X
; # (set Y (cons Z V))
; # (cons Z V)
  %72 = call i64 @cons(i64 %53, i64 %55)
  %73 = inttoptr i64 %15 to i64*
  store i64 %72, i64* %73
  br label %$30
$30:
  %74 = phi i64 [%45, %$25], [%71, %$29] ; # X
; # (? (atom X) Z)
; # (atom X)
  %75 = and i64 %74, 15
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$33, label %$31
$33:
  %77 = phi i64 [%74, %$30] ; # X
  br label %$32
$31:
  %78 = phi i64 [%74, %$30] ; # X
  br label %$17
$32:
  %79 = phi i64 [%77, %$33] ; # X
  %80 = phi i64 [%53, %$33] ; # ->
; # (drop *Safe)
  %81 = inttoptr i64 %22 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_pop(i64) {
$1:
; # (let X (needChkVar Exe (eval (cadr Exe))) (when (and (sym? X) (sy...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needChkVar Exe (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$10, label %$9
$10:
  %17 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %13
  br label %$9
$9:
  %18 = phi i1 [0, %$8], [%17, %$10] ; # ->
  br i1 %18, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$12:
; # (when (and (sym? X) (sym? (val (tail X)))) (dbTouch Exe X))
; # (and (sym? X) (sym? (val (tail X))))
; # (sym? X)
  %19 = and i64 %13, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$14, label %$13
$14:
; # (tail X)
  %21 = add i64 %13, -8
; # (val (tail X))
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
; # (sym? (val (tail X)))
  %24 = and i64 %23, 8
  %25 = icmp ne i64 %24, 0
  br label %$13
$13:
  %26 = phi i1 [0, %$12], [%25, %$14] ; # ->
  br i1 %26, label %$15, label %$16
$15:
; # (dbTouch Exe X)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$16
$16:
; # (if (atom (val X)) @ (set X (cdr @)) (car @))
; # (val X)
  %27 = inttoptr i64 %13 to i64*
  %28 = load i64, i64* %27
; # (atom (val X))
  %29 = and i64 %28, 15
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$17, label %$18
$17:
  br label %$19
$18:
; # (set X (cdr @))
; # (cdr @)
  %31 = inttoptr i64 %28 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %13 to i64*
  store i64 %33, i64* %34
; # (car @)
  %35 = inttoptr i64 %28 to i64*
  %36 = load i64, i64* %35
  br label %$19
$19:
  %37 = phi i64 [%28, %$17], [%36, %$18] ; # ->
  ret i64 %37
}

define i64 @_popq(i64) {
$1:
; # (let X (needChkVar Exe (cadr Exe)) (if (atom (val X)) @ (set X (c...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (needChkVar Exe (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$2, label %$3
$2:
  call void @varErr(i64 %0, i64 %5)
  unreachable
$3:
  %8 = icmp uge i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %8, label %$5, label %$4
$5:
  %9 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %5
  br label %$4
$4:
  %10 = phi i1 [0, %$3], [%9, %$5] ; # ->
  br i1 %10, label %$6, label %$7
$6:
  call void @protErr(i64 %0, i64 %5)
  unreachable
$7:
; # (if (atom (val X)) @ (set X (cdr @)) (car @))
; # (val X)
  %11 = inttoptr i64 %5 to i64*
  %12 = load i64, i64* %11
; # (atom (val X))
  %13 = and i64 %12, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$9
$8:
  br label %$10
$9:
; # (set X (cdr @))
; # (cdr @)
  %15 = inttoptr i64 %12 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %5 to i64*
  store i64 %17, i64* %18
; # (car @)
  %19 = inttoptr i64 %12 to i64*
  %20 = load i64, i64* %19
  br label %$10
$10:
  %21 = phi i64 [%12, %$8], [%20, %$9] ; # ->
  ret i64 %21
}

define i64 @_cut(i64) {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X)) (if (le0 N) $Nil (let Y (needC...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (if (le0 N) $Nil (let Y (needChkVar Exe (eval (cadr X))) (when (a...
; # (le0 N)
  %5 = icmp sle i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%4, %$1] ; # N
  br label %$4
$3:
  %7 = phi i64 [%4, %$1] ; # N
; # (let Y (needChkVar Exe (eval (cadr X))) (when (and (sym? Y) (sym?...
; # (cadr X)
  %8 = inttoptr i64 %3 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (cadr X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  br label %$5
$6:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$5
$8:
  %19 = call i64 @evList(i64 %12)
  br label %$5
$5:
  %20 = phi i64 [%12, %$7], [%18, %$9], [%19, %$8] ; # ->
; # (needChkVar Exe (eval (cadr X)))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$10, label %$11
$10:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$11:
  %23 = icmp uge i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %23, label %$13, label %$12
$13:
  %24 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %20
  br label %$12
$12:
  %25 = phi i1 [0, %$11], [%24, %$13] ; # ->
  br i1 %25, label %$14, label %$15
$14:
  call void @protErr(i64 %0, i64 %20)
  unreachable
$15:
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %26 = and i64 %20, 8
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$17, label %$16
$17:
  %28 = phi i64 [%7, %$15] ; # N
; # (tail Y)
  %29 = add i64 %20, -8
; # (val (tail Y))
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (sym? (val (tail Y)))
  %32 = and i64 %31, 8
  %33 = icmp ne i64 %32, 0
  br label %$16
$16:
  %34 = phi i64 [%7, %$15], [%28, %$17] ; # N
  %35 = phi i1 [0, %$15], [%33, %$17] ; # ->
  br i1 %35, label %$18, label %$19
$18:
  %36 = phi i64 [%34, %$16] ; # N
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %20)
  br label %$19
$19:
  %37 = phi i64 [%34, %$16], [%36, %$18] ; # N
; # (if (atom (val Y)) @ (let (V (save @) Z (cons (++ V) $Nil) R (sav...
; # (val Y)
  %38 = inttoptr i64 %20 to i64*
  %39 = load i64, i64* %38
; # (atom (val Y))
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$20, label %$21
$20:
  %42 = phi i64 [%37, %$19] ; # N
  br label %$22
$21:
  %43 = phi i64 [%37, %$19] ; # N
; # (let (V (save @) Z (cons (++ V) $Nil) R (save Z)) (while (and (pa...
; # (save @)
  %44 = alloca i64, i64 2, align 16
  %45 = ptrtoint i64* %44 to i64
  %46 = inttoptr i64 %45 to i64*
  store i64 %39, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %48 = load i64, i64* %47
  %49 = inttoptr i64 %45 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  store i64 %48, i64* %50
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %51
; # (++ V)
  %52 = inttoptr i64 %39 to i64*
  %53 = load i64, i64* %52
  %54 = getelementptr i64, i64* %52, i32 1
  %55 = load i64, i64* %54
; # (cons (++ V) $Nil)
  %56 = call i64 @cons(i64 %53, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Z)
  %57 = alloca i64, i64 2, align 16
  %58 = ptrtoint i64* %57 to i64
  %59 = inttoptr i64 %58 to i64*
  store i64 %56, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %61 = load i64, i64* %60
  %62 = inttoptr i64 %58 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 %61, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %64
; # (while (and (pair V) (dec 'N)) (setq Z (set 2 Z (cons (++ V) $Nil...
  br label %$23
$23:
  %65 = phi i64 [%43, %$21], [%79, %$26] ; # N
  %66 = phi i64 [%55, %$21], [%85, %$26] ; # V
  %67 = phi i64 [%56, %$21], [%86, %$26] ; # Z
; # (and (pair V) (dec 'N))
; # (pair V)
  %68 = and i64 %66, 15
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %$25, label %$24
$25:
  %70 = phi i64 [%65, %$23] ; # N
  %71 = phi i64 [%66, %$23] ; # V
  %72 = phi i64 [%67, %$23] ; # Z
; # (dec 'N)
  %73 = sub i64 %70, 1
  %74 = icmp ne i64 %73, 0
  br label %$24
$24:
  %75 = phi i64 [%65, %$23], [%73, %$25] ; # N
  %76 = phi i64 [%66, %$23], [%71, %$25] ; # V
  %77 = phi i64 [%67, %$23], [%72, %$25] ; # Z
  %78 = phi i1 [0, %$23], [%74, %$25] ; # ->
  br i1 %78, label %$26, label %$27
$26:
  %79 = phi i64 [%75, %$24] ; # N
  %80 = phi i64 [%76, %$24] ; # V
  %81 = phi i64 [%77, %$24] ; # Z
; # (set 2 Z (cons (++ V) $Nil))
; # (++ V)
  %82 = inttoptr i64 %80 to i64*
  %83 = load i64, i64* %82
  %84 = getelementptr i64, i64* %82, i32 1
  %85 = load i64, i64* %84
; # (cons (++ V) $Nil)
  %86 = call i64 @cons(i64 %83, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %87 = inttoptr i64 %81 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  store i64 %86, i64* %88
  br label %$23
$27:
  %89 = phi i64 [%75, %$24] ; # N
  %90 = phi i64 [%76, %$24] ; # V
  %91 = phi i64 [%77, %$24] ; # Z
; # (set Y V)
  %92 = inttoptr i64 %20 to i64*
  store i64 %90, i64* %92
; # (drop *Safe)
  %93 = inttoptr i64 %45 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  %95 = load i64, i64* %94
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %95, i64* %96
  br label %$22
$22:
  %97 = phi i64 [%42, %$20], [%89, %$27] ; # N
  %98 = phi i64 [%39, %$20], [%56, %$27] ; # ->
  br label %$4
$4:
  %99 = phi i64 [%6, %$2], [%97, %$22] ; # N
  %100 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%98, %$22] ; # ->
  ret i64 %100
}

define i64 @_del(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Var (save (needChkVar Ex...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %36 = and i64 %35, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  call void @varErr(i64 %0, i64 %35)
  unreachable
$13:
  %38 = icmp uge i64 %35, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %38, label %$15, label %$14
$15:
  %39 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %35
  br label %$14
$14:
  %40 = phi i1 [0, %$13], [%39, %$15] ; # ->
  br i1 %40, label %$16, label %$17
$16:
  call void @protErr(i64 %0, i64 %35)
  unreachable
$17:
; # (save (needChkVar Exe (eval (++ X))))
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %35, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %45 = load i64, i64* %44
  %46 = inttoptr i64 %42 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %48
; # (car X)
  %49 = inttoptr i64 %27 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$20, label %$19
$20:
  br label %$18
$19:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$22, label %$21
$22:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$18
$21:
  %57 = call i64 @evList(i64 %50)
  br label %$18
$18:
  %58 = phi i64 [%50, %$20], [%56, %$22], [%57, %$21] ; # ->
; # (nil? (eval (car X)))
  %59 = icmp eq i64 %58, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (when (and (sym? Var) (sym? (val (tail Var)))) (dbTouch Exe Var))...
; # (and (sym? Var) (sym? (val (tail Var))))
; # (sym? Var)
  %60 = and i64 %35, 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$24, label %$23
$24:
; # (tail Var)
  %62 = add i64 %35, -8
; # (val (tail Var))
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (sym? (val (tail Var)))
  %65 = and i64 %64, 8
  %66 = icmp ne i64 %65, 0
  br label %$23
$23:
  %67 = phi i1 [0, %$18], [%66, %$24] ; # ->
  br i1 %67, label %$25, label %$26
$25:
; # (dbTouch Exe Var)
  call void @dbTouch(i64 %0, i64 %35)
  br label %$26
$26:
; # (let V (val Var) (loop (? (atom V) V) (let Z (++ V) (? (not (equa...
; # (val Var)
  %68 = inttoptr i64 %35 to i64*
  %69 = load i64, i64* %68
; # (loop (? (atom V) V) (let Z (++ V) (? (not (equal Y Z)) (let (P (...
  br label %$27
$27:
  %70 = phi i64 [%69, %$26], [%135, %$40] ; # V
; # (? (atom V) V)
; # (atom V)
  %71 = and i64 %70, 15
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$30, label %$28
$30:
  %73 = phi i64 [%70, %$27] ; # V
  br label %$29
$28:
  %74 = phi i64 [%70, %$27] ; # V
; # (let Z (++ V) (? (not (equal Y Z)) (let (P (cons Z $Nil) R P) (sa...
; # (++ V)
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
  %77 = getelementptr i64, i64* %75, i32 1
  %78 = load i64, i64* %77
; # (? (not (equal Y Z)) (let (P (cons Z $Nil) R P) (save R (loop (? ...
; # (equal Y Z)
  %79 = call i1 @equal(i64 %15, i64 %76)
; # (not (equal Y Z))
  %80 = icmp eq i1 %79, 0
  br i1 %80, label %$32, label %$31
$32:
  %81 = phi i64 [%78, %$28] ; # V
  %82 = phi i64 [%76, %$28] ; # Z
; # (let (P (cons Z $Nil) R P) (save R (loop (? (atom V)) (if (equal ...
; # (cons Z $Nil)
  %83 = call i64 @cons(i64 %82, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save R (loop (? (atom V)) (if (equal Y (setq Z (++ V))) (? Flg) ...
  %84 = alloca i64, i64 2, align 16
  %85 = ptrtoint i64* %84 to i64
  %86 = inttoptr i64 %85 to i64*
  store i64 %83, i64* %86
  %87 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %88 = load i64, i64* %87
  %89 = inttoptr i64 %85 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %88, i64* %90
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %85, i64* %91
; # (loop (? (atom V)) (if (equal Y (setq Z (++ V))) (? Flg) (setq P ...
  br label %$33
$33:
  %92 = phi i64 [%81, %$32], [%117, %$38] ; # V
  %93 = phi i64 [%82, %$32], [%118, %$38] ; # Z
  %94 = phi i64 [%83, %$32], [%119, %$38] ; # P
; # (? (atom V))
; # (atom V)
  %95 = and i64 %92, 15
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$35, label %$34
$34:
  %97 = phi i64 [%92, %$33] ; # V
  %98 = phi i64 [%93, %$33] ; # Z
  %99 = phi i64 [%94, %$33] ; # P
; # (if (equal Y (setq Z (++ V))) (? Flg) (setq P (set 2 P (cons Z $N...
; # (++ V)
  %100 = inttoptr i64 %97 to i64*
  %101 = load i64, i64* %100
  %102 = getelementptr i64, i64* %100, i32 1
  %103 = load i64, i64* %102
; # (equal Y (setq Z (++ V)))
  %104 = call i1 @equal(i64 %15, i64 %101)
  br i1 %104, label %$36, label %$37
$36:
  %105 = phi i64 [%103, %$34] ; # V
  %106 = phi i64 [%101, %$34] ; # Z
  %107 = phi i64 [%99, %$34] ; # P
; # (? Flg)
  br i1 %59, label %$35, label %$39
$39:
  %108 = phi i64 [%105, %$36] ; # V
  %109 = phi i64 [%106, %$36] ; # Z
  %110 = phi i64 [%107, %$36] ; # P
  br label %$38
$37:
  %111 = phi i64 [%103, %$34] ; # V
  %112 = phi i64 [%101, %$34] ; # Z
  %113 = phi i64 [%99, %$34] ; # P
; # (set 2 P (cons Z $Nil))
; # (cons Z $Nil)
  %114 = call i64 @cons(i64 %112, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %115 = inttoptr i64 %113 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  store i64 %114, i64* %116
  br label %$38
$38:
  %117 = phi i64 [%108, %$39], [%111, %$37] ; # V
  %118 = phi i64 [%109, %$39], [%112, %$37] ; # Z
  %119 = phi i64 [%110, %$39], [%114, %$37] ; # P
  br label %$33
$35:
  %120 = phi i64 [%92, %$33], [%105, %$36] ; # V
  %121 = phi i64 [%93, %$33], [%106, %$36] ; # Z
  %122 = phi i64 [%94, %$33], [%107, %$36] ; # P
  %123 = phi i64 [0, %$33], [0, %$36] ; # ->
  %124 = inttoptr i64 %85 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
  %127 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %126, i64* %127
; # (set 2 P V Var R)
  %128 = inttoptr i64 %122 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  store i64 %120, i64* %129
  %130 = inttoptr i64 %35 to i64*
  store i64 %83, i64* %130
  br label %$29
$31:
  %131 = phi i64 [%78, %$28] ; # V
  %132 = phi i64 [%76, %$28] ; # Z
; # (set Var V)
  %133 = inttoptr i64 %35 to i64*
  store i64 %131, i64* %133
; # (? Flg V)
  br i1 %59, label %$41, label %$40
$41:
  %134 = phi i64 [%131, %$31] ; # V
  br label %$29
$40:
  %135 = phi i64 [%131, %$31] ; # V
  br label %$27
$29:
  %136 = phi i64 [%73, %$30], [%120, %$35], [%134, %$41] ; # V
  %137 = phi i64 [%73, %$30], [%83, %$35], [%134, %$41] ; # ->
; # (drop *Safe)
  %138 = inttoptr i64 %17 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  %140 = load i64, i64* %139
  %141 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %140, i64* %141
  ret i64 %137
}

define i64 @_queue(i64) {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
; # (tail Y)
  %31 = add i64 %15, -8
; # (val (tail Y))
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (sym? (val (tail Y)))
  %34 = and i64 %33, 8
  %35 = icmp ne i64 %34, 0
  br label %$13
$13:
  %36 = phi i1 [0, %$12], [%35, %$14] ; # ->
  br i1 %36, label %$15, label %$16
$15:
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
; # (let (Z (eval (car X)) L (cons Z $Nil) V (val Y)) (if (atom V) (s...
; # (car X)
  %37 = inttoptr i64 %7 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$19, label %$18
$19:
  br label %$17
$18:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$21, label %$20
$21:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$17
$20:
  %45 = call i64 @evList(i64 %38)
  br label %$17
$17:
  %46 = phi i64 [%38, %$19], [%44, %$21], [%45, %$20] ; # ->
; # (cons Z $Nil)
  %47 = call i64 @cons(i64 %46, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (val Y)
  %48 = inttoptr i64 %15 to i64*
  %49 = load i64, i64* %48
; # (if (atom V) (set Y L) (while (pair (cdr V)) (shift V)) (set 2 V ...
; # (atom V)
  %50 = and i64 %49, 15
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$22, label %$23
$22:
  %52 = phi i64 [%49, %$17] ; # V
; # (set Y L)
  %53 = inttoptr i64 %15 to i64*
  store i64 %47, i64* %53
  br label %$24
$23:
  %54 = phi i64 [%49, %$17] ; # V
; # (while (pair (cdr V)) (shift V))
  br label %$25
$25:
  %55 = phi i64 [%54, %$23], [%64, %$26] ; # V
; # (cdr V)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (pair (cdr V))
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$26, label %$27
$26:
  %61 = phi i64 [%55, %$25] ; # V
; # (shift V)
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  br label %$25
$27:
  %65 = phi i64 [%55, %$25] ; # V
; # (set 2 V L)
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %47, i64* %67
  br label %$24
$24:
  %68 = phi i64 [%52, %$22], [%65, %$27] ; # V
  %69 = phi i64 [%47, %$22], [%47, %$27] ; # ->
; # (drop *Safe)
  %70 = inttoptr i64 %22 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %72, i64* %73
  ret i64 %46
}

define i64 @_fifo(i64) {
$1:
; # (let (X (cdr Exe) Y (save (needChkVar Exe (eval (++ X))))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (save (needChkVar Exe (eval (++ X))))
  %21 = alloca i64, i64 2, align 16
  %22 = ptrtoint i64* %21 to i64
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %25 = load i64, i64* %24
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %28
; # (when (and (sym? Y) (sym? (val (tail Y)))) (dbTouch Exe Y))
; # (and (sym? Y) (sym? (val (tail Y))))
; # (sym? Y)
  %29 = and i64 %15, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = phi i64 [%7, %$12] ; # X
; # (tail Y)
  %32 = add i64 %15, -8
; # (val (tail Y))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (sym? (val (tail Y)))
  %35 = and i64 %34, 8
  %36 = icmp ne i64 %35, 0
  br label %$13
$13:
  %37 = phi i64 [%7, %$12], [%31, %$14] ; # X
  %38 = phi i1 [0, %$12], [%36, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%37, %$13] ; # X
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$16
$16:
  %40 = phi i64 [%37, %$13], [%39, %$15] ; # X
; # (let V (val Y) (cond ((pair X) (let E (eval (car X)) (if (pair V)...
; # (val Y)
  %41 = inttoptr i64 %15 to i64*
  %42 = load i64, i64* %41
; # (cond ((pair X) (let E (eval (car X)) (if (pair V) (setq V (set 2...
; # (pair X)
  %43 = and i64 %40, 15
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$19, label %$18
$19:
  %45 = phi i64 [%40, %$16] ; # X
  %46 = phi i64 [%42, %$16] ; # V
; # (let E (eval (car X)) (if (pair V) (setq V (set 2 V (cons E (cdr ...
; # (car X)
  %47 = inttoptr i64 %45 to i64*
  %48 = load i64, i64* %47
; # (eval (car X))
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  br label %$20
$21:
  %51 = and i64 %48, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$24, label %$23
$24:
  %53 = inttoptr i64 %48 to i64*
  %54 = load i64, i64* %53
  br label %$20
$23:
  %55 = call i64 @evList(i64 %48)
  br label %$20
$20:
  %56 = phi i64 [%48, %$22], [%54, %$24], [%55, %$23] ; # ->
; # (if (pair V) (setq V (set 2 V (cons E (cdr V)))) (setq V (cons E ...
; # (pair V)
  %57 = and i64 %46, 15
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %$25, label %$26
$25:
  %59 = phi i64 [%45, %$20] ; # X
  %60 = phi i64 [%46, %$20] ; # V
  %61 = phi i64 [%56, %$20] ; # E
; # (set 2 V (cons E (cdr V)))
; # (cdr V)
  %62 = inttoptr i64 %60 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (cons E (cdr V))
  %65 = call i64 @cons(i64 %61, i64 %64)
  %66 = inttoptr i64 %60 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %65, i64* %67
  br label %$27
$26:
  %68 = phi i64 [%45, %$20] ; # X
  %69 = phi i64 [%46, %$20] ; # V
  %70 = phi i64 [%56, %$20] ; # E
; # (cons E -ZERO)
  %71 = call i64 @cons(i64 %70, i64 10)
; # (set 2 V V)
  %72 = inttoptr i64 %71 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  store i64 %71, i64* %73
  br label %$27
$27:
  %74 = phi i64 [%59, %$25], [%68, %$26] ; # X
  %75 = phi i64 [%65, %$25], [%71, %$26] ; # V
  %76 = phi i64 [%61, %$25], [%70, %$26] ; # E
  %77 = phi i64 [%65, %$25], [%71, %$26] ; # ->
; # (while (pair (shift X)) (setq V (set 2 V (cons (setq E (eval (car...
  br label %$28
$28:
  %78 = phi i64 [%74, %$27], [%86, %$31] ; # X
  %79 = phi i64 [%75, %$27], [%102, %$31] ; # V
  %80 = phi i64 [%76, %$27], [%98, %$31] ; # E
; # (shift X)
  %81 = inttoptr i64 %78 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (pair (shift X))
  %84 = and i64 %83, 15
  %85 = icmp eq i64 %84, 0
  br i1 %85, label %$29, label %$30
$29:
  %86 = phi i64 [%83, %$28] ; # X
  %87 = phi i64 [%79, %$28] ; # V
  %88 = phi i64 [%80, %$28] ; # E
; # (set 2 V (cons (setq E (eval (car X))) (cdr V)))
; # (car X)
  %89 = inttoptr i64 %86 to i64*
  %90 = load i64, i64* %89
; # (eval (car X))
  %91 = and i64 %90, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$33, label %$32
$33:
  br label %$31
$32:
  %93 = and i64 %90, 8
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$35, label %$34
$35:
  %95 = inttoptr i64 %90 to i64*
  %96 = load i64, i64* %95
  br label %$31
$34:
  %97 = call i64 @evList(i64 %90)
  br label %$31
$31:
  %98 = phi i64 [%90, %$33], [%96, %$35], [%97, %$34] ; # ->
; # (cdr V)
  %99 = inttoptr i64 %87 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
; # (cons (setq E (eval (car X))) (cdr V))
  %102 = call i64 @cons(i64 %98, i64 %101)
  %103 = inttoptr i64 %87 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  store i64 %102, i64* %104
  br label %$28
$30:
  %105 = phi i64 [%83, %$28] ; # X
  %106 = phi i64 [%79, %$28] ; # V
  %107 = phi i64 [%80, %$28] ; # E
; # (set Y V)
  %108 = inttoptr i64 %15 to i64*
  store i64 %106, i64* %108
  br label %$17
$18:
  %109 = phi i64 [%40, %$16] ; # X
  %110 = phi i64 [%42, %$16] ; # V
; # (atom V)
  %111 = and i64 %110, 15
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$37, label %$36
$37:
  %113 = phi i64 [%109, %$18] ; # X
  %114 = phi i64 [%110, %$18] ; # V
  br label %$17
$36:
  %115 = phi i64 [%109, %$18] ; # X
  %116 = phi i64 [%110, %$18] ; # V
; # (cdr V)
  %117 = inttoptr i64 %116 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  %119 = load i64, i64* %118
; # (== (cdr V) V)
  %120 = icmp eq i64 %119, %116
  br i1 %120, label %$39, label %$38
$39:
  %121 = phi i64 [%115, %$36] ; # X
  %122 = phi i64 [%116, %$36] ; # V
; # (set Y $Nil)
  %123 = inttoptr i64 %15 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %123
; # (car V)
  %124 = inttoptr i64 %122 to i64*
  %125 = load i64, i64* %124
  br label %$17
$38:
  %126 = phi i64 [%115, %$36] ; # X
  %127 = phi i64 [%116, %$36] ; # V
; # (set 2 V (cdr @))
; # (cdr @)
  %128 = inttoptr i64 %119 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 %127 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  store i64 %130, i64* %132
; # (car @)
  %133 = inttoptr i64 %119 to i64*
  %134 = load i64, i64* %133
  br label %$17
$17:
  %135 = phi i64 [%105, %$30], [%113, %$37], [%121, %$39], [%126, %$38] ; # X
  %136 = phi i64 [%106, %$30], [%114, %$37], [%122, %$39], [%127, %$38] ; # V
  %137 = phi i64 [%107, %$30], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$37], [%125, %$39], [%134, %$38] ; # ->
; # (drop *Safe)
  %138 = inttoptr i64 %22 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  %140 = load i64, i64* %139
  %141 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %140, i64* %141
  ret i64 %137
}

define i64 @idxPut(i64, i64) {
$1:
; # (let X (val Var) (if (pair X) (loop (? (=0 (compare (car X) Key))...
; # (val Var)
  %2 = inttoptr i64 %0 to i64*
  %3 = load i64, i64* %2
; # (if (pair X) (loop (? (=0 (compare (car X) Key)) X) (let Y (cdr X...
; # (pair X)
  %4 = and i64 %3, 15
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
; # (loop (? (=0 (compare (car X) Key)) X) (let Y (cdr X) (cond ((lt0...
  br label %$5
$5:
  %7 = phi i64 [%6, %$2], [%65, %$9] ; # X
; # (? (=0 (compare (car X) Key)) X)
; # (car X)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (compare (car X) Key)
  %10 = call i64 @compare(i64 %9, i64 %1)
; # (=0 (compare (car X) Key))
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$8, label %$6
$8:
  %12 = phi i64 [%7, %$5] ; # X
  br label %$7
$6:
  %13 = phi i64 [%7, %$5] ; # X
; # (let Y (cdr X) (cond ((lt0 @) (? (atom Y) (set 2 X (cons $Nil (co...
; # (cdr X)
  %14 = inttoptr i64 %13 to i64*
  %15 = getelementptr i64, i64* %14, i32 1
  %16 = load i64, i64* %15
; # (cond ((lt0 @) (? (atom Y) (set 2 X (cons $Nil (cons Key $Nil))) ...
; # (lt0 @)
  %17 = icmp slt i64 %10, 0
  br i1 %17, label %$11, label %$10
$11:
  %18 = phi i64 [%13, %$6] ; # X
  %19 = phi i64 [%16, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons $Nil (cons Key $Nil))) $Nil)
; # (atom Y)
  %20 = and i64 %19, 15
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  %22 = phi i64 [%18, %$11] ; # X
  %23 = phi i64 [%19, %$11] ; # Y
; # (set 2 X (cons $Nil (cons Key $Nil)))
; # (cons Key $Nil)
  %24 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Nil (cons Key $Nil))
  %25 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 %24)
  %26 = inttoptr i64 %22 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  store i64 %25, i64* %27
  br label %$7
$12:
  %28 = phi i64 [%18, %$11] ; # X
  %29 = phi i64 [%19, %$11] ; # Y
; # (? (atom (setq Y (cdr (setq X Y)))) (set 2 X (cons Key $Nil)) $Ni...
; # (cdr (setq X Y))
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (atom (setq Y (cdr (setq X Y))))
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$15, label %$14
$15:
  %35 = phi i64 [%29, %$12] ; # X
  %36 = phi i64 [%32, %$12] ; # Y
; # (set 2 X (cons Key $Nil))
; # (cons Key $Nil)
  %37 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %38 = inttoptr i64 %35 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  store i64 %37, i64* %39
  br label %$7
$14:
  %40 = phi i64 [%29, %$12] ; # X
  %41 = phi i64 [%32, %$12] ; # Y
  br label %$9
$10:
  %42 = phi i64 [%13, %$6] ; # X
  %43 = phi i64 [%16, %$6] ; # Y
; # (? (atom Y) (set 2 X (cons (cons Key $Nil) $Nil)) $Nil)
; # (atom Y)
  %44 = and i64 %43, 15
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$17, label %$16
$17:
  %46 = phi i64 [%42, %$10] ; # X
  %47 = phi i64 [%43, %$10] ; # Y
; # (set 2 X (cons (cons Key $Nil) $Nil))
; # (cons Key $Nil)
  %48 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (cons Key $Nil) $Nil)
  %49 = call i64 @cons(i64 %48, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %50 = inttoptr i64 %46 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  store i64 %49, i64* %51
  br label %$7
$16:
  %52 = phi i64 [%42, %$10] ; # X
  %53 = phi i64 [%43, %$10] ; # Y
; # (? (atom (setq Y (car (setq X Y)))) (set X (cons Key $Nil)) $Nil)...
; # (car (setq X Y))
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (atom (setq Y (car (setq X Y))))
  %56 = and i64 %55, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$19, label %$18
$19:
  %58 = phi i64 [%53, %$16] ; # X
  %59 = phi i64 [%55, %$16] ; # Y
; # (set X (cons Key $Nil))
; # (cons Key $Nil)
  %60 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %61 = inttoptr i64 %58 to i64*
  store i64 %60, i64* %61
  br label %$7
$18:
  %62 = phi i64 [%53, %$16] ; # X
  %63 = phi i64 [%55, %$16] ; # Y
  br label %$9
$9:
  %64 = phi i64 [%40, %$14], [%62, %$18] ; # X
  %65 = phi i64 [%41, %$14], [%63, %$18] ; # Y
  br label %$5
$7:
  %66 = phi i64 [%12, %$8], [%22, %$13], [%35, %$15], [%46, %$17], [%58, %$19] ; # X
  %67 = phi i64 [%12, %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$19] ; # ->
  br label %$4
$3:
  %68 = phi i64 [%3, %$1] ; # X
; # (set Var (cons Key $Nil))
; # (cons Key $Nil)
  %69 = call i64 @cons(i64 %1, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %70 = inttoptr i64 %0 to i64*
  store i64 %69, i64* %70
  br label %$4
$4:
  %71 = phi i64 [%66, %$7], [%68, %$3] ; # X
  %72 = phi i64 [%67, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %72
}

define i64 @idxGet(i64, i64) {
$1:
; # (let X (val Var) (loop (? (atom X) $Nil) (? (=0 (compare (car X) ...
; # (val Var)
  %2 = inttoptr i64 %0 to i64*
  %3 = load i64, i64* %2
; # (loop (? (atom X) $Nil) (? (=0 (compare (car X) Key)) X) (let Y (...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%27, %$10] ; # X
; # (? (atom X) $Nil)
; # (atom X)
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%4, %$2] ; # X
  br label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
; # (? (=0 (compare (car X) Key)) X)
; # (car X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (compare (car X) Key)
  %11 = call i64 @compare(i64 %10, i64 %1)
; # (=0 (compare (car X) Key))
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = phi i64 [%8, %$3] ; # X
  br label %$4
$6:
  %14 = phi i64 [%8, %$3] ; # X
; # (let Y (cdr X) (setq X (if (lt0 @) (cdr Y) (car Y))))
; # (cdr X)
  %15 = inttoptr i64 %14 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
; # (if (lt0 @) (cdr Y) (car Y))
; # (lt0 @)
  %18 = icmp slt i64 %11, 0
  br i1 %18, label %$8, label %$9
$8:
  %19 = phi i64 [%14, %$6] ; # X
; # (cdr Y)
  %20 = inttoptr i64 %17 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
  br label %$10
$9:
  %23 = phi i64 [%14, %$6] ; # X
; # (car Y)
  %24 = inttoptr i64 %17 to i64*
  %25 = load i64, i64* %24
  br label %$10
$10:
  %26 = phi i64 [%19, %$8], [%23, %$9] ; # X
  %27 = phi i64 [%22, %$8], [%25, %$9] ; # ->
  br label %$2
$4:
  %28 = phi i64 [%7, %$5], [%13, %$7] ; # X
  %29 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%13, %$7] ; # ->
  ret i64 %29
}

define i64 @idxDel(i64, i64) {
$1:
; # (loop (let X (val Var) (? (atom X) $Nil) (let Y (cdr X) (let I (c...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%126, %$21] ; # Var
; # (let X (val Var) (? (atom X) $Nil) (let Y (cdr X) (let I (compare...
; # (val Var)
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (? (atom X) $Nil)
; # (atom X)
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%2, %$2] ; # Var
  br label %$4
$3:
  %8 = phi i64 [%2, %$2] ; # Var
; # (let Y (cdr X) (let I (compare (car X) Key) (? (=0 I) (cond ((ato...
; # (cdr X)
  %9 = inttoptr i64 %4 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (let I (compare (car X) Key) (? (=0 I) (cond ((atom (car Y)) (set...
; # (car X)
  %12 = inttoptr i64 %4 to i64*
  %13 = load i64, i64* %12
; # (compare (car X) Key)
  %14 = call i64 @compare(i64 %13, i64 %1)
; # (? (=0 I) (cond ((atom (car Y)) (set Var (cdr Y))) ((atom (cdr Y)...
; # (=0 I)
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  %16 = phi i64 [%8, %$3] ; # Var
  %17 = phi i64 [%11, %$3] ; # Y
; # (cond ((atom (car Y)) (set Var (cdr Y))) ((atom (cdr Y)) (set Var...
; # (car Y)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (atom (car Y))
  %20 = and i64 %19, 15
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$9
$10:
  %22 = phi i64 [%16, %$7] ; # Var
  %23 = phi i64 [%17, %$7] ; # Y
; # (set Var (cdr Y))
; # (cdr Y)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %22 to i64*
  store i64 %26, i64* %27
  br label %$8
$9:
  %28 = phi i64 [%16, %$7] ; # Var
  %29 = phi i64 [%17, %$7] ; # Y
; # (cdr Y)
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (atom (cdr Y))
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  %35 = phi i64 [%28, %$9] ; # Var
  %36 = phi i64 [%29, %$9] ; # Y
; # (set Var (car Y))
; # (car Y)
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %35 to i64*
  store i64 %38, i64* %39
  br label %$8
$11:
  %40 = phi i64 [%28, %$9] ; # Var
  %41 = phi i64 [%29, %$9] ; # Y
; # (let Z (cdr (setq Y (cdr Y))) (if (atom (car Z)) (set X (car Y) 2...
; # (cdr Y)
  %42 = inttoptr i64 %41 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
; # (cdr (setq Y (cdr Y)))
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (if (atom (car Z)) (set X (car Y) 2 (cdr X) (cdr Z)) (let L (cdr ...
; # (car Z)
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (atom (car Z))
  %50 = and i64 %49, 15
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$13, label %$14
$13:
  %52 = phi i64 [%40, %$11] ; # Var
  %53 = phi i64 [%44, %$11] ; # Y
  %54 = phi i64 [%47, %$11] ; # Z
; # (set X (car Y) 2 (cdr X) (cdr Z))
; # (car Y)
  %55 = inttoptr i64 %53 to i64*
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %4 to i64*
  store i64 %56, i64* %57
; # (cdr X)
  %58 = inttoptr i64 %4 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
; # (cdr Z)
  %61 = inttoptr i64 %54 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
  %64 = inttoptr i64 %60 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  store i64 %63, i64* %65
  br label %$15
$14:
  %66 = phi i64 [%40, %$11] ; # Var
  %67 = phi i64 [%44, %$11] ; # Y
  %68 = phi i64 [%47, %$11] ; # Z
; # (let L (cdr (setq Z (car Z))) (loop (? (atom (car L))) (setq Y Z ...
; # (car Z)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (cdr (setq Z (car Z)))
  %71 = inttoptr i64 %70 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
; # (loop (? (atom (car L))) (setq Y Z Z (car L) L (cdr Z)))
  br label %$16
$16:
  %74 = phi i64 [%66, %$14], [%82, %$17] ; # Var
  %75 = phi i64 [%67, %$14], [%84, %$17] ; # Y
  %76 = phi i64 [%70, %$14], [%87, %$17] ; # Z
  %77 = phi i64 [%73, %$14], [%90, %$17] ; # L
; # (? (atom (car L)))
; # (car L)
  %78 = inttoptr i64 %77 to i64*
  %79 = load i64, i64* %78
; # (atom (car L))
  %80 = and i64 %79, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$18, label %$17
$17:
  %82 = phi i64 [%74, %$16] ; # Var
  %83 = phi i64 [%75, %$16] ; # Y
  %84 = phi i64 [%76, %$16] ; # Z
  %85 = phi i64 [%77, %$16] ; # L
; # (car L)
  %86 = inttoptr i64 %85 to i64*
  %87 = load i64, i64* %86
; # (cdr Z)
  %88 = inttoptr i64 %87 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  br label %$16
$18:
  %91 = phi i64 [%74, %$16] ; # Var
  %92 = phi i64 [%75, %$16] ; # Y
  %93 = phi i64 [%76, %$16] ; # Z
  %94 = phi i64 [%77, %$16] ; # L
  %95 = phi i64 [0, %$16] ; # ->
; # (set X (car Z) (cdr Y) (cdr L))
; # (car Z)
  %96 = inttoptr i64 %93 to i64*
  %97 = load i64, i64* %96
  %98 = inttoptr i64 %4 to i64*
  store i64 %97, i64* %98
; # (cdr Y)
  %99 = inttoptr i64 %92 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
; # (cdr L)
  %102 = inttoptr i64 %94 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  %105 = inttoptr i64 %101 to i64*
  store i64 %104, i64* %105
  br label %$15
$15:
  %106 = phi i64 [%52, %$13], [%91, %$18] ; # Var
  %107 = phi i64 [%53, %$13], [%92, %$18] ; # Y
  %108 = phi i64 [%54, %$13], [%93, %$18] ; # Z
  %109 = phi i64 [%63, %$13], [%104, %$18] ; # ->
  br label %$8
$8:
  %110 = phi i64 [%22, %$10], [%35, %$12], [%106, %$15] ; # Var
  %111 = phi i64 [%23, %$10], [%36, %$12], [%107, %$15] ; # Y
  %112 = phi i64 [%26, %$10], [%38, %$12], [%109, %$15] ; # ->
  br label %$4
$6:
  %113 = phi i64 [%8, %$3] ; # Var
  %114 = phi i64 [%11, %$3] ; # Y
; # (? (atom Y) $Nil)
; # (atom Y)
  %115 = and i64 %114, 15
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$20, label %$19
$20:
  %117 = phi i64 [%113, %$6] ; # Var
  %118 = phi i64 [%114, %$6] ; # Y
  br label %$4
$19:
  %119 = phi i64 [%113, %$6] ; # Var
  %120 = phi i64 [%114, %$6] ; # Y
; # (and (lt0 I) (setq Var (ofs Var 1)))
; # (lt0 I)
  %121 = icmp slt i64 %14, 0
  br i1 %121, label %$22, label %$21
$22:
  %122 = phi i64 [%120, %$19] ; # Var
  %123 = phi i64 [%120, %$19] ; # Y
; # (ofs Var 1)
  %124 = add i64 %122, 8
  %125 = icmp ne i64 %124, 0
  br label %$21
$21:
  %126 = phi i64 [%120, %$19], [%124, %$22] ; # Var
  %127 = phi i64 [%120, %$19], [%123, %$22] ; # Y
  %128 = phi i1 [0, %$19], [%125, %$22] ; # ->
  br label %$2
$4:
  %129 = phi i64 [%7, %$5], [%110, %$8], [%117, %$20] ; # Var
  %130 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%4, %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$20] ; # ->
  ret i64 %130
}

define i64 @_idx(i64) {
$1:
; # (let (X (cdr Exe) Var (needChkVar Exe (eval (++ X)))) (if (atom X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needChkVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
  %18 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$10, label %$9
$10:
  %19 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$9
$9:
  %20 = phi i1 [0, %$8], [%19, %$10] ; # ->
  br i1 %20, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$12:
; # (if (atom X) (consTree (val Var) $Nil) (save Var (let Key (save (...
; # (atom X)
  %21 = and i64 %7, 15
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$13, label %$14
$13:
  %23 = phi i64 [%7, %$12] ; # X
; # (val Var)
  %24 = inttoptr i64 %15 to i64*
  %25 = load i64, i64* %24
; # (consTree (val Var) $Nil)
  %26 = call i64 @consTree(i64 %25, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$15
$14:
  %27 = phi i64 [%7, %$12] ; # X
; # (save Var (let Key (save (eval (++ X))) (cond ((atom X) (idxGet V...
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %15, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (let Key (save (eval (++ X))) (cond ((atom X) (idxGet Var Key)) (...
; # (++ X)
  %36 = inttoptr i64 %27 to i64*
  %37 = load i64, i64* %36
  %38 = getelementptr i64, i64* %36, i32 1
  %39 = load i64, i64* %38
; # (eval (++ X))
  %40 = and i64 %37, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$18, label %$17
$18:
  br label %$16
$17:
  %42 = and i64 %37, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$20, label %$19
$20:
  %44 = inttoptr i64 %37 to i64*
  %45 = load i64, i64* %44
  br label %$16
$19:
  %46 = call i64 @evList(i64 %37)
  br label %$16
$16:
  %47 = phi i64 [%37, %$18], [%45, %$20], [%46, %$19] ; # ->
; # (save (eval (++ X)))
  %48 = alloca i64, i64 2, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %47, i64* %50
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %52 = load i64, i64* %51
  %53 = inttoptr i64 %49 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  store i64 %52, i64* %54
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %55
; # (cond ((atom X) (idxGet Var Key)) ((nil? (eval (car X))) (idxDel ...
; # (atom X)
  %56 = and i64 %39, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$23, label %$22
$23:
  %58 = phi i64 [%39, %$16] ; # X
; # (idxGet Var Key)
  %59 = call i64 @idxGet(i64 %15, i64 %47)
  br label %$21
$22:
  %60 = phi i64 [%39, %$16] ; # X
; # (car X)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (eval (car X))
  %63 = and i64 %62, 6
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$26, label %$25
$26:
  br label %$24
$25:
  %65 = and i64 %62, 8
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$28, label %$27
$28:
  %67 = inttoptr i64 %62 to i64*
  %68 = load i64, i64* %67
  br label %$24
$27:
  %69 = call i64 @evList(i64 %62)
  br label %$24
$24:
  %70 = phi i64 [%62, %$26], [%68, %$28], [%69, %$27] ; # ->
; # (nil? (eval (car X)))
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %71, label %$30, label %$29
$30:
  %72 = phi i64 [%60, %$24] ; # X
; # (idxDel Var Key)
  %73 = call i64 @idxDel(i64 %15, i64 %47)
  br label %$21
$29:
  %74 = phi i64 [%60, %$24] ; # X
; # (idxPut Var Key)
  %75 = call i64 @idxPut(i64 %15, i64 %47)
  br label %$21
$21:
  %76 = phi i64 [%58, %$23], [%72, %$30], [%74, %$29] ; # X
  %77 = phi i64 [%59, %$23], [%73, %$30], [%75, %$29] ; # ->
  %78 = inttoptr i64 %29 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  %80 = load i64, i64* %79
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %81
  br label %$15
$15:
  %82 = phi i64 [%23, %$13], [%76, %$21] ; # X
  %83 = phi i64 [%26, %$13], [%77, %$21] ; # ->
  ret i64 %83
}

define i64 @_lup(i64) {
$1:
; # (let (X (cdr Exe) P (save (eval (++ X)))) (if (atom P) P (let Key...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (if (atom P) P (let Key (eval (++ X)) (if (atom X) (loop (let Y (...
; # (atom P)
  %24 = and i64 %15, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$7, label %$8
$7:
  %26 = phi i64 [%7, %$2] ; # X
  %27 = phi i64 [%15, %$2] ; # P
  br label %$9
$8:
  %28 = phi i64 [%7, %$2] ; # X
  %29 = phi i64 [%15, %$2] ; # P
; # (let Key (eval (++ X)) (if (atom X) (loop (let Y (car P) (cond ((...
; # (++ X)
  %30 = inttoptr i64 %28 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
; # (eval (++ X))
  %34 = and i64 %31, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %31, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %31 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %31)
  br label %$10
$10:
  %41 = phi i64 [%31, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (if (atom X) (loop (let Y (car P) (cond ((== $T Y) (setq P (cadr ...
; # (atom X)
  %42 = and i64 %33, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$15, label %$16
$15:
  %44 = phi i64 [%33, %$10] ; # X
  %45 = phi i64 [%29, %$10] ; # P
; # (loop (let Y (car P) (cond ((== $T Y) (setq P (cadr P))) ((atom Y...
  br label %$18
$18:
  %46 = phi i64 [%44, %$15], [%105, %$30] ; # X
  %47 = phi i64 [%45, %$15], [%106, %$30] ; # P
; # (let Y (car P) (cond ((== $T Y) (setq P (cadr P))) ((atom Y) (set...
; # (car P)
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (cond ((== $T Y) (setq P (cadr P))) ((atom Y) (setq P (cddr P))) ...
; # (== $T Y)
  %50 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %49
  br i1 %50, label %$21, label %$20
$21:
  %51 = phi i64 [%46, %$18] ; # X
  %52 = phi i64 [%47, %$18] ; # P
; # (cadr P)
  %53 = inttoptr i64 %52 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
  br label %$19
$20:
  %58 = phi i64 [%46, %$18] ; # X
  %59 = phi i64 [%47, %$18] ; # P
; # (atom Y)
  %60 = and i64 %49, 15
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$23, label %$22
$23:
  %62 = phi i64 [%58, %$20] ; # X
  %63 = phi i64 [%59, %$20] ; # P
; # (cddr P)
  %64 = inttoptr i64 %63 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  %66 = load i64, i64* %65
  %67 = inttoptr i64 %66 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  br label %$19
$22:
  %70 = phi i64 [%58, %$20] ; # X
  %71 = phi i64 [%59, %$20] ; # P
; # (? (=0 (compare (car Y) Key)) (car P))
; # (car Y)
  %72 = inttoptr i64 %49 to i64*
  %73 = load i64, i64* %72
; # (compare (car Y) Key)
  %74 = call i64 @compare(i64 %73, i64 %41)
; # (=0 (compare (car Y) Key))
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$26, label %$24
$26:
  %76 = phi i64 [%70, %$22] ; # X
  %77 = phi i64 [%71, %$22] ; # P
; # (car P)
  %78 = inttoptr i64 %77 to i64*
  %79 = load i64, i64* %78
  br label %$25
$24:
  %80 = phi i64 [%70, %$22] ; # X
  %81 = phi i64 [%71, %$22] ; # P
; # (cdr P)
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (if (lt0 @) (cdr P) (car P))
; # (lt0 @)
  %85 = icmp slt i64 %74, 0
  br i1 %85, label %$27, label %$28
$27:
  %86 = phi i64 [%80, %$24] ; # X
  %87 = phi i64 [%84, %$24] ; # P
; # (cdr P)
  %88 = inttoptr i64 %87 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  br label %$29
$28:
  %91 = phi i64 [%80, %$24] ; # X
  %92 = phi i64 [%84, %$24] ; # P
; # (car P)
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
  br label %$29
$29:
  %95 = phi i64 [%86, %$27], [%91, %$28] ; # X
  %96 = phi i64 [%87, %$27], [%92, %$28] ; # P
  %97 = phi i64 [%90, %$27], [%94, %$28] ; # ->
  br label %$19
$19:
  %98 = phi i64 [%51, %$21], [%62, %$23], [%95, %$29] ; # X
  %99 = phi i64 [%57, %$21], [%69, %$23], [%97, %$29] ; # P
  %100 = phi i64 [%57, %$21], [%69, %$23], [%97, %$29] ; # ->
; # (? (atom P) $Nil)
; # (atom P)
  %101 = and i64 %99, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$31, label %$30
$31:
  %103 = phi i64 [%98, %$19] ; # X
  %104 = phi i64 [%99, %$19] ; # P
  br label %$25
$30:
  %105 = phi i64 [%98, %$19] ; # X
  %106 = phi i64 [%99, %$19] ; # P
  br label %$18
$25:
  %107 = phi i64 [%76, %$26], [%103, %$31] ; # X
  %108 = phi i64 [%77, %$26], [%104, %$31] ; # P
  %109 = phi i64 [%79, %$26], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$31] ; # ->
  br label %$17
$16:
  %110 = phi i64 [%33, %$10] ; # X
  %111 = phi i64 [%29, %$10] ; # P
; # (save Key)
  %112 = alloca i64, i64 2, align 16
  %113 = ptrtoint i64* %112 to i64
  %114 = inttoptr i64 %113 to i64*
  store i64 %41, i64* %114
  %115 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %116 = load i64, i64* %115
  %117 = inttoptr i64 %113 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  store i64 %116, i64* %118
  %119 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %113, i64* %119
; # (let (Key2 (save (eval (car X))) Q (link (push P NIL)) Tos (link ...
; # (car X)
  %120 = inttoptr i64 %110 to i64*
  %121 = load i64, i64* %120
; # (eval (car X))
  %122 = and i64 %121, 6
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$34, label %$33
$34:
  br label %$32
$33:
  %124 = and i64 %121, 8
  %125 = icmp ne i64 %124, 0
  br i1 %125, label %$36, label %$35
$36:
  %126 = inttoptr i64 %121 to i64*
  %127 = load i64, i64* %126
  br label %$32
$35:
  %128 = call i64 @evList(i64 %121)
  br label %$32
$32:
  %129 = phi i64 [%121, %$34], [%127, %$36], [%128, %$35] ; # ->
; # (save (eval (car X)))
  %130 = alloca i64, i64 2, align 16
  %131 = ptrtoint i64* %130 to i64
  %132 = inttoptr i64 %131 to i64*
  store i64 %129, i64* %132
  %133 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %134 = load i64, i64* %133
  %135 = inttoptr i64 %131 to i64*
  %136 = getelementptr i64, i64* %135, i32 1
  store i64 %134, i64* %136
  %137 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %131, i64* %137
; # (push P NIL)
  %138 = alloca i64, i64 2, align 16
  %139 = ptrtoint i64* %138 to i64
  %140 = inttoptr i64 %139 to i64*
  store i64 %111, i64* %140
; # (link (push P NIL))
  %141 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %142 = load i64, i64* %141
  %143 = inttoptr i64 %139 to i64*
  %144 = getelementptr i64, i64* %143, i32 1
  store i64 %142, i64* %144
  %145 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %139, i64* %145
; # (push -ZERO NIL)
  %146 = alloca i64, i64 2, align 16
  %147 = ptrtoint i64* %146 to i64
  %148 = inttoptr i64 %147 to i64*
  store i64 10, i64* %148
; # (link (push -ZERO NIL))
  %149 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %150 = load i64, i64* %149
  %151 = inttoptr i64 %147 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  store i64 %150, i64* %152
  %153 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %147, i64* %153
; # (loop (loop (let Y (cdr (setq X (cdr P))) (? (atom Y)) (let Z (ca...
  br label %$37
$37:
  %154 = phi i64 [%110, %$32], [%304, %$53] ; # X
  %155 = phi i64 [%111, %$32], [%305, %$53] ; # P
  %156 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$32], [%306, %$53] ; # R
; # (loop (let Y (cdr (setq X (cdr P))) (? (atom Y)) (let Z (car P) (...
  br label %$38
$38:
  %157 = phi i64 [%154, %$37], [%190, %$44] ; # X
  %158 = phi i64 [%155, %$37], [%165, %$44] ; # P
  %159 = phi i64 [%156, %$37], [%192, %$44] ; # R
; # (let Y (cdr (setq X (cdr P))) (? (atom Y)) (let Z (car P) (? (== ...
; # (cdr P)
  %160 = inttoptr i64 %158 to i64*
  %161 = getelementptr i64, i64* %160, i32 1
  %162 = load i64, i64* %161
; # (cdr (setq X (cdr P)))
  %163 = inttoptr i64 %162 to i64*
  %164 = getelementptr i64, i64* %163, i32 1
  %165 = load i64, i64* %164
; # (? (atom Y))
; # (atom Y)
  %166 = and i64 %165, 15
  %167 = icmp ne i64 %166, 0
  br i1 %167, label %$40, label %$39
$39:
  %168 = phi i64 [%162, %$38] ; # X
  %169 = phi i64 [%158, %$38] ; # P
  %170 = phi i64 [%159, %$38] ; # R
; # (let Z (car P) (? (== $T Z)) (? (and (pair Z) (gt0 (compare (car ...
; # (car P)
  %171 = inttoptr i64 %169 to i64*
  %172 = load i64, i64* %171
; # (? (== $T Z))
; # (== $T Z)
  %173 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %172
  br i1 %173, label %$40, label %$41
$41:
  %174 = phi i64 [%168, %$39] ; # X
  %175 = phi i64 [%169, %$39] ; # P
  %176 = phi i64 [%170, %$39] ; # R
; # (? (and (pair Z) (gt0 (compare (car Z) Key2))))
; # (and (pair Z) (gt0 (compare (car Z) Key2)))
; # (pair Z)
  %177 = and i64 %172, 15
  %178 = icmp eq i64 %177, 0
  br i1 %178, label %$43, label %$42
$43:
  %179 = phi i64 [%174, %$41] ; # X
  %180 = phi i64 [%175, %$41] ; # P
  %181 = phi i64 [%176, %$41] ; # R
; # (car Z)
  %182 = inttoptr i64 %172 to i64*
  %183 = load i64, i64* %182
; # (compare (car Z) Key2)
  %184 = call i64 @compare(i64 %183, i64 %129)
; # (gt0 (compare (car Z) Key2))
  %185 = icmp sgt i64 %184, 0
  br label %$42
$42:
  %186 = phi i64 [%174, %$41], [%179, %$43] ; # X
  %187 = phi i64 [%175, %$41], [%180, %$43] ; # P
  %188 = phi i64 [%176, %$41], [%181, %$43] ; # R
  %189 = phi i1 [0, %$41], [%185, %$43] ; # ->
  br i1 %189, label %$40, label %$44
$44:
  %190 = phi i64 [%186, %$42] ; # X
  %191 = phi i64 [%187, %$42] ; # P
  %192 = phi i64 [%188, %$42] ; # R
; # (let Z P (setq P Y) (set 2 X (val Tos)) (set Tos Z))
; # (set 2 X (val Tos))
; # (val Tos)
  %193 = inttoptr i64 %147 to i64*
  %194 = load i64, i64* %193
  %195 = inttoptr i64 %190 to i64*
  %196 = getelementptr i64, i64* %195, i32 1
  store i64 %194, i64* %196
; # (set Tos Z)
  %197 = inttoptr i64 %147 to i64*
  store i64 %191, i64* %197
  br label %$38
$40:
  %198 = phi i64 [%162, %$38], [%168, %$39], [%186, %$42] ; # X
  %199 = phi i64 [%158, %$38], [%169, %$39], [%187, %$42] ; # P
  %200 = phi i64 [%159, %$38], [%170, %$39], [%188, %$42] ; # R
  %201 = phi i64 [0, %$38], [0, %$39], [0, %$42] ; # ->
; # (set Q P)
  %202 = inttoptr i64 %139 to i64*
  store i64 %199, i64* %202
; # (loop (when (and (pair (setq X (car P))) (ge0 (compare (car X) Ke...
  br label %$45
$45:
  %203 = phi i64 [%198, %$40], [%300, %$59] ; # X
  %204 = phi i64 [%199, %$40], [%301, %$59] ; # P
  %205 = phi i64 [%200, %$40], [%302, %$59] ; # R
; # (when (and (pair (setq X (car P))) (ge0 (compare (car X) Key))) (...
; # (and (pair (setq X (car P))) (ge0 (compare (car X) Key)))
; # (car P)
  %206 = inttoptr i64 %204 to i64*
  %207 = load i64, i64* %206
; # (pair (setq X (car P)))
  %208 = and i64 %207, 15
  %209 = icmp eq i64 %208, 0
  br i1 %209, label %$47, label %$46
$47:
  %210 = phi i64 [%207, %$45] ; # X
  %211 = phi i64 [%204, %$45] ; # P
  %212 = phi i64 [%205, %$45] ; # R
; # (car X)
  %213 = inttoptr i64 %210 to i64*
  %214 = load i64, i64* %213
; # (compare (car X) Key)
  %215 = call i64 @compare(i64 %214, i64 %41)
; # (ge0 (compare (car X) Key))
  %216 = icmp sge i64 %215, 0
  br label %$46
$46:
  %217 = phi i64 [%207, %$45], [%210, %$47] ; # X
  %218 = phi i64 [%204, %$45], [%211, %$47] ; # P
  %219 = phi i64 [%205, %$45], [%212, %$47] ; # R
  %220 = phi i1 [0, %$45], [%216, %$47] ; # ->
  br i1 %220, label %$48, label %$49
$48:
  %221 = phi i64 [%217, %$46] ; # X
  %222 = phi i64 [%218, %$46] ; # P
  %223 = phi i64 [%219, %$46] ; # R
; # (when (le0 (compare (car X) Key2)) (setq R (cons X R)))
; # (car X)
  %224 = inttoptr i64 %221 to i64*
  %225 = load i64, i64* %224
; # (compare (car X) Key2)
  %226 = call i64 @compare(i64 %225, i64 %129)
; # (le0 (compare (car X) Key2))
  %227 = icmp sle i64 %226, 0
  br i1 %227, label %$50, label %$51
$50:
  %228 = phi i64 [%221, %$48] ; # X
  %229 = phi i64 [%222, %$48] ; # P
  %230 = phi i64 [%223, %$48] ; # R
; # (cons X R)
  %231 = call i64 @cons(i64 %228, i64 %230)
  br label %$51
$51:
  %232 = phi i64 [%221, %$48], [%228, %$50] ; # X
  %233 = phi i64 [%222, %$48], [%229, %$50] ; # P
  %234 = phi i64 [%223, %$48], [%231, %$50] ; # R
; # (? (pair (car (setq X (cdr P)))) (let Z P (setq P @) (set X (val ...
; # (cdr P)
  %235 = inttoptr i64 %233 to i64*
  %236 = getelementptr i64, i64* %235, i32 1
  %237 = load i64, i64* %236
; # (car (setq X (cdr P)))
  %238 = inttoptr i64 %237 to i64*
  %239 = load i64, i64* %238
; # (pair (car (setq X (cdr P))))
  %240 = and i64 %239, 15
  %241 = icmp eq i64 %240, 0
  br i1 %241, label %$54, label %$52
$54:
  %242 = phi i64 [%237, %$51] ; # X
  %243 = phi i64 [%233, %$51] ; # P
  %244 = phi i64 [%234, %$51] ; # R
; # (let Z P (setq P @) (set X (val Tos)) (set Tos (| Z 8)) (set Q P)...
; # (set X (val Tos))
; # (val Tos)
  %245 = inttoptr i64 %147 to i64*
  %246 = load i64, i64* %245
  %247 = inttoptr i64 %242 to i64*
  store i64 %246, i64* %247
; # (set Tos (| Z 8))
; # (| Z 8)
  %248 = or i64 %243, 8
  %249 = inttoptr i64 %147 to i64*
  store i64 %248, i64* %249
; # (set Q P)
  %250 = inttoptr i64 %139 to i64*
  store i64 %239, i64* %250
  br label %$53
$52:
  %251 = phi i64 [%237, %$51] ; # X
  %252 = phi i64 [%233, %$51] ; # P
  %253 = phi i64 [%234, %$51] ; # R
  br label %$49
$49:
  %254 = phi i64 [%217, %$46], [%251, %$52] ; # X
  %255 = phi i64 [%218, %$46], [%252, %$52] ; # P
  %256 = phi i64 [%219, %$46], [%253, %$52] ; # R
; # (loop (when (== -ZERO (setq X (val Tos))) (ret R)) (? (=0 (& X 8)...
  br label %$55
$55:
  %257 = phi i64 [%254, %$49], [%291, %$58] ; # X
  %258 = phi i64 [%255, %$49], [%291, %$58] ; # P
  %259 = phi i64 [%256, %$49], [%290, %$58] ; # R
; # (when (== -ZERO (setq X (val Tos))) (ret R))
; # (val Tos)
  %260 = inttoptr i64 %147 to i64*
  %261 = load i64, i64* %260
; # (== -ZERO (setq X (val Tos)))
  %262 = icmp eq i64 10, %261
  br i1 %262, label %$56, label %$57
$56:
  %263 = phi i64 [%261, %$55] ; # X
  %264 = phi i64 [%258, %$55] ; # P
  %265 = phi i64 [%259, %$55] ; # R
; # (ret R)
; # (drop *Safe)
  %266 = inttoptr i64 %17 to i64*
  %267 = getelementptr i64, i64* %266, i32 1
  %268 = load i64, i64* %267
  %269 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %268, i64* %269
  ret i64 %265
$57:
  %270 = phi i64 [%261, %$55] ; # X
  %271 = phi i64 [%258, %$55] ; # P
  %272 = phi i64 [%259, %$55] ; # R
; # (? (=0 (& X 8)) (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (set...
; # (& X 8)
  %273 = and i64 %270, 8
; # (=0 (& X 8))
  %274 = icmp eq i64 %273, 0
  br i1 %274, label %$60, label %$58
$60:
  %275 = phi i64 [%270, %$57] ; # X
  %276 = phi i64 [%271, %$57] ; # P
  %277 = phi i64 [%272, %$57] ; # R
; # (let Y (cdr X) (set Tos (cdr Y)) (set 2 Y P) (setq P X) (set Q P)...
; # (cdr X)
  %278 = inttoptr i64 %275 to i64*
  %279 = getelementptr i64, i64* %278, i32 1
  %280 = load i64, i64* %279
; # (set Tos (cdr Y))
; # (cdr Y)
  %281 = inttoptr i64 %280 to i64*
  %282 = getelementptr i64, i64* %281, i32 1
  %283 = load i64, i64* %282
  %284 = inttoptr i64 %147 to i64*
  store i64 %283, i64* %284
; # (set 2 Y P)
  %285 = inttoptr i64 %280 to i64*
  %286 = getelementptr i64, i64* %285, i32 1
  store i64 %276, i64* %286
; # (set Q P)
  %287 = inttoptr i64 %139 to i64*
  store i64 %275, i64* %287
  br label %$59
$58:
  %288 = phi i64 [%270, %$57] ; # X
  %289 = phi i64 [%271, %$57] ; # P
  %290 = phi i64 [%272, %$57] ; # R
; # (& X -9)
  %291 = and i64 %288, -9
; # (let Y (cdr X) (set Tos (car Y)) (set Y P) (setq P X) (set Q P))
; # (cdr X)
  %292 = inttoptr i64 %291 to i64*
  %293 = getelementptr i64, i64* %292, i32 1
  %294 = load i64, i64* %293
; # (set Tos (car Y))
; # (car Y)
  %295 = inttoptr i64 %294 to i64*
  %296 = load i64, i64* %295
  %297 = inttoptr i64 %147 to i64*
  store i64 %296, i64* %297
; # (set Y P)
  %298 = inttoptr i64 %294 to i64*
  store i64 %289, i64* %298
; # (set Q P)
  %299 = inttoptr i64 %139 to i64*
  store i64 %291, i64* %299
  br label %$55
$59:
  %300 = phi i64 [%275, %$60] ; # X
  %301 = phi i64 [%275, %$60] ; # P
  %302 = phi i64 [%277, %$60] ; # R
  %303 = phi i64 [%275, %$60] ; # ->
  br label %$45
$53:
  %304 = phi i64 [%242, %$54] ; # X
  %305 = phi i64 [%239, %$54] ; # P
  %306 = phi i64 [%244, %$54] ; # R
  %307 = phi i64 [%239, %$54] ; # ->
  br label %$37
$17:
  %308 = phi i64 [%107, %$25] ; # X
  %309 = phi i64 [%108, %$25] ; # P
  %310 = phi i64 [%109, %$25] ; # ->
  br label %$9
$9:
  %311 = phi i64 [%26, %$7], [%308, %$17] ; # X
  %312 = phi i64 [%27, %$7], [%309, %$17] ; # P
  %313 = phi i64 [%27, %$7], [%310, %$17] ; # ->
; # (drop *Safe)
  %314 = inttoptr i64 %17 to i64*
  %315 = getelementptr i64, i64* %314, i32 1
  %316 = load i64, i64* %315
  %317 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %316, i64* %317
  ret i64 %313
}

define void @put(i64, i64, i64) {
$1:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (let (L (any (& Ta...
; # (tail Sym)
  %3 = add i64 %0, -8
; # (val (tail Sym))
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (unless (num? Tail) (let (L (any (& Tail -9)) X (car L)) (if (ato...
; # (num? Tail)
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$3, label %$2
$2:
  %8 = phi i64 [%2, %$1] ; # Val
; # (let (L (any (& Tail -9)) X (car L)) (if (atom X) (when (== Key X...
; # (& Tail -9)
  %9 = and i64 %5, -9
; # (any (& Tail -9))
; # (car L)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
; # (if (atom X) (when (== Key X) (cond ((nil? Val) (shift L) (set (t...
; # (atom X)
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$4, label %$5
$4:
  %14 = phi i64 [%8, %$2] ; # Val
  %15 = phi i64 [%9, %$2] ; # L
  %16 = phi i64 [%11, %$2] ; # X
; # (when (== Key X) (cond ((nil? Val) (shift L) (set (tail Sym) (if ...
; # (== Key X)
  %17 = icmp eq i64 %1, %16
  br i1 %17, label %$7, label %$8
$7:
  %18 = phi i64 [%14, %$4] ; # Val
  %19 = phi i64 [%15, %$4] ; # L
  %20 = phi i64 [%16, %$4] ; # X
; # (cond ((nil? Val) (shift L) (set (tail Sym) (if (sym? Tail) (sym ...
; # (nil? Val)
  %21 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$11, label %$10
$11:
  %22 = phi i64 [%18, %$7] ; # Val
  %23 = phi i64 [%19, %$7] ; # L
  %24 = phi i64 [%20, %$7] ; # X
; # (shift L)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (set (tail Sym) (if (sym? Tail) (sym L) L))
; # (tail Sym)
  %28 = add i64 %0, -8
; # (if (sym? Tail) (sym L) L)
; # (sym? Tail)
  %29 = and i64 %5, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$12, label %$13
$12:
  %31 = phi i64 [%22, %$11] ; # Val
  %32 = phi i64 [%27, %$11] ; # L
  %33 = phi i64 [%24, %$11] ; # X
; # (sym L)
  %34 = or i64 %32, 8
  br label %$14
$13:
  %35 = phi i64 [%22, %$11] ; # Val
  %36 = phi i64 [%27, %$11] ; # L
  %37 = phi i64 [%24, %$11] ; # X
  br label %$14
$14:
  %38 = phi i64 [%31, %$12], [%35, %$13] ; # Val
  %39 = phi i64 [%32, %$12], [%36, %$13] ; # L
  %40 = phi i64 [%33, %$12], [%37, %$13] ; # X
  %41 = phi i64 [%34, %$12], [%36, %$13] ; # ->
  %42 = inttoptr i64 %28 to i64*
  store i64 %41, i64* %42
  br label %$9
$10:
  %43 = phi i64 [%18, %$7] ; # Val
  %44 = phi i64 [%19, %$7] ; # L
  %45 = phi i64 [%20, %$7] ; # X
; # (<> Val $T)
  %46 = icmp ne i64 %43, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %46, label %$16, label %$15
$16:
  %47 = phi i64 [%43, %$10] ; # Val
  %48 = phi i64 [%44, %$10] ; # L
  %49 = phi i64 [%45, %$10] ; # X
; # (set L (cons Val Key))
; # (cons Val Key)
  %50 = call i64 @cons(i64 %47, i64 %1)
  %51 = inttoptr i64 %48 to i64*
  store i64 %50, i64* %51
  br label %$9
$15:
  %52 = phi i64 [%43, %$10] ; # Val
  %53 = phi i64 [%44, %$10] ; # L
  %54 = phi i64 [%45, %$10] ; # X
  br label %$9
$9:
  %55 = phi i64 [%38, %$14], [%47, %$16], [%52, %$15] ; # Val
  %56 = phi i64 [%39, %$14], [%48, %$16], [%53, %$15] ; # L
  %57 = phi i64 [%40, %$14], [%49, %$16], [%54, %$15] ; # X
  %58 = phi i64 [%41, %$14], [%50, %$16], [0, %$15] ; # ->
; # (ret)
  ret void
$8:
  %59 = phi i64 [%14, %$4] ; # Val
  %60 = phi i64 [%15, %$4] ; # L
  %61 = phi i64 [%16, %$4] ; # X
  br label %$6
$5:
  %62 = phi i64 [%8, %$2] ; # Val
  %63 = phi i64 [%9, %$2] ; # L
  %64 = phi i64 [%11, %$2] ; # X
; # (when (== Key (cdr X)) (cond ((nil? Val) (shift L) (set (tail Sym...
; # (cdr X)
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (== Key (cdr X))
  %68 = icmp eq i64 %1, %67
  br i1 %68, label %$17, label %$18
$17:
  %69 = phi i64 [%62, %$5] ; # Val
  %70 = phi i64 [%63, %$5] ; # L
  %71 = phi i64 [%64, %$5] ; # X
; # (cond ((nil? Val) (shift L) (set (tail Sym) (if (sym? Tail) (sym ...
; # (nil? Val)
  %72 = icmp eq i64 %69, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %72, label %$21, label %$20
$21:
  %73 = phi i64 [%69, %$17] ; # Val
  %74 = phi i64 [%70, %$17] ; # L
  %75 = phi i64 [%71, %$17] ; # X
; # (shift L)
  %76 = inttoptr i64 %74 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (set (tail Sym) (if (sym? Tail) (sym L) L))
; # (tail Sym)
  %79 = add i64 %0, -8
; # (if (sym? Tail) (sym L) L)
; # (sym? Tail)
  %80 = and i64 %5, 8
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$22, label %$23
$22:
  %82 = phi i64 [%73, %$21] ; # Val
  %83 = phi i64 [%78, %$21] ; # L
  %84 = phi i64 [%75, %$21] ; # X
; # (sym L)
  %85 = or i64 %83, 8
  br label %$24
$23:
  %86 = phi i64 [%73, %$21] ; # Val
  %87 = phi i64 [%78, %$21] ; # L
  %88 = phi i64 [%75, %$21] ; # X
  br label %$24
$24:
  %89 = phi i64 [%82, %$22], [%86, %$23] ; # Val
  %90 = phi i64 [%83, %$22], [%87, %$23] ; # L
  %91 = phi i64 [%84, %$22], [%88, %$23] ; # X
  %92 = phi i64 [%85, %$22], [%87, %$23] ; # ->
  %93 = inttoptr i64 %79 to i64*
  store i64 %92, i64* %93
  br label %$19
$20:
  %94 = phi i64 [%69, %$17] ; # Val
  %95 = phi i64 [%70, %$17] ; # L
  %96 = phi i64 [%71, %$17] ; # X
; # (t? Val)
  %97 = icmp eq i64 %94, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %97, label %$26, label %$25
$26:
  %98 = phi i64 [%94, %$20] ; # Val
  %99 = phi i64 [%95, %$20] ; # L
  %100 = phi i64 [%96, %$20] ; # X
; # (set L Key)
  %101 = inttoptr i64 %99 to i64*
  store i64 %1, i64* %101
  br label %$19
$25:
  %102 = phi i64 [%94, %$20] ; # Val
  %103 = phi i64 [%95, %$20] ; # L
  %104 = phi i64 [%96, %$20] ; # X
; # (set X Val)
  %105 = inttoptr i64 %104 to i64*
  store i64 %102, i64* %105
  br label %$19
$19:
  %106 = phi i64 [%89, %$24], [%98, %$26], [%102, %$25] ; # Val
  %107 = phi i64 [%90, %$24], [%99, %$26], [%103, %$25] ; # L
  %108 = phi i64 [%91, %$24], [%100, %$26], [%104, %$25] ; # X
  %109 = phi i64 [%92, %$24], [%1, %$26], [%102, %$25] ; # ->
; # (ret)
  ret void
$18:
  %110 = phi i64 [%62, %$5] ; # Val
  %111 = phi i64 [%63, %$5] ; # L
  %112 = phi i64 [%64, %$5] ; # X
  br label %$6
$6:
  %113 = phi i64 [%59, %$8], [%110, %$18] ; # Val
  %114 = phi i64 [%60, %$8], [%111, %$18] ; # L
  %115 = phi i64 [%61, %$8], [%112, %$18] ; # X
; # (while (pair (setq X (cdr L))) (let Y (car X) (if (atom Y) (when ...
  br label %$27
$27:
  %116 = phi i64 [%113, %$6], [%258, %$32] ; # Val
  %117 = phi i64 [%114, %$6], [%260, %$32] ; # L
  %118 = phi i64 [%115, %$6], [%260, %$32] ; # X
; # (cdr L)
  %119 = inttoptr i64 %117 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
; # (pair (setq X (cdr L)))
  %122 = and i64 %121, 15
  %123 = icmp eq i64 %122, 0
  br i1 %123, label %$28, label %$29
$28:
  %124 = phi i64 [%116, %$27] ; # Val
  %125 = phi i64 [%117, %$27] ; # L
  %126 = phi i64 [%121, %$27] ; # X
; # (let Y (car X) (if (atom Y) (when (== Key Y) (if (nil? Val) (set ...
; # (car X)
  %127 = inttoptr i64 %126 to i64*
  %128 = load i64, i64* %127
; # (if (atom Y) (when (== Key Y) (if (nil? Val) (set 2 L (cdr X)) (u...
; # (atom Y)
  %129 = and i64 %128, 15
  %130 = icmp ne i64 %129, 0
  br i1 %130, label %$30, label %$31
$30:
  %131 = phi i64 [%124, %$28] ; # Val
  %132 = phi i64 [%125, %$28] ; # L
  %133 = phi i64 [%126, %$28] ; # X
; # (when (== Key Y) (if (nil? Val) (set 2 L (cdr X)) (unless (== $T ...
; # (== Key Y)
  %134 = icmp eq i64 %1, %128
  br i1 %134, label %$33, label %$34
$33:
  %135 = phi i64 [%131, %$30] ; # Val
  %136 = phi i64 [%132, %$30] ; # L
  %137 = phi i64 [%133, %$30] ; # X
; # (if (nil? Val) (set 2 L (cdr X)) (unless (== $T Val) (set X (cons...
; # (nil? Val)
  %138 = icmp eq i64 %135, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %138, label %$35, label %$36
$35:
  %139 = phi i64 [%135, %$33] ; # Val
  %140 = phi i64 [%136, %$33] ; # L
  %141 = phi i64 [%137, %$33] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %142 = inttoptr i64 %141 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  %144 = load i64, i64* %143
  %145 = inttoptr i64 %140 to i64*
  %146 = getelementptr i64, i64* %145, i32 1
  store i64 %144, i64* %146
  br label %$37
$36:
  %147 = phi i64 [%135, %$33] ; # Val
  %148 = phi i64 [%136, %$33] ; # L
  %149 = phi i64 [%137, %$33] ; # X
; # (unless (== $T Val) (set X (cons Val Key)))
; # (== $T Val)
  %150 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %147
  br i1 %150, label %$39, label %$38
$38:
  %151 = phi i64 [%147, %$36] ; # Val
  %152 = phi i64 [%148, %$36] ; # L
  %153 = phi i64 [%149, %$36] ; # X
; # (set X (cons Val Key))
; # (cons Val Key)
  %154 = call i64 @cons(i64 %151, i64 %1)
  %155 = inttoptr i64 %153 to i64*
  store i64 %154, i64* %155
  br label %$39
$39:
  %156 = phi i64 [%147, %$36], [%151, %$38] ; # Val
  %157 = phi i64 [%148, %$36], [%152, %$38] ; # L
  %158 = phi i64 [%149, %$36], [%153, %$38] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %159 = inttoptr i64 %158 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  %161 = load i64, i64* %160
  %162 = inttoptr i64 %157 to i64*
  %163 = getelementptr i64, i64* %162, i32 1
  store i64 %161, i64* %163
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %164 = and i64 %5, 8
  %165 = icmp ne i64 %164, 0
  br i1 %165, label %$41, label %$40
$40:
  %166 = phi i64 [%156, %$39] ; # Val
  %167 = phi i64 [%157, %$39] ; # L
  %168 = phi i64 [%158, %$39] ; # X
; # (set 2 X Tail)
  %169 = inttoptr i64 %168 to i64*
  %170 = getelementptr i64, i64* %169, i32 1
  store i64 %5, i64* %170
  br label %$42
$41:
  %171 = phi i64 [%156, %$39] ; # Val
  %172 = phi i64 [%157, %$39] ; # L
  %173 = phi i64 [%158, %$39] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %174 = and i64 %5, -9
  %175 = inttoptr i64 %173 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  store i64 %174, i64* %176
; # (sym X)
  %177 = or i64 %173, 8
  br label %$42
$42:
  %178 = phi i64 [%166, %$40], [%171, %$41] ; # Val
  %179 = phi i64 [%167, %$40], [%172, %$41] ; # L
  %180 = phi i64 [%168, %$40], [%177, %$41] ; # X
  %181 = phi i64 [%5, %$40], [%177, %$41] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %182 = add i64 %0, -8
  %183 = inttoptr i64 %182 to i64*
  store i64 %180, i64* %183
  br label %$37
$37:
  %184 = phi i64 [%139, %$35], [%178, %$42] ; # Val
  %185 = phi i64 [%140, %$35], [%179, %$42] ; # L
  %186 = phi i64 [%141, %$35], [%180, %$42] ; # X
  %187 = phi i64 [%144, %$35], [%180, %$42] ; # ->
; # (ret)
  ret void
$34:
  %188 = phi i64 [%131, %$30] ; # Val
  %189 = phi i64 [%132, %$30] ; # L
  %190 = phi i64 [%133, %$30] ; # X
  br label %$32
$31:
  %191 = phi i64 [%124, %$28] ; # Val
  %192 = phi i64 [%125, %$28] ; # L
  %193 = phi i64 [%126, %$28] ; # X
; # (when (== Key (cdr Y)) (if (nil? Val) (set 2 L (cdr X)) (if (== $...
; # (cdr Y)
  %194 = inttoptr i64 %128 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
; # (== Key (cdr Y))
  %197 = icmp eq i64 %1, %196
  br i1 %197, label %$43, label %$44
$43:
  %198 = phi i64 [%191, %$31] ; # Val
  %199 = phi i64 [%192, %$31] ; # L
  %200 = phi i64 [%193, %$31] ; # X
; # (if (nil? Val) (set 2 L (cdr X)) (if (== $T Val) (set X Key) (set...
; # (nil? Val)
  %201 = icmp eq i64 %198, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %201, label %$45, label %$46
$45:
  %202 = phi i64 [%198, %$43] ; # Val
  %203 = phi i64 [%199, %$43] ; # L
  %204 = phi i64 [%200, %$43] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %205 = inttoptr i64 %204 to i64*
  %206 = getelementptr i64, i64* %205, i32 1
  %207 = load i64, i64* %206
  %208 = inttoptr i64 %203 to i64*
  %209 = getelementptr i64, i64* %208, i32 1
  store i64 %207, i64* %209
  br label %$47
$46:
  %210 = phi i64 [%198, %$43] ; # Val
  %211 = phi i64 [%199, %$43] ; # L
  %212 = phi i64 [%200, %$43] ; # X
; # (if (== $T Val) (set X Key) (set Y Val))
; # (== $T Val)
  %213 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %210
  br i1 %213, label %$48, label %$49
$48:
  %214 = phi i64 [%210, %$46] ; # Val
  %215 = phi i64 [%211, %$46] ; # L
  %216 = phi i64 [%212, %$46] ; # X
; # (set X Key)
  %217 = inttoptr i64 %216 to i64*
  store i64 %1, i64* %217
  br label %$50
$49:
  %218 = phi i64 [%210, %$46] ; # Val
  %219 = phi i64 [%211, %$46] ; # L
  %220 = phi i64 [%212, %$46] ; # X
; # (set Y Val)
  %221 = inttoptr i64 %128 to i64*
  store i64 %218, i64* %221
  br label %$50
$50:
  %222 = phi i64 [%214, %$48], [%218, %$49] ; # Val
  %223 = phi i64 [%215, %$48], [%219, %$49] ; # L
  %224 = phi i64 [%216, %$48], [%220, %$49] ; # X
  %225 = phi i64 [%1, %$48], [%218, %$49] ; # ->
; # (set 2 L (cdr X))
; # (cdr X)
  %226 = inttoptr i64 %224 to i64*
  %227 = getelementptr i64, i64* %226, i32 1
  %228 = load i64, i64* %227
  %229 = inttoptr i64 %223 to i64*
  %230 = getelementptr i64, i64* %229, i32 1
  store i64 %228, i64* %230
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %231 = and i64 %5, 8
  %232 = icmp ne i64 %231, 0
  br i1 %232, label %$52, label %$51
$51:
  %233 = phi i64 [%222, %$50] ; # Val
  %234 = phi i64 [%223, %$50] ; # L
  %235 = phi i64 [%224, %$50] ; # X
; # (set 2 X Tail)
  %236 = inttoptr i64 %235 to i64*
  %237 = getelementptr i64, i64* %236, i32 1
  store i64 %5, i64* %237
  br label %$53
$52:
  %238 = phi i64 [%222, %$50] ; # Val
  %239 = phi i64 [%223, %$50] ; # L
  %240 = phi i64 [%224, %$50] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %241 = and i64 %5, -9
  %242 = inttoptr i64 %240 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  store i64 %241, i64* %243
; # (sym X)
  %244 = or i64 %240, 8
  br label %$53
$53:
  %245 = phi i64 [%233, %$51], [%238, %$52] ; # Val
  %246 = phi i64 [%234, %$51], [%239, %$52] ; # L
  %247 = phi i64 [%235, %$51], [%244, %$52] ; # X
  %248 = phi i64 [%5, %$51], [%244, %$52] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %249 = add i64 %0, -8
  %250 = inttoptr i64 %249 to i64*
  store i64 %247, i64* %250
  br label %$47
$47:
  %251 = phi i64 [%202, %$45], [%245, %$53] ; # Val
  %252 = phi i64 [%203, %$45], [%246, %$53] ; # L
  %253 = phi i64 [%204, %$45], [%247, %$53] ; # X
  %254 = phi i64 [%207, %$45], [%247, %$53] ; # ->
; # (ret)
  ret void
$44:
  %255 = phi i64 [%191, %$31] ; # Val
  %256 = phi i64 [%192, %$31] ; # L
  %257 = phi i64 [%193, %$31] ; # X
  br label %$32
$32:
  %258 = phi i64 [%188, %$34], [%255, %$44] ; # Val
  %259 = phi i64 [%189, %$34], [%256, %$44] ; # L
  %260 = phi i64 [%190, %$34], [%257, %$44] ; # X
  br label %$27
$29:
  %261 = phi i64 [%116, %$27] ; # Val
  %262 = phi i64 [%117, %$27] ; # L
  %263 = phi i64 [%121, %$27] ; # X
  br label %$3
$3:
  %264 = phi i64 [%2, %$1], [%261, %$29] ; # Val
; # (unless (nil? Val) (setq Val (if (== $T Val) Key (cons Val Key)))...
; # (nil? Val)
  %265 = icmp eq i64 %264, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %265, label %$55, label %$54
$54:
  %266 = phi i64 [%264, %$3] ; # Val
; # (if (== $T Val) Key (cons Val Key))
; # (== $T Val)
  %267 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %266
  br i1 %267, label %$56, label %$57
$56:
  %268 = phi i64 [%266, %$54] ; # Val
  br label %$58
$57:
  %269 = phi i64 [%266, %$54] ; # Val
; # (cons Val Key)
  %270 = call i64 @cons(i64 %269, i64 %1)
  br label %$58
$58:
  %271 = phi i64 [%268, %$56], [%269, %$57] ; # Val
  %272 = phi i64 [%1, %$56], [%270, %$57] ; # ->
; # (set (tail Sym) (if (sym? Tail) (sym (cons Val (& Tail -9))) (con...
; # (tail Sym)
  %273 = add i64 %0, -8
; # (if (sym? Tail) (sym (cons Val (& Tail -9))) (cons Val Tail))
; # (sym? Tail)
  %274 = and i64 %5, 8
  %275 = icmp ne i64 %274, 0
  br i1 %275, label %$59, label %$60
$59:
  %276 = phi i64 [%272, %$58] ; # Val
; # (& Tail -9)
  %277 = and i64 %5, -9
; # (cons Val (& Tail -9))
  %278 = call i64 @cons(i64 %276, i64 %277)
; # (sym (cons Val (& Tail -9)))
  %279 = or i64 %278, 8
  br label %$61
$60:
  %280 = phi i64 [%272, %$58] ; # Val
; # (cons Val Tail)
  %281 = call i64 @cons(i64 %280, i64 %5)
  br label %$61
$61:
  %282 = phi i64 [%276, %$59], [%280, %$60] ; # Val
  %283 = phi i64 [%279, %$59], [%281, %$60] ; # ->
  %284 = inttoptr i64 %273 to i64*
  store i64 %283, i64* %284
  br label %$55
$55:
  %285 = phi i64 [%264, %$3], [%282, %$61] ; # Val
  ret void
}

define void @putn(i64, i64, i64, i64) {
$1:
; # (nond ((num? Key) (loop (let X (car Lst) (? (and (pair X) (== Key...
; # (num? Key)
  %4 = and i64 %2, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$3, label %$4
$4:
  %6 = phi i64 [%1, %$1] ; # Lst
; # (loop (let X (car Lst) (? (and (pair X) (== Key (car X))) (set 2 ...
  br label %$5
$5:
  %7 = phi i64 [%6, %$4], [%28, %$12] ; # Lst
; # (let X (car Lst) (? (and (pair X) (== Key (car X))) (set 2 X Val)...
; # (car Lst)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (? (and (pair X) (== Key (car X))) (set 2 X Val))
; # (and (pair X) (== Key (car X)))
; # (pair X)
  %10 = and i64 %9, 15
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$7, label %$6
$7:
  %12 = phi i64 [%7, %$5] ; # Lst
; # (car X)
  %13 = inttoptr i64 %9 to i64*
  %14 = load i64, i64* %13
; # (== Key (car X))
  %15 = icmp eq i64 %2, %14
  br label %$6
$6:
  %16 = phi i64 [%7, %$5], [%12, %$7] ; # Lst
  %17 = phi i1 [0, %$5], [%15, %$7] ; # ->
  br i1 %17, label %$10, label %$8
$10:
  %18 = phi i64 [%16, %$6] ; # Lst
; # (set 2 X Val)
  %19 = inttoptr i64 %9 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %3, i64* %20
  br label %$9
$8:
  %21 = phi i64 [%16, %$6] ; # Lst
; # (when (atom (shift Lst)) (itemErr Exe Key))
; # (shift Lst)
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (atom (shift Lst))
  %25 = and i64 %24, 15
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$11, label %$12
$11:
  %27 = phi i64 [%24, %$8] ; # Lst
; # (itemErr Exe Key)
  call void @itemErr(i64 %0, i64 %2)
  unreachable
$12:
  %28 = phi i64 [%24, %$8] ; # Lst
  br label %$5
$9:
  %29 = phi i64 [%18, %$10] ; # Lst
  %30 = phi i64 [%3, %$10] ; # ->
  br label %$2
$3:
  %31 = phi i64 [%1, %$1] ; # Lst
; # (== ZERO Key)
  %32 = icmp eq i64 2, %2
  br i1 %32, label %$13, label %$14
$14:
  %33 = phi i64 [%31, %$3] ; # Lst
; # (let Cnt (int Key) (while (dec 'Cnt) (when (atom (shift Lst)) (it...
; # (int Key)
  %34 = lshr i64 %2, 4
; # (while (dec 'Cnt) (when (atom (shift Lst)) (itemErr Exe Key)))
  br label %$15
$15:
  %35 = phi i64 [%33, %$14], [%48, %$19] ; # Lst
  %36 = phi i64 [%34, %$14], [%49, %$19] ; # Cnt
; # (dec 'Cnt)
  %37 = sub i64 %36, 1
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%35, %$15] ; # Lst
  %40 = phi i64 [%37, %$15] ; # Cnt
; # (when (atom (shift Lst)) (itemErr Exe Key))
; # (shift Lst)
  %41 = inttoptr i64 %39 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (atom (shift Lst))
  %44 = and i64 %43, 15
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$18, label %$19
$18:
  %46 = phi i64 [%43, %$16] ; # Lst
  %47 = phi i64 [%40, %$16] ; # Cnt
; # (itemErr Exe Key)
  call void @itemErr(i64 %0, i64 %2)
  unreachable
$19:
  %48 = phi i64 [%43, %$16] ; # Lst
  %49 = phi i64 [%40, %$16] ; # Cnt
  br label %$15
$17:
  %50 = phi i64 [%35, %$15] ; # Lst
  %51 = phi i64 [%37, %$15] ; # Cnt
; # (if (sign? Key) (set 2 Lst Val) (set Lst Val))
; # (sign? Key)
  %52 = and i64 %2, 8
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$20, label %$21
$20:
  %54 = phi i64 [%50, %$17] ; # Lst
; # (set 2 Lst Val)
  %55 = inttoptr i64 %54 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  store i64 %3, i64* %56
  br label %$22
$21:
  %57 = phi i64 [%50, %$17] ; # Lst
; # (set Lst Val)
  %58 = inttoptr i64 %57 to i64*
  store i64 %3, i64* %58
  br label %$22
$22:
  %59 = phi i64 [%54, %$20], [%57, %$21] ; # Lst
  %60 = phi i64 [%3, %$20], [%3, %$21] ; # ->
  br label %$2
$13:
  %61 = phi i64 [%31, %$3] ; # Lst
; # (argErr Exe Key)
  call void @argErr(i64 %0, i64 %2)
  unreachable
$2:
  %62 = phi i64 [%29, %$9], [%59, %$22] ; # Lst
  %63 = phi i64 [%30, %$9], [%60, %$22] ; # ->
  ret void
}

define i64 @get(i64, i64) {
$1:
; # (if (== Key ZERO) (val Sym) (let Tail (val (tail Sym)) (unless (n...
; # (== Key ZERO)
  %2 = icmp eq i64 %1, 2
  br i1 %2, label %$2, label %$3
$2:
; # (val Sym)
  %3 = inttoptr i64 %0 to i64*
  %4 = load i64, i64* %3
  br label %$4
$3:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (let (L (any (& Ta...
; # (tail Sym)
  %5 = add i64 %0, -8
; # (val (tail Sym))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (unless (num? Tail) (let (L (any (& Tail -9)) X (car L)) (if (ato...
; # (num? Tail)
  %8 = and i64 %7, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$5:
; # (let (L (any (& Tail -9)) X (car L)) (if (atom X) (when (== Key X...
; # (& Tail -9)
  %10 = and i64 %7, -9
; # (any (& Tail -9))
; # (car L)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (if (atom X) (when (== Key X) (ret $T)) (when (== Key (cdr X)) (r...
; # (atom X)
  %13 = and i64 %12, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%10, %$5] ; # L
  %16 = phi i64 [%12, %$5] ; # X
; # (when (== Key X) (ret $T))
; # (== Key X)
  %17 = icmp eq i64 %1, %16
  br i1 %17, label %$10, label %$11
$10:
  %18 = phi i64 [%15, %$7] ; # L
  %19 = phi i64 [%16, %$7] ; # X
; # (ret $T)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
$11:
  %20 = phi i64 [%15, %$7] ; # L
  %21 = phi i64 [%16, %$7] ; # X
  br label %$9
$8:
  %22 = phi i64 [%10, %$5] ; # L
  %23 = phi i64 [%12, %$5] ; # X
; # (when (== Key (cdr X)) (ret (car X)))
; # (cdr X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (== Key (cdr X))
  %27 = icmp eq i64 %1, %26
  br i1 %27, label %$12, label %$13
$12:
  %28 = phi i64 [%22, %$8] ; # L
  %29 = phi i64 [%23, %$8] ; # X
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (ret (car X))
  ret i64 %31
$13:
  %32 = phi i64 [%22, %$8] ; # L
  %33 = phi i64 [%23, %$8] ; # X
  br label %$9
$9:
  %34 = phi i64 [%20, %$11], [%32, %$13] ; # L
  %35 = phi i64 [%21, %$11], [%33, %$13] ; # X
; # (while (pair (setq X (cdr L))) (let Y (car X) (if (atom Y) (when ...
  br label %$14
$14:
  %36 = phi i64 [%34, %$9], [%113, %$19] ; # L
  %37 = phi i64 [%35, %$9], [%113, %$19] ; # X
; # (cdr L)
  %38 = inttoptr i64 %36 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (pair (setq X (cdr L)))
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%36, %$14] ; # L
  %44 = phi i64 [%40, %$14] ; # X
; # (let Y (car X) (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (i...
; # (car X)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) ...
; # (atom Y)
  %47 = and i64 %46, 15
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$17, label %$18
$17:
  %49 = phi i64 [%43, %$15] ; # L
  %50 = phi i64 [%44, %$15] ; # X
; # (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 X Tail...
; # (== Key Y)
  %51 = icmp eq i64 %1, %46
  br i1 %51, label %$20, label %$21
$20:
  %52 = phi i64 [%49, %$17] ; # L
  %53 = phi i64 [%50, %$17] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %54 = inttoptr i64 %53 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %52 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %59 = and i64 %7, 8
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$23, label %$22
$22:
  %61 = phi i64 [%52, %$20] ; # L
  %62 = phi i64 [%53, %$20] ; # X
; # (set 2 X Tail)
  %63 = inttoptr i64 %62 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  store i64 %7, i64* %64
  br label %$24
$23:
  %65 = phi i64 [%52, %$20] ; # L
  %66 = phi i64 [%53, %$20] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %67 = and i64 %7, -9
  %68 = inttoptr i64 %66 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %67, i64* %69
; # (sym X)
  %70 = or i64 %66, 8
  br label %$24
$24:
  %71 = phi i64 [%61, %$22], [%65, %$23] ; # L
  %72 = phi i64 [%62, %$22], [%70, %$23] ; # X
  %73 = phi i64 [%7, %$22], [%70, %$23] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %74 = add i64 %0, -8
  %75 = inttoptr i64 %74 to i64*
  store i64 %72, i64* %75
; # (ret $T)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
$21:
  %76 = phi i64 [%49, %$17] ; # L
  %77 = phi i64 [%50, %$17] ; # X
  br label %$19
$18:
  %78 = phi i64 [%43, %$15] ; # L
  %79 = phi i64 [%44, %$15] ; # X
; # (when (== Key (cdr Y)) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 ...
; # (cdr Y)
  %80 = inttoptr i64 %46 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
; # (== Key (cdr Y))
  %83 = icmp eq i64 %1, %82
  br i1 %83, label %$25, label %$26
$25:
  %84 = phi i64 [%78, %$18] ; # L
  %85 = phi i64 [%79, %$18] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
  %89 = inttoptr i64 %84 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %88, i64* %90
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %91 = and i64 %7, 8
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$28, label %$27
$27:
  %93 = phi i64 [%84, %$25] ; # L
  %94 = phi i64 [%85, %$25] ; # X
; # (set 2 X Tail)
  %95 = inttoptr i64 %94 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %7, i64* %96
  br label %$29
$28:
  %97 = phi i64 [%84, %$25] ; # L
  %98 = phi i64 [%85, %$25] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %99 = and i64 %7, -9
  %100 = inttoptr i64 %98 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  store i64 %99, i64* %101
; # (sym X)
  %102 = or i64 %98, 8
  br label %$29
$29:
  %103 = phi i64 [%93, %$27], [%97, %$28] ; # L
  %104 = phi i64 [%94, %$27], [%102, %$28] ; # X
  %105 = phi i64 [%7, %$27], [%102, %$28] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %106 = add i64 %0, -8
  %107 = inttoptr i64 %106 to i64*
  store i64 %104, i64* %107
; # (car Y)
  %108 = inttoptr i64 %46 to i64*
  %109 = load i64, i64* %108
; # (ret (car Y))
  ret i64 %109
$26:
  %110 = phi i64 [%78, %$18] ; # L
  %111 = phi i64 [%79, %$18] ; # X
  br label %$19
$19:
  %112 = phi i64 [%76, %$21], [%110, %$26] ; # L
  %113 = phi i64 [%77, %$21], [%111, %$26] ; # X
  br label %$14
$16:
  %114 = phi i64 [%36, %$14] ; # L
  %115 = phi i64 [%40, %$14] ; # X
  br label %$6
$6:
  br label %$4
$4:
  %116 = phi i64 [%4, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$6] ; # ->
  ret i64 %116
}

define i64 @getn(i64, i64, i64) {
$1:
; # (when (num? X) (argErr Exe X))
; # (num? X)
  %3 = and i64 %1, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%1, %$1] ; # X
; # (argErr Exe X)
  call void @argErr(i64 %0, i64 %5)
  unreachable
$3:
  %6 = phi i64 [%1, %$1] ; # X
; # (if (pair X) (nond ((num? Key) (loop (let Y (car X) (? (and (pair...
; # (pair X)
  %7 = and i64 %6, 15
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %$4, label %$5
$4:
  %9 = phi i64 [%6, %$3] ; # X
; # (nond ((num? Key) (loop (let Y (car X) (? (and (pair Y) (== Key (...
; # (num? Key)
  %10 = and i64 %2, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$8, label %$9
$9:
  %12 = phi i64 [%9, %$4] ; # X
; # (loop (let Y (car X) (? (and (pair Y) (== Key (car Y))) (cdr Y)))...
  br label %$10
$10:
  %13 = phi i64 [%12, %$9], [%35, %$16] ; # X
; # (let Y (car X) (? (and (pair Y) (== Key (car Y))) (cdr Y)))
; # (car X)
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
; # (? (and (pair Y) (== Key (car Y))) (cdr Y))
; # (and (pair Y) (== Key (car Y)))
; # (pair Y)
  %16 = and i64 %15, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$12, label %$11
$12:
  %18 = phi i64 [%13, %$10] ; # X
; # (car Y)
  %19 = inttoptr i64 %15 to i64*
  %20 = load i64, i64* %19
; # (== Key (car Y))
  %21 = icmp eq i64 %2, %20
  br label %$11
$11:
  %22 = phi i64 [%13, %$10], [%18, %$12] ; # X
  %23 = phi i1 [0, %$10], [%21, %$12] ; # ->
  br i1 %23, label %$15, label %$13
$15:
  %24 = phi i64 [%22, %$11] ; # X
; # (cdr Y)
  %25 = inttoptr i64 %15 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
  br label %$14
$13:
  %28 = phi i64 [%22, %$11] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (atom (shift X))
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$16
$17:
  %34 = phi i64 [%31, %$13] ; # X
  br label %$14
$16:
  %35 = phi i64 [%31, %$13] ; # X
  br label %$10
$14:
  %36 = phi i64 [%24, %$15], [%34, %$17] ; # X
  %37 = phi i64 [%27, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
  br label %$7
$8:
  %38 = phi i64 [%9, %$4] ; # X
; # (== ZERO Key)
  %39 = icmp eq i64 2, %2
  br i1 %39, label %$18, label %$19
$19:
  %40 = phi i64 [%38, %$8] ; # X
; # (nth Key X)
  %41 = lshr i64 %2, 4
  br label %$20
$20:
  %42 = phi i64 [%40, %$19], [%50, %$21] ; # X
  %43 = phi i64 [%41, %$19], [%47, %$21] ; # C
  %44 = sub i64 %43, 1
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$21, label %$22
$21:
  %46 = phi i64 [%42, %$20] ; # X
  %47 = phi i64 [%44, %$20] ; # C
  %48 = inttoptr i64 %46 to i64*
  %49 = getelementptr i64, i64* %48, i32 1
  %50 = load i64, i64* %49
  br label %$20
$22:
  %51 = phi i64 [%42, %$20] ; # X
  %52 = phi i64 [%44, %$20] ; # C
  %53 = and i64 %2, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$23, label %$24
$23:
  %55 = phi i64 [%51, %$22] ; # X
  %56 = phi i64 [%52, %$22] ; # C
  %57 = inttoptr i64 %55 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  br label %$25
$24:
  %60 = phi i64 [%51, %$22] ; # X
  %61 = phi i64 [%52, %$22] ; # C
  %62 = inttoptr i64 %60 to i64*
  %63 = load i64, i64* %62
  br label %$25
$25:
  %64 = phi i64 [%55, %$23], [%60, %$24] ; # X
  %65 = phi i64 [%56, %$23], [%61, %$24] ; # C
  %66 = phi i64 [%59, %$23], [%63, %$24] ; # ->
  br label %$7
$18:
  %67 = phi i64 [%38, %$8] ; # X
  br label %$7
$7:
  %68 = phi i64 [%36, %$14], [%40, %$25], [%67, %$18] ; # X
  %69 = phi i64 [%37, %$14], [%66, %$25], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$18] ; # ->
  br label %$6
$5:
  %70 = phi i64 [%6, %$3] ; # X
; # (when (sym? (val (tail X))) (dbFetch Exe X))
; # (tail X)
  %71 = add i64 %70, -8
; # (val (tail X))
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
; # (sym? (val (tail X)))
  %74 = and i64 %73, 8
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$26, label %$27
$26:
  %76 = phi i64 [%70, %$5] ; # X
; # (dbFetch Exe X)
  call void @dbFetch(i64 %0, i64 %76)
  br label %$27
$27:
  %77 = phi i64 [%70, %$5], [%76, %$26] ; # X
; # (get X Key)
  %78 = tail call i64 @get(i64 %77, i64 %2)
  br label %$6
$6:
  %79 = phi i64 [%68, %$7], [%77, %$27] ; # X
  %80 = phi i64 [%69, %$7], [%78, %$27] ; # ->
  ret i64 %80
}

define i64 @prop(i64, i64) {
$1:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (let (L (any (& Ta...
; # (tail Sym)
  %2 = add i64 %0, -8
; # (val (tail Sym))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (unless (num? Tail) (let (L (any (& Tail -9)) X (car L)) (if (ato...
; # (num? Tail)
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
; # (let (L (any (& Tail -9)) X (car L)) (if (atom X) (when (== Key X...
; # (& Tail -9)
  %7 = and i64 %4, -9
; # (any (& Tail -9))
; # (car L)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (if (atom X) (when (== Key X) (ret Key)) (when (== Key (cdr X)) (...
; # (atom X)
  %10 = and i64 %9, 15
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$5
$4:
  %12 = phi i64 [%7, %$2] ; # L
  %13 = phi i64 [%9, %$2] ; # X
; # (when (== Key X) (ret Key))
; # (== Key X)
  %14 = icmp eq i64 %1, %13
  br i1 %14, label %$7, label %$8
$7:
  %15 = phi i64 [%12, %$4] ; # L
  %16 = phi i64 [%13, %$4] ; # X
; # (ret Key)
  ret i64 %1
$8:
  %17 = phi i64 [%12, %$4] ; # L
  %18 = phi i64 [%13, %$4] ; # X
  br label %$6
$5:
  %19 = phi i64 [%7, %$2] ; # L
  %20 = phi i64 [%9, %$2] ; # X
; # (when (== Key (cdr X)) (ret X))
; # (cdr X)
  %21 = inttoptr i64 %20 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (== Key (cdr X))
  %24 = icmp eq i64 %1, %23
  br i1 %24, label %$9, label %$10
$9:
  %25 = phi i64 [%19, %$5] ; # L
  %26 = phi i64 [%20, %$5] ; # X
; # (ret X)
  ret i64 %26
$10:
  %27 = phi i64 [%19, %$5] ; # L
  %28 = phi i64 [%20, %$5] ; # X
  br label %$6
$6:
  %29 = phi i64 [%17, %$8], [%27, %$10] ; # L
  %30 = phi i64 [%18, %$8], [%28, %$10] ; # X
; # (while (pair (setq X (cdr L))) (let Y (car X) (if (atom Y) (when ...
  br label %$11
$11:
  %31 = phi i64 [%29, %$6], [%106, %$16] ; # L
  %32 = phi i64 [%30, %$6], [%106, %$16] ; # X
; # (cdr L)
  %33 = inttoptr i64 %31 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
; # (pair (setq X (cdr L)))
  %36 = and i64 %35, 15
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %$12, label %$13
$12:
  %38 = phi i64 [%31, %$11] ; # L
  %39 = phi i64 [%35, %$11] ; # X
; # (let Y (car X) (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (i...
; # (car X)
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
; # (if (atom Y) (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) ...
; # (atom Y)
  %42 = and i64 %41, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$14, label %$15
$14:
  %44 = phi i64 [%38, %$12] ; # L
  %45 = phi i64 [%39, %$12] ; # X
; # (when (== Key Y) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 X Tail...
; # (== Key Y)
  %46 = icmp eq i64 %1, %41
  br i1 %46, label %$17, label %$18
$17:
  %47 = phi i64 [%44, %$14] ; # L
  %48 = phi i64 [%45, %$14] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %47 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  store i64 %51, i64* %53
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %54 = and i64 %4, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$20, label %$19
$19:
  %56 = phi i64 [%47, %$17] ; # L
  %57 = phi i64 [%48, %$17] ; # X
; # (set 2 X Tail)
  %58 = inttoptr i64 %57 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %4, i64* %59
  br label %$21
$20:
  %60 = phi i64 [%47, %$17] ; # L
  %61 = phi i64 [%48, %$17] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %62 = and i64 %4, -9
  %63 = inttoptr i64 %61 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  store i64 %62, i64* %64
; # (sym X)
  %65 = or i64 %61, 8
  br label %$21
$21:
  %66 = phi i64 [%56, %$19], [%60, %$20] ; # L
  %67 = phi i64 [%57, %$19], [%65, %$20] ; # X
  %68 = phi i64 [%4, %$19], [%65, %$20] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %69 = add i64 %0, -8
  %70 = inttoptr i64 %69 to i64*
  store i64 %67, i64* %70
; # (ret Key)
  ret i64 %1
$18:
  %71 = phi i64 [%44, %$14] ; # L
  %72 = phi i64 [%45, %$14] ; # X
  br label %$16
$15:
  %73 = phi i64 [%38, %$12] ; # L
  %74 = phi i64 [%39, %$12] ; # X
; # (when (== Key (cdr Y)) (set 2 L (cdr X)) (ifn (sym? Tail) (set 2 ...
; # (cdr Y)
  %75 = inttoptr i64 %41 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
; # (== Key (cdr Y))
  %78 = icmp eq i64 %1, %77
  br i1 %78, label %$22, label %$23
$22:
  %79 = phi i64 [%73, %$15] ; # L
  %80 = phi i64 [%74, %$15] ; # X
; # (set 2 L (cdr X))
; # (cdr X)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 %79 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  store i64 %83, i64* %85
; # (ifn (sym? Tail) (set 2 X Tail) (set 2 X (& Tail -9)) (setq X (sy...
; # (sym? Tail)
  %86 = and i64 %4, 8
  %87 = icmp ne i64 %86, 0
  br i1 %87, label %$25, label %$24
$24:
  %88 = phi i64 [%79, %$22] ; # L
  %89 = phi i64 [%80, %$22] ; # X
; # (set 2 X Tail)
  %90 = inttoptr i64 %89 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %4, i64* %91
  br label %$26
$25:
  %92 = phi i64 [%79, %$22] ; # L
  %93 = phi i64 [%80, %$22] ; # X
; # (set 2 X (& Tail -9))
; # (& Tail -9)
  %94 = and i64 %4, -9
  %95 = inttoptr i64 %93 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %94, i64* %96
; # (sym X)
  %97 = or i64 %93, 8
  br label %$26
$26:
  %98 = phi i64 [%88, %$24], [%92, %$25] ; # L
  %99 = phi i64 [%89, %$24], [%97, %$25] ; # X
  %100 = phi i64 [%4, %$24], [%97, %$25] ; # ->
; # (set (tail Sym) X)
; # (tail Sym)
  %101 = add i64 %0, -8
  %102 = inttoptr i64 %101 to i64*
  store i64 %99, i64* %102
; # (ret Y)
  ret i64 %41
$23:
  %103 = phi i64 [%73, %$15] ; # L
  %104 = phi i64 [%74, %$15] ; # X
  br label %$16
$16:
  %105 = phi i64 [%71, %$18], [%103, %$23] ; # L
  %106 = phi i64 [%72, %$18], [%104, %$23] ; # X
  br label %$11
$13:
  %107 = phi i64 [%31, %$11] ; # L
  %108 = phi i64 [%35, %$11] ; # X
  br label %$3
$3:
; # (let R (cons $Nil Key) (set (tail Sym) (if (sym? Tail) (sym (cons...
; # (cons $Nil Key)
  %109 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 %1)
; # (set (tail Sym) (if (sym? Tail) (sym (cons R (& Tail -9))) (cons ...
; # (tail Sym)
  %110 = add i64 %0, -8
; # (if (sym? Tail) (sym (cons R (& Tail -9))) (cons R Tail))
; # (sym? Tail)
  %111 = and i64 %4, 8
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$27, label %$28
$27:
; # (& Tail -9)
  %113 = and i64 %4, -9
; # (cons R (& Tail -9))
  %114 = call i64 @cons(i64 %109, i64 %113)
; # (sym (cons R (& Tail -9)))
  %115 = or i64 %114, 8
  br label %$29
$28:
; # (cons R Tail)
  %116 = call i64 @cons(i64 %109, i64 %4)
  br label %$29
$29:
  %117 = phi i64 [%115, %$27], [%116, %$28] ; # ->
  %118 = inttoptr i64 %110 to i64*
  store i64 %117, i64* %118
  ret i64 %109
}

define i64 @_put(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Key T) (loop (setq Key (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (loop (setq Key (eval (++ X))) (? (atom (cdr X))) (setq Y (safe (...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%43, %$13] ; # X
  %25 = phi i64 [%15, %$2], [%46, %$13] ; # Y
; # (++ X)
  %26 = inttoptr i64 %24 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
; # (eval (++ X))
  %30 = and i64 %27, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$10, label %$9
$10:
  br label %$8
$9:
  %32 = and i64 %27, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = inttoptr i64 %27 to i64*
  %35 = load i64, i64* %34
  br label %$8
$11:
  %36 = call i64 @evList(i64 %27)
  br label %$8
$8:
  %37 = phi i64 [%27, %$10], [%35, %$12], [%36, %$11] ; # ->
; # (? (atom (cdr X)))
; # (cdr X)
  %38 = inttoptr i64 %29 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (atom (cdr X))
  %41 = and i64 %40, 15
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$14, label %$13
$13:
  %43 = phi i64 [%29, %$8] ; # X
  %44 = phi i64 [%25, %$8] ; # Y
  %45 = phi i64 [%37, %$8] ; # Key
; # (getn Exe Y Key)
  %46 = call i64 @getn(i64 %0, i64 %44, i64 %45)
; # (safe (getn Exe Y Key))
  %47 = inttoptr i64 %17 to i64*
  store i64 %46, i64* %47
  br label %$7
$14:
  %48 = phi i64 [%29, %$8] ; # X
  %49 = phi i64 [%25, %$8] ; # Y
  %50 = phi i64 [%37, %$8] ; # Key
  %51 = phi i64 [0, %$8] ; # ->
; # (when (num? Y) (argErr Exe Y))
; # (num? Y)
  %52 = and i64 %49, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$15, label %$16
$15:
  %54 = phi i64 [%48, %$14] ; # X
  %55 = phi i64 [%49, %$14] ; # Y
  %56 = phi i64 [%50, %$14] ; # Key
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %55)
  unreachable
$16:
  %57 = phi i64 [%48, %$14] ; # X
  %58 = phi i64 [%49, %$14] ; # Y
  %59 = phi i64 [%50, %$14] ; # Key
; # (push Key NIL)
  %60 = alloca i64, i64 2, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = inttoptr i64 %61 to i64*
  store i64 %59, i64* %62
; # (link (push Key NIL))
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %64 = load i64, i64* %63
  %65 = inttoptr i64 %61 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  store i64 %64, i64* %66
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %61, i64* %67
; # (let Val (eval (car X)) (if (pair Y) (putn Exe Y Key Val) (when (...
; # (car X)
  %68 = inttoptr i64 %57 to i64*
  %69 = load i64, i64* %68
; # (eval (car X))
  %70 = and i64 %69, 6
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$19, label %$18
$19:
  br label %$17
$18:
  %72 = and i64 %69, 8
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$21, label %$20
$21:
  %74 = inttoptr i64 %69 to i64*
  %75 = load i64, i64* %74
  br label %$17
$20:
  %76 = call i64 @evList(i64 %69)
  br label %$17
$17:
  %77 = phi i64 [%69, %$19], [%75, %$21], [%76, %$20] ; # ->
; # (if (pair Y) (putn Exe Y Key Val) (when (sym? (val (tail Y))) (if...
; # (pair Y)
  %78 = and i64 %58, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$22, label %$23
$22:
  %80 = phi i64 [%57, %$17] ; # X
  %81 = phi i64 [%58, %$17] ; # Y
  %82 = phi i64 [%59, %$17] ; # Key
; # (putn Exe Y Key Val)
  call void @putn(i64 %0, i64 %81, i64 %82, i64 %77)
  br label %$24
$23:
  %83 = phi i64 [%57, %$17] ; # X
  %84 = phi i64 [%58, %$17] ; # Y
  %85 = phi i64 [%59, %$17] ; # Key
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %86 = add i64 %84, -8
; # (val (tail Y))
  %87 = inttoptr i64 %86 to i64*
  %88 = load i64, i64* %87
; # (sym? (val (tail Y)))
  %89 = and i64 %88, 8
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$25, label %$26
$25:
  %91 = phi i64 [%83, %$23] ; # X
  %92 = phi i64 [%84, %$23] ; # Y
  %93 = phi i64 [%85, %$23] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %94 = icmp eq i64 %93, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %94, label %$27, label %$28
$27:
  %95 = phi i64 [%91, %$25] ; # X
  %96 = phi i64 [%92, %$25] ; # Y
  %97 = phi i64 [%93, %$25] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %96)
  br label %$29
$28:
  %98 = phi i64 [%91, %$25] ; # X
  %99 = phi i64 [%92, %$25] ; # Y
  %100 = phi i64 [%93, %$25] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %99)
  br label %$29
$29:
  %101 = phi i64 [%95, %$27], [%98, %$28] ; # X
  %102 = phi i64 [%96, %$27], [%99, %$28] ; # Y
  %103 = phi i64 [%97, %$27], [%100, %$28] ; # Key
  br label %$26
$26:
  %104 = phi i64 [%83, %$23], [%101, %$29] ; # X
  %105 = phi i64 [%84, %$23], [%102, %$29] ; # Y
  %106 = phi i64 [%85, %$23], [%103, %$29] ; # Key
; # (if (== ZERO Key) (set (chkVar Exe Y) Val) (put Y Key Val))
; # (== ZERO Key)
  %107 = icmp eq i64 2, %106
  br i1 %107, label %$30, label %$31
$30:
  %108 = phi i64 [%104, %$26] ; # X
  %109 = phi i64 [%105, %$26] ; # Y
  %110 = phi i64 [%106, %$26] ; # Key
; # (set (chkVar Exe Y) Val)
; # (chkVar Exe Y)
  %111 = icmp uge i64 %109, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %111, label %$34, label %$33
$34:
  %112 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %109
  br label %$33
$33:
  %113 = phi i1 [0, %$30], [%112, %$34] ; # ->
  br i1 %113, label %$35, label %$36
$35:
  call void @protErr(i64 %0, i64 %109)
  unreachable
$36:
  %114 = inttoptr i64 %109 to i64*
  store i64 %77, i64* %114
  br label %$32
$31:
  %115 = phi i64 [%104, %$26] ; # X
  %116 = phi i64 [%105, %$26] ; # Y
  %117 = phi i64 [%106, %$26] ; # Key
; # (put Y Key Val)
  call void @put(i64 %116, i64 %117, i64 %77)
  br label %$32
$32:
  %118 = phi i64 [%108, %$36], [%115, %$31] ; # X
  %119 = phi i64 [%109, %$36], [%116, %$31] ; # Y
  %120 = phi i64 [%110, %$36], [%117, %$31] ; # Key
  br label %$24
$24:
  %121 = phi i64 [%80, %$22], [%118, %$32] ; # X
  %122 = phi i64 [%81, %$22], [%119, %$32] ; # Y
  %123 = phi i64 [%82, %$22], [%120, %$32] ; # Key
; # (drop *Safe)
  %124 = inttoptr i64 %17 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
  %127 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %126, i64* %127
  ret i64 %77
}

define i64 @_get(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (when (pair X) (save Y (loop (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (when (pair X) (save Y (loop (setq Y (getn Exe Y (eval (++ X)))) ...
; # (pair X)
  %16 = and i64 %7, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  %18 = phi i64 [%7, %$2] ; # X
  %19 = phi i64 [%15, %$2] ; # Y
; # (save Y (loop (setq Y (getn Exe Y (eval (++ X)))) (? (atom X)) (s...
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %19, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %21 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %27
; # (loop (setq Y (getn Exe Y (eval (++ X)))) (? (atom X)) (safe Y))
  br label %$9
$9:
  %28 = phi i64 [%18, %$7], [%45, %$15] ; # X
  %29 = phi i64 [%19, %$7], [%46, %$15] ; # Y
; # (++ X)
  %30 = inttoptr i64 %28 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
; # (eval (++ X))
  %34 = and i64 %31, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %31, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %31 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %31)
  br label %$10
$10:
  %41 = phi i64 [%31, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (getn Exe Y (eval (++ X)))
  %42 = call i64 @getn(i64 %0, i64 %29, i64 %41)
; # (? (atom X))
; # (atom X)
  %43 = and i64 %33, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$16, label %$15
$15:
  %45 = phi i64 [%33, %$10] ; # X
  %46 = phi i64 [%42, %$10] ; # Y
; # (safe Y)
  %47 = inttoptr i64 %21 to i64*
  store i64 %46, i64* %47
  br label %$9
$16:
  %48 = phi i64 [%33, %$10] ; # X
  %49 = phi i64 [%42, %$10] ; # Y
  %50 = phi i64 [0, %$10] ; # ->
  %51 = inttoptr i64 %21 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %54
  br label %$8
$8:
  %55 = phi i64 [%7, %$2], [%48, %$16] ; # X
  %56 = phi i64 [%15, %$2], [%49, %$16] ; # Y
  ret i64 %56
}

define i64 @_prop(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Key T) (loop (setq Key (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (loop (setq Key (eval (++ X))) (? (atom X)) (setq Y (safe (getn E...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%40, %$13] ; # X
  %25 = phi i64 [%15, %$2], [%43, %$13] ; # Y
; # (++ X)
  %26 = inttoptr i64 %24 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
; # (eval (++ X))
  %30 = and i64 %27, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$10, label %$9
$10:
  br label %$8
$9:
  %32 = and i64 %27, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = inttoptr i64 %27 to i64*
  %35 = load i64, i64* %34
  br label %$8
$11:
  %36 = call i64 @evList(i64 %27)
  br label %$8
$8:
  %37 = phi i64 [%27, %$10], [%35, %$12], [%36, %$11] ; # ->
; # (? (atom X))
; # (atom X)
  %38 = and i64 %29, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$14, label %$13
$13:
  %40 = phi i64 [%29, %$8] ; # X
  %41 = phi i64 [%25, %$8] ; # Y
  %42 = phi i64 [%37, %$8] ; # Key
; # (getn Exe Y Key)
  %43 = call i64 @getn(i64 %0, i64 %41, i64 %42)
; # (safe (getn Exe Y Key))
  %44 = inttoptr i64 %17 to i64*
  store i64 %43, i64* %44
  br label %$7
$14:
  %45 = phi i64 [%29, %$8] ; # X
  %46 = phi i64 [%25, %$8] ; # Y
  %47 = phi i64 [%37, %$8] ; # Key
  %48 = phi i64 [0, %$8] ; # ->
; # (needSymb Exe Y)
  %49 = xor i64 %46, 8
  %50 = and i64 %49, 14
  %51 = icmp eq i64 %50, 0
  br i1 %51, label %$16, label %$15
$15:
  call void @symErr(i64 %0, i64 %46)
  unreachable
$16:
; # (push Key NIL)
  %52 = alloca i64, i64 2, align 16
  %53 = ptrtoint i64* %52 to i64
  %54 = inttoptr i64 %53 to i64*
  store i64 %47, i64* %54
; # (link (push Key NIL))
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %53 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %59
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %60 = add i64 %46, -8
; # (val (tail Y))
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (sym? (val (tail Y)))
  %63 = and i64 %62, 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$17, label %$18
$17:
  %65 = phi i64 [%45, %$16] ; # X
  %66 = phi i64 [%46, %$16] ; # Y
  %67 = phi i64 [%47, %$16] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %68 = icmp eq i64 %67, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %68, label %$19, label %$20
$19:
  %69 = phi i64 [%65, %$17] ; # X
  %70 = phi i64 [%66, %$17] ; # Y
  %71 = phi i64 [%67, %$17] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %70)
  br label %$21
$20:
  %72 = phi i64 [%65, %$17] ; # X
  %73 = phi i64 [%66, %$17] ; # Y
  %74 = phi i64 [%67, %$17] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %73)
  br label %$21
$21:
  %75 = phi i64 [%69, %$19], [%72, %$20] ; # X
  %76 = phi i64 [%70, %$19], [%73, %$20] ; # Y
  %77 = phi i64 [%71, %$19], [%74, %$20] ; # Key
  br label %$18
$18:
  %78 = phi i64 [%45, %$16], [%75, %$21] ; # X
  %79 = phi i64 [%46, %$16], [%76, %$21] ; # Y
  %80 = phi i64 [%47, %$16], [%77, %$21] ; # Key
; # (prop Y Key)
  %81 = call i64 @prop(i64 %79, i64 %80)
; # (drop *Safe)
  %82 = inttoptr i64 %17 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %84, i64* %85
  ret i64 %81
}

define i64 @_semicol(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (when (pair X) (save Y (loop (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (when (pair X) (save Y (loop (setq Y (getn Exe Y (++ X))) (? (ato...
; # (pair X)
  %16 = and i64 %7, 15
  %17 = icmp eq i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  %18 = phi i64 [%7, %$2] ; # X
  %19 = phi i64 [%15, %$2] ; # Y
; # (save Y (loop (setq Y (getn Exe Y (++ X))) (? (atom X)) (safe Y))...
  %20 = alloca i64, i64 2, align 16
  %21 = ptrtoint i64* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 %19, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %21 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %21, i64* %27
; # (loop (setq Y (getn Exe Y (++ X))) (? (atom X)) (safe Y))
  br label %$9
$9:
  %28 = phi i64 [%18, %$7], [%37, %$10] ; # X
  %29 = phi i64 [%19, %$7], [%38, %$10] ; # Y
; # (++ X)
  %30 = inttoptr i64 %28 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
; # (getn Exe Y (++ X))
  %34 = call i64 @getn(i64 %0, i64 %29, i64 %31)
; # (? (atom X))
; # (atom X)
  %35 = and i64 %33, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$11, label %$10
$10:
  %37 = phi i64 [%33, %$9] ; # X
  %38 = phi i64 [%34, %$9] ; # Y
; # (safe Y)
  %39 = inttoptr i64 %21 to i64*
  store i64 %38, i64* %39
  br label %$9
$11:
  %40 = phi i64 [%33, %$9] ; # X
  %41 = phi i64 [%34, %$9] ; # Y
  %42 = phi i64 [0, %$9] ; # ->
  %43 = inttoptr i64 %21 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %46
  br label %$8
$8:
  %47 = phi i64 [%7, %$2], [%40, %$11] ; # X
  %48 = phi i64 [%15, %$2], [%41, %$11] ; # Y
  ret i64 %48
}

define i64 @_setCol(i64) {
$1:
; # (let (X (cdr Exe) Y (val $This) Key T) (loop (setq Key (++ X)) (?...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $This)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %5 = load i64, i64* %4
; # (loop (setq Key (++ X)) (? (atom (cdr X))) (setq Y (getn Exe Y Ke...
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%17, %$3] ; # X
  %7 = phi i64 [%5, %$1], [%20, %$3] ; # Y
; # (++ X)
  %8 = inttoptr i64 %6 to i64*
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %8, i32 1
  %11 = load i64, i64* %10
; # (? (atom (cdr X)))
; # (cdr X)
  %12 = inttoptr i64 %11 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  %14 = load i64, i64* %13
; # (atom (cdr X))
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$4, label %$3
$3:
  %17 = phi i64 [%11, %$2] ; # X
  %18 = phi i64 [%7, %$2] ; # Y
  %19 = phi i64 [%9, %$2] ; # Key
; # (getn Exe Y Key)
  %20 = call i64 @getn(i64 %0, i64 %18, i64 %19)
  br label %$2
$4:
  %21 = phi i64 [%11, %$2] ; # X
  %22 = phi i64 [%7, %$2] ; # Y
  %23 = phi i64 [%9, %$2] ; # Key
  %24 = phi i64 [0, %$2] ; # ->
; # (when (num? Y) (argErr Exe Y))
; # (num? Y)
  %25 = and i64 %22, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$5, label %$6
$5:
  %27 = phi i64 [%21, %$4] ; # X
  %28 = phi i64 [%22, %$4] ; # Y
  %29 = phi i64 [%23, %$4] ; # Key
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %28)
  unreachable
$6:
  %30 = phi i64 [%21, %$4] ; # X
  %31 = phi i64 [%22, %$4] ; # Y
  %32 = phi i64 [%23, %$4] ; # Key
; # (let Val (eval (car X)) (if (pair Y) (putn Exe Y Key Val) (when (...
; # (car X)
  %33 = inttoptr i64 %30 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$9, label %$8
$9:
  br label %$7
$8:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$11, label %$10
$11:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$7
$10:
  %41 = call i64 @evList(i64 %34)
  br label %$7
$7:
  %42 = phi i64 [%34, %$9], [%40, %$11], [%41, %$10] ; # ->
; # (if (pair Y) (putn Exe Y Key Val) (when (sym? (val (tail Y))) (if...
; # (pair Y)
  %43 = and i64 %31, 15
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$12, label %$13
$12:
  %45 = phi i64 [%30, %$7] ; # X
  %46 = phi i64 [%31, %$7] ; # Y
  %47 = phi i64 [%32, %$7] ; # Key
; # (putn Exe Y Key Val)
  call void @putn(i64 %0, i64 %46, i64 %47, i64 %42)
  br label %$14
$13:
  %48 = phi i64 [%30, %$7] ; # X
  %49 = phi i64 [%31, %$7] ; # Y
  %50 = phi i64 [%32, %$7] ; # Key
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %51 = add i64 %49, -8
; # (val (tail Y))
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
; # (sym? (val (tail Y)))
  %54 = and i64 %53, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$15, label %$16
$15:
  %56 = phi i64 [%48, %$13] ; # X
  %57 = phi i64 [%49, %$13] ; # Y
  %58 = phi i64 [%50, %$13] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %59 = icmp eq i64 %58, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %59, label %$17, label %$18
$17:
  %60 = phi i64 [%56, %$15] ; # X
  %61 = phi i64 [%57, %$15] ; # Y
  %62 = phi i64 [%58, %$15] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %61)
  br label %$19
$18:
  %63 = phi i64 [%56, %$15] ; # X
  %64 = phi i64 [%57, %$15] ; # Y
  %65 = phi i64 [%58, %$15] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %64)
  br label %$19
$19:
  %66 = phi i64 [%60, %$17], [%63, %$18] ; # X
  %67 = phi i64 [%61, %$17], [%64, %$18] ; # Y
  %68 = phi i64 [%62, %$17], [%65, %$18] ; # Key
  br label %$16
$16:
  %69 = phi i64 [%48, %$13], [%66, %$19] ; # X
  %70 = phi i64 [%49, %$13], [%67, %$19] ; # Y
  %71 = phi i64 [%50, %$13], [%68, %$19] ; # Key
; # (if (== ZERO Key) (set (chkVar Exe Y) Val) (put Y Key Val))
; # (== ZERO Key)
  %72 = icmp eq i64 2, %71
  br i1 %72, label %$20, label %$21
$20:
  %73 = phi i64 [%69, %$16] ; # X
  %74 = phi i64 [%70, %$16] ; # Y
  %75 = phi i64 [%71, %$16] ; # Key
; # (set (chkVar Exe Y) Val)
; # (chkVar Exe Y)
  %76 = icmp uge i64 %74, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %76, label %$24, label %$23
$24:
  %77 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %74
  br label %$23
$23:
  %78 = phi i1 [0, %$20], [%77, %$24] ; # ->
  br i1 %78, label %$25, label %$26
$25:
  call void @protErr(i64 %0, i64 %74)
  unreachable
$26:
  %79 = inttoptr i64 %74 to i64*
  store i64 %42, i64* %79
  br label %$22
$21:
  %80 = phi i64 [%69, %$16] ; # X
  %81 = phi i64 [%70, %$16] ; # Y
  %82 = phi i64 [%71, %$16] ; # Key
; # (put Y Key Val)
  call void @put(i64 %81, i64 %82, i64 %42)
  br label %$22
$22:
  %83 = phi i64 [%73, %$26], [%80, %$21] ; # X
  %84 = phi i64 [%74, %$26], [%81, %$21] ; # Y
  %85 = phi i64 [%75, %$26], [%82, %$21] ; # Key
  br label %$14
$14:
  %86 = phi i64 [%45, %$12], [%83, %$22] ; # X
  %87 = phi i64 [%46, %$12], [%84, %$22] ; # Y
  %88 = phi i64 [%47, %$12], [%85, %$22] ; # Key
  ret i64 %42
}

define i64 @_col(i64) {
$1:
; # (let (X (cdr Exe) Y (val $This)) (loop (setq Y (getn Exe Y (++ X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $This)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %5 = load i64, i64* %4
; # (loop (setq Y (getn Exe Y (++ X))) (? (atom X) Y))
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%17, %$3] ; # X
  %7 = phi i64 [%5, %$1], [%18, %$3] ; # Y
; # (++ X)
  %8 = inttoptr i64 %6 to i64*
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %8, i32 1
  %11 = load i64, i64* %10
; # (getn Exe Y (++ X))
  %12 = call i64 @getn(i64 %0, i64 %7, i64 %9)
; # (? (atom X) Y)
; # (atom X)
  %13 = and i64 %11, 15
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$5, label %$3
$5:
  %15 = phi i64 [%11, %$2] ; # X
  %16 = phi i64 [%12, %$2] ; # Y
  br label %$4
$3:
  %17 = phi i64 [%11, %$2] ; # X
  %18 = phi i64 [%12, %$2] ; # Y
  br label %$2
$4:
  %19 = phi i64 [%15, %$5] ; # X
  %20 = phi i64 [%16, %$5] ; # Y
  %21 = phi i64 [%16, %$5] ; # ->
  ret i64 %21
}

define i64 @_propCol(i64) {
$1:
; # (let (X (cdr Exe) Y (val $This) Key T) (loop (setq Key (++ X)) (?...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $This)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %5 = load i64, i64* %4
; # (loop (setq Key (++ X)) (? (atom X)) (setq Y (getn Exe Y Key)))
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%14, %$3] ; # X
  %7 = phi i64 [%5, %$1], [%17, %$3] ; # Y
; # (++ X)
  %8 = inttoptr i64 %6 to i64*
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %8, i32 1
  %11 = load i64, i64* %10
; # (? (atom X))
; # (atom X)
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$4, label %$3
$3:
  %14 = phi i64 [%11, %$2] ; # X
  %15 = phi i64 [%7, %$2] ; # Y
  %16 = phi i64 [%9, %$2] ; # Key
; # (getn Exe Y Key)
  %17 = call i64 @getn(i64 %0, i64 %15, i64 %16)
  br label %$2
$4:
  %18 = phi i64 [%11, %$2] ; # X
  %19 = phi i64 [%7, %$2] ; # Y
  %20 = phi i64 [%9, %$2] ; # Key
  %21 = phi i64 [0, %$2] ; # ->
; # (needSymb Exe Y)
  %22 = xor i64 %19, 8
  %23 = and i64 %22, 14
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$6, label %$5
$5:
  call void @symErr(i64 %0, i64 %19)
  unreachable
$6:
; # (when (sym? (val (tail Y))) (if (nil? Key) (dbFetch Exe Y) (dbTou...
; # (tail Y)
  %25 = add i64 %19, -8
; # (val (tail Y))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (sym? (val (tail Y)))
  %28 = and i64 %27, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$7, label %$8
$7:
  %30 = phi i64 [%18, %$6] ; # X
  %31 = phi i64 [%19, %$6] ; # Y
  %32 = phi i64 [%20, %$6] ; # Key
; # (if (nil? Key) (dbFetch Exe Y) (dbTouch Exe Y))
; # (nil? Key)
  %33 = icmp eq i64 %32, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %33, label %$9, label %$10
$9:
  %34 = phi i64 [%30, %$7] ; # X
  %35 = phi i64 [%31, %$7] ; # Y
  %36 = phi i64 [%32, %$7] ; # Key
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %35)
  br label %$11
$10:
  %37 = phi i64 [%30, %$7] ; # X
  %38 = phi i64 [%31, %$7] ; # Y
  %39 = phi i64 [%32, %$7] ; # Key
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %38)
  br label %$11
$11:
  %40 = phi i64 [%34, %$9], [%37, %$10] ; # X
  %41 = phi i64 [%35, %$9], [%38, %$10] ; # Y
  %42 = phi i64 [%36, %$9], [%39, %$10] ; # Key
  br label %$8
$8:
  %43 = phi i64 [%18, %$6], [%40, %$11] ; # X
  %44 = phi i64 [%19, %$6], [%41, %$11] ; # Y
  %45 = phi i64 [%20, %$6], [%42, %$11] ; # Key
; # (prop Y Key)
  %46 = call i64 @prop(i64 %44, i64 %45)
  ret i64 %46
}

define i64 @_putl(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z T) (loop (setq Z (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (loop (setq Z (eval (++ X))) (? (atom X)) (setq Y (safe (getn Exe...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%40, %$13] ; # X
  %25 = phi i64 [%15, %$2], [%43, %$13] ; # Y
; # (++ X)
  %26 = inttoptr i64 %24 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
; # (eval (++ X))
  %30 = and i64 %27, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$10, label %$9
$10:
  br label %$8
$9:
  %32 = and i64 %27, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$11
$12:
  %34 = inttoptr i64 %27 to i64*
  %35 = load i64, i64* %34
  br label %$8
$11:
  %36 = call i64 @evList(i64 %27)
  br label %$8
$8:
  %37 = phi i64 [%27, %$10], [%35, %$12], [%36, %$11] ; # ->
; # (? (atom X))
; # (atom X)
  %38 = and i64 %29, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$14, label %$13
$13:
  %40 = phi i64 [%29, %$8] ; # X
  %41 = phi i64 [%25, %$8] ; # Y
  %42 = phi i64 [%37, %$8] ; # Z
; # (getn Exe Y Z)
  %43 = call i64 @getn(i64 %0, i64 %41, i64 %42)
; # (safe (getn Exe Y Z))
  %44 = inttoptr i64 %17 to i64*
  store i64 %43, i64* %44
  br label %$7
$14:
  %45 = phi i64 [%29, %$8] ; # X
  %46 = phi i64 [%25, %$8] ; # Y
  %47 = phi i64 [%37, %$8] ; # Z
  %48 = phi i64 [0, %$8] ; # ->
; # (let (R (save Z) Tail (val (tail Y))) (when (sym? (setq X Tail)) ...
; # (save Z)
  %49 = alloca i64, i64 2, align 16
  %50 = ptrtoint i64* %49 to i64
  %51 = inttoptr i64 %50 to i64*
  store i64 %47, i64* %51
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %50 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %53, i64* %55
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %50, i64* %56
; # (tail Y)
  %57 = add i64 %46, -8
; # (val (tail Y))
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (when (sym? (setq X Tail)) (dbTouch Exe Y) (setq X (& (val (tail ...
; # (sym? (setq X Tail))
  %60 = and i64 %59, 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$15, label %$16
$15:
  %62 = phi i64 [%59, %$14] ; # X
  %63 = phi i64 [%46, %$14] ; # Y
  %64 = phi i64 [%47, %$14] ; # Z
; # (dbTouch Exe Y)
  call void @dbTouch(i64 %0, i64 %63)
; # (tail Y)
  %65 = add i64 %63, -8
; # (val (tail Y))
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
; # (& (val (tail Y)) -9)
  %68 = and i64 %67, -9
  br label %$16
$16:
  %69 = phi i64 [%59, %$14], [%68, %$15] ; # X
  %70 = phi i64 [%46, %$14], [%63, %$15] ; # Y
  %71 = phi i64 [%47, %$14], [%64, %$15] ; # Z
; # (until (num? X) (shift X))
  br label %$17
$17:
  %72 = phi i64 [%69, %$16], [%82, %$18] ; # X
  %73 = phi i64 [%70, %$16], [%78, %$18] ; # Y
  %74 = phi i64 [%71, %$16], [%79, %$18] ; # Z
; # (num? X)
  %75 = and i64 %72, 6
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$19, label %$18
$18:
  %77 = phi i64 [%72, %$17] ; # X
  %78 = phi i64 [%73, %$17] ; # Y
  %79 = phi i64 [%74, %$17] ; # Z
; # (shift X)
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
  br label %$17
$19:
  %83 = phi i64 [%72, %$17] ; # X
  %84 = phi i64 [%73, %$17] ; # Y
  %85 = phi i64 [%74, %$17] ; # Z
; # (while (pair Z) (let P (++ Z) (if (atom P) (setq X (cons P X)) (u...
  br label %$20
$20:
  %86 = phi i64 [%83, %$19], [%135, %$25] ; # X
  %87 = phi i64 [%84, %$19], [%136, %$25] ; # Y
  %88 = phi i64 [%85, %$19], [%137, %$25] ; # Z
; # (pair Z)
  %89 = and i64 %88, 15
  %90 = icmp eq i64 %89, 0
  br i1 %90, label %$21, label %$22
$21:
  %91 = phi i64 [%86, %$20] ; # X
  %92 = phi i64 [%87, %$20] ; # Y
  %93 = phi i64 [%88, %$20] ; # Z
; # (let P (++ Z) (if (atom P) (setq X (cons P X)) (unless (nil? (car...
; # (++ Z)
  %94 = inttoptr i64 %93 to i64*
  %95 = load i64, i64* %94
  %96 = getelementptr i64, i64* %94, i32 1
  %97 = load i64, i64* %96
; # (if (atom P) (setq X (cons P X)) (unless (nil? (car P)) (when (==...
; # (atom P)
  %98 = and i64 %95, 15
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$23, label %$24
$23:
  %100 = phi i64 [%91, %$21] ; # X
  %101 = phi i64 [%92, %$21] ; # Y
  %102 = phi i64 [%97, %$21] ; # Z
  %103 = phi i64 [%95, %$21] ; # P
; # (cons P X)
  %104 = call i64 @cons(i64 %103, i64 %100)
  br label %$25
$24:
  %105 = phi i64 [%91, %$21] ; # X
  %106 = phi i64 [%92, %$21] ; # Y
  %107 = phi i64 [%97, %$21] ; # Z
  %108 = phi i64 [%95, %$21] ; # P
; # (unless (nil? (car P)) (when (== $T (car P)) (setq P (cdr P))) (s...
; # (car P)
  %109 = inttoptr i64 %108 to i64*
  %110 = load i64, i64* %109
; # (nil? (car P))
  %111 = icmp eq i64 %110, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %111, label %$27, label %$26
$26:
  %112 = phi i64 [%105, %$24] ; # X
  %113 = phi i64 [%106, %$24] ; # Y
  %114 = phi i64 [%107, %$24] ; # Z
  %115 = phi i64 [%108, %$24] ; # P
; # (when (== $T (car P)) (setq P (cdr P)))
; # (car P)
  %116 = inttoptr i64 %115 to i64*
  %117 = load i64, i64* %116
; # (== $T (car P))
  %118 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %117
  br i1 %118, label %$28, label %$29
$28:
  %119 = phi i64 [%112, %$26] ; # X
  %120 = phi i64 [%113, %$26] ; # Y
  %121 = phi i64 [%114, %$26] ; # Z
  %122 = phi i64 [%115, %$26] ; # P
; # (cdr P)
  %123 = inttoptr i64 %122 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  br label %$29
$29:
  %126 = phi i64 [%112, %$26], [%119, %$28] ; # X
  %127 = phi i64 [%113, %$26], [%120, %$28] ; # Y
  %128 = phi i64 [%114, %$26], [%121, %$28] ; # Z
  %129 = phi i64 [%115, %$26], [%125, %$28] ; # P
; # (cons P X)
  %130 = call i64 @cons(i64 %129, i64 %126)
  br label %$27
$27:
  %131 = phi i64 [%105, %$24], [%130, %$29] ; # X
  %132 = phi i64 [%106, %$24], [%127, %$29] ; # Y
  %133 = phi i64 [%107, %$24], [%128, %$29] ; # Z
  %134 = phi i64 [%108, %$24], [%129, %$29] ; # P
  br label %$25
$25:
  %135 = phi i64 [%104, %$23], [%131, %$27] ; # X
  %136 = phi i64 [%101, %$23], [%132, %$27] ; # Y
  %137 = phi i64 [%102, %$23], [%133, %$27] ; # Z
  %138 = phi i64 [%103, %$23], [%134, %$27] ; # P
  br label %$20
$22:
  %139 = phi i64 [%86, %$20] ; # X
  %140 = phi i64 [%87, %$20] ; # Y
  %141 = phi i64 [%88, %$20] ; # Z
; # (set (tail Y) (if (sym? Tail) (sym X) X))
; # (tail Y)
  %142 = add i64 %140, -8
; # (if (sym? Tail) (sym X) X)
; # (sym? Tail)
  %143 = and i64 %59, 8
  %144 = icmp ne i64 %143, 0
  br i1 %144, label %$30, label %$31
$30:
  %145 = phi i64 [%139, %$22] ; # X
  %146 = phi i64 [%140, %$22] ; # Y
  %147 = phi i64 [%141, %$22] ; # Z
; # (sym X)
  %148 = or i64 %145, 8
  br label %$32
$31:
  %149 = phi i64 [%139, %$22] ; # X
  %150 = phi i64 [%140, %$22] ; # Y
  %151 = phi i64 [%141, %$22] ; # Z
  br label %$32
$32:
  %152 = phi i64 [%145, %$30], [%149, %$31] ; # X
  %153 = phi i64 [%146, %$30], [%150, %$31] ; # Y
  %154 = phi i64 [%147, %$30], [%151, %$31] ; # Z
  %155 = phi i64 [%148, %$30], [%149, %$31] ; # ->
  %156 = inttoptr i64 %142 to i64*
  store i64 %155, i64* %156
; # (drop *Safe)
  %157 = inttoptr i64 %17 to i64*
  %158 = getelementptr i64, i64* %157, i32 1
  %159 = load i64, i64* %158
  %160 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %159, i64* %160
  ret i64 %47
}

define i64 @_getl(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (while (pair (shift X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (while (pair (shift X)) (setq Y (safe (getn Exe Y (eval (car X)))...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%29, %$10] ; # X
  %23 = phi i64 [%13, %$2], [%41, %$10] ; # Y
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (pair (shift X))
  %27 = and i64 %26, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$9
$8:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
; # (car X)
  %31 = inttoptr i64 %29 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  br label %$10
$11:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$14, label %$13
$14:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$10
$13:
  %39 = call i64 @evList(i64 %32)
  br label %$10
$10:
  %40 = phi i64 [%32, %$12], [%38, %$14], [%39, %$13] ; # ->
; # (getn Exe Y (eval (car X)))
  %41 = call i64 @getn(i64 %0, i64 %30, i64 %40)
; # (safe (getn Exe Y (eval (car X))))
  %42 = inttoptr i64 %15 to i64*
  store i64 %41, i64* %42
  br label %$7
$9:
  %43 = phi i64 [%26, %$7] ; # X
  %44 = phi i64 [%23, %$7] ; # Y
; # (when (sym? (setq X (val (tail (needSymb Exe Y))))) (dbFetch Exe ...
; # (needSymb Exe Y)
  %45 = xor i64 %44, 8
  %46 = and i64 %45, 14
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %$16, label %$15
$15:
  call void @symErr(i64 %0, i64 %44)
  unreachable
$16:
; # (tail (needSymb Exe Y))
  %48 = add i64 %44, -8
; # (val (tail (needSymb Exe Y)))
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (sym? (setq X (val (tail (needSymb Exe Y)))))
  %51 = and i64 %50, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$17, label %$18
$17:
  %53 = phi i64 [%50, %$16] ; # X
  %54 = phi i64 [%44, %$16] ; # Y
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %54)
; # (tail Y)
  %55 = add i64 %54, -8
; # (val (tail Y))
  %56 = inttoptr i64 %55 to i64*
  %57 = load i64, i64* %56
; # (& (val (tail Y)) -9)
  %58 = and i64 %57, -9
  br label %$18
$18:
  %59 = phi i64 [%50, %$16], [%58, %$17] ; # X
  %60 = phi i64 [%44, %$16], [%54, %$17] ; # Y
; # (if (num? X) $Nil (let R (setq Y (cons (car X) $Nil)) (link (push...
; # (num? X)
  %61 = and i64 %59, 6
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$20
$19:
  %63 = phi i64 [%59, %$18] ; # X
  %64 = phi i64 [%60, %$18] ; # Y
  br label %$21
$20:
  %65 = phi i64 [%59, %$18] ; # X
  %66 = phi i64 [%60, %$18] ; # Y
; # (let R (setq Y (cons (car X) $Nil)) (link (push R NIL)) (while (p...
; # (car X)
  %67 = inttoptr i64 %65 to i64*
  %68 = load i64, i64* %67
; # (cons (car X) $Nil)
  %69 = call i64 @cons(i64 %68, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (push R NIL)
  %70 = alloca i64, i64 2, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = inttoptr i64 %71 to i64*
  store i64 %69, i64* %72
; # (link (push R NIL))
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %74 = load i64, i64* %73
  %75 = inttoptr i64 %71 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %74, i64* %76
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %77
; # (while (pair (shift X)) (setq Y (set 2 Y (cons (car X) $Nil))))
  br label %$22
$22:
  %78 = phi i64 [%65, %$20], [%85, %$23] ; # X
  %79 = phi i64 [%69, %$20], [%89, %$23] ; # Y
; # (shift X)
  %80 = inttoptr i64 %78 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  %82 = load i64, i64* %81
; # (pair (shift X))
  %83 = and i64 %82, 15
  %84 = icmp eq i64 %83, 0
  br i1 %84, label %$23, label %$24
$23:
  %85 = phi i64 [%82, %$22] ; # X
  %86 = phi i64 [%79, %$22] ; # Y
; # (set 2 Y (cons (car X) $Nil))
; # (car X)
  %87 = inttoptr i64 %85 to i64*
  %88 = load i64, i64* %87
; # (cons (car X) $Nil)
  %89 = call i64 @cons(i64 %88, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %90 = inttoptr i64 %86 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %89, i64* %91
  br label %$22
$24:
  %92 = phi i64 [%82, %$22] ; # X
  %93 = phi i64 [%79, %$22] ; # Y
  br label %$21
$21:
  %94 = phi i64 [%63, %$19], [%92, %$24] ; # X
  %95 = phi i64 [%64, %$19], [%93, %$24] ; # Y
  %96 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$19], [%69, %$24] ; # ->
; # (drop *Safe)
  %97 = inttoptr i64 %15 to i64*
  %98 = getelementptr i64, i64* %97, i32 1
  %99 = load i64, i64* %98
  %100 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %99, i64* %100
  ret i64 %96
}

define void @wipe(i64, i64) {
$1:
; # (let (Tail (val (tail (needSymb Exe X))) Nm (name (& Tail -9))) (...
; # (needSymb Exe X)
  %2 = xor i64 %1, 8
  %3 = and i64 %2, 14
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$3, label %$2
$2:
  call void @symErr(i64 %0, i64 %1)
  unreachable
$3:
; # (tail (needSymb Exe X))
  %5 = add i64 %1, -8
; # (val (tail (needSymb Exe X)))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (& Tail -9)
  %8 = and i64 %7, -9
; # (name (& Tail -9))
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%15, %$5] ; # Tail
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$5:
  %12 = phi i64 [%9, %$4] ; # Tail
  %13 = inttoptr i64 %12 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
  br label %$4
$6:
  %16 = phi i64 [%9, %$4] ; # Tail
; # (if (sym? Tail) (let N (add Nm Nm) (unless @@ (add N N) (when @@ ...
; # (sym? Tail)
  %17 = and i64 %7, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$7, label %$8
$7:
; # (let N (add Nm Nm) (unless @@ (add N N) (when @@ (set X $Nil (tai...
; # (add Nm Nm)
  %19 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %16, i64 %16)
  %20 = extractvalue {i64, i1} %19, 1
  %21 = extractvalue {i64, i1} %19, 0
; # (unless @@ (add N N) (when @@ (set X $Nil (tail X) Nm)))
  br i1 %20, label %$11, label %$10
$10:
; # (add N N)
  %22 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %21, i64 %21)
  %23 = extractvalue {i64, i1} %22, 1
  %24 = extractvalue {i64, i1} %22, 0
; # (when @@ (set X $Nil (tail X) Nm))
  br i1 %23, label %$12, label %$13
$12:
; # (set X $Nil (tail X) Nm)
  %25 = inttoptr i64 %1 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %25
; # (tail X)
  %26 = add i64 %1, -8
  %27 = inttoptr i64 %26 to i64*
  store i64 %16, i64* %27
  br label %$13
$13:
  br label %$11
$11:
  br label %$9
$8:
; # (set X $Nil (tail X) Nm)
  %28 = inttoptr i64 %1 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %28
; # (tail X)
  %29 = add i64 %1, -8
  %30 = inttoptr i64 %29 to i64*
  store i64 %16, i64* %30
  br label %$9
$9:
  ret void
}

define i64 @_wipe(i64) {
$1:
; # (let X (eval (cadr Exe)) (unless (nil? X) (if (atom X) (wipe Exe ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (unless (nil? X) (if (atom X) (wipe Exe X) (let Y X (loop (wipe E...
; # (nil? X)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$8, label %$7
$7:
; # (if (atom X) (wipe Exe X) (let Y X (loop (wipe Exe (++ Y)) (? (at...
; # (atom X)
  %15 = and i64 %13, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$10
$9:
; # (wipe Exe X)
  call void @wipe(i64 %0, i64 %13)
  br label %$11
$10:
; # (let Y X (loop (wipe Exe (++ Y)) (? (atom Y))))
; # (loop (wipe Exe (++ Y)) (? (atom Y)))
  br label %$12
$12:
  %17 = phi i64 [%13, %$10], [%24, %$13] ; # Y
; # (++ Y)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
; # (wipe Exe (++ Y))
  call void @wipe(i64 %0, i64 %19)
; # (? (atom Y))
; # (atom Y)
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$13
$13:
  %24 = phi i64 [%21, %$12] ; # Y
  br label %$12
$14:
  %25 = phi i64 [%21, %$12] ; # Y
  %26 = phi i64 [0, %$12] ; # ->
  br label %$11
$11:
  br label %$8
$8:
  ret i64 %13
}

define i64 @meta(i64, i64) {
$1:
; # (loop (? (atom X) $Nil) (let Y (car X) (when (symb? Y) (? (not (n...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%31, %$7] ; # X
; # (? (atom X) $Nil)
; # (atom X)
  %3 = and i64 %2, 15
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$5, label %$3
$5:
  %5 = phi i64 [%2, %$2] ; # X
  br label %$4
$3:
  %6 = phi i64 [%2, %$2] ; # X
; # (let Y (car X) (when (symb? Y) (? (not (nil? (get Y Key))) @) (st...
; # (car X)
  %7 = inttoptr i64 %6 to i64*
  %8 = load i64, i64* %7
; # (when (symb? Y) (? (not (nil? (get Y Key))) @) (stkChk 0) (? (not...
; # (symb? Y)
  %9 = xor i64 %8, 8
  %10 = and i64 %9, 14
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$6, label %$7
$6:
  %12 = phi i64 [%6, %$3] ; # X
; # (? (not (nil? (get Y Key))) @)
; # (get Y Key)
  %13 = call i64 @get(i64 %8, i64 %1)
; # (nil? (get Y Key))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (get Y Key)))
  %15 = icmp eq i1 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%12, %$6] ; # X
  br label %$4
$8:
  %17 = phi i64 [%12, %$6] ; # X
; # (stkChk 0)
  %18 = load i8*, i8** @$StkLimit
  %19 = call i8* @llvm.stacksave()
  %20 = icmp ugt i8* %18, %19
  br i1 %20, label %$10, label %$11
$10:
  call void @stkErr(i64 0)
  unreachable
$11:
; # (? (not (nil? (meta (car Y) Key))) @)
; # (car Y)
  %21 = inttoptr i64 %8 to i64*
  %22 = load i64, i64* %21
; # (meta (car Y) Key)
  %23 = call i64 @meta(i64 %22, i64 %1)
; # (nil? (meta (car Y) Key))
  %24 = icmp eq i64 %23, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (meta (car Y) Key)))
  %25 = icmp eq i1 %24, 0
  br i1 %25, label %$13, label %$12
$13:
  %26 = phi i64 [%17, %$11] ; # X
  br label %$4
$12:
  %27 = phi i64 [%17, %$11] ; # X
  br label %$7
$7:
  %28 = phi i64 [%6, %$3], [%27, %$12] ; # X
; # (shift X)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  br label %$2
$4:
  %32 = phi i64 [%5, %$5], [%16, %$9], [%26, %$13] ; # X
  %33 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%13, %$9], [%23, %$13] ; # ->
  ret i64 %33
}

define i64 @_meta(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X)))) (when (num? Y) (argErr ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (when (num? Y) (argErr Exe Y))
; # (num? Y)
  %24 = and i64 %15, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$7, label %$8
$7:
  %26 = phi i64 [%7, %$2] ; # X
  %27 = phi i64 [%15, %$2] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %27)
  unreachable
$8:
  %28 = phi i64 [%7, %$2] ; # X
  %29 = phi i64 [%15, %$2] ; # Y
; # (when (sym? Y) (when (sym? (val (tail Y))) (dbFetch Exe Y)) (setq...
; # (sym? Y)
  %30 = and i64 %29, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$9, label %$10
$9:
  %32 = phi i64 [%28, %$8] ; # X
  %33 = phi i64 [%29, %$8] ; # Y
; # (when (sym? (val (tail Y))) (dbFetch Exe Y))
; # (tail Y)
  %34 = add i64 %33, -8
; # (val (tail Y))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (sym? (val (tail Y)))
  %37 = and i64 %36, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$11, label %$12
$11:
  %39 = phi i64 [%32, %$9] ; # X
  %40 = phi i64 [%33, %$9] ; # Y
; # (dbFetch Exe Y)
  call void @dbFetch(i64 %0, i64 %40)
  br label %$12
$12:
  %41 = phi i64 [%32, %$9], [%39, %$11] ; # X
  %42 = phi i64 [%33, %$9], [%40, %$11] ; # Y
; # (val Y)
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  br label %$10
$10:
  %45 = phi i64 [%28, %$8], [%41, %$12] ; # X
  %46 = phi i64 [%29, %$8], [%44, %$12] ; # Y
; # (car X)
  %47 = inttoptr i64 %45 to i64*
  %48 = load i64, i64* %47
; # (eval (car X))
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$15, label %$14
$15:
  br label %$13
$14:
  %51 = and i64 %48, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$17, label %$16
$17:
  %53 = inttoptr i64 %48 to i64*
  %54 = load i64, i64* %53
  br label %$13
$16:
  %55 = call i64 @evList(i64 %48)
  br label %$13
$13:
  %56 = phi i64 [%48, %$15], [%54, %$17], [%55, %$16] ; # ->
; # (meta Y (eval (car X)))
  %57 = call i64 @meta(i64 %46, i64 %56)
; # (while (pair (shift X)) (safe Y) (setq Y (getn Exe Y (eval (car X...
  br label %$18
$18:
  %58 = phi i64 [%45, %$13], [%65, %$21] ; # X
  %59 = phi i64 [%57, %$13], [%78, %$21] ; # Y
; # (shift X)
  %60 = inttoptr i64 %58 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
; # (pair (shift X))
  %63 = and i64 %62, 15
  %64 = icmp eq i64 %63, 0
  br i1 %64, label %$19, label %$20
$19:
  %65 = phi i64 [%62, %$18] ; # X
  %66 = phi i64 [%59, %$18] ; # Y
; # (safe Y)
  %67 = inttoptr i64 %17 to i64*
  store i64 %66, i64* %67
; # (car X)
  %68 = inttoptr i64 %65 to i64*
  %69 = load i64, i64* %68
; # (eval (car X))
  %70 = and i64 %69, 6
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$23, label %$22
$23:
  br label %$21
$22:
  %72 = and i64 %69, 8
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$25, label %$24
$25:
  %74 = inttoptr i64 %69 to i64*
  %75 = load i64, i64* %74
  br label %$21
$24:
  %76 = call i64 @evList(i64 %69)
  br label %$21
$21:
  %77 = phi i64 [%69, %$23], [%75, %$25], [%76, %$24] ; # ->
; # (getn Exe Y (eval (car X)))
  %78 = call i64 @getn(i64 %0, i64 %66, i64 %77)
  br label %$18
$20:
  %79 = phi i64 [%62, %$18] ; # X
  %80 = phi i64 [%59, %$18] ; # Y
; # (drop *Safe)
  %81 = inttoptr i64 %17 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_lowQ(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (isLowc (firstChar X)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (isLowc (firstChar X))) X $Nil)
; # (and (symb? X) (isLowc (firstChar X)))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (firstChar X)
  %17 = call i32 @firstChar(i64 %13)
; # (isLowc (firstChar X))
  %18 = call i1 @isLowc(i32 %17)
  br label %$7
$7:
  %19 = phi i1 [0, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_uppQ(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (isUppc (firstChar X)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (isUppc (firstChar X))) X $Nil)
; # (and (symb? X) (isUppc (firstChar X)))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (firstChar X)
  %17 = call i32 @firstChar(i64 %13)
; # (isUppc (firstChar X))
  %18 = call i1 @isUppc(i32 %17)
  br label %$7
$7:
  %19 = phi i1 [0, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %20 = phi i64 [%13, %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %20
}

define i64 @_lowc(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (or (not (symb? X)) (nil? X)) X (let...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (not (symb? X)) (nil? X)) X (let (P (push 0 (xName Exe X)...
; # (or (not (symb? X)) (nil? X))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$7, label %$8
$8:
; # (nil? X)
  %18 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %19 = phi i1 [1, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (P (push 0 (xName Exe X) NIL) Q (link (ofs P 1) T) R (push 4...
; # (xName Exe X)
  %20 = call i64 @xName(i64 %0, i64 %13)
; # (push 0 (xName Exe X) NIL)
  %21 = alloca i64, i64 3, align 16
  store i64 0, i64* %21
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
; # (ofs P 1)
  %23 = getelementptr i64, i64* %21, i32 1
; # (link (ofs P 1) T)
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
; # (push 4 NIL ZERO NIL)
  %30 = alloca i64, i64 4, align 16
  store i64 4, i64* %30
  %31 = getelementptr i64, i64* %30, i32 2
  store i64 2, i64* %31
; # (ofs R 2)
  %32 = getelementptr i64, i64* %30, i32 2
; # (link (ofs R 2))
  %33 = ptrtoint i64* %32 to i64
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %33 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %33, i64* %38
; # (while (setq C (symChar P)) (charSym (toLowerCase C) R))
  br label %$12
$12:
; # (symChar P)
  %39 = call i32 @symChar(i64* %21)
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %$13, label %$14
$13:
  %41 = phi i32 [%39, %$12] ; # C
; # (toLowerCase C)
  %42 = call i32 @toLowerCase(i32 %41)
; # (charSym (toLowerCase C) R)
  call void @charSym(i32 %42, i64* %30)
  br label %$12
$14:
  %43 = phi i32 [%39, %$12] ; # C
; # (val 3 R)
  %44 = getelementptr i64, i64* %30, i32 2
  %45 = load i64, i64* %44
; # (consStr (val 3 R))
  %46 = call i64 @consStr(i64 %45)
; # (drop *Safe)
  %47 = inttoptr i64 %24 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %50
  br label %$11
$11:
  %51 = phi i64 [%13, %$9], [%46, %$14] ; # ->
  ret i64 %51
}

define i64 @_uppc(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (or (not (symb? X)) (nil? X)) X (let...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (not (symb? X)) (nil? X)) X (let (P (push 0 (xName Exe X)...
; # (or (not (symb? X)) (nil? X))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
; # (not (symb? X))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$7, label %$8
$8:
; # (nil? X)
  %18 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %19 = phi i1 [1, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (P (push 0 (xName Exe X) NIL) Q (link (ofs P 1) T) R (push 4...
; # (xName Exe X)
  %20 = call i64 @xName(i64 %0, i64 %13)
; # (push 0 (xName Exe X) NIL)
  %21 = alloca i64, i64 3, align 16
  store i64 0, i64* %21
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
; # (ofs P 1)
  %23 = getelementptr i64, i64* %21, i32 1
; # (link (ofs P 1) T)
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
; # (push 4 NIL ZERO NIL)
  %30 = alloca i64, i64 4, align 16
  store i64 4, i64* %30
  %31 = getelementptr i64, i64* %30, i32 2
  store i64 2, i64* %31
; # (ofs R 2)
  %32 = getelementptr i64, i64* %30, i32 2
; # (link (ofs R 2))
  %33 = ptrtoint i64* %32 to i64
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %33 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %33, i64* %38
; # (while (setq C (symChar P)) (ifn (== C (char "")) (charSym (toUp...
  br label %$12
$12:
; # (symChar P)
  %39 = call i32 @symChar(i64* %21)
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %$13, label %$14
$13:
  %41 = phi i32 [%39, %$12] ; # C
; # (ifn (== C (char "")) (charSym (toUpperCase C) R) (charSym (char...
; # (== C (char ""))
  %42 = icmp eq i32 %41, 223
  br i1 %42, label %$16, label %$15
$15:
  %43 = phi i32 [%41, %$13] ; # C
; # (toUpperCase C)
  %44 = call i32 @toUpperCase(i32 %43)
; # (charSym (toUpperCase C) R)
  call void @charSym(i32 %44, i64* %30)
  br label %$17
$16:
  %45 = phi i32 [%41, %$13] ; # C
; # (charSym (char "S") R)
  call void @charSym(i32 83, i64* %30)
; # (charSym (char "S") R)
  call void @charSym(i32 83, i64* %30)
  br label %$17
$17:
  %46 = phi i32 [%43, %$15], [%45, %$16] ; # C
  br label %$12
$14:
  %47 = phi i32 [%39, %$12] ; # C
; # (val 3 R)
  %48 = getelementptr i64, i64* %30, i32 2
  %49 = load i64, i64* %48
; # (consStr (val 3 R))
  %50 = call i64 @consStr(i64 %49)
; # (drop *Safe)
  %51 = inttoptr i64 %24 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %53, i64* %54
  br label %$11
$11:
  %55 = phi i64 [%13, %$9], [%50, %$14] ; # ->
  ret i64 %55
}

define i64 @_fold(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (if (or (not (symb? Y)) (nil? ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (if (or (not (symb? Y)) (nil? Y)) Y (let (N (if (atom X) 0 (evCnt...
; # (or (not (symb? Y)) (nil? Y))
; # (symb? Y)
  %16 = xor i64 %15, 8
  %17 = and i64 %16, 14
  %18 = icmp eq i64 %17, 0
; # (not (symb? Y))
  %19 = icmp eq i1 %18, 0
  br i1 %19, label %$7, label %$8
$8:
; # (nil? Y)
  %20 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %21 = phi i1 [1, %$2], [%20, %$8] ; # ->
  br i1 %21, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let (N (if (atom X) 0 (evCnt Exe X)) P (push 0 (xName Exe Y) NIL...
; # (if (atom X) 0 (evCnt Exe X))
; # (atom X)
  %22 = and i64 %7, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$13
$12:
  br label %$14
$13:
; # (evCnt Exe X)
  %24 = call i64 @evCnt(i64 %0, i64 %7)
  br label %$14
$14:
  %25 = phi i64 [0, %$12], [%24, %$13] ; # ->
; # (xName Exe Y)
  %26 = call i64 @xName(i64 %0, i64 %15)
; # (push 0 (xName Exe Y) NIL)
  %27 = alloca i64, i64 3, align 16
  store i64 0, i64* %27
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
; # (ofs P 1)
  %29 = getelementptr i64, i64* %27, i32 1
; # (link (ofs P 1) T)
  %30 = ptrtoint i64* %29 to i64
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %30 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %35
; # (push 4 NIL ZERO NIL)
  %36 = alloca i64, i64 4, align 16
  store i64 4, i64* %36
  %37 = getelementptr i64, i64* %36, i32 2
  store i64 2, i64* %37
; # (ofs R 2)
  %38 = getelementptr i64, i64* %36, i32 2
; # (link (ofs R 2))
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = inttoptr i64 %39 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  store i64 %41, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %44
; # (while (setq C (symChar P)) (when (isLetterOrDigit C) (charSym (t...
  br label %$15
$15:
  %45 = phi i64 [%25, %$14], [%58, %$19] ; # N
; # (symChar P)
  %46 = call i32 @symChar(i64* %27)
  %47 = icmp ne i32 %46, 0
  br i1 %47, label %$16, label %$17
$16:
  %48 = phi i64 [%45, %$15] ; # N
  %49 = phi i32 [%46, %$15] ; # C
; # (when (isLetterOrDigit C) (charSym (toLowerCase C) R) (? (=0 (dec...
; # (isLetterOrDigit C)
  %50 = call i1 @isLetterOrDigit(i32 %49)
  br i1 %50, label %$18, label %$19
$18:
  %51 = phi i64 [%48, %$16] ; # N
  %52 = phi i32 [%49, %$16] ; # C
; # (toLowerCase C)
  %53 = call i32 @toLowerCase(i32 %52)
; # (charSym (toLowerCase C) R)
  call void @charSym(i32 %53, i64* %36)
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %54 = sub i64 %51, 1
; # (=0 (dec 'N))
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %$17, label %$20
$20:
  %56 = phi i64 [%54, %$18] ; # N
  %57 = phi i32 [%52, %$18] ; # C
  br label %$19
$19:
  %58 = phi i64 [%48, %$16], [%56, %$20] ; # N
  %59 = phi i32 [%49, %$16], [%57, %$20] ; # C
  br label %$15
$17:
  %60 = phi i64 [%45, %$15], [%54, %$18] ; # N
  %61 = phi i32 [%46, %$15], [%52, %$18] ; # C
; # (val 3 R)
  %62 = getelementptr i64, i64* %36, i32 2
  %63 = load i64, i64* %62
; # (consStr (val 3 R))
  %64 = call i64 @consStr(i64 %63)
; # (drop *Safe)
  %65 = inttoptr i64 %30 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %68
  br label %$11
$11:
  %69 = phi i64 [%15, %$9], [%64, %$17] ; # ->
  ret i64 %69
}

define i1 @equal(i64, i64) {
$1:
; # (cond ((== X Y) YES) ((cnt? X) NO) ((big? X) (if (cnt? Y) NO (whe...
; # (== X Y)
  %2 = icmp eq i64 %0, %1
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
  %4 = phi i64 [%1, %$1] ; # Y
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
  %6 = phi i64 [%1, %$1] ; # Y
; # (cnt? X)
  %7 = and i64 %5, 2
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i64 [%5, %$3] ; # X
  %10 = phi i64 [%6, %$3] ; # Y
  br label %$2
$5:
  %11 = phi i64 [%5, %$3] ; # X
  %12 = phi i64 [%6, %$3] ; # Y
; # (big? X)
  %13 = and i64 %11, 4
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  %15 = phi i64 [%11, %$5] ; # X
  %16 = phi i64 [%12, %$5] ; # Y
; # (if (cnt? Y) NO (when (sign? X) (unless (sign? Y) (ret NO)) (setq...
; # (cnt? Y)
  %17 = and i64 %16, 2
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$9, label %$10
$9:
  %19 = phi i64 [%15, %$8] ; # X
  %20 = phi i64 [%16, %$8] ; # Y
  br label %$11
$10:
  %21 = phi i64 [%15, %$8] ; # X
  %22 = phi i64 [%16, %$8] ; # Y
; # (when (sign? X) (unless (sign? Y) (ret NO)) (setq X (pos X) Y (po...
; # (sign? X)
  %23 = and i64 %21, 8
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$13
$12:
  %25 = phi i64 [%21, %$10] ; # X
  %26 = phi i64 [%22, %$10] ; # Y
; # (unless (sign? Y) (ret NO))
; # (sign? Y)
  %27 = and i64 %26, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$14:
  %29 = phi i64 [%25, %$12] ; # X
  %30 = phi i64 [%26, %$12] ; # Y
; # (ret NO)
  ret i1 0
$15:
  %31 = phi i64 [%25, %$12] ; # X
  %32 = phi i64 [%26, %$12] ; # Y
; # (pos X)
  %33 = and i64 %31, -9
; # (pos Y)
  %34 = and i64 %32, -9
  br label %$13
$13:
  %35 = phi i64 [%21, %$10], [%33, %$15] ; # X
  %36 = phi i64 [%22, %$10], [%34, %$15] ; # Y
; # (equalBig X Y)
  br label %$16
$16:
  %37 = phi i64 [%35, %$13], [%71, %$24] ; # X
  %38 = phi i64 [%36, %$13], [%72, %$24] ; # Y
  %39 = add i64 %37, -4
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
  %42 = add i64 %38, -4
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
  %45 = icmp ne i64 %41, %44
  br i1 %45, label %$19, label %$17
$19:
  %46 = phi i64 [%37, %$16] ; # X
  %47 = phi i64 [%38, %$16] ; # Y
  br label %$18
$17:
  %48 = phi i64 [%37, %$16] ; # X
  %49 = phi i64 [%38, %$16] ; # Y
  %50 = add i64 %48, 4
  %51 = inttoptr i64 %50 to i64*
  %52 = load i64, i64* %51
  %53 = add i64 %49, 4
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
  %56 = icmp eq i64 %52, %55
  br i1 %56, label %$21, label %$20
$21:
  %57 = phi i64 [%52, %$17] ; # X
  %58 = phi i64 [%55, %$17] ; # Y
  br label %$18
$20:
  %59 = phi i64 [%52, %$17] ; # X
  %60 = phi i64 [%55, %$17] ; # Y
  %61 = and i64 %59, 2
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$23, label %$22
$23:
  %63 = phi i64 [%59, %$20] ; # X
  %64 = phi i64 [%60, %$20] ; # Y
  br label %$18
$22:
  %65 = phi i64 [%59, %$20] ; # X
  %66 = phi i64 [%60, %$20] ; # Y
  %67 = and i64 %66, 2
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$25, label %$24
$25:
  %69 = phi i64 [%65, %$22] ; # X
  %70 = phi i64 [%66, %$22] ; # Y
  br label %$18
$24:
  %71 = phi i64 [%65, %$22] ; # X
  %72 = phi i64 [%66, %$22] ; # Y
  br label %$16
$18:
  %73 = phi i64 [%46, %$19], [%57, %$21], [%63, %$23], [%69, %$25] ; # X
  %74 = phi i64 [%47, %$19], [%58, %$21], [%64, %$23], [%70, %$25] ; # Y
  %75 = phi i1 [0, %$19], [1, %$21], [0, %$23], [0, %$25] ; # ->
  br label %$11
$11:
  %76 = phi i64 [%19, %$9], [%35, %$18] ; # X
  %77 = phi i64 [%20, %$9], [%36, %$18] ; # Y
  %78 = phi i1 [0, %$9], [%75, %$18] ; # ->
  br label %$2
$7:
  %79 = phi i64 [%11, %$5] ; # X
  %80 = phi i64 [%12, %$5] ; # Y
; # (sym? X)
  %81 = and i64 %79, 8
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$27, label %$26
$27:
  %83 = phi i64 [%79, %$7] ; # X
  %84 = phi i64 [%80, %$7] ; # Y
; # (cond ((num? Y) NO) ((pair Y) NO) ((sym? (val (tail X))) NO) ((==...
; # (num? Y)
  %85 = and i64 %84, 6
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$30, label %$29
$30:
  %87 = phi i64 [%83, %$27] ; # X
  %88 = phi i64 [%84, %$27] ; # Y
  br label %$28
$29:
  %89 = phi i64 [%83, %$27] ; # X
  %90 = phi i64 [%84, %$27] ; # Y
; # (pair Y)
  %91 = and i64 %90, 15
  %92 = icmp eq i64 %91, 0
  br i1 %92, label %$32, label %$31
$32:
  %93 = phi i64 [%89, %$29] ; # X
  %94 = phi i64 [%90, %$29] ; # Y
  br label %$28
$31:
  %95 = phi i64 [%89, %$29] ; # X
  %96 = phi i64 [%90, %$29] ; # Y
; # (tail X)
  %97 = add i64 %95, -8
; # (val (tail X))
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
; # (sym? (val (tail X)))
  %100 = and i64 %99, 8
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$34, label %$33
$34:
  %102 = phi i64 [%95, %$31] ; # X
  %103 = phi i64 [%96, %$31] ; # Y
  br label %$28
$33:
  %104 = phi i64 [%95, %$31] ; # X
  %105 = phi i64 [%96, %$31] ; # Y
; # (name @)
  br label %$35
$35:
  %106 = phi i64 [%99, %$33], [%112, %$36] ; # Tail
  %107 = and i64 %106, 6
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$37, label %$36
$36:
  %109 = phi i64 [%106, %$35] ; # Tail
  %110 = inttoptr i64 %109 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  %112 = load i64, i64* %111
  br label %$35
$37:
  %113 = phi i64 [%106, %$35] ; # Tail
; # (== ZERO (setq X (name @)))
  %114 = icmp eq i64 2, %113
  br i1 %114, label %$39, label %$38
$39:
  %115 = phi i64 [%113, %$37] ; # X
  %116 = phi i64 [%105, %$37] ; # Y
  br label %$28
$38:
  %117 = phi i64 [%113, %$37] ; # X
  %118 = phi i64 [%105, %$37] ; # Y
; # (tail Y)
  %119 = add i64 %118, -8
; # (val (tail Y))
  %120 = inttoptr i64 %119 to i64*
  %121 = load i64, i64* %120
; # (sym? (val (tail Y)))
  %122 = and i64 %121, 8
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$41, label %$40
$41:
  %124 = phi i64 [%117, %$38] ; # X
  %125 = phi i64 [%118, %$38] ; # Y
  br label %$28
$40:
  %126 = phi i64 [%117, %$38] ; # X
  %127 = phi i64 [%118, %$38] ; # Y
; # (name @)
  br label %$42
$42:
  %128 = phi i64 [%121, %$40], [%134, %$43] ; # Tail
  %129 = and i64 %128, 6
  %130 = icmp ne i64 %129, 0
  br i1 %130, label %$44, label %$43
$43:
  %131 = phi i64 [%128, %$42] ; # Tail
  %132 = inttoptr i64 %131 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
  br label %$42
$44:
  %135 = phi i64 [%128, %$42] ; # Tail
; # (== ZERO (setq Y (name @)))
  %136 = icmp eq i64 2, %135
  br i1 %136, label %$46, label %$45
$46:
  %137 = phi i64 [%126, %$44] ; # X
  %138 = phi i64 [%135, %$44] ; # Y
  br label %$28
$45:
  %139 = phi i64 [%126, %$44] ; # X
  %140 = phi i64 [%135, %$44] ; # Y
; # (== X Y)
  %141 = icmp eq i64 %139, %140
  br i1 %141, label %$48, label %$47
$48:
  %142 = phi i64 [%139, %$45] ; # X
  %143 = phi i64 [%140, %$45] ; # Y
  br label %$28
$47:
  %144 = phi i64 [%139, %$45] ; # X
  %145 = phi i64 [%140, %$45] ; # Y
; # (cnt? X)
  %146 = and i64 %144, 2
  %147 = icmp ne i64 %146, 0
  br i1 %147, label %$50, label %$49
$50:
  %148 = phi i64 [%144, %$47] ; # X
  %149 = phi i64 [%145, %$47] ; # Y
  br label %$28
$49:
  %150 = phi i64 [%144, %$47] ; # X
  %151 = phi i64 [%145, %$47] ; # Y
; # (cnt? Y)
  %152 = and i64 %151, 2
  %153 = icmp ne i64 %152, 0
  br i1 %153, label %$52, label %$51
$52:
  %154 = phi i64 [%150, %$49] ; # X
  %155 = phi i64 [%151, %$49] ; # Y
  br label %$28
$51:
  %156 = phi i64 [%150, %$49] ; # X
  %157 = phi i64 [%151, %$49] ; # Y
; # (equalBig X Y)
  br label %$53
$53:
  %158 = phi i64 [%156, %$51], [%192, %$61] ; # X
  %159 = phi i64 [%157, %$51], [%193, %$61] ; # Y
  %160 = add i64 %158, -4
  %161 = inttoptr i64 %160 to i64*
  %162 = load i64, i64* %161
  %163 = add i64 %159, -4
  %164 = inttoptr i64 %163 to i64*
  %165 = load i64, i64* %164
  %166 = icmp ne i64 %162, %165
  br i1 %166, label %$56, label %$54
$56:
  %167 = phi i64 [%158, %$53] ; # X
  %168 = phi i64 [%159, %$53] ; # Y
  br label %$55
$54:
  %169 = phi i64 [%158, %$53] ; # X
  %170 = phi i64 [%159, %$53] ; # Y
  %171 = add i64 %169, 4
  %172 = inttoptr i64 %171 to i64*
  %173 = load i64, i64* %172
  %174 = add i64 %170, 4
  %175 = inttoptr i64 %174 to i64*
  %176 = load i64, i64* %175
  %177 = icmp eq i64 %173, %176
  br i1 %177, label %$58, label %$57
$58:
  %178 = phi i64 [%173, %$54] ; # X
  %179 = phi i64 [%176, %$54] ; # Y
  br label %$55
$57:
  %180 = phi i64 [%173, %$54] ; # X
  %181 = phi i64 [%176, %$54] ; # Y
  %182 = and i64 %180, 2
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$60, label %$59
$60:
  %184 = phi i64 [%180, %$57] ; # X
  %185 = phi i64 [%181, %$57] ; # Y
  br label %$55
$59:
  %186 = phi i64 [%180, %$57] ; # X
  %187 = phi i64 [%181, %$57] ; # Y
  %188 = and i64 %187, 2
  %189 = icmp ne i64 %188, 0
  br i1 %189, label %$62, label %$61
$62:
  %190 = phi i64 [%186, %$59] ; # X
  %191 = phi i64 [%187, %$59] ; # Y
  br label %$55
$61:
  %192 = phi i64 [%186, %$59] ; # X
  %193 = phi i64 [%187, %$59] ; # Y
  br label %$53
$55:
  %194 = phi i64 [%167, %$56], [%178, %$58], [%184, %$60], [%190, %$62] ; # X
  %195 = phi i64 [%168, %$56], [%179, %$58], [%185, %$60], [%191, %$62] ; # Y
  %196 = phi i1 [0, %$56], [1, %$58], [0, %$60], [0, %$62] ; # ->
  br label %$28
$28:
  %197 = phi i64 [%87, %$30], [%93, %$32], [%102, %$34], [%115, %$39], [%124, %$41], [%137, %$46], [%142, %$48], [%148, %$50], [%154, %$52], [%156, %$55] ; # X
  %198 = phi i64 [%88, %$30], [%94, %$32], [%103, %$34], [%116, %$39], [%125, %$41], [%138, %$46], [%143, %$48], [%149, %$50], [%155, %$52], [%157, %$55] ; # Y
  %199 = phi i1 [0, %$30], [0, %$32], [0, %$34], [0, %$39], [0, %$41], [0, %$46], [1, %$48], [0, %$50], [0, %$52], [%196, %$55] ; # ->
  br label %$2
$26:
  %200 = phi i64 [%79, %$7] ; # X
  %201 = phi i64 [%80, %$7] ; # Y
; # (atom Y)
  %202 = and i64 %201, 15
  %203 = icmp ne i64 %202, 0
  br i1 %203, label %$64, label %$63
$64:
  %204 = phi i64 [%200, %$26] ; # X
  %205 = phi i64 [%201, %$26] ; # Y
  br label %$2
$63:
  %206 = phi i64 [%200, %$26] ; # X
  %207 = phi i64 [%201, %$26] ; # Y
; # (stkChk 0)
  %208 = load i8*, i8** @$StkLimit
  %209 = call i8* @llvm.stacksave()
  %210 = icmp ugt i8* %208, %209
  br i1 %210, label %$65, label %$66
$65:
  call void @stkErr(i64 0)
  unreachable
$66:
; # (let (A X B Y) (prog1 (loop (? (not (equal (car X) (& (car Y) -2)...
; # (prog1 (loop (? (not (equal (car X) (& (car Y) -2))) NO) (? (atom...
; # (loop (? (not (equal (car X) (& (car Y) -2))) NO) (? (atom (cdr X...
  br label %$67
$67:
  %211 = phi i64 [%206, %$66], [%373, %$75] ; # X
  %212 = phi i64 [%207, %$66], [%374, %$75] ; # Y
  %213 = phi i64 [%206, %$66], [%375, %$75] ; # A
  %214 = phi i64 [%207, %$66], [%376, %$75] ; # B
; # (? (not (equal (car X) (& (car Y) -2))) NO)
; # (car X)
  %215 = inttoptr i64 %211 to i64*
  %216 = load i64, i64* %215
; # (car Y)
  %217 = inttoptr i64 %212 to i64*
  %218 = load i64, i64* %217
; # (& (car Y) -2)
  %219 = and i64 %218, -2
; # (equal (car X) (& (car Y) -2))
  %220 = call i1 @equal(i64 %216, i64 %219)
; # (not (equal (car X) (& (car Y) -2)))
  %221 = icmp eq i1 %220, 0
  br i1 %221, label %$70, label %$68
$70:
  %222 = phi i64 [%211, %$67] ; # X
  %223 = phi i64 [%212, %$67] ; # Y
  %224 = phi i64 [%213, %$67] ; # A
  %225 = phi i64 [%214, %$67] ; # B
  br label %$69
$68:
  %226 = phi i64 [%211, %$67] ; # X
  %227 = phi i64 [%212, %$67] ; # Y
  %228 = phi i64 [%213, %$67] ; # A
  %229 = phi i64 [%214, %$67] ; # B
; # (? (atom (cdr X)) (equal (cdr X) (cdr Y)))
; # (cdr X)
  %230 = inttoptr i64 %226 to i64*
  %231 = getelementptr i64, i64* %230, i32 1
  %232 = load i64, i64* %231
; # (atom (cdr X))
  %233 = and i64 %232, 15
  %234 = icmp ne i64 %233, 0
  br i1 %234, label %$72, label %$71
$72:
  %235 = phi i64 [%226, %$68] ; # X
  %236 = phi i64 [%227, %$68] ; # Y
  %237 = phi i64 [%228, %$68] ; # A
  %238 = phi i64 [%229, %$68] ; # B
; # (cdr X)
  %239 = inttoptr i64 %235 to i64*
  %240 = getelementptr i64, i64* %239, i32 1
  %241 = load i64, i64* %240
; # (cdr Y)
  %242 = inttoptr i64 %236 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
; # (equal (cdr X) (cdr Y))
  %245 = call i1 @equal(i64 %241, i64 %244)
  br label %$69
$71:
  %246 = phi i64 [%226, %$68] ; # X
  %247 = phi i64 [%227, %$68] ; # Y
  %248 = phi i64 [%228, %$68] ; # A
  %249 = phi i64 [%229, %$68] ; # B
; # (? (atom (cdr Y)) NO)
; # (cdr Y)
  %250 = inttoptr i64 %247 to i64*
  %251 = getelementptr i64, i64* %250, i32 1
  %252 = load i64, i64* %251
; # (atom (cdr Y))
  %253 = and i64 %252, 15
  %254 = icmp ne i64 %253, 0
  br i1 %254, label %$74, label %$73
$74:
  %255 = phi i64 [%246, %$71] ; # X
  %256 = phi i64 [%247, %$71] ; # Y
  %257 = phi i64 [%248, %$71] ; # A
  %258 = phi i64 [%249, %$71] ; # B
  br label %$69
$73:
  %259 = phi i64 [%246, %$71] ; # X
  %260 = phi i64 [%247, %$71] ; # Y
  %261 = phi i64 [%248, %$71] ; # A
  %262 = phi i64 [%249, %$71] ; # B
; # (set X (| (val X) 1))
; # (val X)
  %263 = inttoptr i64 %259 to i64*
  %264 = load i64, i64* %263
; # (| (val X) 1)
  %265 = or i64 %264, 1
  %266 = inttoptr i64 %259 to i64*
  store i64 %265, i64* %266
; # (shift X)
  %267 = inttoptr i64 %259 to i64*
  %268 = getelementptr i64, i64* %267, i32 1
  %269 = load i64, i64* %268
; # (shift Y)
  %270 = inttoptr i64 %260 to i64*
  %271 = getelementptr i64, i64* %270, i32 1
  %272 = load i64, i64* %271
; # (? (& (val X) 1) (prog1 (loop (? (== A X) (if (== B Y) (loop (shi...
; # (val X)
  %273 = inttoptr i64 %269 to i64*
  %274 = load i64, i64* %273
; # (& (val X) 1)
  %275 = and i64 %274, 1
  %276 = icmp ne i64 %275, 0
  br i1 %276, label %$76, label %$75
$76:
  %277 = phi i64 [%269, %$73] ; # X
  %278 = phi i64 [%272, %$73] ; # Y
  %279 = phi i64 [%261, %$73] ; # A
  %280 = phi i64 [%262, %$73] ; # B
; # (prog1 (loop (? (== A X) (if (== B Y) (loop (shift A) (? (== (shi...
; # (loop (? (== A X) (if (== B Y) (loop (shift A) (? (== (shift B) Y...
  br label %$77
$77:
  %281 = phi i64 [%277, %$76], [%347, %$90] ; # X
  %282 = phi i64 [%278, %$76], [%348, %$90] ; # Y
  %283 = phi i64 [%279, %$76], [%357, %$90] ; # A
  %284 = phi i64 [%280, %$76], [%360, %$90] ; # B
; # (? (== A X) (if (== B Y) (loop (shift A) (? (== (shift B) Y) (== ...
; # (== A X)
  %285 = icmp eq i64 %283, %281
  br i1 %285, label %$80, label %$78
$80:
  %286 = phi i64 [%281, %$77] ; # X
  %287 = phi i64 [%282, %$77] ; # Y
  %288 = phi i64 [%283, %$77] ; # A
  %289 = phi i64 [%284, %$77] ; # B
; # (if (== B Y) (loop (shift A) (? (== (shift B) Y) (== A X)) (? (==...
; # (== B Y)
  %290 = icmp eq i64 %289, %287
  br i1 %290, label %$81, label %$82
$81:
  %291 = phi i64 [%286, %$80] ; # X
  %292 = phi i64 [%287, %$80] ; # Y
  %293 = phi i64 [%288, %$80] ; # A
  %294 = phi i64 [%289, %$80] ; # B
; # (loop (shift A) (? (== (shift B) Y) (== A X)) (? (== A X) YES))
  br label %$84
$84:
  %295 = phi i64 [%291, %$81], [%320, %$88] ; # X
  %296 = phi i64 [%292, %$81], [%321, %$88] ; # Y
  %297 = phi i64 [%293, %$81], [%322, %$88] ; # A
  %298 = phi i64 [%294, %$81], [%323, %$88] ; # B
; # (shift A)
  %299 = inttoptr i64 %297 to i64*
  %300 = getelementptr i64, i64* %299, i32 1
  %301 = load i64, i64* %300
; # (? (== (shift B) Y) (== A X))
; # (shift B)
  %302 = inttoptr i64 %298 to i64*
  %303 = getelementptr i64, i64* %302, i32 1
  %304 = load i64, i64* %303
; # (== (shift B) Y)
  %305 = icmp eq i64 %304, %296
  br i1 %305, label %$87, label %$85
$87:
  %306 = phi i64 [%295, %$84] ; # X
  %307 = phi i64 [%296, %$84] ; # Y
  %308 = phi i64 [%301, %$84] ; # A
  %309 = phi i64 [%304, %$84] ; # B
; # (== A X)
  %310 = icmp eq i64 %308, %306
  br label %$86
$85:
  %311 = phi i64 [%295, %$84] ; # X
  %312 = phi i64 [%296, %$84] ; # Y
  %313 = phi i64 [%301, %$84] ; # A
  %314 = phi i64 [%304, %$84] ; # B
; # (? (== A X) YES)
; # (== A X)
  %315 = icmp eq i64 %313, %311
  br i1 %315, label %$89, label %$88
$89:
  %316 = phi i64 [%311, %$85] ; # X
  %317 = phi i64 [%312, %$85] ; # Y
  %318 = phi i64 [%313, %$85] ; # A
  %319 = phi i64 [%314, %$85] ; # B
  br label %$86
$88:
  %320 = phi i64 [%311, %$85] ; # X
  %321 = phi i64 [%312, %$85] ; # Y
  %322 = phi i64 [%313, %$85] ; # A
  %323 = phi i64 [%314, %$85] ; # B
  br label %$84
$86:
  %324 = phi i64 [%306, %$87], [%316, %$89] ; # X
  %325 = phi i64 [%307, %$87], [%317, %$89] ; # Y
  %326 = phi i64 [%308, %$87], [%318, %$89] ; # A
  %327 = phi i64 [%309, %$87], [%319, %$89] ; # B
  %328 = phi i1 [%310, %$87], [1, %$89] ; # ->
  br label %$83
$82:
  %329 = phi i64 [%286, %$80] ; # X
  %330 = phi i64 [%287, %$80] ; # Y
  %331 = phi i64 [%288, %$80] ; # A
  %332 = phi i64 [%289, %$80] ; # B
  br label %$83
$83:
  %333 = phi i64 [%324, %$86], [%329, %$82] ; # X
  %334 = phi i64 [%325, %$86], [%330, %$82] ; # Y
  %335 = phi i64 [%326, %$86], [%331, %$82] ; # A
  %336 = phi i64 [%327, %$86], [%332, %$82] ; # B
  %337 = phi i1 [%328, %$86], [0, %$82] ; # ->
  br label %$79
$78:
  %338 = phi i64 [%281, %$77] ; # X
  %339 = phi i64 [%282, %$77] ; # Y
  %340 = phi i64 [%283, %$77] ; # A
  %341 = phi i64 [%284, %$77] ; # B
; # (? (== B Y) NO)
; # (== B Y)
  %342 = icmp eq i64 %341, %339
  br i1 %342, label %$91, label %$90
$91:
  %343 = phi i64 [%338, %$78] ; # X
  %344 = phi i64 [%339, %$78] ; # Y
  %345 = phi i64 [%340, %$78] ; # A
  %346 = phi i64 [%341, %$78] ; # B
  br label %$79
$90:
  %347 = phi i64 [%338, %$78] ; # X
  %348 = phi i64 [%339, %$78] ; # Y
  %349 = phi i64 [%340, %$78] ; # A
  %350 = phi i64 [%341, %$78] ; # B
; # (set A (& (val A) -2))
; # (val A)
  %351 = inttoptr i64 %349 to i64*
  %352 = load i64, i64* %351
; # (& (val A) -2)
  %353 = and i64 %352, -2
  %354 = inttoptr i64 %349 to i64*
  store i64 %353, i64* %354
; # (shift A)
  %355 = inttoptr i64 %349 to i64*
  %356 = getelementptr i64, i64* %355, i32 1
  %357 = load i64, i64* %356
; # (shift B)
  %358 = inttoptr i64 %350 to i64*
  %359 = getelementptr i64, i64* %358, i32 1
  %360 = load i64, i64* %359
  br label %$77
$79:
  %361 = phi i64 [%333, %$83], [%343, %$91] ; # X
  %362 = phi i64 [%334, %$83], [%344, %$91] ; # Y
  %363 = phi i64 [%335, %$83], [%345, %$91] ; # A
  %364 = phi i64 [%336, %$83], [%346, %$91] ; # B
  %365 = phi i1 [%337, %$83], [0, %$91] ; # ->
; # (set A (& (val A) -2))
; # (val A)
  %366 = inttoptr i64 %363 to i64*
  %367 = load i64, i64* %366
; # (& (val A) -2)
  %368 = and i64 %367, -2
  %369 = inttoptr i64 %363 to i64*
  store i64 %368, i64* %369
; # (shift A)
  %370 = inttoptr i64 %363 to i64*
  %371 = getelementptr i64, i64* %370, i32 1
  %372 = load i64, i64* %371
  br label %$69
$75:
  %373 = phi i64 [%269, %$73] ; # X
  %374 = phi i64 [%272, %$73] ; # Y
  %375 = phi i64 [%261, %$73] ; # A
  %376 = phi i64 [%262, %$73] ; # B
  br label %$67
$69:
  %377 = phi i64 [%222, %$70], [%235, %$72], [%255, %$74], [%361, %$79] ; # X
  %378 = phi i64 [%223, %$70], [%236, %$72], [%256, %$74], [%362, %$79] ; # Y
  %379 = phi i64 [%224, %$70], [%237, %$72], [%257, %$74], [%372, %$79] ; # A
  %380 = phi i64 [%225, %$70], [%238, %$72], [%258, %$74], [%364, %$79] ; # B
  %381 = phi i1 [0, %$70], [%245, %$72], [0, %$74], [%365, %$79] ; # ->
; # (until (== A X) (set A (& (val A) -2)) (shift A))
  br label %$92
$92:
  %382 = phi i64 [%377, %$69], [%387, %$93] ; # X
  %383 = phi i64 [%378, %$69], [%388, %$93] ; # Y
  %384 = phi i64 [%379, %$69], [%397, %$93] ; # A
  %385 = phi i64 [%380, %$69], [%390, %$93] ; # B
; # (== A X)
  %386 = icmp eq i64 %384, %382
  br i1 %386, label %$94, label %$93
$93:
  %387 = phi i64 [%382, %$92] ; # X
  %388 = phi i64 [%383, %$92] ; # Y
  %389 = phi i64 [%384, %$92] ; # A
  %390 = phi i64 [%385, %$92] ; # B
; # (set A (& (val A) -2))
; # (val A)
  %391 = inttoptr i64 %389 to i64*
  %392 = load i64, i64* %391
; # (& (val A) -2)
  %393 = and i64 %392, -2
  %394 = inttoptr i64 %389 to i64*
  store i64 %393, i64* %394
; # (shift A)
  %395 = inttoptr i64 %389 to i64*
  %396 = getelementptr i64, i64* %395, i32 1
  %397 = load i64, i64* %396
  br label %$92
$94:
  %398 = phi i64 [%382, %$92] ; # X
  %399 = phi i64 [%383, %$92] ; # Y
  %400 = phi i64 [%384, %$92] ; # A
  %401 = phi i64 [%385, %$92] ; # B
  br label %$2
$2:
  %402 = phi i64 [%3, %$4], [%9, %$6], [%76, %$11], [%197, %$28], [%204, %$64], [%398, %$94] ; # X
  %403 = phi i64 [%4, %$4], [%10, %$6], [%77, %$11], [%198, %$28], [%205, %$64], [%399, %$94] ; # Y
  %404 = phi i1 [1, %$4], [0, %$6], [%78, %$11], [%199, %$28], [0, %$64], [%381, %$94] ; # ->
  ret i1 %404
}

define i64 @compare(i64, i64) {
$1:
; # (cond ((== X Y) 0) ((nil? X) -1) ((t? X) 1) ((num? X) (cond ((num...
; # (== X Y)
  %2 = icmp eq i64 %0, %1
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
  %4 = phi i64 [%1, %$1] ; # Y
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
  %6 = phi i64 [%1, %$1] ; # Y
; # (nil? X)
  %7 = icmp eq i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$3] ; # X
  %9 = phi i64 [%6, %$3] ; # Y
  br label %$2
$5:
  %10 = phi i64 [%5, %$3] ; # X
  %11 = phi i64 [%6, %$3] ; # Y
; # (t? X)
  %12 = icmp eq i64 %10, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %12, label %$8, label %$7
$8:
  %13 = phi i64 [%10, %$5] ; # X
  %14 = phi i64 [%11, %$5] ; # Y
  br label %$2
$7:
  %15 = phi i64 [%10, %$5] ; # X
  %16 = phi i64 [%11, %$5] ; # Y
; # (num? X)
  %17 = and i64 %15, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$9
$10:
  %19 = phi i64 [%15, %$7] ; # X
  %20 = phi i64 [%16, %$7] ; # Y
; # (cond ((num? Y) (cmpNum X Y)) ((nil? Y) 1) (T -1))
; # (num? Y)
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$13, label %$12
$13:
  %23 = phi i64 [%19, %$10] ; # X
  %24 = phi i64 [%20, %$10] ; # Y
; # (cmpNum X Y)
  %25 = call i64 @cmpNum(i64 %23, i64 %24)
  br label %$11
$12:
  %26 = phi i64 [%19, %$10] ; # X
  %27 = phi i64 [%20, %$10] ; # Y
; # (nil? Y)
  %28 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %28, label %$15, label %$14
$15:
  %29 = phi i64 [%26, %$12] ; # X
  %30 = phi i64 [%27, %$12] ; # Y
  br label %$11
$14:
  %31 = phi i64 [%26, %$12] ; # X
  %32 = phi i64 [%27, %$12] ; # Y
  br label %$11
$11:
  %33 = phi i64 [%23, %$13], [%29, %$15], [%31, %$14] ; # X
  %34 = phi i64 [%24, %$13], [%30, %$15], [%32, %$14] ; # Y
  %35 = phi i64 [%25, %$13], [1, %$15], [-1, %$14] ; # ->
  br label %$2
$9:
  %36 = phi i64 [%15, %$7] ; # X
  %37 = phi i64 [%16, %$7] ; # Y
; # (sym? X)
  %38 = and i64 %36, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$17, label %$16
$17:
  %40 = phi i64 [%36, %$9] ; # X
  %41 = phi i64 [%37, %$9] ; # Y
; # (cond ((or (num? Y) (nil? Y)) 1) ((or (pair Y) (t? Y)) -1) (T (le...
; # (or (num? Y) (nil? Y))
; # (num? Y)
  %42 = and i64 %41, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$19, label %$20
$20:
  %44 = phi i64 [%40, %$17] ; # X
  %45 = phi i64 [%41, %$17] ; # Y
; # (nil? Y)
  %46 = icmp eq i64 %45, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$19
$19:
  %47 = phi i64 [%40, %$17], [%44, %$20] ; # X
  %48 = phi i64 [%41, %$17], [%45, %$20] ; # Y
  %49 = phi i1 [1, %$17], [%46, %$20] ; # ->
  br i1 %49, label %$22, label %$21
$22:
  %50 = phi i64 [%47, %$19] ; # X
  %51 = phi i64 [%48, %$19] ; # Y
  br label %$18
$21:
  %52 = phi i64 [%47, %$19] ; # X
  %53 = phi i64 [%48, %$19] ; # Y
; # (or (pair Y) (t? Y))
; # (pair Y)
  %54 = and i64 %53, 15
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %$23, label %$24
$24:
  %56 = phi i64 [%52, %$21] ; # X
  %57 = phi i64 [%53, %$21] ; # Y
; # (t? Y)
  %58 = icmp eq i64 %57, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br label %$23
$23:
  %59 = phi i64 [%52, %$21], [%56, %$24] ; # X
  %60 = phi i64 [%53, %$21], [%57, %$24] ; # Y
  %61 = phi i1 [1, %$21], [%58, %$24] ; # ->
  br i1 %61, label %$26, label %$25
$26:
  %62 = phi i64 [%59, %$23] ; # X
  %63 = phi i64 [%60, %$23] ; # Y
  br label %$18
$25:
  %64 = phi i64 [%59, %$23] ; # X
  %65 = phi i64 [%60, %$23] ; # Y
; # (let (NmX (name (& (val (tail X)) -9)) NmY (name (& (val (tail Y)...
; # (tail X)
  %66 = add i64 %64, -8
; # (val (tail X))
  %67 = inttoptr i64 %66 to i64*
  %68 = load i64, i64* %67
; # (& (val (tail X)) -9)
  %69 = and i64 %68, -9
; # (name (& (val (tail X)) -9))
  br label %$27
$27:
  %70 = phi i64 [%69, %$25], [%76, %$28] ; # Tail
  %71 = and i64 %70, 6
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$29, label %$28
$28:
  %73 = phi i64 [%70, %$27] ; # Tail
  %74 = inttoptr i64 %73 to i64*
  %75 = getelementptr i64, i64* %74, i32 1
  %76 = load i64, i64* %75
  br label %$27
$29:
  %77 = phi i64 [%70, %$27] ; # Tail
; # (tail Y)
  %78 = add i64 %65, -8
; # (val (tail Y))
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
; # (& (val (tail Y)) -9)
  %81 = and i64 %80, -9
; # (name (& (val (tail Y)) -9))
  br label %$30
$30:
  %82 = phi i64 [%81, %$29], [%88, %$31] ; # Tail
  %83 = and i64 %82, 6
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$32, label %$31
$31:
  %85 = phi i64 [%82, %$30] ; # Tail
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
  br label %$30
$32:
  %89 = phi i64 [%82, %$30] ; # Tail
; # (cond ((== ZERO NmX) (nond ((== ZERO NmY) -1) ((== X Y) 0) ((> X ...
; # (== ZERO NmX)
  %90 = icmp eq i64 2, %77
  br i1 %90, label %$35, label %$34
$35:
  %91 = phi i64 [%64, %$32] ; # X
  %92 = phi i64 [%65, %$32] ; # Y
  %93 = phi i64 [%77, %$32] ; # NmX
  %94 = phi i64 [%89, %$32] ; # NmY
; # (nond ((== ZERO NmY) -1) ((== X Y) 0) ((> X Y) 1) (NIL -1))
; # (== ZERO NmY)
  %95 = icmp eq i64 2, %94
  br i1 %95, label %$37, label %$38
$38:
  %96 = phi i64 [%91, %$35] ; # X
  %97 = phi i64 [%92, %$35] ; # Y
  %98 = phi i64 [%93, %$35] ; # NmX
  %99 = phi i64 [%94, %$35] ; # NmY
  br label %$36
$37:
  %100 = phi i64 [%91, %$35] ; # X
  %101 = phi i64 [%92, %$35] ; # Y
  %102 = phi i64 [%93, %$35] ; # NmX
  %103 = phi i64 [%94, %$35] ; # NmY
; # (== X Y)
  %104 = icmp eq i64 %100, %101
  br i1 %104, label %$39, label %$40
$40:
  %105 = phi i64 [%100, %$37] ; # X
  %106 = phi i64 [%101, %$37] ; # Y
  %107 = phi i64 [%102, %$37] ; # NmX
  %108 = phi i64 [%103, %$37] ; # NmY
  br label %$36
$39:
  %109 = phi i64 [%100, %$37] ; # X
  %110 = phi i64 [%101, %$37] ; # Y
  %111 = phi i64 [%102, %$37] ; # NmX
  %112 = phi i64 [%103, %$37] ; # NmY
; # (> X Y)
  %113 = icmp ugt i64 %109, %110
  br i1 %113, label %$41, label %$42
$42:
  %114 = phi i64 [%109, %$39] ; # X
  %115 = phi i64 [%110, %$39] ; # Y
  %116 = phi i64 [%111, %$39] ; # NmX
  %117 = phi i64 [%112, %$39] ; # NmY
  br label %$36
$41:
  %118 = phi i64 [%109, %$39] ; # X
  %119 = phi i64 [%110, %$39] ; # Y
  %120 = phi i64 [%111, %$39] ; # NmX
  %121 = phi i64 [%112, %$39] ; # NmY
  br label %$36
$36:
  %122 = phi i64 [%96, %$38], [%105, %$40], [%114, %$42], [%118, %$41] ; # X
  %123 = phi i64 [%97, %$38], [%106, %$40], [%115, %$42], [%119, %$41] ; # Y
  %124 = phi i64 [%98, %$38], [%107, %$40], [%116, %$42], [%120, %$41] ; # NmX
  %125 = phi i64 [%99, %$38], [%108, %$40], [%117, %$42], [%121, %$41] ; # NmY
  %126 = phi i64 [-1, %$38], [0, %$40], [1, %$42], [-1, %$41] ; # ->
  br label %$33
$34:
  %127 = phi i64 [%64, %$32] ; # X
  %128 = phi i64 [%65, %$32] ; # Y
  %129 = phi i64 [%77, %$32] ; # NmX
  %130 = phi i64 [%89, %$32] ; # NmY
; # (== ZERO NmY)
  %131 = icmp eq i64 2, %130
  br i1 %131, label %$44, label %$43
$44:
  %132 = phi i64 [%127, %$34] ; # X
  %133 = phi i64 [%128, %$34] ; # Y
  %134 = phi i64 [%129, %$34] ; # NmX
  %135 = phi i64 [%130, %$34] ; # NmY
  br label %$33
$43:
  %136 = phi i64 [%127, %$34] ; # X
  %137 = phi i64 [%128, %$34] ; # Y
  %138 = phi i64 [%129, %$34] ; # NmX
  %139 = phi i64 [%130, %$34] ; # NmY
; # (loop (let (A (if (cnt? NmX) (prog1 (& (int NmX) (hex "3FFFFFFFFF...
  br label %$45
$45:
  %140 = phi i64 [%136, %$43], [%323, %$59] ; # X
  %141 = phi i64 [%137, %$43], [%324, %$59] ; # Y
  %142 = phi i64 [%138, %$43], [%325, %$59] ; # NmX
  %143 = phi i64 [%139, %$43], [%326, %$59] ; # NmY
; # (let (A (if (cnt? NmX) (prog1 (& (int NmX) (hex "3FFFFFFFFFFFFFF"...
; # (if (cnt? NmX) (prog1 (& (int NmX) (hex "3FFFFFFFFFFFFFF")) (setq...
; # (cnt? NmX)
  %144 = and i64 %142, 2
  %145 = icmp ne i64 %144, 0
  br i1 %145, label %$46, label %$47
$46:
  %146 = phi i64 [%140, %$45] ; # X
  %147 = phi i64 [%141, %$45] ; # Y
  %148 = phi i64 [%142, %$45] ; # NmX
  %149 = phi i64 [%143, %$45] ; # NmY
; # (prog1 (& (int NmX) (hex "3FFFFFFFFFFFFFF")) (setq NmX 0))
; # (int NmX)
  %150 = lshr i64 %148, 4
; # (& (int NmX) (hex "3FFFFFFFFFFFFFF"))
  %151 = and i64 %150, 288230376151711743
  br label %$48
$47:
  %152 = phi i64 [%140, %$45] ; # X
  %153 = phi i64 [%141, %$45] ; # Y
  %154 = phi i64 [%142, %$45] ; # NmX
  %155 = phi i64 [%143, %$45] ; # NmY
; # (prog1 (val (dig NmX)) (setq NmX (val (big NmX))))
; # (dig NmX)
  %156 = add i64 %154, -4
; # (val (dig NmX))
  %157 = inttoptr i64 %156 to i64*
  %158 = load i64, i64* %157
; # (big NmX)
  %159 = add i64 %154, 4
; # (val (big NmX))
  %160 = inttoptr i64 %159 to i64*
  %161 = load i64, i64* %160
  br label %$48
$48:
  %162 = phi i64 [%146, %$46], [%152, %$47] ; # X
  %163 = phi i64 [%147, %$46], [%153, %$47] ; # Y
  %164 = phi i64 [0, %$46], [%161, %$47] ; # NmX
  %165 = phi i64 [%149, %$46], [%155, %$47] ; # NmY
  %166 = phi i64 [%151, %$46], [%158, %$47] ; # ->
; # (if (cnt? NmY) (prog1 (& (int NmY) (hex "3FFFFFFFFFFFFFF")) (setq...
; # (cnt? NmY)
  %167 = and i64 %165, 2
  %168 = icmp ne i64 %167, 0
  br i1 %168, label %$49, label %$50
$49:
  %169 = phi i64 [%162, %$48] ; # X
  %170 = phi i64 [%163, %$48] ; # Y
  %171 = phi i64 [%164, %$48] ; # NmX
  %172 = phi i64 [%165, %$48] ; # NmY
  %173 = phi i64 [%166, %$48] ; # A
; # (prog1 (& (int NmY) (hex "3FFFFFFFFFFFFFF")) (setq NmY 0))
; # (int NmY)
  %174 = lshr i64 %172, 4
; # (& (int NmY) (hex "3FFFFFFFFFFFFFF"))
  %175 = and i64 %174, 288230376151711743
  br label %$51
$50:
  %176 = phi i64 [%162, %$48] ; # X
  %177 = phi i64 [%163, %$48] ; # Y
  %178 = phi i64 [%164, %$48] ; # NmX
  %179 = phi i64 [%165, %$48] ; # NmY
  %180 = phi i64 [%166, %$48] ; # A
; # (prog1 (val (dig NmY)) (setq NmY (val (big NmY))))
; # (dig NmY)
  %181 = add i64 %179, -4
; # (val (dig NmY))
  %182 = inttoptr i64 %181 to i64*
  %183 = load i64, i64* %182
; # (big NmY)
  %184 = add i64 %179, 4
; # (val (big NmY))
  %185 = inttoptr i64 %184 to i64*
  %186 = load i64, i64* %185
  br label %$51
$51:
  %187 = phi i64 [%169, %$49], [%176, %$50] ; # X
  %188 = phi i64 [%170, %$49], [%177, %$50] ; # Y
  %189 = phi i64 [%171, %$49], [%178, %$50] ; # NmX
  %190 = phi i64 [0, %$49], [%186, %$50] ; # NmY
  %191 = phi i64 [%173, %$49], [%180, %$50] ; # A
  %192 = phi i64 [%175, %$49], [%183, %$50] ; # ->
; # (loop (when (- (& A 255) (& B 255)) (ret (if (gt0 @) 1 -1))) (? (...
  br label %$52
$52:
  %193 = phi i64 [%187, %$51], [%317, %$71] ; # X
  %194 = phi i64 [%188, %$51], [%318, %$71] ; # Y
  %195 = phi i64 [%189, %$51], [%319, %$71] ; # NmX
  %196 = phi i64 [%190, %$51], [%320, %$71] ; # NmY
  %197 = phi i64 [%191, %$51], [%321, %$71] ; # A
  %198 = phi i64 [%192, %$51], [%322, %$71] ; # B
; # (when (- (& A 255) (& B 255)) (ret (if (gt0 @) 1 -1)))
; # (& A 255)
  %199 = and i64 %197, 255
; # (& B 255)
  %200 = and i64 %198, 255
; # (- (& A 255) (& B 255))
  %201 = sub i64 %199, %200
  %202 = icmp ne i64 %201, 0
  br i1 %202, label %$53, label %$54
$53:
  %203 = phi i64 [%193, %$52] ; # X
  %204 = phi i64 [%194, %$52] ; # Y
  %205 = phi i64 [%195, %$52] ; # NmX
  %206 = phi i64 [%196, %$52] ; # NmY
  %207 = phi i64 [%197, %$52] ; # A
  %208 = phi i64 [%198, %$52] ; # B
; # (if (gt0 @) 1 -1)
; # (gt0 @)
  %209 = icmp sgt i64 %201, 0
  br i1 %209, label %$55, label %$56
$55:
  %210 = phi i64 [%203, %$53] ; # X
  %211 = phi i64 [%204, %$53] ; # Y
  %212 = phi i64 [%205, %$53] ; # NmX
  %213 = phi i64 [%206, %$53] ; # NmY
  %214 = phi i64 [%207, %$53] ; # A
  %215 = phi i64 [%208, %$53] ; # B
  br label %$57
$56:
  %216 = phi i64 [%203, %$53] ; # X
  %217 = phi i64 [%204, %$53] ; # Y
  %218 = phi i64 [%205, %$53] ; # NmX
  %219 = phi i64 [%206, %$53] ; # NmY
  %220 = phi i64 [%207, %$53] ; # A
  %221 = phi i64 [%208, %$53] ; # B
  br label %$57
$57:
  %222 = phi i64 [%210, %$55], [%216, %$56] ; # X
  %223 = phi i64 [%211, %$55], [%217, %$56] ; # Y
  %224 = phi i64 [%212, %$55], [%218, %$56] ; # NmX
  %225 = phi i64 [%213, %$55], [%219, %$56] ; # NmY
  %226 = phi i64 [%214, %$55], [%220, %$56] ; # A
  %227 = phi i64 [%215, %$55], [%221, %$56] ; # B
  %228 = phi i64 [1, %$55], [-1, %$56] ; # ->
; # (ret (if (gt0 @) 1 -1))
  ret i64 %228
$54:
  %229 = phi i64 [%193, %$52] ; # X
  %230 = phi i64 [%194, %$52] ; # Y
  %231 = phi i64 [%195, %$52] ; # NmX
  %232 = phi i64 [%196, %$52] ; # NmY
  %233 = phi i64 [%197, %$52] ; # A
  %234 = phi i64 [%198, %$52] ; # B
; # (? (=0 (setq A (shr A 8))) (when (setq B (shr B 8)) (ret -1)) (un...
; # (shr A 8)
  %235 = lshr i64 %233, 8
; # (=0 (setq A (shr A 8)))
  %236 = icmp eq i64 %235, 0
  br i1 %236, label %$60, label %$58
$60:
  %237 = phi i64 [%229, %$54] ; # X
  %238 = phi i64 [%230, %$54] ; # Y
  %239 = phi i64 [%231, %$54] ; # NmX
  %240 = phi i64 [%232, %$54] ; # NmY
  %241 = phi i64 [%235, %$54] ; # A
  %242 = phi i64 [%234, %$54] ; # B
; # (when (setq B (shr B 8)) (ret -1))
; # (shr B 8)
  %243 = lshr i64 %242, 8
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$61, label %$62
$61:
  %245 = phi i64 [%237, %$60] ; # X
  %246 = phi i64 [%238, %$60] ; # Y
  %247 = phi i64 [%239, %$60] ; # NmX
  %248 = phi i64 [%240, %$60] ; # NmY
  %249 = phi i64 [%241, %$60] ; # A
  %250 = phi i64 [%243, %$60] ; # B
; # (ret -1)
  ret i64 -1
$62:
  %251 = phi i64 [%237, %$60] ; # X
  %252 = phi i64 [%238, %$60] ; # Y
  %253 = phi i64 [%239, %$60] ; # NmX
  %254 = phi i64 [%240, %$60] ; # NmY
  %255 = phi i64 [%241, %$60] ; # A
  %256 = phi i64 [%243, %$60] ; # B
; # (unless NmX (ret (if NmY -1 0)))
  %257 = icmp ne i64 %253, 0
  br i1 %257, label %$64, label %$63
$63:
  %258 = phi i64 [%251, %$62] ; # X
  %259 = phi i64 [%252, %$62] ; # Y
  %260 = phi i64 [%253, %$62] ; # NmX
  %261 = phi i64 [%254, %$62] ; # NmY
  %262 = phi i64 [%255, %$62] ; # A
  %263 = phi i64 [%256, %$62] ; # B
; # (if NmY -1 0)
  %264 = icmp ne i64 %261, 0
  br i1 %264, label %$65, label %$66
$65:
  %265 = phi i64 [%258, %$63] ; # X
  %266 = phi i64 [%259, %$63] ; # Y
  %267 = phi i64 [%260, %$63] ; # NmX
  %268 = phi i64 [%261, %$63] ; # NmY
  %269 = phi i64 [%262, %$63] ; # A
  %270 = phi i64 [%263, %$63] ; # B
  br label %$67
$66:
  %271 = phi i64 [%258, %$63] ; # X
  %272 = phi i64 [%259, %$63] ; # Y
  %273 = phi i64 [%260, %$63] ; # NmX
  %274 = phi i64 [%261, %$63] ; # NmY
  %275 = phi i64 [%262, %$63] ; # A
  %276 = phi i64 [%263, %$63] ; # B
  br label %$67
$67:
  %277 = phi i64 [%265, %$65], [%271, %$66] ; # X
  %278 = phi i64 [%266, %$65], [%272, %$66] ; # Y
  %279 = phi i64 [%267, %$65], [%273, %$66] ; # NmX
  %280 = phi i64 [%268, %$65], [%274, %$66] ; # NmY
  %281 = phi i64 [%269, %$65], [%275, %$66] ; # A
  %282 = phi i64 [%270, %$65], [%276, %$66] ; # B
  %283 = phi i64 [-1, %$65], [0, %$66] ; # ->
; # (ret (if NmY -1 0))
  ret i64 %283
$64:
  %284 = phi i64 [%251, %$62] ; # X
  %285 = phi i64 [%252, %$62] ; # Y
  %286 = phi i64 [%253, %$62] ; # NmX
  %287 = phi i64 [%254, %$62] ; # NmY
  %288 = phi i64 [%255, %$62] ; # A
  %289 = phi i64 [%256, %$62] ; # B
; # (unless NmY (ret 1))
  %290 = icmp ne i64 %287, 0
  br i1 %290, label %$69, label %$68
$68:
  %291 = phi i64 [%284, %$64] ; # X
  %292 = phi i64 [%285, %$64] ; # Y
  %293 = phi i64 [%286, %$64] ; # NmX
  %294 = phi i64 [%287, %$64] ; # NmY
  %295 = phi i64 [%288, %$64] ; # A
  %296 = phi i64 [%289, %$64] ; # B
; # (ret 1)
  ret i64 1
$69:
  %297 = phi i64 [%284, %$64] ; # X
  %298 = phi i64 [%285, %$64] ; # Y
  %299 = phi i64 [%286, %$64] ; # NmX
  %300 = phi i64 [%287, %$64] ; # NmY
  %301 = phi i64 [%288, %$64] ; # A
  %302 = phi i64 [%289, %$64] ; # B
  br label %$59
$58:
  %303 = phi i64 [%229, %$54] ; # X
  %304 = phi i64 [%230, %$54] ; # Y
  %305 = phi i64 [%231, %$54] ; # NmX
  %306 = phi i64 [%232, %$54] ; # NmY
  %307 = phi i64 [%235, %$54] ; # A
  %308 = phi i64 [%234, %$54] ; # B
; # (unless (setq B (shr B 8)) (ret 1))
; # (shr B 8)
  %309 = lshr i64 %308, 8
  %310 = icmp ne i64 %309, 0
  br i1 %310, label %$71, label %$70
$70:
  %311 = phi i64 [%303, %$58] ; # X
  %312 = phi i64 [%304, %$58] ; # Y
  %313 = phi i64 [%305, %$58] ; # NmX
  %314 = phi i64 [%306, %$58] ; # NmY
  %315 = phi i64 [%307, %$58] ; # A
  %316 = phi i64 [%309, %$58] ; # B
; # (ret 1)
  ret i64 1
$71:
  %317 = phi i64 [%303, %$58] ; # X
  %318 = phi i64 [%304, %$58] ; # Y
  %319 = phi i64 [%305, %$58] ; # NmX
  %320 = phi i64 [%306, %$58] ; # NmY
  %321 = phi i64 [%307, %$58] ; # A
  %322 = phi i64 [%309, %$58] ; # B
  br label %$52
$59:
  %323 = phi i64 [%297, %$69] ; # X
  %324 = phi i64 [%298, %$69] ; # Y
  %325 = phi i64 [%299, %$69] ; # NmX
  %326 = phi i64 [%300, %$69] ; # NmY
  %327 = phi i64 [%301, %$69] ; # A
  %328 = phi i64 [%302, %$69] ; # B
  br label %$45
$33:
  %329 = phi i64 [%122, %$36], [%132, %$44] ; # X
  %330 = phi i64 [%123, %$36], [%133, %$44] ; # Y
  %331 = phi i64 [%124, %$36], [%134, %$44] ; # NmX
  %332 = phi i64 [%125, %$36], [%135, %$44] ; # NmY
  %333 = phi i64 [%126, %$36], [1, %$44] ; # ->
  br label %$18
$18:
  %334 = phi i64 [%50, %$22], [%62, %$26], [%329, %$33] ; # X
  %335 = phi i64 [%51, %$22], [%63, %$26], [%330, %$33] ; # Y
  %336 = phi i64 [1, %$22], [-1, %$26], [%333, %$33] ; # ->
  br label %$2
$16:
  %337 = phi i64 [%36, %$9] ; # X
  %338 = phi i64 [%37, %$9] ; # Y
; # (atom Y)
  %339 = and i64 %338, 15
  %340 = icmp ne i64 %339, 0
  br i1 %340, label %$73, label %$72
$73:
  %341 = phi i64 [%337, %$16] ; # X
  %342 = phi i64 [%338, %$16] ; # Y
; # (if (t? Y) -1 1)
; # (t? Y)
  %343 = icmp eq i64 %342, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %343, label %$74, label %$75
$74:
  %344 = phi i64 [%341, %$73] ; # X
  %345 = phi i64 [%342, %$73] ; # Y
  br label %$76
$75:
  %346 = phi i64 [%341, %$73] ; # X
  %347 = phi i64 [%342, %$73] ; # Y
  br label %$76
$76:
  %348 = phi i64 [%344, %$74], [%346, %$75] ; # X
  %349 = phi i64 [%345, %$74], [%347, %$75] ; # Y
  %350 = phi i64 [-1, %$74], [1, %$75] ; # ->
  br label %$2
$72:
  %351 = phi i64 [%337, %$16] ; # X
  %352 = phi i64 [%338, %$16] ; # Y
; # (stkChk 0)
  %353 = load i8*, i8** @$StkLimit
  %354 = call i8* @llvm.stacksave()
  %355 = icmp ugt i8* %353, %354
  br i1 %355, label %$77, label %$78
$77:
  call void @stkErr(i64 0)
  unreachable
$78:
; # (let (A X B Y) (loop (? (compare (car X) (car Y)) @) (? (atom (sh...
; # (loop (? (compare (car X) (car Y)) @) (? (atom (shift X)) (compar...
  br label %$79
$79:
  %356 = phi i64 [%351, %$78], [%407, %$95] ; # X
  %357 = phi i64 [%352, %$78], [%408, %$95] ; # Y
; # (? (compare (car X) (car Y)) @)
; # (car X)
  %358 = inttoptr i64 %356 to i64*
  %359 = load i64, i64* %358
; # (car Y)
  %360 = inttoptr i64 %357 to i64*
  %361 = load i64, i64* %360
; # (compare (car X) (car Y))
  %362 = call i64 @compare(i64 %359, i64 %361)
  %363 = icmp ne i64 %362, 0
  br i1 %363, label %$82, label %$80
$82:
  %364 = phi i64 [%356, %$79] ; # X
  %365 = phi i64 [%357, %$79] ; # Y
  br label %$81
$80:
  %366 = phi i64 [%356, %$79] ; # X
  %367 = phi i64 [%357, %$79] ; # Y
; # (? (atom (shift X)) (compare X (cdr Y)))
; # (shift X)
  %368 = inttoptr i64 %366 to i64*
  %369 = getelementptr i64, i64* %368, i32 1
  %370 = load i64, i64* %369
; # (atom (shift X))
  %371 = and i64 %370, 15
  %372 = icmp ne i64 %371, 0
  br i1 %372, label %$84, label %$83
$84:
  %373 = phi i64 [%370, %$80] ; # X
  %374 = phi i64 [%367, %$80] ; # Y
; # (cdr Y)
  %375 = inttoptr i64 %374 to i64*
  %376 = getelementptr i64, i64* %375, i32 1
  %377 = load i64, i64* %376
; # (compare X (cdr Y))
  %378 = call i64 @compare(i64 %373, i64 %377)
  br label %$81
$83:
  %379 = phi i64 [%370, %$80] ; # X
  %380 = phi i64 [%367, %$80] ; # Y
; # (? (atom (shift Y)) (if (t? Y) -1 1))
; # (shift Y)
  %381 = inttoptr i64 %380 to i64*
  %382 = getelementptr i64, i64* %381, i32 1
  %383 = load i64, i64* %382
; # (atom (shift Y))
  %384 = and i64 %383, 15
  %385 = icmp ne i64 %384, 0
  br i1 %385, label %$86, label %$85
$86:
  %386 = phi i64 [%379, %$83] ; # X
  %387 = phi i64 [%383, %$83] ; # Y
; # (if (t? Y) -1 1)
; # (t? Y)
  %388 = icmp eq i64 %387, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %388, label %$87, label %$88
$87:
  %389 = phi i64 [%386, %$86] ; # X
  %390 = phi i64 [%387, %$86] ; # Y
  br label %$89
$88:
  %391 = phi i64 [%386, %$86] ; # X
  %392 = phi i64 [%387, %$86] ; # Y
  br label %$89
$89:
  %393 = phi i64 [%389, %$87], [%391, %$88] ; # X
  %394 = phi i64 [%390, %$87], [%392, %$88] ; # Y
  %395 = phi i64 [-1, %$87], [1, %$88] ; # ->
  br label %$81
$85:
  %396 = phi i64 [%379, %$83] ; # X
  %397 = phi i64 [%383, %$83] ; # Y
; # (? (and (== X A) (== Y B)) 0)
; # (and (== X A) (== Y B))
; # (== X A)
  %398 = icmp eq i64 %396, %351
  br i1 %398, label %$91, label %$90
$91:
  %399 = phi i64 [%396, %$85] ; # X
  %400 = phi i64 [%397, %$85] ; # Y
; # (== Y B)
  %401 = icmp eq i64 %400, %352
  br label %$90
$90:
  %402 = phi i64 [%396, %$85], [%399, %$91] ; # X
  %403 = phi i64 [%397, %$85], [%400, %$91] ; # Y
  %404 = phi i1 [0, %$85], [%401, %$91] ; # ->
  br i1 %404, label %$93, label %$92
$93:
  %405 = phi i64 [%402, %$90] ; # X
  %406 = phi i64 [%403, %$90] ; # Y
  br label %$81
$92:
  %407 = phi i64 [%402, %$90] ; # X
  %408 = phi i64 [%403, %$90] ; # Y
; # (sigChk 0)
  %409 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %410 = icmp ne i32 %409, 0
  br i1 %410, label %$94, label %$95
$94:
  call void @sighandler(i64 0)
  br label %$95
$95:
  br label %$79
$81:
  %411 = phi i64 [%364, %$82], [%373, %$84], [%393, %$89], [%405, %$93] ; # X
  %412 = phi i64 [%365, %$82], [%374, %$84], [%394, %$89], [%406, %$93] ; # Y
  %413 = phi i64 [%362, %$82], [%378, %$84], [%395, %$89], [0, %$93] ; # ->
  br label %$2
$2:
  %414 = phi i64 [%3, %$4], [%8, %$6], [%13, %$8], [%33, %$11], [%334, %$18], [%348, %$76], [%411, %$81] ; # X
  %415 = phi i64 [%4, %$4], [%9, %$6], [%14, %$8], [%34, %$11], [%335, %$18], [%349, %$76], [%412, %$81] ; # Y
  %416 = phi i64 [0, %$4], [-1, %$6], [1, %$8], [%35, %$11], [%336, %$18], [%350, %$76], [%413, %$81] ; # ->
  ret i64 %416
}

define void @openErr(i64, i64) {
$1:
; # (strErrno)
  %2 = call i8* @strErrno()
; # (err Exe X ($ "Open error: %s") (strErrno))
  call void @err(i64 %0, i64 %1, i8* bitcast ([15 x i8]* @$26 to i8*), i8* %2)
  unreachable
}

define void @closeErr() {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "Close error: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([16 x i8]* @$27 to i8*), i8* %0)
  unreachable
}

define void @pipeErr(i64) {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err Exe 0 ($ "Pipe error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([15 x i8]* @$28 to i8*), i8* %1)
  unreachable
}

define void @eofErr() {
$1:
; # (err 0 0 ($ "EOF Overrun") null)
  call void @err(i64 0, i64 0, i8* bitcast ([12 x i8]* @$29 to i8*), i8* null)
  unreachable
}

define void @badInput() {
$1:
; # (let S (b8 2) (set S (i8 (val $Chr))) (set 2 S 0) (err 0 0 ($ "Ba...
; # (b8 2)
  %0 = alloca i8, i64 2
; # (set S (i8 (val $Chr)))
; # (val $Chr)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (i8 (val $Chr))
  %2 = trunc i32 %1 to i8
  store i8 %2, i8* %0
; # (set 2 S 0)
  %3 = getelementptr i8, i8* %0, i32 1
  store i8 0, i8* %3
; # (err 0 0 ($ "Bad input '%s'") S)
  call void @err(i64 0, i64 0, i8* bitcast ([15 x i8]* @$30 to i8*), i8* %0)
  unreachable
}

define void @badFd(i64, i64) {
$1:
; # (err Exe Fd ($ "Bad FD") null)
  call void @err(i64 %0, i64 %1, i8* bitcast ([7 x i8]* @$31 to i8*), i8* null)
  unreachable
}

define void @writeErr(i8*) {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err 0 0 Fmt (strErrno))
  call void @err(i64 0, i64 0, i8* %0, i8* %1)
  unreachable
}

define void @selectErr(i64) {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err Exe 0 ($ "Select error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([17 x i8]* @$32 to i8*), i8* %1)
  unreachable
}

define void @closeOnExec(i64, i32) {
$1:
; # (when (lt0 (fcntlCloExec Fd)) (err Exe 0 ($ "SETFD %s") (strErrno...
; # (fcntlCloExec Fd)
  %2 = call i32 @fcntlCloExec(i32 %1)
; # (lt0 (fcntlCloExec Fd))
  %3 = icmp slt i32 %2, 0
  br i1 %3, label %$2, label %$3
$2:
; # (strErrno)
  %4 = call i8* @strErrno()
; # (err Exe 0 ($ "SETFD %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([9 x i8]* @$33 to i8*), i8* %4)
  unreachable
$3:
  ret void
}

define i8* @initInFile(i32, i8*) {
$1:
; # (let I (val $InFDs) (when (>= Fd I) (let P (set $InFiles (i8** (a...
; # (val $InFDs)
  %2 = load i32, i32* @$InFDs
; # (when (>= Fd I) (let P (set $InFiles (i8** (alloc (i8* (val $InFi...
; # (>= Fd I)
  %3 = icmp sge i32 %0, %2
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i32 [%2, %$1] ; # I
; # (let P (set $InFiles (i8** (alloc (i8* (val $InFiles)) (* 8 (i64 ...
; # (set $InFiles (i8** (alloc (i8* (val $InFiles)) (* 8 (i64 (set $I...
; # (val $InFiles)
  %5 = load i8**, i8*** @$InFiles
; # (i8* (val $InFiles))
  %6 = bitcast i8** %5 to i8*
; # (set $InFDs (+ Fd 1))
; # (+ Fd 1)
  %7 = add i32 %0, 1
  store i32 %7, i32* @$InFDs
; # (i64 (set $InFDs (+ Fd 1)))
  %8 = sext i32 %7 to i64
; # (* 8 (i64 (set $InFDs (+ Fd 1))))
  %9 = mul i64 8, %8
; # (alloc (i8* (val $InFiles)) (* 8 (i64 (set $InFDs (+ Fd 1)))))
  %10 = call i8* @alloc(i8* %6, i64 %9)
; # (i8** (alloc (i8* (val $InFiles)) (* 8 (i64 (set $InFDs (+ Fd 1))...
  %11 = bitcast i8* %10 to i8**
  store i8** %11, i8*** @$InFiles
; # (loop (set (ofs P I) null) (? (== I Fd)) (inc 'I))
  br label %$4
$4:
  %12 = phi i32 [%4, %$2], [%16, %$5] ; # I
; # (set (ofs P I) null)
; # (ofs P I)
  %13 = getelementptr i8*, i8** %11, i32 %12
  store i8* null, i8** %13
; # (? (== I Fd))
; # (== I Fd)
  %14 = icmp eq i32 %12, %0
  br i1 %14, label %$6, label %$5
$5:
  %15 = phi i32 [%12, %$4] ; # I
; # (inc 'I)
  %16 = add i32 %15, 1
  br label %$4
$6:
  %17 = phi i32 [%12, %$4] ; # I
  %18 = phi i64 [0, %$4] ; # ->
  br label %$3
$3:
  %19 = phi i32 [%2, %$1], [%17, %$6] ; # I
; # (let (P (ofs (val $InFiles) Fd) In (set P (alloc (val P) (inFile ...
; # (val $InFiles)
  %20 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %21 = getelementptr i8*, i8** %20, i32 %0
; # (set P (alloc (val P) (inFile T)))
; # (val P)
  %22 = load i8*, i8** %21
; # (alloc (val P) (inFile T))
  %23 = call i8* @alloc(i8* %22, i64 4136)
  store i8* %23, i8** %21
; # (In: ix (In: cnt 0))
  %24 = bitcast i8* %23 to i64*
  %25 = getelementptr i8, i8* %23, i32 8
  %26 = bitcast i8* %25 to i64*
  store i64 0, i64* %26
  store i64 0, i64* %24
; # (In: fd Fd)
  %27 = getelementptr i8, i8* %23, i32 16
  %28 = bitcast i8* %27 to i32*
  store i32 %0, i32* %28
; # (In: next 0)
  %29 = getelementptr i8, i8* %23, i32 20
  %30 = bitcast i8* %29 to i32*
  store i32 0, i32* %30
; # (In: line (In: src 1))
  %31 = getelementptr i8, i8* %23, i32 32
  %32 = bitcast i8* %31 to i32*
  %33 = getelementptr i8, i8* %23, i32 36
  %34 = bitcast i8* %33 to i32*
  store i32 1, i32* %34
  store i32 1, i32* %32
; # (In: name Nm)
  %35 = getelementptr i8, i8* %23, i32 24
  %36 = bitcast i8* %35 to i8**
  store i8* %1, i8** %36
  ret i8* %23
}

define i8* @initOutFile(i32) {
$1:
; # (let I (val $OutFDs) (when (>= Fd I) (let P (set $OutFiles (i8** ...
; # (val $OutFDs)
  %1 = load i32, i32* @$OutFDs
; # (when (>= Fd I) (let P (set $OutFiles (i8** (alloc (i8* (val $Out...
; # (>= Fd I)
  %2 = icmp sge i32 %0, %1
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i32 [%1, %$1] ; # I
; # (let P (set $OutFiles (i8** (alloc (i8* (val $OutFiles)) (* 8 (i6...
; # (set $OutFiles (i8** (alloc (i8* (val $OutFiles)) (* 8 (i64 (set ...
; # (val $OutFiles)
  %4 = load i8**, i8*** @$OutFiles
; # (i8* (val $OutFiles))
  %5 = bitcast i8** %4 to i8*
; # (set $OutFDs (+ Fd 1))
; # (+ Fd 1)
  %6 = add i32 %0, 1
  store i32 %6, i32* @$OutFDs
; # (i64 (set $OutFDs (+ Fd 1)))
  %7 = sext i32 %6 to i64
; # (* 8 (i64 (set $OutFDs (+ Fd 1))))
  %8 = mul i64 8, %7
; # (alloc (i8* (val $OutFiles)) (* 8 (i64 (set $OutFDs (+ Fd 1)))))
  %9 = call i8* @alloc(i8* %5, i64 %8)
; # (i8** (alloc (i8* (val $OutFiles)) (* 8 (i64 (set $OutFDs (+ Fd 1...
  %10 = bitcast i8* %9 to i8**
  store i8** %10, i8*** @$OutFiles
; # (loop (set (ofs P I) null) (? (== I Fd)) (inc 'I))
  br label %$4
$4:
  %11 = phi i32 [%3, %$2], [%15, %$5] ; # I
; # (set (ofs P I) null)
; # (ofs P I)
  %12 = getelementptr i8*, i8** %10, i32 %11
  store i8* null, i8** %12
; # (? (== I Fd))
; # (== I Fd)
  %13 = icmp eq i32 %11, %0
  br i1 %13, label %$6, label %$5
$5:
  %14 = phi i32 [%11, %$4] ; # I
; # (inc 'I)
  %15 = add i32 %14, 1
  br label %$4
$6:
  %16 = phi i32 [%11, %$4] ; # I
  %17 = phi i64 [0, %$4] ; # ->
  br label %$3
$3:
  %18 = phi i32 [%1, %$1], [%16, %$6] ; # I
; # (let (P (ofs (val $OutFiles) Fd) Out (set P (alloc (val P) (outFi...
; # (val $OutFiles)
  %19 = load i8**, i8*** @$OutFiles
; # (ofs (val $OutFiles) Fd)
  %20 = getelementptr i8*, i8** %19, i32 %0
; # (set P (alloc (val P) (outFile T)))
; # (val P)
  %21 = load i8*, i8** %20
; # (alloc (val P) (outFile T))
  %22 = call i8* @alloc(i8* %21, i64 4109)
  store i8* %22, i8** %20
; # (Out: tty (n0 (isatty (Out: fd Fd))))
  %23 = getelementptr i8, i8* %22, i32 4108
  %24 = bitcast i8* %23 to i1*
  %25 = getelementptr i8, i8* %22, i32 8
  %26 = bitcast i8* %25 to i32*
  store i32 %0, i32* %26
  %27 = call i32 @isatty(i32 %0)
  %28 = icmp ne i32 %27, 0
  store i1 %28, i1* %24
; # (Out: ix 0)
  %29 = bitcast i8* %22 to i64*
  store i64 0, i64* %29
  ret i8* %22
}

define void @closeInFile(i32) {
$1:
; # (when (> (val $InFDs) Fd) (let (P (ofs (val $InFiles) Fd) V (val ...
; # (val $InFDs)
  %1 = load i32, i32* @$InFDs
; # (> (val $InFDs) Fd)
  %2 = icmp sgt i32 %1, %0
  br i1 %2, label %$2, label %$3
$2:
; # (let (P (ofs (val $InFiles) Fd) V (val P)) (when V (when (== V (v...
; # (val $InFiles)
  %3 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %4 = getelementptr i8*, i8** %3, i32 %0
; # (val P)
  %5 = load i8*, i8** %4
; # (when V (when (== V (val $InFile)) (set $InFile null)) (free ((in...
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$4, label %$5
$4:
; # (when (== V (val $InFile)) (set $InFile null))
; # (val $InFile)
  %7 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (== V (val $InFile))
  %8 = icmp eq i8* %5, %7
  br i1 %8, label %$6, label %$7
$6:
; # (set $InFile null)
  store i8* null, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
  br label %$7
$7:
; # ((inFile V) name)
  %9 = getelementptr i8, i8* %5, i32 24
  %10 = bitcast i8* %9 to i8**
  %11 = load i8*, i8** %10
; # (free ((inFile V) name))
  call void @free(i8* %11)
; # (free V)
  call void @free(i8* %5)
; # (set P null)
  store i8* null, i8** %4
  br label %$5
$5:
  br label %$3
$3:
  ret void
}

define void @closeOutFile(i32) {
$1:
; # (when (> (val $OutFDs) Fd) (let (P (ofs (val $OutFiles) Fd) V (va...
; # (val $OutFDs)
  %1 = load i32, i32* @$OutFDs
; # (> (val $OutFDs) Fd)
  %2 = icmp sgt i32 %1, %0
  br i1 %2, label %$2, label %$3
$2:
; # (let (P (ofs (val $OutFiles) Fd) V (val P)) (when V (when (== V (...
; # (val $OutFiles)
  %3 = load i8**, i8*** @$OutFiles
; # (ofs (val $OutFiles) Fd)
  %4 = getelementptr i8*, i8** %3, i32 %0
; # (val P)
  %5 = load i8*, i8** %4
; # (when V (when (== V (val $OutFile)) (set $OutFile null)) (free V)...
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$4, label %$5
$4:
; # (when (== V (val $OutFile)) (set $OutFile null))
; # (val $OutFile)
  %7 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (== V (val $OutFile))
  %8 = icmp eq i8* %5, %7
  br i1 %8, label %$6, label %$7
$6:
; # (set $OutFile null)
  store i8* null, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
  br label %$7
$7:
; # (free V)
  call void @free(i8* %5)
; # (set P null)
  store i8* null, i8** %4
  br label %$5
$5:
  br label %$3
$3:
  ret void
}

define i64 @slow(i8*) {
$1:
; # (let In: (inFile In) (In: ix (In: cnt 0)) (loop (? (ge0 (read (In...
; # (In: ix (In: cnt 0))
  %1 = bitcast i8* %0 to i64*
  %2 = getelementptr i8, i8* %0, i32 8
  %3 = bitcast i8* %2 to i64*
  store i64 0, i64* %3
  store i64 0, i64* %1
; # (loop (? (ge0 (read (In: fd) (In: (buf)) BUFSIZ)) (In: cnt @)) (?...
  br label %$2
$2:
; # (? (ge0 (read (In: fd) (In: (buf)) BUFSIZ)) (In: cnt @))
; # (In: fd)
  %4 = getelementptr i8, i8* %0, i32 16
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5
; # (In: (buf))
  %7 = getelementptr i8, i8* %0, i32 40
; # (read (In: fd) (In: (buf)) BUFSIZ)
  %8 = call i64 @read(i32 %6, i8* %7, i64 4096)
; # (ge0 (read (In: fd) (In: (buf)) BUFSIZ))
  %9 = icmp sge i64 %8, 0
  br i1 %9, label %$5, label %$3
$5:
; # (In: cnt @)
  %10 = getelementptr i8, i8* %0, i32 8
  %11 = bitcast i8* %10 to i64*
  store i64 %8, i64* %11
  br label %$4
$3:
; # (? (<> (gErrno) EINTR) 0)
; # (gErrno)
  %12 = call i32 @gErrno()
; # (<> (gErrno) EINTR)
  %13 = icmp ne i32 %12, 2
  br i1 %13, label %$7, label %$6
$7:
  br label %$4
$6:
; # (sigChk 0)
  %14 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %15 = icmp ne i32 %14, 0
  br i1 %15, label %$8, label %$9
$8:
  call void @sighandler(i64 0)
  br label %$9
$9:
  br label %$2
$4:
  %16 = phi i64 [%8, %$5], [0, %$7] ; # ->
  ret i64 %16
}

define i64 @slowNb(i8*) {
$1:
; # (let In: (inFile In) (In: ix (In: cnt 0)) (loop (let (Flg (nonBlo...
; # (In: ix (In: cnt 0))
  %1 = bitcast i8* %0 to i64*
  %2 = getelementptr i8, i8* %0, i32 8
  %3 = bitcast i8* %2 to i64*
  store i64 0, i64* %3
  store i64 0, i64* %1
; # (loop (let (Flg (nonBlocking (In: fd)) N (read (In: fd) (In: (buf...
  br label %$2
$2:
; # (let (Flg (nonBlocking (In: fd)) N (read (In: fd) (In: (buf)) BUF...
; # (In: fd)
  %4 = getelementptr i8, i8* %0, i32 16
  %5 = bitcast i8* %4 to i32*
  %6 = load i32, i32* %5
; # (nonBlocking (In: fd))
  %7 = call i32 @nonBlocking(i32 %6)
; # (In: fd)
  %8 = getelementptr i8, i8* %0, i32 16
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (In: (buf))
  %11 = getelementptr i8, i8* %0, i32 40
; # (read (In: fd) (In: (buf)) BUFSIZ)
  %12 = call i64 @read(i32 %10, i8* %11, i64 4096)
; # (In: fd)
  %13 = getelementptr i8, i8* %0, i32 16
  %14 = bitcast i8* %13 to i32*
  %15 = load i32, i32* %14
; # (fcntlSetFl (In: fd) Flg)
  call void @fcntlSetFl(i32 %15, i32 %7)
; # (? (gt0 N) (In: cnt N))
; # (gt0 N)
  %16 = icmp sgt i64 %12, 0
  br i1 %16, label %$5, label %$3
$5:
; # (In: cnt N)
  %17 = getelementptr i8, i8* %0, i32 8
  %18 = bitcast i8* %17 to i64*
  store i64 %12, i64* %18
  br label %$4
$3:
; # (? (=0 N) (In: ix (In: cnt -1)) 0)
; # (=0 N)
  %19 = icmp eq i64 %12, 0
  br i1 %19, label %$7, label %$6
$7:
; # (In: ix (In: cnt -1))
  %20 = bitcast i8* %0 to i64*
  %21 = getelementptr i8, i8* %0, i32 8
  %22 = bitcast i8* %21 to i64*
  store i64 -1, i64* %22
  store i64 -1, i64* %20
  br label %$4
$6:
; # (? (== (gErrno) EAGAIN) -1)
; # (gErrno)
  %23 = call i32 @gErrno()
; # (== (gErrno) EAGAIN)
  %24 = icmp eq i32 %23, 4
  br i1 %24, label %$9, label %$8
$9:
  br label %$4
$8:
; # (? (<> @ EINTR) 0)
; # (<> @ EINTR)
  %25 = icmp ne i32 %23, 2
  br i1 %25, label %$11, label %$10
$11:
  br label %$4
$10:
; # (sigChk 0)
  %26 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$12, label %$13
$12:
  call void @sighandler(i64 0)
  br label %$13
$13:
  br label %$2
$4:
  %28 = phi i64 [%12, %$5], [0, %$7], [-1, %$9], [0, %$11] ; # ->
  ret i64 %28
}

define i1 @rdBytes(i32, i8*, i64) {
$1:
; # (loop (loop (? (gt0 (read Fd P Cnt)) (inc 'P @) (dec 'Cnt @)) (un...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%35, %$13] ; # P
  %4 = phi i64 [%2, %$1], [%36, %$13] ; # Cnt
; # (loop (? (gt0 (read Fd P Cnt)) (inc 'P @) (dec 'Cnt @)) (unless (...
  br label %$3
$3:
  %5 = phi i8* [%3, %$2], [%25, %$12] ; # P
  %6 = phi i64 [%4, %$2], [%26, %$12] ; # Cnt
; # (? (gt0 (read Fd P Cnt)) (inc 'P @) (dec 'Cnt @))
; # (read Fd P Cnt)
  %7 = call i64 @read(i32 %0, i8* %5, i64 %6)
; # (gt0 (read Fd P Cnt))
  %8 = icmp sgt i64 %7, 0
  br i1 %8, label %$6, label %$4
$6:
  %9 = phi i8* [%5, %$3] ; # P
  %10 = phi i64 [%6, %$3] ; # Cnt
; # (inc 'P @)
  %11 = getelementptr i8, i8* %9, i64 %7
; # (dec 'Cnt @)
  %12 = sub i64 %10, %7
  br label %$5
$4:
  %13 = phi i8* [%5, %$3] ; # P
  %14 = phi i64 [%6, %$3] ; # Cnt
; # (unless (and @ (== (gErrno) EINTR)) (ret NO))
; # (and @ (== (gErrno) EINTR))
  %15 = icmp ne i64 %7, 0
  br i1 %15, label %$8, label %$7
$8:
  %16 = phi i8* [%13, %$4] ; # P
  %17 = phi i64 [%14, %$4] ; # Cnt
; # (gErrno)
  %18 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %19 = icmp eq i32 %18, 2
  br label %$7
$7:
  %20 = phi i8* [%13, %$4], [%16, %$8] ; # P
  %21 = phi i64 [%14, %$4], [%17, %$8] ; # Cnt
  %22 = phi i1 [0, %$4], [%19, %$8] ; # ->
  br i1 %22, label %$10, label %$9
$9:
  %23 = phi i8* [%20, %$7] ; # P
  %24 = phi i64 [%21, %$7] ; # Cnt
; # (ret NO)
  ret i1 0
$10:
  %25 = phi i8* [%20, %$7] ; # P
  %26 = phi i64 [%21, %$7] ; # Cnt
; # (sigChk 0)
  %27 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %28 = icmp ne i32 %27, 0
  br i1 %28, label %$11, label %$12
$11:
  call void @sighandler(i64 0)
  br label %$12
$12:
  br label %$3
$5:
  %29 = phi i8* [%11, %$6] ; # P
  %30 = phi i64 [%12, %$6] ; # Cnt
  %31 = phi i64 [%12, %$6] ; # ->
; # (? (=0 Cnt) YES)
; # (=0 Cnt)
  %32 = icmp eq i64 %30, 0
  br i1 %32, label %$15, label %$13
$15:
  %33 = phi i8* [%29, %$5] ; # P
  %34 = phi i64 [%30, %$5] ; # Cnt
  br label %$14
$13:
  %35 = phi i8* [%29, %$5] ; # P
  %36 = phi i64 [%30, %$5] ; # Cnt
  br label %$2
$14:
  %37 = phi i8* [%33, %$15] ; # P
  %38 = phi i64 [%34, %$15] ; # Cnt
  %39 = phi i1 [1, %$15] ; # ->
  ret i1 %39
}

define i64 @rdBytesNb(i32, i8*, i64) {
$1:
; # (loop (let (Flg (nonBlocking Fd) N (read Fd P Cnt)) (fcntlSetFl F...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%71, %$25] ; # P
  %4 = phi i64 [%2, %$1], [%72, %$25] ; # Cnt
; # (let (Flg (nonBlocking Fd) N (read Fd P Cnt)) (fcntlSetFl Fd Flg)...
; # (nonBlocking Fd)
  %5 = call i32 @nonBlocking(i32 %0)
; # (read Fd P Cnt)
  %6 = call i64 @read(i32 %0, i8* %3, i64 %4)
; # (fcntlSetFl Fd Flg)
  call void @fcntlSetFl(i32 %0, i32 %5)
; # (when (gt0 N) (loop (unless (dec 'Cnt N) (ret 1)) (inc 'P N) (whi...
; # (gt0 N)
  %7 = icmp sgt i64 %6, 0
  br i1 %7, label %$3, label %$4
$3:
  %8 = phi i8* [%3, %$2] ; # P
  %9 = phi i64 [%4, %$2] ; # Cnt
  %10 = phi i64 [%6, %$2] ; # N
; # (loop (unless (dec 'Cnt N) (ret 1)) (inc 'P N) (while (le0 (setq ...
  br label %$5
$5:
  %11 = phi i8* [%8, %$3], [%49, %$10] ; # P
  %12 = phi i64 [%9, %$3], [%50, %$10] ; # Cnt
  %13 = phi i64 [%10, %$3], [%51, %$10] ; # N
; # (unless (dec 'Cnt N) (ret 1))
; # (dec 'Cnt N)
  %14 = sub i64 %12, %13
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$6:
  %16 = phi i8* [%11, %$5] ; # P
  %17 = phi i64 [%14, %$5] ; # Cnt
  %18 = phi i64 [%13, %$5] ; # N
; # (ret 1)
  ret i64 1
$7:
  %19 = phi i8* [%11, %$5] ; # P
  %20 = phi i64 [%14, %$5] ; # Cnt
  %21 = phi i64 [%13, %$5] ; # N
; # (inc 'P N)
  %22 = getelementptr i8, i8* %19, i64 %21
; # (while (le0 (setq N (read Fd P Cnt))) (unless (and N (== (gErrno)...
  br label %$8
$8:
  %23 = phi i8* [%22, %$7], [%44, %$16] ; # P
  %24 = phi i64 [%20, %$7], [%45, %$16] ; # Cnt
  %25 = phi i64 [%21, %$7], [%46, %$16] ; # N
; # (read Fd P Cnt)
  %26 = call i64 @read(i32 %0, i8* %23, i64 %24)
; # (le0 (setq N (read Fd P Cnt)))
  %27 = icmp sle i64 %26, 0
  br i1 %27, label %$9, label %$10
$9:
  %28 = phi i8* [%23, %$8] ; # P
  %29 = phi i64 [%24, %$8] ; # Cnt
  %30 = phi i64 [%26, %$8] ; # N
; # (unless (and N (== (gErrno) EINTR)) (ret 0))
; # (and N (== (gErrno) EINTR))
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$12, label %$11
$12:
  %32 = phi i8* [%28, %$9] ; # P
  %33 = phi i64 [%29, %$9] ; # Cnt
  %34 = phi i64 [%30, %$9] ; # N
; # (gErrno)
  %35 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %36 = icmp eq i32 %35, 2
  br label %$11
$11:
  %37 = phi i8* [%28, %$9], [%32, %$12] ; # P
  %38 = phi i64 [%29, %$9], [%33, %$12] ; # Cnt
  %39 = phi i64 [%30, %$9], [%34, %$12] ; # N
  %40 = phi i1 [0, %$9], [%36, %$12] ; # ->
  br i1 %40, label %$14, label %$13
$13:
  %41 = phi i8* [%37, %$11] ; # P
  %42 = phi i64 [%38, %$11] ; # Cnt
  %43 = phi i64 [%39, %$11] ; # N
; # (ret 0)
  ret i64 0
$14:
  %44 = phi i8* [%37, %$11] ; # P
  %45 = phi i64 [%38, %$11] ; # Cnt
  %46 = phi i64 [%39, %$11] ; # N
; # (sigChk 0)
  %47 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %48 = icmp ne i32 %47, 0
  br i1 %48, label %$15, label %$16
$15:
  call void @sighandler(i64 0)
  br label %$16
$16:
  br label %$8
$10:
  %49 = phi i8* [%23, %$8] ; # P
  %50 = phi i64 [%24, %$8] ; # Cnt
  %51 = phi i64 [%26, %$8] ; # N
  br label %$5
$4:
  %52 = phi i8* [%3, %$2] ; # P
  %53 = phi i64 [%4, %$2] ; # Cnt
  %54 = phi i64 [%6, %$2] ; # N
; # (? (=0 N) 0)
; # (=0 N)
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %$19, label %$17
$19:
  %56 = phi i8* [%52, %$4] ; # P
  %57 = phi i64 [%53, %$4] ; # Cnt
  %58 = phi i64 [%54, %$4] ; # N
  br label %$18
$17:
  %59 = phi i8* [%52, %$4] ; # P
  %60 = phi i64 [%53, %$4] ; # Cnt
  %61 = phi i64 [%54, %$4] ; # N
; # (? (== (gErrno) EAGAIN) -1)
; # (gErrno)
  %62 = call i32 @gErrno()
; # (== (gErrno) EAGAIN)
  %63 = icmp eq i32 %62, 4
  br i1 %63, label %$21, label %$20
$21:
  %64 = phi i8* [%59, %$17] ; # P
  %65 = phi i64 [%60, %$17] ; # Cnt
  br label %$18
$20:
  %66 = phi i8* [%59, %$17] ; # P
  %67 = phi i64 [%60, %$17] ; # Cnt
; # (? (<> @ EINTR) 0)
; # (<> @ EINTR)
  %68 = icmp ne i32 %62, 2
  br i1 %68, label %$23, label %$22
$23:
  %69 = phi i8* [%66, %$20] ; # P
  %70 = phi i64 [%67, %$20] ; # Cnt
  br label %$18
$22:
  %71 = phi i8* [%66, %$20] ; # P
  %72 = phi i64 [%67, %$20] ; # Cnt
; # (sigChk 0)
  %73 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %74 = icmp ne i32 %73, 0
  br i1 %74, label %$24, label %$25
$24:
  call void @sighandler(i64 0)
  br label %$25
$25:
  br label %$2
$18:
  %75 = phi i8* [%56, %$19], [%64, %$21], [%69, %$23] ; # P
  %76 = phi i64 [%57, %$19], [%65, %$21], [%70, %$23] ; # Cnt
  %77 = phi i64 [0, %$19], [-1, %$21], [0, %$23] ; # ->
  ret i64 %77
}

define i1 @wrBytes(i32, i8*, i64) {
$1:
; # (loop (let N (write Fd P Cnt) (if (lt0 N) (let E (gErrno) (? (== ...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%46, %$5] ; # P
  %4 = phi i64 [%2, %$1], [%47, %$5] ; # Cnt
; # (let N (write Fd P Cnt) (if (lt0 N) (let E (gErrno) (? (== E EBAD...
; # (write Fd P Cnt)
  %5 = call i64 @write(i32 %0, i8* %3, i64 %4)
; # (if (lt0 N) (let E (gErrno) (? (== E EBADF) NO) (? (== E EPIPE) N...
; # (lt0 N)
  %6 = icmp slt i64 %5, 0
  br i1 %6, label %$3, label %$4
$3:
  %7 = phi i8* [%3, %$2] ; # P
  %8 = phi i64 [%4, %$2] ; # Cnt
; # (let E (gErrno) (? (== E EBADF) NO) (? (== E EPIPE) NO) (? (== E ...
; # (gErrno)
  %9 = call i32 @gErrno()
; # (? (== E EBADF) NO)
; # (== E EBADF)
  %10 = icmp eq i32 %9, 3
  br i1 %10, label %$8, label %$6
$8:
  %11 = phi i8* [%7, %$3] ; # P
  %12 = phi i64 [%8, %$3] ; # Cnt
  br label %$7
$6:
  %13 = phi i8* [%7, %$3] ; # P
  %14 = phi i64 [%8, %$3] ; # Cnt
; # (? (== E EPIPE) NO)
; # (== E EPIPE)
  %15 = icmp eq i32 %9, 6
  br i1 %15, label %$10, label %$9
$10:
  %16 = phi i8* [%13, %$6] ; # P
  %17 = phi i64 [%14, %$6] ; # Cnt
  br label %$7
$9:
  %18 = phi i8* [%13, %$6] ; # P
  %19 = phi i64 [%14, %$6] ; # Cnt
; # (? (== E ECONNRESET) NO)
; # (== E ECONNRESET)
  %20 = icmp eq i32 %9, 7
  br i1 %20, label %$12, label %$11
$12:
  %21 = phi i8* [%18, %$9] ; # P
  %22 = phi i64 [%19, %$9] ; # Cnt
  br label %$7
$11:
  %23 = phi i8* [%18, %$9] ; # P
  %24 = phi i64 [%19, %$9] ; # Cnt
; # (unless (== E EINTR) (when (== Fd 2) (bye 2)) (writeErr ($ "bytes...
; # (== E EINTR)
  %25 = icmp eq i32 %9, 2
  br i1 %25, label %$14, label %$13
$13:
  %26 = phi i8* [%23, %$11] ; # P
  %27 = phi i64 [%24, %$11] ; # Cnt
; # (when (== Fd 2) (bye 2))
; # (== Fd 2)
  %28 = icmp eq i32 %0, 2
  br i1 %28, label %$15, label %$16
$15:
  %29 = phi i8* [%26, %$13] ; # P
  %30 = phi i64 [%27, %$13] ; # Cnt
; # (bye 2)
  call void @bye(i32 2)
  unreachable
$16:
  %31 = phi i8* [%26, %$13] ; # P
  %32 = phi i64 [%27, %$13] ; # Cnt
; # (writeErr ($ "bytes write: %s"))
  call void @writeErr(i8* bitcast ([16 x i8]* @$34 to i8*))
  unreachable
$14:
  %33 = phi i8* [%23, %$11] ; # P
  %34 = phi i64 [%24, %$11] ; # Cnt
; # (sigChk 0)
  %35 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %$17, label %$18
$17:
  call void @sighandler(i64 0)
  br label %$18
$18:
  br label %$5
$4:
  %37 = phi i8* [%3, %$2] ; # P
  %38 = phi i64 [%4, %$2] ; # Cnt
; # (? (=0 (dec 'Cnt N)) YES)
; # (dec 'Cnt N)
  %39 = sub i64 %38, %5
; # (=0 (dec 'Cnt N))
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %$20, label %$19
$20:
  %41 = phi i8* [%37, %$4] ; # P
  %42 = phi i64 [%39, %$4] ; # Cnt
  br label %$7
$19:
  %43 = phi i8* [%37, %$4] ; # P
  %44 = phi i64 [%39, %$4] ; # Cnt
; # (inc 'P N)
  %45 = getelementptr i8, i8* %43, i64 %5
  br label %$5
$5:
  %46 = phi i8* [%33, %$18], [%45, %$19] ; # P
  %47 = phi i64 [%34, %$18], [%44, %$19] ; # Cnt
  br label %$2
$7:
  %48 = phi i8* [%11, %$8], [%16, %$10], [%21, %$12], [%41, %$20] ; # P
  %49 = phi i64 [%12, %$8], [%17, %$10], [%22, %$12], [%42, %$20] ; # Cnt
  %50 = phi i1 [0, %$8], [0, %$10], [0, %$12], [1, %$20] ; # ->
  ret i1 %50
}

define void @clsChild(i8*) {
$1:
; # (let Cld: (child Cld) (when (== (Cld: pid) (val $Talking)) (set $...
; # (when (== (Cld: pid) (val $Talking)) (set $Talking 0))
; # (Cld: pid)
  %1 = getelementptr i8, i8* %0, i32 24
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (val $Talking)
  %4 = load i32, i32* @$Talking
; # (== (Cld: pid) (val $Talking))
  %5 = icmp eq i32 %3, %4
  br i1 %5, label %$2, label %$3
$2:
; # (set $Talking 0)
  store i32 0, i32* @$Talking
  br label %$3
$3:
; # (Cld: pid 0)
  %6 = getelementptr i8, i8* %0, i32 24
  %7 = bitcast i8* %6 to i32*
  store i32 0, i32* %7
; # (Cld: hear)
  %8 = getelementptr i8, i8* %0, i32 28
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (close (Cld: hear))
  %11 = call i32 @close(i32 %10)
; # (Cld: buf)
  %12 = bitcast i8* %0 to i8**
  %13 = load i8*, i8** %12
; # (free (Cld: buf))
  call void @free(i8* %13)
  ret void
}

define void @wrChild(i8*, i8*, i64) {
$1:
; # (let (Cld: (child Cld) C (Cld: cnt)) (unless C (loop (let N (writ...
; # (Cld: cnt)
  %3 = getelementptr i8, i8* %0, i32 16
  %4 = bitcast i8* %3 to i64*
  %5 = load i64, i64* %4
; # (unless C (loop (let N (write (Cld: tell) P Cnt) (if (lt0 N) (let...
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i8* [%1, %$1] ; # P
  %8 = phi i64 [%2, %$1] ; # Cnt
; # (loop (let N (write (Cld: tell) P Cnt) (if (lt0 N) (let E (gErrno...
  br label %$4
$4:
  %9 = phi i8* [%7, %$2], [%47, %$7] ; # P
  %10 = phi i64 [%8, %$2], [%48, %$7] ; # Cnt
; # (let N (write (Cld: tell) P Cnt) (if (lt0 N) (let E (gErrno) (? (...
; # (Cld: tell)
  %11 = getelementptr i8, i8* %0, i32 32
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
; # (write (Cld: tell) P Cnt)
  %14 = call i64 @write(i32 %13, i8* %9, i64 %10)
; # (if (lt0 N) (let E (gErrno) (? (== E EAGAIN)) (when (or (== E EPI...
; # (lt0 N)
  %15 = icmp slt i64 %14, 0
  br i1 %15, label %$5, label %$6
$5:
  %16 = phi i8* [%9, %$4] ; # P
  %17 = phi i64 [%10, %$4] ; # Cnt
; # (let E (gErrno) (? (== E EAGAIN)) (when (or (== E EPIPE) (== E EC...
; # (gErrno)
  %18 = call i32 @gErrno()
; # (? (== E EAGAIN))
; # (== E EAGAIN)
  %19 = icmp eq i32 %18, 4
  br i1 %19, label %$9, label %$8
$8:
  %20 = phi i8* [%16, %$5] ; # P
  %21 = phi i64 [%17, %$5] ; # Cnt
; # (when (or (== E EPIPE) (== E ECONNRESET)) (clsChild Cld) (ret))
; # (or (== E EPIPE) (== E ECONNRESET))
; # (== E EPIPE)
  %22 = icmp eq i32 %18, 6
  br i1 %22, label %$10, label %$11
$11:
  %23 = phi i8* [%20, %$8] ; # P
  %24 = phi i64 [%21, %$8] ; # Cnt
; # (== E ECONNRESET)
  %25 = icmp eq i32 %18, 7
  br label %$10
$10:
  %26 = phi i8* [%20, %$8], [%23, %$11] ; # P
  %27 = phi i64 [%21, %$8], [%24, %$11] ; # Cnt
  %28 = phi i1 [1, %$8], [%25, %$11] ; # ->
  br i1 %28, label %$12, label %$13
$12:
  %29 = phi i8* [%26, %$10] ; # P
  %30 = phi i64 [%27, %$10] ; # Cnt
; # (clsChild Cld)
  call void @clsChild(i8* %0)
; # (ret)
  ret void
$13:
  %31 = phi i8* [%26, %$10] ; # P
  %32 = phi i64 [%27, %$10] ; # Cnt
; # (unless (== E EINTR) (writeErr ($ "child write: %s")))
; # (== E EINTR)
  %33 = icmp eq i32 %18, 2
  br i1 %33, label %$15, label %$14
$14:
  %34 = phi i8* [%31, %$13] ; # P
  %35 = phi i64 [%32, %$13] ; # Cnt
; # (writeErr ($ "child write: %s"))
  call void @writeErr(i8* bitcast ([16 x i8]* @$35 to i8*))
  unreachable
$15:
  %36 = phi i8* [%31, %$13] ; # P
  %37 = phi i64 [%32, %$13] ; # Cnt
  br label %$7
$6:
  %38 = phi i8* [%9, %$4] ; # P
  %39 = phi i64 [%10, %$4] ; # Cnt
; # (unless (dec 'Cnt N) (ret))
; # (dec 'Cnt N)
  %40 = sub i64 %39, %14
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$17, label %$16
$16:
  %42 = phi i8* [%38, %$6] ; # P
  %43 = phi i64 [%40, %$6] ; # Cnt
; # (ret)
  ret void
$17:
  %44 = phi i8* [%38, %$6] ; # P
  %45 = phi i64 [%40, %$6] ; # Cnt
; # (inc 'P N)
  %46 = getelementptr i8, i8* %44, i64 %14
  br label %$7
$7:
  %47 = phi i8* [%36, %$15], [%46, %$17] ; # P
  %48 = phi i64 [%37, %$15], [%45, %$17] ; # Cnt
  br label %$4
$9:
  %49 = phi i8* [%16, %$5] ; # P
  %50 = phi i64 [%17, %$5] ; # Cnt
  %51 = phi i64 [0, %$5] ; # ->
  br label %$3
$3:
  %52 = phi i8* [%1, %$1], [%49, %$9] ; # P
  %53 = phi i64 [%2, %$1], [%50, %$9] ; # Cnt
; # (+ C Cnt 8)
  %54 = add i64 %5, %53
  %55 = add i64 %54, 8
; # (let Q (ofs (Cld: buf (alloc (Cld: buf) N)) C) (set (i64* Q) Cnt)...
; # (Cld: buf (alloc (Cld: buf) N))
  %56 = bitcast i8* %0 to i8**
  %57 = bitcast i8* %0 to i8**
  %58 = load i8*, i8** %57
  %59 = call i8* @alloc(i8* %58, i64 %55)
  store i8* %59, i8** %56
; # (ofs (Cld: buf (alloc (Cld: buf) N)) C)
  %60 = getelementptr i8, i8* %59, i64 %5
; # (set (i64* Q) Cnt)
; # (i64* Q)
  %61 = bitcast i8* %60 to i64*
  store i64 %53, i64* %61
; # (ofs Q 8)
  %62 = getelementptr i8, i8* %60, i32 8
; # (memcpy (ofs Q 8) P Cnt)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %62, i8* %52, i64 %53, i1 0)
; # (Cld: cnt N)
  %63 = getelementptr i8, i8* %0, i32 16
  %64 = bitcast i8* %63 to i64*
  store i64 %55, i64* %64
  ret void
}

define i1 @flush(i8*) {
$1:
; # (ifn Out YES (let Out: (outFile Out) (ifn (Out: ix) YES (Out: ix ...
  %1 = icmp ne i8* %0, null
  br i1 %1, label %$3, label %$2
$2:
  br label %$4
$3:
; # (let Out: (outFile Out) (ifn (Out: ix) YES (Out: ix 0) (wrBytes (...
; # (ifn (Out: ix) YES (Out: ix 0) (wrBytes (Out: fd) (Out: (buf)) @)...
; # (Out: ix)
  %2 = bitcast i8* %0 to i64*
  %3 = load i64, i64* %2
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$6, label %$5
$5:
  br label %$7
$6:
; # (Out: ix 0)
  %5 = bitcast i8* %0 to i64*
  store i64 0, i64* %5
; # (Out: fd)
  %6 = getelementptr i8, i8* %0, i32 8
  %7 = bitcast i8* %6 to i32*
  %8 = load i32, i32* %7
; # (Out: (buf))
  %9 = getelementptr i8, i8* %0, i32 12
; # (wrBytes (Out: fd) (Out: (buf)) @)
  %10 = call i1 @wrBytes(i32 %8, i8* %9, i64 %3)
  br label %$7
$7:
  %11 = phi i1 [1, %$5], [%10, %$6] ; # ->
  br label %$4
$4:
  %12 = phi i1 [1, %$2], [%11, %$7] ; # ->
  ret i1 %12
}

define void @flushAll() {
$1:
; # (let (A (val $OutFiles) N (val $OutFDs) I (i32 0)) (while (> N I)...
; # (val $OutFiles)
  %0 = load i8**, i8*** @$OutFiles
; # (val $OutFDs)
  %1 = load i32, i32* @$OutFDs
; # (i32 0)
; # (while (> N I) (flush (val (ofs A I))) (inc 'I))
  br label %$2
$2:
  %2 = phi i32 [0, %$1], [%8, %$3] ; # I
; # (> N I)
  %3 = icmp sgt i32 %1, %2
  br i1 %3, label %$3, label %$4
$3:
  %4 = phi i32 [%2, %$2] ; # I
; # (ofs A I)
  %5 = getelementptr i8*, i8** %0, i32 %4
; # (val (ofs A I))
  %6 = load i8*, i8** %5
; # (flush (val (ofs A I)))
  %7 = call i1 @flush(i8* %6)
; # (inc 'I)
  %8 = add i32 %4, 1
  br label %$2
$4:
  %9 = phi i32 [%2, %$2] ; # I
  ret void
}

define i32 @stdinByte() {
$1:
; # (let In: (inFile (val (val $InFiles))) (when (In:) (when (or (<> ...
; # (val $InFiles)
  %0 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %1 = load i8*, i8** %0
; # (when (In:) (when (or (<> (In: ix) (In: cnt)) (and (ge0 @) (slow ...
; # (In:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$2, label %$3
$2:
; # (when (or (<> (In: ix) (In: cnt)) (and (ge0 @) (slow (In:)))) (le...
; # (or (<> (In: ix) (In: cnt)) (and (ge0 @) (slow (In:))))
; # (In: ix)
  %3 = bitcast i8* %1 to i64*
  %4 = load i64, i64* %3
; # (In: cnt)
  %5 = getelementptr i8, i8* %1, i32 8
  %6 = bitcast i8* %5 to i64*
  %7 = load i64, i64* %6
; # (<> (In: ix) (In: cnt))
  %8 = icmp ne i64 %4, %7
  br i1 %8, label %$4, label %$5
$5:
; # (and (ge0 @) (slow (In:)))
; # (ge0 @)
  %9 = icmp sge i64 %4, 0
  br i1 %9, label %$7, label %$6
$7:
; # (In:)
; # (slow (In:))
  %10 = call i64 @slow(i8* %1)
  %11 = icmp ne i64 %10, 0
  br label %$6
$6:
  %12 = phi i1 [0, %$5], [%11, %$7] ; # ->
  br label %$4
$4:
  %13 = phi i1 [1, %$2], [%12, %$6] ; # ->
  br i1 %13, label %$8, label %$9
$8:
; # (let I (In: ix) (In: ix (+ I 1)) (ret (i32 (val (ofs (In: (buf)) ...
; # (In: ix)
  %14 = bitcast i8* %1 to i64*
  %15 = load i64, i64* %14
; # (In: ix (+ I 1))
  %16 = bitcast i8* %1 to i64*
  %17 = add i64 %15, 1
  store i64 %17, i64* %16
; # (In: (buf))
  %18 = getelementptr i8, i8* %1, i32 40
; # (ofs (In: (buf)) I)
  %19 = getelementptr i8, i8* %18, i64 %15
; # (val (ofs (In: (buf)) I))
  %20 = load i8, i8* %19
; # (i32 (val (ofs (In: (buf)) I)))
  %21 = zext i8 %20 to i32
; # (ret (i32 (val (ofs (In: (buf)) I))))
  ret i32 %21
$9:
  br label %$3
$3:
; # (when (isatty 0) (bye 0))
; # (isatty 0)
  %22 = call i32 @isatty(i32 0)
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %$10, label %$11
$10:
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$11:
  ret i32 -1
}

define i32 @getBinary() {
$1:
; # (let (In: (inFile (val $InFile)) I (In: ix)) (when (== I (In: cnt...
; # (val $InFile)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (In: ix)
  %1 = bitcast i8* %0 to i64*
  %2 = load i64, i64* %1
; # (when (== I (In: cnt)) (when (lt0 I) (ret -1)) (unless (slow (In:...
; # (In: cnt)
  %3 = getelementptr i8, i8* %0, i32 8
  %4 = bitcast i8* %3 to i64*
  %5 = load i64, i64* %4
; # (== I (In: cnt))
  %6 = icmp eq i64 %2, %5
  br i1 %6, label %$2, label %$3
$2:
  %7 = phi i64 [%2, %$1] ; # I
; # (when (lt0 I) (ret -1))
; # (lt0 I)
  %8 = icmp slt i64 %7, 0
  br i1 %8, label %$4, label %$5
$4:
  %9 = phi i64 [%7, %$2] ; # I
; # (ret -1)
  ret i32 -1
$5:
  %10 = phi i64 [%7, %$2] ; # I
; # (unless (slow (In:)) (ret -1))
; # (In:)
; # (slow (In:))
  %11 = call i64 @slow(i8* %0)
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$6:
  %13 = phi i64 [%10, %$5] ; # I
; # (ret -1)
  ret i32 -1
$7:
  %14 = phi i64 [%10, %$5] ; # I
  br label %$3
$3:
  %15 = phi i64 [%2, %$1], [0, %$7] ; # I
; # (In: ix (+ I 1))
  %16 = bitcast i8* %0 to i64*
  %17 = add i64 %15, 1
  store i64 %17, i64* %16
; # (In: (buf))
  %18 = getelementptr i8, i8* %0, i32 40
; # (ofs (In: (buf)) I)
  %19 = getelementptr i8, i8* %18, i64 %15
; # (val (ofs (In: (buf)) I))
  %20 = load i8, i8* %19
; # (i32 (val (ofs (In: (buf)) I)))
  %21 = zext i8 %20 to i32
  ret i32 %21
}

define i64 @binRead() {
$1:
; # (let B (call $GetBin) (cond ((lt0 B) 0) ((== B NIX) $Nil) ((=0 (&...
; # (call $GetBin)
  %0 = load i32()*, i32()** @$GetBin
  %1 = call i32 %0()
; # (cond ((lt0 B) 0) ((== B NIX) $Nil) ((=0 (& B -4)) (if (<> BEG B)...
; # (lt0 B)
  %2 = icmp slt i32 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  br label %$2
$3:
; # (== B NIX)
  %3 = icmp eq i32 %1, 0
  br i1 %3, label %$6, label %$5
$6:
  br label %$2
$5:
; # (& B -4)
  %4 = and i32 %1, -4
; # (=0 (& B -4))
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %$8, label %$7
$8:
; # (if (<> BEG B) (any (i64 B)) (let X (binRead) (ifn X 0 (let (Y (c...
; # (<> BEG B)
  %6 = icmp ne i32 1, %1
  br i1 %6, label %$9, label %$10
$9:
; # (i64 B)
  %7 = sext i32 %1 to i64
; # (any (i64 B))
  br label %$11
$10:
; # (let X (binRead) (ifn X 0 (let (Y (cons X $Nil) R (save Y)) (loop...
; # (binRead)
  %8 = call i64 @binRead()
; # (ifn X 0 (let (Y (cons X $Nil) R (save Y)) (loop (? (=0 (setq X (...
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$13, label %$12
$12:
  %10 = phi i64 [%8, %$10] ; # X
  br label %$14
$13:
  %11 = phi i64 [%8, %$10] ; # X
; # (let (Y (cons X $Nil) R (save Y)) (loop (? (=0 (setq X (binRead))...
; # (cons X $Nil)
  %12 = call i64 @cons(i64 %11, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %13 = alloca i64, i64 2, align 16
  %14 = ptrtoint i64* %13 to i64
  %15 = inttoptr i64 %14 to i64*
  store i64 %12, i64* %15
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %14 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  store i64 %17, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %14, i64* %20
; # (loop (? (=0 (setq X (binRead))) 0) (? (== X END) R) (? (== X DOT...
  br label %$15
$15:
  %21 = phi i64 [%11, %$13], [%56, %$21] ; # X
  %22 = phi i64 [%12, %$13], [%58, %$21] ; # Y
; # (? (=0 (setq X (binRead))) 0)
; # (binRead)
  %23 = call i64 @binRead()
; # (=0 (setq X (binRead)))
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$18, label %$16
$18:
  %25 = phi i64 [%23, %$15] ; # X
  %26 = phi i64 [%22, %$15] ; # Y
  br label %$17
$16:
  %27 = phi i64 [%23, %$15] ; # X
  %28 = phi i64 [%22, %$15] ; # Y
; # (? (== X END) R)
; # (== X END)
  %29 = icmp eq i64 %27, 3
  br i1 %29, label %$20, label %$19
$20:
  %30 = phi i64 [%27, %$16] ; # X
  %31 = phi i64 [%28, %$16] ; # Y
  br label %$17
$19:
  %32 = phi i64 [%27, %$16] ; # X
  %33 = phi i64 [%28, %$16] ; # Y
; # (? (== X DOT) (ifn (setq X (binRead)) 0 (set 2 Y (if (== X END) R...
; # (== X DOT)
  %34 = icmp eq i64 %32, 2
  br i1 %34, label %$22, label %$21
$22:
  %35 = phi i64 [%32, %$19] ; # X
  %36 = phi i64 [%33, %$19] ; # Y
; # (ifn (setq X (binRead)) 0 (set 2 Y (if (== X END) R X)) R)
; # (binRead)
  %37 = call i64 @binRead()
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$24, label %$23
$23:
  %39 = phi i64 [%37, %$22] ; # X
  %40 = phi i64 [%36, %$22] ; # Y
  br label %$25
$24:
  %41 = phi i64 [%37, %$22] ; # X
  %42 = phi i64 [%36, %$22] ; # Y
; # (set 2 Y (if (== X END) R X))
; # (if (== X END) R X)
; # (== X END)
  %43 = icmp eq i64 %41, 3
  br i1 %43, label %$26, label %$27
$26:
  %44 = phi i64 [%41, %$24] ; # X
  %45 = phi i64 [%42, %$24] ; # Y
  br label %$28
$27:
  %46 = phi i64 [%41, %$24] ; # X
  %47 = phi i64 [%42, %$24] ; # Y
  br label %$28
$28:
  %48 = phi i64 [%44, %$26], [%46, %$27] ; # X
  %49 = phi i64 [%45, %$26], [%47, %$27] ; # Y
  %50 = phi i64 [%12, %$26], [%46, %$27] ; # ->
  %51 = inttoptr i64 %42 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %50, i64* %52
  br label %$25
$25:
  %53 = phi i64 [%39, %$23], [%48, %$28] ; # X
  %54 = phi i64 [%40, %$23], [%49, %$28] ; # Y
  %55 = phi i64 [0, %$23], [%12, %$28] ; # ->
  br label %$17
$21:
  %56 = phi i64 [%32, %$19] ; # X
  %57 = phi i64 [%33, %$19] ; # Y
; # (set 2 Y (cons X $Nil))
; # (cons X $Nil)
  %58 = call i64 @cons(i64 %56, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %59 = inttoptr i64 %57 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  store i64 %58, i64* %60
  br label %$15
$17:
  %61 = phi i64 [%25, %$18], [%30, %$20], [%53, %$25] ; # X
  %62 = phi i64 [%26, %$18], [%31, %$20], [%54, %$25] ; # Y
  %63 = phi i64 [0, %$18], [%12, %$20], [%55, %$25] ; # ->
; # (drop *Safe)
  %64 = inttoptr i64 %14 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  %66 = load i64, i64* %65
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %66, i64* %67
  br label %$14
$14:
  %68 = phi i64 [%10, %$12], [%61, %$17] ; # X
  %69 = phi i64 [0, %$12], [%63, %$17] ; # ->
  br label %$11
$11:
  %70 = phi i64 [%7, %$9], [%69, %$14] ; # ->
  br label %$2
$7:
; # (let (P (i64* (push NIL NIL ZERO NIL)) Q (link (ofs P 2)) Cnt (sh...
; # (push NIL NIL ZERO NIL)
  %71 = alloca i64, i64 4, align 16
  %72 = ptrtoint i64* %71 to i64
  %73 = add i64 %72, 16
  %74 = inttoptr i64 %73 to i64*
  store i64 2, i64* %74
; # (i64* (push NIL NIL ZERO NIL))
  %75 = inttoptr i64 %72 to i64*
; # (ofs P 2)
  %76 = getelementptr i64, i64* %75, i32 2
; # (link (ofs P 2))
  %77 = ptrtoint i64* %76 to i64
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
; # (shr B 2)
  %83 = lshr i32 %1, 2
; # (& B 3)
  %84 = and i32 %1, 3
; # (cond ((== Tag NUMBER) (set P 3) (when (== Cnt 63) (loop (loop (w...
; # (== Tag NUMBER)
  %85 = icmp eq i32 %84, 0
  br i1 %85, label %$31, label %$30
$31:
  %86 = phi i32 [%83, %$7] ; # Cnt
; # (set P 3)
  store i64 3, i64* %75
; # (when (== Cnt 63) (loop (loop (when (lt0 (call $GetBin)) (: 1 (dr...
; # (== Cnt 63)
  %87 = icmp eq i32 %86, 63
  br i1 %87, label %$32, label %$33
$32:
  %88 = phi i32 [%86, %$31] ; # Cnt
; # (loop (loop (when (lt0 (call $GetBin)) (: 1 (drop Q) (ret 0))) (b...
  br label %$34
$34:
  %89 = phi i32 [%88, %$32], [%113, %$42] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (: 1 (drop Q) (ret 0))) (byteNum...
  br label %$35
$35:
  %90 = phi i32 [%89, %$34], [%104, %$38] ; # Cnt
; # (when (lt0 (call $GetBin)) (: 1 (drop Q) (ret 0)))
; # (call $GetBin)
  %91 = load i32()*, i32()** @$GetBin
  %92 = call i32 %91()
; # (lt0 (call $GetBin))
  %93 = icmp slt i32 %92, 0
  br i1 %93, label %$36, label %$37
$36:
  %94 = phi i32 [%90, %$35] ; # Cnt
; # (: 1 (drop Q) (ret 0))
  br label %$-1
$-1:
  %95 = phi i32 [%94, %$36], [%110, %$40], [%124, %$47], [%157, %$58], [%168, %$62], [%182, %$69] ; # Cnt
; # (drop Q)
  %96 = inttoptr i64 %77 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  %98 = load i64, i64* %97
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %98, i64* %99
; # (ret 0)
  ret i64 0
$37:
  %100 = phi i32 [%90, %$35] ; # Cnt
; # (i8 @)
  %101 = trunc i32 %92 to i8
; # (byteNum (i8 @) P)
  call void @byteNum(i8 %101, i64* %75)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %102 = sub i32 %100, 1
; # (=0 (dec 'Cnt))
  %103 = icmp eq i32 %102, 0
  br i1 %103, label %$39, label %$38
$38:
  %104 = phi i32 [%102, %$37] ; # Cnt
  br label %$35
$39:
  %105 = phi i32 [%102, %$37] ; # Cnt
  %106 = phi i64 [0, %$37] ; # ->
; # (when (lt0 (setq Cnt (call $GetBin))) (goto 1))
; # (call $GetBin)
  %107 = load i32()*, i32()** @$GetBin
  %108 = call i32 %107()
; # (lt0 (setq Cnt (call $GetBin)))
  %109 = icmp slt i32 %108, 0
  br i1 %109, label %$40, label %$41
$40:
  %110 = phi i32 [%108, %$39] ; # Cnt
; # (goto 1)
  br label %$-1
$41:
  %111 = phi i32 [%108, %$39] ; # Cnt
; # (? (<> Cnt 255))
; # (<> Cnt 255)
  %112 = icmp ne i32 %111, 255
  br i1 %112, label %$43, label %$42
$42:
  %113 = phi i32 [%111, %$41] ; # Cnt
  br label %$34
$43:
  %114 = phi i32 [%111, %$41] ; # Cnt
  %115 = phi i64 [0, %$41] ; # ->
; # (unless Cnt (goto 2))
  %116 = icmp ne i32 %114, 0
  br i1 %116, label %$45, label %$44
$44:
  %117 = phi i32 [%114, %$43] ; # Cnt
; # (goto 2)
  br label %$-2
$45:
  %118 = phi i32 [%114, %$43] ; # Cnt
  br label %$33
$33:
  %119 = phi i32 [%86, %$31], [%118, %$45] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (goto 1)) (byteNum (i8 @) P) (? ...
  br label %$46
$46:
  %120 = phi i32 [%119, %$33], [%129, %$49] ; # Cnt
; # (when (lt0 (call $GetBin)) (goto 1))
; # (call $GetBin)
  %121 = load i32()*, i32()** @$GetBin
  %122 = call i32 %121()
; # (lt0 (call $GetBin))
  %123 = icmp slt i32 %122, 0
  br i1 %123, label %$47, label %$48
$47:
  %124 = phi i32 [%120, %$46] ; # Cnt
; # (goto 1)
  br label %$-1
$48:
  %125 = phi i32 [%120, %$46] ; # Cnt
; # (i8 @)
  %126 = trunc i32 %122 to i8
; # (byteNum (i8 @) P)
  call void @byteNum(i8 %126, i64* %75)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %127 = sub i32 %125, 1
; # (=0 (dec 'Cnt))
  %128 = icmp eq i32 %127, 0
  br i1 %128, label %$50, label %$49
$49:
  %129 = phi i32 [%127, %$48] ; # Cnt
  br label %$46
$50:
  %130 = phi i32 [%127, %$48] ; # Cnt
  %131 = phi i64 [0, %$48] ; # ->
; # (: 2 (drop Q (if (cnt? (val Q)) @ (| (half @) (shl (& @ 1) 3)))))...
  br label %$-2
$-2:
  %132 = phi i32 [%117, %$44], [%130, %$50] ; # Cnt
; # (drop Q (if (cnt? (val Q)) @ (| (half @) (shl (& @ 1) 3))))
; # (if (cnt? (val Q)) @ (| (half @) (shl (& @ 1) 3)))
; # (val Q)
  %133 = inttoptr i64 %77 to i64*
  %134 = load i64, i64* %133
; # (cnt? (val Q))
  %135 = and i64 %134, 2
  %136 = icmp ne i64 %135, 0
  br i1 %136, label %$51, label %$52
$51:
  %137 = phi i32 [%132, %$-2] ; # Cnt
  br label %$53
$52:
  %138 = phi i32 [%132, %$-2] ; # Cnt
; # (half @)
  %139 = call i64 @half(i64 %134)
; # (& @ 1)
  %140 = and i64 %134, 1
; # (shl (& @ 1) 3)
  %141 = shl i64 %140, 3
; # (| (half @) (shl (& @ 1) 3))
  %142 = or i64 %139, %141
  br label %$53
$53:
  %143 = phi i32 [%137, %$51], [%138, %$52] ; # Cnt
  %144 = phi i64 [%134, %$51], [%142, %$52] ; # ->
  %145 = inttoptr i64 %77 to i64*
  %146 = getelementptr i64, i64* %145, i32 1
  %147 = load i64, i64* %146
  %148 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %147, i64* %148
  br label %$29
$30:
  %149 = phi i32 [%83, %$7] ; # Cnt
; # (set P 4)
  store i64 4, i64* %75
; # (when (== Cnt 63) (loop (loop (when (lt0 (call $GetBin)) (goto 1)...
; # (== Cnt 63)
  %150 = icmp eq i32 %149, 63
  br i1 %150, label %$54, label %$55
$54:
  %151 = phi i32 [%149, %$30] ; # Cnt
; # (loop (loop (when (lt0 (call $GetBin)) (goto 1)) (byteSym (i8 @) ...
  br label %$56
$56:
  %152 = phi i32 [%151, %$54], [%171, %$64] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (goto 1)) (byteSym (i8 @) P) (? ...
  br label %$57
$57:
  %153 = phi i32 [%152, %$56], [%162, %$60] ; # Cnt
; # (when (lt0 (call $GetBin)) (goto 1))
; # (call $GetBin)
  %154 = load i32()*, i32()** @$GetBin
  %155 = call i32 %154()
; # (lt0 (call $GetBin))
  %156 = icmp slt i32 %155, 0
  br i1 %156, label %$58, label %$59
$58:
  %157 = phi i32 [%153, %$57] ; # Cnt
; # (goto 1)
  br label %$-1
$59:
  %158 = phi i32 [%153, %$57] ; # Cnt
; # (i8 @)
  %159 = trunc i32 %155 to i8
; # (byteSym (i8 @) P)
  call void @byteSym(i8 %159, i64* %75)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %160 = sub i32 %158, 1
; # (=0 (dec 'Cnt))
  %161 = icmp eq i32 %160, 0
  br i1 %161, label %$61, label %$60
$60:
  %162 = phi i32 [%160, %$59] ; # Cnt
  br label %$57
$61:
  %163 = phi i32 [%160, %$59] ; # Cnt
  %164 = phi i64 [0, %$59] ; # ->
; # (when (lt0 (setq Cnt (call $GetBin))) (goto 1))
; # (call $GetBin)
  %165 = load i32()*, i32()** @$GetBin
  %166 = call i32 %165()
; # (lt0 (setq Cnt (call $GetBin)))
  %167 = icmp slt i32 %166, 0
  br i1 %167, label %$62, label %$63
$62:
  %168 = phi i32 [%166, %$61] ; # Cnt
; # (goto 1)
  br label %$-1
$63:
  %169 = phi i32 [%166, %$61] ; # Cnt
; # (? (<> Cnt 255))
; # (<> Cnt 255)
  %170 = icmp ne i32 %169, 255
  br i1 %170, label %$65, label %$64
$64:
  %171 = phi i32 [%169, %$63] ; # Cnt
  br label %$56
$65:
  %172 = phi i32 [%169, %$63] ; # Cnt
  %173 = phi i64 [0, %$63] ; # ->
; # (unless Cnt (goto 3))
  %174 = icmp ne i32 %172, 0
  br i1 %174, label %$67, label %$66
$66:
  %175 = phi i32 [%172, %$65] ; # Cnt
; # (goto 3)
  br label %$-3
$67:
  %176 = phi i32 [%172, %$65] ; # Cnt
  br label %$55
$55:
  %177 = phi i32 [%149, %$30], [%176, %$67] ; # Cnt
; # (loop (when (lt0 (call $GetBin)) (goto 1)) (byteSym (i8 @) P) (? ...
  br label %$68
$68:
  %178 = phi i32 [%177, %$55], [%187, %$71] ; # Cnt
; # (when (lt0 (call $GetBin)) (goto 1))
; # (call $GetBin)
  %179 = load i32()*, i32()** @$GetBin
  %180 = call i32 %179()
; # (lt0 (call $GetBin))
  %181 = icmp slt i32 %180, 0
  br i1 %181, label %$69, label %$70
$69:
  %182 = phi i32 [%178, %$68] ; # Cnt
; # (goto 1)
  br label %$-1
$70:
  %183 = phi i32 [%178, %$68] ; # Cnt
; # (i8 @)
  %184 = trunc i32 %180 to i8
; # (byteSym (i8 @) P)
  call void @byteSym(i8 %184, i64* %75)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %185 = sub i32 %183, 1
; # (=0 (dec 'Cnt))
  %186 = icmp eq i32 %185, 0
  br i1 %186, label %$72, label %$71
$71:
  %187 = phi i32 [%185, %$70] ; # Cnt
  br label %$68
$72:
  %188 = phi i32 [%185, %$70] ; # Cnt
  %189 = phi i64 [0, %$70] ; # ->
; # (: 3 (drop Q (let Nm (val Q) (case Tag (TRANSIENT (consStr Nm)) (...
  br label %$-3
$-3:
  %190 = phi i32 [%175, %$66], [%188, %$72] ; # Cnt
; # (drop Q (let Nm (val Q) (case Tag (TRANSIENT (consStr Nm)) (INTER...
; # (let Nm (val Q) (case Tag (TRANSIENT (consStr Nm)) (INTERN (reque...
; # (val Q)
  %191 = inttoptr i64 %77 to i64*
  %192 = load i64, i64* %191
; # (case Tag (TRANSIENT (consStr Nm)) (INTERN (requestSym Nm)) (T (w...
  switch i32 %84, label %$73 [
    i32 2, label %$75
    i32 1, label %$76
  ]
$75:
  %193 = phi i32 [%190, %$-3] ; # Cnt
  %194 = phi i64 [%192, %$-3] ; # Nm
; # (consStr Nm)
  %195 = call i64 @consStr(i64 %194)
  br label %$74
$76:
  %196 = phi i32 [%190, %$-3] ; # Cnt
  %197 = phi i64 [%192, %$-3] ; # Nm
; # (requestSym Nm)
  %198 = call i64 @requestSym(i64 %197)
  br label %$74
$73:
  %199 = phi i32 [%190, %$-3] ; # Cnt
  %200 = phi i64 [%192, %$-3] ; # Nm
; # (when (val $Extn) (let N (shl (& (i64 (+ (objFile Nm) @)) (hex "F...
; # (val $Extn)
  %201 = load i32, i32* @$Extn
  %202 = icmp ne i32 %201, 0
  br i1 %202, label %$77, label %$78
$77:
  %203 = phi i32 [%199, %$73] ; # Cnt
  %204 = phi i64 [%200, %$73] ; # Nm
; # (let N (shl (& (i64 (+ (objFile Nm) @)) (hex "FFFF")) 24) (setq N...
; # (objFile Nm)
  %205 = call i32 @objFile(i64 %204)
; # (+ (objFile Nm) @)
  %206 = add i32 %205, %201
; # (i64 (+ (objFile Nm) @))
  %207 = sext i32 %206 to i64
; # (& (i64 (+ (objFile Nm) @)) (hex "FFFF"))
  %208 = and i64 %207, 65535
; # (shl (& (i64 (+ (objFile Nm) @)) (hex "FFFF")) 24)
  %209 = shl i64 %208, 24
; # (& Nm (hex "FFF00FFF00FFFFFF"))
  %210 = and i64 %204, 18442258061990035455
; # (shl N 12)
  %211 = shl i64 %209, 12
; # (| N (shl N 12))
  %212 = or i64 %209, %211
; # (& (| N (shl N 12)) (hex "000FF000FF000000"))
  %213 = and i64 %212, 4486011719516160
; # (| (& Nm (hex "FFF00FFF00FFFFFF")) (& (| N (shl N 12)) (hex "000F...
  %214 = or i64 %210, %213
  br label %$78
$78:
  %215 = phi i32 [%199, %$73], [%203, %$77] ; # Cnt
  %216 = phi i64 [%200, %$73], [%214, %$77] ; # Nm
; # (extern Nm)
  %217 = call i64 @extern(i64 %216)
  br label %$74
$74:
  %218 = phi i32 [%193, %$75], [%196, %$76], [%215, %$78] ; # Cnt
  %219 = phi i64 [%194, %$75], [%197, %$76], [%216, %$78] ; # Nm
  %220 = phi i64 [%195, %$75], [%198, %$76], [%217, %$78] ; # ->
  %221 = inttoptr i64 %77 to i64*
  %222 = getelementptr i64, i64* %221, i32 1
  %223 = load i64, i64* %222
  %224 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %223, i64* %224
  br label %$29
$29:
  %225 = phi i32 [%143, %$53], [%218, %$74] ; # Cnt
  %226 = phi i64 [%144, %$53], [%220, %$74] ; # ->
  br label %$2
$2:
  %227 = phi i64 [0, %$4], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$6], [%70, %$11], [%226, %$29] ; # ->
  ret i64 %227
}

define void @prCnt(i8, i64) {
$1:
; # (let N Num (while (setq N (shr N 8)) (inc 'Tag 4)))
; # (while (setq N (shr N 8)) (inc 'Tag 4))
  br label %$2
$2:
  %2 = phi i8 [%0, %$1], [%10, %$3] ; # Tag
  %3 = phi i64 [%1, %$1], [%8, %$3] ; # Num
  %4 = phi i64 [%1, %$1], [%9, %$3] ; # N
; # (shr N 8)
  %5 = lshr i64 %4, 8
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$4
$3:
  %7 = phi i8 [%2, %$2] ; # Tag
  %8 = phi i64 [%3, %$2] ; # Num
  %9 = phi i64 [%5, %$2] ; # N
; # (inc 'Tag 4)
  %10 = add i8 %7, 4
  br label %$2
$4:
  %11 = phi i8 [%2, %$2] ; # Tag
  %12 = phi i64 [%3, %$2] ; # Num
  %13 = phi i64 [%5, %$2] ; # N
; # (call $PutBin Tag)
  %14 = load void(i8)*, void(i8)** @$PutBin
  call void %14(i8 %11)
; # (loop (call $PutBin (i8 Num)) (? (=0 (setq Num (shr Num 8)))))
  br label %$5
$5:
  %15 = phi i8 [%11, %$4], [%21, %$6] ; # Tag
  %16 = phi i64 [%12, %$4], [%22, %$6] ; # Num
; # (i8 Num)
  %17 = trunc i64 %16 to i8
; # (call $PutBin (i8 Num))
  %18 = load void(i8)*, void(i8)** @$PutBin
  call void %18(i8 %17)
; # (? (=0 (setq Num (shr Num 8))))
; # (shr Num 8)
  %19 = lshr i64 %16, 8
; # (=0 (setq Num (shr Num 8)))
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %$7, label %$6
$6:
  %21 = phi i8 [%15, %$5] ; # Tag
  %22 = phi i64 [%19, %$5] ; # Num
  br label %$5
$7:
  %23 = phi i8 [%15, %$5] ; # Tag
  %24 = phi i64 [%19, %$5] ; # Num
  %25 = phi i64 [0, %$5] ; # ->
  ret void
}

define void @binPrint(i64) {
$1:
; # (cond ((cnt? X) (tailcall (prCnt (+ NUMBER 4) (shr X 3)))) ((big?...
; # (cnt? X)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
; # (+ NUMBER 4)
; # (shr X 3)
  %4 = lshr i64 %3, 3
; # (prCnt (+ NUMBER 4) (shr X 3))
  tail call void @prCnt(i8 4, i64 %4)
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
; # (big? X)
  %6 = and i64 %5, 4
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$3] ; # X
; # (let (Y (pos X) Z Y N 8) (loop (let C (val (dig Z)) (? (cnt? (set...
; # (pos X)
  %9 = and i64 %8, -9
; # (loop (let C (val (dig Z)) (? (cnt? (setq Z (val (big Z)))) (setq...
  br label %$7
$7:
  %10 = phi i64 [%8, %$6], [%39, %$8] ; # X
  %11 = phi i64 [%9, %$6], [%40, %$8] ; # Y
  %12 = phi i64 [%9, %$6], [%41, %$8] ; # Z
  %13 = phi i64 [8, %$6], [%44, %$8] ; # N
; # (let C (val (dig Z)) (? (cnt? (setq Z (val (big Z)))) (setq Z (in...
; # (dig Z)
  %14 = add i64 %12, -4
; # (val (dig Z))
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
; # (? (cnt? (setq Z (val (big Z)))) (setq Z (int Z) C (add C C) Z (a...
; # (big Z)
  %17 = add i64 %12, 4
; # (val (big Z))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (cnt? (setq Z (val (big Z))))
  %20 = and i64 %19, 2
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$8
$10:
  %22 = phi i64 [%10, %$7] ; # X
  %23 = phi i64 [%11, %$7] ; # Y
  %24 = phi i64 [%19, %$7] ; # Z
  %25 = phi i64 [%13, %$7] ; # N
  %26 = phi i64 [%16, %$7] ; # C
; # (int Z)
  %27 = lshr i64 %24, 4
; # (add C C)
  %28 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %26, i64 %26)
  %29 = extractvalue {i64, i1} %28, 1
  %30 = extractvalue {i64, i1} %28, 0
; # (add Z Z @@)
  %31 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %27, i64 %27)
  %32 = extractvalue {i64, i1} %31, 1
  %33 = extractvalue {i64, i1} %31, 0
  %34 = zext i1 %29 to i64
  %35 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %33, i64 %34)
  %36 = extractvalue {i64, i1} %35, 1
  %37 = or i1 %32, %36
  %38 = extractvalue {i64, i1} %35, 0
  br label %$9
$8:
  %39 = phi i64 [%10, %$7] ; # X
  %40 = phi i64 [%11, %$7] ; # Y
  %41 = phi i64 [%19, %$7] ; # Z
  %42 = phi i64 [%13, %$7] ; # N
  %43 = phi i64 [%16, %$7] ; # C
; # (inc 'N 8)
  %44 = add i64 %42, 8
  br label %$7
$9:
  %45 = phi i64 [%22, %$10] ; # X
  %46 = phi i64 [%23, %$10] ; # Y
  %47 = phi i64 [%38, %$10] ; # Z
  %48 = phi i64 [%25, %$10] ; # N
  %49 = phi i64 [%38, %$10] ; # ->
; # (when Z (loop (inc 'N) (? (=0 (setq Z (shr Z 8))))))
  %50 = icmp ne i64 %47, 0
  br i1 %50, label %$11, label %$12
$11:
  %51 = phi i64 [%45, %$9] ; # X
  %52 = phi i64 [%46, %$9] ; # Y
  %53 = phi i64 [%47, %$9] ; # Z
  %54 = phi i64 [%48, %$9] ; # N
; # (loop (inc 'N) (? (=0 (setq Z (shr Z 8)))))
  br label %$13
$13:
  %55 = phi i64 [%51, %$11], [%62, %$14] ; # X
  %56 = phi i64 [%52, %$11], [%63, %$14] ; # Y
  %57 = phi i64 [%53, %$11], [%64, %$14] ; # Z
  %58 = phi i64 [%54, %$11], [%65, %$14] ; # N
; # (inc 'N)
  %59 = add i64 %58, 1
; # (? (=0 (setq Z (shr Z 8))))
; # (shr Z 8)
  %60 = lshr i64 %57, 8
; # (=0 (setq Z (shr Z 8)))
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %$15, label %$14
$14:
  %62 = phi i64 [%55, %$13] ; # X
  %63 = phi i64 [%56, %$13] ; # Y
  %64 = phi i64 [%60, %$13] ; # Z
  %65 = phi i64 [%59, %$13] ; # N
  br label %$13
$15:
  %66 = phi i64 [%55, %$13] ; # X
  %67 = phi i64 [%56, %$13] ; # Y
  %68 = phi i64 [%60, %$13] ; # Z
  %69 = phi i64 [%59, %$13] ; # N
  %70 = phi i64 [0, %$13] ; # ->
  br label %$12
$12:
  %71 = phi i64 [%45, %$9], [%66, %$15] ; # X
  %72 = phi i64 [%46, %$9], [%67, %$15] ; # Y
  %73 = phi i64 [%47, %$9], [%68, %$15] ; # Z
  %74 = phi i64 [%48, %$9], [%69, %$15] ; # N
; # (let (M (- N 63) D (val (dig Y))) (when (ge0 M) (setq N 63)) (set...
; # (- N 63)
  %75 = sub i64 %74, 63
; # (dig Y)
  %76 = add i64 %72, -4
; # (val (dig Y))
  %77 = inttoptr i64 %76 to i64*
  %78 = load i64, i64* %77
; # (when (ge0 M) (setq N 63))
; # (ge0 M)
  %79 = icmp sge i64 %75, 0
  br i1 %79, label %$16, label %$17
$16:
  %80 = phi i64 [%71, %$12] ; # X
  %81 = phi i64 [%72, %$12] ; # Y
  %82 = phi i64 [%73, %$12] ; # Z
  %83 = phi i64 [%74, %$12] ; # N
  %84 = phi i64 [%75, %$12] ; # M
  %85 = phi i64 [%78, %$12] ; # D
  br label %$17
$17:
  %86 = phi i64 [%71, %$12], [%80, %$16] ; # X
  %87 = phi i64 [%72, %$12], [%81, %$16] ; # Y
  %88 = phi i64 [%73, %$12], [%82, %$16] ; # Z
  %89 = phi i64 [%74, %$12], [63, %$16] ; # N
  %90 = phi i64 [%75, %$12], [%84, %$16] ; # M
  %91 = phi i64 [%78, %$12], [%85, %$16] ; # D
; # (big Y)
  %92 = add i64 %87, 4
; # (val (big Y))
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
; # (shr X X 4)
  %95 = call i64 @llvm.fshr.i64(i64 %86, i64 %86, i64 4)
; # (add X X)
  %96 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %95, i64 %95)
  %97 = extractvalue {i64, i1} %96, 1
  %98 = extractvalue {i64, i1} %96, 0
; # (add D D @@)
  %99 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %91, i64 %91)
  %100 = extractvalue {i64, i1} %99, 1
  %101 = extractvalue {i64, i1} %99, 0
  %102 = zext i1 %97 to i64
  %103 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %101, i64 %102)
  %104 = extractvalue {i64, i1} %103, 1
  %105 = or i1 %100, %104
  %106 = extractvalue {i64, i1} %103, 0
; # (shl N 2)
  %107 = shl i64 %89, 2
; # (i8 (shl N 2))
  %108 = trunc i64 %107 to i8
; # (call $PutBin (i8 (shl N 2)))
  %109 = load void(i8)*, void(i8)** @$PutBin
  call void %109(i8 %108)
; # (let (S @@ C 8) (loop (loop (call $PutBin (i8 D)) (if (dec 'C) (s...
; # (loop (loop (call $PutBin (i8 D)) (if (dec 'C) (setq D (shr D 8))...
  br label %$18
$18:
  %110 = phi i64 [%95, %$17], [%253, %$33] ; # X
  %111 = phi i64 [%94, %$17], [%254, %$33] ; # Y
  %112 = phi i64 [%88, %$17], [%255, %$33] ; # Z
  %113 = phi i64 [%89, %$17], [%256, %$33] ; # N
  %114 = phi i64 [%90, %$17], [%257, %$33] ; # M
  %115 = phi i64 [%106, %$17], [%258, %$33] ; # D
  %116 = phi i1 [%105, %$17], [%259, %$33] ; # S
  %117 = phi i64 [8, %$17], [%260, %$33] ; # C
; # (loop (call $PutBin (i8 D)) (if (dec 'C) (setq D (shr D 8)) (setq...
  br label %$19
$19:
  %118 = phi i64 [%110, %$18], [%199, %$26] ; # X
  %119 = phi i64 [%111, %$18], [%200, %$26] ; # Y
  %120 = phi i64 [%112, %$18], [%201, %$26] ; # Z
  %121 = phi i64 [%113, %$18], [%202, %$26] ; # N
  %122 = phi i64 [%114, %$18], [%203, %$26] ; # M
  %123 = phi i64 [%115, %$18], [%204, %$26] ; # D
  %124 = phi i1 [%116, %$18], [%205, %$26] ; # S
  %125 = phi i64 [%117, %$18], [%206, %$26] ; # C
; # (i8 D)
  %126 = trunc i64 %123 to i8
; # (call $PutBin (i8 D))
  %127 = load void(i8)*, void(i8)** @$PutBin
  call void %127(i8 %126)
; # (if (dec 'C) (setq D (shr D 8)) (setq C 8) (if (cnt? Y) (setq D (...
; # (dec 'C)
  %128 = sub i64 %125, 1
  %129 = icmp ne i64 %128, 0
  br i1 %129, label %$20, label %$21
$20:
  %130 = phi i64 [%118, %$19] ; # X
  %131 = phi i64 [%119, %$19] ; # Y
  %132 = phi i64 [%120, %$19] ; # Z
  %133 = phi i64 [%121, %$19] ; # N
  %134 = phi i64 [%122, %$19] ; # M
  %135 = phi i64 [%123, %$19] ; # D
  %136 = phi i1 [%124, %$19] ; # S
  %137 = phi i64 [%128, %$19] ; # C
; # (shr D 8)
  %138 = lshr i64 %135, 8
  br label %$22
$21:
  %139 = phi i64 [%118, %$19] ; # X
  %140 = phi i64 [%119, %$19] ; # Y
  %141 = phi i64 [%120, %$19] ; # Z
  %142 = phi i64 [%121, %$19] ; # N
  %143 = phi i64 [%122, %$19] ; # M
  %144 = phi i64 [%123, %$19] ; # D
  %145 = phi i1 [%124, %$19] ; # S
  %146 = phi i64 [%128, %$19] ; # C
; # (if (cnt? Y) (setq D (int Y)) (setq D (val (dig Y)) Y (val (big Y...
; # (cnt? Y)
  %147 = and i64 %140, 2
  %148 = icmp ne i64 %147, 0
  br i1 %148, label %$23, label %$24
$23:
  %149 = phi i64 [%139, %$21] ; # X
  %150 = phi i64 [%140, %$21] ; # Y
  %151 = phi i64 [%141, %$21] ; # Z
  %152 = phi i64 [%142, %$21] ; # N
  %153 = phi i64 [%143, %$21] ; # M
  %154 = phi i64 [%144, %$21] ; # D
  %155 = phi i1 [%145, %$21] ; # S
  %156 = phi i64 [8, %$21] ; # C
; # (int Y)
  %157 = lshr i64 %150, 4
  br label %$25
$24:
  %158 = phi i64 [%139, %$21] ; # X
  %159 = phi i64 [%140, %$21] ; # Y
  %160 = phi i64 [%141, %$21] ; # Z
  %161 = phi i64 [%142, %$21] ; # N
  %162 = phi i64 [%143, %$21] ; # M
  %163 = phi i64 [%144, %$21] ; # D
  %164 = phi i1 [%145, %$21] ; # S
  %165 = phi i64 [8, %$21] ; # C
; # (dig Y)
  %166 = add i64 %159, -4
; # (val (dig Y))
  %167 = inttoptr i64 %166 to i64*
  %168 = load i64, i64* %167
; # (big Y)
  %169 = add i64 %159, 4
; # (val (big Y))
  %170 = inttoptr i64 %169 to i64*
  %171 = load i64, i64* %170
  br label %$25
$25:
  %172 = phi i64 [%149, %$23], [%158, %$24] ; # X
  %173 = phi i64 [%150, %$23], [%171, %$24] ; # Y
  %174 = phi i64 [%151, %$23], [%160, %$24] ; # Z
  %175 = phi i64 [%152, %$23], [%161, %$24] ; # N
  %176 = phi i64 [%153, %$23], [%162, %$24] ; # M
  %177 = phi i64 [%157, %$23], [%168, %$24] ; # D
  %178 = phi i1 [%155, %$23], [%164, %$24] ; # S
  %179 = phi i64 [%156, %$23], [%165, %$24] ; # C
  %180 = phi i64 [%157, %$23], [%171, %$24] ; # ->
; # (add D D S)
  %181 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %177, i64 %177)
  %182 = extractvalue {i64, i1} %181, 1
  %183 = extractvalue {i64, i1} %181, 0
  %184 = zext i1 %178 to i64
  %185 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %183, i64 %184)
  %186 = extractvalue {i64, i1} %185, 1
  %187 = or i1 %182, %186
  %188 = extractvalue {i64, i1} %185, 0
  br label %$22
$22:
  %189 = phi i64 [%130, %$20], [%172, %$25] ; # X
  %190 = phi i64 [%131, %$20], [%173, %$25] ; # Y
  %191 = phi i64 [%132, %$20], [%174, %$25] ; # Z
  %192 = phi i64 [%133, %$20], [%175, %$25] ; # N
  %193 = phi i64 [%134, %$20], [%176, %$25] ; # M
  %194 = phi i64 [%138, %$20], [%188, %$25] ; # D
  %195 = phi i1 [%136, %$20], [%187, %$25] ; # S
  %196 = phi i64 [%137, %$20], [%179, %$25] ; # C
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %197 = sub i64 %192, 1
; # (=0 (dec 'N))
  %198 = icmp eq i64 %197, 0
  br i1 %198, label %$27, label %$26
$26:
  %199 = phi i64 [%189, %$22] ; # X
  %200 = phi i64 [%190, %$22] ; # Y
  %201 = phi i64 [%191, %$22] ; # Z
  %202 = phi i64 [%197, %$22] ; # N
  %203 = phi i64 [%193, %$22] ; # M
  %204 = phi i64 [%194, %$22] ; # D
  %205 = phi i1 [%195, %$22] ; # S
  %206 = phi i64 [%196, %$22] ; # C
  br label %$19
$27:
  %207 = phi i64 [%189, %$22] ; # X
  %208 = phi i64 [%190, %$22] ; # Y
  %209 = phi i64 [%191, %$22] ; # Z
  %210 = phi i64 [%197, %$22] ; # N
  %211 = phi i64 [%193, %$22] ; # M
  %212 = phi i64 [%194, %$22] ; # D
  %213 = phi i1 [%195, %$22] ; # S
  %214 = phi i64 [%196, %$22] ; # C
  %215 = phi i64 [0, %$22] ; # ->
; # (? (lt0 M))
; # (lt0 M)
  %216 = icmp slt i64 %211, 0
  br i1 %216, label %$29, label %$28
$28:
  %217 = phi i64 [%207, %$27] ; # X
  %218 = phi i64 [%208, %$27] ; # Y
  %219 = phi i64 [%209, %$27] ; # Z
  %220 = phi i64 [%210, %$27] ; # N
  %221 = phi i64 [%211, %$27] ; # M
  %222 = phi i64 [%212, %$27] ; # D
  %223 = phi i1 [%213, %$27] ; # S
  %224 = phi i64 [%214, %$27] ; # C
; # (? (=0 M) (call $PutBin 0))
; # (=0 M)
  %225 = icmp eq i64 %221, 0
  br i1 %225, label %$31, label %$30
$31:
  %226 = phi i64 [%217, %$28] ; # X
  %227 = phi i64 [%218, %$28] ; # Y
  %228 = phi i64 [%219, %$28] ; # Z
  %229 = phi i64 [%220, %$28] ; # N
  %230 = phi i64 [%221, %$28] ; # M
  %231 = phi i64 [%222, %$28] ; # D
  %232 = phi i1 [%223, %$28] ; # S
  %233 = phi i64 [%224, %$28] ; # C
; # (call $PutBin 0)
  %234 = load void(i8)*, void(i8)** @$PutBin
  call void %234(i8 0)
  br label %$29
$30:
  %235 = phi i64 [%217, %$28] ; # X
  %236 = phi i64 [%218, %$28] ; # Y
  %237 = phi i64 [%219, %$28] ; # Z
  %238 = phi i64 [%220, %$28] ; # N
  %239 = phi i64 [%221, %$28] ; # M
  %240 = phi i64 [%222, %$28] ; # D
  %241 = phi i1 [%223, %$28] ; # S
  %242 = phi i64 [%224, %$28] ; # C
; # (when (ge0 (setq M (- (setq N M) 255))) (setq N 255))
; # (- (setq N M) 255)
  %243 = sub i64 %239, 255
; # (ge0 (setq M (- (setq N M) 255)))
  %244 = icmp sge i64 %243, 0
  br i1 %244, label %$32, label %$33
$32:
  %245 = phi i64 [%235, %$30] ; # X
  %246 = phi i64 [%236, %$30] ; # Y
  %247 = phi i64 [%237, %$30] ; # Z
  %248 = phi i64 [%239, %$30] ; # N
  %249 = phi i64 [%243, %$30] ; # M
  %250 = phi i64 [%240, %$30] ; # D
  %251 = phi i1 [%241, %$30] ; # S
  %252 = phi i64 [%242, %$30] ; # C
  br label %$33
$33:
  %253 = phi i64 [%235, %$30], [%245, %$32] ; # X
  %254 = phi i64 [%236, %$30], [%246, %$32] ; # Y
  %255 = phi i64 [%237, %$30], [%247, %$32] ; # Z
  %256 = phi i64 [%239, %$30], [255, %$32] ; # N
  %257 = phi i64 [%243, %$30], [%249, %$32] ; # M
  %258 = phi i64 [%240, %$30], [%250, %$32] ; # D
  %259 = phi i1 [%241, %$30], [%251, %$32] ; # S
  %260 = phi i64 [%242, %$30], [%252, %$32] ; # C
; # (i8 N)
  %261 = trunc i64 %256 to i8
; # (call $PutBin (i8 N))
  %262 = load void(i8)*, void(i8)** @$PutBin
  call void %262(i8 %261)
  br label %$18
$29:
  %263 = phi i64 [%207, %$27], [%226, %$31] ; # X
  %264 = phi i64 [%208, %$27], [%227, %$31] ; # Y
  %265 = phi i64 [%209, %$27], [%228, %$31] ; # Z
  %266 = phi i64 [%210, %$27], [%229, %$31] ; # N
  %267 = phi i64 [%211, %$27], [%230, %$31] ; # M
  %268 = phi i64 [%212, %$27], [%231, %$31] ; # D
  %269 = phi i1 [%213, %$27], [%232, %$31] ; # S
  %270 = phi i64 [%214, %$27], [%233, %$31] ; # C
  br label %$2
$5:
  %271 = phi i64 [%5, %$3] ; # X
; # (nil? X)
  %272 = icmp eq i64 %271, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %272, label %$35, label %$34
$35:
  %273 = phi i64 [%271, %$5] ; # X
; # (call $PutBin NIX)
  %274 = load void(i8)*, void(i8)** @$PutBin
  call void %274(i8 0)
  br label %$2
$34:
  %275 = phi i64 [%271, %$5] ; # X
; # (pair X)
  %276 = and i64 %275, 15
  %277 = icmp eq i64 %276, 0
  br i1 %277, label %$37, label %$36
$37:
  %278 = phi i64 [%275, %$34] ; # X
; # (call $PutBin BEG)
  %279 = load void(i8)*, void(i8)** @$PutBin
  call void %279(i8 1)
; # (let P (circ X) (ifn P (loop (binPrint (car X)) (? (== $Nil (shif...
; # (circ X)
  %280 = call i64 @circ(i64 %278)
; # (ifn P (loop (binPrint (car X)) (? (== $Nil (shift X)) (call $Put...
  %281 = icmp ne i64 %280, 0
  br i1 %281, label %$39, label %$38
$38:
  %282 = phi i64 [%278, %$37] ; # X
; # (loop (binPrint (car X)) (? (== $Nil (shift X)) (call $PutBin END...
  br label %$41
$41:
  %283 = phi i64 [%282, %$38], [%297, %$45] ; # X
; # (car X)
  %284 = inttoptr i64 %283 to i64*
  %285 = load i64, i64* %284
; # (binPrint (car X))
  call void @binPrint(i64 %285)
; # (? (== $Nil (shift X)) (call $PutBin END))
; # (shift X)
  %286 = inttoptr i64 %283 to i64*
  %287 = getelementptr i64, i64* %286, i32 1
  %288 = load i64, i64* %287
; # (== $Nil (shift X))
  %289 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %288
  br i1 %289, label %$44, label %$42
$44:
  %290 = phi i64 [%288, %$41] ; # X
; # (call $PutBin END)
  %291 = load void(i8)*, void(i8)** @$PutBin
  call void %291(i8 3)
  br label %$43
$42:
  %292 = phi i64 [%288, %$41] ; # X
; # (? (atom X) (call $PutBin DOT) (binPrint X))
; # (atom X)
  %293 = and i64 %292, 15
  %294 = icmp ne i64 %293, 0
  br i1 %294, label %$46, label %$45
$46:
  %295 = phi i64 [%292, %$42] ; # X
; # (call $PutBin DOT)
  %296 = load void(i8)*, void(i8)** @$PutBin
  call void %296(i8 2)
; # (binPrint X)
  call void @binPrint(i64 %295)
  br label %$43
$45:
  %297 = phi i64 [%292, %$42] ; # X
  br label %$41
$43:
  %298 = phi i64 [%290, %$44], [%295, %$46] ; # X
  br label %$40
$39:
  %299 = phi i64 [%278, %$37] ; # X
; # (let Flg (== P X) (loop (binPrint (car X)) (? (== P (shift X)))) ...
; # (== P X)
  %300 = icmp eq i64 %280, %299
; # (loop (binPrint (car X)) (? (== P (shift X))))
  br label %$47
$47:
  %301 = phi i64 [%299, %$39], [%308, %$48] ; # X
; # (car X)
  %302 = inttoptr i64 %301 to i64*
  %303 = load i64, i64* %302
; # (binPrint (car X))
  call void @binPrint(i64 %303)
; # (? (== P (shift X)))
; # (shift X)
  %304 = inttoptr i64 %301 to i64*
  %305 = getelementptr i64, i64* %304, i32 1
  %306 = load i64, i64* %305
; # (== P (shift X))
  %307 = icmp eq i64 %280, %306
  br i1 %307, label %$49, label %$48
$48:
  %308 = phi i64 [%306, %$47] ; # X
  br label %$47
$49:
  %309 = phi i64 [%306, %$47] ; # X
  %310 = phi i64 [0, %$47] ; # ->
; # (call $PutBin DOT)
  %311 = load void(i8)*, void(i8)** @$PutBin
  call void %311(i8 2)
; # (unless Flg (call $PutBin BEG) (loop (binPrint (car X)) (? (== P ...
  br i1 %300, label %$51, label %$50
$50:
  %312 = phi i64 [%309, %$49] ; # X
; # (call $PutBin BEG)
  %313 = load void(i8)*, void(i8)** @$PutBin
  call void %313(i8 1)
; # (loop (binPrint (car X)) (? (== P (shift X))))
  br label %$52
$52:
  %314 = phi i64 [%312, %$50], [%321, %$53] ; # X
; # (car X)
  %315 = inttoptr i64 %314 to i64*
  %316 = load i64, i64* %315
; # (binPrint (car X))
  call void @binPrint(i64 %316)
; # (? (== P (shift X)))
; # (shift X)
  %317 = inttoptr i64 %314 to i64*
  %318 = getelementptr i64, i64* %317, i32 1
  %319 = load i64, i64* %318
; # (== P (shift X))
  %320 = icmp eq i64 %280, %319
  br i1 %320, label %$54, label %$53
$53:
  %321 = phi i64 [%319, %$52] ; # X
  br label %$52
$54:
  %322 = phi i64 [%319, %$52] ; # X
  %323 = phi i64 [0, %$52] ; # ->
; # (call $PutBin DOT)
  %324 = load void(i8)*, void(i8)** @$PutBin
  call void %324(i8 2)
  br label %$51
$51:
  %325 = phi i64 [%309, %$49], [%322, %$54] ; # X
; # (call $PutBin END)
  %326 = load void(i8)*, void(i8)** @$PutBin
  call void %326(i8 3)
  br label %$40
$40:
  %327 = phi i64 [%298, %$43], [%325, %$51] ; # X
  br label %$2
$36:
  %328 = phi i64 [%275, %$34] ; # X
; # (tail X)
  %329 = add i64 %328, -8
; # (val (tail X))
  %330 = inttoptr i64 %329 to i64*
  %331 = load i64, i64* %330
; # (sym? (val (tail X)))
  %332 = and i64 %331, 8
  %333 = icmp ne i64 %332, 0
  br i1 %333, label %$56, label %$55
$56:
  %334 = phi i64 [%328, %$36] ; # X
; # (let Nm (name (& @ -9)) (when (val $Extn) (let N (shl (& (i64 (- ...
; # (& @ -9)
  %335 = and i64 %331, -9
; # (name (& @ -9))
  br label %$57
$57:
  %336 = phi i64 [%335, %$56], [%342, %$58] ; # Tail
  %337 = and i64 %336, 6
  %338 = icmp ne i64 %337, 0
  br i1 %338, label %$59, label %$58
$58:
  %339 = phi i64 [%336, %$57] ; # Tail
  %340 = inttoptr i64 %339 to i64*
  %341 = getelementptr i64, i64* %340, i32 1
  %342 = load i64, i64* %341
  br label %$57
$59:
  %343 = phi i64 [%336, %$57] ; # Tail
; # (when (val $Extn) (let N (shl (& (i64 (- (objFile Nm) @)) (hex "F...
; # (val $Extn)
  %344 = load i32, i32* @$Extn
  %345 = icmp ne i32 %344, 0
  br i1 %345, label %$60, label %$61
$60:
  %346 = phi i64 [%334, %$59] ; # X
  %347 = phi i64 [%343, %$59] ; # Nm
; # (let N (shl (& (i64 (- (objFile Nm) @)) (hex "FFFF")) 24) (setq N...
; # (objFile Nm)
  %348 = call i32 @objFile(i64 %347)
; # (- (objFile Nm) @)
  %349 = sub i32 %348, %344
; # (i64 (- (objFile Nm) @))
  %350 = sext i32 %349 to i64
; # (& (i64 (- (objFile Nm) @)) (hex "FFFF"))
  %351 = and i64 %350, 65535
; # (shl (& (i64 (- (objFile Nm) @)) (hex "FFFF")) 24)
  %352 = shl i64 %351, 24
; # (& Nm (hex "FFF00FFF00FFFFFF"))
  %353 = and i64 %347, 18442258061990035455
; # (shl N 12)
  %354 = shl i64 %352, 12
; # (| N (shl N 12))
  %355 = or i64 %352, %354
; # (& (| N (shl N 12)) (hex "000FF000FF000000"))
  %356 = and i64 %355, 4486011719516160
; # (| (& Nm (hex "FFF00FFF00FFFFFF")) (& (| N (shl N 12)) (hex "000F...
  %357 = or i64 %353, %356
  br label %$61
$61:
  %358 = phi i64 [%334, %$59], [%346, %$60] ; # X
  %359 = phi i64 [%343, %$59], [%357, %$60] ; # Nm
; # (+ EXTERN 4)
; # (shl Nm 2)
  %360 = shl i64 %359, 2
; # (shr (shl Nm 2) 6)
  %361 = lshr i64 %360, 6
; # (prCnt (+ EXTERN 4) (shr (shl Nm 2) 6))
  tail call void @prCnt(i8 7, i64 %361)
  br label %$2
$55:
  %362 = phi i64 [%328, %$36] ; # X
; # (name @)
  br label %$62
$62:
  %363 = phi i64 [%331, %$55], [%369, %$63] ; # Tail
  %364 = and i64 %363, 6
  %365 = icmp ne i64 %364, 0
  br i1 %365, label %$64, label %$63
$63:
  %366 = phi i64 [%363, %$62] ; # Tail
  %367 = inttoptr i64 %366 to i64*
  %368 = getelementptr i64, i64* %367, i32 1
  %369 = load i64, i64* %368
  br label %$62
$64:
  %370 = phi i64 [%363, %$62] ; # Tail
; # (== (name @) ZERO)
  %371 = icmp eq i64 %370, 2
  br i1 %371, label %$66, label %$65
$66:
  %372 = phi i64 [%362, %$64] ; # X
; # (call $PutBin NIX)
  %373 = load void(i8)*, void(i8)** @$PutBin
  call void %373(i8 0)
  br label %$2
$65:
  %374 = phi i64 [%362, %$64] ; # X
; # (let (Nm @ Tag (if (== X (isLstIntern Nm (val $Intern))) (i8 INTE...
; # (if (== X (isLstIntern Nm (val $Intern))) (i8 INTERN) (i8 TRANSIE...
; # (val $Intern)
  %375 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %376 = load i64, i64* %375
; # (isLstIntern Nm (val $Intern))
  %377 = call i64 @isLstIntern(i64 %370, i64 %376)
; # (== X (isLstIntern Nm (val $Intern)))
  %378 = icmp eq i64 %374, %377
  br i1 %378, label %$67, label %$68
$67:
  %379 = phi i64 [%374, %$65] ; # X
; # (i8 INTERN)
  br label %$69
$68:
  %380 = phi i64 [%374, %$65] ; # X
; # (i8 TRANSIENT)
  br label %$69
$69:
  %381 = phi i64 [%379, %$67], [%380, %$68] ; # X
  %382 = phi i8 [1, %$67], [2, %$68] ; # ->
; # (if (cnt? Nm) (prCnt (+ Tag 4) (int Nm)) (let (Y Nm N 8) (while (...
; # (cnt? Nm)
  %383 = and i64 %370, 2
  %384 = icmp ne i64 %383, 0
  br i1 %384, label %$70, label %$71
$70:
  %385 = phi i64 [%381, %$69] ; # X
; # (+ Tag 4)
  %386 = add i8 %382, 4
; # (int Nm)
  %387 = lshr i64 %370, 4
; # (prCnt (+ Tag 4) (int Nm))
  call void @prCnt(i8 %386, i64 %387)
  br label %$72
$71:
  %388 = phi i64 [%381, %$69] ; # X
; # (let (Y Nm N 8) (while (big? (setq Y (val (big Y)))) (inc 'N 8)) ...
; # (while (big? (setq Y (val (big Y)))) (inc 'N 8))
  br label %$73
$73:
  %389 = phi i64 [%388, %$71], [%397, %$74] ; # X
  %390 = phi i64 [%370, %$71], [%398, %$74] ; # Y
  %391 = phi i64 [8, %$71], [%400, %$74] ; # N
; # (big Y)
  %392 = add i64 %390, 4
; # (val (big Y))
  %393 = inttoptr i64 %392 to i64*
  %394 = load i64, i64* %393
; # (big? (setq Y (val (big Y))))
  %395 = and i64 %394, 4
  %396 = icmp ne i64 %395, 0
  br i1 %396, label %$74, label %$75
$74:
  %397 = phi i64 [%389, %$73] ; # X
  %398 = phi i64 [%394, %$73] ; # Y
  %399 = phi i64 [%391, %$73] ; # N
; # (inc 'N 8)
  %400 = add i64 %399, 8
  br label %$73
$75:
  %401 = phi i64 [%389, %$73] ; # X
  %402 = phi i64 [%394, %$73] ; # Y
  %403 = phi i64 [%391, %$73] ; # N
; # (int Y)
  %404 = lshr i64 %402, 4
; # (while Y (inc 'N) (setq Y (shr Y 8)))
  br label %$76
$76:
  %405 = phi i64 [%401, %$75], [%409, %$77] ; # X
  %406 = phi i64 [%404, %$75], [%413, %$77] ; # Y
  %407 = phi i64 [%403, %$75], [%412, %$77] ; # N
  %408 = icmp ne i64 %406, 0
  br i1 %408, label %$77, label %$78
$77:
  %409 = phi i64 [%405, %$76] ; # X
  %410 = phi i64 [%406, %$76] ; # Y
  %411 = phi i64 [%407, %$76] ; # N
; # (inc 'N)
  %412 = add i64 %411, 1
; # (shr Y 8)
  %413 = lshr i64 %410, 8
  br label %$76
$78:
  %414 = phi i64 [%405, %$76] ; # X
  %415 = phi i64 [%406, %$76] ; # Y
  %416 = phi i64 [%407, %$76] ; # N
; # (let (P (push 0 Nm) M (- N 63) C 8) (when (ge0 M) (setq N 63)) (c...
; # (push 0 Nm)
  %417 = alloca i64, i64 2, align 16
  store i64 0, i64* %417
  %418 = getelementptr i64, i64* %417, i32 1
  store i64 %370, i64* %418
; # (- N 63)
  %419 = sub i64 %416, 63
; # (when (ge0 M) (setq N 63))
; # (ge0 M)
  %420 = icmp sge i64 %419, 0
  br i1 %420, label %$79, label %$80
$79:
  %421 = phi i64 [%414, %$78] ; # X
  %422 = phi i64 [%415, %$78] ; # Y
  %423 = phi i64 [%416, %$78] ; # N
  %424 = phi i64 [%419, %$78] ; # M
  br label %$80
$80:
  %425 = phi i64 [%414, %$78], [%421, %$79] ; # X
  %426 = phi i64 [%415, %$78], [%422, %$79] ; # Y
  %427 = phi i64 [%416, %$78], [63, %$79] ; # N
  %428 = phi i64 [%419, %$78], [%424, %$79] ; # M
; # (shl N 2)
  %429 = shl i64 %427, 2
; # (i8 (shl N 2))
  %430 = trunc i64 %429 to i8
; # (+ Tag (i8 (shl N 2)))
  %431 = add i8 %382, %430
; # (call $PutBin (+ Tag (i8 (shl N 2))))
  %432 = load void(i8)*, void(i8)** @$PutBin
  call void %432(i8 %431)
; # (loop (loop (call $PutBin (symByte P)) (? (=0 (dec 'N)))) (? (lt0...
  br label %$81
$81:
  %433 = phi i64 [%425, %$80], [%475, %$90] ; # X
  %434 = phi i64 [%426, %$80], [%476, %$90] ; # Y
  %435 = phi i64 [%427, %$80], [%477, %$90] ; # N
  %436 = phi i64 [%428, %$80], [%478, %$90] ; # M
; # (loop (call $PutBin (symByte P)) (? (=0 (dec 'N))))
  br label %$82
$82:
  %437 = phi i64 [%433, %$81], [%445, %$83] ; # X
  %438 = phi i64 [%434, %$81], [%446, %$83] ; # Y
  %439 = phi i64 [%435, %$81], [%447, %$83] ; # N
  %440 = phi i64 [%436, %$81], [%448, %$83] ; # M
; # (symByte P)
  %441 = call i8 @symByte(i64* %417)
; # (call $PutBin (symByte P))
  %442 = load void(i8)*, void(i8)** @$PutBin
  call void %442(i8 %441)
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %443 = sub i64 %439, 1
; # (=0 (dec 'N))
  %444 = icmp eq i64 %443, 0
  br i1 %444, label %$84, label %$83
$83:
  %445 = phi i64 [%437, %$82] ; # X
  %446 = phi i64 [%438, %$82] ; # Y
  %447 = phi i64 [%443, %$82] ; # N
  %448 = phi i64 [%440, %$82] ; # M
  br label %$82
$84:
  %449 = phi i64 [%437, %$82] ; # X
  %450 = phi i64 [%438, %$82] ; # Y
  %451 = phi i64 [%443, %$82] ; # N
  %452 = phi i64 [%440, %$82] ; # M
  %453 = phi i64 [0, %$82] ; # ->
; # (? (lt0 M))
; # (lt0 M)
  %454 = icmp slt i64 %452, 0
  br i1 %454, label %$86, label %$85
$85:
  %455 = phi i64 [%449, %$84] ; # X
  %456 = phi i64 [%450, %$84] ; # Y
  %457 = phi i64 [%451, %$84] ; # N
  %458 = phi i64 [%452, %$84] ; # M
; # (? (=0 M) (call $PutBin 0))
; # (=0 M)
  %459 = icmp eq i64 %458, 0
  br i1 %459, label %$88, label %$87
$88:
  %460 = phi i64 [%455, %$85] ; # X
  %461 = phi i64 [%456, %$85] ; # Y
  %462 = phi i64 [%457, %$85] ; # N
  %463 = phi i64 [%458, %$85] ; # M
; # (call $PutBin 0)
  %464 = load void(i8)*, void(i8)** @$PutBin
  call void %464(i8 0)
  br label %$86
$87:
  %465 = phi i64 [%455, %$85] ; # X
  %466 = phi i64 [%456, %$85] ; # Y
  %467 = phi i64 [%457, %$85] ; # N
  %468 = phi i64 [%458, %$85] ; # M
; # (when (ge0 (setq M (- (setq N M) 255))) (setq N 255))
; # (- (setq N M) 255)
  %469 = sub i64 %468, 255
; # (ge0 (setq M (- (setq N M) 255)))
  %470 = icmp sge i64 %469, 0
  br i1 %470, label %$89, label %$90
$89:
  %471 = phi i64 [%465, %$87] ; # X
  %472 = phi i64 [%466, %$87] ; # Y
  %473 = phi i64 [%468, %$87] ; # N
  %474 = phi i64 [%469, %$87] ; # M
  br label %$90
$90:
  %475 = phi i64 [%465, %$87], [%471, %$89] ; # X
  %476 = phi i64 [%466, %$87], [%472, %$89] ; # Y
  %477 = phi i64 [%468, %$87], [255, %$89] ; # N
  %478 = phi i64 [%469, %$87], [%474, %$89] ; # M
; # (i8 N)
  %479 = trunc i64 %477 to i8
; # (call $PutBin (i8 N))
  %480 = load void(i8)*, void(i8)** @$PutBin
  call void %480(i8 %479)
  br label %$81
$86:
  %481 = phi i64 [%449, %$84], [%460, %$88] ; # X
  %482 = phi i64 [%450, %$84], [%461, %$88] ; # Y
  %483 = phi i64 [%451, %$84], [%462, %$88] ; # N
  %484 = phi i64 [%452, %$84], [%463, %$88] ; # M
  br label %$72
$72:
  %485 = phi i64 [%385, %$70], [%481, %$86] ; # X
  br label %$2
$2:
  %486 = phi i64 [%3, %$4], [%263, %$29], [%273, %$35], [%327, %$40], [%358, %$61], [%372, %$66], [%485, %$72] ; # X
  ret void
}

define void @pr(i64) {
$1:
; # (set $PutBin (fun (void i8) _putStdout))
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$PutBin
; # (binPrint X)
  tail call void @binPrint(i64 %0)
  ret void
}

define void @putTell(i8) {
$1:
; # (let P (val $Ptr) (set P B) (when (== (set $Ptr (inc P)) (val $En...
; # (val $Ptr)
  %1 = load i8*, i8** @$Ptr
; # (set P B)
  store i8 %0, i8* %1
; # (when (== (set $Ptr (inc P)) (val $End)) (err 0 0 ($ "Tell PIPE_B...
; # (set $Ptr (inc P))
; # (inc P)
  %2 = getelementptr i8, i8* %1, i32 1
  store i8* %2, i8** @$Ptr
; # (val $End)
  %3 = load i8*, i8** @$End
; # (== (set $Ptr (inc P)) (val $End))
  %4 = icmp eq i8* %2, %3
  br i1 %4, label %$2, label %$3
$2:
; # (err 0 0 ($ "Tell PIPE_BUF") null)
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$36 to i8*), i8* null)
  unreachable
$3:
  ret void
}

define void @prTell(i64) {
$1:
; # (set $PutBin (fun (void i8) putTell) $Extn 0)
; # (fun (void i8) putTell)
  store void(i8)* @putTell, void(i8)** @$PutBin
  store i32 0, i32* @$Extn
; # (binPrint X)
  tail call void @binPrint(i64 %0)
  ret void
}

define void @tellBeg(i8*) {
$1:
; # (set $TellBuf P $End (ofs P (dec (val PipeBufSize))) (inc 'P 8) B...
  store i8* %0, i8** @$TellBuf
; # (val PipeBufSize)
  %1 = load i64, i64* @PipeBufSize
; # (dec (val PipeBufSize))
  %2 = sub i64 %1, 1
; # (ofs P (dec (val PipeBufSize)))
  %3 = getelementptr i8, i8* %0, i64 %2
  store i8* %3, i8** @$End
; # (inc 'P 8)
  %4 = getelementptr i8, i8* %0, i32 8
  store i8 1, i8* %4
; # (inc P)
  %5 = getelementptr i8, i8* %4, i32 1
  store i8* %5, i8** @$Ptr
  ret void
}

define void @tellEnd(i32) {
$1:
; # (let (P (val $Ptr) Q (val $TellBuf)) (set P END) (inc 'P) (let (D...
; # (val $Ptr)
  %1 = load i8*, i8** @$Ptr
; # (val $TellBuf)
  %2 = load i8*, i8** @$TellBuf
; # (set P END)
  store i8 3, i8* %1
; # (inc 'P)
  %3 = getelementptr i8, i8* %1, i32 1
; # (let (D (- P Q) N (- D 8)) (set (i32* Q) Pid (inc (i32* Q)) (i32 ...
; # (- P Q)
  %4 = ptrtoint i8* %3 to i64
  %5 = ptrtoint i8* %2 to i64
  %6 = sub i64 %4, %5
; # (- D 8)
  %7 = sub i64 %6, 8
; # (set (i32* Q) Pid (inc (i32* Q)) (i32 N))
; # (i32* Q)
  %8 = bitcast i8* %2 to i32*
  store i32 %0, i32* %8
; # (i32* Q)
  %9 = bitcast i8* %2 to i32*
; # (inc (i32* Q))
  %10 = getelementptr i32, i32* %9, i32 1
; # (i32 N)
  %11 = trunc i64 %7 to i32
  store i32 %11, i32* %10
; # (when (val $Tell) (unless (wrBytes @ Q D) (close @) (set $Tell 0)...
; # (val $Tell)
  %12 = load i32, i32* @$Tell
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i8* [%3, %$1] ; # P
  %15 = phi i8* [%2, %$1] ; # Q
; # (unless (wrBytes @ Q D) (close @) (set $Tell 0))
; # (wrBytes @ Q D)
  %16 = call i1 @wrBytes(i32 %12, i8* %15, i64 %6)
  br i1 %16, label %$5, label %$4
$4:
  %17 = phi i8* [%14, %$2] ; # P
  %18 = phi i8* [%15, %$2] ; # Q
; # (close @)
  %19 = call i32 @close(i32 %12)
; # (set $Tell 0)
  store i32 0, i32* @$Tell
  br label %$5
$5:
  %20 = phi i8* [%14, %$2], [%17, %$4] ; # P
  %21 = phi i8* [%15, %$2], [%18, %$4] ; # Q
  br label %$3
$3:
  %22 = phi i8* [%3, %$1], [%20, %$5] ; # P
  %23 = phi i8* [%2, %$1], [%21, %$5] ; # Q
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %24 = load i8*, i8** @$Child
; # (val $Children)
  %25 = load i64, i64* @$Children
; # (* (val $Children) (child T))
  %26 = mul i64 %25, 36
; # (ofs Cld (* (val $Children) (child T)))
  %27 = getelementptr i8, i8* %24, i64 %26
; # (inc 'Q 8)
  %28 = getelementptr i8, i8* %23, i32 8
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (and (Cld: pid) ...
  br label %$6
$6:
  %29 = phi i8* [%22, %$3], [%62, %$14] ; # P
  %30 = phi i8* [%28, %$3], [%63, %$14] ; # Q
  %31 = phi i8* [%24, %$3], [%65, %$14] ; # Cld
; # (== Cld <Cld)
  %32 = icmp eq i8* %31, %27
  br i1 %32, label %$8, label %$7
$7:
  %33 = phi i8* [%29, %$6] ; # P
  %34 = phi i8* [%30, %$6] ; # Q
  %35 = phi i8* [%31, %$6] ; # Cld
; # (let Cld: (child Cld) (when (and (Cld: pid) (or (=0 Pid) (== Pid ...
; # (when (and (Cld: pid) (or (=0 Pid) (== Pid (Cld: pid)))) (wrChild...
; # (and (Cld: pid) (or (=0 Pid) (== Pid (Cld: pid))))
; # (Cld: pid)
  %36 = getelementptr i8, i8* %35, i32 24
  %37 = bitcast i8* %36 to i32*
  %38 = load i32, i32* %37
  %39 = icmp ne i32 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  %40 = phi i8* [%33, %$7] ; # P
  %41 = phi i8* [%34, %$7] ; # Q
  %42 = phi i8* [%35, %$7] ; # Cld
; # (or (=0 Pid) (== Pid (Cld: pid)))
; # (=0 Pid)
  %43 = icmp eq i32 %0, 0
  br i1 %43, label %$11, label %$12
$12:
  %44 = phi i8* [%40, %$10] ; # P
  %45 = phi i8* [%41, %$10] ; # Q
  %46 = phi i8* [%42, %$10] ; # Cld
; # (Cld: pid)
  %47 = getelementptr i8, i8* %35, i32 24
  %48 = bitcast i8* %47 to i32*
  %49 = load i32, i32* %48
; # (== Pid (Cld: pid))
  %50 = icmp eq i32 %0, %49
  br label %$11
$11:
  %51 = phi i8* [%40, %$10], [%44, %$12] ; # P
  %52 = phi i8* [%41, %$10], [%45, %$12] ; # Q
  %53 = phi i8* [%42, %$10], [%46, %$12] ; # Cld
  %54 = phi i1 [1, %$10], [%50, %$12] ; # ->
  br label %$9
$9:
  %55 = phi i8* [%33, %$7], [%51, %$11] ; # P
  %56 = phi i8* [%34, %$7], [%52, %$11] ; # Q
  %57 = phi i8* [%35, %$7], [%53, %$11] ; # Cld
  %58 = phi i1 [0, %$7], [%54, %$11] ; # ->
  br i1 %58, label %$13, label %$14
$13:
  %59 = phi i8* [%55, %$9] ; # P
  %60 = phi i8* [%56, %$9] ; # Q
  %61 = phi i8* [%57, %$9] ; # Cld
; # (wrChild Cld Q N)
  call void @wrChild(i8* %61, i8* %60, i64 %7)
  br label %$14
$14:
  %62 = phi i8* [%55, %$9], [%59, %$13] ; # P
  %63 = phi i8* [%56, %$9], [%60, %$13] ; # Q
  %64 = phi i8* [%57, %$9], [%61, %$13] ; # Cld
; # (ofs Cld (child T))
  %65 = getelementptr i8, i8* %64, i32 36
  br label %$6
$8:
  %66 = phi i8* [%29, %$6] ; # P
  %67 = phi i8* [%30, %$6] ; # Q
  %68 = phi i8* [%31, %$6] ; # Cld
  ret void
}

define void @unsync() {
$1:
; # (when (val $Tell) (unless (wrBytes @ (i8* (push 0)) 8) (close @) ...
; # (val $Tell)
  %0 = load i32, i32* @$Tell
  %1 = icmp ne i32 %0, 0
  br i1 %1, label %$2, label %$3
$2:
; # (unless (wrBytes @ (i8* (push 0)) 8) (close @) (set $Tell 0))
; # (push 0)
  %2 = alloca i64, i64 1
  store i64 0, i64* %2
; # (i8* (push 0))
  %3 = bitcast i64* %2 to i8*
; # (wrBytes @ (i8* (push 0)) 8)
  %4 = call i1 @wrBytes(i32 %0, i8* %3, i64 8)
  br i1 %4, label %$5, label %$4
$4:
; # (close @)
  %5 = call i32 @close(i32 %0)
; # (set $Tell 0)
  store i32 0, i32* @$Tell
  br label %$5
$5:
  br label %$3
$3:
; # (set $Sync NO)
  store i1 0, i1* @$Sync
  ret void
}

define i64 @rdHear() {
$1:
; # (let In (val $InFile) (set $InFile (val (ofs (val $InFiles) (val ...
; # (val $InFile)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (set $InFile (val (ofs (val $InFiles) (val $Hear))) $GetBin (fun ...
; # (val $InFiles)
  %1 = load i8**, i8*** @$InFiles
; # (val $Hear)
  %2 = load i32, i32* @$Hear
; # (ofs (val $InFiles) (val $Hear))
  %3 = getelementptr i8*, i8** %1, i32 %2
; # (val (ofs (val $InFiles) (val $Hear)))
  %4 = load i8*, i8** %3
  store i8* %4, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (fun (i32) getBinary)
  store i32()* @getBinary, i32()** @$GetBin
  store i32 0, i32* @$Extn
; # (prog1 (binRead) (set $InFile In))
; # (binRead)
  %5 = call i64 @binRead()
; # (set $InFile In)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
  ret i64 %5
}

define void @waitFile(i32) {
$1:
; # (when (> Pid 1) (let Res (b32 1) (while (lt0 (waitpid Pid Res 0))...
; # (> Pid 1)
  %1 = icmp sgt i32 %0, 1
  br i1 %1, label %$2, label %$3
$2:
; # (let Res (b32 1) (while (lt0 (waitpid Pid Res 0)) (unless (== (gE...
; # (b32 1)
  %2 = alloca i32, i64 1
; # (while (lt0 (waitpid Pid Res 0)) (unless (== (gErrno) EINTR) (clo...
  br label %$4
$4:
; # (waitpid Pid Res 0)
  %3 = call i32 @waitpid(i32 %0, i32* %2, i32 0)
; # (lt0 (waitpid Pid Res 0))
  %4 = icmp slt i32 %3, 0
  br i1 %4, label %$5, label %$6
$5:
; # (unless (== (gErrno) EINTR) (closeErr))
; # (gErrno)
  %5 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %6 = icmp eq i32 %5, 2
  br i1 %6, label %$8, label %$7
$7:
; # (closeErr)
  call void @closeErr()
  unreachable
$8:
; # (sigChk 0)
  %7 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %$9, label %$10
$9:
  call void @sighandler(i64 0)
  br label %$10
$10:
  br label %$4
$6:
; # (set $At2 (cnt (i64 (val Res))))
; # (val Res)
  %9 = load i32, i32* %2
; # (i64 (val Res))
  %10 = sext i32 %9 to i64
; # (cnt (i64 (val Res)))
  %11 = shl i64 %10, 4
  %12 = or i64 %11, 2
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %12, i64* %13
  br label %$3
$3:
  ret void
}

define i32 @currFd(i64) {
$1:
; # (let (In (val $InFrames) Out (val $OutFrames)) (nond ((or In Out)...
; # (val $InFrames)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (val $OutFrames)
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (nond ((or In Out) (err 0 0 ($ "No current fd") null)) (Out ((ioF...
; # (or In Out)
  %3 = icmp ne i8* %1, null
  br i1 %3, label %$3, label %$4
$4:
  %4 = icmp ne i8* %2, null
  br label %$3
$3:
  %5 = phi i1 [1, %$1], [%4, %$4] ; # ->
  br i1 %5, label %$5, label %$6
$6:
; # (err 0 0 ($ "No current fd") null)
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$37 to i8*), i8* null)
  unreachable
$5:
  %6 = icmp ne i8* %2, null
  br i1 %6, label %$7, label %$8
$8:
; # ((ioFrame In) fd)
  %7 = getelementptr i8, i8* %1, i32 8
  %8 = bitcast i8* %7 to i32*
  %9 = load i32, i32* %8
  br label %$2
$7:
  %10 = icmp ne i8* %1, null
  br i1 %10, label %$9, label %$10
$10:
; # ((ioFrame Out) fd)
  %11 = getelementptr i8, i8* %2, i32 8
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
  br label %$2
$9:
; # (if (if (> In (stack)) (> Out In) (> In Out)) ((ioFrame In) fd) (...
; # (if (> In (stack)) (> Out In) (> In Out))
; # (stack)
  %14 = call i8* @llvm.stacksave()
; # (> In (stack))
  %15 = icmp ugt i8* %1, %14
  br i1 %15, label %$11, label %$12
$11:
; # (> Out In)
  %16 = icmp ugt i8* %2, %1
  br label %$13
$12:
; # (> In Out)
  %17 = icmp ugt i8* %1, %2
  br label %$13
$13:
  %18 = phi i1 [%16, %$11], [%17, %$12] ; # ->
  br i1 %18, label %$14, label %$15
$14:
; # ((ioFrame In) fd)
  %19 = getelementptr i8, i8* %1, i32 8
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* %20
  br label %$16
$15:
; # ((ioFrame Out) fd)
  %22 = getelementptr i8, i8* %2, i32 8
  %23 = bitcast i8* %22 to i32*
  %24 = load i32, i32* %23
  br label %$16
$16:
  %25 = phi i32 [%21, %$14], [%24, %$15] ; # ->
  br label %$2
$2:
  %26 = phi i32 [%9, %$8], [%13, %$10], [%25, %$16] ; # ->
  ret i32 %26
}

define void @pushInFiles(i8*) {
$1:
; # (let (Io: (ioFrame P) In: (inFile (val $InFile))) (when (In:) (In...
; # (val $InFile)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (when (In:) (In: next (val $Chr)))
; # (In:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$2, label %$3
$2:
; # (In: next (val $Chr))
  %3 = getelementptr i8, i8* %1, i32 20
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  store i32 %5, i32* %4
  br label %$3
$3:
; # (set $Chr (if (set $InFile (val (ofs (val $InFiles) (Io: fd)))) (...
; # (if (set $InFile (val (ofs (val $InFiles) (Io: fd)))) ((inFile @)...
; # (set $InFile (val (ofs (val $InFiles) (Io: fd))))
; # (val $InFiles)
  %6 = load i8**, i8*** @$InFiles
; # (Io: fd)
  %7 = getelementptr i8, i8* %0, i32 8
  %8 = bitcast i8* %7 to i32*
  %9 = load i32, i32* %8
; # (ofs (val $InFiles) (Io: fd))
  %10 = getelementptr i8*, i8** %6, i32 %9
; # (val (ofs (val $InFiles) (Io: fd)))
  %11 = load i8*, i8** %10
  store i8* %11, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
  %12 = icmp ne i8* %11, null
  br i1 %12, label %$4, label %$5
$4:
; # ((inFile @) next)
  %13 = getelementptr i8, i8* %11, i32 20
  %14 = bitcast i8* %13 to i32*
  %15 = load i32, i32* %14
  br label %$6
$5:
  br label %$6
$6:
  %16 = phi i32 [%15, %$4], [-1, %$5] ; # ->
  store i32 %16, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (Io: fun (val (i8** $Get)))
  %17 = getelementptr i8, i8* %0, i32 16
  %18 = bitcast i8* %17 to i8**
  %19 = bitcast i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**) to i8**
  %20 = load i8*, i8** %19
  store i8* %20, i8** %18
; # (set $Get (fun (i32) _getStdin))
; # (fun (i32) _getStdin)
  store i32()* @_getStdin, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
; # (Io: link (val $InFrames))
  %21 = bitcast i8* %0 to i8**
  %22 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
  store i8* %22, i8** %21
; # (set $InFrames (Io:))
; # (Io:)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
  ret void
}

define void @pushOutFiles(i8*) {
$1:
; # (let Io: (ioFrame P) (set $OutFile (val (ofs (val $OutFiles) (Io:...
; # (set $OutFile (val (ofs (val $OutFiles) (Io: fd))))
; # (val $OutFiles)
  %1 = load i8**, i8*** @$OutFiles
; # (Io: fd)
  %2 = getelementptr i8, i8* %0, i32 8
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3
; # (ofs (val $OutFiles) (Io: fd))
  %5 = getelementptr i8*, i8** %1, i32 %4
; # (val (ofs (val $OutFiles) (Io: fd)))
  %6 = load i8*, i8** %5
  store i8* %6, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (Io: fun (val (i8** $Put)))
  %7 = getelementptr i8, i8* %0, i32 16
  %8 = bitcast i8* %7 to i8**
  %9 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i8**
  %10 = load i8*, i8** %9
  store i8* %10, i8** %8
; # (set $Put (fun (void i8) _putStdout))
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
; # (Io: link (val $OutFrames))
  %11 = bitcast i8* %0 to i8**
  %12 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
  store i8* %12, i8** %11
; # (set $OutFrames (Io:))
; # (Io:)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
  ret void
}

define void @pushErrFiles(i8*) {
$1:
; # ((ioFrame P) link (val $ErrFrames))
  %1 = bitcast i8* %0 to i8**
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 56) to i8**)
  store i8* %2, i8** %1
; # (set $ErrFrames P)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 56) to i8**)
  ret void
}

define void @pushCtlFiles(i8*) {
$1:
; # ((ioFrame P) link (val $CtlFrames))
  %1 = bitcast i8* %0 to i8**
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 64) to i8**)
  store i8* %2, i8** %1
; # (set $CtlFrames P)
  store i8* %0, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 64) to i8**)
  ret void
}

define void @popInFiles() {
$1:
; # (let Io: (ioFrame (val $InFrames)) (cond ((Io: pid) (close (Io: f...
; # (val $InFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (cond ((Io: pid) (close (Io: fd)) (closeInFile (Io: fd)) (waitFil...
; # (Io: pid)
  %1 = getelementptr i8, i8* %0, i32 12
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %$4, label %$3
$4:
; # (Io: fd)
  %5 = getelementptr i8, i8* %0, i32 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
; # (close (Io: fd))
  %8 = call i32 @close(i32 %7)
; # (Io: fd)
  %9 = getelementptr i8, i8* %0, i32 8
  %10 = bitcast i8* %9 to i32*
  %11 = load i32, i32* %10
; # (closeInFile (Io: fd))
  call void @closeInFile(i32 %11)
; # (Io: pid)
  %12 = getelementptr i8, i8* %0, i32 12
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13
; # (waitFile (Io: pid))
  call void @waitFile(i32 %14)
  br label %$2
$3:
; # (val $InFile)
  %15 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
  %16 = icmp ne i8* %15, null
  br i1 %16, label %$6, label %$5
$6:
; # (val $InFile)
  %17 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # ((inFile (val $InFile)) next (val $Chr))
  %18 = getelementptr i8, i8* %17, i32 20
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  store i32 %20, i32* %19
  br label %$2
$5:
  br label %$2
$2:
; # (set (i8** $Get) (Io: fun))
; # (i8** $Get)
  %21 = bitcast i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**) to i8**
; # (Io: fun)
  %22 = getelementptr i8, i8* %0, i32 16
  %23 = bitcast i8* %22 to i8**
  %24 = load i8*, i8** %23
  store i8* %24, i8** %21
; # (set $InFrames (Io: link))
; # (Io: link)
  %25 = bitcast i8* %0 to i8**
  %26 = load i8*, i8** %25
  store i8* %26, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (set $Chr (if (set $InFile (val (if (Io:) (ofs (val $InFiles) (Io...
; # (if (set $InFile (val (if (Io:) (ofs (val $InFiles) (Io: fd)) (va...
; # (set $InFile (val (if (Io:) (ofs (val $InFiles) (Io: fd)) (val $I...
; # (if (Io:) (ofs (val $InFiles) (Io: fd)) (val $InFiles))
; # (Io:)
  %27 = icmp ne i8* %26, null
  br i1 %27, label %$7, label %$8
$7:
; # (val $InFiles)
  %28 = load i8**, i8*** @$InFiles
; # (Io: fd)
  %29 = getelementptr i8, i8* %26, i32 8
  %30 = bitcast i8* %29 to i32*
  %31 = load i32, i32* %30
; # (ofs (val $InFiles) (Io: fd))
  %32 = getelementptr i8*, i8** %28, i32 %31
  br label %$9
$8:
; # (val $InFiles)
  %33 = load i8**, i8*** @$InFiles
  br label %$9
$9:
  %34 = phi i8** [%32, %$7], [%33, %$8] ; # ->
; # (val (if (Io:) (ofs (val $InFiles) (Io: fd)) (val $InFiles)))
  %35 = load i8*, i8** %34
  store i8* %35, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
  %36 = icmp ne i8* %35, null
  br i1 %36, label %$10, label %$11
$10:
; # (val $InFile)
  %37 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # ((inFile (val $InFile)) next)
  %38 = getelementptr i8, i8* %37, i32 20
  %39 = bitcast i8* %38 to i32*
  %40 = load i32, i32* %39
  br label %$12
$11:
  br label %$12
$12:
  %41 = phi i32 [%40, %$10], [-1, %$11] ; # ->
  store i32 %41, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  ret void
}

define void @popOutFiles() {
$1:
; # (val $OutFile)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (flush (val $OutFile))
  %1 = call i1 @flush(i8* %0)
; # (let Io: (ioFrame (val $OutFrames)) (when (Io: pid) (close (Io: f...
; # (val $OutFrames)
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (when (Io: pid) (close (Io: fd)) (closeOutFile (Io: fd)) (waitFil...
; # (Io: pid)
  %3 = getelementptr i8, i8* %2, i32 12
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
  %6 = icmp ne i32 %5, 0
  br i1 %6, label %$2, label %$3
$2:
; # (Io: fd)
  %7 = getelementptr i8, i8* %2, i32 8
  %8 = bitcast i8* %7 to i32*
  %9 = load i32, i32* %8
; # (close (Io: fd))
  %10 = call i32 @close(i32 %9)
; # (Io: fd)
  %11 = getelementptr i8, i8* %2, i32 8
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
; # (closeOutFile (Io: fd))
  call void @closeOutFile(i32 %13)
; # (Io: pid)
  %14 = getelementptr i8, i8* %2, i32 12
  %15 = bitcast i8* %14 to i32*
  %16 = load i32, i32* %15
; # (waitFile (Io: pid))
  call void @waitFile(i32 %16)
  br label %$3
$3:
; # (set (i8** $Put) (Io: fun))
; # (i8** $Put)
  %17 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i8**
; # (Io: fun)
  %18 = getelementptr i8, i8* %2, i32 16
  %19 = bitcast i8* %18 to i8**
  %20 = load i8*, i8** %19
  store i8* %20, i8** %17
; # (set $OutFrames (Io: link))
; # (Io: link)
  %21 = bitcast i8* %2 to i8**
  %22 = load i8*, i8** %21
  store i8* %22, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (set $OutFile (if (Io:) (val (ofs (val $OutFiles) (Io: fd))) (val...
; # (if (Io:) (val (ofs (val $OutFiles) (Io: fd))) (val 2 (val $OutFi...
; # (Io:)
  %23 = icmp ne i8* %22, null
  br i1 %23, label %$4, label %$5
$4:
; # (val $OutFiles)
  %24 = load i8**, i8*** @$OutFiles
; # (Io: fd)
  %25 = getelementptr i8, i8* %22, i32 8
  %26 = bitcast i8* %25 to i32*
  %27 = load i32, i32* %26
; # (ofs (val $OutFiles) (Io: fd))
  %28 = getelementptr i8*, i8** %24, i32 %27
; # (val (ofs (val $OutFiles) (Io: fd)))
  %29 = load i8*, i8** %28
  br label %$6
$5:
; # (val $OutFiles)
  %30 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %31 = getelementptr i8*, i8** %30, i32 1
  %32 = load i8*, i8** %31
  br label %$6
$6:
  %33 = phi i8* [%29, %$4], [%32, %$5] ; # ->
  store i8* %33, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
  ret void
}

define void @popErrFiles() {
$1:
; # (let Io: (ioFrame (val $ErrFrames)) (dup2 (Io: fd) 2) (close (Io:...
; # (val $ErrFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 56) to i8**)
; # (Io: fd)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (dup2 (Io: fd) 2)
  %4 = call i32 @dup2(i32 %3, i32 2)
; # (Io: fd)
  %5 = getelementptr i8, i8* %0, i32 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
; # (close (Io: fd))
  %8 = call i32 @close(i32 %7)
; # (set $ErrFrames (Io: link))
; # (Io: link)
  %9 = bitcast i8* %0 to i8**
  %10 = load i8*, i8** %9
  store i8* %10, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 56) to i8**)
  ret void
}

define void @popCtlFiles() {
$1:
; # (let Io: (ioFrame (val $CtlFrames)) (if (ge0 (Io: fd)) (close @) ...
; # (val $CtlFrames)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 64) to i8**)
; # (if (ge0 (Io: fd)) (close @) (unLock (currFd 0) 0 0))
; # (Io: fd)
  %1 = getelementptr i8, i8* %0, i32 8
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (ge0 (Io: fd))
  %4 = icmp sge i32 %3, 0
  br i1 %4, label %$2, label %$3
$2:
; # (close @)
  %5 = call i32 @close(i32 %3)
  br label %$4
$3:
; # (currFd 0)
  %6 = call i32 @currFd(i64 0)
; # (unLock (currFd 0) 0 0)
  %7 = call i32 @unLock(i32 %6, i64 0, i64 0)
  br label %$4
$4:
  %8 = phi i32 [%5, %$2], [%7, %$3] ; # ->
; # (set $CtlFrames (Io: link))
; # (Io: link)
  %9 = bitcast i8* %0 to i8**
  %10 = load i8*, i8** %9
  store i8* %10, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 64) to i8**)
  ret void
}

define i64 @_path(i64) {
$1:
; # (let Nm (xName Exe (evSym (cdr Exe))) (mkStr (pathString Nm (b8 (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym (cdr Exe)))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %6 = call i64 @pathSize(i64 %5)
; # (b8 (pathSize Nm))
  %7 = alloca i8, i64 %6
; # (pathString Nm (b8 (pathSize Nm)))
  %8 = call i8* @pathString(i64 %5, i8* %7)
; # (mkStr (pathString Nm (b8 (pathSize Nm))))
  %9 = call i64 @mkStr(i8* %8)
  ret i64 %9
}

define i1 @hasData(i32) {
$1:
; # (and (> (val $InFDs) Fd) (val (ofs (val $InFiles) Fd)) (let In: (...
; # (val $InFDs)
  %1 = load i32, i32* @$InFDs
; # (> (val $InFDs) Fd)
  %2 = icmp sgt i32 %1, %0
  br i1 %2, label %$3, label %$2
$3:
; # (val $InFiles)
  %3 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %4 = getelementptr i8*, i8** %3, i32 %0
; # (val (ofs (val $InFiles) Fd))
  %5 = load i8*, i8** %4
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$4, label %$2
$4:
; # (let In: (inFile @) (> (In: cnt) (In: ix)))
; # (In: cnt)
  %7 = getelementptr i8, i8* %5, i32 8
  %8 = bitcast i8* %7 to i64*
  %9 = load i64, i64* %8
; # (In: ix)
  %10 = bitcast i8* %5 to i64*
  %11 = load i64, i64* %10
; # (> (In: cnt) (In: ix))
  %12 = icmp ugt i64 %9, %11
  br label %$2
$2:
  %13 = phi i1 [0, %$1], [0, %$3], [%12, %$4] ; # ->
  ret i1 %13
}

define i64 @waitFd(i64, i32, i64) {
$1:
; # (let (At (save (val $At)) Task (val $Task) Run (link (push (set $...
; # (val $At)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %4 = load i64, i64* %3
; # (save (val $At))
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %4, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %12
; # (val $Task)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 168) to i64) to i64*
  %14 = load i64, i64* %13
; # (set $Task (val $Run))
; # (val $Run)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 168) to i64) to i64*
  store i64 %16, i64* %17
; # (push (set $Task (val $Run)) NIL)
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %16, i64* %20
; # (link (push (set $Task (val $Run)) NIL))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (val PipeBufSize)
  %26 = load i64, i64* @PipeBufSize
; # (b8 (val PipeBufSize))
  %27 = alloca i8, i64 %26
; # (b32 2)
  %28 = alloca i32, i64 2
; # (getMsec)
  %29 = call i64 @getMsec()
; # (stkChk Exe)
  %30 = load i8*, i8** @$StkLimit
  %31 = call i8* @llvm.stacksave()
  %32 = icmp ugt i8* %30, %31
  br i1 %32, label %$2, label %$3
$2:
  call void @stkErr(i64 %0)
  unreachable
$3:
; # (loop (let (Stk (stack) Poll (b64 (+ (length (val $Run)) (val $Ch...
  br label %$4
$4:
  %33 = phi i64 [%2, %$3], [%1002, %$164] ; # Ms
  %34 = phi i64 [%29, %$3], [%1003, %$164] ; # Tim
; # (let (Stk (stack) Poll (b64 (+ (length (val $Run)) (val $Children...
; # (stack)
  %35 = call i8* @llvm.stacksave()
; # (val $Run)
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  %37 = load i64, i64* %36
; # (length (val $Run))
  br label %$5
$5:
  %38 = phi i64 [%37, %$4], [%47, %$6] ; # X
  %39 = phi i64 [0, %$4], [%44, %$6] ; # N
  %40 = and i64 %38, 15
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %$6, label %$7
$6:
  %42 = phi i64 [%38, %$5] ; # X
  %43 = phi i64 [%39, %$5] ; # N
  %44 = add i64 %43, 1
  %45 = inttoptr i64 %42 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  br label %$5
$7:
  %48 = phi i64 [%38, %$5] ; # X
  %49 = phi i64 [%39, %$5] ; # N
; # (val $Children)
  %50 = load i64, i64* @$Children
; # (+ (length (val $Run)) (val $Children) 3)
  %51 = add i64 %49, %50
  %52 = add i64 %51, 3
; # (b64 (+ (length (val $Run)) (val $Children) 3))
  %53 = alloca i64, i64 %52
; # (when (ge0 Fd) (if (hasData Fd) (setq Dly 0) (pollIn Fd Poll) (in...
; # (ge0 Fd)
  %54 = icmp sge i32 %1, 0
  br i1 %54, label %$8, label %$9
$8:
  %55 = phi i64 [%33, %$7] ; # Ms
  %56 = phi i64 [%34, %$7] ; # Tim
  %57 = phi i64 [0, %$7] ; # Nfds
  %58 = phi i64 [%33, %$7] ; # Dly
; # (if (hasData Fd) (setq Dly 0) (pollIn Fd Poll) (inc 'Nfds))
; # (hasData Fd)
  %59 = call i1 @hasData(i32 %1)
  br i1 %59, label %$10, label %$11
$10:
  %60 = phi i64 [%55, %$8] ; # Ms
  %61 = phi i64 [%56, %$8] ; # Tim
  %62 = phi i64 [%57, %$8] ; # Nfds
  %63 = phi i64 [%58, %$8] ; # Dly
  br label %$12
$11:
  %64 = phi i64 [%55, %$8] ; # Ms
  %65 = phi i64 [%56, %$8] ; # Tim
  %66 = phi i64 [%57, %$8] ; # Nfds
  %67 = phi i64 [%58, %$8] ; # Dly
; # (pollIn Fd Poll)
  call void @pollIn(i32 %1, i64* %53)
; # (inc 'Nfds)
  %68 = add i64 %66, 1
  br label %$12
$12:
  %69 = phi i64 [%60, %$10], [%64, %$11] ; # Ms
  %70 = phi i64 [%61, %$10], [%65, %$11] ; # Tim
  %71 = phi i64 [%62, %$10], [%68, %$11] ; # Nfds
  %72 = phi i64 [0, %$10], [%67, %$11] ; # Dly
  %73 = phi i64 [0, %$10], [%68, %$11] ; # ->
  br label %$9
$9:
  %74 = phi i64 [%33, %$7], [%69, %$12] ; # Ms
  %75 = phi i64 [%34, %$7], [%70, %$12] ; # Tim
  %76 = phi i64 [0, %$7], [%71, %$12] ; # Nfds
  %77 = phi i64 [%33, %$7], [%72, %$12] ; # Dly
; # (let R (val Run) (while (pair R) (let X (++ R) (unless (memq X Ta...
; # (val Run)
  %78 = inttoptr i64 %19 to i64*
  %79 = load i64, i64* %78
; # (while (pair R) (let X (++ R) (unless (memq X Task) (cond ((sign?...
  br label %$13
$13:
  %80 = phi i64 [%74, %$9], [%184, %$23] ; # Ms
  %81 = phi i64 [%75, %$9], [%185, %$23] ; # Tim
  %82 = phi i64 [%76, %$9], [%186, %$23] ; # Nfds
  %83 = phi i64 [%77, %$9], [%187, %$23] ; # Dly
  %84 = phi i64 [%79, %$9], [%188, %$23] ; # R
; # (pair R)
  %85 = and i64 %84, 15
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$14, label %$15
$14:
  %87 = phi i64 [%80, %$13] ; # Ms
  %88 = phi i64 [%81, %$13] ; # Tim
  %89 = phi i64 [%82, %$13] ; # Nfds
  %90 = phi i64 [%83, %$13] ; # Dly
  %91 = phi i64 [%84, %$13] ; # R
; # (let X (++ R) (unless (memq X Task) (cond ((sign? (car X)) (let N...
; # (++ R)
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
  %94 = getelementptr i64, i64* %92, i32 1
  %95 = load i64, i64* %94
; # (unless (memq X Task) (cond ((sign? (car X)) (let N (int (cadr X)...
; # (memq X Task)
  br label %$16
$16:
  %96 = phi i64 [%14, %$14], [%108, %$20] ; # L
  %97 = and i64 %96, 15
  %98 = icmp ne i64 %97, 0
  br i1 %98, label %$19, label %$17
$19:
  %99 = phi i64 [%96, %$16] ; # L
  br label %$18
$17:
  %100 = phi i64 [%96, %$16] ; # L
  %101 = inttoptr i64 %100 to i64*
  %102 = load i64, i64* %101
  %103 = icmp eq i64 %93, %102
  br i1 %103, label %$21, label %$20
$21:
  %104 = phi i64 [%100, %$17] ; # L
  br label %$18
$20:
  %105 = phi i64 [%100, %$17] ; # L
  %106 = inttoptr i64 %105 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
  br label %$16
$18:
  %109 = phi i64 [%99, %$19], [%104, %$21] ; # L
  %110 = phi i1 [0, %$19], [1, %$21] ; # ->
  br i1 %110, label %$23, label %$22
$22:
  %111 = phi i64 [%87, %$18] ; # Ms
  %112 = phi i64 [%88, %$18] ; # Tim
  %113 = phi i64 [%89, %$18] ; # Nfds
  %114 = phi i64 [%90, %$18] ; # Dly
  %115 = phi i64 [%95, %$18] ; # R
; # (cond ((sign? (car X)) (let N (int (cadr X)) (when (> Dly N) (set...
; # (car X)
  %116 = inttoptr i64 %93 to i64*
  %117 = load i64, i64* %116
; # (sign? (car X))
  %118 = and i64 %117, 8
  %119 = icmp ne i64 %118, 0
  br i1 %119, label %$26, label %$25
$26:
  %120 = phi i64 [%111, %$22] ; # Ms
  %121 = phi i64 [%112, %$22] ; # Tim
  %122 = phi i64 [%113, %$22] ; # Nfds
  %123 = phi i64 [%114, %$22] ; # Dly
  %124 = phi i64 [%115, %$22] ; # R
; # (let N (int (cadr X)) (when (> Dly N) (setq Dly N)))
; # (cadr X)
  %125 = inttoptr i64 %93 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
  %128 = inttoptr i64 %127 to i64*
  %129 = load i64, i64* %128
; # (int (cadr X))
  %130 = lshr i64 %129, 4
; # (when (> Dly N) (setq Dly N))
; # (> Dly N)
  %131 = icmp ugt i64 %123, %130
  br i1 %131, label %$27, label %$28
$27:
  %132 = phi i64 [%120, %$26] ; # Ms
  %133 = phi i64 [%121, %$26] ; # Tim
  %134 = phi i64 [%122, %$26] ; # Nfds
  %135 = phi i64 [%123, %$26] ; # Dly
  %136 = phi i64 [%124, %$26] ; # R
  br label %$28
$28:
  %137 = phi i64 [%120, %$26], [%132, %$27] ; # Ms
  %138 = phi i64 [%121, %$26], [%133, %$27] ; # Tim
  %139 = phi i64 [%122, %$26], [%134, %$27] ; # Nfds
  %140 = phi i64 [%123, %$26], [%130, %$27] ; # Dly
  %141 = phi i64 [%124, %$26], [%136, %$27] ; # R
  br label %$24
$25:
  %142 = phi i64 [%111, %$22] ; # Ms
  %143 = phi i64 [%112, %$22] ; # Tim
  %144 = phi i64 [%113, %$22] ; # Nfds
  %145 = phi i64 [%114, %$22] ; # Dly
  %146 = phi i64 [%115, %$22] ; # R
; # (int @)
  %147 = lshr i64 %117, 4
; # (i32 (int @))
  %148 = trunc i64 %147 to i32
; # (<> (i32 (int @)) Fd)
  %149 = icmp ne i32 %148, %1
  br i1 %149, label %$30, label %$29
$30:
  %150 = phi i64 [%142, %$25] ; # Ms
  %151 = phi i64 [%143, %$25] ; # Tim
  %152 = phi i64 [%144, %$25] ; # Nfds
  %153 = phi i64 [%145, %$25] ; # Dly
  %154 = phi i64 [%146, %$25] ; # R
; # (let N @ (if (hasData N) (setq Dly 0) (pollIn N (ofs Poll Nfds)) ...
; # (if (hasData N) (setq Dly 0) (pollIn N (ofs Poll Nfds)) (inc 'Nfd...
; # (hasData N)
  %155 = call i1 @hasData(i32 %148)
  br i1 %155, label %$31, label %$32
$31:
  %156 = phi i64 [%150, %$30] ; # Ms
  %157 = phi i64 [%151, %$30] ; # Tim
  %158 = phi i64 [%152, %$30] ; # Nfds
  %159 = phi i64 [%153, %$30] ; # Dly
  %160 = phi i64 [%154, %$30] ; # R
  br label %$33
$32:
  %161 = phi i64 [%150, %$30] ; # Ms
  %162 = phi i64 [%151, %$30] ; # Tim
  %163 = phi i64 [%152, %$30] ; # Nfds
  %164 = phi i64 [%153, %$30] ; # Dly
  %165 = phi i64 [%154, %$30] ; # R
; # (ofs Poll Nfds)
  %166 = getelementptr i64, i64* %53, i64 %163
; # (pollIn N (ofs Poll Nfds))
  call void @pollIn(i32 %148, i64* %166)
; # (inc 'Nfds)
  %167 = add i64 %163, 1
  br label %$33
$33:
  %168 = phi i64 [%156, %$31], [%161, %$32] ; # Ms
  %169 = phi i64 [%157, %$31], [%162, %$32] ; # Tim
  %170 = phi i64 [%158, %$31], [%167, %$32] ; # Nfds
  %171 = phi i64 [0, %$31], [%164, %$32] ; # Dly
  %172 = phi i64 [%160, %$31], [%165, %$32] ; # R
  %173 = phi i64 [0, %$31], [%167, %$32] ; # ->
  br label %$24
$29:
  %174 = phi i64 [%142, %$25] ; # Ms
  %175 = phi i64 [%143, %$25] ; # Tim
  %176 = phi i64 [%144, %$25] ; # Nfds
  %177 = phi i64 [%145, %$25] ; # Dly
  %178 = phi i64 [%146, %$25] ; # R
  br label %$24
$24:
  %179 = phi i64 [%137, %$28], [%168, %$33], [%174, %$29] ; # Ms
  %180 = phi i64 [%138, %$28], [%169, %$33], [%175, %$29] ; # Tim
  %181 = phi i64 [%139, %$28], [%170, %$33], [%176, %$29] ; # Nfds
  %182 = phi i64 [%140, %$28], [%171, %$33], [%177, %$29] ; # Dly
  %183 = phi i64 [%141, %$28], [%172, %$33], [%178, %$29] ; # R
  br label %$23
$23:
  %184 = phi i64 [%87, %$18], [%179, %$24] ; # Ms
  %185 = phi i64 [%88, %$18], [%180, %$24] ; # Tim
  %186 = phi i64 [%89, %$18], [%181, %$24] ; # Nfds
  %187 = phi i64 [%90, %$18], [%182, %$24] ; # Dly
  %188 = phi i64 [%95, %$18], [%183, %$24] ; # R
  br label %$13
$15:
  %189 = phi i64 [%80, %$13] ; # Ms
  %190 = phi i64 [%81, %$13] ; # Tim
  %191 = phi i64 [%82, %$13] ; # Nfds
  %192 = phi i64 [%83, %$13] ; # Dly
  %193 = phi i64 [%84, %$13] ; # R
; # (and (val $Hear) (<> @ Fd) (let N @ (if (hasData N) (setq Dly 0) ...
; # (val $Hear)
  %194 = load i32, i32* @$Hear
  %195 = icmp ne i32 %194, 0
  br i1 %195, label %$35, label %$34
$35:
  %196 = phi i64 [%189, %$15] ; # Ms
  %197 = phi i64 [%190, %$15] ; # Tim
  %198 = phi i64 [%191, %$15] ; # Nfds
  %199 = phi i64 [%192, %$15] ; # Dly
; # (<> @ Fd)
  %200 = icmp ne i32 %194, %1
  br i1 %200, label %$36, label %$34
$36:
  %201 = phi i64 [%196, %$35] ; # Ms
  %202 = phi i64 [%197, %$35] ; # Tim
  %203 = phi i64 [%198, %$35] ; # Nfds
  %204 = phi i64 [%199, %$35] ; # Dly
; # (let N @ (if (hasData N) (setq Dly 0) (pollIn N (ofs Poll Nfds)) ...
; # (if (hasData N) (setq Dly 0) (pollIn N (ofs Poll Nfds)) (inc 'Nfd...
; # (hasData N)
  %205 = call i1 @hasData(i32 %194)
  br i1 %205, label %$37, label %$38
$37:
  %206 = phi i64 [%201, %$36] ; # Ms
  %207 = phi i64 [%202, %$36] ; # Tim
  %208 = phi i64 [%203, %$36] ; # Nfds
  %209 = phi i64 [%204, %$36] ; # Dly
  br label %$39
$38:
  %210 = phi i64 [%201, %$36] ; # Ms
  %211 = phi i64 [%202, %$36] ; # Tim
  %212 = phi i64 [%203, %$36] ; # Nfds
  %213 = phi i64 [%204, %$36] ; # Dly
; # (ofs Poll Nfds)
  %214 = getelementptr i64, i64* %53, i64 %212
; # (pollIn N (ofs Poll Nfds))
  call void @pollIn(i32 %194, i64* %214)
; # (inc 'Nfds)
  %215 = add i64 %212, 1
  br label %$39
$39:
  %216 = phi i64 [%206, %$37], [%210, %$38] ; # Ms
  %217 = phi i64 [%207, %$37], [%211, %$38] ; # Tim
  %218 = phi i64 [%208, %$37], [%215, %$38] ; # Nfds
  %219 = phi i64 [0, %$37], [%213, %$38] ; # Dly
  %220 = phi i64 [0, %$37], [%215, %$38] ; # ->
  %221 = icmp ne i64 %220, 0
  br label %$34
$34:
  %222 = phi i64 [%189, %$15], [%196, %$35], [%216, %$39] ; # Ms
  %223 = phi i64 [%190, %$15], [%197, %$35], [%217, %$39] ; # Tim
  %224 = phi i64 [%191, %$15], [%198, %$35], [%218, %$39] ; # Nfds
  %225 = phi i64 [%192, %$15], [%199, %$35], [%219, %$39] ; # Dly
  %226 = phi i1 [0, %$15], [0, %$35], [%221, %$39] ; # ->
; # (when (val $Spkr) (pollIn @ (ofs Poll Nfds)) (inc 'Nfds) (let (Cl...
; # (val $Spkr)
  %227 = load i32, i32* @$Spkr
  %228 = icmp ne i32 %227, 0
  br i1 %228, label %$40, label %$41
$40:
  %229 = phi i64 [%222, %$34] ; # Ms
  %230 = phi i64 [%223, %$34] ; # Tim
  %231 = phi i64 [%224, %$34] ; # Nfds
  %232 = phi i64 [%225, %$34] ; # Dly
; # (ofs Poll Nfds)
  %233 = getelementptr i64, i64* %53, i64 %231
; # (pollIn @ (ofs Poll Nfds))
  call void @pollIn(i32 %227, i64* %233)
; # (inc 'Nfds)
  %234 = add i64 %231, 1
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %235 = load i8*, i8** @$Child
; # (val $Children)
  %236 = load i64, i64* @$Children
; # (* (val $Children) (child T))
  %237 = mul i64 %236, 36
; # (ofs Cld (* (val $Children) (child T)))
  %238 = getelementptr i8, i8* %235, i64 %237
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (Cld: pid) (poll...
  br label %$42
$42:
  %239 = phi i64 [%229, %$40], [%283, %$46] ; # Ms
  %240 = phi i64 [%230, %$40], [%284, %$46] ; # Tim
  %241 = phi i64 [%234, %$40], [%285, %$46] ; # Nfds
  %242 = phi i64 [%232, %$40], [%286, %$46] ; # Dly
  %243 = phi i8* [%235, %$40], [%288, %$46] ; # Cld
; # (== Cld <Cld)
  %244 = icmp eq i8* %243, %238
  br i1 %244, label %$44, label %$43
$43:
  %245 = phi i64 [%239, %$42] ; # Ms
  %246 = phi i64 [%240, %$42] ; # Tim
  %247 = phi i64 [%241, %$42] ; # Nfds
  %248 = phi i64 [%242, %$42] ; # Dly
  %249 = phi i8* [%243, %$42] ; # Cld
; # (let Cld: (child Cld) (when (Cld: pid) (pollIn (Cld: hear) (ofs P...
; # (when (Cld: pid) (pollIn (Cld: hear) (ofs Poll Nfds)) (inc 'Nfds)...
; # (Cld: pid)
  %250 = getelementptr i8, i8* %249, i32 24
  %251 = bitcast i8* %250 to i32*
  %252 = load i32, i32* %251
  %253 = icmp ne i32 %252, 0
  br i1 %253, label %$45, label %$46
$45:
  %254 = phi i64 [%245, %$43] ; # Ms
  %255 = phi i64 [%246, %$43] ; # Tim
  %256 = phi i64 [%247, %$43] ; # Nfds
  %257 = phi i64 [%248, %$43] ; # Dly
  %258 = phi i8* [%249, %$43] ; # Cld
; # (Cld: hear)
  %259 = getelementptr i8, i8* %249, i32 28
  %260 = bitcast i8* %259 to i32*
  %261 = load i32, i32* %260
; # (ofs Poll Nfds)
  %262 = getelementptr i64, i64* %53, i64 %256
; # (pollIn (Cld: hear) (ofs Poll Nfds))
  call void @pollIn(i32 %261, i64* %262)
; # (inc 'Nfds)
  %263 = add i64 %256, 1
; # (when (Cld: cnt) (pollIn (Cld: tell) (ofs Poll Nfds)) (inc 'Nfds)...
; # (Cld: cnt)
  %264 = getelementptr i8, i8* %249, i32 16
  %265 = bitcast i8* %264 to i64*
  %266 = load i64, i64* %265
  %267 = icmp ne i64 %266, 0
  br i1 %267, label %$47, label %$48
$47:
  %268 = phi i64 [%254, %$45] ; # Ms
  %269 = phi i64 [%255, %$45] ; # Tim
  %270 = phi i64 [%263, %$45] ; # Nfds
  %271 = phi i64 [%257, %$45] ; # Dly
  %272 = phi i8* [%258, %$45] ; # Cld
; # (Cld: tell)
  %273 = getelementptr i8, i8* %249, i32 32
  %274 = bitcast i8* %273 to i32*
  %275 = load i32, i32* %274
; # (ofs Poll Nfds)
  %276 = getelementptr i64, i64* %53, i64 %270
; # (pollIn (Cld: tell) (ofs Poll Nfds))
  call void @pollIn(i32 %275, i64* %276)
; # (inc 'Nfds)
  %277 = add i64 %270, 1
  br label %$48
$48:
  %278 = phi i64 [%254, %$45], [%268, %$47] ; # Ms
  %279 = phi i64 [%255, %$45], [%269, %$47] ; # Tim
  %280 = phi i64 [%263, %$45], [%277, %$47] ; # Nfds
  %281 = phi i64 [%257, %$45], [%271, %$47] ; # Dly
  %282 = phi i8* [%258, %$45], [%272, %$47] ; # Cld
  br label %$46
$46:
  %283 = phi i64 [%245, %$43], [%278, %$48] ; # Ms
  %284 = phi i64 [%246, %$43], [%279, %$48] ; # Tim
  %285 = phi i64 [%247, %$43], [%280, %$48] ; # Nfds
  %286 = phi i64 [%248, %$43], [%281, %$48] ; # Dly
  %287 = phi i8* [%249, %$43], [%282, %$48] ; # Cld
; # (ofs Cld (child T))
  %288 = getelementptr i8, i8* %287, i32 36
  br label %$42
$44:
  %289 = phi i64 [%239, %$42] ; # Ms
  %290 = phi i64 [%240, %$42] ; # Tim
  %291 = phi i64 [%241, %$42] ; # Nfds
  %292 = phi i64 [%242, %$42] ; # Dly
  %293 = phi i8* [%243, %$42] ; # Cld
  br label %$41
$41:
  %294 = phi i64 [%222, %$34], [%289, %$44] ; # Ms
  %295 = phi i64 [%223, %$34], [%290, %$44] ; # Tim
  %296 = phi i64 [%224, %$34], [%291, %$44] ; # Nfds
  %297 = phi i64 [%225, %$34], [%292, %$44] ; # Dly
; # (while (lt0 (gPoll Poll Nfds Dly)) (unless (== (gErrno) EINTR) (s...
  br label %$49
$49:
  %298 = phi i64 [%294, %$41], [%315, %$55] ; # Ms
  %299 = phi i64 [%295, %$41], [%316, %$55] ; # Tim
  %300 = phi i64 [%296, %$41], [%317, %$55] ; # Nfds
  %301 = phi i64 [%297, %$41], [%318, %$55] ; # Dly
; # (gPoll Poll Nfds Dly)
  %302 = call i32 @gPoll(i64* %53, i64 %300, i64 %301)
; # (lt0 (gPoll Poll Nfds Dly))
  %303 = icmp slt i32 %302, 0
  br i1 %303, label %$50, label %$51
$50:
  %304 = phi i64 [%298, %$49] ; # Ms
  %305 = phi i64 [%299, %$49] ; # Tim
  %306 = phi i64 [%300, %$49] ; # Nfds
  %307 = phi i64 [%301, %$49] ; # Dly
; # (unless (== (gErrno) EINTR) (set $Run $Nil) (selectErr Exe))
; # (gErrno)
  %308 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %309 = icmp eq i32 %308, 2
  br i1 %309, label %$53, label %$52
$52:
  %310 = phi i64 [%304, %$50] ; # Ms
  %311 = phi i64 [%305, %$50] ; # Tim
  %312 = phi i64 [%306, %$50] ; # Nfds
  %313 = phi i64 [%307, %$50] ; # Dly
; # (set $Run $Nil)
  %314 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %314
; # (selectErr Exe)
  call void @selectErr(i64 %0)
  unreachable
$53:
  %315 = phi i64 [%304, %$50] ; # Ms
  %316 = phi i64 [%305, %$50] ; # Tim
  %317 = phi i64 [%306, %$50] ; # Nfds
  %318 = phi i64 [%307, %$50] ; # Dly
; # (sigChk Exe)
  %319 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %320 = icmp ne i32 %319, 0
  br i1 %320, label %$54, label %$55
$54:
  call void @sighandler(i64 %0)
  br label %$55
$55:
  br label %$49
$51:
  %321 = phi i64 [%298, %$49] ; # Ms
  %322 = phi i64 [%299, %$49] ; # Tim
  %323 = phi i64 [%300, %$49] ; # Nfds
  %324 = phi i64 [%301, %$49] ; # Dly
; # (let (Now (getMsec) Dif (- Now Tim)) (when (val $Spkr) (set $Prot...
; # (getMsec)
  %325 = call i64 @getMsec()
; # (- Now Tim)
  %326 = sub i64 %325, %322
; # (when (val $Spkr) (set $Protect (inc (val $Protect))) (let (Cld (...
; # (val $Spkr)
  %327 = load i32, i32* @$Spkr
  %328 = icmp ne i32 %327, 0
  br i1 %328, label %$56, label %$57
$56:
  %329 = phi i64 [%321, %$51] ; # Ms
  %330 = phi i64 [%322, %$51] ; # Tim
  %331 = phi i64 [%323, %$51] ; # Nfds
  %332 = phi i64 [%324, %$51] ; # Dly
; # (set $Protect (inc (val $Protect)))
; # (val $Protect)
  %333 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (inc (val $Protect))
  %334 = add i32 %333, 1
  store i32 %334, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (let (Cld (val $Child) <Cld (ofs Cld (* (val $Children) (child T)...
; # (val $Child)
  %335 = load i8*, i8** @$Child
; # (val $Children)
  %336 = load i64, i64* @$Children
; # (* (val $Children) (child T))
  %337 = mul i64 %336, 36
; # (ofs Cld (* (val $Children) (child T)))
  %338 = getelementptr i8, i8* %335, i64 %337
; # (until (== Cld <Cld) (let Cld: (child Cld) (when (Cld: pid) (when...
  br label %$58
$58:
  %339 = phi i64 [%329, %$56], [%659, %$-1] ; # Ms
  %340 = phi i64 [%330, %$56], [%660, %$-1] ; # Tim
  %341 = phi i64 [%331, %$56], [%661, %$-1] ; # Nfds
  %342 = phi i64 [%332, %$56], [%662, %$-1] ; # Dly
  %343 = phi i8* [%335, %$56], [%664, %$-1] ; # Cld
; # (== Cld <Cld)
  %344 = icmp eq i8* %343, %338
  br i1 %344, label %$60, label %$59
$59:
  %345 = phi i64 [%339, %$58] ; # Ms
  %346 = phi i64 [%340, %$58] ; # Tim
  %347 = phi i64 [%341, %$58] ; # Nfds
  %348 = phi i64 [%342, %$58] ; # Dly
  %349 = phi i8* [%343, %$58] ; # Cld
; # (let Cld: (child Cld) (when (Cld: pid) (when (readyIn Poll (Cld: ...
; # (when (Cld: pid) (when (readyIn Poll (Cld: hear)) (cond ((=0 (rdB...
; # (Cld: pid)
  %350 = getelementptr i8, i8* %349, i32 24
  %351 = bitcast i8* %350 to i32*
  %352 = load i32, i32* %351
  %353 = icmp ne i32 %352, 0
  br i1 %353, label %$61, label %$62
$61:
  %354 = phi i64 [%345, %$59] ; # Ms
  %355 = phi i64 [%346, %$59] ; # Tim
  %356 = phi i64 [%347, %$59] ; # Nfds
  %357 = phi i64 [%348, %$59] ; # Dly
  %358 = phi i8* [%349, %$59] ; # Cld
; # (when (readyIn Poll (Cld: hear)) (cond ((=0 (rdBytesNb (Cld: hear...
; # (Cld: hear)
  %359 = getelementptr i8, i8* %349, i32 28
  %360 = bitcast i8* %359 to i32*
  %361 = load i32, i32* %360
; # (readyIn Poll (Cld: hear))
  %362 = call i1 @readyIn(i64* %53, i32 %361)
  br i1 %362, label %$63, label %$64
$63:
  %363 = phi i64 [%354, %$61] ; # Ms
  %364 = phi i64 [%355, %$61] ; # Tim
  %365 = phi i64 [%356, %$61] ; # Nfds
  %366 = phi i64 [%357, %$61] ; # Dly
  %367 = phi i8* [%358, %$61] ; # Cld
; # (cond ((=0 (rdBytesNb (Cld: hear) (i8* Pn) (* 2 4))) (clsChild Cl...
; # (Cld: hear)
  %368 = getelementptr i8, i8* %349, i32 28
  %369 = bitcast i8* %368 to i32*
  %370 = load i32, i32* %369
; # (i8* Pn)
  %371 = bitcast i32* %28 to i8*
; # (* 2 4)
; # (rdBytesNb (Cld: hear) (i8* Pn) (* 2 4))
  %372 = call i64 @rdBytesNb(i32 %370, i8* %371, i64 8)
; # (=0 (rdBytesNb (Cld: hear) (i8* Pn) (* 2 4)))
  %373 = icmp eq i64 %372, 0
  br i1 %373, label %$67, label %$66
$67:
  %374 = phi i64 [%363, %$63] ; # Ms
  %375 = phi i64 [%364, %$63] ; # Tim
  %376 = phi i64 [%365, %$63] ; # Nfds
  %377 = phi i64 [%366, %$63] ; # Dly
  %378 = phi i8* [%367, %$63] ; # Cld
; # (clsChild Cld)
  call void @clsChild(i8* %378)
; # (goto 1)
  br label %$-1
$66:
  %379 = phi i64 [%363, %$63] ; # Ms
  %380 = phi i64 [%364, %$63] ; # Tim
  %381 = phi i64 [%365, %$63] ; # Nfds
  %382 = phi i64 [%366, %$63] ; # Dly
  %383 = phi i8* [%367, %$63] ; # Cld
; # (gt0 @)
  %384 = icmp sgt i64 %372, 0
  br i1 %384, label %$69, label %$68
$69:
  %385 = phi i64 [%379, %$66] ; # Ms
  %386 = phi i64 [%380, %$66] ; # Tim
  %387 = phi i64 [%381, %$66] ; # Nfds
  %388 = phi i64 [%382, %$66] ; # Dly
  %389 = phi i8* [%383, %$66] ; # Cld
; # (cond ((=0 (val (i64* Pn))) (when (== (Cld: pid) (val $Talking)) ...
; # (i64* Pn)
  %390 = bitcast i32* %28 to i64*
; # (val (i64* Pn))
  %391 = load i64, i64* %390
; # (=0 (val (i64* Pn)))
  %392 = icmp eq i64 %391, 0
  br i1 %392, label %$72, label %$71
$72:
  %393 = phi i64 [%385, %$69] ; # Ms
  %394 = phi i64 [%386, %$69] ; # Tim
  %395 = phi i64 [%387, %$69] ; # Nfds
  %396 = phi i64 [%388, %$69] ; # Dly
  %397 = phi i8* [%389, %$69] ; # Cld
; # (when (== (Cld: pid) (val $Talking)) (set $Talking 0))
; # (Cld: pid)
  %398 = getelementptr i8, i8* %349, i32 24
  %399 = bitcast i8* %398 to i32*
  %400 = load i32, i32* %399
; # (val $Talking)
  %401 = load i32, i32* @$Talking
; # (== (Cld: pid) (val $Talking))
  %402 = icmp eq i32 %400, %401
  br i1 %402, label %$73, label %$74
$73:
  %403 = phi i64 [%393, %$72] ; # Ms
  %404 = phi i64 [%394, %$72] ; # Tim
  %405 = phi i64 [%395, %$72] ; # Nfds
  %406 = phi i64 [%396, %$72] ; # Dly
  %407 = phi i8* [%397, %$72] ; # Cld
; # (set $Talking 0)
  store i32 0, i32* @$Talking
  br label %$74
$74:
  %408 = phi i64 [%393, %$72], [%403, %$73] ; # Ms
  %409 = phi i64 [%394, %$72], [%404, %$73] ; # Tim
  %410 = phi i64 [%395, %$72], [%405, %$73] ; # Nfds
  %411 = phi i64 [%396, %$72], [%406, %$73] ; # Dly
  %412 = phi i8* [%397, %$72], [%407, %$73] ; # Cld
  br label %$70
$71:
  %413 = phi i64 [%385, %$69] ; # Ms
  %414 = phi i64 [%386, %$69] ; # Tim
  %415 = phi i64 [%387, %$69] ; # Nfds
  %416 = phi i64 [%388, %$69] ; # Dly
  %417 = phi i8* [%389, %$69] ; # Cld
; # (Cld: hear)
  %418 = getelementptr i8, i8* %349, i32 28
  %419 = bitcast i8* %418 to i32*
  %420 = load i32, i32* %419
; # (val 1 Pn)
  %421 = getelementptr i32, i32* %28, i32 0
  %422 = load i32, i32* %421
; # (i64 (val 1 Pn))
  %423 = sext i32 %422 to i64
; # (rdBytes (Cld: hear) Buf (i64 (val 1 Pn)))
  %424 = call i1 @rdBytes(i32 %420, i8* %27, i64 %423)
  br i1 %424, label %$76, label %$75
$76:
  %425 = phi i64 [%413, %$71] ; # Ms
  %426 = phi i64 [%414, %$71] ; # Tim
  %427 = phi i64 [%415, %$71] ; # Nfds
  %428 = phi i64 [%416, %$71] ; # Dly
  %429 = phi i8* [%417, %$71] ; # Cld
; # (let (Cld2 (val $Child) <Cld2 (ofs Cld2 (* (val $Children) (child...
; # (val $Child)
  %430 = load i8*, i8** @$Child
; # (val $Children)
  %431 = load i64, i64* @$Children
; # (* (val $Children) (child T))
  %432 = mul i64 %431, 36
; # (ofs Cld2 (* (val $Children) (child T)))
  %433 = getelementptr i8, i8* %430, i64 %432
; # (until (== Cld2 <Cld2) (let Cld2: (child Cld2) (when (and (<> Cld...
  br label %$77
$77:
  %434 = phi i64 [%425, %$76], [%499, %$86] ; # Ms
  %435 = phi i64 [%426, %$76], [%500, %$86] ; # Tim
  %436 = phi i64 [%427, %$76], [%501, %$86] ; # Nfds
  %437 = phi i64 [%428, %$76], [%502, %$86] ; # Dly
  %438 = phi i8* [%429, %$76], [%503, %$86] ; # Cld
  %439 = phi i8* [%430, %$76], [%505, %$86] ; # Cld2
; # (== Cld2 <Cld2)
  %440 = icmp eq i8* %439, %433
  br i1 %440, label %$79, label %$78
$78:
  %441 = phi i64 [%434, %$77] ; # Ms
  %442 = phi i64 [%435, %$77] ; # Tim
  %443 = phi i64 [%436, %$77] ; # Nfds
  %444 = phi i64 [%437, %$77] ; # Dly
  %445 = phi i8* [%438, %$77] ; # Cld
  %446 = phi i8* [%439, %$77] ; # Cld2
; # (let Cld2: (child Cld2) (when (and (<> Cld Cld2) (Cld2: pid) (or ...
; # (when (and (<> Cld Cld2) (Cld2: pid) (or (=0 (val Pn)) (== @ (Cld...
; # (and (<> Cld Cld2) (Cld2: pid) (or (=0 (val Pn)) (== @ (Cld2: pid...
; # (<> Cld Cld2)
  %447 = icmp ne i8* %445, %446
  br i1 %447, label %$81, label %$80
$81:
  %448 = phi i64 [%441, %$78] ; # Ms
  %449 = phi i64 [%442, %$78] ; # Tim
  %450 = phi i64 [%443, %$78] ; # Nfds
  %451 = phi i64 [%444, %$78] ; # Dly
  %452 = phi i8* [%445, %$78] ; # Cld
  %453 = phi i8* [%446, %$78] ; # Cld2
; # (Cld2: pid)
  %454 = getelementptr i8, i8* %446, i32 24
  %455 = bitcast i8* %454 to i32*
  %456 = load i32, i32* %455
  %457 = icmp ne i32 %456, 0
  br i1 %457, label %$82, label %$80
$82:
  %458 = phi i64 [%448, %$81] ; # Ms
  %459 = phi i64 [%449, %$81] ; # Tim
  %460 = phi i64 [%450, %$81] ; # Nfds
  %461 = phi i64 [%451, %$81] ; # Dly
  %462 = phi i8* [%452, %$81] ; # Cld
  %463 = phi i8* [%453, %$81] ; # Cld2
; # (or (=0 (val Pn)) (== @ (Cld2: pid)))
; # (val Pn)
  %464 = load i32, i32* %28
; # (=0 (val Pn))
  %465 = icmp eq i32 %464, 0
  br i1 %465, label %$83, label %$84
$84:
  %466 = phi i64 [%458, %$82] ; # Ms
  %467 = phi i64 [%459, %$82] ; # Tim
  %468 = phi i64 [%460, %$82] ; # Nfds
  %469 = phi i64 [%461, %$82] ; # Dly
  %470 = phi i8* [%462, %$82] ; # Cld
  %471 = phi i8* [%463, %$82] ; # Cld2
; # (Cld2: pid)
  %472 = getelementptr i8, i8* %446, i32 24
  %473 = bitcast i8* %472 to i32*
  %474 = load i32, i32* %473
; # (== @ (Cld2: pid))
  %475 = icmp eq i32 %464, %474
  br label %$83
$83:
  %476 = phi i64 [%458, %$82], [%466, %$84] ; # Ms
  %477 = phi i64 [%459, %$82], [%467, %$84] ; # Tim
  %478 = phi i64 [%460, %$82], [%468, %$84] ; # Nfds
  %479 = phi i64 [%461, %$82], [%469, %$84] ; # Dly
  %480 = phi i8* [%462, %$82], [%470, %$84] ; # Cld
  %481 = phi i8* [%463, %$82], [%471, %$84] ; # Cld2
  %482 = phi i1 [1, %$82], [%475, %$84] ; # ->
  br label %$80
$80:
  %483 = phi i64 [%441, %$78], [%448, %$81], [%476, %$83] ; # Ms
  %484 = phi i64 [%442, %$78], [%449, %$81], [%477, %$83] ; # Tim
  %485 = phi i64 [%443, %$78], [%450, %$81], [%478, %$83] ; # Nfds
  %486 = phi i64 [%444, %$78], [%451, %$81], [%479, %$83] ; # Dly
  %487 = phi i8* [%445, %$78], [%452, %$81], [%480, %$83] ; # Cld
  %488 = phi i8* [%446, %$78], [%453, %$81], [%481, %$83] ; # Cld2
  %489 = phi i1 [0, %$78], [0, %$81], [%482, %$83] ; # ->
  br i1 %489, label %$85, label %$86
$85:
  %490 = phi i64 [%483, %$80] ; # Ms
  %491 = phi i64 [%484, %$80] ; # Tim
  %492 = phi i64 [%485, %$80] ; # Nfds
  %493 = phi i64 [%486, %$80] ; # Dly
  %494 = phi i8* [%487, %$80] ; # Cld
  %495 = phi i8* [%488, %$80] ; # Cld2
; # (val 2 Pn)
  %496 = getelementptr i32, i32* %28, i32 1
  %497 = load i32, i32* %496
; # (i64 (val 2 Pn))
  %498 = sext i32 %497 to i64
; # (wrChild Cld2 Buf (i64 (val 2 Pn)))
  call void @wrChild(i8* %495, i8* %27, i64 %498)
  br label %$86
$86:
  %499 = phi i64 [%483, %$80], [%490, %$85] ; # Ms
  %500 = phi i64 [%484, %$80], [%491, %$85] ; # Tim
  %501 = phi i64 [%485, %$80], [%492, %$85] ; # Nfds
  %502 = phi i64 [%486, %$80], [%493, %$85] ; # Dly
  %503 = phi i8* [%487, %$80], [%494, %$85] ; # Cld
  %504 = phi i8* [%488, %$80], [%495, %$85] ; # Cld2
; # (ofs Cld2 (child T))
  %505 = getelementptr i8, i8* %504, i32 36
  br label %$77
$79:
  %506 = phi i64 [%434, %$77] ; # Ms
  %507 = phi i64 [%435, %$77] ; # Tim
  %508 = phi i64 [%436, %$77] ; # Nfds
  %509 = phi i64 [%437, %$77] ; # Dly
  %510 = phi i8* [%438, %$77] ; # Cld
  %511 = phi i8* [%439, %$77] ; # Cld2
  br label %$70
$75:
  %512 = phi i64 [%413, %$71] ; # Ms
  %513 = phi i64 [%414, %$71] ; # Tim
  %514 = phi i64 [%415, %$71] ; # Nfds
  %515 = phi i64 [%416, %$71] ; # Dly
  %516 = phi i8* [%417, %$71] ; # Cld
; # (clsChild Cld)
  call void @clsChild(i8* %516)
; # (goto 1)
  br label %$-1
$70:
  %517 = phi i64 [%408, %$74], [%506, %$79] ; # Ms
  %518 = phi i64 [%409, %$74], [%507, %$79] ; # Tim
  %519 = phi i64 [%410, %$74], [%508, %$79] ; # Nfds
  %520 = phi i64 [%411, %$74], [%509, %$79] ; # Dly
  %521 = phi i8* [%412, %$74], [%510, %$79] ; # Cld
  br label %$65
$68:
  %522 = phi i64 [%379, %$66] ; # Ms
  %523 = phi i64 [%380, %$66] ; # Tim
  %524 = phi i64 [%381, %$66] ; # Nfds
  %525 = phi i64 [%382, %$66] ; # Dly
  %526 = phi i8* [%383, %$66] ; # Cld
  br label %$65
$65:
  %527 = phi i64 [%517, %$70], [%522, %$68] ; # Ms
  %528 = phi i64 [%518, %$70], [%523, %$68] ; # Tim
  %529 = phi i64 [%519, %$70], [%524, %$68] ; # Nfds
  %530 = phi i64 [%520, %$70], [%525, %$68] ; # Dly
  %531 = phi i8* [%521, %$70], [%526, %$68] ; # Cld
  br label %$64
$64:
  %532 = phi i64 [%354, %$61], [%527, %$65] ; # Ms
  %533 = phi i64 [%355, %$61], [%528, %$65] ; # Tim
  %534 = phi i64 [%356, %$61], [%529, %$65] ; # Nfds
  %535 = phi i64 [%357, %$61], [%530, %$65] ; # Dly
  %536 = phi i8* [%358, %$61], [%531, %$65] ; # Cld
; # (when (readyOut Poll (Cld: tell)) (let N (+ (i64 (val (i32* (Cld:...
; # (Cld: tell)
  %537 = getelementptr i8, i8* %349, i32 32
  %538 = bitcast i8* %537 to i32*
  %539 = load i32, i32* %538
; # (readyOut Poll (Cld: tell))
  %540 = call i1 @readyOut(i64* %53, i32 %539)
  br i1 %540, label %$87, label %$88
$87:
  %541 = phi i64 [%532, %$64] ; # Ms
  %542 = phi i64 [%533, %$64] ; # Tim
  %543 = phi i64 [%534, %$64] ; # Nfds
  %544 = phi i64 [%535, %$64] ; # Dly
  %545 = phi i8* [%536, %$64] ; # Cld
; # (let N (+ (i64 (val (i32* (Cld: buf)))) (Cld: ofs)) (ifn (wrBytes...
; # (Cld: buf)
  %546 = bitcast i8* %349 to i8**
  %547 = load i8*, i8** %546
; # (i32* (Cld: buf))
  %548 = bitcast i8* %547 to i32*
; # (val (i32* (Cld: buf)))
  %549 = load i32, i32* %548
; # (i64 (val (i32* (Cld: buf))))
  %550 = sext i32 %549 to i64
; # (Cld: ofs)
  %551 = getelementptr i8, i8* %349, i32 8
  %552 = bitcast i8* %551 to i64*
  %553 = load i64, i64* %552
; # (+ (i64 (val (i32* (Cld: buf)))) (Cld: ofs))
  %554 = add i64 %550, %553
; # (ifn (wrBytes (Cld: tell) (ofs (Cld: buf) (+ (Cld: ofs) 4)) N) (c...
; # (Cld: tell)
  %555 = getelementptr i8, i8* %349, i32 32
  %556 = bitcast i8* %555 to i32*
  %557 = load i32, i32* %556
; # (Cld: buf)
  %558 = bitcast i8* %349 to i8**
  %559 = load i8*, i8** %558
; # (Cld: ofs)
  %560 = getelementptr i8, i8* %349, i32 8
  %561 = bitcast i8* %560 to i64*
  %562 = load i64, i64* %561
; # (+ (Cld: ofs) 4)
  %563 = add i64 %562, 4
; # (ofs (Cld: buf) (+ (Cld: ofs) 4))
  %564 = getelementptr i8, i8* %559, i64 %563
; # (wrBytes (Cld: tell) (ofs (Cld: buf) (+ (Cld: ofs) 4)) N)
  %565 = call i1 @wrBytes(i32 %557, i8* %564, i64 %554)
  br i1 %565, label %$90, label %$89
$89:
  %566 = phi i64 [%541, %$87] ; # Ms
  %567 = phi i64 [%542, %$87] ; # Tim
  %568 = phi i64 [%543, %$87] ; # Nfds
  %569 = phi i64 [%544, %$87] ; # Dly
  %570 = phi i8* [%545, %$87] ; # Cld
; # (clsChild Cld)
  call void @clsChild(i8* %570)
  br label %$91
$90:
  %571 = phi i64 [%541, %$87] ; # Ms
  %572 = phi i64 [%542, %$87] ; # Tim
  %573 = phi i64 [%543, %$87] ; # Nfds
  %574 = phi i64 [%544, %$87] ; # Dly
  %575 = phi i8* [%545, %$87] ; # Cld
; # (Cld: ofs (+ (Cld: ofs) (Cld: cnt) N))
  %576 = getelementptr i8, i8* %349, i32 8
  %577 = bitcast i8* %576 to i64*
  %578 = getelementptr i8, i8* %349, i32 8
  %579 = bitcast i8* %578 to i64*
  %580 = load i64, i64* %579
  %581 = getelementptr i8, i8* %349, i32 16
  %582 = bitcast i8* %581 to i64*
  %583 = load i64, i64* %582
  %584 = add i64 %580, %583
  %585 = add i64 %584, %554
  store i64 %585, i64* %577
; # (when (>= (* 2 (Cld: ofs)) (Cld: cnt)) (when (Cld: cnt (- (Cld: c...
; # (Cld: ofs)
  %586 = getelementptr i8, i8* %349, i32 8
  %587 = bitcast i8* %586 to i64*
  %588 = load i64, i64* %587
; # (* 2 (Cld: ofs))
  %589 = mul i64 2, %588
; # (Cld: cnt)
  %590 = getelementptr i8, i8* %349, i32 16
  %591 = bitcast i8* %590 to i64*
  %592 = load i64, i64* %591
; # (>= (* 2 (Cld: ofs)) (Cld: cnt))
  %593 = icmp uge i64 %589, %592
  br i1 %593, label %$92, label %$93
$92:
  %594 = phi i64 [%571, %$90] ; # Ms
  %595 = phi i64 [%572, %$90] ; # Tim
  %596 = phi i64 [%573, %$90] ; # Nfds
  %597 = phi i64 [%574, %$90] ; # Dly
  %598 = phi i8* [%575, %$90] ; # Cld
; # (when (Cld: cnt (- (Cld: cnt) (Cld: ofs))) (memcpy (Cld: buf) (of...
; # (Cld: cnt (- (Cld: cnt) (Cld: ofs)))
  %599 = getelementptr i8, i8* %349, i32 16
  %600 = bitcast i8* %599 to i64*
  %601 = getelementptr i8, i8* %349, i32 16
  %602 = bitcast i8* %601 to i64*
  %603 = load i64, i64* %602
  %604 = getelementptr i8, i8* %349, i32 8
  %605 = bitcast i8* %604 to i64*
  %606 = load i64, i64* %605
  %607 = sub i64 %603, %606
  store i64 %607, i64* %600
  %608 = icmp ne i64 %607, 0
  br i1 %608, label %$94, label %$95
$94:
  %609 = phi i64 [%594, %$92] ; # Ms
  %610 = phi i64 [%595, %$92] ; # Tim
  %611 = phi i64 [%596, %$92] ; # Nfds
  %612 = phi i64 [%597, %$92] ; # Dly
  %613 = phi i8* [%598, %$92] ; # Cld
; # (Cld: buf)
  %614 = bitcast i8* %349 to i8**
  %615 = load i8*, i8** %614
; # (Cld: buf)
  %616 = bitcast i8* %349 to i8**
  %617 = load i8*, i8** %616
; # (Cld: ofs)
  %618 = getelementptr i8, i8* %349, i32 8
  %619 = bitcast i8* %618 to i64*
  %620 = load i64, i64* %619
; # (ofs (Cld: buf) (Cld: ofs))
  %621 = getelementptr i8, i8* %617, i64 %620
; # (Cld: cnt)
  %622 = getelementptr i8, i8* %349, i32 16
  %623 = bitcast i8* %622 to i64*
  %624 = load i64, i64* %623
; # (memcpy (Cld: buf) (ofs (Cld: buf) (Cld: ofs)) (Cld: cnt))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %615, i8* %621, i64 %624, i1 0)
; # (Cld: buf (alloc (Cld: buf) (Cld: cnt)))
  %625 = bitcast i8* %349 to i8**
  %626 = bitcast i8* %349 to i8**
  %627 = load i8*, i8** %626
  %628 = getelementptr i8, i8* %349, i32 16
  %629 = bitcast i8* %628 to i64*
  %630 = load i64, i64* %629
  %631 = call i8* @alloc(i8* %627, i64 %630)
  store i8* %631, i8** %625
  br label %$95
$95:
  %632 = phi i64 [%594, %$92], [%609, %$94] ; # Ms
  %633 = phi i64 [%595, %$92], [%610, %$94] ; # Tim
  %634 = phi i64 [%596, %$92], [%611, %$94] ; # Nfds
  %635 = phi i64 [%597, %$92], [%612, %$94] ; # Dly
  %636 = phi i8* [%598, %$92], [%613, %$94] ; # Cld
; # (Cld: ofs 0)
  %637 = getelementptr i8, i8* %349, i32 8
  %638 = bitcast i8* %637 to i64*
  store i64 0, i64* %638
  br label %$93
$93:
  %639 = phi i64 [%571, %$90], [%632, %$95] ; # Ms
  %640 = phi i64 [%572, %$90], [%633, %$95] ; # Tim
  %641 = phi i64 [%573, %$90], [%634, %$95] ; # Nfds
  %642 = phi i64 [%574, %$90], [%635, %$95] ; # Dly
  %643 = phi i8* [%575, %$90], [%636, %$95] ; # Cld
  br label %$91
$91:
  %644 = phi i64 [%566, %$89], [%639, %$93] ; # Ms
  %645 = phi i64 [%567, %$89], [%640, %$93] ; # Tim
  %646 = phi i64 [%568, %$89], [%641, %$93] ; # Nfds
  %647 = phi i64 [%569, %$89], [%642, %$93] ; # Dly
  %648 = phi i8* [%570, %$89], [%643, %$93] ; # Cld
  br label %$88
$88:
  %649 = phi i64 [%532, %$64], [%644, %$91] ; # Ms
  %650 = phi i64 [%533, %$64], [%645, %$91] ; # Tim
  %651 = phi i64 [%534, %$64], [%646, %$91] ; # Nfds
  %652 = phi i64 [%535, %$64], [%647, %$91] ; # Dly
  %653 = phi i8* [%536, %$64], [%648, %$91] ; # Cld
  br label %$62
$62:
  %654 = phi i64 [%345, %$59], [%649, %$88] ; # Ms
  %655 = phi i64 [%346, %$59], [%650, %$88] ; # Tim
  %656 = phi i64 [%347, %$59], [%651, %$88] ; # Nfds
  %657 = phi i64 [%348, %$59], [%652, %$88] ; # Dly
  %658 = phi i8* [%349, %$59], [%653, %$88] ; # Cld
; # (: 1 (setq Cld (ofs Cld (child T))))
  br label %$-1
$-1:
  %659 = phi i64 [%374, %$67], [%512, %$75], [%654, %$62] ; # Ms
  %660 = phi i64 [%375, %$67], [%513, %$75], [%655, %$62] ; # Tim
  %661 = phi i64 [%376, %$67], [%514, %$75], [%656, %$62] ; # Nfds
  %662 = phi i64 [%377, %$67], [%515, %$75], [%657, %$62] ; # Dly
  %663 = phi i8* [%378, %$67], [%516, %$75], [%658, %$62] ; # Cld
; # (ofs Cld (child T))
  %664 = getelementptr i8, i8* %663, i32 36
  br label %$58
$60:
  %665 = phi i64 [%339, %$58] ; # Ms
  %666 = phi i64 [%340, %$58] ; # Tim
  %667 = phi i64 [%341, %$58] ; # Nfds
  %668 = phi i64 [%342, %$58] ; # Dly
  %669 = phi i8* [%343, %$58] ; # Cld
; # (when (and (=0 (val $Talking)) (readyIn Poll (val $Spkr)) (gt0 (r...
; # (and (=0 (val $Talking)) (readyIn Poll (val $Spkr)) (gt0 (rdBytes...
; # (val $Talking)
  %670 = load i32, i32* @$Talking
; # (=0 (val $Talking))
  %671 = icmp eq i32 %670, 0
  br i1 %671, label %$97, label %$96
$97:
  %672 = phi i64 [%665, %$60] ; # Ms
  %673 = phi i64 [%666, %$60] ; # Tim
  %674 = phi i64 [%667, %$60] ; # Nfds
  %675 = phi i64 [%668, %$60] ; # Dly
; # (val $Spkr)
  %676 = load i32, i32* @$Spkr
; # (readyIn Poll (val $Spkr))
  %677 = call i1 @readyIn(i64* %53, i32 %676)
  br i1 %677, label %$98, label %$96
$98:
  %678 = phi i64 [%672, %$97] ; # Ms
  %679 = phi i64 [%673, %$97] ; # Tim
  %680 = phi i64 [%674, %$97] ; # Nfds
  %681 = phi i64 [%675, %$97] ; # Dly
; # (val $Spkr)
  %682 = load i32, i32* @$Spkr
; # (i8* Pn)
  %683 = bitcast i32* %28 to i8*
; # (rdBytesNb (val $Spkr) (i8* Pn) 4)
  %684 = call i64 @rdBytesNb(i32 %682, i8* %683, i64 4)
; # (gt0 (rdBytesNb (val $Spkr) (i8* Pn) 4))
  %685 = icmp sgt i64 %684, 0
  br label %$96
$96:
  %686 = phi i64 [%665, %$60], [%672, %$97], [%678, %$98] ; # Ms
  %687 = phi i64 [%666, %$60], [%673, %$97], [%679, %$98] ; # Tim
  %688 = phi i64 [%667, %$60], [%674, %$97], [%680, %$98] ; # Nfds
  %689 = phi i64 [%668, %$60], [%675, %$97], [%681, %$98] ; # Dly
  %690 = phi i1 [0, %$60], [0, %$97], [%685, %$98] ; # ->
  br i1 %690, label %$99, label %$100
$99:
  %691 = phi i64 [%686, %$96] ; # Ms
  %692 = phi i64 [%687, %$96] ; # Tim
  %693 = phi i64 [%688, %$96] ; # Nfds
  %694 = phi i64 [%689, %$96] ; # Dly
; # (let Cld (ofs (val $Child) (* (val Pn) (child T))) (when ((child ...
; # (val $Child)
  %695 = load i8*, i8** @$Child
; # (val Pn)
  %696 = load i32, i32* %28
; # (* (val Pn) (child T))
  %697 = mul i32 %696, 36
; # (ofs (val $Child) (* (val Pn) (child T)))
  %698 = getelementptr i8, i8* %695, i32 %697
; # (when ((child Cld) pid) (set $Talking @) (wrChild Cld $TBuf 2))
; # ((child Cld) pid)
  %699 = getelementptr i8, i8* %698, i32 24
  %700 = bitcast i8* %699 to i32*
  %701 = load i32, i32* %700
  %702 = icmp ne i32 %701, 0
  br i1 %702, label %$101, label %$102
$101:
  %703 = phi i64 [%691, %$99] ; # Ms
  %704 = phi i64 [%692, %$99] ; # Tim
  %705 = phi i64 [%693, %$99] ; # Nfds
  %706 = phi i64 [%694, %$99] ; # Dly
; # (set $Talking @)
  store i32 %701, i32* @$Talking
; # (wrChild Cld $TBuf 2)
  call void @wrChild(i8* %698, i8* bitcast ([2 x i8]* @$TBuf to i8*), i64 2)
  br label %$102
$102:
  %707 = phi i64 [%691, %$99], [%703, %$101] ; # Ms
  %708 = phi i64 [%692, %$99], [%704, %$101] ; # Tim
  %709 = phi i64 [%693, %$99], [%705, %$101] ; # Nfds
  %710 = phi i64 [%694, %$99], [%706, %$101] ; # Dly
  br label %$100
$100:
  %711 = phi i64 [%686, %$96], [%707, %$102] ; # Ms
  %712 = phi i64 [%687, %$96], [%708, %$102] ; # Tim
  %713 = phi i64 [%688, %$96], [%709, %$102] ; # Nfds
  %714 = phi i64 [%689, %$96], [%710, %$102] ; # Dly
; # (set $Protect (dec (val $Protect)))
; # (val $Protect)
  %715 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (dec (val $Protect))
  %716 = sub i32 %715, 1
  store i32 %716, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  br label %$57
$57:
  %717 = phi i64 [%321, %$51], [%711, %$100] ; # Ms
  %718 = phi i64 [%322, %$51], [%712, %$100] ; # Tim
  %719 = phi i64 [%323, %$51], [%713, %$100] ; # Nfds
  %720 = phi i64 [%324, %$51], [%714, %$100] ; # Dly
; # (let N (val $Hear) (when (and N (<> N Fd) (readyIn Poll N)) (cond...
; # (val $Hear)
  %721 = load i32, i32* @$Hear
; # (when (and N (<> N Fd) (readyIn Poll N)) (cond ((=0 (rdHear)) (cl...
; # (and N (<> N Fd) (readyIn Poll N))
  %722 = icmp ne i32 %721, 0
  br i1 %722, label %$104, label %$103
$104:
  %723 = phi i64 [%717, %$57] ; # Ms
  %724 = phi i64 [%718, %$57] ; # Tim
  %725 = phi i64 [%719, %$57] ; # Nfds
  %726 = phi i64 [%720, %$57] ; # Dly
; # (<> N Fd)
  %727 = icmp ne i32 %721, %1
  br i1 %727, label %$105, label %$103
$105:
  %728 = phi i64 [%723, %$104] ; # Ms
  %729 = phi i64 [%724, %$104] ; # Tim
  %730 = phi i64 [%725, %$104] ; # Nfds
  %731 = phi i64 [%726, %$104] ; # Dly
; # (readyIn Poll N)
  %732 = call i1 @readyIn(i64* %53, i32 %721)
  br label %$103
$103:
  %733 = phi i64 [%717, %$57], [%723, %$104], [%728, %$105] ; # Ms
  %734 = phi i64 [%718, %$57], [%724, %$104], [%729, %$105] ; # Tim
  %735 = phi i64 [%719, %$57], [%725, %$104], [%730, %$105] ; # Nfds
  %736 = phi i64 [%720, %$57], [%726, %$104], [%731, %$105] ; # Dly
  %737 = phi i1 [0, %$57], [0, %$104], [%732, %$105] ; # ->
  br i1 %737, label %$106, label %$107
$106:
  %738 = phi i64 [%733, %$103] ; # Ms
  %739 = phi i64 [%734, %$103] ; # Tim
  %740 = phi i64 [%735, %$103] ; # Nfds
  %741 = phi i64 [%736, %$103] ; # Dly
; # (cond ((=0 (rdHear)) (close N) (closeInFile N) (closeOutFile N) (...
; # (rdHear)
  %742 = call i64 @rdHear()
; # (=0 (rdHear))
  %743 = icmp eq i64 %742, 0
  br i1 %743, label %$110, label %$109
$110:
  %744 = phi i64 [%738, %$106] ; # Ms
  %745 = phi i64 [%739, %$106] ; # Tim
  %746 = phi i64 [%740, %$106] ; # Nfds
  %747 = phi i64 [%741, %$106] ; # Dly
; # (close N)
  %748 = call i32 @close(i32 %721)
; # (closeInFile N)
  call void @closeInFile(i32 %721)
; # (closeOutFile N)
  call void @closeOutFile(i32 %721)
; # (set $Hear 0)
  store i32 0, i32* @$Hear
  br label %$108
$109:
  %749 = phi i64 [%738, %$106] ; # Ms
  %750 = phi i64 [%739, %$106] ; # Tim
  %751 = phi i64 [%740, %$106] ; # Nfds
  %752 = phi i64 [%741, %$106] ; # Dly
; # (t? @)
  %753 = icmp eq i64 %742, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %753, label %$112, label %$111
$112:
  %754 = phi i64 [%749, %$109] ; # Ms
  %755 = phi i64 [%750, %$109] ; # Tim
  %756 = phi i64 [%751, %$109] ; # Nfds
  %757 = phi i64 [%752, %$109] ; # Dly
; # (set $Sync YES)
  store i1 1, i1* @$Sync
  br label %$108
$111:
  %758 = phi i64 [%749, %$109] ; # Ms
  %759 = phi i64 [%750, %$109] ; # Tim
  %760 = phi i64 [%751, %$109] ; # Nfds
  %761 = phi i64 [%752, %$109] ; # Dly
; # (save @ (evList @))
  %762 = alloca i64, i64 2, align 16
  %763 = ptrtoint i64* %762 to i64
  %764 = inttoptr i64 %763 to i64*
  store i64 %742, i64* %764
  %765 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %766 = load i64, i64* %765
  %767 = inttoptr i64 %763 to i64*
  %768 = getelementptr i64, i64* %767, i32 1
  store i64 %766, i64* %768
  %769 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %763, i64* %769
; # (evList @)
  %770 = call i64 @evList(i64 %742)
  %771 = inttoptr i64 %763 to i64*
  %772 = getelementptr i64, i64* %771, i32 1
  %773 = load i64, i64* %772
  %774 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %773, i64* %774
  br label %$108
$108:
  %775 = phi i64 [%744, %$110], [%754, %$112], [%758, %$111] ; # Ms
  %776 = phi i64 [%745, %$110], [%755, %$112], [%759, %$111] ; # Tim
  %777 = phi i64 [%746, %$110], [%756, %$112], [%760, %$111] ; # Nfds
  %778 = phi i64 [%747, %$110], [%757, %$112], [%761, %$111] ; # Dly
  br label %$107
$107:
  %779 = phi i64 [%733, %$103], [%775, %$108] ; # Ms
  %780 = phi i64 [%734, %$103], [%776, %$108] ; # Tim
  %781 = phi i64 [%735, %$103], [%777, %$108] ; # Nfds
  %782 = phi i64 [%736, %$103], [%778, %$108] ; # Dly
; # (let R (val Run) (while (pair R) (let X (++ R) (unless (memq X Ta...
; # (val Run)
  %783 = inttoptr i64 %19 to i64*
  %784 = load i64, i64* %783
; # (while (pair R) (let X (++ R) (unless (memq X Task) (cond ((sign?...
  br label %$113
$113:
  %785 = phi i64 [%779, %$107], [%958, %$123] ; # Ms
  %786 = phi i64 [%780, %$107], [%959, %$123] ; # Tim
  %787 = phi i64 [%781, %$107], [%960, %$123] ; # Nfds
  %788 = phi i64 [%782, %$107], [%961, %$123] ; # Dly
  %789 = phi i64 [%784, %$107], [%962, %$123] ; # R
; # (pair R)
  %790 = and i64 %789, 15
  %791 = icmp eq i64 %790, 0
  br i1 %791, label %$114, label %$115
$114:
  %792 = phi i64 [%785, %$113] ; # Ms
  %793 = phi i64 [%786, %$113] ; # Tim
  %794 = phi i64 [%787, %$113] ; # Nfds
  %795 = phi i64 [%788, %$113] ; # Dly
  %796 = phi i64 [%789, %$113] ; # R
; # (let X (++ R) (unless (memq X Task) (cond ((sign? (car X)) (let Y...
; # (++ R)
  %797 = inttoptr i64 %796 to i64*
  %798 = load i64, i64* %797
  %799 = getelementptr i64, i64* %797, i32 1
  %800 = load i64, i64* %799
; # (unless (memq X Task) (cond ((sign? (car X)) (let Y (cdr X) (if (...
; # (memq X Task)
  br label %$116
$116:
  %801 = phi i64 [%14, %$114], [%813, %$120] ; # L
  %802 = and i64 %801, 15
  %803 = icmp ne i64 %802, 0
  br i1 %803, label %$119, label %$117
$119:
  %804 = phi i64 [%801, %$116] ; # L
  br label %$118
$117:
  %805 = phi i64 [%801, %$116] ; # L
  %806 = inttoptr i64 %805 to i64*
  %807 = load i64, i64* %806
  %808 = icmp eq i64 %798, %807
  br i1 %808, label %$121, label %$120
$121:
  %809 = phi i64 [%805, %$117] ; # L
  br label %$118
$120:
  %810 = phi i64 [%805, %$117] ; # L
  %811 = inttoptr i64 %810 to i64*
  %812 = getelementptr i64, i64* %811, i32 1
  %813 = load i64, i64* %812
  br label %$116
$118:
  %814 = phi i64 [%804, %$119], [%809, %$121] ; # L
  %815 = phi i1 [0, %$119], [1, %$121] ; # ->
  br i1 %815, label %$123, label %$122
$122:
  %816 = phi i64 [%792, %$118] ; # Ms
  %817 = phi i64 [%793, %$118] ; # Tim
  %818 = phi i64 [%794, %$118] ; # Nfds
  %819 = phi i64 [%795, %$118] ; # Dly
  %820 = phi i64 [%800, %$118] ; # R
; # (cond ((sign? (car X)) (let Y (cdr X) (if (gt0 (- (int (car Y)) D...
; # (car X)
  %821 = inttoptr i64 %798 to i64*
  %822 = load i64, i64* %821
; # (sign? (car X))
  %823 = and i64 %822, 8
  %824 = icmp ne i64 %823, 0
  br i1 %824, label %$126, label %$125
$126:
  %825 = phi i64 [%816, %$122] ; # Ms
  %826 = phi i64 [%817, %$122] ; # Tim
  %827 = phi i64 [%818, %$122] ; # Nfds
  %828 = phi i64 [%819, %$122] ; # Dly
  %829 = phi i64 [%820, %$122] ; # R
; # (let Y (cdr X) (if (gt0 (- (int (car Y)) Dif)) (set Y (sign (cnt ...
; # (cdr X)
  %830 = inttoptr i64 %798 to i64*
  %831 = getelementptr i64, i64* %830, i32 1
  %832 = load i64, i64* %831
; # (if (gt0 (- (int (car Y)) Dif)) (set Y (sign (cnt @))) (let V (ca...
; # (car Y)
  %833 = inttoptr i64 %832 to i64*
  %834 = load i64, i64* %833
; # (int (car Y))
  %835 = lshr i64 %834, 4
; # (- (int (car Y)) Dif)
  %836 = sub i64 %835, %326
; # (gt0 (- (int (car Y)) Dif))
  %837 = icmp sgt i64 %836, 0
  br i1 %837, label %$127, label %$128
$127:
  %838 = phi i64 [%825, %$126] ; # Ms
  %839 = phi i64 [%826, %$126] ; # Tim
  %840 = phi i64 [%827, %$126] ; # Nfds
  %841 = phi i64 [%828, %$126] ; # Dly
  %842 = phi i64 [%829, %$126] ; # R
; # (set Y (sign (cnt @)))
; # (cnt @)
  %843 = shl i64 %836, 4
  %844 = or i64 %843, 2
; # (sign (cnt @))
  %845 = or i64 %844, 8
  %846 = inttoptr i64 %832 to i64*
  store i64 %845, i64* %846
  br label %$129
$128:
  %847 = phi i64 [%825, %$126] ; # Ms
  %848 = phi i64 [%826, %$126] ; # Tim
  %849 = phi i64 [%827, %$126] ; # Nfds
  %850 = phi i64 [%828, %$126] ; # Dly
  %851 = phi i64 [%829, %$126] ; # R
; # (let V (car X) (set Y (pos V) $At V) (run (cdr Y)))
; # (car X)
  %852 = inttoptr i64 %798 to i64*
  %853 = load i64, i64* %852
; # (set Y (pos V) $At V)
; # (pos V)
  %854 = and i64 %853, -9
  %855 = inttoptr i64 %832 to i64*
  store i64 %854, i64* %855
  %856 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %853, i64* %856
; # (cdr Y)
  %857 = inttoptr i64 %832 to i64*
  %858 = getelementptr i64, i64* %857, i32 1
  %859 = load i64, i64* %858
; # (run (cdr Y))
  br label %$130
$130:
  %860 = phi i64 [%859, %$128], [%882, %$139] ; # Prg
  %861 = inttoptr i64 %860 to i64*
  %862 = load i64, i64* %861
  %863 = getelementptr i64, i64* %861, i32 1
  %864 = load i64, i64* %863
  %865 = and i64 %864, 15
  %866 = icmp ne i64 %865, 0
  br i1 %866, label %$133, label %$131
$133:
  %867 = phi i64 [%864, %$130] ; # Prg
  %868 = and i64 %862, 6
  %869 = icmp ne i64 %868, 0
  br i1 %869, label %$136, label %$135
$136:
  br label %$134
$135:
  %870 = and i64 %862, 8
  %871 = icmp ne i64 %870, 0
  br i1 %871, label %$138, label %$137
$138:
  %872 = inttoptr i64 %862 to i64*
  %873 = load i64, i64* %872
  br label %$134
$137:
  %874 = call i64 @evList(i64 %862)
  br label %$134
$134:
  %875 = phi i64 [%862, %$136], [%873, %$138], [%874, %$137] ; # ->
  br label %$132
$131:
  %876 = phi i64 [%864, %$130] ; # Prg
  %877 = and i64 %862, 15
  %878 = icmp eq i64 %877, 0
  br i1 %878, label %$140, label %$139
$140:
  %879 = phi i64 [%876, %$131] ; # Prg
  %880 = call i64 @evList(i64 %862)
  %881 = icmp ne i64 %880, 0
  br label %$139
$139:
  %882 = phi i64 [%876, %$131], [%879, %$140] ; # Prg
  %883 = phi i1 [0, %$131], [%881, %$140] ; # ->
  br label %$130
$132:
  %884 = phi i64 [%867, %$134] ; # Prg
  %885 = phi i64 [%875, %$134] ; # ->
  br label %$129
$129:
  %886 = phi i64 [%838, %$127], [%847, %$132] ; # Ms
  %887 = phi i64 [%839, %$127], [%848, %$132] ; # Tim
  %888 = phi i64 [%840, %$127], [%849, %$132] ; # Nfds
  %889 = phi i64 [%841, %$127], [%850, %$132] ; # Dly
  %890 = phi i64 [%842, %$127], [%851, %$132] ; # R
  %891 = phi i64 [%845, %$127], [%885, %$132] ; # ->
  br label %$124
$125:
  %892 = phi i64 [%816, %$122] ; # Ms
  %893 = phi i64 [%817, %$122] ; # Tim
  %894 = phi i64 [%818, %$122] ; # Nfds
  %895 = phi i64 [%819, %$122] ; # Dly
  %896 = phi i64 [%820, %$122] ; # R
; # (int @)
  %897 = lshr i64 %822, 4
; # (i32 (int @))
  %898 = trunc i64 %897 to i32
; # (<> (i32 (int @)) Fd)
  %899 = icmp ne i32 %898, %1
  br i1 %899, label %$142, label %$141
$142:
  %900 = phi i64 [%892, %$125] ; # Ms
  %901 = phi i64 [%893, %$125] ; # Tim
  %902 = phi i64 [%894, %$125] ; # Nfds
  %903 = phi i64 [%895, %$125] ; # Dly
  %904 = phi i64 [%896, %$125] ; # R
; # (when (readyIn Poll @) (set $At (car X)) (run (cdr X)))
; # (readyIn Poll @)
  %905 = call i1 @readyIn(i64* %53, i32 %898)
  br i1 %905, label %$143, label %$144
$143:
  %906 = phi i64 [%900, %$142] ; # Ms
  %907 = phi i64 [%901, %$142] ; # Tim
  %908 = phi i64 [%902, %$142] ; # Nfds
  %909 = phi i64 [%903, %$142] ; # Dly
  %910 = phi i64 [%904, %$142] ; # R
; # (set $At (car X))
; # (car X)
  %911 = inttoptr i64 %798 to i64*
  %912 = load i64, i64* %911
  %913 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %912, i64* %913
; # (cdr X)
  %914 = inttoptr i64 %798 to i64*
  %915 = getelementptr i64, i64* %914, i32 1
  %916 = load i64, i64* %915
; # (run (cdr X))
  br label %$145
$145:
  %917 = phi i64 [%916, %$143], [%939, %$154] ; # Prg
  %918 = inttoptr i64 %917 to i64*
  %919 = load i64, i64* %918
  %920 = getelementptr i64, i64* %918, i32 1
  %921 = load i64, i64* %920
  %922 = and i64 %921, 15
  %923 = icmp ne i64 %922, 0
  br i1 %923, label %$148, label %$146
$148:
  %924 = phi i64 [%921, %$145] ; # Prg
  %925 = and i64 %919, 6
  %926 = icmp ne i64 %925, 0
  br i1 %926, label %$151, label %$150
$151:
  br label %$149
$150:
  %927 = and i64 %919, 8
  %928 = icmp ne i64 %927, 0
  br i1 %928, label %$153, label %$152
$153:
  %929 = inttoptr i64 %919 to i64*
  %930 = load i64, i64* %929
  br label %$149
$152:
  %931 = call i64 @evList(i64 %919)
  br label %$149
$149:
  %932 = phi i64 [%919, %$151], [%930, %$153], [%931, %$152] ; # ->
  br label %$147
$146:
  %933 = phi i64 [%921, %$145] ; # Prg
  %934 = and i64 %919, 15
  %935 = icmp eq i64 %934, 0
  br i1 %935, label %$155, label %$154
$155:
  %936 = phi i64 [%933, %$146] ; # Prg
  %937 = call i64 @evList(i64 %919)
  %938 = icmp ne i64 %937, 0
  br label %$154
$154:
  %939 = phi i64 [%933, %$146], [%936, %$155] ; # Prg
  %940 = phi i1 [0, %$146], [%938, %$155] ; # ->
  br label %$145
$147:
  %941 = phi i64 [%924, %$149] ; # Prg
  %942 = phi i64 [%932, %$149] ; # ->
  br label %$144
$144:
  %943 = phi i64 [%900, %$142], [%906, %$147] ; # Ms
  %944 = phi i64 [%901, %$142], [%907, %$147] ; # Tim
  %945 = phi i64 [%902, %$142], [%908, %$147] ; # Nfds
  %946 = phi i64 [%903, %$142], [%909, %$147] ; # Dly
  %947 = phi i64 [%904, %$142], [%910, %$147] ; # R
  br label %$124
$141:
  %948 = phi i64 [%892, %$125] ; # Ms
  %949 = phi i64 [%893, %$125] ; # Tim
  %950 = phi i64 [%894, %$125] ; # Nfds
  %951 = phi i64 [%895, %$125] ; # Dly
  %952 = phi i64 [%896, %$125] ; # R
  br label %$124
$124:
  %953 = phi i64 [%886, %$129], [%943, %$144], [%948, %$141] ; # Ms
  %954 = phi i64 [%887, %$129], [%944, %$144], [%949, %$141] ; # Tim
  %955 = phi i64 [%888, %$129], [%945, %$144], [%950, %$141] ; # Nfds
  %956 = phi i64 [%889, %$129], [%946, %$144], [%951, %$141] ; # Dly
  %957 = phi i64 [%890, %$129], [%947, %$144], [%952, %$141] ; # R
  br label %$123
$123:
  %958 = phi i64 [%792, %$118], [%953, %$124] ; # Ms
  %959 = phi i64 [%793, %$118], [%954, %$124] ; # Tim
  %960 = phi i64 [%794, %$118], [%955, %$124] ; # Nfds
  %961 = phi i64 [%795, %$118], [%956, %$124] ; # Dly
  %962 = phi i64 [%800, %$118], [%957, %$124] ; # R
  br label %$113
$115:
  %963 = phi i64 [%785, %$113] ; # Ms
  %964 = phi i64 [%786, %$113] ; # Tim
  %965 = phi i64 [%787, %$113] ; # Nfds
  %966 = phi i64 [%788, %$113] ; # Dly
  %967 = phi i64 [%789, %$113] ; # R
; # (and (gt0 Ms) (lt0 (dec 'Ms Dif)) (setq Ms 0))
; # (gt0 Ms)
  %968 = icmp sgt i64 %963, 0
  br i1 %968, label %$157, label %$156
$157:
  %969 = phi i64 [%963, %$115] ; # Ms
  %970 = phi i64 [%964, %$115] ; # Tim
  %971 = phi i64 [%965, %$115] ; # Nfds
  %972 = phi i64 [%966, %$115] ; # Dly
; # (dec 'Ms Dif)
  %973 = sub i64 %969, %326
; # (lt0 (dec 'Ms Dif))
  %974 = icmp slt i64 %973, 0
  br i1 %974, label %$158, label %$156
$158:
  %975 = phi i64 [%973, %$157] ; # Ms
  %976 = phi i64 [%970, %$157] ; # Tim
  %977 = phi i64 [%971, %$157] ; # Nfds
  %978 = phi i64 [%972, %$157] ; # Dly
  br label %$156
$156:
  %979 = phi i64 [%963, %$115], [%973, %$157], [0, %$158] ; # Ms
  %980 = phi i64 [%964, %$115], [%970, %$157], [%976, %$158] ; # Tim
  %981 = phi i64 [%965, %$115], [%971, %$157], [%977, %$158] ; # Nfds
  %982 = phi i64 [%966, %$115], [%972, %$157], [%978, %$158] ; # Dly
  %983 = phi i1 [0, %$115], [0, %$157], [0, %$158] ; # ->
; # (sigChk Exe)
  %984 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %985 = icmp ne i32 %984, 0
  br i1 %985, label %$159, label %$160
$159:
  call void @sighandler(i64 %0)
  br label %$160
$160:
; # (? (or (=0 Ms) (lt0 Fd) (readyIn Poll Fd)))
; # (or (=0 Ms) (lt0 Fd) (readyIn Poll Fd))
; # (=0 Ms)
  %986 = icmp eq i64 %979, 0
  br i1 %986, label %$161, label %$162
$162:
  %987 = phi i64 [%979, %$160] ; # Ms
  %988 = phi i64 [%325, %$160] ; # Tim
  %989 = phi i64 [%981, %$160] ; # Nfds
  %990 = phi i64 [%982, %$160] ; # Dly
; # (lt0 Fd)
  %991 = icmp slt i32 %1, 0
  br i1 %991, label %$161, label %$163
$163:
  %992 = phi i64 [%987, %$162] ; # Ms
  %993 = phi i64 [%988, %$162] ; # Tim
  %994 = phi i64 [%989, %$162] ; # Nfds
  %995 = phi i64 [%990, %$162] ; # Dly
; # (readyIn Poll Fd)
  %996 = call i1 @readyIn(i64* %53, i32 %1)
  br label %$161
$161:
  %997 = phi i64 [%979, %$160], [%987, %$162], [%992, %$163] ; # Ms
  %998 = phi i64 [%325, %$160], [%988, %$162], [%993, %$163] ; # Tim
  %999 = phi i64 [%981, %$160], [%989, %$162], [%994, %$163] ; # Nfds
  %1000 = phi i64 [%982, %$160], [%990, %$162], [%995, %$163] ; # Dly
  %1001 = phi i1 [1, %$160], [1, %$162], [%996, %$163] ; # ->
  br i1 %1001, label %$165, label %$164
$164:
  %1002 = phi i64 [%997, %$161] ; # Ms
  %1003 = phi i64 [%998, %$161] ; # Tim
  %1004 = phi i64 [%999, %$161] ; # Nfds
  %1005 = phi i64 [%1000, %$161] ; # Dly
; # (stack Stk)
  call void @llvm.stackrestore(i8* %35)
; # (set Run (set $Task (val $Run)))
; # (set $Task (val $Run))
; # (val $Run)
  %1006 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  %1007 = load i64, i64* %1006
  %1008 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 168) to i64) to i64*
  store i64 %1007, i64* %1008
  %1009 = inttoptr i64 %19 to i64*
  store i64 %1007, i64* %1009
  br label %$4
$165:
  %1010 = phi i64 [%997, %$161] ; # Ms
  %1011 = phi i64 [%998, %$161] ; # Tim
  %1012 = phi i64 [0, %$161] ; # ->
; # (set $Task Task $At At)
  %1013 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 168) to i64) to i64*
  store i64 %14, i64* %1013
  %1014 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %4, i64* %1014
; # (drop *Safe)
  %1015 = inttoptr i64 %6 to i64*
  %1016 = getelementptr i64, i64* %1015, i32 1
  %1017 = load i64, i64* %1016
  %1018 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %1017, i64* %1018
  ret i64 %1010
}

define i64 @_wait(i64) {
$1:
; # (let (X (cdr Exe) N (if (nil? (eval (++ X))) 292MY (xCnt Exe @)))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) 292MY (xCnt Exe @))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  br label %$9
$8:
; # (xCnt Exe @)
  %17 = call i64 @xCnt(i64 %0, i64 %15)
  br label %$9
$9:
  %18 = phi i64 [9223372036854775807, %$7], [%17, %$8] ; # ->
; # (if (t? (car X)) (let Fd (evCnt Exe (cdr X)) (if (waitFd Exe (i32...
; # (car X)
  %19 = inttoptr i64 %7 to i64*
  %20 = load i64, i64* %19
; # (t? (car X))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %21, label %$10, label %$11
$10:
  %22 = phi i64 [%18, %$9] ; # N
; # (let Fd (evCnt Exe (cdr X)) (if (waitFd Exe (i32 Fd) N) (cnt Fd) ...
; # (cdr X)
  %23 = inttoptr i64 %7 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (evCnt Exe (cdr X))
  %26 = call i64 @evCnt(i64 %0, i64 %25)
; # (if (waitFd Exe (i32 Fd) N) (cnt Fd) $Nil)
; # (i32 Fd)
  %27 = trunc i64 %26 to i32
; # (waitFd Exe (i32 Fd) N)
  %28 = call i64 @waitFd(i64 %0, i32 %27, i64 %22)
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$13, label %$14
$13:
  %30 = phi i64 [%22, %$10] ; # N
; # (cnt Fd)
  %31 = shl i64 %26, 4
  %32 = or i64 %31, 2
  br label %$15
$14:
  %33 = phi i64 [%22, %$10] ; # N
  br label %$15
$15:
  %34 = phi i64 [%30, %$13], [%33, %$14] ; # N
  %35 = phi i64 [%32, %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$14] ; # ->
  br label %$12
$11:
  %36 = phi i64 [%18, %$9] ; # N
; # (loop (? (not (nil? (run X))) @) (? (=0 (waitFd Exe -1 N)) (run X...
  br label %$16
$16:
  %37 = phi i64 [%36, %$11], [%68, %$31] ; # N
; # (? (not (nil? (run X))) @)
; # (run X)
  br label %$17
$17:
  %38 = phi i64 [%7, %$16], [%60, %$26] ; # Prg
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  %41 = getelementptr i64, i64* %39, i32 1
  %42 = load i64, i64* %41
  %43 = and i64 %42, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$20, label %$18
$20:
  %45 = phi i64 [%42, %$17] ; # Prg
  %46 = and i64 %40, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$23, label %$22
$23:
  br label %$21
$22:
  %48 = and i64 %40, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$25, label %$24
$25:
  %50 = inttoptr i64 %40 to i64*
  %51 = load i64, i64* %50
  br label %$21
$24:
  %52 = call i64 @evList(i64 %40)
  br label %$21
$21:
  %53 = phi i64 [%40, %$23], [%51, %$25], [%52, %$24] ; # ->
  br label %$19
$18:
  %54 = phi i64 [%42, %$17] ; # Prg
  %55 = and i64 %40, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$27, label %$26
$27:
  %57 = phi i64 [%54, %$18] ; # Prg
  %58 = call i64 @evList(i64 %40)
  %59 = icmp ne i64 %58, 0
  br label %$26
$26:
  %60 = phi i64 [%54, %$18], [%57, %$27] ; # Prg
  %61 = phi i1 [0, %$18], [%59, %$27] ; # ->
  br label %$17
$19:
  %62 = phi i64 [%45, %$21] ; # Prg
  %63 = phi i64 [%53, %$21] ; # ->
; # (nil? (run X))
  %64 = icmp eq i64 %63, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (run X)))
  %65 = icmp eq i1 %64, 0
  br i1 %65, label %$30, label %$28
$30:
  %66 = phi i64 [%37, %$19] ; # N
  br label %$29
$28:
  %67 = phi i64 [%37, %$19] ; # N
; # (? (=0 (waitFd Exe -1 N)) (run X))
; # (waitFd Exe -1 N)
  %68 = call i64 @waitFd(i64 %0, i32 -1, i64 %67)
; # (=0 (waitFd Exe -1 N))
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %$32, label %$31
$32:
  %70 = phi i64 [%67, %$28] ; # N
; # (run X)
  br label %$33
$33:
  %71 = phi i64 [%7, %$32], [%93, %$42] ; # Prg
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
  %74 = getelementptr i64, i64* %72, i32 1
  %75 = load i64, i64* %74
  %76 = and i64 %75, 15
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$36, label %$34
$36:
  %78 = phi i64 [%75, %$33] ; # Prg
  %79 = and i64 %73, 6
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$39, label %$38
$39:
  br label %$37
$38:
  %81 = and i64 %73, 8
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$41, label %$40
$41:
  %83 = inttoptr i64 %73 to i64*
  %84 = load i64, i64* %83
  br label %$37
$40:
  %85 = call i64 @evList(i64 %73)
  br label %$37
$37:
  %86 = phi i64 [%73, %$39], [%84, %$41], [%85, %$40] ; # ->
  br label %$35
$34:
  %87 = phi i64 [%75, %$33] ; # Prg
  %88 = and i64 %73, 15
  %89 = icmp eq i64 %88, 0
  br i1 %89, label %$43, label %$42
$43:
  %90 = phi i64 [%87, %$34] ; # Prg
  %91 = call i64 @evList(i64 %73)
  %92 = icmp ne i64 %91, 0
  br label %$42
$42:
  %93 = phi i64 [%87, %$34], [%90, %$43] ; # Prg
  %94 = phi i1 [0, %$34], [%92, %$43] ; # ->
  br label %$33
$35:
  %95 = phi i64 [%78, %$37] ; # Prg
  %96 = phi i64 [%86, %$37] ; # ->
  br label %$29
$31:
  %97 = phi i64 [%67, %$28] ; # N
  br label %$16
$29:
  %98 = phi i64 [%66, %$30], [%70, %$35] ; # N
  %99 = phi i64 [%63, %$30], [%96, %$35] ; # ->
  br label %$12
$12:
  %100 = phi i64 [%34, %$15], [%98, %$29] ; # N
  %101 = phi i64 [%35, %$15], [%99, %$29] ; # ->
  ret i64 %101
}

define i64 @_sync(i64) {
$1:
; # (cond ((or (=0 (val $Mic)) (=0 (val $Hear))) $Nil) ((val $Sync) $...
; # (or (=0 (val $Mic)) (=0 (val $Hear)))
; # (val $Mic)
  %1 = load i32, i32* @$Mic
; # (=0 (val $Mic))
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %$3, label %$4
$4:
; # (val $Hear)
  %3 = load i32, i32* @$Hear
; # (=0 (val $Hear))
  %4 = icmp eq i32 %3, 0
  br label %$3
$3:
  %5 = phi i1 [1, %$1], [%4, %$4] ; # ->
  br i1 %5, label %$6, label %$5
$6:
  br label %$2
$5:
; # (val $Sync)
  %6 = load i1, i1* @$Sync
  br i1 %6, label %$8, label %$7
$8:
  br label %$2
$7:
; # (let (Mic (val $Mic) P (i8* $Slot) Cnt 8) (loop (let N (write Mic...
; # (val $Mic)
  %7 = load i32, i32* @$Mic
; # (i8* $Slot)
  %8 = bitcast i64* @$Slot to i8*
; # (loop (let N (write Mic P Cnt) (cond ((ge0 N) (? (=0 (dec 'Cnt N)...
  br label %$9
$9:
  %9 = phi i8* [%8, %$7], [%30, %$10] ; # P
  %10 = phi i64 [8, %$7], [%31, %$10] ; # Cnt
; # (let N (write Mic P Cnt) (cond ((ge0 N) (? (=0 (dec 'Cnt N))) (se...
; # (write Mic P Cnt)
  %11 = call i64 @write(i32 %7, i8* %9, i64 %10)
; # (cond ((ge0 N) (? (=0 (dec 'Cnt N))) (setq P (ofs P N))) ((== (gE...
; # (ge0 N)
  %12 = icmp sge i64 %11, 0
  br i1 %12, label %$12, label %$11
$12:
  %13 = phi i8* [%9, %$9] ; # P
  %14 = phi i64 [%10, %$9] ; # Cnt
; # (? (=0 (dec 'Cnt N)))
; # (dec 'Cnt N)
  %15 = sub i64 %14, %11
; # (=0 (dec 'Cnt N))
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$14, label %$13
$13:
  %17 = phi i8* [%13, %$12] ; # P
  %18 = phi i64 [%15, %$12] ; # Cnt
; # (ofs P N)
  %19 = getelementptr i8, i8* %17, i64 %11
  br label %$10
$11:
  %20 = phi i8* [%9, %$9] ; # P
  %21 = phi i64 [%10, %$9] ; # Cnt
; # (gErrno)
  %22 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %23 = icmp eq i32 %22, 2
  br i1 %23, label %$16, label %$15
$16:
  %24 = phi i8* [%20, %$11] ; # P
  %25 = phi i64 [%21, %$11] ; # Cnt
; # (sigChk Exe)
  %26 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$17, label %$18
$17:
  call void @sighandler(i64 %0)
  br label %$18
$18:
  br label %$10
$15:
  %28 = phi i8* [%20, %$11] ; # P
  %29 = phi i64 [%21, %$11] ; # Cnt
; # (writeErr ($ "sync write: %s"))
  call void @writeErr(i8* bitcast ([15 x i8]* @$38 to i8*))
  unreachable
$10:
  %30 = phi i8* [%19, %$13], [%24, %$18] ; # P
  %31 = phi i64 [%18, %$13], [%25, %$18] ; # Cnt
  br label %$9
$14:
  %32 = phi i8* [%13, %$12] ; # P
  %33 = phi i64 [%15, %$12] ; # Cnt
  %34 = phi i64 [0, %$12] ; # ->
; # (set $Sync NO)
  store i1 0, i1* @$Sync
; # (loop (waitFd Exe -1 292MY) (? (val $Sync)))
  br label %$19
$19:
; # (waitFd Exe -1 292MY)
  %35 = call i64 @waitFd(i64 %0, i32 -1, i64 9223372036854775807)
; # (? (val $Sync))
; # (val $Sync)
  %36 = load i1, i1* @$Sync
  br i1 %36, label %$21, label %$20
$20:
  br label %$19
$21:
  %37 = phi i64 [0, %$19] ; # ->
  br label %$2
$2:
  %38 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$6], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$8], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$21] ; # ->
  ret i64 %38
}

define i64 @_hear(i64) {
$1:
; # (let (C (eval (cadr Exe)) Fd (i32 (xCnt Exe C))) (when (or (lt0 F...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (xCnt Exe C)
  %14 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe C))
  %15 = trunc i64 %14 to i32
; # (when (or (lt0 Fd) (>= Fd (val $InFDs)) (=0 (val (ofs (val $InFil...
; # (or (lt0 Fd) (>= Fd (val $InFDs)) (=0 (val (ofs (val $InFiles) Fd...
; # (lt0 Fd)
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %$7, label %$8
$8:
; # (val $InFDs)
  %17 = load i32, i32* @$InFDs
; # (>= Fd (val $InFDs))
  %18 = icmp sge i32 %15, %17
  br i1 %18, label %$7, label %$9
$9:
; # (val $InFiles)
  %19 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %20 = getelementptr i8*, i8** %19, i32 %15
; # (val (ofs (val $InFiles) Fd))
  %21 = load i8*, i8** %20
; # (=0 (val (ofs (val $InFiles) Fd)))
  %22 = icmp eq i8* %21, null
  br label %$7
$7:
  %23 = phi i1 [1, %$2], [1, %$8], [%22, %$9] ; # ->
  br i1 %23, label %$10, label %$11
$10:
; # (badFd Exe C)
  call void @badFd(i64 %0, i64 %13)
  unreachable
$11:
; # (when (val $Hear) (close @) (closeInFile @) (closeOutFile @))
; # (val $Hear)
  %24 = load i32, i32* @$Hear
  %25 = icmp ne i32 %24, 0
  br i1 %25, label %$12, label %$13
$12:
; # (close @)
  %26 = call i32 @close(i32 %24)
; # (closeInFile @)
  call void @closeInFile(i32 %24)
; # (closeOutFile @)
  call void @closeOutFile(i32 %24)
  br label %$13
$13:
; # (set $Hear Fd)
  store i32 %15, i32* @$Hear
  ret i64 %13
}

define i64 @_tell(i64) {
$1:
; # (cond ((and (=0 (val $Tell)) (=0 (val $Children))) $Nil) ((atom (...
; # (and (=0 (val $Tell)) (=0 (val $Children)))
; # (val $Tell)
  %1 = load i32, i32* @$Tell
; # (=0 (val $Tell))
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %$4, label %$3
$4:
; # (val $Children)
  %3 = load i64, i64* @$Children
; # (=0 (val $Children))
  %4 = icmp eq i64 %3, 0
  br label %$3
$3:
  %5 = phi i1 [0, %$1], [%4, %$4] ; # ->
  br i1 %5, label %$6, label %$5
$6:
  br label %$2
$5:
; # (cdr Exe)
  %6 = inttoptr i64 %0 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
; # (atom (cdr Exe))
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$8, label %$7
$8:
; # (unsync)
  call void @unsync()
  br label %$2
$7:
; # (let (X @ Y (eval (car X)) Pid (i32 0)) (when (cnt? Y) (setq Pid ...
; # (car X)
  %11 = inttoptr i64 %8 to i64*
  %12 = load i64, i64* %11
; # (eval (car X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$11, label %$10
$11:
  br label %$9
$10:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$13, label %$12
$13:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$9
$12:
  %19 = call i64 @evList(i64 %12)
  br label %$9
$9:
  %20 = phi i64 [%12, %$11], [%18, %$13], [%19, %$12] ; # ->
; # (i32 0)
; # (when (cnt? Y) (setq Pid (i32 (int @)) Y (eval (car (shift X)))))...
; # (cnt? Y)
  %21 = and i64 %20, 2
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$14, label %$15
$14:
  %23 = phi i64 [%8, %$9] ; # X
  %24 = phi i64 [%20, %$9] ; # Y
  %25 = phi i32 [0, %$9] ; # Pid
; # (int @)
  %26 = lshr i64 %20, 4
; # (i32 (int @))
  %27 = trunc i64 %26 to i32
; # (shift X)
  %28 = inttoptr i64 %23 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (car (shift X))
  %31 = inttoptr i64 %30 to i64*
  %32 = load i64, i64* %31
; # (eval (car (shift X)))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$18, label %$17
$18:
  br label %$16
$17:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$20, label %$19
$20:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$16
$19:
  %39 = call i64 @evList(i64 %32)
  br label %$16
$16:
  %40 = phi i64 [%32, %$18], [%38, %$20], [%39, %$19] ; # ->
  br label %$15
$15:
  %41 = phi i64 [%8, %$9], [%30, %$16] ; # X
  %42 = phi i64 [%20, %$9], [%40, %$16] ; # Y
  %43 = phi i32 [0, %$9], [%27, %$16] ; # Pid
; # (let (TellBuf (val $TellBuf) Ptr (val $Ptr) End (val $End)) (tell...
; # (val $TellBuf)
  %44 = load i8*, i8** @$TellBuf
; # (val $Ptr)
  %45 = load i8*, i8** @$Ptr
; # (val $End)
  %46 = load i8*, i8** @$End
; # (val PipeBufSize)
  %47 = load i64, i64* @PipeBufSize
; # (b8 (val PipeBufSize))
  %48 = alloca i8, i64 %47
; # (tellBeg (b8 (val PipeBufSize)))
  call void @tellBeg(i8* %48)
; # (stkChk Exe)
  %49 = load i8*, i8** @$StkLimit
  %50 = call i8* @llvm.stacksave()
  %51 = icmp ugt i8* %49, %50
  br i1 %51, label %$21, label %$22
$21:
  call void @stkErr(i64 %0)
  unreachable
$22:
; # (loop (prTell Y) (? (atom (shift X))) (setq Y (eval (car X))))
  br label %$23
$23:
  %52 = phi i64 [%41, %$22], [%60, %$26] ; # X
  %53 = phi i64 [%42, %$22], [%72, %$26] ; # Y
  %54 = phi i32 [%43, %$22], [%62, %$26] ; # Pid
; # (prTell Y)
  call void @prTell(i64 %53)
; # (? (atom (shift X)))
; # (shift X)
  %55 = inttoptr i64 %52 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
; # (atom (shift X))
  %58 = and i64 %57, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$25, label %$24
$24:
  %60 = phi i64 [%57, %$23] ; # X
  %61 = phi i64 [%53, %$23] ; # Y
  %62 = phi i32 [%54, %$23] ; # Pid
; # (car X)
  %63 = inttoptr i64 %60 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$28, label %$27
$28:
  br label %$26
$27:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$30, label %$29
$30:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$26
$29:
  %71 = call i64 @evList(i64 %64)
  br label %$26
$26:
  %72 = phi i64 [%64, %$28], [%70, %$30], [%71, %$29] ; # ->
  br label %$23
$25:
  %73 = phi i64 [%57, %$23] ; # X
  %74 = phi i64 [%53, %$23] ; # Y
  %75 = phi i32 [%54, %$23] ; # Pid
  %76 = phi i64 [0, %$23] ; # ->
; # (tellEnd Pid)
  call void @tellEnd(i32 %75)
; # (set $TellBuf TellBuf $Ptr Ptr $End End)
  store i8* %44, i8** @$TellBuf
  store i8* %45, i8** @$Ptr
  store i8* %46, i8** @$End
  br label %$2
$2:
  %77 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$6], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8], [%74, %$25] ; # ->
  ret i64 %77
}

define i64 @_poll(i64) {
$1:
; # (let (C (eval (cadr Exe)) Fd (i32 (xCnt Exe C))) (when (or (lt0 F...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (xCnt Exe C)
  %14 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe C))
  %15 = trunc i64 %14 to i32
; # (when (or (lt0 Fd) (>= Fd (val $InFDs))) (badFd Exe C))
; # (or (lt0 Fd) (>= Fd (val $InFDs)))
; # (lt0 Fd)
  %16 = icmp slt i32 %15, 0
  br i1 %16, label %$7, label %$8
$8:
; # (val $InFDs)
  %17 = load i32, i32* @$InFDs
; # (>= Fd (val $InFDs))
  %18 = icmp sge i32 %15, %17
  br label %$7
$7:
  %19 = phi i1 [1, %$2], [%18, %$8] ; # ->
  br i1 %19, label %$9, label %$10
$9:
; # (badFd Exe C)
  call void @badFd(i64 %0, i64 %13)
  unreachable
$10:
; # (let In: (inFile (val (ofs (val $InFiles) Fd))) (ifn (In:) $Nil (...
; # (val $InFiles)
  %20 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) Fd)
  %21 = getelementptr i8*, i8** %20, i32 %15
; # (val (ofs (val $InFiles) Fd))
  %22 = load i8*, i8** %21
; # (ifn (In:) $Nil (let Poll (b64 1) (pollIn Fd Poll) (loop (? (> (I...
; # (In:)
  %23 = icmp ne i8* %22, null
  br i1 %23, label %$12, label %$11
$11:
  br label %$13
$12:
; # (let Poll (b64 1) (pollIn Fd Poll) (loop (? (> (In: cnt) (In: ix)...
; # (b64 1)
  %24 = alloca i64, i64 1
; # (pollIn Fd Poll)
  call void @pollIn(i32 %15, i64* %24)
; # (loop (? (> (In: cnt) (In: ix)) C) (while (lt0 (gPoll Poll 1 0)) ...
  br label %$14
$14:
; # (? (> (In: cnt) (In: ix)) C)
; # (In: cnt)
  %25 = getelementptr i8, i8* %22, i32 8
  %26 = bitcast i8* %25 to i64*
  %27 = load i64, i64* %26
; # (In: ix)
  %28 = bitcast i8* %22 to i64*
  %29 = load i64, i64* %28
; # (> (In: cnt) (In: ix))
  %30 = icmp ugt i64 %27, %29
  br i1 %30, label %$17, label %$15
$17:
  br label %$16
$15:
; # (while (lt0 (gPoll Poll 1 0)) (unless (== (gErrno) EINTR) (select...
  br label %$18
$18:
; # (gPoll Poll 1 0)
  %31 = call i32 @gPoll(i64* %24, i64 1, i64 0)
; # (lt0 (gPoll Poll 1 0))
  %32 = icmp slt i32 %31, 0
  br i1 %32, label %$19, label %$20
$19:
; # (unless (== (gErrno) EINTR) (selectErr Exe))
; # (gErrno)
  %33 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %34 = icmp eq i32 %33, 2
  br i1 %34, label %$22, label %$21
$21:
; # (selectErr Exe)
  call void @selectErr(i64 %0)
  unreachable
$22:
  br label %$18
$20:
; # (? (not (readyIn Poll Fd)) $Nil)
; # (readyIn Poll Fd)
  %35 = call i1 @readyIn(i64* %24, i32 %15)
; # (not (readyIn Poll Fd))
  %36 = icmp eq i1 %35, 0
  br i1 %36, label %$24, label %$23
$24:
  br label %$16
$23:
; # (? (ge0 (slowNb (In:))))
; # (In:)
; # (slowNb (In:))
  %37 = call i64 @slowNb(i8* %22)
; # (ge0 (slowNb (In:)))
  %38 = icmp sge i64 %37, 0
  br i1 %38, label %$16, label %$25
$25:
  br label %$14
$16:
  %39 = phi i64 [%13, %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$24], [0, %$23] ; # ->
  br label %$13
$13:
  %40 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [%39, %$16] ; # ->
  ret i64 %40
}

define void @rdOpen(i64, i64, i8*) {
$1:
; # (let Io: (ioFrame P) (cond ((nil? X) (Io: fd 0) (Io: pid 0)) ((nu...
; # (cond ((nil? X) (Io: fd 0) (Io: pid 0)) ((num? X) (Io: pid 0) (le...
; # (nil? X)
  %3 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%1, %$1] ; # X
; # (Io: fd 0)
  %5 = getelementptr i8, i8* %2, i32 8
  %6 = bitcast i8* %5 to i32*
  store i32 0, i32* %6
; # (Io: pid 0)
  %7 = getelementptr i8, i8* %2, i32 12
  %8 = bitcast i8* %7 to i32*
  store i32 0, i32* %8
  br label %$2
$3:
  %9 = phi i64 [%1, %$1] ; # X
; # (num? X)
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = phi i64 [%9, %$3] ; # X
; # (Io: pid 0)
  %13 = getelementptr i8, i8* %2, i32 12
  %14 = bitcast i8* %13 to i32*
  store i32 0, i32* %14
; # (let N (i32 (int X)) (when (sign? X) (let In (val $InFrames) (loo...
; # (int X)
  %15 = lshr i64 %12, 4
; # (i32 (int X))
  %16 = trunc i64 %15 to i32
; # (when (sign? X) (let In (val $InFrames) (loop (unless (setq In ((...
; # (sign? X)
  %17 = and i64 %12, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$7, label %$8
$7:
  %19 = phi i64 [%12, %$6] ; # X
  %20 = phi i32 [%16, %$6] ; # N
; # (let In (val $InFrames) (loop (unless (setq In ((ioFrame In) link...
; # (val $InFrames)
  %21 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (loop (unless (setq In ((ioFrame In) link)) (badFd Exe X)) (? (=0...
  br label %$9
$9:
  %22 = phi i64 [%19, %$7], [%36, %$12] ; # X
  %23 = phi i32 [%20, %$7], [%37, %$12] ; # N
  %24 = phi i8* [%21, %$7], [%38, %$12] ; # In
; # (unless (setq In ((ioFrame In) link)) (badFd Exe X))
; # ((ioFrame In) link)
  %25 = bitcast i8* %24 to i8**
  %26 = load i8*, i8** %25
  %27 = icmp ne i8* %26, null
  br i1 %27, label %$11, label %$10
$10:
  %28 = phi i64 [%22, %$9] ; # X
  %29 = phi i32 [%23, %$9] ; # N
  %30 = phi i8* [%26, %$9] ; # In
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %28)
  unreachable
$11:
  %31 = phi i64 [%22, %$9] ; # X
  %32 = phi i32 [%23, %$9] ; # N
  %33 = phi i8* [%26, %$9] ; # In
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %34 = sub i32 %32, 1
; # (=0 (dec 'N))
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %$13, label %$12
$12:
  %36 = phi i64 [%31, %$11] ; # X
  %37 = phi i32 [%34, %$11] ; # N
  %38 = phi i8* [%33, %$11] ; # In
  br label %$9
$13:
  %39 = phi i64 [%31, %$11] ; # X
  %40 = phi i32 [%34, %$11] ; # N
  %41 = phi i8* [%33, %$11] ; # In
  %42 = phi i64 [0, %$11] ; # ->
; # ((ioFrame In) fd)
  %43 = getelementptr i8, i8* %41, i32 8
  %44 = bitcast i8* %43 to i32*
  %45 = load i32, i32* %44
  br label %$8
$8:
  %46 = phi i64 [%12, %$6], [%39, %$13] ; # X
  %47 = phi i32 [%16, %$6], [%45, %$13] ; # N
; # (when (or (>= (Io: fd N) (val $InFDs)) (=0 (val (ofs (val $InFile...
; # (or (>= (Io: fd N) (val $InFDs)) (=0 (val (ofs (val $InFiles) N))...
; # (Io: fd N)
  %48 = getelementptr i8, i8* %2, i32 8
  %49 = bitcast i8* %48 to i32*
  store i32 %47, i32* %49
; # (val $InFDs)
  %50 = load i32, i32* @$InFDs
; # (>= (Io: fd N) (val $InFDs))
  %51 = icmp sge i32 %47, %50
  br i1 %51, label %$14, label %$15
$15:
  %52 = phi i64 [%46, %$8] ; # X
  %53 = phi i32 [%47, %$8] ; # N
; # (val $InFiles)
  %54 = load i8**, i8*** @$InFiles
; # (ofs (val $InFiles) N)
  %55 = getelementptr i8*, i8** %54, i32 %53
; # (val (ofs (val $InFiles) N))
  %56 = load i8*, i8** %55
; # (=0 (val (ofs (val $InFiles) N)))
  %57 = icmp eq i8* %56, null
  br label %$14
$14:
  %58 = phi i64 [%46, %$8], [%52, %$15] ; # X
  %59 = phi i32 [%47, %$8], [%53, %$15] ; # N
  %60 = phi i1 [1, %$8], [%57, %$15] ; # ->
  br i1 %60, label %$16, label %$17
$16:
  %61 = phi i64 [%58, %$14] ; # X
  %62 = phi i32 [%59, %$14] ; # N
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %61)
  unreachable
$17:
  %63 = phi i64 [%58, %$14] ; # X
  %64 = phi i32 [%59, %$14] ; # N
  br label %$2
$5:
  %65 = phi i64 [%9, %$3] ; # X
; # (sym? X)
  %66 = and i64 %65, 8
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$19, label %$18
$19:
  %68 = phi i64 [%65, %$5] ; # X
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %69 = call i64 @xName(i64 %0, i64 %68)
; # (pathSize Nm)
  %70 = call i64 @pathSize(i64 %69)
; # (b8 (pathSize Nm))
  %71 = alloca i8, i64 %70
; # (pathString Nm (b8 (pathSize Nm)))
  %72 = call i8* @pathString(i64 %69, i8* %71)
; # (val S)
  %73 = load i8, i8* %72
; # (== (val S) (char "+"))
  %74 = icmp eq i8 %73, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %74, label %$20, label %$21
$20:
  %75 = phi i64 [%68, %$19] ; # X
  %76 = phi i8* [%72, %$19] ; # S
; # (ofs S 1)
  %77 = getelementptr i8, i8* %76, i32 1
  br label %$21
$21:
  %78 = phi i64 [%68, %$19], [%75, %$20] ; # X
  %79 = phi i8* [%72, %$19], [%77, %$20] ; # S
; # (while (lt0 (Io: fd (if Flg (openRdWrAppend S) (openRd S)))) (unl...
  br label %$22
$22:
  %80 = phi i64 [%78, %$21], [%100, %$31] ; # X
  %81 = phi i8* [%79, %$21], [%101, %$31] ; # S
; # (Io: fd (if Flg (openRdWrAppend S) (openRd S)))
  %82 = getelementptr i8, i8* %2, i32 8
  %83 = bitcast i8* %82 to i32*
  br i1 %74, label %$23, label %$24
$23:
  %84 = phi i64 [%80, %$22] ; # X
  %85 = phi i8* [%81, %$22] ; # S
  %86 = call i32 @openRdWrAppend(i8* %85)
  br label %$25
$24:
  %87 = phi i64 [%80, %$22] ; # X
  %88 = phi i8* [%81, %$22] ; # S
  %89 = call i32 @openRd(i8* %88)
  br label %$25
$25:
  %90 = phi i64 [%84, %$23], [%87, %$24] ; # X
  %91 = phi i8* [%85, %$23], [%88, %$24] ; # S
  %92 = phi i32 [%86, %$23], [%89, %$24] ; # ->
  store i32 %92, i32* %83
; # (lt0 (Io: fd (if Flg (openRdWrAppend S) (openRd S))))
  %93 = icmp slt i32 %92, 0
  br i1 %93, label %$26, label %$27
$26:
  %94 = phi i64 [%90, %$25] ; # X
  %95 = phi i8* [%91, %$25] ; # S
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %96 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %97 = icmp eq i32 %96, 2
  br i1 %97, label %$29, label %$28
$28:
  %98 = phi i64 [%94, %$26] ; # X
  %99 = phi i8* [%95, %$26] ; # S
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %98)
  unreachable
$29:
  %100 = phi i64 [%94, %$26] ; # X
  %101 = phi i8* [%95, %$26] ; # S
; # (sigChk Exe)
  %102 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %103 = icmp ne i32 %102, 0
  br i1 %103, label %$30, label %$31
$30:
  call void @sighandler(i64 %0)
  br label %$31
$31:
  br label %$22
$27:
  %104 = phi i64 [%90, %$25] ; # X
  %105 = phi i8* [%91, %$25] ; # S
; # (Io: pid 1)
  %106 = getelementptr i8, i8* %2, i32 12
  %107 = bitcast i8* %106 to i32*
  store i32 1, i32* %107
; # (Io: fd)
  %108 = getelementptr i8, i8* %2, i32 8
  %109 = bitcast i8* %108 to i32*
  %110 = load i32, i32* %109
; # (strdup S)
  %111 = call i8* @strdup(i8* %105)
; # (initInFile (Io: fd) (strdup S))
  %112 = call i8* @initInFile(i32 %110, i8* %111)
; # (Io: fd)
  %113 = getelementptr i8, i8* %2, i32 8
  %114 = bitcast i8* %113 to i32*
  %115 = load i32, i32* %114
; # (closeOnExec Exe (Io: fd))
  call void @closeOnExec(i64 %0, i32 %115)
  br label %$2
$18:
  %116 = phi i64 [%65, %$5] ; # X
; # (let (Pfd (b32 2) Av (b8* (inc (length X))) Cmd (xName Exe (xSym ...
; # (b32 2)
  %117 = alloca i32, i64 2
; # (length X)
  br label %$32
$32:
  %118 = phi i64 [%116, %$18], [%127, %$33] ; # X
  %119 = phi i64 [0, %$18], [%124, %$33] ; # N
  %120 = and i64 %118, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$33, label %$34
$33:
  %122 = phi i64 [%118, %$32] ; # X
  %123 = phi i64 [%119, %$32] ; # N
  %124 = add i64 %123, 1
  %125 = inttoptr i64 %122 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
  br label %$32
$34:
  %128 = phi i64 [%118, %$32] ; # X
  %129 = phi i64 [%119, %$32] ; # N
; # (inc (length X))
  %130 = add i64 %129, 1
; # (b8* (inc (length X)))
  %131 = alloca i8*, i64 %130
; # (car X)
  %132 = inttoptr i64 %116 to i64*
  %133 = load i64, i64* %132
; # (xSym (car X))
  %134 = call i64 @xSym(i64 %133)
; # (xName Exe (xSym (car X)))
  %135 = call i64 @xName(i64 %0, i64 %134)
; # (when (lt0 (pipe Pfd)) (pipeErr Exe))
; # (pipe Pfd)
  %136 = call i32 @pipe(i32* %117)
; # (lt0 (pipe Pfd))
  %137 = icmp slt i32 %136, 0
  br i1 %137, label %$35, label %$36
$35:
  %138 = phi i64 [%116, %$34] ; # X
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$36:
  %139 = phi i64 [%116, %$34] ; # X
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %140 = call i64 @pathSize(i64 %135)
; # (b8 (pathSize Cmd))
  %141 = alloca i8, i64 %140
; # (pathString Cmd (b8 (pathSize Cmd)))
  %142 = call i8* @pathString(i64 %135, i8* %141)
  store i8* %142, i8** %131
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (xSym (car X...
; # (while (pair (shift X)) (let Nm (xName Exe (xSym (car X))) (set (...
  br label %$37
$37:
  %143 = phi i64 [%139, %$36], [%150, %$38] ; # X
  %144 = phi i8** [%131, %$36], [%156, %$38] ; # A
; # (shift X)
  %145 = inttoptr i64 %143 to i64*
  %146 = getelementptr i64, i64* %145, i32 1
  %147 = load i64, i64* %146
; # (pair (shift X))
  %148 = and i64 %147, 15
  %149 = icmp eq i64 %148, 0
  br i1 %149, label %$38, label %$39
$38:
  %150 = phi i64 [%147, %$37] ; # X
  %151 = phi i8** [%144, %$37] ; # A
; # (let Nm (xName Exe (xSym (car X))) (set (inc 'A) (bufString Nm (b...
; # (car X)
  %152 = inttoptr i64 %150 to i64*
  %153 = load i64, i64* %152
; # (xSym (car X))
  %154 = call i64 @xSym(i64 %153)
; # (xName Exe (xSym (car X)))
  %155 = call i64 @xName(i64 %0, i64 %154)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %156 = getelementptr i8*, i8** %151, i32 1
; # (bufSize Nm)
  %157 = call i64 @bufSize(i64 %155)
; # (b8 (bufSize Nm))
  %158 = alloca i8, i64 %157
; # (bufString Nm (b8 (bufSize Nm)))
  %159 = call i8* @bufString(i64 %155, i8* %158)
  store i8* %159, i8** %156
  br label %$37
$39:
  %160 = phi i64 [%147, %$37] ; # X
  %161 = phi i8** [%144, %$37] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %162 = getelementptr i8*, i8** %161, i32 1
  store i8* null, i8** %162
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (setpgid 0 0) (close (...
; # (fork)
  %163 = call i32 @fork()
; # (lt0 (fork))
  %164 = icmp slt i32 %163, 0
  br i1 %164, label %$42, label %$41
$42:
  %165 = phi i64 [%160, %$39] ; # X
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$41:
  %166 = phi i64 [%160, %$39] ; # X
; # (=0 @)
  %167 = icmp eq i32 %163, 0
  br i1 %167, label %$44, label %$43
$44:
  %168 = phi i64 [%166, %$41] ; # X
; # (setpgid 0 0)
  %169 = call i32 @setpgid(i32 0, i32 0)
; # (val Pfd)
  %170 = load i32, i32* %117
; # (close (val Pfd))
  %171 = call i32 @close(i32 %170)
; # (unless (== (val 2 Pfd) 1) (dup2 @ 1) (close @))
; # (val 2 Pfd)
  %172 = getelementptr i32, i32* %117, i32 1
  %173 = load i32, i32* %172
; # (== (val 2 Pfd) 1)
  %174 = icmp eq i32 %173, 1
  br i1 %174, label %$46, label %$45
$45:
  %175 = phi i64 [%168, %$44] ; # X
; # (dup2 @ 1)
  %176 = call i32 @dup2(i32 %173, i32 1)
; # (close @)
  %177 = call i32 @close(i32 %173)
  br label %$46
$46:
  %178 = phi i64 [%168, %$44], [%175, %$45] ; # X
; # (val SIGPIPE Sig)
  %179 = getelementptr i32, i32* @Sig, i32 4
  %180 = load i32, i32* %179
; # (val SigDfl)
  %181 = load i8*, i8** @SigDfl
; # (signal (val SIGPIPE Sig) (val SigDfl))
  %182 = call i8* @signal(i32 %180, i8* %181)
; # (val Av)
  %183 = load i8*, i8** %131
; # (execvp (val Av) Av)
  %184 = call i32 @execvp(i8* %183, i8** %131)
; # (val Av)
  %185 = load i8*, i8** %131
; # (execErr (val Av))
  call void @execErr(i8* %185)
  unreachable
$43:
  %186 = phi i64 [%166, %$41] ; # X
  br label %$40
$40:
  %187 = phi i64 [%186, %$43] ; # X
  %188 = phi i64 [0, %$43] ; # ->
; # (Io: pid @)
  %189 = getelementptr i8, i8* %2, i32 12
  %190 = bitcast i8* %189 to i32*
  store i32 %163, i32* %190
; # (setpgid (Io: pid @) 0)
  %191 = call i32 @setpgid(i32 %163, i32 0)
; # (val 2 Pfd)
  %192 = getelementptr i32, i32* %117, i32 1
  %193 = load i32, i32* %192
; # (close (val 2 Pfd))
  %194 = call i32 @close(i32 %193)
; # (let F (Io: fd (val Pfd)) (initInFile F null) (closeOnExec Exe F)...
; # (Io: fd (val Pfd))
  %195 = getelementptr i8, i8* %2, i32 8
  %196 = bitcast i8* %195 to i32*
  %197 = load i32, i32* %117
  store i32 %197, i32* %196
; # (initInFile F null)
  %198 = call i8* @initInFile(i32 %197, i8* null)
; # (closeOnExec Exe F)
  call void @closeOnExec(i64 %0, i32 %197)
  br label %$2
$2:
  %199 = phi i64 [%4, %$4], [%63, %$17], [%104, %$27], [%187, %$40] ; # X
  ret void
}

define void @wrOpen(i64, i64, i8*) {
$1:
; # (let Io: (ioFrame P) (cond ((nil? X) (Io: fd 1) (Io: pid 0)) ((nu...
; # (cond ((nil? X) (Io: fd 1) (Io: pid 0)) ((num? X) (Io: pid 0) (le...
; # (nil? X)
  %3 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%1, %$1] ; # X
; # (Io: fd 1)
  %5 = getelementptr i8, i8* %2, i32 8
  %6 = bitcast i8* %5 to i32*
  store i32 1, i32* %6
; # (Io: pid 0)
  %7 = getelementptr i8, i8* %2, i32 12
  %8 = bitcast i8* %7 to i32*
  store i32 0, i32* %8
  br label %$2
$3:
  %9 = phi i64 [%1, %$1] ; # X
; # (num? X)
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = phi i64 [%9, %$3] ; # X
; # (Io: pid 0)
  %13 = getelementptr i8, i8* %2, i32 12
  %14 = bitcast i8* %13 to i32*
  store i32 0, i32* %14
; # (let N (i32 (int X)) (when (sign? X) (let Out (val $OutFrames) (l...
; # (int X)
  %15 = lshr i64 %12, 4
; # (i32 (int X))
  %16 = trunc i64 %15 to i32
; # (when (sign? X) (let Out (val $OutFrames) (loop (unless (setq Out...
; # (sign? X)
  %17 = and i64 %12, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$7, label %$8
$7:
  %19 = phi i64 [%12, %$6] ; # X
  %20 = phi i32 [%16, %$6] ; # N
; # (let Out (val $OutFrames) (loop (unless (setq Out ((ioFrame Out) ...
; # (val $OutFrames)
  %21 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (loop (unless (setq Out ((ioFrame Out) link)) (badFd Exe X)) (? (...
  br label %$9
$9:
  %22 = phi i64 [%19, %$7], [%36, %$12] ; # X
  %23 = phi i32 [%20, %$7], [%37, %$12] ; # N
  %24 = phi i8* [%21, %$7], [%38, %$12] ; # Out
; # (unless (setq Out ((ioFrame Out) link)) (badFd Exe X))
; # ((ioFrame Out) link)
  %25 = bitcast i8* %24 to i8**
  %26 = load i8*, i8** %25
  %27 = icmp ne i8* %26, null
  br i1 %27, label %$11, label %$10
$10:
  %28 = phi i64 [%22, %$9] ; # X
  %29 = phi i32 [%23, %$9] ; # N
  %30 = phi i8* [%26, %$9] ; # Out
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %28)
  unreachable
$11:
  %31 = phi i64 [%22, %$9] ; # X
  %32 = phi i32 [%23, %$9] ; # N
  %33 = phi i8* [%26, %$9] ; # Out
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %34 = sub i32 %32, 1
; # (=0 (dec 'N))
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %$13, label %$12
$12:
  %36 = phi i64 [%31, %$11] ; # X
  %37 = phi i32 [%34, %$11] ; # N
  %38 = phi i8* [%33, %$11] ; # Out
  br label %$9
$13:
  %39 = phi i64 [%31, %$11] ; # X
  %40 = phi i32 [%34, %$11] ; # N
  %41 = phi i8* [%33, %$11] ; # Out
  %42 = phi i64 [0, %$11] ; # ->
; # ((ioFrame Out) fd)
  %43 = getelementptr i8, i8* %41, i32 8
  %44 = bitcast i8* %43 to i32*
  %45 = load i32, i32* %44
  br label %$8
$8:
  %46 = phi i64 [%12, %$6], [%39, %$13] ; # X
  %47 = phi i32 [%16, %$6], [%45, %$13] ; # N
; # (when (or (>= (Io: fd N) (val $OutFDs)) (=0 (val (ofs (val $OutFi...
; # (or (>= (Io: fd N) (val $OutFDs)) (=0 (val (ofs (val $OutFiles) N...
; # (Io: fd N)
  %48 = getelementptr i8, i8* %2, i32 8
  %49 = bitcast i8* %48 to i32*
  store i32 %47, i32* %49
; # (val $OutFDs)
  %50 = load i32, i32* @$OutFDs
; # (>= (Io: fd N) (val $OutFDs))
  %51 = icmp sge i32 %47, %50
  br i1 %51, label %$14, label %$15
$15:
  %52 = phi i64 [%46, %$8] ; # X
  %53 = phi i32 [%47, %$8] ; # N
; # (val $OutFiles)
  %54 = load i8**, i8*** @$OutFiles
; # (ofs (val $OutFiles) N)
  %55 = getelementptr i8*, i8** %54, i32 %53
; # (val (ofs (val $OutFiles) N))
  %56 = load i8*, i8** %55
; # (=0 (val (ofs (val $OutFiles) N)))
  %57 = icmp eq i8* %56, null
  br label %$14
$14:
  %58 = phi i64 [%46, %$8], [%52, %$15] ; # X
  %59 = phi i32 [%47, %$8], [%53, %$15] ; # N
  %60 = phi i1 [1, %$8], [%57, %$15] ; # ->
  br i1 %60, label %$16, label %$17
$16:
  %61 = phi i64 [%58, %$14] ; # X
  %62 = phi i32 [%59, %$14] ; # N
; # (badFd Exe X)
  call void @badFd(i64 %0, i64 %61)
  unreachable
$17:
  %63 = phi i64 [%58, %$14] ; # X
  %64 = phi i32 [%59, %$14] ; # N
  br label %$2
$5:
  %65 = phi i64 [%9, %$3] ; # X
; # (sym? X)
  %66 = and i64 %65, 8
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$19, label %$18
$19:
  %68 = phi i64 [%65, %$5] ; # X
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %69 = call i64 @xName(i64 %0, i64 %68)
; # (pathSize Nm)
  %70 = call i64 @pathSize(i64 %69)
; # (b8 (pathSize Nm))
  %71 = alloca i8, i64 %70
; # (pathString Nm (b8 (pathSize Nm)))
  %72 = call i8* @pathString(i64 %69, i8* %71)
; # (val S)
  %73 = load i8, i8* %72
; # (== (val S) (char "+"))
  %74 = icmp eq i8 %73, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %74, label %$20, label %$21
$20:
  %75 = phi i64 [%68, %$19] ; # X
  %76 = phi i8* [%72, %$19] ; # S
; # (ofs S 1)
  %77 = getelementptr i8, i8* %76, i32 1
  br label %$21
$21:
  %78 = phi i64 [%68, %$19], [%75, %$20] ; # X
  %79 = phi i8* [%72, %$19], [%77, %$20] ; # S
; # (while (lt0 (Io: fd (if Flg (openWrAppend S) (openWr S)))) (unles...
  br label %$22
$22:
  %80 = phi i64 [%78, %$21], [%100, %$31] ; # X
  %81 = phi i8* [%79, %$21], [%101, %$31] ; # S
; # (Io: fd (if Flg (openWrAppend S) (openWr S)))
  %82 = getelementptr i8, i8* %2, i32 8
  %83 = bitcast i8* %82 to i32*
  br i1 %74, label %$23, label %$24
$23:
  %84 = phi i64 [%80, %$22] ; # X
  %85 = phi i8* [%81, %$22] ; # S
  %86 = call i32 @openWrAppend(i8* %85)
  br label %$25
$24:
  %87 = phi i64 [%80, %$22] ; # X
  %88 = phi i8* [%81, %$22] ; # S
  %89 = call i32 @openWr(i8* %88)
  br label %$25
$25:
  %90 = phi i64 [%84, %$23], [%87, %$24] ; # X
  %91 = phi i8* [%85, %$23], [%88, %$24] ; # S
  %92 = phi i32 [%86, %$23], [%89, %$24] ; # ->
  store i32 %92, i32* %83
; # (lt0 (Io: fd (if Flg (openWrAppend S) (openWr S))))
  %93 = icmp slt i32 %92, 0
  br i1 %93, label %$26, label %$27
$26:
  %94 = phi i64 [%90, %$25] ; # X
  %95 = phi i8* [%91, %$25] ; # S
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %96 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %97 = icmp eq i32 %96, 2
  br i1 %97, label %$29, label %$28
$28:
  %98 = phi i64 [%94, %$26] ; # X
  %99 = phi i8* [%95, %$26] ; # S
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %98)
  unreachable
$29:
  %100 = phi i64 [%94, %$26] ; # X
  %101 = phi i8* [%95, %$26] ; # S
; # (sigChk Exe)
  %102 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %103 = icmp ne i32 %102, 0
  br i1 %103, label %$30, label %$31
$30:
  call void @sighandler(i64 %0)
  br label %$31
$31:
  br label %$22
$27:
  %104 = phi i64 [%90, %$25] ; # X
  %105 = phi i8* [%91, %$25] ; # S
; # (Io: pid 1)
  %106 = getelementptr i8, i8* %2, i32 12
  %107 = bitcast i8* %106 to i32*
  store i32 1, i32* %107
; # (Io: fd)
  %108 = getelementptr i8, i8* %2, i32 8
  %109 = bitcast i8* %108 to i32*
  %110 = load i32, i32* %109
; # (initOutFile (Io: fd))
  %111 = call i8* @initOutFile(i32 %110)
; # (Io: fd)
  %112 = getelementptr i8, i8* %2, i32 8
  %113 = bitcast i8* %112 to i32*
  %114 = load i32, i32* %113
; # (closeOnExec Exe (Io: fd))
  call void @closeOnExec(i64 %0, i32 %114)
  br label %$2
$18:
  %115 = phi i64 [%65, %$5] ; # X
; # (let (Pfd (b32 2) Av (b8* (inc (length X))) Cmd (xName Exe (xSym ...
; # (b32 2)
  %116 = alloca i32, i64 2
; # (length X)
  br label %$32
$32:
  %117 = phi i64 [%115, %$18], [%126, %$33] ; # X
  %118 = phi i64 [0, %$18], [%123, %$33] ; # N
  %119 = and i64 %117, 15
  %120 = icmp eq i64 %119, 0
  br i1 %120, label %$33, label %$34
$33:
  %121 = phi i64 [%117, %$32] ; # X
  %122 = phi i64 [%118, %$32] ; # N
  %123 = add i64 %122, 1
  %124 = inttoptr i64 %121 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
  br label %$32
$34:
  %127 = phi i64 [%117, %$32] ; # X
  %128 = phi i64 [%118, %$32] ; # N
; # (inc (length X))
  %129 = add i64 %128, 1
; # (b8* (inc (length X)))
  %130 = alloca i8*, i64 %129
; # (car X)
  %131 = inttoptr i64 %115 to i64*
  %132 = load i64, i64* %131
; # (xSym (car X))
  %133 = call i64 @xSym(i64 %132)
; # (xName Exe (xSym (car X)))
  %134 = call i64 @xName(i64 %0, i64 %133)
; # (when (lt0 (pipe Pfd)) (pipeErr Exe))
; # (pipe Pfd)
  %135 = call i32 @pipe(i32* %116)
; # (lt0 (pipe Pfd))
  %136 = icmp slt i32 %135, 0
  br i1 %136, label %$35, label %$36
$35:
  %137 = phi i64 [%115, %$34] ; # X
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$36:
  %138 = phi i64 [%115, %$34] ; # X
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %139 = call i64 @pathSize(i64 %134)
; # (b8 (pathSize Cmd))
  %140 = alloca i8, i64 %139
; # (pathString Cmd (b8 (pathSize Cmd)))
  %141 = call i8* @pathString(i64 %134, i8* %140)
  store i8* %141, i8** %130
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (xSym (car X...
; # (while (pair (shift X)) (let Nm (xName Exe (xSym (car X))) (set (...
  br label %$37
$37:
  %142 = phi i64 [%138, %$36], [%149, %$38] ; # X
  %143 = phi i8** [%130, %$36], [%155, %$38] ; # A
; # (shift X)
  %144 = inttoptr i64 %142 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (pair (shift X))
  %147 = and i64 %146, 15
  %148 = icmp eq i64 %147, 0
  br i1 %148, label %$38, label %$39
$38:
  %149 = phi i64 [%146, %$37] ; # X
  %150 = phi i8** [%143, %$37] ; # A
; # (let Nm (xName Exe (xSym (car X))) (set (inc 'A) (bufString Nm (b...
; # (car X)
  %151 = inttoptr i64 %149 to i64*
  %152 = load i64, i64* %151
; # (xSym (car X))
  %153 = call i64 @xSym(i64 %152)
; # (xName Exe (xSym (car X)))
  %154 = call i64 @xName(i64 %0, i64 %153)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %155 = getelementptr i8*, i8** %150, i32 1
; # (bufSize Nm)
  %156 = call i64 @bufSize(i64 %154)
; # (b8 (bufSize Nm))
  %157 = alloca i8, i64 %156
; # (bufString Nm (b8 (bufSize Nm)))
  %158 = call i8* @bufString(i64 %154, i8* %157)
  store i8* %158, i8** %155
  br label %$37
$39:
  %159 = phi i64 [%146, %$37] ; # X
  %160 = phi i8** [%143, %$37] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %161 = getelementptr i8*, i8** %160, i32 1
  store i8* null, i8** %161
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (setpgid 0 0) (close (...
; # (fork)
  %162 = call i32 @fork()
; # (lt0 (fork))
  %163 = icmp slt i32 %162, 0
  br i1 %163, label %$42, label %$41
$42:
  %164 = phi i64 [%159, %$39] ; # X
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$41:
  %165 = phi i64 [%159, %$39] ; # X
; # (=0 @)
  %166 = icmp eq i32 %162, 0
  br i1 %166, label %$44, label %$43
$44:
  %167 = phi i64 [%165, %$41] ; # X
; # (setpgid 0 0)
  %168 = call i32 @setpgid(i32 0, i32 0)
; # (val 2 Pfd)
  %169 = getelementptr i32, i32* %116, i32 1
  %170 = load i32, i32* %169
; # (close (val 2 Pfd))
  %171 = call i32 @close(i32 %170)
; # (when (val Pfd) (dup2 @ 0) (close @))
; # (val Pfd)
  %172 = load i32, i32* %116
  %173 = icmp ne i32 %172, 0
  br i1 %173, label %$45, label %$46
$45:
  %174 = phi i64 [%167, %$44] ; # X
; # (dup2 @ 0)
  %175 = call i32 @dup2(i32 %172, i32 0)
; # (close @)
  %176 = call i32 @close(i32 %172)
  br label %$46
$46:
  %177 = phi i64 [%167, %$44], [%174, %$45] ; # X
; # (val Av)
  %178 = load i8*, i8** %130
; # (execvp (val Av) Av)
  %179 = call i32 @execvp(i8* %178, i8** %130)
; # (val Av)
  %180 = load i8*, i8** %130
; # (execErr (val Av))
  call void @execErr(i8* %180)
  unreachable
$43:
  %181 = phi i64 [%165, %$41] ; # X
  br label %$40
$40:
  %182 = phi i64 [%181, %$43] ; # X
  %183 = phi i64 [0, %$43] ; # ->
; # (Io: pid @)
  %184 = getelementptr i8, i8* %2, i32 12
  %185 = bitcast i8* %184 to i32*
  store i32 %162, i32* %185
; # (setpgid (Io: pid @) 0)
  %186 = call i32 @setpgid(i32 %162, i32 0)
; # (val Pfd)
  %187 = load i32, i32* %116
; # (close (val Pfd))
  %188 = call i32 @close(i32 %187)
; # (let F (Io: fd (val 2 Pfd)) (initOutFile F) (closeOnExec Exe F))
; # (Io: fd (val 2 Pfd))
  %189 = getelementptr i8, i8* %2, i32 8
  %190 = bitcast i8* %189 to i32*
  %191 = getelementptr i32, i32* %116, i32 1
  %192 = load i32, i32* %191
  store i32 %192, i32* %190
; # (initOutFile F)
  %193 = call i8* @initOutFile(i32 %192)
; # (closeOnExec Exe F)
  call void @closeOnExec(i64 %0, i32 %192)
  br label %$2
$2:
  %194 = phi i64 [%4, %$4], [%63, %$17], [%104, %$27], [%182, %$40] ; # X
  ret void
}

define void @erOpen(i64, i64, i8*) {
$1:
; # (let Io: (ioFrame P) (Io: fd (dup 2)) (let Fd (if (nil? (needSymb...
; # (Io: fd (dup 2))
  %3 = getelementptr i8, i8* %2, i32 8
  %4 = bitcast i8* %3 to i32*
  %5 = call i32 @dup(i32 2)
  store i32 %5, i32* %4
; # (let Fd (if (nil? (needSymb Exe X)) (dup ((outFile (val $OutFile)...
; # (if (nil? (needSymb Exe X)) (dup ((outFile (val $OutFile)) fd)) (...
; # (needSymb Exe X)
  %6 = xor i64 %1, 8
  %7 = and i64 %6, 14
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %$3, label %$2
$2:
  call void @symErr(i64 %0, i64 %1)
  unreachable
$3:
; # (nil? (needSymb Exe X))
  %9 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %9, label %$4, label %$5
$4:
; # (val $OutFile)
  %10 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # ((outFile (val $OutFile)) fd)
  %11 = getelementptr i8, i8* %10, i32 8
  %12 = bitcast i8* %11 to i32*
  %13 = load i32, i32* %12
; # (dup ((outFile (val $OutFile)) fd))
  %14 = call i32 @dup(i32 %13)
  br label %$6
$5:
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %15 = call i64 @xName(i64 %0, i64 %1)
; # (pathSize Nm)
  %16 = call i64 @pathSize(i64 %15)
; # (b8 (pathSize Nm))
  %17 = alloca i8, i64 %16
; # (pathString Nm (b8 (pathSize Nm)))
  %18 = call i8* @pathString(i64 %15, i8* %17)
; # (val S)
  %19 = load i8, i8* %18
; # (== (val S) (char "+"))
  %20 = icmp eq i8 %19, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %20, label %$7, label %$8
$7:
  %21 = phi i8* [%18, %$5] ; # S
; # (ofs S 1)
  %22 = getelementptr i8, i8* %21, i32 1
  br label %$8
$8:
  %23 = phi i8* [%18, %$5], [%22, %$7] ; # S
; # (while (lt0 (if Flg (openWrAppend S) (openWr S))) (unless (== (gE...
  br label %$9
$9:
  %24 = phi i8* [%23, %$8], [%36, %$18] ; # S
; # (if Flg (openWrAppend S) (openWr S))
  br i1 %20, label %$10, label %$11
$10:
  %25 = phi i8* [%24, %$9] ; # S
; # (openWrAppend S)
  %26 = call i32 @openWrAppend(i8* %25)
  br label %$12
$11:
  %27 = phi i8* [%24, %$9] ; # S
; # (openWr S)
  %28 = call i32 @openWr(i8* %27)
  br label %$12
$12:
  %29 = phi i8* [%25, %$10], [%27, %$11] ; # S
  %30 = phi i32 [%26, %$10], [%28, %$11] ; # ->
; # (lt0 (if Flg (openWrAppend S) (openWr S)))
  %31 = icmp slt i32 %30, 0
  br i1 %31, label %$13, label %$14
$13:
  %32 = phi i8* [%29, %$12] ; # S
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %33 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %34 = icmp eq i32 %33, 2
  br i1 %34, label %$16, label %$15
$15:
  %35 = phi i8* [%32, %$13] ; # S
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %1)
  unreachable
$16:
  %36 = phi i8* [%32, %$13] ; # S
; # (sigChk Exe)
  %37 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %38 = icmp ne i32 %37, 0
  br i1 %38, label %$17, label %$18
$17:
  call void @sighandler(i64 %0)
  br label %$18
$18:
  br label %$9
$14:
  %39 = phi i8* [%29, %$12] ; # S
; # (closeOnExec Exe @)
  call void @closeOnExec(i64 %0, i32 %30)
  br label %$6
$6:
  %40 = phi i32 [%14, %$4], [%30, %$14] ; # ->
; # (dup2 Fd 2)
  %41 = call i32 @dup2(i32 %40, i32 2)
; # (close Fd)
  %42 = call i32 @close(i32 %40)
  ret void
}

define void @ctOpen(i64, i64, i8*) {
$1:
; # (let Io: (ioFrame P) (cond ((nil? (needSymb Exe X)) (Io: fd -1) (...
; # (cond ((nil? (needSymb Exe X)) (Io: fd -1) (rdLock (currFd Exe) 0...
; # (needSymb Exe X)
  %3 = xor i64 %1, 8
  %4 = and i64 %3, 14
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$4, label %$3
$3:
  call void @symErr(i64 %0, i64 %1)
  unreachable
$4:
; # (nil? (needSymb Exe X))
  %6 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %6, label %$6, label %$5
$6:
; # (Io: fd -1)
  %7 = getelementptr i8, i8* %2, i32 8
  %8 = bitcast i8* %7 to i32*
  store i32 -1, i32* %8
; # (currFd Exe)
  %9 = call i32 @currFd(i64 %0)
; # (rdLock (currFd Exe) 0 0 YES)
  %10 = call i32 @rdLock(i32 %9, i64 0, i64 0)
  br label %$2
$5:
; # (t? X)
  %11 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %11, label %$8, label %$7
$8:
; # (Io: fd -1)
  %12 = getelementptr i8, i8* %2, i32 8
  %13 = bitcast i8* %12 to i32*
  store i32 -1, i32* %13
; # (currFd Exe)
  %14 = call i32 @currFd(i64 %0)
; # (wrLock (currFd Exe) 0 0 YES)
  %15 = call i32 @wrLock(i32 %14, i64 0, i64 0, i32 1)
  br label %$2
$7:
; # (let (Nm (xName Exe X) S (pathString Nm (b8 (pathSize Nm))) Flg (...
; # (xName Exe X)
  %16 = call i64 @xName(i64 %0, i64 %1)
; # (pathSize Nm)
  %17 = call i64 @pathSize(i64 %16)
; # (b8 (pathSize Nm))
  %18 = alloca i8, i64 %17
; # (pathString Nm (b8 (pathSize Nm)))
  %19 = call i8* @pathString(i64 %16, i8* %18)
; # (val S)
  %20 = load i8, i8* %19
; # (== (val S) (char "+"))
  %21 = icmp eq i8 %20, 43
; # (when Flg (setq S (ofs S 1)))
  br i1 %21, label %$9, label %$10
$9:
  %22 = phi i8* [%19, %$7] ; # S
; # (ofs S 1)
  %23 = getelementptr i8, i8* %22, i32 1
  br label %$10
$10:
  %24 = phi i8* [%19, %$7], [%23, %$9] ; # S
; # (while (lt0 (openRdWrCreate S)) (unless (== (gErrno) EINTR) (open...
  br label %$11
$11:
  %25 = phi i8* [%24, %$10], [%32, %$17] ; # S
; # (openRdWrCreate S)
  %26 = call i32 @openRdWrCreate(i8* %25)
; # (lt0 (openRdWrCreate S))
  %27 = icmp slt i32 %26, 0
  br i1 %27, label %$12, label %$13
$12:
  %28 = phi i8* [%25, %$11] ; # S
; # (unless (== (gErrno) EINTR) (openErr Exe X))
; # (gErrno)
  %29 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %30 = icmp eq i32 %29, 2
  br i1 %30, label %$15, label %$14
$14:
  %31 = phi i8* [%28, %$12] ; # S
; # (openErr Exe X)
  call void @openErr(i64 %0, i64 %1)
  unreachable
$15:
  %32 = phi i8* [%28, %$12] ; # S
; # (sigChk Exe)
  %33 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %34 = icmp ne i32 %33, 0
  br i1 %34, label %$16, label %$17
$16:
  call void @sighandler(i64 %0)
  br label %$17
$17:
  br label %$11
$13:
  %35 = phi i8* [%25, %$11] ; # S
; # (let Fd (Io: fd @) (if Flg (rdLock Fd 0 0 YES) (wrLock Fd 0 0 YES...
; # (Io: fd @)
  %36 = getelementptr i8, i8* %2, i32 8
  %37 = bitcast i8* %36 to i32*
  store i32 %26, i32* %37
; # (if Flg (rdLock Fd 0 0 YES) (wrLock Fd 0 0 YES))
  br i1 %21, label %$18, label %$19
$18:
  %38 = phi i8* [%35, %$13] ; # S
; # (rdLock Fd 0 0 YES)
  %39 = call i32 @rdLock(i32 %26, i64 0, i64 0)
  br label %$20
$19:
  %40 = phi i8* [%35, %$13] ; # S
; # (wrLock Fd 0 0 YES)
  %41 = call i32 @wrLock(i32 %26, i64 0, i64 0, i32 1)
  br label %$20
$20:
  %42 = phi i8* [%38, %$18], [%40, %$19] ; # S
  %43 = phi i32 [%39, %$18], [%41, %$19] ; # ->
; # (closeOnExec Exe Fd)
  call void @closeOnExec(i64 %0, i32 %26)
  br label %$2
$2:
  ret void
}

define i32 @waitTty() {
$1:
; # (waitFd 0 0 292MY)
  %0 = call i64 @waitFd(i64 0, i32 0, i64 9223372036854775807)
  ret i32 0
}

define i32 @_getStdin() {
$1:
; # (let In: (inFile (val $InFile)) (set $Chr (cond ((=0 (In:)) -1) (...
; # (val $InFile)
  %0 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (set $Chr (cond ((=0 (In:)) -1) ((In: fd) (if (and (== (In: ix) (...
; # (cond ((=0 (In:)) -1) ((In: fd) (if (and (== (In: ix) (In: cnt)) ...
; # (In:)
; # (=0 (In:))
  %1 = icmp eq i8* %0, null
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (In: fd)
  %2 = getelementptr i8, i8* %0, i32 16
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %$6, label %$5
$6:
; # (if (and (== (In: ix) (In: cnt)) (or (lt0 (In: ix)) (=0 (slow (In...
; # (and (== (In: ix) (In: cnt)) (or (lt0 (In: ix)) (=0 (slow (In:)))...
; # (In: ix)
  %6 = bitcast i8* %0 to i64*
  %7 = load i64, i64* %6
; # (In: cnt)
  %8 = getelementptr i8, i8* %0, i32 8
  %9 = bitcast i8* %8 to i64*
  %10 = load i64, i64* %9
; # (== (In: ix) (In: cnt))
  %11 = icmp eq i64 %7, %10
  br i1 %11, label %$8, label %$7
$8:
; # (or (lt0 (In: ix)) (=0 (slow (In:))))
; # (In: ix)
  %12 = bitcast i8* %0 to i64*
  %13 = load i64, i64* %12
; # (lt0 (In: ix))
  %14 = icmp slt i64 %13, 0
  br i1 %14, label %$9, label %$10
$10:
; # (In:)
; # (slow (In:))
  %15 = call i64 @slow(i8* %0)
; # (=0 (slow (In:)))
  %16 = icmp eq i64 %15, 0
  br label %$9
$9:
  %17 = phi i1 [1, %$8], [%16, %$10] ; # ->
  br label %$7
$7:
  %18 = phi i1 [0, %$6], [%17, %$9] ; # ->
  br i1 %18, label %$11, label %$12
$11:
  br label %$13
$12:
; # (let I (In: ix) (prog1 (i32 (val (ofs (In: (buf)) I))) (when (== ...
; # (In: ix)
  %19 = bitcast i8* %0 to i64*
  %20 = load i64, i64* %19
; # (prog1 (i32 (val (ofs (In: (buf)) I))) (when (== @ (char "^J")) (...
; # (In: (buf))
  %21 = getelementptr i8, i8* %0, i32 40
; # (ofs (In: (buf)) I)
  %22 = getelementptr i8, i8* %21, i64 %20
; # (val (ofs (In: (buf)) I))
  %23 = load i8, i8* %22
; # (i32 (val (ofs (In: (buf)) I)))
  %24 = zext i8 %23 to i32
; # (when (== @ (char "^J")) (In: line (+ (In: line) 1)))
; # (== @ (char "^J"))
  %25 = icmp eq i32 %24, 10
  br i1 %25, label %$14, label %$15
$14:
; # (In: line (+ (In: line) 1))
  %26 = getelementptr i8, i8* %0, i32 32
  %27 = bitcast i8* %26 to i32*
  %28 = getelementptr i8, i8* %0, i32 32
  %29 = bitcast i8* %28 to i32*
  %30 = load i32, i32* %29
  %31 = add i32 %30, 1
  store i32 %31, i32* %27
  br label %$15
$15:
; # (In: ix (+ I 1))
  %32 = bitcast i8* %0 to i64*
  %33 = add i64 %20, 1
  store i64 %33, i64* %32
  br label %$13
$13:
  %34 = phi i32 [-1, %$11], [%24, %$15] ; # ->
  br label %$2
$5:
; # (isatty 0)
  %35 = call i32 @isatty(i32 0)
; # (=0 (isatty 0))
  %36 = icmp eq i32 %35, 0
  br i1 %36, label %$17, label %$16
$17:
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$16:
; # (let P (val $LinePtr) (unless P (initReadline) (free (val $LineBu...
; # (val $LinePtr)
  %37 = load i8*, i8** @$LinePtr
; # (unless P (initReadline) (free (val $LineBuf)) (unless (setq P (s...
  %38 = icmp ne i8* %37, null
  br i1 %38, label %$19, label %$18
$18:
  %39 = phi i8* [%37, %$16] ; # P
; # (initReadline)
  call void @initReadline()
; # (val $LineBuf)
  %40 = load i8*, i8** @$LineBuf
; # (free (val $LineBuf))
  call void @free(i8* %40)
; # (unless (setq P (set $LineBuf (readline (val $LinePrmt)))) (wrnl)...
; # (set $LineBuf (readline (val $LinePrmt)))
; # (val $LinePrmt)
  %41 = load i8*, i8** @$LinePrmt
; # (readline (val $LinePrmt))
  %42 = call i8* @readline(i8* %41)
  store i8* %42, i8** @$LineBuf
  %43 = icmp ne i8* %42, null
  br i1 %43, label %$21, label %$20
$20:
  %44 = phi i8* [%42, %$18] ; # P
; # (wrnl)
  %45 = call i64 @wrnl()
; # (when (or (val $Bind) (== (val $LinePrmt) $Indent)) (err 0 0 $Emp...
; # (or (val $Bind) (== (val $LinePrmt) $Indent))
; # (val $Bind)
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %47 = load i64, i64* %46
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$22, label %$23
$23:
  %49 = phi i8* [%44, %$20] ; # P
; # (val $LinePrmt)
  %50 = load i8*, i8** @$LinePrmt
; # (== (val $LinePrmt) $Indent)
  %51 = icmp eq i8* %50, bitcast ([4 x i8]* @$Indent to i8*)
  br label %$22
$22:
  %52 = phi i8* [%44, %$20], [%49, %$23] ; # P
  %53 = phi i1 [1, %$20], [%51, %$23] ; # ->
  br i1 %53, label %$24, label %$25
$24:
  %54 = phi i8* [%52, %$22] ; # P
; # (err 0 0 $Empty null)
  call void @err(i64 0, i64 0, i8* bitcast ([1 x i8]* @$Empty to i8*), i8* null)
  unreachable
$25:
  %55 = phi i8* [%52, %$22] ; # P
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$21:
  %56 = phi i8* [%42, %$18] ; # P
; # (set $LinePrmt $Indent)
  store i8* bitcast ([4 x i8]* @$Indent to i8*), i8** @$LinePrmt
; # (unless (or (=0 (val P)) (== @ 32) (and (currentLine) (=0 (strcmp...
; # (or (=0 (val P)) (== @ 32) (and (currentLine) (=0 (strcmp @ P))))...
; # (val P)
  %57 = load i8, i8* %56
; # (=0 (val P))
  %58 = icmp eq i8 %57, 0
  br i1 %58, label %$26, label %$27
$27:
  %59 = phi i8* [%56, %$21] ; # P
; # (== @ 32)
  %60 = icmp eq i8 %57, 32
  br i1 %60, label %$26, label %$28
$28:
  %61 = phi i8* [%59, %$27] ; # P
; # (and (currentLine) (=0 (strcmp @ P)))
; # (currentLine)
  %62 = call i8* @currentLine()
  %63 = icmp ne i8* %62, null
  br i1 %63, label %$30, label %$29
$30:
  %64 = phi i8* [%61, %$28] ; # P
; # (strcmp @ P)
  %65 = call i32 @strcmp(i8* %62, i8* %64)
; # (=0 (strcmp @ P))
  %66 = icmp eq i32 %65, 0
  br label %$29
$29:
  %67 = phi i8* [%61, %$28], [%64, %$30] ; # P
  %68 = phi i1 [0, %$28], [%66, %$30] ; # ->
  br label %$26
$26:
  %69 = phi i8* [%56, %$21], [%59, %$27], [%67, %$29] ; # P
  %70 = phi i1 [1, %$21], [1, %$27], [%68, %$29] ; # ->
  br i1 %70, label %$32, label %$31
$31:
  %71 = phi i8* [%69, %$26] ; # P
; # (add_history P)
  call void @add_history(i8* %71)
  br label %$32
$32:
  %72 = phi i8* [%69, %$26], [%71, %$31] ; # P
  br label %$19
$19:
  %73 = phi i8* [%37, %$16], [%72, %$32] ; # P
; # (nond ((val P) (set $LinePtr null) (char "^J")) (NIL (set $LinePt...
; # (val P)
  %74 = load i8, i8* %73
  %75 = icmp ne i8 %74, 0
  br i1 %75, label %$34, label %$35
$35:
  %76 = phi i8* [%73, %$19] ; # P
; # (set $LinePtr null)
  store i8* null, i8** @$LinePtr
  br label %$33
$34:
  %77 = phi i8* [%73, %$19] ; # P
; # (set $LinePtr (inc P))
; # (inc P)
  %78 = getelementptr i8, i8* %77, i32 1
  store i8* %78, i8** @$LinePtr
; # (i32 @)
  %79 = zext i8 %74 to i32
  br label %$33
$33:
  %80 = phi i8* [%76, %$35], [%77, %$34] ; # P
  %81 = phi i32 [10, %$35], [%79, %$34] ; # ->
  br label %$2
$2:
  %82 = phi i32 [-1, %$4], [%34, %$13], [%81, %$33] ; # ->
  store i32 %82, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  ret i32 %82
}

define i32 @getChar(i32) {
$1:
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (let B (ifn...
; # (>= 127 C)
  %1 = icmp sge i32 127, %0
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (== C (hex "FF"))
  %2 = icmp eq i32 %0, 255
  br i1 %2, label %$6, label %$5
$6:
; # (i32 TOP)
  br label %$2
$5:
; # (let B (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (h...
; # (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (hex "10"...
; # (& C (hex "20"))
  %3 = and i32 %0, 32
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %$8, label %$7
$7:
; # (& C (hex "1F"))
  %5 = and i32 %0, 31
  br label %$9
$8:
; # (let A (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) ...
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) (& (cal...
; # (& C (hex "10"))
  %6 = and i32 %0, 16
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %$11, label %$10
$10:
; # (& C (hex "0F"))
  %8 = and i32 %0, 15
  br label %$12
$11:
; # (& C 7)
  %9 = and i32 %0, 7
; # (shl (& C 7) 6)
  %10 = shl i32 %9, 6
; # (call $Get)
  %11 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %12 = call i32 %11()
; # (& (call $Get) (hex "3F"))
  %13 = and i32 %12, 63
; # (| (shl (& C 7) 6) (& (call $Get) (hex "3F")))
  %14 = or i32 %10, %13
  br label %$12
$12:
  %15 = phi i32 [%8, %$10], [%14, %$11] ; # ->
; # (shl A 6)
  %16 = shl i32 %15, 6
; # (call $Get)
  %17 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %18 = call i32 %17()
; # (& (call $Get) (hex "3F"))
  %19 = and i32 %18, 63
; # (| (shl A 6) (& (call $Get) (hex "3F")))
  %20 = or i32 %16, %19
  br label %$9
$9:
  %21 = phi i32 [%5, %$7], [%20, %$12] ; # ->
; # (shl B 6)
  %22 = shl i32 %21, 6
; # (call $Get)
  %23 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %24 = call i32 %23()
; # (& (call $Get) (hex "3F"))
  %25 = and i32 %24, 63
; # (| (shl B 6) (& (call $Get) (hex "3F")))
  %26 = or i32 %22, %25
  br label %$2
$2:
  %27 = phi i32 [%0, %$4], [1114112, %$6], [%26, %$9] ; # ->
  ret i32 %27
}

define i32 @skipc(i32) {
$1:
; # (let Chr (val $Chr) (loop (while (>= 32 Chr) (when (lt0 (setq Chr...
; # (val $Chr)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (loop (while (>= 32 Chr) (when (lt0 (setq Chr (call $Get))) (ret ...
  br label %$2
$2:
  %2 = phi i32 [%1, %$1], [%25, %$12] ; # Chr
; # (while (>= 32 Chr) (when (lt0 (setq Chr (call $Get))) (ret Chr)))...
  br label %$3
$3:
  %3 = phi i32 [%2, %$2], [%10, %$7] ; # Chr
; # (>= 32 Chr)
  %4 = icmp sge i32 32, %3
  br i1 %4, label %$4, label %$5
$4:
  %5 = phi i32 [%3, %$3] ; # Chr
; # (when (lt0 (setq Chr (call $Get))) (ret Chr))
; # (call $Get)
  %6 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %7 = call i32 %6()
; # (lt0 (setq Chr (call $Get)))
  %8 = icmp slt i32 %7, 0
  br i1 %8, label %$6, label %$7
$6:
  %9 = phi i32 [%7, %$4] ; # Chr
; # (ret Chr)
  ret i32 %9
$7:
  %10 = phi i32 [%7, %$4] ; # Chr
  br label %$3
$5:
  %11 = phi i32 [%3, %$3] ; # Chr
; # (unless (== Chr C) (ret Chr))
; # (== Chr C)
  %12 = icmp eq i32 %11, %0
  br i1 %12, label %$9, label %$8
$8:
  %13 = phi i32 [%11, %$5] ; # Chr
; # (ret Chr)
  ret i32 %13
$9:
  %14 = phi i32 [%11, %$5] ; # Chr
; # (until (== (setq Chr (call $Get)) (char "^J")) (when (lt0 Chr) (r...
  br label %$10
$10:
  %15 = phi i32 [%14, %$9], [%22, %$14] ; # Chr
; # (call $Get)
  %16 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %17 = call i32 %16()
; # (== (setq Chr (call $Get)) (char "^J"))
  %18 = icmp eq i32 %17, 10
  br i1 %18, label %$12, label %$11
$11:
  %19 = phi i32 [%17, %$10] ; # Chr
; # (when (lt0 Chr) (ret Chr))
; # (lt0 Chr)
  %20 = icmp slt i32 %19, 0
  br i1 %20, label %$13, label %$14
$13:
  %21 = phi i32 [%19, %$11] ; # Chr
; # (ret Chr)
  ret i32 %21
$14:
  %22 = phi i32 [%19, %$11] ; # Chr
  br label %$10
$12:
  %23 = phi i32 [%17, %$10] ; # Chr
; # (call $Get)
  %24 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %25 = call i32 %24()
  br label %$2
}

define void @comment() {
$1:
; # (let Chr (call $Get) (if (== Chr (char "{")) (let N 0 (loop (? (l...
; # (call $Get)
  %0 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %1 = call i32 %0()
; # (if (== Chr (char "{")) (let N 0 (loop (? (lt0 (setq Chr (call $G...
; # (== Chr (char "{"))
  %2 = icmp eq i32 %1, 123
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i32 [%1, %$1] ; # Chr
; # (let N 0 (loop (? (lt0 (setq Chr (call $Get)))) (if (and (== Chr ...
; # (loop (? (lt0 (setq Chr (call $Get)))) (if (and (== Chr (char "#"...
  br label %$5
$5:
  %4 = phi i32 [%3, %$2], [%40, %$12] ; # Chr
  %5 = phi i64 [0, %$2], [%41, %$12] ; # N
; # (? (lt0 (setq Chr (call $Get))))
; # (call $Get)
  %6 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %7 = call i32 %6()
; # (lt0 (setq Chr (call $Get)))
  %8 = icmp slt i32 %7, 0
  br i1 %8, label %$7, label %$6
$6:
  %9 = phi i32 [%7, %$5] ; # Chr
  %10 = phi i64 [%5, %$5] ; # N
; # (if (and (== Chr (char "#")) (== (setq Chr (call $Get)) (char "{"...
; # (and (== Chr (char "#")) (== (setq Chr (call $Get)) (char "{")))
; # (== Chr (char "#"))
  %11 = icmp eq i32 %9, 35
  br i1 %11, label %$9, label %$8
$9:
  %12 = phi i32 [%9, %$6] ; # Chr
  %13 = phi i64 [%10, %$6] ; # N
; # (call $Get)
  %14 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %15 = call i32 %14()
; # (== (setq Chr (call $Get)) (char "{"))
  %16 = icmp eq i32 %15, 123
  br label %$8
$8:
  %17 = phi i32 [%9, %$6], [%15, %$9] ; # Chr
  %18 = phi i64 [%10, %$6], [%13, %$9] ; # N
  %19 = phi i1 [0, %$6], [%16, %$9] ; # ->
  br i1 %19, label %$10, label %$11
$10:
  %20 = phi i32 [%17, %$8] ; # Chr
  %21 = phi i64 [%18, %$8] ; # N
; # (inc 'N)
  %22 = add i64 %21, 1
  br label %$12
$11:
  %23 = phi i32 [%17, %$8] ; # Chr
  %24 = phi i64 [%18, %$8] ; # N
; # (? (and (== Chr (char "}")) (== (setq Chr (call $Get)) (char "#")...
; # (and (== Chr (char "}")) (== (setq Chr (call $Get)) (char "#")) (...
; # (== Chr (char "}"))
  %25 = icmp eq i32 %23, 125
  br i1 %25, label %$14, label %$13
$14:
  %26 = phi i32 [%23, %$11] ; # Chr
  %27 = phi i64 [%24, %$11] ; # N
; # (call $Get)
  %28 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %29 = call i32 %28()
; # (== (setq Chr (call $Get)) (char "#"))
  %30 = icmp eq i32 %29, 35
  br i1 %30, label %$15, label %$13
$15:
  %31 = phi i32 [%29, %$14] ; # Chr
  %32 = phi i64 [%27, %$14] ; # N
; # (dec 'N)
  %33 = sub i64 %32, 1
; # (lt0 (dec 'N))
  %34 = icmp slt i64 %33, 0
  br label %$13
$13:
  %35 = phi i32 [%23, %$11], [%29, %$14], [%31, %$15] ; # Chr
  %36 = phi i64 [%24, %$11], [%27, %$14], [%33, %$15] ; # N
  %37 = phi i1 [0, %$11], [0, %$14], [%34, %$15] ; # ->
  br i1 %37, label %$7, label %$16
$16:
  %38 = phi i32 [%35, %$13] ; # Chr
  %39 = phi i64 [%36, %$13] ; # N
  br label %$12
$12:
  %40 = phi i32 [%20, %$10], [%38, %$16] ; # Chr
  %41 = phi i64 [%22, %$10], [%39, %$16] ; # N
  br label %$5
$7:
  %42 = phi i32 [%7, %$5], [%35, %$13] ; # Chr
  %43 = phi i64 [%5, %$5], [%36, %$13] ; # N
  %44 = phi i64 [0, %$5], [0, %$13] ; # ->
  br label %$4
$3:
  %45 = phi i32 [%1, %$1] ; # Chr
; # (until (== Chr (char "^J")) (? (lt0 Chr)) (setq Chr (call $Get)))...
  br label %$17
$17:
  %46 = phi i32 [%45, %$3], [%52, %$20] ; # Chr
; # (== Chr (char "^J"))
  %47 = icmp eq i32 %46, 10
  br i1 %47, label %$19, label %$18
$18:
  %48 = phi i32 [%46, %$17] ; # Chr
; # (? (lt0 Chr))
; # (lt0 Chr)
  %49 = icmp slt i32 %48, 0
  br i1 %49, label %$19, label %$20
$20:
  %50 = phi i32 [%48, %$18] ; # Chr
; # (call $Get)
  %51 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %52 = call i32 %51()
  br label %$17
$19:
  %53 = phi i32 [%46, %$17], [%48, %$18] ; # Chr
  br label %$4
$4:
  %54 = phi i32 [%42, %$7], [%53, %$19] ; # Chr
; # (call $Get)
  %55 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %56 = call i32 %55()
  ret void
}

define i32 @skip() {
$1:
; # (loop (let Chr (val $Chr) (when (lt0 Chr) (ret Chr)) (while (>= (...
  br label %$2
$2:
; # (let Chr (val $Chr) (when (lt0 Chr) (ret Chr)) (while (>= (char "...
; # (val $Chr)
  %0 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (when (lt0 Chr) (ret Chr))
; # (lt0 Chr)
  %1 = icmp slt i32 %0, 0
  br i1 %1, label %$3, label %$4
$3:
  %2 = phi i32 [%0, %$2] ; # Chr
; # (ret Chr)
  ret i32 %2
$4:
  %3 = phi i32 [%0, %$2] ; # Chr
; # (while (>= (char " ") Chr) (when (lt0 (setq Chr (call $Get))) (re...
  br label %$5
$5:
  %4 = phi i32 [%3, %$4], [%11, %$9] ; # Chr
; # (>= (char " ") Chr)
  %5 = icmp sge i32 32, %4
  br i1 %5, label %$6, label %$7
$6:
  %6 = phi i32 [%4, %$5] ; # Chr
; # (when (lt0 (setq Chr (call $Get))) (ret Chr))
; # (call $Get)
  %7 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %8 = call i32 %7()
; # (lt0 (setq Chr (call $Get)))
  %9 = icmp slt i32 %8, 0
  br i1 %9, label %$8, label %$9
$8:
  %10 = phi i32 [%8, %$6] ; # Chr
; # (ret Chr)
  ret i32 %10
$9:
  %11 = phi i32 [%8, %$6] ; # Chr
  br label %$5
$7:
  %12 = phi i32 [%4, %$5] ; # Chr
; # (unless (== Chr (char "#")) (ret Chr))
; # (== Chr (char "#"))
  %13 = icmp eq i32 %12, 35
  br i1 %13, label %$11, label %$10
$10:
  %14 = phi i32 [%12, %$7] ; # Chr
; # (ret Chr)
  ret i32 %14
$11:
  %15 = phi i32 [%12, %$7] ; # Chr
; # (comment)
  call void @comment()
  br label %$2
}

define i1 @testEsc(i32) {
$1:
; # (loop (? (lt0 Chr) NO) (? (== Chr (char "\^")) (when (== (setq Ch...
  br label %$2
$2:
  %1 = phi i32 [%0, %$1], [%70, %$37] ; # Chr
; # (? (lt0 Chr) NO)
; # (lt0 Chr)
  %2 = icmp slt i32 %1, 0
  br i1 %2, label %$5, label %$3
$5:
  %3 = phi i32 [%1, %$2] ; # Chr
  br label %$4
$3:
  %4 = phi i32 [%1, %$2] ; # Chr
; # (? (== Chr (char "\^")) (when (== (setq Chr (call $Get)) (char "@...
; # (== Chr (char "\^"))
  %5 = icmp eq i32 %4, 94
  br i1 %5, label %$7, label %$6
$7:
  %6 = phi i32 [%4, %$3] ; # Chr
; # (when (== (setq Chr (call $Get)) (char "@")) (badInput))
; # (call $Get)
  %7 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %8 = call i32 %7()
; # (== (setq Chr (call $Get)) (char "@"))
  %9 = icmp eq i32 %8, 64
  br i1 %9, label %$8, label %$9
$8:
  %10 = phi i32 [%8, %$7] ; # Chr
; # (badInput)
  call void @badInput()
  unreachable
$9:
  %11 = phi i32 [%8, %$7] ; # Chr
; # (set $Chr (if (== Chr (char "?")) 127 (& Chr (hex "1F"))))
; # (if (== Chr (char "?")) 127 (& Chr (hex "1F")))
; # (== Chr (char "?"))
  %12 = icmp eq i32 %11, 63
  br i1 %12, label %$10, label %$11
$10:
  %13 = phi i32 [%11, %$9] ; # Chr
  br label %$12
$11:
  %14 = phi i32 [%11, %$9] ; # Chr
; # (& Chr (hex "1F"))
  %15 = and i32 %14, 31
  br label %$12
$12:
  %16 = phi i32 [%13, %$10], [%14, %$11] ; # Chr
  %17 = phi i32 [127, %$10], [%15, %$11] ; # ->
  store i32 %17, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$4
$6:
  %18 = phi i32 [%4, %$3] ; # Chr
; # (? (<> Chr (char "\\")) (set $Chr (getChar Chr)) YES)
; # (<> Chr (char "\\"))
  %19 = icmp ne i32 %18, 92
  br i1 %19, label %$14, label %$13
$14:
  %20 = phi i32 [%18, %$6] ; # Chr
; # (set $Chr (getChar Chr))
; # (getChar Chr)
  %21 = call i32 @getChar(i32 %20)
  store i32 %21, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$4
$13:
  %22 = phi i32 [%18, %$6] ; # Chr
; # (? (<> (char "^J") (setq Chr (call $Get))) (case Chr ((char "n") ...
; # (call $Get)
  %23 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %24 = call i32 %23()
; # (<> (char "^J") (setq Chr (call $Get)))
  %25 = icmp ne i32 10, %24
  br i1 %25, label %$16, label %$15
$16:
  %26 = phi i32 [%24, %$13] ; # Chr
; # (case Chr ((char "n") (set $Chr (char "^J"))) ((char "r") (set $C...
  switch i32 %26, label %$17 [
    i32 110, label %$19
    i32 114, label %$20
    i32 116, label %$21
  ]
$19:
  %27 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^J"))
  store i32 10, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$18
$20:
  %28 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^M"))
  store i32 13, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$18
$21:
  %29 = phi i32 [%26, %$16] ; # Chr
; # (set $Chr (char "^I"))
  store i32 9, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$18
$17:
  %30 = phi i32 [%26, %$16] ; # Chr
; # (when (and (>= Chr (char "0")) (>= (char "9") Chr)) (dec 'Chr (ch...
; # (and (>= Chr (char "0")) (>= (char "9") Chr))
; # (>= Chr (char "0"))
  %31 = icmp sge i32 %30, 48
  br i1 %31, label %$23, label %$22
$23:
  %32 = phi i32 [%30, %$17] ; # Chr
; # (>= (char "9") Chr)
  %33 = icmp sge i32 57, %32
  br label %$22
$22:
  %34 = phi i32 [%30, %$17], [%32, %$23] ; # Chr
  %35 = phi i1 [0, %$17], [%33, %$23] ; # ->
  br i1 %35, label %$24, label %$25
$24:
  %36 = phi i32 [%34, %$22] ; # Chr
; # (dec 'Chr (char "0"))
  %37 = sub i32 %36, 48
; # (until (== (call $Get) (char "\\")) (unless (and (>= (val $Chr) (...
  br label %$26
$26:
  %38 = phi i32 [%37, %$24], [%55, %$32] ; # Chr
; # (call $Get)
  %39 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %40 = call i32 %39()
; # (== (call $Get) (char "\\"))
  %41 = icmp eq i32 %40, 92
  br i1 %41, label %$28, label %$27
$27:
  %42 = phi i32 [%38, %$26] ; # Chr
; # (unless (and (>= (val $Chr) (char "0")) (>= (char "9") (val $Chr)...
; # (and (>= (val $Chr) (char "0")) (>= (char "9") (val $Chr)))
; # (val $Chr)
  %43 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (>= (val $Chr) (char "0"))
  %44 = icmp sge i32 %43, 48
  br i1 %44, label %$30, label %$29
$30:
  %45 = phi i32 [%42, %$27] ; # Chr
; # (val $Chr)
  %46 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (>= (char "9") (val $Chr))
  %47 = icmp sge i32 57, %46
  br label %$29
$29:
  %48 = phi i32 [%42, %$27], [%45, %$30] ; # Chr
  %49 = phi i1 [0, %$27], [%47, %$30] ; # ->
  br i1 %49, label %$32, label %$31
$31:
  %50 = phi i32 [%48, %$29] ; # Chr
; # (badInput)
  call void @badInput()
  unreachable
$32:
  %51 = phi i32 [%48, %$29] ; # Chr
; # (* Chr 10)
  %52 = mul i32 %51, 10
; # (val $Chr)
  %53 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (- (val $Chr) (char "0"))
  %54 = sub i32 %53, 48
; # (+ (* Chr 10) (- (val $Chr) (char "0")))
  %55 = add i32 %52, %54
  br label %$26
$28:
  %56 = phi i32 [%38, %$26] ; # Chr
  br label %$25
$25:
  %57 = phi i32 [%34, %$22], [%56, %$28] ; # Chr
; # (set $Chr Chr)
  store i32 %57, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$18
$18:
  %58 = phi i32 [%27, %$19], [%28, %$20], [%29, %$21], [%57, %$25] ; # Chr
  %59 = phi i32 [10, %$19], [13, %$20], [9, %$21], [%57, %$25] ; # ->
  br label %$4
$15:
  %60 = phi i32 [%24, %$13] ; # Chr
; # (loop (setq Chr (call $Get)) (? (and (<> Chr (char " ")) (<> Chr ...
  br label %$33
$33:
  %61 = phi i32 [%60, %$15], [%69, %$36] ; # Chr
; # (call $Get)
  %62 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %63 = call i32 %62()
; # (? (and (<> Chr (char " ")) (<> Chr (char "^I"))))
; # (and (<> Chr (char " ")) (<> Chr (char "^I")))
; # (<> Chr (char " "))
  %64 = icmp ne i32 %63, 32
  br i1 %64, label %$35, label %$34
$35:
  %65 = phi i32 [%63, %$33] ; # Chr
; # (<> Chr (char "^I"))
  %66 = icmp ne i32 %65, 9
  br label %$34
$34:
  %67 = phi i32 [%63, %$33], [%65, %$35] ; # Chr
  %68 = phi i1 [0, %$33], [%66, %$35] ; # ->
  br i1 %68, label %$37, label %$36
$36:
  %69 = phi i32 [%67, %$34] ; # Chr
  br label %$33
$37:
  %70 = phi i32 [%67, %$34] ; # Chr
  %71 = phi i64 [0, %$34] ; # ->
  br label %$2
$4:
  %72 = phi i32 [%3, %$5], [%16, %$12], [%20, %$14], [%58, %$18] ; # Chr
  %73 = phi i1 [0, %$5], [1, %$12], [1, %$14], [1, %$18] ; # ->
  ret i1 %73
}

define i64 @anonymous(i64) {
$1:
; # (let P (push 0 Nm) (unless (== (symByte P) (char "$")) (ret 0)) (...
; # (push 0 Nm)
  %1 = alloca i64, i64 2, align 16
  store i64 0, i64* %1
  %2 = getelementptr i64, i64* %1, i32 1
  store i64 %0, i64* %2
; # (unless (== (symByte P) (char "$")) (ret 0))
; # (symByte P)
  %3 = call i8 @symByte(i64* %1)
; # (== (symByte P) (char "$"))
  %4 = icmp eq i8 %3, 36
  br i1 %4, label %$3, label %$2
$2:
; # (ret 0)
  ret i64 0
$3:
; # (let B (- (symByte P) (char "0")) (unless (>= 7 B) (ret 0)) (let ...
; # (symByte P)
  %5 = call i8 @symByte(i64* %1)
; # (- (symByte P) (char "0"))
  %6 = sub i8 %5, 48
; # (unless (>= 7 B) (ret 0))
; # (>= 7 B)
  %7 = icmp uge i8 7, %6
  br i1 %7, label %$5, label %$4
$4:
; # (ret 0)
  ret i64 0
$5:
; # (let N (i64 B) (loop (? (=0 (symByte P)) (sym (shl N 4))) (? (> (...
; # (i64 B)
  %8 = zext i8 %6 to i64
; # (loop (? (=0 (symByte P)) (sym (shl N 4))) (? (> (- @ (char "0"))...
  br label %$6
$6:
  %9 = phi i64 [%8, %$5], [%22, %$10] ; # N
; # (? (=0 (symByte P)) (sym (shl N 4)))
; # (symByte P)
  %10 = call i8 @symByte(i64* %1)
; # (=0 (symByte P))
  %11 = icmp eq i8 %10, 0
  br i1 %11, label %$9, label %$7
$9:
  %12 = phi i64 [%9, %$6] ; # N
; # (shl N 4)
  %13 = shl i64 %12, 4
; # (sym (shl N 4))
  %14 = or i64 %13, 8
  br label %$8
$7:
  %15 = phi i64 [%9, %$6] ; # N
; # (? (> (- @ (char "0")) 7) 0)
; # (- @ (char "0"))
  %16 = sub i8 %10, 48
; # (> (- @ (char "0")) 7)
  %17 = icmp ugt i8 %16, 7
  br i1 %17, label %$11, label %$10
$11:
  %18 = phi i64 [%15, %$7] ; # N
  br label %$8
$10:
  %19 = phi i64 [%15, %$7] ; # N
; # (i64 @)
  %20 = zext i8 %16 to i64
; # (shl N 3)
  %21 = shl i64 %19, 3
; # (| (i64 @) (shl N 3))
  %22 = or i64 %20, %21
  br label %$6
$8:
  %23 = phi i64 [%12, %$9], [%18, %$11] ; # N
  %24 = phi i64 [%14, %$9], [0, %$11] ; # ->
  ret i64 %24
}

define i64 @rdAtom(i32) {
$1:
; # (let (Int (save (val $Intern)) P (push 4 NIL ZERO NIL)) (link (of...
; # (val $Intern)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %2 = load i64, i64* %1
; # (save (val $Intern))
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 %2, i64* %5
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %4 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %10
; # (push 4 NIL ZERO NIL)
  %11 = alloca i64, i64 4, align 16
  store i64 4, i64* %11
  %12 = getelementptr i64, i64* %11, i32 2
  store i64 2, i64* %12
; # (ofs P 2)
  %13 = getelementptr i64, i64* %11, i32 2
; # (link (ofs P 2))
  %14 = ptrtoint i64* %13 to i64
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
  %17 = inttoptr i64 %14 to i64*
  %18 = getelementptr i64, i64* %17, i32 1
  store i64 %16, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %14, i64* %19
; # (charSym Chr P)
  call void @charSym(i32 %0, i64* %11)
; # (val $Chr)
  %20 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (while (ge0 Chr) (if (== Chr (char "~")) (let S (requestSym (val ...
  br label %$2
$2:
  %21 = phi i32 [%20, %$1], [%52, %$7] ; # Chr
; # (ge0 Chr)
  %22 = icmp sge i32 %21, 0
  br i1 %22, label %$3, label %$4
$3:
  %23 = phi i32 [%21, %$2] ; # Chr
; # (if (== Chr (char "~")) (let S (requestSym (val 3 P)) (needNsp 0 ...
; # (== Chr (char "~"))
  %24 = icmp eq i32 %23, 126
  br i1 %24, label %$5, label %$6
$5:
  %25 = phi i32 [%23, %$3] ; # Chr
; # (let S (requestSym (val 3 P)) (needNsp 0 S) (set (set $Intern (an...
; # (val 3 P)
  %26 = getelementptr i64, i64* %11, i32 2
  %27 = load i64, i64* %26
; # (requestSym (val 3 P))
  %28 = call i64 @requestSym(i64 %27)
; # (needNsp 0 S)
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  %31 = and i64 %30, 15
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  %33 = inttoptr i64 %30 to i64*
  %34 = load i64, i64* %33
  %35 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 56) to i64), %34
  br label %$8
$8:
  %36 = phi i1 [0, %$5], [%35, %$9] ; # ->
  br i1 %36, label %$11, label %$10
$10:
  call void @symNspErr(i64 0, i64 %28)
  unreachable
$11:
; # (set (set $Intern (any $Cell)) S)
; # (set $Intern (any $Cell))
; # (any $Cell)
  %37 = ptrtoint i64* bitcast ([2 x i64]* @$Cell to i64*) to i64
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %37, i64* %38
  %39 = inttoptr i64 %37 to i64*
  store i64 %28, i64* %39
; # (set P 4 3 P ZERO)
  store i64 4, i64* %11
  %40 = getelementptr i64, i64* %11, i32 2
  store i64 2, i64* %40
  br label %$7
$6:
  %41 = phi i32 [%23, %$3] ; # Chr
; # (? (strchr $Delim Chr))
; # (strchr $Delim Chr)
  %42 = call i8* @strchr(i8* bitcast ([16 x i8]* @$Delim to i8*), i32 %41)
  %43 = icmp ne i8* %42, null
  br i1 %43, label %$4, label %$12
$12:
  %44 = phi i32 [%41, %$6] ; # Chr
; # (when (== Chr (char "\\")) (setq Chr (call $Get)))
; # (== Chr (char "\\"))
  %45 = icmp eq i32 %44, 92
  br i1 %45, label %$13, label %$14
$13:
  %46 = phi i32 [%44, %$12] ; # Chr
; # (call $Get)
  %47 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %48 = call i32 %47()
  br label %$14
$14:
  %49 = phi i32 [%44, %$12], [%48, %$13] ; # Chr
; # (charSym Chr P)
  call void @charSym(i32 %49, i64* %11)
  br label %$7
$7:
  %50 = phi i32 [%25, %$11], [%49, %$14] ; # Chr
; # (call $Get)
  %51 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %52 = call i32 %51()
  br label %$2
$4:
  %53 = phi i32 [%21, %$2], [%41, %$6] ; # Chr
; # (prog1 (let Nm (val 3 P) (cond ((== Nm ZERO) (badInput)) ((symToN...
; # (let Nm (val 3 P) (cond ((== Nm ZERO) (badInput)) ((symToNum Nm (...
; # (val 3 P)
  %54 = getelementptr i64, i64* %11, i32 2
  %55 = load i64, i64* %54
; # (cond ((== Nm ZERO) (badInput)) ((symToNum Nm (int (val $Scl)) (c...
; # (== Nm ZERO)
  %56 = icmp eq i64 %55, 2
  br i1 %56, label %$17, label %$16
$17:
  %57 = phi i32 [%53, %$4] ; # Chr
; # (badInput)
  call void @badInput()
  unreachable
$16:
  %58 = phi i32 [%53, %$4] ; # Chr
; # (val $Scl)
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 520) to i64) to i64*
  %60 = load i64, i64* %59
; # (int (val $Scl))
  %61 = lshr i64 %60, 4
; # (symToNum Nm (int (val $Scl)) (char ".") 0)
  %62 = call i64 @symToNum(i64 %55, i64 %61, i8 46, i8 0)
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$19, label %$18
$19:
  %64 = phi i32 [%58, %$16] ; # Chr
  br label %$15
$18:
  %65 = phi i32 [%58, %$16] ; # Chr
; # (anonymous Nm)
  %66 = call i64 @anonymous(i64 %55)
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$21, label %$20
$21:
  %68 = phi i32 [%65, %$18] ; # Chr
  br label %$15
$20:
  %69 = phi i32 [%65, %$18] ; # Chr
; # (requestSym Nm)
  %70 = call i64 @requestSym(i64 %55)
  br label %$15
$15:
  %71 = phi i32 [%64, %$19], [%68, %$21], [%69, %$20] ; # Chr
  %72 = phi i64 [%62, %$19], [%66, %$21], [%70, %$20] ; # ->
; # (set $Intern Int)
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %2, i64* %73
; # (drop *Safe)
  %74 = inttoptr i64 %4 to i64*
  %75 = getelementptr i64, i64* %74, i32 1
  %76 = load i64, i64* %75
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %76, i64* %77
  ret i64 %72
}

define i64 @rdList() {
$1:
; # (stkChk 0)
  %0 = load i8*, i8** @$StkLimit
  %1 = call i8* @llvm.stacksave()
  %2 = icmp ugt i8* %0, %1
  br i1 %2, label %$2, label %$3
$2:
  call void @stkErr(i64 0)
  unreachable
$3:
; # (call $Get)
  %3 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %4 = call i32 %3()
; # (let (P (push NIL NIL) X (loop (let C (skip) (when (== C (char ")...
; # (push NIL NIL)
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
; # (loop (let C (skip) (when (== C (char ")")) (call $Get) (ret $Nil...
  br label %$4
$4:
; # (let C (skip) (when (== C (char ")")) (call $Get) (ret $Nil)) (wh...
; # (skip)
  %7 = call i32 @skip()
; # (when (== C (char ")")) (call $Get) (ret $Nil))
; # (== C (char ")"))
  %8 = icmp eq i32 %7, 41
  br i1 %8, label %$5, label %$6
$5:
; # (call $Get)
  %9 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %10 = call i32 %9()
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$6:
; # (when (== C (char "]")) (ret $Nil))
; # (== C (char "]"))
  %11 = icmp eq i32 %7, 93
  br i1 %11, label %$7, label %$8
$7:
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$8:
; # (? (<> C (char "~")) (prog1 (set P (cons (read0 NO) $Nil)) (link ...
; # (<> C (char "~"))
  %12 = icmp ne i32 %7, 126
  br i1 %12, label %$11, label %$9
$11:
; # (prog1 (set P (cons (read0 NO) $Nil)) (link P))
; # (set P (cons (read0 NO) $Nil))
; # (read0 NO)
  %13 = call i64 @read0(i1 0)
; # (cons (read0 NO) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %15 = inttoptr i64 %6 to i64*
  store i64 %14, i64* %15
; # (link P)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %6 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  store i64 %17, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %20
  br label %$10
$9:
; # (call $Get)
  %21 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %22 = call i32 %21()
; # (let Y (set P (read0 NO)) (link P) (? (pair (setq Y (eval Y))) (w...
; # (set P (read0 NO))
; # (read0 NO)
  %23 = call i64 @read0(i1 0)
  %24 = inttoptr i64 %6 to i64*
  store i64 %23, i64* %24
; # (link P)
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %6 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %29
; # (? (pair (setq Y (eval Y))) (while (pair (cdr Y)) (shift Y)) Y)
; # (eval Y)
  %30 = and i64 %23, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$14, label %$13
$14:
  br label %$12
$13:
  %32 = and i64 %23, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$16, label %$15
$16:
  %34 = inttoptr i64 %23 to i64*
  %35 = load i64, i64* %34
  br label %$12
$15:
  %36 = call i64 @evList(i64 %23)
  br label %$12
$12:
  %37 = phi i64 [%23, %$14], [%35, %$16], [%36, %$15] ; # ->
; # (pair (setq Y (eval Y)))
  %38 = and i64 %37, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$18, label %$17
$18:
  %40 = phi i64 [%37, %$12] ; # Y
; # (while (pair (cdr Y)) (shift Y))
  br label %$19
$19:
  %41 = phi i64 [%40, %$18], [%50, %$20] ; # Y
; # (cdr Y)
  %42 = inttoptr i64 %41 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
; # (pair (cdr Y))
  %45 = and i64 %44, 15
  %46 = icmp eq i64 %45, 0
  br i1 %46, label %$20, label %$21
$20:
  %47 = phi i64 [%41, %$19] ; # Y
; # (shift Y)
  %48 = inttoptr i64 %47 to i64*
  %49 = getelementptr i64, i64* %48, i32 1
  %50 = load i64, i64* %49
  br label %$19
$21:
  %51 = phi i64 [%41, %$19] ; # Y
  br label %$10
$17:
  %52 = phi i64 [%37, %$12] ; # Y
; # (drop P)
  %53 = inttoptr i64 %6 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  br label %$4
$10:
  %57 = phi i64 [%14, %$11], [%51, %$21] ; # ->
; # (loop (let C (skip) (? (== C (char ")")) (call $Get)) (? (== C (c...
  br label %$22
$22:
  %58 = phi i64 [%57, %$10], [%162, %$27] ; # X
; # (let C (skip) (? (== C (char ")")) (call $Get)) (? (== C (char "]...
; # (skip)
  %59 = call i32 @skip()
; # (? (== C (char ")")) (call $Get))
; # (== C (char ")"))
  %60 = icmp eq i32 %59, 41
  br i1 %60, label %$25, label %$23
$25:
  %61 = phi i64 [%58, %$22] ; # X
  %62 = phi i32 [%59, %$22] ; # C
; # (call $Get)
  %63 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %64 = call i32 %63()
  br label %$24
$23:
  %65 = phi i64 [%58, %$22] ; # X
  %66 = phi i32 [%59, %$22] ; # C
; # (? (== C (char "]")))
; # (== C (char "]"))
  %67 = icmp eq i32 %66, 93
  br i1 %67, label %$24, label %$26
$26:
  %68 = phi i64 [%65, %$23] ; # X
  %69 = phi i32 [%66, %$23] ; # C
; # (cond ((== C (char ".")) (? (strchr $Delim (call $Get)) (setq X (...
; # (== C (char "."))
  %70 = icmp eq i32 %69, 46
  br i1 %70, label %$29, label %$28
$29:
  %71 = phi i64 [%68, %$26] ; # X
  %72 = phi i32 [%69, %$26] ; # C
; # (? (strchr $Delim (call $Get)) (setq X (set 2 X (if (or (== (setq...
; # (call $Get)
  %73 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %74 = call i32 %73()
; # (strchr $Delim (call $Get))
  %75 = call i8* @strchr(i8* bitcast ([16 x i8]* @$Delim to i8*), i32 %74)
  %76 = icmp ne i8* %75, null
  br i1 %76, label %$31, label %$30
$31:
  %77 = phi i64 [%71, %$29] ; # X
  %78 = phi i32 [%72, %$29] ; # C
; # (set 2 X (if (or (== (setq C (skip)) (char ")")) (== C (char "]")...
; # (if (or (== (setq C (skip)) (char ")")) (== C (char "]"))) (val P...
; # (or (== (setq C (skip)) (char ")")) (== C (char "]")))
; # (skip)
  %79 = call i32 @skip()
; # (== (setq C (skip)) (char ")"))
  %80 = icmp eq i32 %79, 41
  br i1 %80, label %$32, label %$33
$33:
  %81 = phi i64 [%77, %$31] ; # X
  %82 = phi i32 [%79, %$31] ; # C
; # (== C (char "]"))
  %83 = icmp eq i32 %82, 93
  br label %$32
$32:
  %84 = phi i64 [%77, %$31], [%81, %$33] ; # X
  %85 = phi i32 [%79, %$31], [%82, %$33] ; # C
  %86 = phi i1 [1, %$31], [%83, %$33] ; # ->
  br i1 %86, label %$34, label %$35
$34:
  %87 = phi i64 [%84, %$32] ; # X
  %88 = phi i32 [%85, %$32] ; # C
; # (val P)
  %89 = inttoptr i64 %6 to i64*
  %90 = load i64, i64* %89
  br label %$36
$35:
  %91 = phi i64 [%84, %$32] ; # X
  %92 = phi i32 [%85, %$32] ; # C
; # (read0 NO)
  %93 = call i64 @read0(i1 0)
  br label %$36
$36:
  %94 = phi i64 [%87, %$34], [%91, %$35] ; # X
  %95 = phi i32 [%88, %$34], [%92, %$35] ; # C
  %96 = phi i64 [%90, %$34], [%93, %$35] ; # ->
  %97 = inttoptr i64 %77 to i64*
  %98 = getelementptr i64, i64* %97, i32 1
  store i64 %96, i64* %98
; # (cond ((== (skip) (char ")")) (call $Get)) ((<> (val $Chr) (char ...
; # (skip)
  %99 = call i32 @skip()
; # (== (skip) (char ")"))
  %100 = icmp eq i32 %99, 41
  br i1 %100, label %$39, label %$38
$39:
  %101 = phi i64 [%96, %$36] ; # X
  %102 = phi i32 [%95, %$36] ; # C
; # (call $Get)
  %103 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %104 = call i32 %103()
  br label %$37
$38:
  %105 = phi i64 [%96, %$36] ; # X
  %106 = phi i32 [%95, %$36] ; # C
; # (val $Chr)
  %107 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (<> (val $Chr) (char "]"))
  %108 = icmp ne i32 %107, 93
  br i1 %108, label %$41, label %$40
$41:
  %109 = phi i64 [%105, %$38] ; # X
  %110 = phi i32 [%106, %$38] ; # C
; # (err 0 X ($ "Bad dotted pair") null)
  call void @err(i64 0, i64 %109, i8* bitcast ([16 x i8]* @$39 to i8*), i8* null)
  unreachable
$40:
  %111 = phi i64 [%105, %$38] ; # X
  %112 = phi i32 [%106, %$38] ; # C
  br label %$37
$37:
  %113 = phi i64 [%101, %$39], [%111, %$40] ; # X
  %114 = phi i32 [%102, %$39], [%112, %$40] ; # C
  %115 = phi i32 [%104, %$39], [0, %$40] ; # ->
  br label %$24
$30:
  %116 = phi i64 [%71, %$29] ; # X
  %117 = phi i32 [%72, %$29] ; # C
; # (set 2 X (cons (rdAtom (char ".")) $Nil))
; # (rdAtom (char "."))
  %118 = call i64 @rdAtom(i32 46)
; # (cons (rdAtom (char ".")) $Nil)
  %119 = call i64 @cons(i64 %118, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %120 = inttoptr i64 %116 to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  store i64 %119, i64* %121
  br label %$27
$28:
  %122 = phi i64 [%68, %$26] ; # X
  %123 = phi i32 [%69, %$26] ; # C
; # (== C (char "~"))
  %124 = icmp eq i32 %123, 126
  br i1 %124, label %$43, label %$42
$43:
  %125 = phi i64 [%122, %$28] ; # X
  %126 = phi i32 [%123, %$28] ; # C
; # (call $Get)
  %127 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %128 = call i32 %127()
; # (set 2 X (eval (set 2 X (read0 NO))))
; # (set 2 X (read0 NO))
; # (read0 NO)
  %129 = call i64 @read0(i1 0)
  %130 = inttoptr i64 %125 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  store i64 %129, i64* %131
; # (eval (set 2 X (read0 NO)))
  %132 = and i64 %129, 6
  %133 = icmp ne i64 %132, 0
  br i1 %133, label %$46, label %$45
$46:
  br label %$44
$45:
  %134 = and i64 %129, 8
  %135 = icmp ne i64 %134, 0
  br i1 %135, label %$48, label %$47
$48:
  %136 = inttoptr i64 %129 to i64*
  %137 = load i64, i64* %136
  br label %$44
$47:
  %138 = call i64 @evList(i64 %129)
  br label %$44
$44:
  %139 = phi i64 [%129, %$46], [%137, %$48], [%138, %$47] ; # ->
  %140 = inttoptr i64 %125 to i64*
  %141 = getelementptr i64, i64* %140, i32 1
  store i64 %139, i64* %141
; # (while (pair (cdr X)) (shift X))
  br label %$49
$49:
  %142 = phi i64 [%125, %$44], [%153, %$50] ; # X
  %143 = phi i32 [%126, %$44], [%150, %$50] ; # C
; # (cdr X)
  %144 = inttoptr i64 %142 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (pair (cdr X))
  %147 = and i64 %146, 15
  %148 = icmp eq i64 %147, 0
  br i1 %148, label %$50, label %$51
$50:
  %149 = phi i64 [%142, %$49] ; # X
  %150 = phi i32 [%143, %$49] ; # C
; # (shift X)
  %151 = inttoptr i64 %149 to i64*
  %152 = getelementptr i64, i64* %151, i32 1
  %153 = load i64, i64* %152
  br label %$49
$51:
  %154 = phi i64 [%142, %$49] ; # X
  %155 = phi i32 [%143, %$49] ; # C
  br label %$27
$42:
  %156 = phi i64 [%122, %$28] ; # X
  %157 = phi i32 [%123, %$28] ; # C
; # (set 2 X (cons (read0 NO) $Nil))
; # (read0 NO)
  %158 = call i64 @read0(i1 0)
; # (cons (read0 NO) $Nil)
  %159 = call i64 @cons(i64 %158, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %160 = inttoptr i64 %156 to i64*
  %161 = getelementptr i64, i64* %160, i32 1
  store i64 %159, i64* %161
  br label %$27
$27:
  %162 = phi i64 [%119, %$30], [%154, %$51], [%159, %$42] ; # X
  %163 = phi i32 [%117, %$30], [%155, %$51], [%157, %$42] ; # C
  br label %$22
$24:
  %164 = phi i64 [%61, %$25], [%65, %$23], [%113, %$37] ; # X
; # (pop P)
  %165 = inttoptr i64 %6 to i64*
  %166 = load i64, i64* %165
  %167 = inttoptr i64 %6 to i64*
  %168 = getelementptr i64, i64* %167, i32 1
  %169 = load i64, i64* %168
  %170 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %169, i64* %170
  ret i64 %166
}

define i64 @read0(i1) {
$1:
; # (let C (skip) (and Top (val $InFile) (let In: (inFile @) (In: src...
; # (skip)
  %1 = call i32 @skip()
; # (and Top (val $InFile) (let In: (inFile @) (In: src (In: line))))...
  br i1 %0, label %$3, label %$2
$3:
  %2 = phi i32 [%1, %$1] ; # C
; # (val $InFile)
  %3 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
  %4 = icmp ne i8* %3, null
  br i1 %4, label %$4, label %$2
$4:
  %5 = phi i32 [%2, %$3] ; # C
; # (let In: (inFile @) (In: src (In: line)))
; # (In: src (In: line))
  %6 = getelementptr i8, i8* %3, i32 36
  %7 = bitcast i8* %6 to i32*
  %8 = getelementptr i8, i8* %3, i32 32
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
  store i32 %10, i32* %7
  %11 = icmp ne i32 %10, 0
  br label %$2
$2:
  %12 = phi i32 [%1, %$1], [%2, %$3], [%5, %$4] ; # C
  %13 = phi i1 [0, %$1], [0, %$3], [%11, %$4] ; # ->
; # (cond ((lt0 C) (unless Top (eofErr)) $Nil) ((== C (char "(")) (pr...
; # (lt0 C)
  %14 = icmp slt i32 %12, 0
  br i1 %14, label %$7, label %$6
$7:
  %15 = phi i32 [%12, %$2] ; # C
; # (unless Top (eofErr))
  br i1 %0, label %$9, label %$8
$8:
  %16 = phi i32 [%15, %$7] ; # C
; # (eofErr)
  call void @eofErr()
  unreachable
$9:
  %17 = phi i32 [%15, %$7] ; # C
  br label %$5
$6:
  %18 = phi i32 [%12, %$2] ; # C
; # (== C (char "("))
  %19 = icmp eq i32 %18, 40
  br i1 %19, label %$11, label %$10
$11:
  %20 = phi i32 [%18, %$6] ; # C
; # (prog1 (rdList) (and Top (== (val $Chr) (char "]")) (call $Get)))...
; # (rdList)
  %21 = call i64 @rdList()
; # (and Top (== (val $Chr) (char "]")) (call $Get))
  br i1 %0, label %$13, label %$12
$13:
  %22 = phi i32 [%20, %$11] ; # C
; # (val $Chr)
  %23 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (== (val $Chr) (char "]"))
  %24 = icmp eq i32 %23, 93
  br i1 %24, label %$14, label %$12
$14:
  %25 = phi i32 [%22, %$13] ; # C
; # (call $Get)
  %26 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %27 = call i32 %26()
  %28 = icmp ne i32 %27, 0
  br label %$12
$12:
  %29 = phi i32 [%20, %$11], [%22, %$13], [%25, %$14] ; # C
  %30 = phi i1 [0, %$11], [0, %$13], [%28, %$14] ; # ->
  br label %$5
$10:
  %31 = phi i32 [%18, %$6] ; # C
; # (== C (char "["))
  %32 = icmp eq i32 %31, 91
  br i1 %32, label %$16, label %$15
$16:
  %33 = phi i32 [%31, %$10] ; # C
; # (let X (rdList) (unless (== (val $Chr) (char "]")) (err 0 X ($ "S...
; # (rdList)
  %34 = call i64 @rdList()
; # (unless (== (val $Chr) (char "]")) (err 0 X ($ "Super parentheses...
; # (val $Chr)
  %35 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (== (val $Chr) (char "]"))
  %36 = icmp eq i32 %35, 93
  br i1 %36, label %$18, label %$17
$17:
  %37 = phi i32 [%33, %$16] ; # C
; # (err 0 X ($ "Super parentheses mismatch") null)
  call void @err(i64 0, i64 %34, i8* bitcast ([27 x i8]* @$40 to i8*), i8* null)
  unreachable
$18:
  %38 = phi i32 [%33, %$16] ; # C
; # (call $Get)
  %39 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %40 = call i32 %39()
  br label %$5
$15:
  %41 = phi i32 [%31, %$10] ; # C
; # (== C (char "'"))
  %42 = icmp eq i32 %41, 39
  br i1 %42, label %$20, label %$19
$20:
  %43 = phi i32 [%41, %$15] ; # C
; # (call $Get)
  %44 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %45 = call i32 %44()
; # (read0 Top)
  %46 = call i64 @read0(i1 %0)
; # (cons $Quote (read0 Top))
  %47 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 168) to i64), i64 %46)
  br label %$5
$19:
  %48 = phi i32 [%41, %$15] ; # C
; # (== C (char ","))
  %49 = icmp eq i32 %48, 44
  br i1 %49, label %$22, label %$21
$22:
  %50 = phi i32 [%48, %$19] ; # C
; # (call $Get)
  %51 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %52 = call i32 %51()
; # (let X (read0 Top) (if (== $T (val $Uni)) X (save X (if (pair (id...
; # (read0 Top)
  %53 = call i64 @read0(i1 %0)
; # (if (== $T (val $Uni)) X (save X (if (pair (idxPut $Uni X)) (car ...
; # (val $Uni)
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 696) to i64) to i64*
  %55 = load i64, i64* %54
; # (== $T (val $Uni))
  %56 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %55
  br i1 %56, label %$23, label %$24
$23:
  %57 = phi i32 [%50, %$22] ; # C
  br label %$25
$24:
  %58 = phi i32 [%50, %$22] ; # C
; # (save X (if (pair (idxPut $Uni X)) (car @) X))
  %59 = alloca i64, i64 2, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = inttoptr i64 %60 to i64*
  store i64 %53, i64* %61
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %63 = load i64, i64* %62
  %64 = inttoptr i64 %60 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  store i64 %63, i64* %65
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %66
; # (if (pair (idxPut $Uni X)) (car @) X)
; # (idxPut $Uni X)
  %67 = call i64 @idxPut(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 696) to i64), i64 %53)
; # (pair (idxPut $Uni X))
  %68 = and i64 %67, 15
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %$26, label %$27
$26:
  %70 = phi i32 [%58, %$24] ; # C
; # (car @)
  %71 = inttoptr i64 %67 to i64*
  %72 = load i64, i64* %71
  br label %$28
$27:
  %73 = phi i32 [%58, %$24] ; # C
  br label %$28
$28:
  %74 = phi i32 [%70, %$26], [%73, %$27] ; # C
  %75 = phi i64 [%72, %$26], [%53, %$27] ; # ->
  %76 = inttoptr i64 %60 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %78, i64* %79
  br label %$25
$25:
  %80 = phi i32 [%57, %$23], [%74, %$28] ; # C
  %81 = phi i64 [%53, %$23], [%75, %$28] ; # ->
  br label %$5
$21:
  %82 = phi i32 [%48, %$19] ; # C
; # (== C (char "`"))
  %83 = icmp eq i32 %82, 96
  br i1 %83, label %$30, label %$29
$30:
  %84 = phi i32 [%82, %$21] ; # C
; # (call $Get)
  %85 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %86 = call i32 %85()
; # (let E (read0 Top) (save E (eval E)))
; # (read0 Top)
  %87 = call i64 @read0(i1 %0)
; # (save E (eval E))
  %88 = alloca i64, i64 2, align 16
  %89 = ptrtoint i64* %88 to i64
  %90 = inttoptr i64 %89 to i64*
  store i64 %87, i64* %90
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %92 = load i64, i64* %91
  %93 = inttoptr i64 %89 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  store i64 %92, i64* %94
  %95 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %89, i64* %95
; # (eval E)
  %96 = and i64 %87, 6
  %97 = icmp ne i64 %96, 0
  br i1 %97, label %$33, label %$32
$33:
  br label %$31
$32:
  %98 = and i64 %87, 8
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$35, label %$34
$35:
  %100 = inttoptr i64 %87 to i64*
  %101 = load i64, i64* %100
  br label %$31
$34:
  %102 = call i64 @evList(i64 %87)
  br label %$31
$31:
  %103 = phi i64 [%87, %$33], [%101, %$35], [%102, %$34] ; # ->
  %104 = inttoptr i64 %89 to i64*
  %105 = getelementptr i64, i64* %104, i32 1
  %106 = load i64, i64* %105
  %107 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %106, i64* %107
  br label %$5
$29:
  %108 = phi i32 [%82, %$21] ; # C
; # (== C (char "\""))
  %109 = icmp eq i32 %108, 34
  br i1 %109, label %$37, label %$36
$37:
  %110 = phi i32 [%108, %$29] ; # C
; # (if (== (setq C (call $Get)) (char "\"")) (prog (call $Get) $Nil)...
; # (call $Get)
  %111 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %112 = call i32 %111()
; # (== (setq C (call $Get)) (char "\""))
  %113 = icmp eq i32 %112, 34
  br i1 %113, label %$38, label %$39
$38:
  %114 = phi i32 [%112, %$37] ; # C
; # (call $Get)
  %115 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %116 = call i32 %115()
  br label %$40
$39:
  %117 = phi i32 [%112, %$37] ; # C
; # (unless (testEsc C) (eofErr))
; # (testEsc C)
  %118 = call i1 @testEsc(i32 %117)
  br i1 %118, label %$42, label %$41
$41:
  %119 = phi i32 [%117, %$39] ; # C
; # (eofErr)
  call void @eofErr()
  unreachable
$42:
  %120 = phi i32 [%117, %$39] ; # C
; # (let (P (push 4 NIL ZERO NIL) Q (link (ofs P 2))) (loop (charSym ...
; # (push 4 NIL ZERO NIL)
  %121 = alloca i64, i64 4, align 16
  store i64 4, i64* %121
  %122 = getelementptr i64, i64* %121, i32 2
  store i64 2, i64* %122
; # (ofs P 2)
  %123 = getelementptr i64, i64* %121, i32 2
; # (link (ofs P 2))
  %124 = ptrtoint i64* %123 to i64
  %125 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %126 = load i64, i64* %125
  %127 = inttoptr i64 %124 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  store i64 %126, i64* %128
  %129 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %124, i64* %129
; # (loop (charSym (val $Chr) P) (? (== (setq C (call $Get)) (char "\...
  br label %$43
$43:
  %130 = phi i32 [%120, %$42], [%138, %$47] ; # C
; # (val $Chr)
  %131 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (charSym (val $Chr) P)
  call void @charSym(i32 %131, i64* %121)
; # (? (== (setq C (call $Get)) (char "\"")))
; # (call $Get)
  %132 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %133 = call i32 %132()
; # (== (setq C (call $Get)) (char "\""))
  %134 = icmp eq i32 %133, 34
  br i1 %134, label %$45, label %$44
$44:
  %135 = phi i32 [%133, %$43] ; # C
; # (unless (testEsc C) (eofErr))
; # (testEsc C)
  %136 = call i1 @testEsc(i32 %135)
  br i1 %136, label %$47, label %$46
$46:
  %137 = phi i32 [%135, %$44] ; # C
; # (eofErr)
  call void @eofErr()
  unreachable
$47:
  %138 = phi i32 [%135, %$44] ; # C
  br label %$43
$45:
  %139 = phi i32 [%133, %$43] ; # C
  %140 = phi i64 [0, %$43] ; # ->
; # (call $Get)
  %141 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %142 = call i32 %141()
; # (drop Q (intern 0 0 (val Q) $Transient $Nil))
; # (val Q)
  %143 = inttoptr i64 %124 to i64*
  %144 = load i64, i64* %143
; # (intern 0 0 (val Q) $Transient $Nil)
  %145 = call i64 @intern(i64 0, i64 0, i64 %144, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %146 = inttoptr i64 %124 to i64*
  %147 = getelementptr i64, i64* %146, i32 1
  %148 = load i64, i64* %147
  %149 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %148, i64* %149
  br label %$40
$40:
  %150 = phi i32 [%114, %$38], [%139, %$45] ; # C
  %151 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$38], [%145, %$45] ; # ->
  br label %$5
$36:
  %152 = phi i32 [%108, %$29] ; # C
; # (== C (char "{"))
  %153 = icmp eq i32 %152, 123
  br i1 %153, label %$49, label %$48
$49:
  %154 = phi i32 [%152, %$36] ; # C
; # (prog1 (if (== (setq C (call $Get)) (char "}")) (consSym ZERO $Ni...
; # (if (== (setq C (call $Get)) (char "}")) (consSym ZERO $Nil) (let...
; # (call $Get)
  %155 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %156 = call i32 %155()
; # (== (setq C (call $Get)) (char "}"))
  %157 = icmp eq i32 %156, 125
  br i1 %157, label %$50, label %$51
$50:
  %158 = phi i32 [%156, %$49] ; # C
; # (consSym ZERO $Nil)
  %159 = call i64 @consSym(i64 2, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$52
$51:
  %160 = phi i32 [%156, %$49] ; # C
; # (let F (i32 0) (while (>= C (char "@")) (when (> C (char "O")) (b...
; # (i32 0)
; # (while (>= C (char "@")) (when (> C (char "O")) (badInput)) (setq...
  br label %$53
$53:
  %161 = phi i32 [%160, %$51], [%175, %$57] ; # C
  %162 = phi i32 [0, %$51], [%173, %$57] ; # F
; # (>= C (char "@"))
  %163 = icmp sge i32 %161, 64
  br i1 %163, label %$54, label %$55
$54:
  %164 = phi i32 [%161, %$53] ; # C
  %165 = phi i32 [%162, %$53] ; # F
; # (when (> C (char "O")) (badInput))
; # (> C (char "O"))
  %166 = icmp sgt i32 %164, 79
  br i1 %166, label %$56, label %$57
$56:
  %167 = phi i32 [%164, %$54] ; # C
  %168 = phi i32 [%165, %$54] ; # F
; # (badInput)
  call void @badInput()
  unreachable
$57:
  %169 = phi i32 [%164, %$54] ; # C
  %170 = phi i32 [%165, %$54] ; # F
; # (shl F 4)
  %171 = shl i32 %170, 4
; # (- C (char "@"))
  %172 = sub i32 %169, 64
; # (| (shl F 4) (- C (char "@")))
  %173 = or i32 %171, %172
; # (call $Get)
  %174 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %175 = call i32 %174()
  br label %$53
$55:
  %176 = phi i32 [%161, %$53] ; # C
  %177 = phi i32 [%162, %$53] ; # F
; # (let N 0 (loop (unless (and (>= C (char "0")) (>= (char "7") C)) ...
; # (loop (unless (and (>= C (char "0")) (>= (char "7") C)) (badInput...
  br label %$58
$58:
  %178 = phi i32 [%176, %$55], [%203, %$63] ; # C
  %179 = phi i32 [%177, %$55], [%204, %$63] ; # F
  %180 = phi i64 [0, %$55], [%205, %$63] ; # N
; # (unless (and (>= C (char "0")) (>= (char "7") C)) (badInput))
; # (and (>= C (char "0")) (>= (char "7") C))
; # (>= C (char "0"))
  %181 = icmp sge i32 %178, 48
  br i1 %181, label %$60, label %$59
$60:
  %182 = phi i32 [%178, %$58] ; # C
  %183 = phi i32 [%179, %$58] ; # F
  %184 = phi i64 [%180, %$58] ; # N
; # (>= (char "7") C)
  %185 = icmp sge i32 55, %182
  br label %$59
$59:
  %186 = phi i32 [%178, %$58], [%182, %$60] ; # C
  %187 = phi i32 [%179, %$58], [%183, %$60] ; # F
  %188 = phi i64 [%180, %$58], [%184, %$60] ; # N
  %189 = phi i1 [0, %$58], [%185, %$60] ; # ->
  br i1 %189, label %$62, label %$61
$61:
  %190 = phi i32 [%186, %$59] ; # C
  %191 = phi i32 [%187, %$59] ; # F
  %192 = phi i64 [%188, %$59] ; # N
; # (badInput)
  call void @badInput()
  unreachable
$62:
  %193 = phi i32 [%186, %$59] ; # C
  %194 = phi i32 [%187, %$59] ; # F
  %195 = phi i64 [%188, %$59] ; # N
; # (shl N 3)
  %196 = shl i64 %195, 3
; # (- C (char "0"))
  %197 = sub i32 %193, 48
; # (i64 (- C (char "0")))
  %198 = sext i32 %197 to i64
; # (| (shl N 3) (i64 (- C (char "0"))))
  %199 = or i64 %196, %198
; # (? (== (setq C (call $Get)) (char "}")))
; # (call $Get)
  %200 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %201 = call i32 %200()
; # (== (setq C (call $Get)) (char "}"))
  %202 = icmp eq i32 %201, 125
  br i1 %202, label %$64, label %$63
$63:
  %203 = phi i32 [%201, %$62] ; # C
  %204 = phi i32 [%194, %$62] ; # F
  %205 = phi i64 [%199, %$62] ; # N
  br label %$58
$64:
  %206 = phi i32 [%201, %$62] ; # C
  %207 = phi i32 [%194, %$62] ; # F
  %208 = phi i64 [%199, %$62] ; # N
  %209 = phi i64 [0, %$62] ; # ->
; # (extNm F N)
  %210 = call i64 @extNm(i32 %207, i64 %208)
; # (extern (extNm F N))
  %211 = call i64 @extern(i64 %210)
  br label %$52
$52:
  %212 = phi i32 [%158, %$50], [%206, %$64] ; # C
  %213 = phi i64 [%159, %$50], [%211, %$64] ; # ->
; # (call $Get)
  %214 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %215 = call i32 %214()
  br label %$5
$48:
  %216 = phi i32 [%152, %$36] ; # C
; # (or (== C (char ")")) (== C (char "]")) (== C (char "~")))
; # (== C (char ")"))
  %217 = icmp eq i32 %216, 41
  br i1 %217, label %$65, label %$66
$66:
  %218 = phi i32 [%216, %$48] ; # C
; # (== C (char "]"))
  %219 = icmp eq i32 %218, 93
  br i1 %219, label %$65, label %$67
$67:
  %220 = phi i32 [%218, %$66] ; # C
; # (== C (char "~"))
  %221 = icmp eq i32 %220, 126
  br label %$65
$65:
  %222 = phi i32 [%216, %$48], [%218, %$66], [%220, %$67] ; # C
  %223 = phi i1 [1, %$48], [1, %$66], [%221, %$67] ; # ->
  br i1 %223, label %$69, label %$68
$69:
  %224 = phi i32 [%222, %$65] ; # C
; # (badInput)
  call void @badInput()
  unreachable
$68:
  %225 = phi i32 [%222, %$65] ; # C
; # (when (== C (char "\\")) (call $Get))
; # (== C (char "\\"))
  %226 = icmp eq i32 %225, 92
  br i1 %226, label %$70, label %$71
$70:
  %227 = phi i32 [%225, %$68] ; # C
; # (call $Get)
  %228 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %229 = call i32 %228()
  br label %$71
$71:
  %230 = phi i32 [%225, %$68], [%227, %$70] ; # C
; # (val $Chr)
  %231 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (call $Get)
  %232 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %233 = call i32 %232()
; # (rdAtom C)
  %234 = call i64 @rdAtom(i32 %231)
  br label %$5
$5:
  %235 = phi i32 [%17, %$9], [%29, %$12], [%38, %$18], [%43, %$20], [%80, %$25], [%84, %$31], [%150, %$40], [%212, %$52], [%231, %$71] ; # C
  %236 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%21, %$12], [%34, %$18], [%47, %$20], [%81, %$25], [%103, %$31], [%151, %$40], [%213, %$52], [%234, %$71] ; # ->
  ret i64 %236
}

define i64 @read1(i32) {
$1:
; # (unless (val $Chr) (call $Get))
; # (val $Chr)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
; # (call $Get)
  %3 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %4 = call i32 %3()
  br label %$3
$3:
; # (if (== End (val $Chr)) $Nil (read0 YES))
; # (val $Chr)
  %5 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (== End (val $Chr))
  %6 = icmp eq i32 %0, %5
  br i1 %6, label %$4, label %$5
$4:
  br label %$6
$5:
; # (read0 YES)
  %7 = call i64 @read0(i1 1)
  br label %$6
$6:
  %8 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%7, %$5] ; # ->
  ret i64 %8
}

define i64 @token(i64, i32) {
$1:
; # (let C (val $Chr) (unless C (setq C (call $Get))) (cond ((lt0 (sk...
; # (val $Chr)
  %2 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (unless C (setq C (call $Get)))
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %$3, label %$2
$2:
  %4 = phi i32 [%2, %$1] ; # C
; # (call $Get)
  %5 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %6 = call i32 %5()
  br label %$3
$3:
  %7 = phi i32 [%2, %$1], [%6, %$2] ; # C
; # (cond ((lt0 (skipc Cmt)) 0) ((== (setq C @) (char "\"")) (cond ((...
; # (skipc Cmt)
  %8 = call i32 @skipc(i32 %1)
; # (lt0 (skipc Cmt))
  %9 = icmp slt i32 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = phi i32 [%7, %$3] ; # C
  br label %$4
$5:
  %11 = phi i32 [%7, %$3] ; # C
; # (== (setq C @) (char "\""))
  %12 = icmp eq i32 %8, 34
  br i1 %12, label %$8, label %$7
$8:
  %13 = phi i32 [%8, %$5] ; # C
; # (cond ((== (setq C (call $Get)) (char "\"")) (call $Get) $Nil) ((...
; # (call $Get)
  %14 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %15 = call i32 %14()
; # (== (setq C (call $Get)) (char "\""))
  %16 = icmp eq i32 %15, 34
  br i1 %16, label %$11, label %$10
$11:
  %17 = phi i32 [%15, %$8] ; # C
; # (call $Get)
  %18 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %19 = call i32 %18()
  br label %$9
$10:
  %20 = phi i32 [%15, %$8] ; # C
; # (testEsc C)
  %21 = call i1 @testEsc(i32 %20)
; # (not (testEsc C))
  %22 = icmp eq i1 %21, 0
  br i1 %22, label %$13, label %$12
$13:
  %23 = phi i32 [%20, %$10] ; # C
  br label %$9
$12:
  %24 = phi i32 [%20, %$10] ; # C
; # (let (Y (cons (mkChar (val $Chr)) $Nil) R (save Y)) (loop (? (== ...
; # (val $Chr)
  %25 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (mkChar (val $Chr))
  %26 = call i64 @mkChar(i32 %25)
; # (cons (mkChar (val $Chr)) $Nil)
  %27 = call i64 @cons(i64 %26, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (loop (? (== (setq C (call $Get)) (char "\"")) (call $Get)) (? (n...
  br label %$14
$14:
  %36 = phi i32 [%24, %$12], [%49, %$18] ; # C
  %37 = phi i64 [%27, %$12], [%53, %$18] ; # Y
; # (? (== (setq C (call $Get)) (char "\"")) (call $Get))
; # (call $Get)
  %38 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %39 = call i32 %38()
; # (== (setq C (call $Get)) (char "\""))
  %40 = icmp eq i32 %39, 34
  br i1 %40, label %$17, label %$15
$17:
  %41 = phi i32 [%39, %$14] ; # C
  %42 = phi i64 [%37, %$14] ; # Y
; # (call $Get)
  %43 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %44 = call i32 %43()
  br label %$16
$15:
  %45 = phi i32 [%39, %$14] ; # C
  %46 = phi i64 [%37, %$14] ; # Y
; # (? (not (testEsc C)))
; # (testEsc C)
  %47 = call i1 @testEsc(i32 %45)
; # (not (testEsc C))
  %48 = icmp eq i1 %47, 0
  br i1 %48, label %$16, label %$18
$18:
  %49 = phi i32 [%45, %$15] ; # C
  %50 = phi i64 [%46, %$15] ; # Y
; # (set 2 Y (cons (mkChar (val $Chr)) $Nil))
; # (val $Chr)
  %51 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (mkChar (val $Chr))
  %52 = call i64 @mkChar(i32 %51)
; # (cons (mkChar (val $Chr)) $Nil)
  %53 = call i64 @cons(i64 %52, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %54 = inttoptr i64 %50 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %53, i64* %55
  br label %$14
$16:
  %56 = phi i32 [%41, %$17], [%45, %$15] ; # C
  %57 = phi i64 [%42, %$17], [%46, %$15] ; # Y
  %58 = phi i32 [%44, %$17], [0, %$15] ; # ->
; # (drop *Safe)
  %59 = inttoptr i64 %29 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %61, i64* %62
  br label %$9
$9:
  %63 = phi i32 [%17, %$11], [%23, %$13], [%56, %$16] ; # C
  %64 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%27, %$16] ; # ->
  br label %$4
$7:
  %65 = phi i32 [%8, %$5] ; # C
; # (and (>= (char "9") C) (>= C (char "0")))
; # (>= (char "9") C)
  %66 = icmp sge i32 57, %65
  br i1 %66, label %$20, label %$19
$20:
  %67 = phi i32 [%65, %$7] ; # C
; # (>= C (char "0"))
  %68 = icmp sge i32 %67, 48
  br label %$19
$19:
  %69 = phi i32 [%65, %$7], [%67, %$20] ; # C
  %70 = phi i1 [0, %$7], [%68, %$20] ; # ->
  br i1 %70, label %$22, label %$21
$22:
  %71 = phi i32 [%69, %$19] ; # C
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (loop (byteSym (i...
; # (push 4 NIL ZERO NIL)
  %72 = alloca i64, i64 4, align 16
  store i64 4, i64* %72
  %73 = getelementptr i64, i64* %72, i32 2
  store i64 2, i64* %73
; # (ofs P 2)
  %74 = getelementptr i64, i64* %72, i32 2
; # (link (ofs P 2) T)
  %75 = ptrtoint i64* %74 to i64
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %75 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %77, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %80
; # (loop (byteSym (i8 C) P) (? (and (<> (setq C (call $Get)) (char "...
  br label %$23
$23:
  %81 = phi i32 [%71, %$22], [%94, %$28] ; # C
; # (i8 C)
  %82 = trunc i32 %81 to i8
; # (byteSym (i8 C) P)
  call void @byteSym(i8 %82, i64* %72)
; # (? (and (<> (setq C (call $Get)) (char ".")) (or (> (char "0") C)...
; # (and (<> (setq C (call $Get)) (char ".")) (or (> (char "0") C) (>...
; # (call $Get)
  %83 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %84 = call i32 %83()
; # (<> (setq C (call $Get)) (char "."))
  %85 = icmp ne i32 %84, 46
  br i1 %85, label %$25, label %$24
$25:
  %86 = phi i32 [%84, %$23] ; # C
; # (or (> (char "0") C) (> C (char "9")))
; # (> (char "0") C)
  %87 = icmp sgt i32 48, %86
  br i1 %87, label %$26, label %$27
$27:
  %88 = phi i32 [%86, %$25] ; # C
; # (> C (char "9"))
  %89 = icmp sgt i32 %88, 57
  br label %$26
$26:
  %90 = phi i32 [%86, %$25], [%88, %$27] ; # C
  %91 = phi i1 [1, %$25], [%89, %$27] ; # ->
  br label %$24
$24:
  %92 = phi i32 [%84, %$23], [%90, %$26] ; # C
  %93 = phi i1 [0, %$23], [%91, %$26] ; # ->
  br i1 %93, label %$29, label %$28
$28:
  %94 = phi i32 [%92, %$24] ; # C
  br label %$23
$29:
  %95 = phi i32 [%92, %$24] ; # C
  %96 = phi i64 [0, %$24] ; # ->
; # (val 3 P)
  %97 = getelementptr i64, i64* %72, i32 2
  %98 = load i64, i64* %97
; # (symToNum (val 3 P) 0 (char ".") 0)
  %99 = call i64 @symToNum(i64 %98, i64 0, i8 46, i8 0)
; # (drop *Safe)
  %100 = inttoptr i64 %75 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
  %103 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %102, i64* %103
  br label %$4
$21:
  %104 = phi i32 [%69, %$19] ; # C
; # (let (Nm (xName 0 Set) S (pathString Nm (b8 (pathSize Nm)))) (if ...
; # (xName 0 Set)
  %105 = call i64 @xName(i64 0, i64 %0)
; # (pathSize Nm)
  %106 = call i64 @pathSize(i64 %105)
; # (b8 (pathSize Nm))
  %107 = alloca i8, i64 %106
; # (pathString Nm (b8 (pathSize Nm)))
  %108 = call i8* @pathString(i64 %105, i8* %107)
; # (if (or (== C (char "+")) (== C (char "-")) (noToken C S)) (prog1...
; # (or (== C (char "+")) (== C (char "-")) (noToken C S))
; # (== C (char "+"))
  %109 = icmp eq i32 %104, 43
  br i1 %109, label %$30, label %$31
$31:
  %110 = phi i32 [%104, %$21] ; # C
; # (== C (char "-"))
  %111 = icmp eq i32 %110, 45
  br i1 %111, label %$30, label %$32
$32:
  %112 = phi i32 [%110, %$31] ; # C
; # (noToken C S)
  %113 = icmp eq i32 %112, 92
  br i1 %113, label %$33, label %$34
$34:
  %114 = icmp sge i32 122, %112
  br i1 %114, label %$36, label %$35
$36:
  %115 = icmp sge i32 %112, 97
  br label %$35
$35:
  %116 = phi i1 [0, %$34], [%115, %$36] ; # ->
  br i1 %116, label %$33, label %$37
$37:
  %117 = icmp sge i32 90, %112
  br i1 %117, label %$39, label %$38
$39:
  %118 = icmp sge i32 %112, 65
  br label %$38
$38:
  %119 = phi i1 [0, %$37], [%118, %$39] ; # ->
  br i1 %119, label %$33, label %$40
$40:
  %120 = call i8* @strchr(i8* %108, i32 %112)
  %121 = icmp ne i8* %120, null
  br label %$33
$33:
  %122 = phi i1 [1, %$32], [1, %$35], [1, %$38], [%121, %$40] ; # ->
  %123 = icmp eq i1 %122, 0
  br label %$30
$30:
  %124 = phi i32 [%104, %$21], [%110, %$31], [%112, %$33] ; # C
  %125 = phi i1 [1, %$21], [1, %$31], [%123, %$33] ; # ->
  br i1 %125, label %$41, label %$42
$41:
  %126 = phi i32 [%124, %$30] ; # C
; # (prog1 (mkChar (getChar C)) (call $Get))
; # (getChar C)
  %127 = call i32 @getChar(i32 %126)
; # (mkChar (getChar C))
  %128 = call i64 @mkChar(i32 %127)
; # (call $Get)
  %129 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %130 = call i32 %129()
  br label %$43
$42:
  %131 = phi i32 [%124, %$30] ; # C
; # (when (== C (char "\\")) (call $Get))
; # (== C (char "\\"))
  %132 = icmp eq i32 %131, 92
  br i1 %132, label %$44, label %$45
$44:
  %133 = phi i32 [%131, %$42] ; # C
; # (call $Get)
  %134 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %135 = call i32 %134()
  br label %$45
$45:
  %136 = phi i32 [%131, %$42], [%133, %$44] ; # C
; # (let P (push 4 NIL ZERO NIL) (link (ofs P 2) T) (loop (byteSym (i...
; # (push 4 NIL ZERO NIL)
  %137 = alloca i64, i64 4, align 16
  store i64 4, i64* %137
  %138 = getelementptr i64, i64* %137, i32 2
  store i64 2, i64* %138
; # (ofs P 2)
  %139 = getelementptr i64, i64* %137, i32 2
; # (link (ofs P 2) T)
  %140 = ptrtoint i64* %139 to i64
  %141 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %142 = load i64, i64* %141
  %143 = inttoptr i64 %140 to i64*
  %144 = getelementptr i64, i64* %143, i32 1
  store i64 %142, i64* %144
  %145 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %140, i64* %145
; # (loop (byteSym (i8 C) P) (? (and (noToken (setq C (call $Get)) S)...
  br label %$46
$46:
  %146 = phi i32 [%136, %$45], [%174, %$62] ; # C
; # (i8 C)
  %147 = trunc i32 %146 to i8
; # (byteSym (i8 C) P)
  call void @byteSym(i8 %147, i64* %137)
; # (? (and (noToken (setq C (call $Get)) S) (or (> (char "0") C) (> ...
; # (and (noToken (setq C (call $Get)) S) (or (> (char "0") C) (> C (...
; # (call $Get)
  %148 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %149 = call i32 %148()
; # (noToken (setq C (call $Get)) S)
  %150 = icmp eq i32 %149, 92
  br i1 %150, label %$48, label %$49
$49:
  %151 = icmp sge i32 122, %149
  br i1 %151, label %$51, label %$50
$51:
  %152 = icmp sge i32 %149, 97
  br label %$50
$50:
  %153 = phi i1 [0, %$49], [%152, %$51] ; # ->
  br i1 %153, label %$48, label %$52
$52:
  %154 = icmp sge i32 90, %149
  br i1 %154, label %$54, label %$53
$54:
  %155 = icmp sge i32 %149, 65
  br label %$53
$53:
  %156 = phi i1 [0, %$52], [%155, %$54] ; # ->
  br i1 %156, label %$48, label %$55
$55:
  %157 = call i8* @strchr(i8* %108, i32 %149)
  %158 = icmp ne i8* %157, null
  br label %$48
$48:
  %159 = phi i1 [1, %$46], [1, %$50], [1, %$53], [%158, %$55] ; # ->
  %160 = icmp eq i1 %159, 0
  br i1 %160, label %$56, label %$47
$56:
  %161 = phi i32 [%149, %$48] ; # C
; # (or (> (char "0") C) (> C (char "9")))
; # (> (char "0") C)
  %162 = icmp sgt i32 48, %161
  br i1 %162, label %$57, label %$58
$58:
  %163 = phi i32 [%161, %$56] ; # C
; # (> C (char "9"))
  %164 = icmp sgt i32 %163, 57
  br label %$57
$57:
  %165 = phi i32 [%161, %$56], [%163, %$58] ; # C
  %166 = phi i1 [1, %$56], [%164, %$58] ; # ->
  br label %$47
$47:
  %167 = phi i32 [%149, %$48], [%165, %$57] ; # C
  %168 = phi i1 [0, %$48], [%166, %$57] ; # ->
  br i1 %168, label %$60, label %$59
$59:
  %169 = phi i32 [%167, %$47] ; # C
; # (when (== C (char "\\")) (call $Get))
; # (== C (char "\\"))
  %170 = icmp eq i32 %169, 92
  br i1 %170, label %$61, label %$62
$61:
  %171 = phi i32 [%169, %$59] ; # C
; # (call $Get)
  %172 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %173 = call i32 %172()
  br label %$62
$62:
  %174 = phi i32 [%169, %$59], [%171, %$61] ; # C
  br label %$46
$60:
  %175 = phi i32 [%167, %$47] ; # C
  %176 = phi i64 [0, %$47] ; # ->
; # (val 3 P)
  %177 = getelementptr i64, i64* %137, i32 2
  %178 = load i64, i64* %177
; # (requestSym (val 3 P))
  %179 = call i64 @requestSym(i64 %178)
; # (drop *Safe)
  %180 = inttoptr i64 %140 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %182, i64* %183
  br label %$43
$43:
  %184 = phi i32 [%126, %$41], [%175, %$60] ; # C
  %185 = phi i64 [%128, %$41], [%179, %$60] ; # ->
  br label %$4
$4:
  %186 = phi i32 [%10, %$6], [%63, %$9], [%95, %$29], [%184, %$43] ; # C
  %187 = phi i64 [0, %$6], [%64, %$9], [%99, %$29], [%185, %$43] ; # ->
  ret i64 %187
}

define i64 @_read(i64) {
$1:
; # (let X (cdr Exe) (prog1 (if (atom X) (read1 0) (let Y (save (need...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog1 (if (atom X) (read1 0) (let Y (save (needSymb Exe (eval (+...
; # (if (atom X) (read1 0) (let Y (save (needSymb Exe (eval (++ X))))...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
; # (read1 0)
  %7 = call i64 @read1(i32 0)
  br label %$4
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (let Y (save (needSymb Exe (eval (++ X)))) (if (token Y (firstCha...
; # (++ X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
; # (eval (++ X))
  %13 = and i64 %10, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$7, label %$6
$7:
  br label %$5
$6:
  %15 = and i64 %10, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = inttoptr i64 %10 to i64*
  %18 = load i64, i64* %17
  br label %$5
$8:
  %19 = call i64 @evList(i64 %10)
  br label %$5
$5:
  %20 = phi i64 [%10, %$7], [%18, %$9], [%19, %$8] ; # ->
; # (needSymb Exe (eval (++ X)))
  %21 = xor i64 %20, 8
  %22 = and i64 %21, 14
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$10
$10:
  call void @symErr(i64 %0, i64 %20)
  unreachable
$11:
; # (save (needSymb Exe (eval (++ X))))
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 %20, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %25 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %31
; # (if (token Y (firstChar (needSymb Exe (eval (car X))))) @ $Nil)
; # (car X)
  %32 = inttoptr i64 %12 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$14, label %$13
$14:
  br label %$12
$13:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$16, label %$15
$16:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$12
$15:
  %40 = call i64 @evList(i64 %33)
  br label %$12
$12:
  %41 = phi i64 [%33, %$14], [%39, %$16], [%40, %$15] ; # ->
; # (needSymb Exe (eval (car X)))
  %42 = xor i64 %41, 8
  %43 = and i64 %42, 14
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$18, label %$17
$17:
  call void @symErr(i64 %0, i64 %41)
  unreachable
$18:
; # (firstChar (needSymb Exe (eval (car X))))
  %45 = call i32 @firstChar(i64 %41)
; # (token Y (firstChar (needSymb Exe (eval (car X)))))
  %46 = call i64 @token(i64 %20, i32 %45)
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$19, label %$20
$19:
  %48 = phi i64 [%12, %$18] ; # X
  br label %$21
$20:
  %49 = phi i64 [%12, %$18] ; # X
  br label %$21
$21:
  %50 = phi i64 [%48, %$19], [%49, %$20] ; # X
  %51 = phi i64 [%46, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$20] ; # ->
; # (drop *Safe)
  %52 = inttoptr i64 %25 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %55
  br label %$4
$4:
  %56 = phi i64 [%6, %$2], [%50, %$21] ; # X
  %57 = phi i64 [%7, %$2], [%51, %$21] ; # ->
; # (and (== (val $Chr) (char "^J")) (== (val $InFile) (val (val $InF...
; # (val $Chr)
  %58 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (== (val $Chr) (char "^J"))
  %59 = icmp eq i32 %58, 10
  br i1 %59, label %$23, label %$22
$23:
  %60 = phi i64 [%56, %$4] ; # X
; # (val $InFile)
  %61 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (val $InFiles)
  %62 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %63 = load i8*, i8** %62
; # (== (val $InFile) (val (val $InFiles)))
  %64 = icmp eq i8* %61, %63
  br i1 %64, label %$24, label %$22
$24:
  %65 = phi i64 [%60, %$23] ; # X
; # (set $Chr 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %66 = icmp ne i32 0, 0
  br label %$22
$22:
  %67 = phi i64 [%56, %$4], [%60, %$23], [%65, %$24] ; # X
  %68 = phi i1 [0, %$4], [0, %$23], [%66, %$24] ; # ->
  ret i64 %57
}

define i64 @_key(i64) {
$1:
; # (flushAll)
  call void @flushAll()
; # (setRaw)
  call void @setRaw()
; # (ifn (waitFd Exe 0 (if (nil? (eval (cadr Exe))) 292MY (xCnt Exe @...
; # (if (nil? (eval (cadr Exe))) 292MY (xCnt Exe @))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (xCnt Exe @)
  %15 = call i64 @xCnt(i64 %0, i64 %13)
  br label %$9
$9:
  %16 = phi i64 [9223372036854775807, %$7], [%15, %$8] ; # ->
; # (waitFd Exe 0 (if (nil? (eval (cadr Exe))) 292MY (xCnt Exe @)))
  %17 = call i64 @waitFd(i64 %0, i32 0, i64 %16)
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$10:
  br label %$12
$11:
; # (let C (stdinByte) (mkChar (cond ((>= 127 C) C) ((== C (hex "FF")...
; # (stdinByte)
  %19 = call i32 @stdinByte()
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (let B (ifn...
; # (>= 127 C)
  %20 = icmp sge i32 127, %19
  br i1 %20, label %$15, label %$14
$15:
  br label %$13
$14:
; # (== C (hex "FF"))
  %21 = icmp eq i32 %19, 255
  br i1 %21, label %$17, label %$16
$17:
; # (i32 TOP)
  br label %$13
$16:
; # (let B (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (h...
; # (ifn (& C (hex "20")) (& C (hex "1F")) (let A (ifn (& C (hex "10"...
; # (& C (hex "20"))
  %22 = and i32 %19, 32
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %$19, label %$18
$18:
; # (& C (hex "1F"))
  %24 = and i32 %19, 31
  br label %$20
$19:
; # (let A (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) ...
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C 7) 6) (& (std...
; # (& C (hex "10"))
  %25 = and i32 %19, 16
  %26 = icmp ne i32 %25, 0
  br i1 %26, label %$22, label %$21
$21:
; # (& C (hex "0F"))
  %27 = and i32 %19, 15
  br label %$23
$22:
; # (& C 7)
  %28 = and i32 %19, 7
; # (shl (& C 7) 6)
  %29 = shl i32 %28, 6
; # (stdinByte)
  %30 = call i32 @stdinByte()
; # (& (stdinByte) (hex "3F"))
  %31 = and i32 %30, 63
; # (| (shl (& C 7) 6) (& (stdinByte) (hex "3F")))
  %32 = or i32 %29, %31
  br label %$23
$23:
  %33 = phi i32 [%27, %$21], [%32, %$22] ; # ->
; # (shl A 6)
  %34 = shl i32 %33, 6
; # (stdinByte)
  %35 = call i32 @stdinByte()
; # (& (stdinByte) (hex "3F"))
  %36 = and i32 %35, 63
; # (| (shl A 6) (& (stdinByte) (hex "3F")))
  %37 = or i32 %34, %36
  br label %$20
$20:
  %38 = phi i32 [%24, %$18], [%37, %$23] ; # ->
; # (shl B 6)
  %39 = shl i32 %38, 6
; # (stdinByte)
  %40 = call i32 @stdinByte()
; # (& (stdinByte) (hex "3F"))
  %41 = and i32 %40, 63
; # (| (shl B 6) (& (stdinByte) (hex "3F")))
  %42 = or i32 %39, %41
  br label %$13
$13:
  %43 = phi i32 [%19, %$15], [1114112, %$17], [%42, %$20] ; # ->
; # (mkChar (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (le...
  %44 = call i64 @mkChar(i32 %43)
  br label %$12
$12:
  %45 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [%44, %$13] ; # ->
  ret i64 %45
}

define i64 @_peek(i64) {
$1:
; # (let Chr (val $Chr) (unless Chr (setq Chr (call $Get))) (if (lt0 ...
; # (val $Chr)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (unless Chr (setq Chr (call $Get)))
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i32 [%1, %$1] ; # Chr
; # (call $Get)
  %4 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %5 = call i32 %4()
  br label %$3
$3:
  %6 = phi i32 [%1, %$1], [%5, %$2] ; # Chr
; # (if (lt0 Chr) $Nil (mkChar (getChar Chr)))
; # (lt0 Chr)
  %7 = icmp slt i32 %6, 0
  br i1 %7, label %$4, label %$5
$4:
  %8 = phi i32 [%6, %$3] ; # Chr
  br label %$6
$5:
  %9 = phi i32 [%6, %$3] ; # Chr
; # (getChar Chr)
  %10 = call i32 @getChar(i32 %9)
; # (mkChar (getChar Chr))
  %11 = call i64 @mkChar(i32 %10)
  br label %$6
$6:
  %12 = phi i32 [%8, %$4], [%9, %$5] ; # Chr
  %13 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%11, %$5] ; # ->
  ret i64 %13
}

define i64 @_char(i64) {
$1:
; # (let X (cdr Exe) (cond ((atom X) (let Chr (val $Chr) (unless Chr ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (cond ((atom X) (let Chr (val $Chr) (unless Chr (setq Chr (call $...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$4:
; # (let Chr (val $Chr) (unless Chr (setq Chr (call $Get))) (prog1 (i...
; # (val $Chr)
  %6 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (unless Chr (setq Chr (call $Get)))
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %$6, label %$5
$5:
  %8 = phi i32 [%6, %$4] ; # Chr
; # (call $Get)
  %9 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %10 = call i32 %9()
  br label %$6
$6:
  %11 = phi i32 [%6, %$4], [%10, %$5] ; # Chr
; # (prog1 (if (lt0 Chr) $Nil (mkChar (getChar Chr))) (call $Get))
; # (if (lt0 Chr) $Nil (mkChar (getChar Chr)))
; # (lt0 Chr)
  %12 = icmp slt i32 %11, 0
  br i1 %12, label %$7, label %$8
$7:
  %13 = phi i32 [%11, %$6] ; # Chr
  br label %$9
$8:
  %14 = phi i32 [%11, %$6] ; # Chr
; # (getChar Chr)
  %15 = call i32 @getChar(i32 %14)
; # (mkChar (getChar Chr))
  %16 = call i64 @mkChar(i32 %15)
  br label %$9
$9:
  %17 = phi i32 [%13, %$7], [%14, %$8] ; # Chr
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%16, %$8] ; # ->
; # (call $Get)
  %19 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %20 = call i32 %19()
  br label %$2
$3:
; # (car X)
  %21 = inttoptr i64 %3 to i64*
  %22 = load i64, i64* %21
; # (eval (car X))
  %23 = and i64 %22, 6
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  br label %$10
$11:
  %25 = and i64 %22, 8
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$14, label %$13
$14:
  %27 = inttoptr i64 %22 to i64*
  %28 = load i64, i64* %27
  br label %$10
$13:
  %29 = call i64 @evList(i64 %22)
  br label %$10
$10:
  %30 = phi i64 [%22, %$12], [%28, %$14], [%29, %$13] ; # ->
; # (cnt? (eval (car X)))
  %31 = and i64 %30, 2
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$15
$16:
; # (if (int @) (mkChar (i32 @)) $Nil)
; # (int @)
  %33 = lshr i64 %30, 4
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$17, label %$18
$17:
; # (i32 @)
  %35 = trunc i64 %33 to i32
; # (mkChar (i32 @))
  %36 = call i64 @mkChar(i32 %35)
  br label %$19
$18:
  br label %$19
$19:
  %37 = phi i64 [%36, %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$18] ; # ->
  br label %$2
$15:
; # (t? @)
  %38 = icmp eq i64 %30, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %38, label %$21, label %$20
$21:
; # (mkChar TOP)
  %39 = call i64 @mkChar(i32 1114112)
  br label %$2
$20:
; # (symb? @)
  %40 = xor i64 %30, 8
  %41 = and i64 %40, 14
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$23, label %$22
$23:
; # (firstChar @)
  %43 = call i32 @firstChar(i64 %30)
; # (i64 (firstChar @))
  %44 = sext i32 %43 to i64
; # (cnt (i64 (firstChar @)))
  %45 = shl i64 %44, 4
  %46 = or i64 %45, 2
  br label %$2
$22:
; # (atomErr Exe @)
  call void @atomErr(i64 %0, i64 %30)
  unreachable
$2:
  %47 = phi i64 [%18, %$9], [%37, %$19], [%39, %$21], [%46, %$23] ; # ->
  ret i64 %47
}

define i64 @_skip(i64) {
$1:
; # (if (lt0 (skipc (firstChar (evSym (cdr Exe))))) $Nil (mkChar @))
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (firstChar (evSym (cdr Exe)))
  %5 = call i32 @firstChar(i64 %4)
; # (skipc (firstChar (evSym (cdr Exe))))
  %6 = call i32 @skipc(i32 %5)
; # (lt0 (skipc (firstChar (evSym (cdr Exe)))))
  %7 = icmp slt i32 %6, 0
  br i1 %7, label %$2, label %$3
$2:
  br label %$4
$3:
; # (mkChar @)
  %8 = call i64 @mkChar(i32 %6)
  br label %$4
$4:
  %9 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%8, %$3] ; # ->
  ret i64 %9
}

define i64 @_eol(i64) {
$1:
; # (let C (if (val $Chr) @ (call $Get)) (if (or (le0 C) (== C (char ...
; # (if (val $Chr) @ (call $Get))
; # (val $Chr)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  br label %$4
$3:
; # (call $Get)
  %3 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %4 = call i32 %3()
  br label %$4
$4:
  %5 = phi i32 [%1, %$2], [%4, %$3] ; # ->
; # (if (or (le0 C) (== C (char "^J"))) $T $Nil)
; # (or (le0 C) (== C (char "^J")))
; # (le0 C)
  %6 = icmp sle i32 %5, 0
  br i1 %6, label %$5, label %$6
$6:
; # (== C (char "^J"))
  %7 = icmp eq i32 %5, 10
  br label %$5
$5:
  %8 = phi i1 [1, %$4], [%7, %$6] ; # ->
  br i1 %8, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %9 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %9
}

define i64 @_eof(i64) {
$1:
; # (nond ((nil? (eval (cadr Exe))) (set $Chr -1) $T) ((=0 (val $Chr)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$8, label %$9
$9:
; # (set $Chr -1)
  store i32 -1, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$2
$8:
; # (val $Chr)
  %15 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (=0 (val $Chr))
  %16 = icmp eq i32 %15, 0
  br i1 %16, label %$10, label %$11
$11:
; # (if (lt0 @) $T $Nil)
; # (lt0 @)
  %17 = icmp slt i32 %15, 0
  br i1 %17, label %$12, label %$13
$12:
  br label %$14
$13:
  br label %$14
$14:
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13] ; # ->
  br label %$2
$10:
; # (if (lt0 (call $Get)) $T $Nil)
; # (call $Get)
  %19 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %20 = call i32 %19()
; # (lt0 (call $Get))
  %21 = icmp slt i32 %20, 0
  br i1 %21, label %$15, label %$16
$15:
  br label %$17
$16:
  br label %$17
$17:
  %22 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$16] ; # ->
  br label %$2
$2:
  %23 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$9], [%18, %$14], [%22, %$17] ; # ->
  ret i64 %23
}

define i64 @_from(i64) {
$1:
; # (let (X (cdr Exe) Link (val $Link) N 1 P T) (loop (let (Y (evSym ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $Link)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %5 = load i64, i64* %4
; # (loop (let (Y (evSym X) Nm (xName Exe Y)) (setq P (link (push Y N...
  br label %$2
$2:
  %6 = phi i64 [%3, %$1], [%31, %$3] ; # X
  %7 = phi i64 [1, %$1], [%34, %$3] ; # N
; # (let (Y (evSym X) Nm (xName Exe Y)) (setq P (link (push Y NIL 0 (...
; # (evSym X)
  %8 = call i64 @evSym(i64 %6)
; # (xName Exe Y)
  %9 = call i64 @xName(i64 %0, i64 %8)
; # (bufSize Nm)
  %10 = call i64 @bufSize(i64 %9)
; # (b8 (bufSize Nm))
  %11 = alloca i8, i64 %10
; # (bufString Nm (b8 (bufSize Nm)))
  %12 = call i8* @bufString(i64 %9, i8* %11)
; # (any (bufString Nm (b8 (bufSize Nm))))
  %13 = ptrtoint i8* %12 to i64
; # (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm)))))
  %14 = alloca i64, i64 4, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %8, i64* %16
  %17 = add i64 %15, 16
  %18 = inttoptr i64 %17 to i64*
  store i64 0, i64* %18
  %19 = add i64 %15, 24
  %20 = inttoptr i64 %19 to i64*
  store i64 %13, i64* %20
; # (link (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm))))))
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %15 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %25
; # (? (atom (shift X)))
; # (shift X)
  %26 = inttoptr i64 %6 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (atom (shift X))
  %29 = and i64 %28, 15
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$4, label %$3
$3:
  %31 = phi i64 [%28, %$2] ; # X
  %32 = phi i64 [%7, %$2] ; # N
  %33 = phi i64 [%15, %$2] ; # P
; # (inc 'N)
  %34 = add i64 %32, 1
  br label %$2
$4:
  %35 = phi i64 [%28, %$2] ; # X
  %36 = phi i64 [%7, %$2] ; # N
  %37 = phi i64 [%15, %$2] ; # P
  %38 = phi i64 [0, %$2] ; # ->
; # (unless (val $Chr) (call $Get))
; # (val $Chr)
  %39 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %40 = icmp ne i32 %39, 0
  br i1 %40, label %$6, label %$5
$5:
  %41 = phi i64 [%35, %$4] ; # X
  %42 = phi i64 [%36, %$4] ; # N
  %43 = phi i64 [%37, %$4] ; # P
; # (call $Get)
  %44 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %45 = call i32 %44()
  br label %$6
$6:
  %46 = phi i64 [%35, %$4], [%41, %$5] ; # X
  %47 = phi i64 [%36, %$4], [%42, %$5] ; # N
  %48 = phi i64 [%37, %$4], [%43, %$5] ; # P
; # (while (ge0 (val $Chr)) (let (B (i8 @) Q (i64* P) I N) (loop (loo...
  br label %$7
$7:
  %49 = phi i64 [%46, %$6], [%166, %$22] ; # X
  %50 = phi i64 [%47, %$6], [%167, %$22] ; # N
  %51 = phi i64 [%48, %$6], [%168, %$22] ; # P
; # (val $Chr)
  %52 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (ge0 (val $Chr))
  %53 = icmp sge i32 %52, 0
  br i1 %53, label %$8, label %$9
$8:
  %54 = phi i64 [%49, %$7] ; # X
  %55 = phi i64 [%50, %$7] ; # N
  %56 = phi i64 [%51, %$7] ; # P
; # (let (B (i8 @) Q (i64* P) I N) (loop (loop (let S (ofs (i8* (val ...
; # (i8 @)
  %57 = trunc i32 %52 to i8
; # (i64* P)
  %58 = inttoptr i64 %56 to i64*
; # (loop (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (v...
  br label %$10
$10:
  %59 = phi i64 [%54, %$8], [%158, %$21] ; # X
  %60 = phi i64 [%55, %$8], [%159, %$21] ; # N
  %61 = phi i64 [%56, %$8], [%160, %$21] ; # P
  %62 = phi i64* [%58, %$8], [%165, %$21] ; # Q
  %63 = phi i64 [%55, %$8], [%162, %$21] ; # I
; # (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S))...
  br label %$11
$11:
  %64 = phi i64 [%59, %$10], [%144, %$19] ; # X
  %65 = phi i64 [%60, %$10], [%145, %$19] ; # N
  %66 = phi i64 [%61, %$10], [%146, %$19] ; # P
  %67 = phi i64* [%62, %$10], [%147, %$19] ; # Q
  %68 = phi i64 [%63, %$10], [%148, %$19] ; # I
; # (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S)) (set ...
; # (val 4 Q)
  %69 = getelementptr i64, i64* %67, i32 3
  %70 = load i64, i64* %69
; # (i8* (val 4 Q))
  %71 = inttoptr i64 %70 to i8*
; # (val 3 Q)
  %72 = getelementptr i64, i64* %67, i32 2
  %73 = load i64, i64* %72
; # (ofs (i8* (val 4 Q)) (val 3 Q))
  %74 = getelementptr i8, i8* %71, i64 %73
; # (when (== B (val S)) (set 3 Q (inc (val 3 Q))) (? (val 2 S)) (cal...
; # (val S)
  %75 = load i8, i8* %74
; # (== B (val S))
  %76 = icmp eq i8 %57, %75
  br i1 %76, label %$12, label %$13
$12:
  %77 = phi i64 [%64, %$11] ; # X
  %78 = phi i64 [%65, %$11] ; # N
  %79 = phi i64 [%66, %$11] ; # P
  %80 = phi i64* [%67, %$11] ; # Q
  %81 = phi i64 [%68, %$11] ; # I
; # (set 3 Q (inc (val 3 Q)))
; # (val 3 Q)
  %82 = getelementptr i64, i64* %80, i32 2
  %83 = load i64, i64* %82
; # (inc (val 3 Q))
  %84 = add i64 %83, 1
  %85 = getelementptr i64, i64* %80, i32 2
  store i64 %84, i64* %85
; # (? (val 2 S))
; # (val 2 S)
  %86 = getelementptr i8, i8* %74, i32 1
  %87 = load i8, i8* %86
  %88 = icmp ne i8 %87, 0
  br i1 %88, label %$15, label %$14
$14:
  %89 = phi i64 [%77, %$12] ; # X
  %90 = phi i64 [%78, %$12] ; # N
  %91 = phi i64 [%79, %$12] ; # P
  %92 = phi i64* [%80, %$12] ; # Q
  %93 = phi i64 [%81, %$12] ; # I
; # (call $Get)
  %94 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %95 = call i32 %94()
; # (set $Link Link)
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %96
; # (val Q)
  %97 = load i64, i64* %92
; # (ret (val Q))
  ret i64 %97
$13:
  %98 = phi i64 [%64, %$11] ; # X
  %99 = phi i64 [%65, %$11] ; # N
  %100 = phi i64 [%66, %$11] ; # P
  %101 = phi i64* [%67, %$11] ; # Q
  %102 = phi i64 [%68, %$11] ; # I
; # (? (=0 (val 3 Q)))
; # (val 3 Q)
  %103 = getelementptr i64, i64* %101, i32 2
  %104 = load i64, i64* %103
; # (=0 (val 3 Q))
  %105 = icmp eq i64 %104, 0
  br i1 %105, label %$15, label %$16
$16:
  %106 = phi i64 [%98, %$13] ; # X
  %107 = phi i64 [%99, %$13] ; # N
  %108 = phi i64 [%100, %$13] ; # P
  %109 = phi i64* [%101, %$13] ; # Q
  %110 = phi i64 [%102, %$13] ; # I
; # (let S (ofs (i8* (val 4 Q)) 1) (while (set 3 Q (dec (val 3 Q))) (...
; # (val 4 Q)
  %111 = getelementptr i64, i64* %109, i32 3
  %112 = load i64, i64* %111
; # (i8* (val 4 Q))
  %113 = inttoptr i64 %112 to i8*
; # (ofs (i8* (val 4 Q)) 1)
  %114 = getelementptr i8, i8* %113, i32 1
; # (while (set 3 Q (dec (val 3 Q))) (? (=0 (memcmp (i8* (val 4 Q)) S...
  br label %$17
$17:
  %115 = phi i64 [%106, %$16], [%137, %$20] ; # X
  %116 = phi i64 [%107, %$16], [%138, %$20] ; # N
  %117 = phi i64 [%108, %$16], [%139, %$20] ; # P
  %118 = phi i64* [%109, %$16], [%140, %$20] ; # Q
  %119 = phi i64 [%110, %$16], [%141, %$20] ; # I
  %120 = phi i8* [%114, %$16], [%143, %$20] ; # S
; # (set 3 Q (dec (val 3 Q)))
; # (val 3 Q)
  %121 = getelementptr i64, i64* %118, i32 2
  %122 = load i64, i64* %121
; # (dec (val 3 Q))
  %123 = sub i64 %122, 1
  %124 = getelementptr i64, i64* %118, i32 2
  store i64 %123, i64* %124
  %125 = icmp ne i64 %123, 0
  br i1 %125, label %$18, label %$19
$18:
  %126 = phi i64 [%115, %$17] ; # X
  %127 = phi i64 [%116, %$17] ; # N
  %128 = phi i64 [%117, %$17] ; # P
  %129 = phi i64* [%118, %$17] ; # Q
  %130 = phi i64 [%119, %$17] ; # I
  %131 = phi i8* [%120, %$17] ; # S
; # (? (=0 (memcmp (i8* (val 4 Q)) S @)))
; # (val 4 Q)
  %132 = getelementptr i64, i64* %129, i32 3
  %133 = load i64, i64* %132
; # (i8* (val 4 Q))
  %134 = inttoptr i64 %133 to i8*
; # (memcmp (i8* (val 4 Q)) S @)
  %135 = call i32 @memcmp(i8* %134, i8* %131, i64 %123)
; # (=0 (memcmp (i8* (val 4 Q)) S @))
  %136 = icmp eq i32 %135, 0
  br i1 %136, label %$19, label %$20
$20:
  %137 = phi i64 [%126, %$18] ; # X
  %138 = phi i64 [%127, %$18] ; # N
  %139 = phi i64 [%128, %$18] ; # P
  %140 = phi i64* [%129, %$18] ; # Q
  %141 = phi i64 [%130, %$18] ; # I
  %142 = phi i8* [%131, %$18] ; # S
; # (inc 'S)
  %143 = getelementptr i8, i8* %142, i32 1
  br label %$17
$19:
  %144 = phi i64 [%115, %$17], [%126, %$18] ; # X
  %145 = phi i64 [%116, %$17], [%127, %$18] ; # N
  %146 = phi i64 [%117, %$17], [%128, %$18] ; # P
  %147 = phi i64* [%118, %$17], [%129, %$18] ; # Q
  %148 = phi i64 [%119, %$17], [%130, %$18] ; # I
  %149 = phi i8* [%120, %$17], [%131, %$18] ; # S
  br label %$11
$15:
  %150 = phi i64 [%77, %$12], [%98, %$13] ; # X
  %151 = phi i64 [%78, %$12], [%99, %$13] ; # N
  %152 = phi i64 [%79, %$12], [%100, %$13] ; # P
  %153 = phi i64* [%80, %$12], [%101, %$13] ; # Q
  %154 = phi i64 [%81, %$12], [%102, %$13] ; # I
  %155 = phi i64 [0, %$12], [0, %$13] ; # ->
; # (? (=0 (dec 'I)))
; # (dec 'I)
  %156 = sub i64 %154, 1
; # (=0 (dec 'I))
  %157 = icmp eq i64 %156, 0
  br i1 %157, label %$22, label %$21
$21:
  %158 = phi i64 [%150, %$15] ; # X
  %159 = phi i64 [%151, %$15] ; # N
  %160 = phi i64 [%152, %$15] ; # P
  %161 = phi i64* [%153, %$15] ; # Q
  %162 = phi i64 [%156, %$15] ; # I
; # (val 2 Q)
  %163 = getelementptr i64, i64* %161, i32 1
  %164 = load i64, i64* %163
; # (i64* (val 2 Q))
  %165 = inttoptr i64 %164 to i64*
  br label %$10
$22:
  %166 = phi i64 [%150, %$15] ; # X
  %167 = phi i64 [%151, %$15] ; # N
  %168 = phi i64 [%152, %$15] ; # P
  %169 = phi i64* [%153, %$15] ; # Q
  %170 = phi i64 [%156, %$15] ; # I
  %171 = phi i64 [0, %$15] ; # ->
; # (call $Get)
  %172 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %173 = call i32 %172()
  br label %$7
$9:
  %174 = phi i64 [%49, %$7] ; # X
  %175 = phi i64 [%50, %$7] ; # N
  %176 = phi i64 [%51, %$7] ; # P
; # (set $Link Link)
  %177 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %177
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_till(i64) {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) S (bufString Nm (b8 (b...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (bufSize Nm)
  %6 = call i64 @bufSize(i64 %5)
; # (b8 (bufSize Nm))
  %7 = alloca i8, i64 %6
; # (bufString Nm (b8 (bufSize Nm)))
  %8 = call i8* @bufString(i64 %5, i8* %7)
; # (let C (if (val $Chr) @ (call $Get)) (cond ((or (lt0 C) (strchr S...
; # (if (val $Chr) @ (call $Get))
; # (val $Chr)
  %9 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %$2, label %$3
$2:
  br label %$4
$3:
; # (call $Get)
  %11 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %12 = call i32 %11()
  br label %$4
$4:
  %13 = phi i32 [%9, %$2], [%12, %$3] ; # ->
; # (cond ((or (lt0 C) (strchr S C)) $Nil) ((nil? (eval (cadr X))) (l...
; # (or (lt0 C) (strchr S C))
; # (lt0 C)
  %14 = icmp slt i32 %13, 0
  br i1 %14, label %$6, label %$7
$7:
  %15 = phi i32 [%13, %$4] ; # C
; # (strchr S C)
  %16 = call i8* @strchr(i8* %8, i32 %15)
  %17 = icmp ne i8* %16, null
  br label %$6
$6:
  %18 = phi i32 [%13, %$4], [%15, %$7] ; # C
  %19 = phi i1 [1, %$4], [%17, %$7] ; # ->
  br i1 %19, label %$9, label %$8
$9:
  %20 = phi i32 [%18, %$6] ; # C
  br label %$5
$8:
  %21 = phi i32 [%18, %$6] ; # C
; # (cadr X)
  %22 = inttoptr i64 %3 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (eval (cadr X))
  %27 = and i64 %26, 6
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$12, label %$11
$12:
  br label %$10
$11:
  %29 = and i64 %26, 8
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  %31 = inttoptr i64 %26 to i64*
  %32 = load i64, i64* %31
  br label %$10
$13:
  %33 = call i64 @evList(i64 %26)
  br label %$10
$10:
  %34 = phi i64 [%26, %$12], [%32, %$14], [%33, %$13] ; # ->
; # (nil? (eval (cadr X)))
  %35 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %35, label %$16, label %$15
$16:
  %36 = phi i32 [%21, %$10] ; # C
; # (let (Y (cons (mkChar (getChar C)) $Nil) R (save Y)) (until (or (...
; # (getChar C)
  %37 = call i32 @getChar(i32 %36)
; # (mkChar (getChar C))
  %38 = call i64 @mkChar(i32 %37)
; # (cons (mkChar (getChar C)) $Nil)
  %39 = call i64 @cons(i64 %38, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %40 = alloca i64, i64 2, align 16
  %41 = ptrtoint i64* %40 to i64
  %42 = inttoptr i64 %41 to i64*
  store i64 %39, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %44 = load i64, i64* %43
  %45 = inttoptr i64 %41 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  store i64 %44, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %41, i64* %47
; # (until (or (le0 (setq C (call $Get))) (strchr S C)) (setq Y (set ...
  br label %$17
$17:
  %48 = phi i32 [%36, %$16], [%60, %$20] ; # C
  %49 = phi i64 [%39, %$16], [%63, %$20] ; # Y
; # (or (le0 (setq C (call $Get))) (strchr S C))
; # (call $Get)
  %50 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %51 = call i32 %50()
; # (le0 (setq C (call $Get)))
  %52 = icmp sle i32 %51, 0
  br i1 %52, label %$18, label %$19
$19:
  %53 = phi i32 [%51, %$17] ; # C
  %54 = phi i64 [%49, %$17] ; # Y
; # (strchr S C)
  %55 = call i8* @strchr(i8* %8, i32 %53)
  %56 = icmp ne i8* %55, null
  br label %$18
$18:
  %57 = phi i32 [%51, %$17], [%53, %$19] ; # C
  %58 = phi i64 [%49, %$17], [%54, %$19] ; # Y
  %59 = phi i1 [1, %$17], [%56, %$19] ; # ->
  br i1 %59, label %$21, label %$20
$20:
  %60 = phi i32 [%57, %$18] ; # C
  %61 = phi i64 [%58, %$18] ; # Y
; # (set 2 Y (cons (mkChar C) $Nil))
; # (mkChar C)
  %62 = call i64 @mkChar(i32 %60)
; # (cons (mkChar C) $Nil)
  %63 = call i64 @cons(i64 %62, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %64 = inttoptr i64 %61 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  store i64 %63, i64* %65
  br label %$17
$21:
  %66 = phi i32 [%57, %$18] ; # C
  %67 = phi i64 [%58, %$18] ; # Y
; # (drop *Safe)
  %68 = inttoptr i64 %41 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %71
  br label %$5
$15:
  %72 = phi i32 [%21, %$10] ; # C
; # (let (P (push 4 NIL ZERO NIL) Q (link (ofs P 2))) (loop (charSym ...
; # (push 4 NIL ZERO NIL)
  %73 = alloca i64, i64 4, align 16
  store i64 4, i64* %73
  %74 = getelementptr i64, i64* %73, i32 2
  store i64 2, i64* %74
; # (ofs P 2)
  %75 = getelementptr i64, i64* %73, i32 2
; # (link (ofs P 2))
  %76 = ptrtoint i64* %75 to i64
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %78 = load i64, i64* %77
  %79 = inttoptr i64 %76 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  store i64 %78, i64* %80
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %76, i64* %81
; # (loop (charSym (getChar C) P) (? (le0 (setq C (call $Get)))) (? (...
  br label %$22
$22:
  %82 = phi i32 [%72, %$15], [%90, %$25] ; # C
; # (getChar C)
  %83 = call i32 @getChar(i32 %82)
; # (charSym (getChar C) P)
  call void @charSym(i32 %83, i64* %73)
; # (? (le0 (setq C (call $Get))))
; # (call $Get)
  %84 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %85 = call i32 %84()
; # (le0 (setq C (call $Get)))
  %86 = icmp sle i32 %85, 0
  br i1 %86, label %$24, label %$23
$23:
  %87 = phi i32 [%85, %$22] ; # C
; # (? (strchr S C))
; # (strchr S C)
  %88 = call i8* @strchr(i8* %8, i32 %87)
  %89 = icmp ne i8* %88, null
  br i1 %89, label %$24, label %$25
$25:
  %90 = phi i32 [%87, %$23] ; # C
  br label %$22
$24:
  %91 = phi i32 [%85, %$22], [%87, %$23] ; # C
  %92 = phi i64 [0, %$22], [0, %$23] ; # ->
; # (drop Q (consStr (val 3 P)))
; # (val 3 P)
  %93 = getelementptr i64, i64* %73, i32 2
  %94 = load i64, i64* %93
; # (consStr (val 3 P))
  %95 = call i64 @consStr(i64 %94)
  %96 = inttoptr i64 %76 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  %98 = load i64, i64* %97
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %98, i64* %99
  br label %$5
$5:
  %100 = phi i32 [%20, %$9], [%66, %$21], [%91, %$24] ; # C
  %101 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%39, %$21], [%95, %$24] ; # ->
  ret i64 %101
}

define i1 @eol(i32) {
$1:
; # (cond ((lt0 C) YES) ((== C (char "^J")) (set $Chr 0) YES) ((== C ...
; # (lt0 C)
  %1 = icmp slt i32 %0, 0
  br i1 %1, label %$4, label %$3
$4:
  br label %$2
$3:
; # (== C (char "^J"))
  %2 = icmp eq i32 %0, 10
  br i1 %2, label %$6, label %$5
$6:
; # (set $Chr 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$2
$5:
; # (== C (char "^M"))
  %3 = icmp eq i32 %0, 13
  br i1 %3, label %$8, label %$7
$8:
; # (when (== (call $Get) (char "^J")) (set $Chr 0))
; # (call $Get)
  %4 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %5 = call i32 %4()
; # (== (call $Get) (char "^J"))
  %6 = icmp eq i32 %5, 10
  br i1 %6, label %$9, label %$10
$9:
; # (set $Chr 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$10
$10:
  br label %$2
$7:
  br label %$2
$2:
  %7 = phi i1 [1, %$4], [1, %$6], [1, %$10], [0, %$7] ; # ->
  ret i1 %7
}

define i64 @_line(i64) {
$1:
; # (let C (val $Chr) (unless C (setq C (call $Get))) (if (eol C) $Ni...
; # (val $Chr)
  %1 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (unless C (setq C (call $Get)))
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
  %3 = phi i32 [%1, %$1] ; # C
; # (call $Get)
  %4 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %5 = call i32 %4()
  br label %$3
$3:
  %6 = phi i32 [%1, %$1], [%5, %$2] ; # C
; # (if (eol C) $Nil (let X (cdr Exe) (cond ((nil? (eval (++ X))) (le...
; # (eol C)
  %7 = call i1 @eol(i32 %6)
  br i1 %7, label %$4, label %$5
$4:
  %8 = phi i32 [%6, %$3] ; # C
  br label %$6
$5:
  %9 = phi i32 [%6, %$3] ; # C
; # (let X (cdr Exe) (cond ((nil? (eval (++ X))) (let (Y (cons (mkCha...
; # (cdr Exe)
  %10 = inttoptr i64 %0 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
; # (cond ((nil? (eval (++ X))) (let (Y (cons (mkChar (getChar C)) $N...
; # (++ X)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
  %15 = getelementptr i64, i64* %13, i32 1
  %16 = load i64, i64* %15
; # (eval (++ X))
  %17 = and i64 %14, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$9
$10:
  br label %$8
$9:
  %19 = and i64 %14, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$12, label %$11
$12:
  %21 = inttoptr i64 %14 to i64*
  %22 = load i64, i64* %21
  br label %$8
$11:
  %23 = call i64 @evList(i64 %14)
  br label %$8
$8:
  %24 = phi i64 [%14, %$10], [%22, %$12], [%23, %$11] ; # ->
; # (nil? (eval (++ X)))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %25, label %$14, label %$13
$14:
  %26 = phi i32 [%9, %$8] ; # C
  %27 = phi i64 [%16, %$8] ; # X
; # (let (Y (cons (mkChar (getChar C)) $Nil) R (save Y)) (when (pair ...
; # (getChar C)
  %28 = call i32 @getChar(i32 %26)
; # (mkChar (getChar C))
  %29 = call i64 @mkChar(i32 %28)
; # (cons (mkChar (getChar C)) $Nil)
  %30 = call i64 @cons(i64 %29, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %31 = alloca i64, i64 2, align 16
  %32 = ptrtoint i64* %31 to i64
  %33 = inttoptr i64 %32 to i64*
  store i64 %30, i64* %33
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %35 = load i64, i64* %34
  %36 = inttoptr i64 %32 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %38
; # (when (pair X) (let Z (set Y (cons (car Y) $Nil)) (loop (let N (e...
; # (pair X)
  %39 = and i64 %27, 15
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %$15, label %$16
$15:
  %41 = phi i32 [%26, %$14] ; # C
  %42 = phi i64 [%27, %$14] ; # X
  %43 = phi i64 [%30, %$14] ; # Y
; # (let Z (set Y (cons (car Y) $Nil)) (loop (let N (evCnt Exe X) (wh...
; # (set Y (cons (car Y) $Nil))
; # (car Y)
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
; # (cons (car Y) $Nil)
  %46 = call i64 @cons(i64 %45, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %47 = inttoptr i64 %43 to i64*
  store i64 %46, i64* %47
; # (loop (let N (evCnt Exe X) (while (gt0 (dec 'N)) (when (eol (setq...
  br label %$17
$17:
  %48 = phi i32 [%41, %$15], [%112, %$26] ; # C
  %49 = phi i64 [%42, %$15], [%113, %$26] ; # X
  %50 = phi i64 [%43, %$15], [%119, %$26] ; # Y
  %51 = phi i64 [%46, %$15], [%118, %$26] ; # Z
; # (let N (evCnt Exe X) (while (gt0 (dec 'N)) (when (eol (setq C (ca...
; # (evCnt Exe X)
  %52 = call i64 @evCnt(i64 %0, i64 %49)
; # (while (gt0 (dec 'N)) (when (eol (setq C (call $Get))) (ret R)) (...
  br label %$18
$18:
  %53 = phi i32 [%48, %$17], [%77, %$22] ; # C
  %54 = phi i64 [%49, %$17], [%78, %$22] ; # X
  %55 = phi i64 [%50, %$17], [%79, %$22] ; # Y
  %56 = phi i64 [%51, %$17], [%84, %$22] ; # Z
  %57 = phi i64 [%52, %$17], [%81, %$22] ; # N
; # (dec 'N)
  %58 = sub i64 %57, 1
; # (gt0 (dec 'N))
  %59 = icmp sgt i64 %58, 0
  br i1 %59, label %$19, label %$20
$19:
  %60 = phi i32 [%53, %$18] ; # C
  %61 = phi i64 [%54, %$18] ; # X
  %62 = phi i64 [%55, %$18] ; # Y
  %63 = phi i64 [%56, %$18] ; # Z
  %64 = phi i64 [%58, %$18] ; # N
; # (when (eol (setq C (call $Get))) (ret R))
; # (call $Get)
  %65 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %66 = call i32 %65()
; # (eol (setq C (call $Get)))
  %67 = call i1 @eol(i32 %66)
  br i1 %67, label %$21, label %$22
$21:
  %68 = phi i32 [%66, %$19] ; # C
  %69 = phi i64 [%61, %$19] ; # X
  %70 = phi i64 [%62, %$19] ; # Y
  %71 = phi i64 [%63, %$19] ; # Z
  %72 = phi i64 [%64, %$19] ; # N
; # (ret R)
; # (drop *Safe)
  %73 = inttoptr i64 %32 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %76
  ret i64 %30
$22:
  %77 = phi i32 [%66, %$19] ; # C
  %78 = phi i64 [%61, %$19] ; # X
  %79 = phi i64 [%62, %$19] ; # Y
  %80 = phi i64 [%63, %$19] ; # Z
  %81 = phi i64 [%64, %$19] ; # N
; # (set 2 Z (cons (mkChar (getChar C)) $Nil))
; # (getChar C)
  %82 = call i32 @getChar(i32 %77)
; # (mkChar (getChar C))
  %83 = call i64 @mkChar(i32 %82)
; # (cons (mkChar (getChar C)) $Nil)
  %84 = call i64 @cons(i64 %83, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %85 = inttoptr i64 %80 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  store i64 %84, i64* %86
  br label %$18
$20:
  %87 = phi i32 [%53, %$18] ; # C
  %88 = phi i64 [%54, %$18] ; # X
  %89 = phi i64 [%55, %$18] ; # Y
  %90 = phi i64 [%56, %$18] ; # Z
  %91 = phi i64 [%58, %$18] ; # N
; # (? (atom (shift X)))
; # (shift X)
  %92 = inttoptr i64 %88 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
; # (atom (shift X))
  %95 = and i64 %94, 15
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$24, label %$23
$23:
  %97 = phi i32 [%87, %$20] ; # C
  %98 = phi i64 [%94, %$20] ; # X
  %99 = phi i64 [%89, %$20] ; # Y
  %100 = phi i64 [%90, %$20] ; # Z
; # (when (eol (setq C (call $Get))) (ret R))
; # (call $Get)
  %101 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %102 = call i32 %101()
; # (eol (setq C (call $Get)))
  %103 = call i1 @eol(i32 %102)
  br i1 %103, label %$25, label %$26
$25:
  %104 = phi i32 [%102, %$23] ; # C
  %105 = phi i64 [%98, %$23] ; # X
  %106 = phi i64 [%99, %$23] ; # Y
  %107 = phi i64 [%100, %$23] ; # Z
; # (ret R)
; # (drop *Safe)
  %108 = inttoptr i64 %32 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  %110 = load i64, i64* %109
  %111 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %110, i64* %111
  ret i64 %30
$26:
  %112 = phi i32 [%102, %$23] ; # C
  %113 = phi i64 [%98, %$23] ; # X
  %114 = phi i64 [%99, %$23] ; # Y
  %115 = phi i64 [%100, %$23] ; # Z
; # (set 2 Y (cons (setq Z (cons (mkChar (getChar C)) $Nil)) $Nil))
; # (getChar C)
  %116 = call i32 @getChar(i32 %112)
; # (mkChar (getChar C))
  %117 = call i64 @mkChar(i32 %116)
; # (cons (mkChar (getChar C)) $Nil)
  %118 = call i64 @cons(i64 %117, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (setq Z (cons (mkChar (getChar C)) $Nil)) $Nil)
  %119 = call i64 @cons(i64 %118, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %120 = inttoptr i64 %114 to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  store i64 %119, i64* %121
  br label %$17
$24:
  %122 = phi i32 [%87, %$20] ; # C
  %123 = phi i64 [%94, %$20] ; # X
  %124 = phi i64 [%89, %$20] ; # Y
  %125 = phi i64 [%90, %$20] ; # Z
  %126 = phi i64 [0, %$20] ; # ->
  br label %$16
$16:
  %127 = phi i32 [%26, %$14], [%122, %$24] ; # C
  %128 = phi i64 [%27, %$14], [%123, %$24] ; # X
  %129 = phi i64 [%30, %$14], [%124, %$24] ; # Y
; # (until (eol (setq C (call $Get))) (setq Y (set 2 Y (cons (mkChar ...
  br label %$27
$27:
  %130 = phi i32 [%127, %$16], [%136, %$28] ; # C
  %131 = phi i64 [%128, %$16], [%137, %$28] ; # X
  %132 = phi i64 [%129, %$16], [%141, %$28] ; # Y
; # (call $Get)
  %133 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %134 = call i32 %133()
; # (eol (setq C (call $Get)))
  %135 = call i1 @eol(i32 %134)
  br i1 %135, label %$29, label %$28
$28:
  %136 = phi i32 [%134, %$27] ; # C
  %137 = phi i64 [%131, %$27] ; # X
  %138 = phi i64 [%132, %$27] ; # Y
; # (set 2 Y (cons (mkChar (getChar C)) $Nil))
; # (getChar C)
  %139 = call i32 @getChar(i32 %136)
; # (mkChar (getChar C))
  %140 = call i64 @mkChar(i32 %139)
; # (cons (mkChar (getChar C)) $Nil)
  %141 = call i64 @cons(i64 %140, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %142 = inttoptr i64 %138 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  store i64 %141, i64* %143
  br label %$27
$29:
  %144 = phi i32 [%134, %$27] ; # C
  %145 = phi i64 [%131, %$27] ; # X
  %146 = phi i64 [%132, %$27] ; # Y
; # (drop *Safe)
  %147 = inttoptr i64 %32 to i64*
  %148 = getelementptr i64, i64* %147, i32 1
  %149 = load i64, i64* %148
  %150 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %149, i64* %150
  br label %$7
$13:
  %151 = phi i32 [%9, %$8] ; # C
  %152 = phi i64 [%16, %$8] ; # X
; # (atom X)
  %153 = and i64 %152, 15
  %154 = icmp ne i64 %153, 0
  br i1 %154, label %$31, label %$30
$31:
  %155 = phi i32 [%151, %$13] ; # C
  %156 = phi i64 [%152, %$13] ; # X
; # (let (P (push 4 NIL ZERO NIL) Q (link (ofs P 2))) (loop (charSym ...
; # (push 4 NIL ZERO NIL)
  %157 = alloca i64, i64 4, align 16
  store i64 4, i64* %157
  %158 = getelementptr i64, i64* %157, i32 2
  store i64 2, i64* %158
; # (ofs P 2)
  %159 = getelementptr i64, i64* %157, i32 2
; # (link (ofs P 2))
  %160 = ptrtoint i64* %159 to i64
  %161 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %162 = load i64, i64* %161
  %163 = inttoptr i64 %160 to i64*
  %164 = getelementptr i64, i64* %163, i32 1
  store i64 %162, i64* %164
  %165 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %160, i64* %165
; # (loop (charSym (getChar C) P) (? (eol (setq C (call $Get)))))
  br label %$32
$32:
  %166 = phi i32 [%155, %$31], [%172, %$33] ; # C
  %167 = phi i64 [%156, %$31], [%173, %$33] ; # X
; # (getChar C)
  %168 = call i32 @getChar(i32 %166)
; # (charSym (getChar C) P)
  call void @charSym(i32 %168, i64* %157)
; # (? (eol (setq C (call $Get))))
; # (call $Get)
  %169 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %170 = call i32 %169()
; # (eol (setq C (call $Get)))
  %171 = call i1 @eol(i32 %170)
  br i1 %171, label %$34, label %$33
$33:
  %172 = phi i32 [%170, %$32] ; # C
  %173 = phi i64 [%167, %$32] ; # X
  br label %$32
$34:
  %174 = phi i32 [%170, %$32] ; # C
  %175 = phi i64 [%167, %$32] ; # X
  %176 = phi i64 [0, %$32] ; # ->
; # (drop Q (consStr (val 3 P)))
; # (val 3 P)
  %177 = getelementptr i64, i64* %157, i32 2
  %178 = load i64, i64* %177
; # (consStr (val 3 P))
  %179 = call i64 @consStr(i64 %178)
  %180 = inttoptr i64 %160 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %182, i64* %183
  br label %$7
$30:
  %184 = phi i32 [%151, %$13] ; # C
  %185 = phi i64 [%152, %$13] ; # X
; # (let (N (evCnt Exe X) P (push 4 NIL ZERO NIL) Q (link (ofs P 2)))...
; # (evCnt Exe X)
  %186 = call i64 @evCnt(i64 %0, i64 %185)
; # (push 4 NIL ZERO NIL)
  %187 = alloca i64, i64 4, align 16
  store i64 4, i64* %187
  %188 = getelementptr i64, i64* %187, i32 2
  store i64 2, i64* %188
; # (ofs P 2)
  %189 = getelementptr i64, i64* %187, i32 2
; # (link (ofs P 2))
  %190 = ptrtoint i64* %189 to i64
  %191 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %192 = load i64, i64* %191
  %193 = inttoptr i64 %190 to i64*
  %194 = getelementptr i64, i64* %193, i32 1
  store i64 %192, i64* %194
  %195 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %190, i64* %195
; # (loop (charSym (getChar C) P) (when (eol (setq C (call $Get))) (r...
  br label %$35
$35:
  %196 = phi i32 [%184, %$30], [%219, %$38] ; # C
  %197 = phi i64 [%185, %$30], [%220, %$38] ; # X
  %198 = phi i64 [%186, %$30], [%221, %$38] ; # N
; # (getChar C)
  %199 = call i32 @getChar(i32 %196)
; # (charSym (getChar C) P)
  call void @charSym(i32 %199, i64* %187)
; # (when (eol (setq C (call $Get))) (ret (drop Q (cons (consStr (val...
; # (call $Get)
  %200 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %201 = call i32 %200()
; # (eol (setq C (call $Get)))
  %202 = call i1 @eol(i32 %201)
  br i1 %202, label %$36, label %$37
$36:
  %203 = phi i32 [%201, %$35] ; # C
  %204 = phi i64 [%197, %$35] ; # X
  %205 = phi i64 [%198, %$35] ; # N
; # (drop Q (cons (consStr (val Q)) $Nil))
; # (val Q)
  %206 = inttoptr i64 %190 to i64*
  %207 = load i64, i64* %206
; # (consStr (val Q))
  %208 = call i64 @consStr(i64 %207)
; # (cons (consStr (val Q)) $Nil)
  %209 = call i64 @cons(i64 %208, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %210 = inttoptr i64 %190 to i64*
  %211 = getelementptr i64, i64* %210, i32 1
  %212 = load i64, i64* %211
  %213 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %212, i64* %213
; # (ret (drop Q (cons (consStr (val Q)) $Nil)))
  ret i64 %209
$37:
  %214 = phi i32 [%201, %$35] ; # C
  %215 = phi i64 [%197, %$35] ; # X
  %216 = phi i64 [%198, %$35] ; # N
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %217 = sub i64 %216, 1
; # (=0 (dec 'N))
  %218 = icmp eq i64 %217, 0
  br i1 %218, label %$39, label %$38
$38:
  %219 = phi i32 [%214, %$37] ; # C
  %220 = phi i64 [%215, %$37] ; # X
  %221 = phi i64 [%217, %$37] ; # N
  br label %$35
$39:
  %222 = phi i32 [%214, %$37] ; # C
  %223 = phi i64 [%215, %$37] ; # X
  %224 = phi i64 [%217, %$37] ; # N
  %225 = phi i64 [0, %$37] ; # ->
; # (let (Y (cons (consStr (val Q)) $Nil) R (save Y)) (while (pair (s...
; # (val Q)
  %226 = inttoptr i64 %190 to i64*
  %227 = load i64, i64* %226
; # (consStr (val Q))
  %228 = call i64 @consStr(i64 %227)
; # (cons (consStr (val Q)) $Nil)
  %229 = call i64 @cons(i64 %228, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %230 = alloca i64, i64 2, align 16
  %231 = ptrtoint i64* %230 to i64
  %232 = inttoptr i64 %231 to i64*
  store i64 %229, i64* %232
  %233 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %234 = load i64, i64* %233
  %235 = inttoptr i64 %231 to i64*
  %236 = getelementptr i64, i64* %235, i32 1
  store i64 %234, i64* %236
  %237 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %231, i64* %237
; # (while (pair (shift X)) (setq N (evCnt Exe X)) (set P 4 3 P ZERO)...
  br label %$40
$40:
  %238 = phi i32 [%222, %$39], [%289, %$47] ; # C
  %239 = phi i64 [%223, %$39], [%290, %$47] ; # X
  %240 = phi i64 [%224, %$39], [%291, %$47] ; # N
  %241 = phi i64 [%229, %$39], [%297, %$47] ; # Y
; # (shift X)
  %242 = inttoptr i64 %239 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
; # (pair (shift X))
  %245 = and i64 %244, 15
  %246 = icmp eq i64 %245, 0
  br i1 %246, label %$41, label %$42
$41:
  %247 = phi i32 [%238, %$40] ; # C
  %248 = phi i64 [%244, %$40] ; # X
  %249 = phi i64 [%240, %$40] ; # N
  %250 = phi i64 [%241, %$40] ; # Y
; # (evCnt Exe X)
  %251 = call i64 @evCnt(i64 %0, i64 %248)
; # (set P 4 3 P ZERO)
  store i64 4, i64* %187
  %252 = getelementptr i64, i64* %187, i32 2
  store i64 2, i64* %252
; # (loop (charSym (getChar C) P) (when (eol (setq C (call $Get))) (s...
  br label %$43
$43:
  %253 = phi i32 [%247, %$41], [%285, %$46] ; # C
  %254 = phi i64 [%248, %$41], [%286, %$46] ; # X
  %255 = phi i64 [%251, %$41], [%287, %$46] ; # N
  %256 = phi i64 [%250, %$41], [%288, %$46] ; # Y
; # (getChar C)
  %257 = call i32 @getChar(i32 %253)
; # (charSym (getChar C) P)
  call void @charSym(i32 %257, i64* %187)
; # (when (eol (setq C (call $Get))) (set 2 Y (cons (consStr (val Q))...
; # (call $Get)
  %258 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %259 = call i32 %258()
; # (eol (setq C (call $Get)))
  %260 = call i1 @eol(i32 %259)
  br i1 %260, label %$44, label %$45
$44:
  %261 = phi i32 [%259, %$43] ; # C
  %262 = phi i64 [%254, %$43] ; # X
  %263 = phi i64 [%255, %$43] ; # N
  %264 = phi i64 [%256, %$43] ; # Y
; # (set 2 Y (cons (consStr (val Q)) $Nil))
; # (val Q)
  %265 = inttoptr i64 %190 to i64*
  %266 = load i64, i64* %265
; # (consStr (val Q))
  %267 = call i64 @consStr(i64 %266)
; # (cons (consStr (val Q)) $Nil)
  %268 = call i64 @cons(i64 %267, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %269 = inttoptr i64 %264 to i64*
  %270 = getelementptr i64, i64* %269, i32 1
  store i64 %268, i64* %270
; # (drop Q)
  %271 = inttoptr i64 %190 to i64*
  %272 = getelementptr i64, i64* %271, i32 1
  %273 = load i64, i64* %272
  %274 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %273, i64* %274
; # (ret R)
; # (drop *Safe)
  %275 = inttoptr i64 %231 to i64*
  %276 = getelementptr i64, i64* %275, i32 1
  %277 = load i64, i64* %276
  %278 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %277, i64* %278
  ret i64 %229
$45:
  %279 = phi i32 [%259, %$43] ; # C
  %280 = phi i64 [%254, %$43] ; # X
  %281 = phi i64 [%255, %$43] ; # N
  %282 = phi i64 [%256, %$43] ; # Y
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %283 = sub i64 %281, 1
; # (=0 (dec 'N))
  %284 = icmp eq i64 %283, 0
  br i1 %284, label %$47, label %$46
$46:
  %285 = phi i32 [%279, %$45] ; # C
  %286 = phi i64 [%280, %$45] ; # X
  %287 = phi i64 [%283, %$45] ; # N
  %288 = phi i64 [%282, %$45] ; # Y
  br label %$43
$47:
  %289 = phi i32 [%279, %$45] ; # C
  %290 = phi i64 [%280, %$45] ; # X
  %291 = phi i64 [%283, %$45] ; # N
  %292 = phi i64 [%282, %$45] ; # Y
  %293 = phi i64 [0, %$45] ; # ->
; # (set 2 Y (cons (consStr (val Q)) $Nil))
; # (val Q)
  %294 = inttoptr i64 %190 to i64*
  %295 = load i64, i64* %294
; # (consStr (val Q))
  %296 = call i64 @consStr(i64 %295)
; # (cons (consStr (val Q)) $Nil)
  %297 = call i64 @cons(i64 %296, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %298 = inttoptr i64 %292 to i64*
  %299 = getelementptr i64, i64* %298, i32 1
  store i64 %297, i64* %299
  br label %$40
$42:
  %300 = phi i32 [%238, %$40] ; # C
  %301 = phi i64 [%244, %$40] ; # X
  %302 = phi i64 [%240, %$40] ; # N
  %303 = phi i64 [%241, %$40] ; # Y
; # (loop (setq Y (set 2 Y (cons (mkChar (getChar C)) $Nil))) (? (eol...
  br label %$48
$48:
  %304 = phi i32 [%300, %$42], [%316, %$49] ; # C
  %305 = phi i64 [%301, %$42], [%317, %$49] ; # X
  %306 = phi i64 [%302, %$42], [%318, %$49] ; # N
  %307 = phi i64 [%303, %$42], [%319, %$49] ; # Y
; # (set 2 Y (cons (mkChar (getChar C)) $Nil))
; # (getChar C)
  %308 = call i32 @getChar(i32 %304)
; # (mkChar (getChar C))
  %309 = call i64 @mkChar(i32 %308)
; # (cons (mkChar (getChar C)) $Nil)
  %310 = call i64 @cons(i64 %309, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %311 = inttoptr i64 %307 to i64*
  %312 = getelementptr i64, i64* %311, i32 1
  store i64 %310, i64* %312
; # (? (eol (setq C (call $Get))))
; # (call $Get)
  %313 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %314 = call i32 %313()
; # (eol (setq C (call $Get)))
  %315 = call i1 @eol(i32 %314)
  br i1 %315, label %$50, label %$49
$49:
  %316 = phi i32 [%314, %$48] ; # C
  %317 = phi i64 [%305, %$48] ; # X
  %318 = phi i64 [%306, %$48] ; # N
  %319 = phi i64 [%310, %$48] ; # Y
  br label %$48
$50:
  %320 = phi i32 [%314, %$48] ; # C
  %321 = phi i64 [%305, %$48] ; # X
  %322 = phi i64 [%306, %$48] ; # N
  %323 = phi i64 [%310, %$48] ; # Y
  %324 = phi i64 [0, %$48] ; # ->
; # (drop *Safe)
  %325 = inttoptr i64 %231 to i64*
  %326 = getelementptr i64, i64* %325, i32 1
  %327 = load i64, i64* %326
  %328 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %327, i64* %328
  br label %$7
$7:
  %329 = phi i32 [%144, %$29], [%174, %$34], [%320, %$50] ; # C
  %330 = phi i64 [%145, %$29], [%175, %$34], [%321, %$50] ; # X
  %331 = phi i64 [%30, %$29], [%179, %$34], [%229, %$50] ; # ->
  br label %$6
$6:
  %332 = phi i32 [%8, %$4], [%329, %$7] ; # C
  %333 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%331, %$7] ; # ->
  ret i64 %333
}

define i64 @_in(i64) {
$1:
; # (let (X (cdr Exe) In (b8 (ioFrame T))) (rdOpen Exe (eval (++ X)) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (b8 (ioFrame T))
  %4 = alloca i8, i64 24
; # (++ X)
  %5 = inttoptr i64 %3 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$4, label %$3
$4:
  br label %$2
$3:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$6, label %$5
$6:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$2
$5:
  %15 = call i64 @evList(i64 %6)
  br label %$2
$2:
  %16 = phi i64 [%6, %$4], [%14, %$6], [%15, %$5] ; # ->
; # (rdOpen Exe (eval (++ X)) In)
  call void @rdOpen(i64 %0, i64 %16, i8* %4)
; # (pushInFiles In)
  call void @pushInFiles(i8* %4)
; # (prog1 (run X) (popInFiles))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%8, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popInFiles)
  call void @popInFiles()
  ret i64 %42
}

define i64 @_out(i64) {
$1:
; # (let (X (cdr Exe) Out (b8 (ioFrame T))) (wrOpen Exe (eval (++ X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (b8 (ioFrame T))
  %4 = alloca i8, i64 24
; # (++ X)
  %5 = inttoptr i64 %3 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$4, label %$3
$4:
  br label %$2
$3:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$6, label %$5
$6:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$2
$5:
  %15 = call i64 @evList(i64 %6)
  br label %$2
$2:
  %16 = phi i64 [%6, %$4], [%14, %$6], [%15, %$5] ; # ->
; # (wrOpen Exe (eval (++ X)) Out)
  call void @wrOpen(i64 %0, i64 %16, i8* %4)
; # (pushOutFiles Out)
  call void @pushOutFiles(i8* %4)
; # (prog1 (run X) (popOutFiles))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%8, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popOutFiles)
  call void @popOutFiles()
  ret i64 %42
}

define i64 @_err(i64) {
$1:
; # (let (X (cdr Exe) Err (b8 (ioFrame T))) (erOpen Exe (eval (++ X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (b8 (ioFrame T))
  %4 = alloca i8, i64 24
; # (++ X)
  %5 = inttoptr i64 %3 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$4, label %$3
$4:
  br label %$2
$3:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$6, label %$5
$6:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$2
$5:
  %15 = call i64 @evList(i64 %6)
  br label %$2
$2:
  %16 = phi i64 [%6, %$4], [%14, %$6], [%15, %$5] ; # ->
; # (erOpen Exe (eval (++ X)) Err)
  call void @erOpen(i64 %0, i64 %16, i8* %4)
; # (pushErrFiles Err)
  call void @pushErrFiles(i8* %4)
; # (prog1 (run X) (popErrFiles))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%8, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popErrFiles)
  call void @popErrFiles()
  ret i64 %42
}

define i64 @_ctl(i64) {
$1:
; # (let (X (cdr Exe) Ctl (b8 (ioFrame T))) (ctOpen Exe (eval (++ X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (b8 (ioFrame T))
  %4 = alloca i8, i64 24
; # (++ X)
  %5 = inttoptr i64 %3 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$4, label %$3
$4:
  br label %$2
$3:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$6, label %$5
$6:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$2
$5:
  %15 = call i64 @evList(i64 %6)
  br label %$2
$2:
  %16 = phi i64 [%6, %$4], [%14, %$6], [%15, %$5] ; # ->
; # (ctOpen Exe (eval (++ X)) Ctl)
  call void @ctOpen(i64 %0, i64 %16, i8* %4)
; # (pushCtlFiles Ctl)
  call void @pushCtlFiles(i8* %4)
; # (prog1 (run X) (popCtlFiles))
; # (run X)
  br label %$7
$7:
  %17 = phi i64 [%8, %$2], [%39, %$16] ; # Prg
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$8
$10:
  %24 = phi i64 [%21, %$7] ; # Prg
  %25 = and i64 %19, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  br label %$11
$12:
  %27 = and i64 %19, 8
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$14
$15:
  %29 = inttoptr i64 %19 to i64*
  %30 = load i64, i64* %29
  br label %$11
$14:
  %31 = call i64 @evList(i64 %19)
  br label %$11
$11:
  %32 = phi i64 [%19, %$13], [%30, %$15], [%31, %$14] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%21, %$7] ; # Prg
  %34 = and i64 %19, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  %36 = phi i64 [%33, %$8] ; # Prg
  %37 = call i64 @evList(i64 %19)
  %38 = icmp ne i64 %37, 0
  br label %$16
$16:
  %39 = phi i64 [%33, %$8], [%36, %$17] ; # Prg
  %40 = phi i1 [0, %$8], [%38, %$17] ; # ->
  br label %$7
$9:
  %41 = phi i64 [%24, %$11] ; # Prg
  %42 = phi i64 [%32, %$11] ; # ->
; # (popCtlFiles)
  call void @popCtlFiles()
  ret i64 %42
}

define i64 @_fd(i64) {
$1:
; # (currFd Exe)
  %1 = call i32 @currFd(i64 %0)
; # (i64 (currFd Exe))
  %2 = sext i32 %1 to i64
; # (cnt (i64 (currFd Exe)))
  %3 = shl i64 %2, 4
  %4 = or i64 %3, 2
  ret i64 %4
}

define i32 @forkLisp(i64) {
$1:
; # (flushAll)
  call void @flushAll()
; # (unless (val $Spkr) (when (lt0 (pipe $SpMiPipe)) (pipeErr Exe)) (...
; # (val $Spkr)
  %1 = load i32, i32* @$Spkr
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$2:
; # (when (lt0 (pipe $SpMiPipe)) (pipeErr Exe))
; # (pipe $SpMiPipe)
  %3 = call i32 @pipe(i32* bitcast ([2 x i32]* @$SpMiPipe to i32*))
; # (lt0 (pipe $SpMiPipe))
  %4 = icmp slt i32 %3, 0
  br i1 %4, label %$4, label %$5
$4:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$5:
; # (set $Spkr (val $SpMiPipe))
; # (val $SpMiPipe)
  %5 = load i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*)
  store i32 %5, i32* @$Spkr
; # (closeOnExec Exe (set $Spkr (val $SpMiPipe)))
  call void @closeOnExec(i64 %0, i32 %5)
; # (val 2 $SpMiPipe)
  %6 = getelementptr i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*), i32 1
  %7 = load i32, i32* %6
; # (closeOnExec Exe (val 2 $SpMiPipe))
  call void @closeOnExec(i64 %0, i32 %7)
  br label %$3
$3:
; # (let (Hear (b32 2) Tell (b32 2)) (when (or (lt0 (pipe Hear)) (lt0...
; # (b32 2)
  %8 = alloca i32, i64 2
; # (b32 2)
  %9 = alloca i32, i64 2
; # (when (or (lt0 (pipe Hear)) (lt0 (pipe Tell))) (pipeErr Exe))
; # (or (lt0 (pipe Hear)) (lt0 (pipe Tell)))
; # (pipe Hear)
  %10 = call i32 @pipe(i32* %8)
; # (lt0 (pipe Hear))
  %11 = icmp slt i32 %10, 0
  br i1 %11, label %$6, label %$7
$7:
; # (pipe Tell)
  %12 = call i32 @pipe(i32* %9)
; # (lt0 (pipe Tell))
  %13 = icmp slt i32 %12, 0
  br label %$6
$6:
  %14 = phi i1 [1, %$3], [%13, %$7] ; # ->
  br i1 %14, label %$8, label %$9
$8:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$9:
; # (val Hear)
  %15 = load i32, i32* %8
; # (closeOnExec Exe (val Hear))
  call void @closeOnExec(i64 %0, i32 %15)
; # (val 2 Hear)
  %16 = getelementptr i32, i32* %8, i32 1
  %17 = load i32, i32* %16
; # (closeOnExec Exe (val 2 Hear))
  call void @closeOnExec(i64 %0, i32 %17)
; # (val Tell)
  %18 = load i32, i32* %9
; # (closeOnExec Exe (val Tell))
  call void @closeOnExec(i64 %0, i32 %18)
; # (val 2 Tell)
  %19 = getelementptr i32, i32* %9, i32 1
  %20 = load i32, i32* %19
; # (closeOnExec Exe (val 2 Tell))
  call void @closeOnExec(i64 %0, i32 %20)
; # (let (I 0 N (val $Children)) (let Cld (val $Child) (while (> N I)...
; # (val $Children)
  %21 = load i64, i64* @$Children
; # (let Cld (val $Child) (while (> N I) (? (=0 ((child Cld) pid))) (...
; # (val $Child)
  %22 = load i8*, i8** @$Child
; # (while (> N I) (? (=0 ((child Cld) pid))) (inc 'I) (setq Cld (ofs...
  br label %$10
$10:
  %23 = phi i64 [0, %$9], [%37, %$13] ; # I
  %24 = phi i64 [%21, %$9], [%35, %$13] ; # N
  %25 = phi i8* [%22, %$9], [%38, %$13] ; # Cld
; # (> N I)
  %26 = icmp ugt i64 %24, %23
  br i1 %26, label %$11, label %$12
$11:
  %27 = phi i64 [%23, %$10] ; # I
  %28 = phi i64 [%24, %$10] ; # N
  %29 = phi i8* [%25, %$10] ; # Cld
; # (? (=0 ((child Cld) pid)))
; # ((child Cld) pid)
  %30 = getelementptr i8, i8* %29, i32 24
  %31 = bitcast i8* %30 to i32*
  %32 = load i32, i32* %31
; # (=0 ((child Cld) pid))
  %33 = icmp eq i32 %32, 0
  br i1 %33, label %$12, label %$13
$13:
  %34 = phi i64 [%27, %$11] ; # I
  %35 = phi i64 [%28, %$11] ; # N
  %36 = phi i8* [%29, %$11] ; # Cld
; # (inc 'I)
  %37 = add i64 %34, 1
; # (ofs Cld (child T))
  %38 = getelementptr i8, i8* %36, i32 36
  br label %$10
$12:
  %39 = phi i64 [%23, %$10], [%27, %$11] ; # I
  %40 = phi i64 [%24, %$10], [%28, %$11] ; # N
  %41 = phi i8* [%25, %$10], [%29, %$11] ; # Cld
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (set $Slot I $Spkr 0 $...
; # (fork)
  %42 = call i32 @fork()
; # (lt0 (fork))
  %43 = icmp slt i32 %42, 0
  br i1 %43, label %$16, label %$15
$16:
  %44 = phi i64 [%39, %$12] ; # I
  %45 = phi i64 [%40, %$12] ; # N
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$15:
  %46 = phi i64 [%39, %$12] ; # I
  %47 = phi i64 [%40, %$12] ; # N
; # (=0 @)
  %48 = icmp eq i32 %42, 0
  br i1 %48, label %$18, label %$17
$18:
  %49 = phi i64 [%46, %$15] ; # I
  %50 = phi i64 [%47, %$15] ; # N
; # (set $Slot I $Spkr 0 $Mic (val 2 $SpMiPipe))
  store i64 %49, i64* @$Slot
  store i32 0, i32* @$Spkr
; # (val 2 $SpMiPipe)
  %51 = getelementptr i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*), i32 1
  %52 = load i32, i32* %51
  store i32 %52, i32* @$Mic
; # (val 2 Hear)
  %53 = getelementptr i32, i32* %8, i32 1
  %54 = load i32, i32* %53
; # (close (val 2 Hear))
  %55 = call i32 @close(i32 %54)
; # (val Tell)
  %56 = load i32, i32* %9
; # (close (val Tell))
  %57 = call i32 @close(i32 %56)
; # (val $SpMiPipe)
  %58 = load i32, i32* bitcast ([2 x i32]* @$SpMiPipe to i32*)
; # (close (val $SpMiPipe))
  %59 = call i32 @close(i32 %58)
; # (when (val $Hear) (close @) (closeInFile @) (closeOutFile @))
; # (val $Hear)
  %60 = load i32, i32* @$Hear
  %61 = icmp ne i32 %60, 0
  br i1 %61, label %$19, label %$20
$19:
  %62 = phi i64 [%49, %$18] ; # I
  %63 = phi i64 [%50, %$18] ; # N
; # (close @)
  %64 = call i32 @close(i32 %60)
; # (closeInFile @)
  call void @closeInFile(i32 %60)
; # (closeOutFile @)
  call void @closeOutFile(i32 %60)
  br label %$20
$20:
  %65 = phi i64 [%49, %$18], [%62, %$19] ; # I
  %66 = phi i64 [%50, %$18], [%63, %$19] ; # N
; # (set $Hear (val Hear))
; # (val Hear)
  %67 = load i32, i32* %8
  store i32 %67, i32* @$Hear
; # (initInFile (set $Hear (val Hear)) null)
  %68 = call i8* @initInFile(i32 %67, i8* null)
; # (when (val $Tell) (close @))
; # (val $Tell)
  %69 = load i32, i32* @$Tell
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %$21, label %$22
$21:
  %71 = phi i64 [%65, %$20] ; # I
  %72 = phi i64 [%66, %$20] ; # N
; # (close @)
  %73 = call i32 @close(i32 %69)
  br label %$22
$22:
  %74 = phi i64 [%65, %$20], [%71, %$21] ; # I
  %75 = phi i64 [%66, %$20], [%72, %$21] ; # N
; # (set $Tell (val 2 Tell))
; # (val 2 Tell)
  %76 = getelementptr i32, i32* %9, i32 1
  %77 = load i32, i32* %76
  store i32 %77, i32* @$Tell
; # (let Cld (val $Child) (while (ge0 (dec 'N)) (let Cld: (child Cld)...
; # (val $Child)
  %78 = load i8*, i8** @$Child
; # (while (ge0 (dec 'N)) (let Cld: (child Cld) (when (Cld: pid) (fre...
  br label %$23
$23:
  %79 = phi i64 [%74, %$22], [%104, %$27] ; # I
  %80 = phi i64 [%75, %$22], [%105, %$27] ; # N
  %81 = phi i8* [%78, %$22], [%107, %$27] ; # Cld
; # (dec 'N)
  %82 = sub i64 %80, 1
; # (ge0 (dec 'N))
  %83 = icmp sge i64 %82, 0
  br i1 %83, label %$24, label %$25
$24:
  %84 = phi i64 [%79, %$23] ; # I
  %85 = phi i64 [%82, %$23] ; # N
  %86 = phi i8* [%81, %$23] ; # Cld
; # (let Cld: (child Cld) (when (Cld: pid) (free (Cld: buf)) (close (...
; # (when (Cld: pid) (free (Cld: buf)) (close (Cld: hear)) (close (Cl...
; # (Cld: pid)
  %87 = getelementptr i8, i8* %86, i32 24
  %88 = bitcast i8* %87 to i32*
  %89 = load i32, i32* %88
  %90 = icmp ne i32 %89, 0
  br i1 %90, label %$26, label %$27
$26:
  %91 = phi i64 [%84, %$24] ; # I
  %92 = phi i64 [%85, %$24] ; # N
  %93 = phi i8* [%86, %$24] ; # Cld
; # (Cld: buf)
  %94 = bitcast i8* %86 to i8**
  %95 = load i8*, i8** %94
; # (free (Cld: buf))
  call void @free(i8* %95)
; # (Cld: hear)
  %96 = getelementptr i8, i8* %86, i32 28
  %97 = bitcast i8* %96 to i32*
  %98 = load i32, i32* %97
; # (close (Cld: hear))
  %99 = call i32 @close(i32 %98)
; # (Cld: tell)
  %100 = getelementptr i8, i8* %86, i32 32
  %101 = bitcast i8* %100 to i32*
  %102 = load i32, i32* %101
; # (close (Cld: tell))
  %103 = call i32 @close(i32 %102)
  br label %$27
$27:
  %104 = phi i64 [%84, %$24], [%91, %$26] ; # I
  %105 = phi i64 [%85, %$24], [%92, %$26] ; # N
  %106 = phi i8* [%86, %$24], [%93, %$26] ; # Cld
; # (ofs Cld (child T))
  %107 = getelementptr i8, i8* %106, i32 36
  br label %$23
$25:
  %108 = phi i64 [%79, %$23] ; # I
  %109 = phi i64 [%82, %$23] ; # N
  %110 = phi i8* [%81, %$23] ; # Cld
; # (set $Children 0)
  store i64 0, i64* @$Children
; # (val $Child)
  %111 = load i8*, i8** @$Child
; # (free (val $Child))
  call void @free(i8* %111)
; # (set $Child null)
  store i8* null, i8** @$Child
; # (let In (val $InFrames) (while In (let In: (ioFrame In) (In: pid ...
; # (val $InFrames)
  %112 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (while In (let In: (ioFrame In) (In: pid 0) (setq In (In: link)))...
  br label %$28
$28:
  %113 = phi i64 [%108, %$25], [%117, %$29] ; # I
  %114 = phi i64 [%109, %$25], [%118, %$29] ; # N
  %115 = phi i8* [%112, %$25], [%123, %$29] ; # In
  %116 = icmp ne i8* %115, null
  br i1 %116, label %$29, label %$30
$29:
  %117 = phi i64 [%113, %$28] ; # I
  %118 = phi i64 [%114, %$28] ; # N
  %119 = phi i8* [%115, %$28] ; # In
; # (let In: (ioFrame In) (In: pid 0) (setq In (In: link)))
; # (In: pid 0)
  %120 = getelementptr i8, i8* %119, i32 12
  %121 = bitcast i8* %120 to i32*
  store i32 0, i32* %121
; # (In: link)
  %122 = bitcast i8* %119 to i8**
  %123 = load i8*, i8** %122
  br label %$28
$30:
  %124 = phi i64 [%113, %$28] ; # I
  %125 = phi i64 [%114, %$28] ; # N
  %126 = phi i8* [%115, %$28] ; # In
; # (let Out (val $OutFrames) (while Out (let Out: (ioFrame Out) (Out...
; # (val $OutFrames)
  %127 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (while Out (let Out: (ioFrame Out) (Out: pid 0) (setq Out (Out: l...
  br label %$31
$31:
  %128 = phi i64 [%124, %$30], [%132, %$32] ; # I
  %129 = phi i64 [%125, %$30], [%133, %$32] ; # N
  %130 = phi i8* [%127, %$30], [%138, %$32] ; # Out
  %131 = icmp ne i8* %130, null
  br i1 %131, label %$32, label %$33
$32:
  %132 = phi i64 [%128, %$31] ; # I
  %133 = phi i64 [%129, %$31] ; # N
  %134 = phi i8* [%130, %$31] ; # Out
; # (let Out: (ioFrame Out) (Out: pid 0) (setq Out (Out: link)))
; # (Out: pid 0)
  %135 = getelementptr i8, i8* %134, i32 12
  %136 = bitcast i8* %135 to i32*
  store i32 0, i32* %136
; # (Out: link)
  %137 = bitcast i8* %134 to i8**
  %138 = load i8*, i8** %137
  br label %$31
$33:
  %139 = phi i64 [%128, %$31] ; # I
  %140 = phi i64 [%129, %$31] ; # N
  %141 = phi i8* [%130, %$31] ; # Out
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (Ca: fin ZER...
; # (val $Catch)
  %142 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (Ca: fin ZERO) (setq Ca (Ca: link...
  br label %$34
$34:
  %143 = phi i64 [%139, %$33], [%147, %$35] ; # I
  %144 = phi i64 [%140, %$33], [%148, %$35] ; # N
  %145 = phi i8* [%142, %$33], [%154, %$35] ; # Ca
  %146 = icmp ne i8* %145, null
  br i1 %146, label %$35, label %$36
$35:
  %147 = phi i64 [%143, %$34] ; # I
  %148 = phi i64 [%144, %$34] ; # N
  %149 = phi i8* [%145, %$34] ; # Ca
; # (let Ca: (caFrame Ca) (Ca: fin ZERO) (setq Ca (Ca: link)))
; # (Ca: fin ZERO)
  %150 = getelementptr i8, i8* %149, i32 16
  %151 = ptrtoint i8* %150 to i64
  %152 = inttoptr i64 %151 to i64*
  store i64 2, i64* %152
; # (Ca: link)
  %153 = bitcast i8* %149 to i8**
  %154 = load i8*, i8** %153
  br label %$34
$36:
  %155 = phi i64 [%143, %$34] ; # I
  %156 = phi i64 [%144, %$34] ; # N
  %157 = phi i8* [%145, %$34] ; # Ca
; # (val Termio)
  %158 = load i8*, i8** @Termio
; # (free (val Termio))
  call void @free(i8* %158)
; # (set Termio null)
  store i8* null, i8** @Termio
; # (set $PRepl (val $Repl) $PPid (val $Pid))
; # (val $Repl)
  %159 = load i1, i1* @$Repl
  store i1 %159, i1* @$PRepl
; # (val $Pid)
  %160 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 344) to i64) to i64*
  %161 = load i64, i64* %160
  %162 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 360) to i64) to i64*
  store i64 %161, i64* %162
; # (set $Pid (cnt (i64 (getpid))))
; # (getpid)
  %163 = call i32 @getpid()
; # (i64 (getpid))
  %164 = sext i32 %163 to i64
; # (cnt (i64 (getpid)))
  %165 = shl i64 %164, 4
  %166 = or i64 %165, 2
  %167 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 344) to i64) to i64*
  store i64 %166, i64* %167
; # (val $Fork)
  %168 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 712) to i64) to i64*
  %169 = load i64, i64* %168
; # (execAt (val $Fork))
  %170 = call i64 @execAt(i64 %169)
; # (set $Fork $Nil)
  %171 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 712) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %171
  br label %$14
$17:
  %172 = phi i64 [%46, %$15] ; # I
  %173 = phi i64 [%47, %$15] ; # N
; # (let Pid @ (when (== I N) (set $Children (inc 'N 8)) (let P (set ...
; # (when (== I N) (set $Children (inc 'N 8)) (let P (set $Child (all...
; # (== I N)
  %174 = icmp eq i64 %172, %173
  br i1 %174, label %$37, label %$38
$37:
  %175 = phi i64 [%172, %$17] ; # I
  %176 = phi i64 [%173, %$17] ; # N
; # (set $Children (inc 'N 8))
; # (inc 'N 8)
  %177 = add i64 %176, 8
  store i64 %177, i64* @$Children
; # (let P (set $Child (alloc (val $Child) (* N (child T)))) (let Cld...
; # (set $Child (alloc (val $Child) (* N (child T))))
; # (val $Child)
  %178 = load i8*, i8** @$Child
; # (* N (child T))
  %179 = mul i64 %177, 36
; # (alloc (val $Child) (* N (child T)))
  %180 = call i8* @alloc(i8* %178, i64 %179)
  store i8* %180, i8** @$Child
; # (let Cld (ofs P (* I (child T))) (loop ((child Cld) pid 0) (? (==...
; # (* I (child T))
  %181 = mul i64 %175, 36
; # (ofs P (* I (child T)))
  %182 = getelementptr i8, i8* %180, i64 %181
; # (loop ((child Cld) pid 0) (? (== I (dec 'N))) (setq Cld (ofs Cld ...
  br label %$39
$39:
  %183 = phi i64 [%175, %$37], [%190, %$40] ; # I
  %184 = phi i64 [%177, %$37], [%191, %$40] ; # N
  %185 = phi i8* [%182, %$37], [%193, %$40] ; # Cld
; # ((child Cld) pid 0)
  %186 = getelementptr i8, i8* %185, i32 24
  %187 = bitcast i8* %186 to i32*
  store i32 0, i32* %187
; # (? (== I (dec 'N)))
; # (dec 'N)
  %188 = sub i64 %184, 1
; # (== I (dec 'N))
  %189 = icmp eq i64 %183, %188
  br i1 %189, label %$41, label %$40
$40:
  %190 = phi i64 [%183, %$39] ; # I
  %191 = phi i64 [%188, %$39] ; # N
  %192 = phi i8* [%185, %$39] ; # Cld
; # (ofs Cld (child T))
  %193 = getelementptr i8, i8* %192, i32 36
  br label %$39
$41:
  %194 = phi i64 [%183, %$39] ; # I
  %195 = phi i64 [%188, %$39] ; # N
  %196 = phi i8* [%185, %$39] ; # Cld
  %197 = phi i64 [0, %$39] ; # ->
  br label %$38
$38:
  %198 = phi i64 [%172, %$17], [%194, %$41] ; # I
  %199 = phi i64 [%173, %$17], [%195, %$41] ; # N
; # (val Hear)
  %200 = load i32, i32* %8
; # (close (val Hear))
  %201 = call i32 @close(i32 %200)
; # (val 2 Tell)
  %202 = getelementptr i32, i32* %9, i32 1
  %203 = load i32, i32* %202
; # (close (val 2 Tell))
  %204 = call i32 @close(i32 %203)
; # (let Cld: (child (ofs (val $Child) (* I (child T)))) (Cld: buf nu...
; # (val $Child)
  %205 = load i8*, i8** @$Child
; # (* I (child T))
  %206 = mul i64 %198, 36
; # (ofs (val $Child) (* I (child T)))
  %207 = getelementptr i8, i8* %205, i64 %206
; # (Cld: buf null)
  %208 = bitcast i8* %207 to i8**
  store i8* null, i8** %208
; # (Cld: ofs (Cld: cnt 0))
  %209 = getelementptr i8, i8* %207, i32 8
  %210 = bitcast i8* %209 to i64*
  %211 = getelementptr i8, i8* %207, i32 16
  %212 = bitcast i8* %211 to i64*
  store i64 0, i64* %212
  store i64 0, i64* %210
; # (Cld: pid Pid)
  %213 = getelementptr i8, i8* %207, i32 24
  %214 = bitcast i8* %213 to i32*
  store i32 %42, i32* %214
; # (Cld: hear (val Tell))
  %215 = getelementptr i8, i8* %207, i32 28
  %216 = bitcast i8* %215 to i32*
  %217 = load i32, i32* %9
  store i32 %217, i32* %216
; # (Cld: tell (val 2 Hear))
  %218 = getelementptr i8, i8* %207, i32 32
  %219 = bitcast i8* %218 to i32*
  %220 = getelementptr i32, i32* %8, i32 1
  %221 = load i32, i32* %220
  store i32 %221, i32* %219
; # (nonBlocking (Cld: tell (val 2 Hear)))
  %222 = call i32 @nonBlocking(i32 %221)
  br label %$14
$14:
  %223 = phi i64 [%155, %$36], [%198, %$38] ; # I
  %224 = phi i64 [%156, %$36], [%199, %$38] ; # N
  %225 = phi i32 [0, %$36], [%42, %$38] ; # ->
  ret i32 %225
}

define i64 @_pipe(i64) {
$1:
; # (let (X (cdr Exe) E (++ X) Pfd (b32 2) Io: (ioFrame (b8 (ioFrame ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (b32 2)
  %8 = alloca i32, i64 2
; # (b8 (ioFrame T))
  %9 = alloca i8, i64 24
; # (when (lt0 (if (pair X) (pipe Pfd) (socketPair Pfd))) (pipeErr Ex...
; # (if (pair X) (pipe Pfd) (socketPair Pfd))
; # (pair X)
  %10 = and i64 %7, 15
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$2, label %$3
$2:
; # (pipe Pfd)
  %12 = call i32 @pipe(i32* %8)
  br label %$4
$3:
; # (socketPair Pfd)
  %13 = call i32 @socketPair(i32* %8)
  br label %$4
$4:
  %14 = phi i32 [%12, %$2], [%13, %$3] ; # ->
; # (lt0 (if (pair X) (pipe Pfd) (socketPair Pfd)))
  %15 = icmp slt i32 %14, 0
  br i1 %15, label %$5, label %$6
$5:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$6:
; # (when (< (val 2 Pfd) 2) (pipeErr Exe))
; # (val 2 Pfd)
  %16 = getelementptr i32, i32* %8, i32 1
  %17 = load i32, i32* %16
; # (< (val 2 Pfd) 2)
  %18 = icmp slt i32 %17, 2
  br i1 %18, label %$7, label %$8
$7:
; # (pipeErr Exe)
  call void @pipeErr(i64 %0)
  unreachable
$8:
; # (cond ((=0 (Io: pid (forkLisp Exe))) (close (val Pfd)) (let F (va...
; # (Io: pid (forkLisp Exe))
  %19 = getelementptr i8, i8* %9, i32 12
  %20 = bitcast i8* %19 to i32*
  %21 = call i32 @forkLisp(i64 %0)
  store i32 %21, i32* %20
; # (=0 (Io: pid (forkLisp Exe)))
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %$11, label %$10
$11:
; # (val Pfd)
  %23 = load i32, i32* %8
; # (close (val Pfd))
  %24 = call i32 @close(i32 %23)
; # (let F (val 2 Pfd) (if (pair X) (setpgid 0 0) (dup2 F 0)) (dup2 F...
; # (val 2 Pfd)
  %25 = getelementptr i32, i32* %8, i32 1
  %26 = load i32, i32* %25
; # (if (pair X) (setpgid 0 0) (dup2 F 0))
; # (pair X)
  %27 = and i64 %7, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$12, label %$13
$12:
; # (setpgid 0 0)
  %29 = call i32 @setpgid(i32 0, i32 0)
  br label %$14
$13:
; # (dup2 F 0)
  %30 = call i32 @dup2(i32 %26, i32 0)
  br label %$14
$14:
  %31 = phi i32 [%29, %$12], [%30, %$13] ; # ->
; # (dup2 F 1)
  %32 = call i32 @dup2(i32 %26, i32 1)
; # (close F)
  %33 = call i32 @close(i32 %26)
; # (val SIGPIPE Sig)
  %34 = getelementptr i32, i32* @Sig, i32 4
  %35 = load i32, i32* %34
; # (val SigDfl)
  %36 = load i8*, i8** @SigDfl
; # (signal (val SIGPIPE Sig) (val SigDfl))
  %37 = call i8* @signal(i32 %35, i8* %36)
; # (Io: fd 1)
  %38 = getelementptr i8, i8* %9, i32 8
  %39 = bitcast i8* %38 to i32*
  store i32 1, i32* %39
; # (Io:)
; # (pushOutFiles (Io:))
  call void @pushOutFiles(i8* %9)
; # (val $OutFile)
  %40 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # ((outFile (val $OutFile)) tty NO)
  %41 = getelementptr i8, i8* %40, i32 4108
  %42 = bitcast i8* %41 to i1*
  store i1 0, i1* %42
; # (set $Run $Nil)
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %43
; # (set $LinePtr null)
  store i8* null, i8** @$LinePtr
; # (when (pair E) (evList E))
; # (pair E)
  %44 = and i64 %5, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$15, label %$16
$15:
; # (evList E)
  %46 = call i64 @evList(i64 %5)
  br label %$16
$16:
; # (bye 0)
  call void @bye(i32 0)
  unreachable
$10:
; # (val 2 Pfd)
  %47 = getelementptr i32, i32* %8, i32 1
  %48 = load i32, i32* %47
; # (close (val 2 Pfd))
  %49 = call i32 @close(i32 %48)
; # (let F (Io: fd (val Pfd)) (initInFile F null) (closeOnExec Exe F)...
; # (Io: fd (val Pfd))
  %50 = getelementptr i8, i8* %9, i32 8
  %51 = bitcast i8* %50 to i32*
  %52 = load i32, i32* %8
  store i32 %52, i32* %51
; # (initInFile F null)
  %53 = call i8* @initInFile(i32 %52, i8* null)
; # (closeOnExec Exe F)
  call void @closeOnExec(i64 %0, i32 %52)
; # (cond ((atom X) (initOutFile F) (cnt (i64 F))) (T (setpgid (Io: p...
; # (atom X)
  %54 = and i64 %7, 15
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$19, label %$18
$19:
; # (initOutFile F)
  %56 = call i8* @initOutFile(i32 %52)
; # (i64 F)
  %57 = sext i32 %52 to i64
; # (cnt (i64 F))
  %58 = shl i64 %57, 4
  %59 = or i64 %58, 2
  br label %$17
$18:
; # (Io: pid)
  %60 = getelementptr i8, i8* %9, i32 12
  %61 = bitcast i8* %60 to i32*
  %62 = load i32, i32* %61
; # (setpgid (Io: pid) 0)
  %63 = call i32 @setpgid(i32 %62, i32 0)
; # (Io:)
; # (pushInFiles (Io:))
  call void @pushInFiles(i8* %9)
; # (prog1 (run X) (popInFiles))
; # (run X)
  br label %$20
$20:
  %64 = phi i64 [%7, %$18], [%86, %$29] ; # Prg
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = getelementptr i64, i64* %65, i32 1
  %68 = load i64, i64* %67
  %69 = and i64 %68, 15
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$23, label %$21
$23:
  %71 = phi i64 [%68, %$20] ; # Prg
  %72 = and i64 %66, 6
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$26, label %$25
$26:
  br label %$24
$25:
  %74 = and i64 %66, 8
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$28, label %$27
$28:
  %76 = inttoptr i64 %66 to i64*
  %77 = load i64, i64* %76
  br label %$24
$27:
  %78 = call i64 @evList(i64 %66)
  br label %$24
$24:
  %79 = phi i64 [%66, %$26], [%77, %$28], [%78, %$27] ; # ->
  br label %$22
$21:
  %80 = phi i64 [%68, %$20] ; # Prg
  %81 = and i64 %66, 15
  %82 = icmp eq i64 %81, 0
  br i1 %82, label %$30, label %$29
$30:
  %83 = phi i64 [%80, %$21] ; # Prg
  %84 = call i64 @evList(i64 %66)
  %85 = icmp ne i64 %84, 0
  br label %$29
$29:
  %86 = phi i64 [%80, %$21], [%83, %$30] ; # Prg
  %87 = phi i1 [0, %$21], [%85, %$30] ; # ->
  br label %$20
$22:
  %88 = phi i64 [%71, %$24] ; # Prg
  %89 = phi i64 [%79, %$24] ; # ->
; # (popInFiles)
  call void @popInFiles()
  br label %$17
$17:
  %90 = phi i64 [%59, %$19], [%89, %$22] ; # ->
  br label %$9
$9:
  %91 = phi i64 [%90, %$17] ; # ->
  ret i64 %91
}

define i64 @_open(i64) {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) S (pathString Nm (b8 (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %6 = call i64 @pathSize(i64 %5)
; # (b8 (pathSize Nm))
  %7 = alloca i8, i64 %6
; # (pathString Nm (b8 (pathSize Nm)))
  %8 = call i8* @pathString(i64 %5, i8* %7)
; # (cadr X)
  %9 = inttoptr i64 %3 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
; # (eval (cadr X))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$4, label %$3
$4:
  br label %$2
$3:
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$6, label %$5
$6:
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
  br label %$2
$5:
  %20 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %21 = phi i64 [%13, %$4], [%19, %$6], [%20, %$5] ; # ->
; # (nil? (eval (cadr X)))
  %22 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (loop (? (ge0 (if Flg (openRdWrCreate S) (openRd S))) (closeOnExe...
  br label %$7
$7:
; # (? (ge0 (if Flg (openRdWrCreate S) (openRd S))) (closeOnExec Exe ...
; # (if Flg (openRdWrCreate S) (openRd S))
  br i1 %22, label %$8, label %$9
$8:
; # (openRdWrCreate S)
  %23 = call i32 @openRdWrCreate(i8* %8)
  br label %$10
$9:
; # (openRd S)
  %24 = call i32 @openRd(i8* %8)
  br label %$10
$10:
  %25 = phi i32 [%23, %$8], [%24, %$9] ; # ->
; # (ge0 (if Flg (openRdWrCreate S) (openRd S)))
  %26 = icmp sge i32 %25, 0
  br i1 %26, label %$13, label %$11
$13:
; # (closeOnExec Exe @)
  call void @closeOnExec(i64 %0, i32 %25)
; # (strdup S)
  %27 = call i8* @strdup(i8* %8)
; # (initInFile @ (strdup S))
  %28 = call i8* @initInFile(i32 %25, i8* %27)
; # (initOutFile @)
  %29 = call i8* @initOutFile(i32 %25)
; # (i64 @)
  %30 = sext i32 %25 to i64
; # (cnt (i64 @))
  %31 = shl i64 %30, 4
  %32 = or i64 %31, 2
  br label %$12
$11:
; # (? (<> (gErrno) EINTR) $Nil)
; # (gErrno)
  %33 = call i32 @gErrno()
; # (<> (gErrno) EINTR)
  %34 = icmp ne i32 %33, 2
  br i1 %34, label %$15, label %$14
$15:
  br label %$12
$14:
; # (sigChk Exe)
  %35 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %36 = icmp ne i32 %35, 0
  br i1 %36, label %$16, label %$17
$16:
  call void @sighandler(i64 %0)
  br label %$17
$17:
  br label %$7
$12:
  %37 = phi i64 [%32, %$13], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15] ; # ->
  ret i64 %37
}

define i64 @_close(i64) {
$1:
; # (let (C (eval (cadr Exe)) Fd (i32 (xCnt Exe C))) (loop (? (=0 (cl...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (xCnt Exe C)
  %14 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe C))
  %15 = trunc i64 %14 to i32
; # (loop (? (=0 (close Fd)) (closeInFile Fd) (closeOutFile Fd) C) (?...
  br label %$7
$7:
; # (? (=0 (close Fd)) (closeInFile Fd) (closeOutFile Fd) C)
; # (close Fd)
  %16 = call i32 @close(i32 %15)
; # (=0 (close Fd))
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %$10, label %$8
$10:
; # (closeInFile Fd)
  call void @closeInFile(i32 %15)
; # (closeOutFile Fd)
  call void @closeOutFile(i32 %15)
  br label %$9
$8:
; # (? (<> (gErrno) EINTR) $Nil)
; # (gErrno)
  %18 = call i32 @gErrno()
; # (<> (gErrno) EINTR)
  %19 = icmp ne i32 %18, 2
  br i1 %19, label %$12, label %$11
$12:
  br label %$9
$11:
; # (sigChk Exe)
  %20 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %21 = icmp ne i32 %20, 0
  br i1 %21, label %$13, label %$14
$13:
  call void @sighandler(i64 %0)
  br label %$14
$14:
  br label %$7
$9:
  %22 = phi i64 [%13, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %22
}

define i64 @_echo(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((and (nil? Y) (atom X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((and (nil? Y) (atom X)) (let C (if (val $Chr) @ (call $Get...
; # (and (nil? Y) (atom X))
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i64 [%7, %$2] ; # X
  %18 = phi i64 [%15, %$2] ; # Y
; # (atom X)
  %19 = and i64 %17, 15
  %20 = icmp ne i64 %19, 0
  br label %$8
$8:
  %21 = phi i64 [%7, %$2], [%17, %$9] ; # X
  %22 = phi i64 [%15, %$2], [%18, %$9] ; # Y
  %23 = phi i1 [0, %$2], [%20, %$9] ; # ->
  br i1 %23, label %$11, label %$10
$11:
  %24 = phi i64 [%21, %$8] ; # X
  %25 = phi i64 [%22, %$8] ; # Y
; # (let C (if (val $Chr) @ (call $Get)) (until (lt0 C) (call $Put (i...
; # (if (val $Chr) @ (call $Get))
; # (val $Chr)
  %26 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %27 = icmp ne i32 %26, 0
  br i1 %27, label %$12, label %$13
$12:
  %28 = phi i64 [%24, %$11] ; # X
  %29 = phi i64 [%25, %$11] ; # Y
  br label %$14
$13:
  %30 = phi i64 [%24, %$11] ; # X
  %31 = phi i64 [%25, %$11] ; # Y
; # (call $Get)
  %32 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %33 = call i32 %32()
  br label %$14
$14:
  %34 = phi i64 [%28, %$12], [%30, %$13] ; # X
  %35 = phi i64 [%29, %$12], [%31, %$13] ; # Y
  %36 = phi i32 [%26, %$12], [%33, %$13] ; # ->
; # (until (lt0 C) (call $Put (i8 C)) (setq C (call $Get)))
  br label %$15
$15:
  %37 = phi i64 [%34, %$14], [%41, %$16] ; # X
  %38 = phi i64 [%35, %$14], [%42, %$16] ; # Y
  %39 = phi i32 [%36, %$14], [%47, %$16] ; # C
; # (lt0 C)
  %40 = icmp slt i32 %39, 0
  br i1 %40, label %$17, label %$16
$16:
  %41 = phi i64 [%37, %$15] ; # X
  %42 = phi i64 [%38, %$15] ; # Y
  %43 = phi i32 [%39, %$15] ; # C
; # (i8 C)
  %44 = trunc i32 %43 to i8
; # (call $Put (i8 C))
  %45 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %45(i8 %44)
; # (call $Get)
  %46 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %47 = call i32 %46()
  br label %$15
$17:
  %48 = phi i64 [%37, %$15] ; # X
  %49 = phi i64 [%38, %$15] ; # Y
  %50 = phi i32 [%39, %$15] ; # C
  br label %$7
$10:
  %51 = phi i64 [%21, %$8] ; # X
  %52 = phi i64 [%22, %$8] ; # Y
; # (num? Y)
  %53 = and i64 %52, 6
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$19, label %$18
$19:
  %55 = phi i64 [%51, %$10] ; # X
  %56 = phi i64 [%52, %$10] ; # Y
; # (let N (xCnt Exe Y) (when (pair X) (let C (evCnt Exe X) (while (g...
; # (xCnt Exe Y)
  %57 = call i64 @xCnt(i64 %0, i64 %56)
; # (when (pair X) (let C (evCnt Exe X) (while (ge0 (dec 'N)) (when (...
; # (pair X)
  %58 = and i64 %55, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$20, label %$21
$20:
  %60 = phi i64 [%55, %$19] ; # X
  %61 = phi i64 [%56, %$19] ; # Y
  %62 = phi i64 [%57, %$19] ; # N
; # (let C (evCnt Exe X) (while (ge0 (dec 'N)) (when (lt0 (call $Get)...
; # (evCnt Exe X)
  %63 = call i64 @evCnt(i64 %0, i64 %60)
; # (while (ge0 (dec 'N)) (when (lt0 (call $Get)) (ret $Nil)))
  br label %$22
$22:
  %64 = phi i64 [%60, %$20], [%78, %$26] ; # X
  %65 = phi i64 [%61, %$20], [%79, %$26] ; # Y
  %66 = phi i64 [%62, %$20], [%80, %$26] ; # N
; # (dec 'N)
  %67 = sub i64 %66, 1
; # (ge0 (dec 'N))
  %68 = icmp sge i64 %67, 0
  br i1 %68, label %$23, label %$24
$23:
  %69 = phi i64 [%64, %$22] ; # X
  %70 = phi i64 [%65, %$22] ; # Y
  %71 = phi i64 [%67, %$22] ; # N
; # (when (lt0 (call $Get)) (ret $Nil))
; # (call $Get)
  %72 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %73 = call i32 %72()
; # (lt0 (call $Get))
  %74 = icmp slt i32 %73, 0
  br i1 %74, label %$25, label %$26
$25:
  %75 = phi i64 [%69, %$23] ; # X
  %76 = phi i64 [%70, %$23] ; # Y
  %77 = phi i64 [%71, %$23] ; # N
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$26:
  %78 = phi i64 [%69, %$23] ; # X
  %79 = phi i64 [%70, %$23] ; # Y
  %80 = phi i64 [%71, %$23] ; # N
  br label %$22
$24:
  %81 = phi i64 [%64, %$22] ; # X
  %82 = phi i64 [%65, %$22] ; # Y
  %83 = phi i64 [%67, %$22] ; # N
  br label %$21
$21:
  %84 = phi i64 [%55, %$19], [%81, %$24] ; # X
  %85 = phi i64 [%56, %$19], [%82, %$24] ; # Y
  %86 = phi i64 [%57, %$19], [%63, %$24] ; # N
; # (while (ge0 (dec 'N)) (when (lt0 (call $Get)) (ret $Nil)) (call $...
  br label %$27
$27:
  %87 = phi i64 [%84, %$21], [%101, %$31] ; # X
  %88 = phi i64 [%85, %$21], [%102, %$31] ; # Y
  %89 = phi i64 [%86, %$21], [%103, %$31] ; # N
; # (dec 'N)
  %90 = sub i64 %89, 1
; # (ge0 (dec 'N))
  %91 = icmp sge i64 %90, 0
  br i1 %91, label %$28, label %$29
$28:
  %92 = phi i64 [%87, %$27] ; # X
  %93 = phi i64 [%88, %$27] ; # Y
  %94 = phi i64 [%90, %$27] ; # N
; # (when (lt0 (call $Get)) (ret $Nil))
; # (call $Get)
  %95 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %96 = call i32 %95()
; # (lt0 (call $Get))
  %97 = icmp slt i32 %96, 0
  br i1 %97, label %$30, label %$31
$30:
  %98 = phi i64 [%92, %$28] ; # X
  %99 = phi i64 [%93, %$28] ; # Y
  %100 = phi i64 [%94, %$28] ; # N
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$31:
  %101 = phi i64 [%92, %$28] ; # X
  %102 = phi i64 [%93, %$28] ; # Y
  %103 = phi i64 [%94, %$28] ; # N
; # (i8 @)
  %104 = trunc i32 %96 to i8
; # (call $Put (i8 @))
  %105 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %105(i8 %104)
  br label %$27
$29:
  %106 = phi i64 [%87, %$27] ; # X
  %107 = phi i64 [%88, %$27] ; # Y
  %108 = phi i64 [%90, %$27] ; # N
; # (set $Chr 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$7
$18:
  %109 = phi i64 [%51, %$10] ; # X
  %110 = phi i64 [%52, %$10] ; # Y
; # (pair Y)
  %111 = and i64 %110, 15
  %112 = icmp eq i64 %111, 0
  br i1 %112, label %$33, label %$32
$33:
  %113 = phi i64 [%109, %$18] ; # X
  %114 = phi i64 [%110, %$18] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %114)
  unreachable
$32:
  %115 = phi i64 [%109, %$18] ; # X
  %116 = phi i64 [%110, %$18] ; # Y
; # (let (Link (val $Link) M (i64* null) N 1 P T) (loop (let Nm (xNam...
; # (val $Link)
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %118 = load i64, i64* %117
; # (i64* null)
  %119 = inttoptr i64 0 to i64*
; # (loop (let Nm (xName Exe Y) (setq P (link (push Y NIL 0 (any (buf...
  br label %$34
$34:
  %120 = phi i64 [%115, %$32], [%151, %$35] ; # X
  %121 = phi i64 [%116, %$32], [%152, %$35] ; # Y
  %122 = phi i64* [%119, %$32], [%145, %$35] ; # M
  %123 = phi i64 [1, %$32], [%153, %$35] ; # N
; # (let Nm (xName Exe Y) (setq P (link (push Y NIL 0 (any (bufString...
; # (xName Exe Y)
  %124 = call i64 @xName(i64 %0, i64 %121)
; # (bufSize Nm)
  %125 = call i64 @bufSize(i64 %124)
; # (b8 (bufSize Nm))
  %126 = alloca i8, i64 %125
; # (bufString Nm (b8 (bufSize Nm)))
  %127 = call i8* @bufString(i64 %124, i8* %126)
; # (any (bufString Nm (b8 (bufSize Nm))))
  %128 = ptrtoint i8* %127 to i64
; # (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm)))))
  %129 = alloca i64, i64 4, align 16
  %130 = ptrtoint i64* %129 to i64
  %131 = inttoptr i64 %130 to i64*
  store i64 %121, i64* %131
  %132 = add i64 %130, 16
  %133 = inttoptr i64 %132 to i64*
  store i64 0, i64* %133
  %134 = add i64 %130, 24
  %135 = inttoptr i64 %134 to i64*
  store i64 %128, i64* %135
; # (link (push Y NIL 0 (any (bufString Nm (b8 (bufSize Nm))))))
  %136 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %137 = load i64, i64* %136
  %138 = inttoptr i64 %130 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  store i64 %137, i64* %139
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %130, i64* %140
; # (? (atom X))
; # (atom X)
  %141 = and i64 %120, 15
  %142 = icmp ne i64 %141, 0
  br i1 %142, label %$36, label %$35
$35:
  %143 = phi i64 [%120, %$34] ; # X
  %144 = phi i64 [%121, %$34] ; # Y
  %145 = phi i64* [%122, %$34] ; # M
  %146 = phi i64 [%123, %$34] ; # N
  %147 = phi i64 [%130, %$34] ; # P
; # (++ X)
  %148 = inttoptr i64 %143 to i64*
  %149 = load i64, i64* %148
  %150 = getelementptr i64, i64* %148, i32 1
  %151 = load i64, i64* %150
; # (evSym (++ X))
  %152 = call i64 @evSym(i64 %149)
; # (inc 'N)
  %153 = add i64 %146, 1
  br label %$34
$36:
  %154 = phi i64 [%120, %$34] ; # X
  %155 = phi i64 [%121, %$34] ; # Y
  %156 = phi i64* [%122, %$34] ; # M
  %157 = phi i64 [%123, %$34] ; # N
  %158 = phi i64 [%130, %$34] ; # P
  %159 = phi i64 [0, %$34] ; # ->
; # (unless (val $Chr) (call $Get))
; # (val $Chr)
  %160 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %161 = icmp ne i32 %160, 0
  br i1 %161, label %$38, label %$37
$37:
  %162 = phi i64 [%154, %$36] ; # X
  %163 = phi i64 [%155, %$36] ; # Y
  %164 = phi i64* [%156, %$36] ; # M
  %165 = phi i64 [%157, %$36] ; # N
  %166 = phi i64 [%158, %$36] ; # P
; # (call $Get)
  %167 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %168 = call i32 %167()
  br label %$38
$38:
  %169 = phi i64 [%154, %$36], [%162, %$37] ; # X
  %170 = phi i64 [%155, %$36], [%163, %$37] ; # Y
  %171 = phi i64* [%156, %$36], [%164, %$37] ; # M
  %172 = phi i64 [%157, %$36], [%165, %$37] ; # N
  %173 = phi i64 [%158, %$36], [%166, %$37] ; # P
; # (while (ge0 (val $Chr)) (let (B (i8 @) Q (i64* P) I N OutM M OutC...
  br label %$39
$39:
  %174 = phi i64 [%169, %$38], [%728, %$79] ; # X
  %175 = phi i64 [%170, %$38], [%729, %$79] ; # Y
  %176 = phi i64* [%171, %$38], [%730, %$79] ; # M
  %177 = phi i64 [%172, %$38], [%731, %$79] ; # N
  %178 = phi i64 [%173, %$38], [%732, %$79] ; # P
; # (val $Chr)
  %179 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (ge0 (val $Chr))
  %180 = icmp sge i32 %179, 0
  br i1 %180, label %$40, label %$41
$40:
  %181 = phi i64 [%174, %$39] ; # X
  %182 = phi i64 [%175, %$39] ; # Y
  %183 = phi i64* [%176, %$39] ; # M
  %184 = phi i64 [%177, %$39] ; # N
  %185 = phi i64 [%178, %$39] ; # P
; # (let (B (i8 @) Q (i64* P) I N OutM M OutC (if M (val 3 M) 0)) (lo...
; # (i8 @)
  %186 = trunc i32 %179 to i8
; # (i64* P)
  %187 = inttoptr i64 %185 to i64*
; # (if M (val 3 M) 0)
  %188 = icmp ne i64* %183, null
  br i1 %188, label %$42, label %$43
$42:
  %189 = phi i64 [%181, %$40] ; # X
  %190 = phi i64 [%182, %$40] ; # Y
  %191 = phi i64* [%183, %$40] ; # M
  %192 = phi i64 [%184, %$40] ; # N
  %193 = phi i64 [%185, %$40] ; # P
  %194 = phi i64* [%187, %$40] ; # Q
  %195 = phi i64 [%184, %$40] ; # I
; # (val 3 M)
  %196 = getelementptr i64, i64* %191, i32 2
  %197 = load i64, i64* %196
  br label %$44
$43:
  %198 = phi i64 [%181, %$40] ; # X
  %199 = phi i64 [%182, %$40] ; # Y
  %200 = phi i64* [%183, %$40] ; # M
  %201 = phi i64 [%184, %$40] ; # N
  %202 = phi i64 [%185, %$40] ; # P
  %203 = phi i64* [%187, %$40] ; # Q
  %204 = phi i64 [%184, %$40] ; # I
  br label %$44
$44:
  %205 = phi i64 [%189, %$42], [%198, %$43] ; # X
  %206 = phi i64 [%190, %$42], [%199, %$43] ; # Y
  %207 = phi i64* [%191, %$42], [%200, %$43] ; # M
  %208 = phi i64 [%192, %$42], [%201, %$43] ; # N
  %209 = phi i64 [%193, %$42], [%202, %$43] ; # P
  %210 = phi i64* [%194, %$42], [%203, %$43] ; # Q
  %211 = phi i64 [%195, %$42], [%204, %$43] ; # I
  %212 = phi i64 [%197, %$42], [0, %$43] ; # ->
; # (loop (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (v...
  br label %$45
$45:
  %213 = phi i64 [%205, %$44], [%579, %$77] ; # X
  %214 = phi i64 [%206, %$44], [%580, %$77] ; # Y
  %215 = phi i64* [%207, %$44], [%581, %$77] ; # M
  %216 = phi i64 [%208, %$44], [%582, %$77] ; # N
  %217 = phi i64 [%209, %$44], [%583, %$77] ; # P
  %218 = phi i64* [%210, %$44], [%589, %$77] ; # Q
  %219 = phi i64 [%211, %$44], [%585, %$77] ; # I
  %220 = phi i64 [%212, %$44], [%586, %$77] ; # OutC
; # (loop (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S))...
  br label %$46
$46:
  %221 = phi i64 [%213, %$45], [%561, %$67] ; # X
  %222 = phi i64 [%214, %$45], [%562, %$67] ; # Y
  %223 = phi i64* [%215, %$45], [%563, %$67] ; # M
  %224 = phi i64 [%216, %$45], [%564, %$67] ; # N
  %225 = phi i64 [%217, %$45], [%565, %$67] ; # P
  %226 = phi i64* [%218, %$45], [%566, %$67] ; # Q
  %227 = phi i64 [%219, %$45], [%567, %$67] ; # I
  %228 = phi i64 [%220, %$45], [%568, %$67] ; # OutC
; # (let S (ofs (i8* (val 4 Q)) (val 3 Q)) (when (== B (val S)) (set ...
; # (val 4 Q)
  %229 = getelementptr i64, i64* %226, i32 3
  %230 = load i64, i64* %229
; # (i8* (val 4 Q))
  %231 = inttoptr i64 %230 to i8*
; # (val 3 Q)
  %232 = getelementptr i64, i64* %226, i32 2
  %233 = load i64, i64* %232
; # (ofs (i8* (val 4 Q)) (val 3 Q))
  %234 = getelementptr i8, i8* %231, i64 %233
; # (when (== B (val S)) (set 3 Q (inc (val 3 Q))) (? (val 2 S) (unle...
; # (val S)
  %235 = load i8, i8* %234
; # (== B (val S))
  %236 = icmp eq i8 %186, %235
  br i1 %236, label %$47, label %$48
$47:
  %237 = phi i64 [%221, %$46] ; # X
  %238 = phi i64 [%222, %$46] ; # Y
  %239 = phi i64* [%223, %$46] ; # M
  %240 = phi i64 [%224, %$46] ; # N
  %241 = phi i64 [%225, %$46] ; # P
  %242 = phi i64* [%226, %$46] ; # Q
  %243 = phi i64 [%227, %$46] ; # I
  %244 = phi i64 [%228, %$46] ; # OutC
  %245 = phi i8* [%234, %$46] ; # S
; # (set 3 Q (inc (val 3 Q)))
; # (val 3 Q)
  %246 = getelementptr i64, i64* %242, i32 2
  %247 = load i64, i64* %246
; # (inc (val 3 Q))
  %248 = add i64 %247, 1
  %249 = getelementptr i64, i64* %242, i32 2
  store i64 %248, i64* %249
; # (? (val 2 S) (unless (and M (>= (val 3 M) (val 3 Q))) (setq M Q))...
; # (val 2 S)
  %250 = getelementptr i8, i8* %245, i32 1
  %251 = load i8, i8* %250
  %252 = icmp ne i8 %251, 0
  br i1 %252, label %$51, label %$49
$51:
  %253 = phi i64 [%237, %$47] ; # X
  %254 = phi i64 [%238, %$47] ; # Y
  %255 = phi i64* [%239, %$47] ; # M
  %256 = phi i64 [%240, %$47] ; # N
  %257 = phi i64 [%241, %$47] ; # P
  %258 = phi i64* [%242, %$47] ; # Q
  %259 = phi i64 [%243, %$47] ; # I
  %260 = phi i64 [%244, %$47] ; # OutC
  %261 = phi i8* [%245, %$47] ; # S
; # (unless (and M (>= (val 3 M) (val 3 Q))) (setq M Q))
; # (and M (>= (val 3 M) (val 3 Q)))
  %262 = icmp ne i64* %255, null
  br i1 %262, label %$53, label %$52
$53:
  %263 = phi i64 [%253, %$51] ; # X
  %264 = phi i64 [%254, %$51] ; # Y
  %265 = phi i64* [%255, %$51] ; # M
  %266 = phi i64 [%256, %$51] ; # N
  %267 = phi i64 [%257, %$51] ; # P
  %268 = phi i64* [%258, %$51] ; # Q
  %269 = phi i64 [%259, %$51] ; # I
  %270 = phi i64 [%260, %$51] ; # OutC
  %271 = phi i8* [%261, %$51] ; # S
; # (val 3 M)
  %272 = getelementptr i64, i64* %265, i32 2
  %273 = load i64, i64* %272
; # (val 3 Q)
  %274 = getelementptr i64, i64* %268, i32 2
  %275 = load i64, i64* %274
; # (>= (val 3 M) (val 3 Q))
  %276 = icmp uge i64 %273, %275
  br label %$52
$52:
  %277 = phi i64 [%253, %$51], [%263, %$53] ; # X
  %278 = phi i64 [%254, %$51], [%264, %$53] ; # Y
  %279 = phi i64* [%255, %$51], [%265, %$53] ; # M
  %280 = phi i64 [%256, %$51], [%266, %$53] ; # N
  %281 = phi i64 [%257, %$51], [%267, %$53] ; # P
  %282 = phi i64* [%258, %$51], [%268, %$53] ; # Q
  %283 = phi i64 [%259, %$51], [%269, %$53] ; # I
  %284 = phi i64 [%260, %$51], [%270, %$53] ; # OutC
  %285 = phi i8* [%261, %$51], [%271, %$53] ; # S
  %286 = phi i1 [0, %$51], [%276, %$53] ; # ->
  br i1 %286, label %$55, label %$54
$54:
  %287 = phi i64 [%277, %$52] ; # X
  %288 = phi i64 [%278, %$52] ; # Y
  %289 = phi i64* [%279, %$52] ; # M
  %290 = phi i64 [%280, %$52] ; # N
  %291 = phi i64 [%281, %$52] ; # P
  %292 = phi i64* [%282, %$52] ; # Q
  %293 = phi i64 [%283, %$52] ; # I
  %294 = phi i64 [%284, %$52] ; # OutC
  %295 = phi i8* [%285, %$52] ; # S
  br label %$55
$55:
  %296 = phi i64 [%277, %$52], [%287, %$54] ; # X
  %297 = phi i64 [%278, %$52], [%288, %$54] ; # Y
  %298 = phi i64* [%279, %$52], [%292, %$54] ; # M
  %299 = phi i64 [%280, %$52], [%290, %$54] ; # N
  %300 = phi i64 [%281, %$52], [%291, %$54] ; # P
  %301 = phi i64* [%282, %$52], [%292, %$54] ; # Q
  %302 = phi i64 [%283, %$52], [%293, %$54] ; # I
  %303 = phi i64 [%284, %$52], [%294, %$54] ; # OutC
  %304 = phi i8* [%285, %$52], [%295, %$54] ; # S
  br label %$50
$49:
  %305 = phi i64 [%237, %$47] ; # X
  %306 = phi i64 [%238, %$47] ; # Y
  %307 = phi i64* [%239, %$47] ; # M
  %308 = phi i64 [%240, %$47] ; # N
  %309 = phi i64 [%241, %$47] ; # P
  %310 = phi i64* [%242, %$47] ; # Q
  %311 = phi i64 [%243, %$47] ; # I
  %312 = phi i64 [%244, %$47] ; # OutC
  %313 = phi i8* [%245, %$47] ; # S
; # (when OutM (setq S (i8* (val 4 OutM))) (dec 'OutC (val 3 Q)) (unt...
  %314 = icmp ne i64* %183, null
  br i1 %314, label %$56, label %$57
$56:
  %315 = phi i64 [%305, %$49] ; # X
  %316 = phi i64 [%306, %$49] ; # Y
  %317 = phi i64* [%307, %$49] ; # M
  %318 = phi i64 [%308, %$49] ; # N
  %319 = phi i64 [%309, %$49] ; # P
  %320 = phi i64* [%310, %$49] ; # Q
  %321 = phi i64 [%311, %$49] ; # I
  %322 = phi i64 [%312, %$49] ; # OutC
  %323 = phi i8* [%313, %$49] ; # S
; # (val 4 OutM)
  %324 = getelementptr i64, i64* %183, i32 3
  %325 = load i64, i64* %324
; # (i8* (val 4 OutM))
  %326 = inttoptr i64 %325 to i8*
; # (val 3 Q)
  %327 = getelementptr i64, i64* %320, i32 2
  %328 = load i64, i64* %327
; # (dec 'OutC (val 3 Q))
  %329 = sub i64 %322, %328
; # (until (lt0 OutC) (call $Put (val S)) (inc 'S) (dec 'OutC))
  br label %$58
$58:
  %330 = phi i64 [%315, %$56], [%340, %$59] ; # X
  %331 = phi i64 [%316, %$56], [%341, %$59] ; # Y
  %332 = phi i64* [%317, %$56], [%342, %$59] ; # M
  %333 = phi i64 [%318, %$56], [%343, %$59] ; # N
  %334 = phi i64 [%319, %$56], [%344, %$59] ; # P
  %335 = phi i64* [%320, %$56], [%345, %$59] ; # Q
  %336 = phi i64 [%321, %$56], [%346, %$59] ; # I
  %337 = phi i64 [%329, %$56], [%352, %$59] ; # OutC
  %338 = phi i8* [%326, %$56], [%351, %$59] ; # S
; # (lt0 OutC)
  %339 = icmp slt i64 %337, 0
  br i1 %339, label %$60, label %$59
$59:
  %340 = phi i64 [%330, %$58] ; # X
  %341 = phi i64 [%331, %$58] ; # Y
  %342 = phi i64* [%332, %$58] ; # M
  %343 = phi i64 [%333, %$58] ; # N
  %344 = phi i64 [%334, %$58] ; # P
  %345 = phi i64* [%335, %$58] ; # Q
  %346 = phi i64 [%336, %$58] ; # I
  %347 = phi i64 [%337, %$58] ; # OutC
  %348 = phi i8* [%338, %$58] ; # S
; # (val S)
  %349 = load i8, i8* %348
; # (call $Put (val S))
  %350 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %350(i8 %349)
; # (inc 'S)
  %351 = getelementptr i8, i8* %348, i32 1
; # (dec 'OutC)
  %352 = sub i64 %347, 1
  br label %$58
$60:
  %353 = phi i64 [%330, %$58] ; # X
  %354 = phi i64 [%331, %$58] ; # Y
  %355 = phi i64* [%332, %$58] ; # M
  %356 = phi i64 [%333, %$58] ; # N
  %357 = phi i64 [%334, %$58] ; # P
  %358 = phi i64* [%335, %$58] ; # Q
  %359 = phi i64 [%336, %$58] ; # I
  %360 = phi i64 [%337, %$58] ; # OutC
  %361 = phi i8* [%338, %$58] ; # S
  br label %$57
$57:
  %362 = phi i64 [%305, %$49], [%353, %$60] ; # X
  %363 = phi i64 [%306, %$49], [%354, %$60] ; # Y
  %364 = phi i64* [%307, %$49], [%355, %$60] ; # M
  %365 = phi i64 [%308, %$49], [%356, %$60] ; # N
  %366 = phi i64 [%309, %$49], [%357, %$60] ; # P
  %367 = phi i64* [%310, %$49], [%358, %$60] ; # Q
  %368 = phi i64 [%311, %$49], [%359, %$60] ; # I
  %369 = phi i64 [%312, %$49], [%360, %$60] ; # OutC
  %370 = phi i8* [%313, %$49], [%361, %$60] ; # S
; # (set $Chr 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (set $Link Link)
  %371 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %118, i64* %371
; # (val Q)
  %372 = load i64, i64* %367
; # (ret (val Q))
  ret i64 %372
$48:
  %373 = phi i64 [%221, %$46] ; # X
  %374 = phi i64 [%222, %$46] ; # Y
  %375 = phi i64* [%223, %$46] ; # M
  %376 = phi i64 [%224, %$46] ; # N
  %377 = phi i64 [%225, %$46] ; # P
  %378 = phi i64* [%226, %$46] ; # Q
  %379 = phi i64 [%227, %$46] ; # I
  %380 = phi i64 [%228, %$46] ; # OutC
  %381 = phi i8* [%234, %$46] ; # S
; # (? (=0 (val 3 Q)))
; # (val 3 Q)
  %382 = getelementptr i64, i64* %378, i32 2
  %383 = load i64, i64* %382
; # (=0 (val 3 Q))
  %384 = icmp eq i64 %383, 0
  br i1 %384, label %$50, label %$61
$61:
  %385 = phi i64 [%373, %$48] ; # X
  %386 = phi i64 [%374, %$48] ; # Y
  %387 = phi i64* [%375, %$48] ; # M
  %388 = phi i64 [%376, %$48] ; # N
  %389 = phi i64 [%377, %$48] ; # P
  %390 = phi i64* [%378, %$48] ; # Q
  %391 = phi i64 [%379, %$48] ; # I
  %392 = phi i64 [%380, %$48] ; # OutC
; # (let S (ofs (i8* (val 4 Q)) 1) (while (set 3 Q (dec (val 3 Q))) (...
; # (val 4 Q)
  %393 = getelementptr i64, i64* %390, i32 3
  %394 = load i64, i64* %393
; # (i8* (val 4 Q))
  %395 = inttoptr i64 %394 to i8*
; # (ofs (i8* (val 4 Q)) 1)
  %396 = getelementptr i8, i8* %395, i32 1
; # (while (set 3 Q (dec (val 3 Q))) (? (=0 (memcmp (i8* (val 4 Q)) S...
  br label %$62
$62:
  %397 = phi i64 [%385, %$61], [%425, %$65] ; # X
  %398 = phi i64 [%386, %$61], [%426, %$65] ; # Y
  %399 = phi i64* [%387, %$61], [%427, %$65] ; # M
  %400 = phi i64 [%388, %$61], [%428, %$65] ; # N
  %401 = phi i64 [%389, %$61], [%429, %$65] ; # P
  %402 = phi i64* [%390, %$61], [%430, %$65] ; # Q
  %403 = phi i64 [%391, %$61], [%431, %$65] ; # I
  %404 = phi i64 [%392, %$61], [%432, %$65] ; # OutC
  %405 = phi i8* [%396, %$61], [%434, %$65] ; # S
; # (set 3 Q (dec (val 3 Q)))
; # (val 3 Q)
  %406 = getelementptr i64, i64* %402, i32 2
  %407 = load i64, i64* %406
; # (dec (val 3 Q))
  %408 = sub i64 %407, 1
  %409 = getelementptr i64, i64* %402, i32 2
  store i64 %408, i64* %409
  %410 = icmp ne i64 %408, 0
  br i1 %410, label %$63, label %$64
$63:
  %411 = phi i64 [%397, %$62] ; # X
  %412 = phi i64 [%398, %$62] ; # Y
  %413 = phi i64* [%399, %$62] ; # M
  %414 = phi i64 [%400, %$62] ; # N
  %415 = phi i64 [%401, %$62] ; # P
  %416 = phi i64* [%402, %$62] ; # Q
  %417 = phi i64 [%403, %$62] ; # I
  %418 = phi i64 [%404, %$62] ; # OutC
  %419 = phi i8* [%405, %$62] ; # S
; # (? (=0 (memcmp (i8* (val 4 Q)) S @)))
; # (val 4 Q)
  %420 = getelementptr i64, i64* %416, i32 3
  %421 = load i64, i64* %420
; # (i8* (val 4 Q))
  %422 = inttoptr i64 %421 to i8*
; # (memcmp (i8* (val 4 Q)) S @)
  %423 = call i32 @memcmp(i8* %422, i8* %419, i64 %408)
; # (=0 (memcmp (i8* (val 4 Q)) S @))
  %424 = icmp eq i32 %423, 0
  br i1 %424, label %$64, label %$65
$65:
  %425 = phi i64 [%411, %$63] ; # X
  %426 = phi i64 [%412, %$63] ; # Y
  %427 = phi i64* [%413, %$63] ; # M
  %428 = phi i64 [%414, %$63] ; # N
  %429 = phi i64 [%415, %$63] ; # P
  %430 = phi i64* [%416, %$63] ; # Q
  %431 = phi i64 [%417, %$63] ; # I
  %432 = phi i64 [%418, %$63] ; # OutC
  %433 = phi i8* [%419, %$63] ; # S
; # (inc 'S)
  %434 = getelementptr i8, i8* %433, i32 1
  br label %$62
$64:
  %435 = phi i64 [%397, %$62], [%411, %$63] ; # X
  %436 = phi i64 [%398, %$62], [%412, %$63] ; # Y
  %437 = phi i64* [%399, %$62], [%413, %$63] ; # M
  %438 = phi i64 [%400, %$62], [%414, %$63] ; # N
  %439 = phi i64 [%401, %$62], [%415, %$63] ; # P
  %440 = phi i64* [%402, %$62], [%416, %$63] ; # Q
  %441 = phi i64 [%403, %$62], [%417, %$63] ; # I
  %442 = phi i64 [%404, %$62], [%418, %$63] ; # OutC
  %443 = phi i8* [%405, %$62], [%419, %$63] ; # S
; # (when (== Q M) (setq M (i64* null)) (let (Z (i64* P) J N) (loop (...
; # (== Q M)
  %444 = icmp eq i64* %440, %437
  br i1 %444, label %$66, label %$67
$66:
  %445 = phi i64 [%435, %$64] ; # X
  %446 = phi i64 [%436, %$64] ; # Y
  %447 = phi i64* [%437, %$64] ; # M
  %448 = phi i64 [%438, %$64] ; # N
  %449 = phi i64 [%439, %$64] ; # P
  %450 = phi i64* [%440, %$64] ; # Q
  %451 = phi i64 [%441, %$64] ; # I
  %452 = phi i64 [%442, %$64] ; # OutC
; # (i64* null)
  %453 = inttoptr i64 0 to i64*
; # (let (Z (i64* P) J N) (loop (when (val 3 Z) (unless (and M (>= (v...
; # (i64* P)
  %454 = inttoptr i64 %449 to i64*
; # (loop (when (val 3 Z) (unless (and M (>= (val 3 M) (val 3 Z))) (s...
  br label %$68
$68:
  %455 = phi i64 [%445, %$66], [%537, %$75] ; # X
  %456 = phi i64 [%446, %$66], [%538, %$75] ; # Y
  %457 = phi i64* [%453, %$66], [%539, %$75] ; # M
  %458 = phi i64 [%448, %$66], [%540, %$75] ; # N
  %459 = phi i64 [%449, %$66], [%541, %$75] ; # P
  %460 = phi i64* [%450, %$66], [%542, %$75] ; # Q
  %461 = phi i64 [%451, %$66], [%543, %$75] ; # I
  %462 = phi i64 [%452, %$66], [%544, %$75] ; # OutC
  %463 = phi i64* [%454, %$66], [%549, %$75] ; # Z
  %464 = phi i64 [%448, %$66], [%546, %$75] ; # J
; # (when (val 3 Z) (unless (and M (>= (val 3 M) (val 3 Z))) (setq M ...
; # (val 3 Z)
  %465 = getelementptr i64, i64* %463, i32 2
  %466 = load i64, i64* %465
  %467 = icmp ne i64 %466, 0
  br i1 %467, label %$69, label %$70
$69:
  %468 = phi i64 [%455, %$68] ; # X
  %469 = phi i64 [%456, %$68] ; # Y
  %470 = phi i64* [%457, %$68] ; # M
  %471 = phi i64 [%458, %$68] ; # N
  %472 = phi i64 [%459, %$68] ; # P
  %473 = phi i64* [%460, %$68] ; # Q
  %474 = phi i64 [%461, %$68] ; # I
  %475 = phi i64 [%462, %$68] ; # OutC
  %476 = phi i64* [%463, %$68] ; # Z
  %477 = phi i64 [%464, %$68] ; # J
; # (unless (and M (>= (val 3 M) (val 3 Z))) (setq M Z))
; # (and M (>= (val 3 M) (val 3 Z)))
  %478 = icmp ne i64* %470, null
  br i1 %478, label %$72, label %$71
$72:
  %479 = phi i64 [%468, %$69] ; # X
  %480 = phi i64 [%469, %$69] ; # Y
  %481 = phi i64* [%470, %$69] ; # M
  %482 = phi i64 [%471, %$69] ; # N
  %483 = phi i64 [%472, %$69] ; # P
  %484 = phi i64* [%473, %$69] ; # Q
  %485 = phi i64 [%474, %$69] ; # I
  %486 = phi i64 [%475, %$69] ; # OutC
  %487 = phi i64* [%476, %$69] ; # Z
  %488 = phi i64 [%477, %$69] ; # J
; # (val 3 M)
  %489 = getelementptr i64, i64* %481, i32 2
  %490 = load i64, i64* %489
; # (val 3 Z)
  %491 = getelementptr i64, i64* %487, i32 2
  %492 = load i64, i64* %491
; # (>= (val 3 M) (val 3 Z))
  %493 = icmp uge i64 %490, %492
  br label %$71
$71:
  %494 = phi i64 [%468, %$69], [%479, %$72] ; # X
  %495 = phi i64 [%469, %$69], [%480, %$72] ; # Y
  %496 = phi i64* [%470, %$69], [%481, %$72] ; # M
  %497 = phi i64 [%471, %$69], [%482, %$72] ; # N
  %498 = phi i64 [%472, %$69], [%483, %$72] ; # P
  %499 = phi i64* [%473, %$69], [%484, %$72] ; # Q
  %500 = phi i64 [%474, %$69], [%485, %$72] ; # I
  %501 = phi i64 [%475, %$69], [%486, %$72] ; # OutC
  %502 = phi i64* [%476, %$69], [%487, %$72] ; # Z
  %503 = phi i64 [%477, %$69], [%488, %$72] ; # J
  %504 = phi i1 [0, %$69], [%493, %$72] ; # ->
  br i1 %504, label %$74, label %$73
$73:
  %505 = phi i64 [%494, %$71] ; # X
  %506 = phi i64 [%495, %$71] ; # Y
  %507 = phi i64* [%496, %$71] ; # M
  %508 = phi i64 [%497, %$71] ; # N
  %509 = phi i64 [%498, %$71] ; # P
  %510 = phi i64* [%499, %$71] ; # Q
  %511 = phi i64 [%500, %$71] ; # I
  %512 = phi i64 [%501, %$71] ; # OutC
  %513 = phi i64* [%502, %$71] ; # Z
  %514 = phi i64 [%503, %$71] ; # J
  br label %$74
$74:
  %515 = phi i64 [%494, %$71], [%505, %$73] ; # X
  %516 = phi i64 [%495, %$71], [%506, %$73] ; # Y
  %517 = phi i64* [%496, %$71], [%513, %$73] ; # M
  %518 = phi i64 [%497, %$71], [%508, %$73] ; # N
  %519 = phi i64 [%498, %$71], [%509, %$73] ; # P
  %520 = phi i64* [%499, %$71], [%510, %$73] ; # Q
  %521 = phi i64 [%500, %$71], [%511, %$73] ; # I
  %522 = phi i64 [%501, %$71], [%512, %$73] ; # OutC
  %523 = phi i64* [%502, %$71], [%513, %$73] ; # Z
  %524 = phi i64 [%503, %$71], [%514, %$73] ; # J
  br label %$70
$70:
  %525 = phi i64 [%455, %$68], [%515, %$74] ; # X
  %526 = phi i64 [%456, %$68], [%516, %$74] ; # Y
  %527 = phi i64* [%457, %$68], [%517, %$74] ; # M
  %528 = phi i64 [%458, %$68], [%518, %$74] ; # N
  %529 = phi i64 [%459, %$68], [%519, %$74] ; # P
  %530 = phi i64* [%460, %$68], [%520, %$74] ; # Q
  %531 = phi i64 [%461, %$68], [%521, %$74] ; # I
  %532 = phi i64 [%462, %$68], [%522, %$74] ; # OutC
  %533 = phi i64* [%463, %$68], [%523, %$74] ; # Z
  %534 = phi i64 [%464, %$68], [%524, %$74] ; # J
; # (? (=0 (dec 'J)))
; # (dec 'J)
  %535 = sub i64 %534, 1
; # (=0 (dec 'J))
  %536 = icmp eq i64 %535, 0
  br i1 %536, label %$76, label %$75
$75:
  %537 = phi i64 [%525, %$70] ; # X
  %538 = phi i64 [%526, %$70] ; # Y
  %539 = phi i64* [%527, %$70] ; # M
  %540 = phi i64 [%528, %$70] ; # N
  %541 = phi i64 [%529, %$70] ; # P
  %542 = phi i64* [%530, %$70] ; # Q
  %543 = phi i64 [%531, %$70] ; # I
  %544 = phi i64 [%532, %$70] ; # OutC
  %545 = phi i64* [%533, %$70] ; # Z
  %546 = phi i64 [%535, %$70] ; # J
; # (val 2 Z)
  %547 = getelementptr i64, i64* %545, i32 1
  %548 = load i64, i64* %547
; # (i64* (val 2 Z))
  %549 = inttoptr i64 %548 to i64*
  br label %$68
$76:
  %550 = phi i64 [%525, %$70] ; # X
  %551 = phi i64 [%526, %$70] ; # Y
  %552 = phi i64* [%527, %$70] ; # M
  %553 = phi i64 [%528, %$70] ; # N
  %554 = phi i64 [%529, %$70] ; # P
  %555 = phi i64* [%530, %$70] ; # Q
  %556 = phi i64 [%531, %$70] ; # I
  %557 = phi i64 [%532, %$70] ; # OutC
  %558 = phi i64* [%533, %$70] ; # Z
  %559 = phi i64 [%535, %$70] ; # J
  %560 = phi i64 [0, %$70] ; # ->
  br label %$67
$67:
  %561 = phi i64 [%435, %$64], [%550, %$76] ; # X
  %562 = phi i64 [%436, %$64], [%551, %$76] ; # Y
  %563 = phi i64* [%437, %$64], [%552, %$76] ; # M
  %564 = phi i64 [%438, %$64], [%553, %$76] ; # N
  %565 = phi i64 [%439, %$64], [%554, %$76] ; # P
  %566 = phi i64* [%440, %$64], [%555, %$76] ; # Q
  %567 = phi i64 [%441, %$64], [%556, %$76] ; # I
  %568 = phi i64 [%442, %$64], [%557, %$76] ; # OutC
  br label %$46
$50:
  %569 = phi i64 [%296, %$55], [%373, %$48] ; # X
  %570 = phi i64 [%297, %$55], [%374, %$48] ; # Y
  %571 = phi i64* [%298, %$55], [%375, %$48] ; # M
  %572 = phi i64 [%299, %$55], [%376, %$48] ; # N
  %573 = phi i64 [%300, %$55], [%377, %$48] ; # P
  %574 = phi i64* [%301, %$55], [%378, %$48] ; # Q
  %575 = phi i64 [%302, %$55], [%379, %$48] ; # I
  %576 = phi i64 [%303, %$55], [%380, %$48] ; # OutC
; # (? (=0 (dec 'I)))
; # (dec 'I)
  %577 = sub i64 %575, 1
; # (=0 (dec 'I))
  %578 = icmp eq i64 %577, 0
  br i1 %578, label %$78, label %$77
$77:
  %579 = phi i64 [%569, %$50] ; # X
  %580 = phi i64 [%570, %$50] ; # Y
  %581 = phi i64* [%571, %$50] ; # M
  %582 = phi i64 [%572, %$50] ; # N
  %583 = phi i64 [%573, %$50] ; # P
  %584 = phi i64* [%574, %$50] ; # Q
  %585 = phi i64 [%577, %$50] ; # I
  %586 = phi i64 [%576, %$50] ; # OutC
; # (val 2 Q)
  %587 = getelementptr i64, i64* %584, i32 1
  %588 = load i64, i64* %587
; # (i64* (val 2 Q))
  %589 = inttoptr i64 %588 to i64*
  br label %$45
$78:
  %590 = phi i64 [%569, %$50] ; # X
  %591 = phi i64 [%570, %$50] ; # Y
  %592 = phi i64* [%571, %$50] ; # M
  %593 = phi i64 [%572, %$50] ; # N
  %594 = phi i64 [%573, %$50] ; # P
  %595 = phi i64* [%574, %$50] ; # Q
  %596 = phi i64 [%577, %$50] ; # I
  %597 = phi i64 [%576, %$50] ; # OutC
  %598 = phi i64 [0, %$50] ; # ->
; # (cond ((=0 M) (when OutM (let (S (i8* (val 4 OutM)) C OutC) (loop...
; # (=0 M)
  %599 = icmp eq i64* %592, null
  br i1 %599, label %$81, label %$80
$81:
  %600 = phi i64 [%590, %$78] ; # X
  %601 = phi i64 [%591, %$78] ; # Y
  %602 = phi i64* [%592, %$78] ; # M
  %603 = phi i64 [%593, %$78] ; # N
  %604 = phi i64 [%594, %$78] ; # P
  %605 = phi i64* [%595, %$78] ; # Q
  %606 = phi i64 [%596, %$78] ; # I
  %607 = phi i64 [%597, %$78] ; # OutC
; # (when OutM (let (S (i8* (val 4 OutM)) C OutC) (loop (call $Put (v...
  %608 = icmp ne i64* %183, null
  br i1 %608, label %$82, label %$83
$82:
  %609 = phi i64 [%600, %$81] ; # X
  %610 = phi i64 [%601, %$81] ; # Y
  %611 = phi i64* [%602, %$81] ; # M
  %612 = phi i64 [%603, %$81] ; # N
  %613 = phi i64 [%604, %$81] ; # P
  %614 = phi i64* [%605, %$81] ; # Q
  %615 = phi i64 [%606, %$81] ; # I
  %616 = phi i64 [%607, %$81] ; # OutC
; # (let (S (i8* (val 4 OutM)) C OutC) (loop (call $Put (val S)) (inc...
; # (val 4 OutM)
  %617 = getelementptr i64, i64* %183, i32 3
  %618 = load i64, i64* %617
; # (i8* (val 4 OutM))
  %619 = inttoptr i64 %618 to i8*
; # (loop (call $Put (val S)) (inc 'S) (? (=0 (dec 'C))))
  br label %$84
$84:
  %620 = phi i64 [%609, %$82], [%635, %$85] ; # X
  %621 = phi i64 [%610, %$82], [%636, %$85] ; # Y
  %622 = phi i64* [%611, %$82], [%637, %$85] ; # M
  %623 = phi i64 [%612, %$82], [%638, %$85] ; # N
  %624 = phi i64 [%613, %$82], [%639, %$85] ; # P
  %625 = phi i64* [%614, %$82], [%640, %$85] ; # Q
  %626 = phi i64 [%615, %$82], [%641, %$85] ; # I
  %627 = phi i64 [%616, %$82], [%642, %$85] ; # OutC
  %628 = phi i8* [%619, %$82], [%643, %$85] ; # S
  %629 = phi i64 [%616, %$82], [%644, %$85] ; # C
; # (val S)
  %630 = load i8, i8* %628
; # (call $Put (val S))
  %631 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %631(i8 %630)
; # (inc 'S)
  %632 = getelementptr i8, i8* %628, i32 1
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %633 = sub i64 %629, 1
; # (=0 (dec 'C))
  %634 = icmp eq i64 %633, 0
  br i1 %634, label %$86, label %$85
$85:
  %635 = phi i64 [%620, %$84] ; # X
  %636 = phi i64 [%621, %$84] ; # Y
  %637 = phi i64* [%622, %$84] ; # M
  %638 = phi i64 [%623, %$84] ; # N
  %639 = phi i64 [%624, %$84] ; # P
  %640 = phi i64* [%625, %$84] ; # Q
  %641 = phi i64 [%626, %$84] ; # I
  %642 = phi i64 [%627, %$84] ; # OutC
  %643 = phi i8* [%632, %$84] ; # S
  %644 = phi i64 [%633, %$84] ; # C
  br label %$84
$86:
  %645 = phi i64 [%620, %$84] ; # X
  %646 = phi i64 [%621, %$84] ; # Y
  %647 = phi i64* [%622, %$84] ; # M
  %648 = phi i64 [%623, %$84] ; # N
  %649 = phi i64 [%624, %$84] ; # P
  %650 = phi i64* [%625, %$84] ; # Q
  %651 = phi i64 [%626, %$84] ; # I
  %652 = phi i64 [%627, %$84] ; # OutC
  %653 = phi i8* [%632, %$84] ; # S
  %654 = phi i64 [%633, %$84] ; # C
  %655 = phi i64 [0, %$84] ; # ->
  br label %$83
$83:
  %656 = phi i64 [%600, %$81], [%645, %$86] ; # X
  %657 = phi i64 [%601, %$81], [%646, %$86] ; # Y
  %658 = phi i64* [%602, %$81], [%647, %$86] ; # M
  %659 = phi i64 [%603, %$81], [%648, %$86] ; # N
  %660 = phi i64 [%604, %$81], [%649, %$86] ; # P
  %661 = phi i64* [%605, %$81], [%650, %$86] ; # Q
  %662 = phi i64 [%606, %$81], [%651, %$86] ; # I
  %663 = phi i64 [%607, %$81], [%652, %$86] ; # OutC
; # (call $Put B)
  %664 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %664(i8 %186)
  br label %$79
$80:
  %665 = phi i64 [%590, %$78] ; # X
  %666 = phi i64 [%591, %$78] ; # Y
  %667 = phi i64* [%592, %$78] ; # M
  %668 = phi i64 [%593, %$78] ; # N
  %669 = phi i64 [%594, %$78] ; # P
  %670 = phi i64* [%595, %$78] ; # Q
  %671 = phi i64 [%596, %$78] ; # I
  %672 = phi i64 [%597, %$78] ; # OutC
  %673 = icmp ne i64* %183, null
  br i1 %673, label %$88, label %$87
$88:
  %674 = phi i64 [%665, %$80] ; # X
  %675 = phi i64 [%666, %$80] ; # Y
  %676 = phi i64* [%667, %$80] ; # M
  %677 = phi i64 [%668, %$80] ; # N
  %678 = phi i64 [%669, %$80] ; # P
  %679 = phi i64* [%670, %$80] ; # Q
  %680 = phi i64 [%671, %$80] ; # I
  %681 = phi i64 [%672, %$80] ; # OutC
; # (let S (i8* (val 4 OutM)) (dec 'OutC (val 3 M)) (until (lt0 OutC)...
; # (val 4 OutM)
  %682 = getelementptr i64, i64* %183, i32 3
  %683 = load i64, i64* %682
; # (i8* (val 4 OutM))
  %684 = inttoptr i64 %683 to i8*
; # (val 3 M)
  %685 = getelementptr i64, i64* %676, i32 2
  %686 = load i64, i64* %685
; # (dec 'OutC (val 3 M))
  %687 = sub i64 %681, %686
; # (until (lt0 OutC) (call $Put (val S)) (inc 'S) (dec 'OutC))
  br label %$89
$89:
  %688 = phi i64 [%674, %$88], [%698, %$90] ; # X
  %689 = phi i64 [%675, %$88], [%699, %$90] ; # Y
  %690 = phi i64* [%676, %$88], [%700, %$90] ; # M
  %691 = phi i64 [%677, %$88], [%701, %$90] ; # N
  %692 = phi i64 [%678, %$88], [%702, %$90] ; # P
  %693 = phi i64* [%679, %$88], [%703, %$90] ; # Q
  %694 = phi i64 [%680, %$88], [%704, %$90] ; # I
  %695 = phi i64 [%687, %$88], [%710, %$90] ; # OutC
  %696 = phi i8* [%684, %$88], [%709, %$90] ; # S
; # (lt0 OutC)
  %697 = icmp slt i64 %695, 0
  br i1 %697, label %$91, label %$90
$90:
  %698 = phi i64 [%688, %$89] ; # X
  %699 = phi i64 [%689, %$89] ; # Y
  %700 = phi i64* [%690, %$89] ; # M
  %701 = phi i64 [%691, %$89] ; # N
  %702 = phi i64 [%692, %$89] ; # P
  %703 = phi i64* [%693, %$89] ; # Q
  %704 = phi i64 [%694, %$89] ; # I
  %705 = phi i64 [%695, %$89] ; # OutC
  %706 = phi i8* [%696, %$89] ; # S
; # (val S)
  %707 = load i8, i8* %706
; # (call $Put (val S))
  %708 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %708(i8 %707)
; # (inc 'S)
  %709 = getelementptr i8, i8* %706, i32 1
; # (dec 'OutC)
  %710 = sub i64 %705, 1
  br label %$89
$91:
  %711 = phi i64 [%688, %$89] ; # X
  %712 = phi i64 [%689, %$89] ; # Y
  %713 = phi i64* [%690, %$89] ; # M
  %714 = phi i64 [%691, %$89] ; # N
  %715 = phi i64 [%692, %$89] ; # P
  %716 = phi i64* [%693, %$89] ; # Q
  %717 = phi i64 [%694, %$89] ; # I
  %718 = phi i64 [%695, %$89] ; # OutC
  %719 = phi i8* [%696, %$89] ; # S
  br label %$79
$87:
  %720 = phi i64 [%665, %$80] ; # X
  %721 = phi i64 [%666, %$80] ; # Y
  %722 = phi i64* [%667, %$80] ; # M
  %723 = phi i64 [%668, %$80] ; # N
  %724 = phi i64 [%669, %$80] ; # P
  %725 = phi i64* [%670, %$80] ; # Q
  %726 = phi i64 [%671, %$80] ; # I
  %727 = phi i64 [%672, %$80] ; # OutC
  br label %$79
$79:
  %728 = phi i64 [%656, %$83], [%711, %$91], [%720, %$87] ; # X
  %729 = phi i64 [%657, %$83], [%712, %$91], [%721, %$87] ; # Y
  %730 = phi i64* [%658, %$83], [%713, %$91], [%722, %$87] ; # M
  %731 = phi i64 [%659, %$83], [%714, %$91], [%723, %$87] ; # N
  %732 = phi i64 [%660, %$83], [%715, %$91], [%724, %$87] ; # P
  %733 = phi i64* [%661, %$83], [%716, %$91], [%725, %$87] ; # Q
  %734 = phi i64 [%662, %$83], [%717, %$91], [%726, %$87] ; # I
  %735 = phi i64 [%663, %$83], [%718, %$91], [%727, %$87] ; # OutC
; # (call $Get)
  %736 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %737 = call i32 %736()
  br label %$39
$41:
  %738 = phi i64 [%174, %$39] ; # X
  %739 = phi i64 [%175, %$39] ; # Y
  %740 = phi i64* [%176, %$39] ; # M
  %741 = phi i64 [%177, %$39] ; # N
  %742 = phi i64 [%178, %$39] ; # P
; # (set $Link Link)
  %743 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %118, i64* %743
  br label %$7
$7:
  %744 = phi i64 [%48, %$17], [%106, %$29], [%738, %$41] ; # X
  %745 = phi i64 [%49, %$17], [%107, %$29], [%739, %$41] ; # Y
  %746 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$29], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$41] ; # ->
  ret i64 %746
}

define void @_putStdout(i8) {
$1:
; # (let Out: (outFile (val $OutFile)) (when (Out:) (let I (Out: ix) ...
; # (val $OutFile)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (when (Out:) (let I (Out: ix) (when (== I BUFSIZ) (Out: ix (setq ...
; # (Out:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$2, label %$3
$2:
; # (let I (Out: ix) (when (== I BUFSIZ) (Out: ix (setq I 0)) (wrByte...
; # (Out: ix)
  %3 = bitcast i8* %1 to i64*
  %4 = load i64, i64* %3
; # (when (== I BUFSIZ) (Out: ix (setq I 0)) (wrBytes (Out: fd) (Out:...
; # (== I BUFSIZ)
  %5 = icmp eq i64 %4, 4096
  br i1 %5, label %$4, label %$5
$4:
  %6 = phi i64 [%4, %$2] ; # I
; # (Out: ix (setq I 0))
  %7 = bitcast i8* %1 to i64*
  store i64 0, i64* %7
; # (Out: fd)
  %8 = getelementptr i8, i8* %1, i32 8
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (Out: (buf))
  %11 = getelementptr i8, i8* %1, i32 12
; # (wrBytes (Out: fd) (Out: (buf)) BUFSIZ)
  %12 = call i1 @wrBytes(i32 %10, i8* %11, i64 4096)
  br label %$5
$5:
  %13 = phi i64 [%4, %$2], [0, %$4] ; # I
; # (set (ofs (Out: (buf)) I) B)
; # (Out: (buf))
  %14 = getelementptr i8, i8* %1, i32 12
; # (ofs (Out: (buf)) I)
  %15 = getelementptr i8, i8* %14, i64 %13
  store i8 %0, i8* %15
; # (Out: ix (inc 'I))
  %16 = bitcast i8* %1 to i64*
  %17 = add i64 %13, 1
  store i64 %17, i64* %16
; # (when (and (== B (char "^J")) (Out: tty)) (Out: ix 0) (wrBytes (O...
; # (and (== B (char "^J")) (Out: tty))
; # (== B (char "^J"))
  %18 = icmp eq i8 %0, 10
  br i1 %18, label %$7, label %$6
$7:
  %19 = phi i64 [%17, %$5] ; # I
; # (Out: tty)
  %20 = getelementptr i8, i8* %1, i32 4108
  %21 = bitcast i8* %20 to i1*
  %22 = load i1, i1* %21
  br label %$6
$6:
  %23 = phi i64 [%17, %$5], [%19, %$7] ; # I
  %24 = phi i1 [0, %$5], [%22, %$7] ; # ->
  br i1 %24, label %$8, label %$9
$8:
  %25 = phi i64 [%23, %$6] ; # I
; # (Out: ix 0)
  %26 = bitcast i8* %1 to i64*
  store i64 0, i64* %26
; # (Out: fd)
  %27 = getelementptr i8, i8* %1, i32 8
  %28 = bitcast i8* %27 to i32*
  %29 = load i32, i32* %28
; # (Out: (buf))
  %30 = getelementptr i8, i8* %1, i32 12
; # (wrBytes (Out: fd) (Out: (buf)) I)
  %31 = call i1 @wrBytes(i32 %29, i8* %30, i64 %25)
  br label %$9
$9:
  %32 = phi i64 [%23, %$6], [%25, %$8] ; # I
  br label %$3
$3:
  ret void
}

define void @newline() {
$1:
; # (call $Put (char "^J"))
  %0 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %0(i8 10)
  ret void
}

define void @space() {
$1:
; # (call $Put (char " "))
  %0 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %0(i8 32)
  ret void
}

define void @outWord(i64) {
$1:
; # (when (> N 9) (outWord (/ N 10)) (setq N (% N 10)))
; # (> N 9)
  %1 = icmp ugt i64 %0, 9
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i64 [%0, %$1] ; # N
; # (/ N 10)
  %3 = udiv i64 %2, 10
; # (outWord (/ N 10))
  call void @outWord(i64 %3)
; # (% N 10)
  %4 = urem i64 %2, 10
  br label %$3
$3:
  %5 = phi i64 [%0, %$1], [%4, %$2] ; # N
; # (i8 N)
  %6 = trunc i64 %5 to i8
; # (+ (i8 N) (char "0"))
  %7 = add i8 %6, 48
; # (call $Put (+ (i8 N) (char "0")))
  %8 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %8(i8 %7)
  ret void
}

define void @outNum(i64) {
$1:
; # (when (sign? X) (call $Put (char "-")))
; # (sign? X)
  %1 = and i64 %0, 8
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (call $Put (char "-"))
  %3 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %3(i8 45)
  br label %$3
$3:
; # (i64 X)
; # (shr (i64 X) 4)
  %4 = lshr i64 %0, 4
; # (outWord (shr (i64 X) 4))
  call void @outWord(i64 %4)
  ret void
}

define void @outOct(i64) {
$1:
; # (when (> N 7) (outOct (shr N 3)) (setq N (& N 7)))
; # (> N 7)
  %1 = icmp ugt i64 %0, 7
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i64 [%0, %$1] ; # N
; # (shr N 3)
  %3 = lshr i64 %2, 3
; # (outOct (shr N 3))
  call void @outOct(i64 %3)
; # (& N 7)
  %4 = and i64 %2, 7
  br label %$3
$3:
  %5 = phi i64 [%0, %$1], [%4, %$2] ; # N
; # (i8 N)
  %6 = trunc i64 %5 to i8
; # (+ (i8 N) (char "0"))
  %7 = add i8 %6, 48
; # (call $Put (+ (i8 N) (char "0")))
  %8 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %8(i8 %7)
  ret void
}

define void @outAo(i32) {
$1:
; # (when (> N 15) (outAo (shr N 4)) (setq N (& N 15)))
; # (> N 15)
  %1 = icmp sgt i32 %0, 15
  br i1 %1, label %$2, label %$3
$2:
  %2 = phi i32 [%0, %$1] ; # N
; # (shr N 4)
  %3 = lshr i32 %2, 4
; # (outAo (shr N 4))
  call void @outAo(i32 %3)
; # (& N 15)
  %4 = and i32 %2, 15
  br label %$3
$3:
  %5 = phi i32 [%0, %$1], [%4, %$2] ; # N
; # (i8 N)
  %6 = trunc i32 %5 to i8
; # (+ (i8 N) (char "@"))
  %7 = add i8 %6, 64
; # (call $Put (+ (i8 N) (char "@")))
  %8 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %8(i8 %7)
  ret void
}

define i8* @bufAo(i8*, i32) {
$1:
; # (when (> N 15) (setq P (bufAo P (shr N 4)) N (& N 15)))
; # (> N 15)
  %2 = icmp sgt i32 %1, 15
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i8* [%0, %$1] ; # P
  %4 = phi i32 [%1, %$1] ; # N
; # (shr N 4)
  %5 = lshr i32 %4, 4
; # (bufAo P (shr N 4))
  %6 = call i8* @bufAo(i8* %3, i32 %5)
; # (& N 15)
  %7 = and i32 %4, 15
  br label %$3
$3:
  %8 = phi i8* [%0, %$1], [%6, %$2] ; # P
  %9 = phi i32 [%1, %$1], [%7, %$2] ; # N
; # (set P (+ (i8 N) (char "@")))
; # (i8 N)
  %10 = trunc i32 %9 to i8
; # (+ (i8 N) (char "@"))
  %11 = add i8 %10, 64
  store i8 %11, i8* %8
; # (inc P)
  %12 = getelementptr i8, i8* %8, i32 1
  ret i8* %12
}

define void @prExt(i64) {
$1:
; # (when (objFile Nm) (outAo @))
; # (objFile Nm)
  %1 = call i32 @objFile(i64 %0)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (outAo @)
  call void @outAo(i32 %1)
  br label %$3
$3:
; # (objId Nm)
  %3 = call i64 @objId(i64 %0)
; # (outOct (objId Nm))
  call void @outOct(i64 %3)
  ret void
}

define void @outString(i8*) {
$1:
; # (while (val S) (call $Put @) (inc 'S))
  br label %$2
$2:
  %1 = phi i8* [%0, %$1], [%6, %$3] ; # S
; # (val S)
  %2 = load i8, i8* %1
  %3 = icmp ne i8 %2, 0
  br i1 %3, label %$3, label %$4
$3:
  %4 = phi i8* [%1, %$2] ; # S
; # (call $Put @)
  %5 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %5(i8 %2)
; # (inc 'S)
  %6 = getelementptr i8, i8* %4, i32 1
  br label %$2
$4:
  %7 = phi i8* [%1, %$2] ; # S
  ret void
}

define void @prName(i64) {
$1:
; # (let P (push 0 Name) (while (symByte P) (call $Put @)))
; # (push 0 Name)
  %1 = alloca i64, i64 2, align 16
  store i64 0, i64* %1
  %2 = getelementptr i64, i64* %1, i32 1
  store i64 %0, i64* %2
; # (while (symByte P) (call $Put @))
  br label %$2
$2:
; # (symByte P)
  %3 = call i8 @symByte(i64* %1)
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %$3, label %$4
$3:
; # (call $Put @)
  %5 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %5(i8 %3)
  br label %$2
$4:
  ret void
}

define void @outName(i64) {
$1:
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (name (val (tail Sym)))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%10, %$3] ; # Tail
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$4, label %$3
$3:
  %7 = phi i64 [%4, %$2] ; # Tail
  %8 = inttoptr i64 %7 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  br label %$2
$4:
  %11 = phi i64 [%4, %$2] ; # Tail
; # (prName (name (val (tail Sym))))
  call void @prName(i64 %11)
  ret void
}

define void @print(i64) {
$1:
; # (sigChk 0)
  %1 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  call void @sighandler(i64 0)
  br label %$3
$3:
; # (cond ((cnt? X) (outNum X)) ((big? X) (fmtNum X -1 0 0 null)) ((s...
; # (cnt? X)
  %3 = and i64 %0, 2
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$6, label %$5
$6:
  %5 = phi i64 [%0, %$3] ; # X
; # (outNum X)
  call void @outNum(i64 %5)
  br label %$4
$5:
  %6 = phi i64 [%0, %$3] ; # X
; # (big? X)
  %7 = and i64 %6, 4
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$8, label %$7
$8:
  %9 = phi i64 [%6, %$5] ; # X
; # (fmtNum X -1 0 0 null)
  %10 = call i64 @fmtNum(i64 %9, i64 -1, i8 0, i8 0, i64* null)
  br label %$4
$7:
  %11 = phi i64 [%6, %$5] ; # X
; # (sym? X)
  %12 = and i64 %11, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$10, label %$9
$10:
  %14 = phi i64 [%11, %$7] ; # X
; # (cond ((sym? (val (tail X))) (call $Put (char "{")) (prExt (name ...
; # (tail X)
  %15 = add i64 %14, -8
; # (val (tail X))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (sym? (val (tail X)))
  %18 = and i64 %17, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$13, label %$12
$13:
  %20 = phi i64 [%14, %$10] ; # X
; # (call $Put (char "{"))
  %21 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %21(i8 123)
; # (& @ -9)
  %22 = and i64 %17, -9
; # (name (& @ -9))
  br label %$14
$14:
  %23 = phi i64 [%22, %$13], [%29, %$15] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$16, label %$15
$15:
  %26 = phi i64 [%23, %$14] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$14
$16:
  %30 = phi i64 [%23, %$14] ; # Tail
; # (prExt (name (& @ -9)))
  call void @prExt(i64 %30)
; # (call $Put (char "}"))
  %31 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %31(i8 125)
  br label %$11
$12:
  %32 = phi i64 [%14, %$10] ; # X
; # (name @)
  br label %$17
$17:
  %33 = phi i64 [%17, %$12], [%39, %$18] ; # Tail
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$19, label %$18
$18:
  %36 = phi i64 [%33, %$17] ; # Tail
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  br label %$17
$19:
  %40 = phi i64 [%33, %$17] ; # Tail
; # (== (name @) ZERO)
  %41 = icmp eq i64 %40, 2
  br i1 %41, label %$21, label %$20
$21:
  %42 = phi i64 [%32, %$19] ; # X
; # (call $Put (char "$"))
  %43 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %43(i8 36)
; # (int X)
  %44 = lshr i64 %42, 4
; # (outOct (int X))
  call void @outOct(i64 %44)
  br label %$11
$20:
  %45 = phi i64 [%32, %$19] ; # X
; # (let (Nm @ Lst (val $Intern) F NO) (loop (? (atom Lst) (call $Put...
; # (val $Intern)
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %47 = load i64, i64* %46
; # (loop (? (atom Lst) (call $Put (char "\"")) (let (P (push 0 Nm) B...
  br label %$22
$22:
  %48 = phi i64 [%45, %$20], [%219, %$40] ; # X
  %49 = phi i64 [%47, %$20], [%224, %$40] ; # Lst
  %50 = phi i1 [0, %$20], [%221, %$40] ; # F
; # (? (atom Lst) (call $Put (char "\"")) (let (P (push 0 Nm) B (symB...
; # (atom Lst)
  %51 = and i64 %49, 15
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$25, label %$23
$25:
  %53 = phi i64 [%48, %$22] ; # X
  %54 = phi i64 [%49, %$22] ; # Lst
  %55 = phi i1 [%50, %$22] ; # F
; # (call $Put (char "\""))
  %56 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %56(i8 34)
; # (let (P (push 0 Nm) B (symByte P)) (loop (cond ((or (== B (char "...
; # (push 0 Nm)
  %57 = alloca i64, i64 2, align 16
  store i64 0, i64* %57
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %40, i64* %58
; # (symByte P)
  %59 = call i8 @symByte(i64* %57)
; # (loop (cond ((or (== B (char "\\")) (== B (char "\^")) (== B (cha...
  br label %$26
$26:
  %60 = phi i64 [%53, %$25], [%117, %$37] ; # X
  %61 = phi i64 [%54, %$25], [%118, %$37] ; # Lst
  %62 = phi i1 [%55, %$25], [%119, %$37] ; # F
  %63 = phi i8 [%59, %$25], [%120, %$37] ; # B
; # (cond ((or (== B (char "\\")) (== B (char "\^")) (== B (char "\""...
; # (or (== B (char "\\")) (== B (char "\^")) (== B (char "\"")))
; # (== B (char "\\"))
  %64 = icmp eq i8 %63, 92
  br i1 %64, label %$28, label %$29
$29:
  %65 = phi i64 [%60, %$26] ; # X
  %66 = phi i64 [%61, %$26] ; # Lst
  %67 = phi i1 [%62, %$26] ; # F
  %68 = phi i8 [%63, %$26] ; # B
; # (== B (char "\^"))
  %69 = icmp eq i8 %68, 94
  br i1 %69, label %$28, label %$30
$30:
  %70 = phi i64 [%65, %$29] ; # X
  %71 = phi i64 [%66, %$29] ; # Lst
  %72 = phi i1 [%67, %$29] ; # F
  %73 = phi i8 [%68, %$29] ; # B
; # (== B (char "\""))
  %74 = icmp eq i8 %73, 34
  br label %$28
$28:
  %75 = phi i64 [%60, %$26], [%65, %$29], [%70, %$30] ; # X
  %76 = phi i64 [%61, %$26], [%66, %$29], [%71, %$30] ; # Lst
  %77 = phi i1 [%62, %$26], [%67, %$29], [%72, %$30] ; # F
  %78 = phi i8 [%63, %$26], [%68, %$29], [%73, %$30] ; # B
  %79 = phi i1 [1, %$26], [1, %$29], [%74, %$30] ; # ->
  br i1 %79, label %$32, label %$31
$32:
  %80 = phi i64 [%75, %$28] ; # X
  %81 = phi i64 [%76, %$28] ; # Lst
  %82 = phi i1 [%77, %$28] ; # F
  %83 = phi i8 [%78, %$28] ; # B
; # (call $Put (char "\\"))
  %84 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %84(i8 92)
  br label %$27
$31:
  %85 = phi i64 [%75, %$28] ; # X
  %86 = phi i64 [%76, %$28] ; # Lst
  %87 = phi i1 [%77, %$28] ; # F
  %88 = phi i8 [%78, %$28] ; # B
; # (== B 127)
  %89 = icmp eq i8 %88, 127
  br i1 %89, label %$34, label %$33
$34:
  %90 = phi i64 [%85, %$31] ; # X
  %91 = phi i64 [%86, %$31] ; # Lst
  %92 = phi i1 [%87, %$31] ; # F
  %93 = phi i8 [%88, %$31] ; # B
; # (call $Put (char "\^"))
  %94 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %94(i8 94)
  br label %$27
$33:
  %95 = phi i64 [%85, %$31] ; # X
  %96 = phi i64 [%86, %$31] ; # Lst
  %97 = phi i1 [%87, %$31] ; # F
  %98 = phi i8 [%88, %$31] ; # B
; # (> 32 B)
  %99 = icmp ugt i8 32, %98
  br i1 %99, label %$36, label %$35
$36:
  %100 = phi i64 [%95, %$33] ; # X
  %101 = phi i64 [%96, %$33] ; # Lst
  %102 = phi i1 [%97, %$33] ; # F
  %103 = phi i8 [%98, %$33] ; # B
; # (call $Put (char "\^"))
  %104 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %104(i8 94)
; # (| B 64)
  %105 = or i8 %103, 64
  br label %$27
$35:
  %106 = phi i64 [%95, %$33] ; # X
  %107 = phi i64 [%96, %$33] ; # Lst
  %108 = phi i1 [%97, %$33] ; # F
  %109 = phi i8 [%98, %$33] ; # B
  br label %$27
$27:
  %110 = phi i64 [%80, %$32], [%90, %$34], [%100, %$36], [%106, %$35] ; # X
  %111 = phi i64 [%81, %$32], [%91, %$34], [%101, %$36], [%107, %$35] ; # Lst
  %112 = phi i1 [%82, %$32], [%92, %$34], [%102, %$36], [%108, %$35] ; # F
  %113 = phi i8 [%83, %$32], [63, %$34], [%105, %$36], [%109, %$35] ; # B
; # (call $Put B)
  %114 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %114(i8 %113)
; # (? (=0 (setq B (symByte P))))
; # (symByte P)
  %115 = call i8 @symByte(i64* %57)
; # (=0 (setq B (symByte P)))
  %116 = icmp eq i8 %115, 0
  br i1 %116, label %$38, label %$37
$37:
  %117 = phi i64 [%110, %$27] ; # X
  %118 = phi i64 [%111, %$27] ; # Lst
  %119 = phi i1 [%112, %$27] ; # F
  %120 = phi i8 [%115, %$27] ; # B
  br label %$26
$38:
  %121 = phi i64 [%110, %$27] ; # X
  %122 = phi i64 [%111, %$27] ; # Lst
  %123 = phi i1 [%112, %$27] ; # F
  %124 = phi i8 [%115, %$27] ; # B
  %125 = phi i64 [0, %$27] ; # ->
; # (call $Put (char "\""))
  %126 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %126(i8 34)
  br label %$24
$23:
  %127 = phi i64 [%48, %$22] ; # X
  %128 = phi i64 [%49, %$22] ; # Lst
  %129 = phi i1 [%50, %$22] ; # F
; # (let Nsp (car Lst) (when (isIntern Nm (cdar Nsp)) (? (== @ X) (wh...
; # (car Lst)
  %130 = inttoptr i64 %128 to i64*
  %131 = load i64, i64* %130
; # (when (isIntern Nm (cdar Nsp)) (? (== @ X) (when F (outName Nsp) ...
; # (cdar Nsp)
  %132 = inttoptr i64 %131 to i64*
  %133 = load i64, i64* %132
  %134 = inttoptr i64 %133 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  %136 = load i64, i64* %135
; # (isIntern Nm (cdar Nsp))
  %137 = call i64 @isIntern(i64 %40, i64 %136)
  %138 = icmp ne i64 %137, 0
  br i1 %138, label %$39, label %$40
$39:
  %139 = phi i64 [%127, %$23] ; # X
  %140 = phi i64 [%128, %$23] ; # Lst
  %141 = phi i1 [%129, %$23] ; # F
; # (? (== @ X) (when F (outName Nsp) (call $Put (char "~"))) (ifn (=...
; # (== @ X)
  %142 = icmp eq i64 %137, %139
  br i1 %142, label %$42, label %$41
$42:
  %143 = phi i64 [%139, %$39] ; # X
  %144 = phi i64 [%140, %$39] ; # Lst
  %145 = phi i1 [%141, %$39] ; # F
; # (when F (outName Nsp) (call $Put (char "~")))
  br i1 %145, label %$43, label %$44
$43:
  %146 = phi i64 [%143, %$42] ; # X
  %147 = phi i64 [%144, %$42] ; # Lst
  %148 = phi i1 [%145, %$42] ; # F
; # (outName Nsp)
  call void @outName(i64 %131)
; # (call $Put (char "~"))
  %149 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %149(i8 126)
  br label %$44
$44:
  %150 = phi i64 [%143, %$42], [%146, %$43] ; # X
  %151 = phi i64 [%144, %$42], [%147, %$43] ; # Lst
  %152 = phi i1 [%145, %$42], [%148, %$43] ; # F
; # (ifn (== Nm (hex "2E2")) (let (P (push 0 Nm) B (symByte P)) (when...
; # (== Nm (hex "2E2"))
  %153 = icmp eq i64 %40, 738
  br i1 %153, label %$46, label %$45
$45:
  %154 = phi i64 [%150, %$44] ; # X
  %155 = phi i64 [%151, %$44] ; # Lst
  %156 = phi i1 [%152, %$44] ; # F
; # (let (P (push 0 Nm) B (symByte P)) (when (== B (char "#")) (call ...
; # (push 0 Nm)
  %157 = alloca i64, i64 2, align 16
  store i64 0, i64* %157
  %158 = getelementptr i64, i64* %157, i32 1
  store i64 %40, i64* %158
; # (symByte P)
  %159 = call i8 @symByte(i64* %157)
; # (when (== B (char "#")) (call $Put (char "\\")))
; # (== B (char "#"))
  %160 = icmp eq i8 %159, 35
  br i1 %160, label %$48, label %$49
$48:
  %161 = phi i64 [%154, %$45] ; # X
  %162 = phi i64 [%155, %$45] ; # Lst
  %163 = phi i1 [%156, %$45] ; # F
  %164 = phi i8 [%159, %$45] ; # B
; # (call $Put (char "\\"))
  %165 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %165(i8 92)
  br label %$49
$49:
  %166 = phi i64 [%154, %$45], [%161, %$48] ; # X
  %167 = phi i64 [%155, %$45], [%162, %$48] ; # Lst
  %168 = phi i1 [%156, %$45], [%163, %$48] ; # F
  %169 = phi i8 [%159, %$45], [%164, %$48] ; # B
; # (loop (when (or (== B (char "\\")) (strchr $Delim (i32 B))) (call...
  br label %$50
$50:
  %170 = phi i64 [%166, %$49], [%199, %$55] ; # X
  %171 = phi i64 [%167, %$49], [%200, %$55] ; # Lst
  %172 = phi i1 [%168, %$49], [%201, %$55] ; # F
  %173 = phi i8 [%169, %$49], [%202, %$55] ; # B
; # (when (or (== B (char "\\")) (strchr $Delim (i32 B))) (call $Put ...
; # (or (== B (char "\\")) (strchr $Delim (i32 B)))
; # (== B (char "\\"))
  %174 = icmp eq i8 %173, 92
  br i1 %174, label %$51, label %$52
$52:
  %175 = phi i64 [%170, %$50] ; # X
  %176 = phi i64 [%171, %$50] ; # Lst
  %177 = phi i1 [%172, %$50] ; # F
  %178 = phi i8 [%173, %$50] ; # B
; # (i32 B)
  %179 = zext i8 %178 to i32
; # (strchr $Delim (i32 B))
  %180 = call i8* @strchr(i8* bitcast ([16 x i8]* @$Delim to i8*), i32 %179)
  %181 = icmp ne i8* %180, null
  br label %$51
$51:
  %182 = phi i64 [%170, %$50], [%175, %$52] ; # X
  %183 = phi i64 [%171, %$50], [%176, %$52] ; # Lst
  %184 = phi i1 [%172, %$50], [%177, %$52] ; # F
  %185 = phi i8 [%173, %$50], [%178, %$52] ; # B
  %186 = phi i1 [1, %$50], [%181, %$52] ; # ->
  br i1 %186, label %$53, label %$54
$53:
  %187 = phi i64 [%182, %$51] ; # X
  %188 = phi i64 [%183, %$51] ; # Lst
  %189 = phi i1 [%184, %$51] ; # F
  %190 = phi i8 [%185, %$51] ; # B
; # (call $Put (char "\\"))
  %191 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %191(i8 92)
  br label %$54
$54:
  %192 = phi i64 [%182, %$51], [%187, %$53] ; # X
  %193 = phi i64 [%183, %$51], [%188, %$53] ; # Lst
  %194 = phi i1 [%184, %$51], [%189, %$53] ; # F
  %195 = phi i8 [%185, %$51], [%190, %$53] ; # B
; # (call $Put B)
  %196 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %196(i8 %195)
; # (? (=0 (setq B (symByte P))))
; # (symByte P)
  %197 = call i8 @symByte(i64* %157)
; # (=0 (setq B (symByte P)))
  %198 = icmp eq i8 %197, 0
  br i1 %198, label %$56, label %$55
$55:
  %199 = phi i64 [%192, %$54] ; # X
  %200 = phi i64 [%193, %$54] ; # Lst
  %201 = phi i1 [%194, %$54] ; # F
  %202 = phi i8 [%197, %$54] ; # B
  br label %$50
$56:
  %203 = phi i64 [%192, %$54] ; # X
  %204 = phi i64 [%193, %$54] ; # Lst
  %205 = phi i1 [%194, %$54] ; # F
  %206 = phi i8 [%197, %$54] ; # B
  %207 = phi i64 [0, %$54] ; # ->
  br label %$47
$46:
  %208 = phi i64 [%150, %$44] ; # X
  %209 = phi i64 [%151, %$44] ; # Lst
  %210 = phi i1 [%152, %$44] ; # F
; # (call $Put (char "\\"))
  %211 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %211(i8 92)
; # (call $Put (char "."))
  %212 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %212(i8 46)
  br label %$47
$47:
  %213 = phi i64 [%203, %$56], [%208, %$46] ; # X
  %214 = phi i64 [%204, %$56], [%209, %$46] ; # Lst
  %215 = phi i1 [%205, %$56], [%210, %$46] ; # F
  br label %$24
$41:
  %216 = phi i64 [%139, %$39] ; # X
  %217 = phi i64 [%140, %$39] ; # Lst
  %218 = phi i1 [%141, %$39] ; # F
  br label %$40
$40:
  %219 = phi i64 [%127, %$23], [%216, %$41] ; # X
  %220 = phi i64 [%128, %$23], [%217, %$41] ; # Lst
  %221 = phi i1 [%129, %$23], [1, %$41] ; # F
; # (shift Lst)
  %222 = inttoptr i64 %220 to i64*
  %223 = getelementptr i64, i64* %222, i32 1
  %224 = load i64, i64* %223
  br label %$22
$24:
  %225 = phi i64 [%121, %$38], [%213, %$47] ; # X
  %226 = phi i64 [%122, %$38], [%214, %$47] ; # Lst
  %227 = phi i1 [%123, %$38], [%215, %$47] ; # F
  br label %$11
$11:
  %228 = phi i64 [%20, %$16], [%42, %$21], [%225, %$24] ; # X
  br label %$4
$9:
  %229 = phi i64 [%11, %$7] ; # X
; # (and (== (car X) $Quote) (<> X (cdr X)))
; # (car X)
  %230 = inttoptr i64 %229 to i64*
  %231 = load i64, i64* %230
; # (== (car X) $Quote)
  %232 = icmp eq i64 %231, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 168) to i64)
  br i1 %232, label %$58, label %$57
$58:
  %233 = phi i64 [%229, %$9] ; # X
; # (cdr X)
  %234 = inttoptr i64 %233 to i64*
  %235 = getelementptr i64, i64* %234, i32 1
  %236 = load i64, i64* %235
; # (<> X (cdr X))
  %237 = icmp ne i64 %233, %236
  br label %$57
$57:
  %238 = phi i64 [%229, %$9], [%233, %$58] ; # X
  %239 = phi i1 [0, %$9], [%237, %$58] ; # ->
  br i1 %239, label %$60, label %$59
$60:
  %240 = phi i64 [%238, %$57] ; # X
; # (call $Put (char "'"))
  %241 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %241(i8 39)
; # (cdr X)
  %242 = inttoptr i64 %240 to i64*
  %243 = getelementptr i64, i64* %242, i32 1
  %244 = load i64, i64* %243
; # (print (cdr X))
  call void @print(i64 %244)
  br label %$4
$59:
  %245 = phi i64 [%238, %$57] ; # X
; # (stkChk 0)
  %246 = load i8*, i8** @$StkLimit
  %247 = call i8* @llvm.stacksave()
  %248 = icmp ugt i8* %246, %247
  br i1 %248, label %$61, label %$62
$61:
  call void @stkErr(i64 0)
  unreachable
$62:
; # (call $Put (char "("))
  %249 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %249(i8 40)
; # (let P (circ X) (ifn P (loop (print (car X)) (? (== $Nil (shift X...
; # (circ X)
  %250 = call i64 @circ(i64 %245)
; # (ifn P (loop (print (car X)) (? (== $Nil (shift X))) (? (atom X) ...
  %251 = icmp ne i64 %250, 0
  br i1 %251, label %$64, label %$63
$63:
  %252 = phi i64 [%245, %$62] ; # X
; # (loop (print (car X)) (? (== $Nil (shift X))) (? (atom X) (outStr...
  br label %$66
$66:
  %253 = phi i64 [%252, %$63], [%264, %$69] ; # X
; # (car X)
  %254 = inttoptr i64 %253 to i64*
  %255 = load i64, i64* %254
; # (print (car X))
  call void @print(i64 %255)
; # (? (== $Nil (shift X)))
; # (shift X)
  %256 = inttoptr i64 %253 to i64*
  %257 = getelementptr i64, i64* %256, i32 1
  %258 = load i64, i64* %257
; # (== $Nil (shift X))
  %259 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %258
  br i1 %259, label %$68, label %$67
$67:
  %260 = phi i64 [%258, %$66] ; # X
; # (? (atom X) (outString ($ " . ")) (print X))
; # (atom X)
  %261 = and i64 %260, 15
  %262 = icmp ne i64 %261, 0
  br i1 %262, label %$70, label %$69
$70:
  %263 = phi i64 [%260, %$67] ; # X
; # (outString ($ " . "))
  call void @outString(i8* bitcast ([4 x i8]* @$41 to i8*))
; # (print X)
  call void @print(i64 %263)
  br label %$68
$69:
  %264 = phi i64 [%260, %$67] ; # X
; # (space)
  call void @space()
  br label %$66
$68:
  %265 = phi i64 [%258, %$66], [%263, %$70] ; # X
  br label %$65
$64:
  %266 = phi i64 [%245, %$62] ; # X
; # (let Flg (== P X) (loop (print (car X)) (space) (? (== P (shift X...
; # (== P X)
  %267 = icmp eq i64 %250, %266
; # (loop (print (car X)) (space) (? (== P (shift X))))
  br label %$71
$71:
  %268 = phi i64 [%266, %$64], [%275, %$72] ; # X
; # (car X)
  %269 = inttoptr i64 %268 to i64*
  %270 = load i64, i64* %269
; # (print (car X))
  call void @print(i64 %270)
; # (space)
  call void @space()
; # (? (== P (shift X)))
; # (shift X)
  %271 = inttoptr i64 %268 to i64*
  %272 = getelementptr i64, i64* %271, i32 1
  %273 = load i64, i64* %272
; # (== P (shift X))
  %274 = icmp eq i64 %250, %273
  br i1 %274, label %$73, label %$72
$72:
  %275 = phi i64 [%273, %$71] ; # X
  br label %$71
$73:
  %276 = phi i64 [%273, %$71] ; # X
  %277 = phi i64 [0, %$71] ; # ->
; # (call $Put (char "."))
  %278 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %278(i8 46)
; # (unless Flg (space) (call $Put (char "(")) (loop (print (car X)) ...
  br i1 %267, label %$75, label %$74
$74:
  %279 = phi i64 [%276, %$73] ; # X
; # (space)
  call void @space()
; # (call $Put (char "("))
  %280 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %280(i8 40)
; # (loop (print (car X)) (space) (? (== P (shift X))))
  br label %$76
$76:
  %281 = phi i64 [%279, %$74], [%288, %$77] ; # X
; # (car X)
  %282 = inttoptr i64 %281 to i64*
  %283 = load i64, i64* %282
; # (print (car X))
  call void @print(i64 %283)
; # (space)
  call void @space()
; # (? (== P (shift X)))
; # (shift X)
  %284 = inttoptr i64 %281 to i64*
  %285 = getelementptr i64, i64* %284, i32 1
  %286 = load i64, i64* %285
; # (== P (shift X))
  %287 = icmp eq i64 %250, %286
  br i1 %287, label %$78, label %$77
$77:
  %288 = phi i64 [%286, %$76] ; # X
  br label %$76
$78:
  %289 = phi i64 [%286, %$76] ; # X
  %290 = phi i64 [0, %$76] ; # ->
; # (call $Put (char "."))
  %291 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %291(i8 46)
; # (call $Put (char ")"))
  %292 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %292(i8 41)
  br label %$75
$75:
  %293 = phi i64 [%276, %$73], [%289, %$78] ; # X
  br label %$65
$65:
  %294 = phi i64 [%265, %$68], [%293, %$75] ; # X
; # (call $Put (char ")"))
  %295 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %295(i8 41)
  br label %$4
$4:
  %296 = phi i64 [%5, %$6], [%9, %$8], [%228, %$11], [%240, %$60], [%294, %$65] ; # X
  ret void
}

define void @prin(i64) {
$1:
; # (sigChk 0)
  %1 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  call void @sighandler(i64 0)
  br label %$3
$3:
; # (unless (nil? X) (cond ((cnt? X) (outNum X)) ((big? X) (fmtNum X ...
; # (nil? X)
  %3 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$5, label %$4
$4:
  %4 = phi i64 [%0, %$3] ; # X
; # (cond ((cnt? X) (outNum X)) ((big? X) (fmtNum X -1 0 0 null)) ((s...
; # (cnt? X)
  %5 = and i64 %4, 2
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$8, label %$7
$8:
  %7 = phi i64 [%4, %$4] ; # X
; # (outNum X)
  call void @outNum(i64 %7)
  br label %$6
$7:
  %8 = phi i64 [%4, %$4] ; # X
; # (big? X)
  %9 = and i64 %8, 4
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$10, label %$9
$10:
  %11 = phi i64 [%8, %$7] ; # X
; # (fmtNum X -1 0 0 null)
  %12 = call i64 @fmtNum(i64 %11, i64 -1, i8 0, i8 0, i64* null)
  br label %$6
$9:
  %13 = phi i64 [%8, %$7] ; # X
; # (sym? X)
  %14 = and i64 %13, 8
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$12, label %$11
$12:
  %16 = phi i64 [%13, %$9] ; # X
; # (ifn (sym? (val (tail X))) (prName (name @)) (call $Put (char "{"...
; # (tail X)
  %17 = add i64 %16, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$14, label %$13
$13:
  %22 = phi i64 [%16, %$12] ; # X
; # (name @)
  br label %$16
$16:
  %23 = phi i64 [%19, %$13], [%29, %$17] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$18, label %$17
$17:
  %26 = phi i64 [%23, %$16] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$16
$18:
  %30 = phi i64 [%23, %$16] ; # Tail
; # (prName (name @))
  call void @prName(i64 %30)
  br label %$15
$14:
  %31 = phi i64 [%16, %$12] ; # X
; # (call $Put (char "{"))
  %32 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %32(i8 123)
; # (& @ -9)
  %33 = and i64 %19, -9
; # (name (& @ -9))
  br label %$19
$19:
  %34 = phi i64 [%33, %$14], [%40, %$20] ; # Tail
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$21, label %$20
$20:
  %37 = phi i64 [%34, %$19] ; # Tail
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  br label %$19
$21:
  %41 = phi i64 [%34, %$19] ; # Tail
; # (prExt (name (& @ -9)))
  call void @prExt(i64 %41)
; # (call $Put (char "}"))
  %42 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %42(i8 125)
  br label %$15
$15:
  %43 = phi i64 [%22, %$18], [%31, %$21] ; # X
  br label %$6
$11:
  %44 = phi i64 [%13, %$9] ; # X
; # (stkChk 0)
  %45 = load i8*, i8** @$StkLimit
  %46 = call i8* @llvm.stacksave()
  %47 = icmp ugt i8* %45, %46
  br i1 %47, label %$22, label %$23
$22:
  call void @stkErr(i64 0)
  unreachable
$23:
; # (loop (prin (car X)) (? (== $Nil (shift X))) (? (atom X) (prin X)...
  br label %$24
$24:
  %48 = phi i64 [%44, %$23], [%59, %$27] ; # X
; # (car X)
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (prin (car X))
  call void @prin(i64 %50)
; # (? (== $Nil (shift X)))
; # (shift X)
  %51 = inttoptr i64 %48 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
; # (== $Nil (shift X))
  %54 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %53
  br i1 %54, label %$26, label %$25
$25:
  %55 = phi i64 [%53, %$24] ; # X
; # (? (atom X) (prin X))
; # (atom X)
  %56 = and i64 %55, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$28, label %$27
$28:
  %58 = phi i64 [%55, %$25] ; # X
; # (prin X)
  call void @prin(i64 %58)
  br label %$26
$27:
  %59 = phi i64 [%55, %$25] ; # X
  br label %$24
$26:
  %60 = phi i64 [%53, %$24], [%58, %$28] ; # X
  br label %$6
$6:
  %61 = phi i64 [%7, %$8], [%11, %$10], [%43, %$15], [%60, %$26] ; # X
  br label %$5
$5:
  %62 = phi i64 [%0, %$3], [%61, %$6] ; # X
  ret void
}

define i64 @_prin(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (++ X)) (prin Y) (? (atom X) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (++ X)) (prin Y) (? (atom X) Y)))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%20, %$8] ; # X
; # (let Y (eval (++ X)) (prin Y) (? (atom X) Y))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (prin Y)
  call void @prin(i64 %16)
; # (? (atom X) Y)
; # (atom X)
  %17 = and i64 %8, 15
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$8
$10:
  %19 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %20 = phi i64 [%8, %$3] ; # X
  br label %$2
$9:
  %21 = phi i64 [%19, %$10] ; # X
  %22 = phi i64 [%16, %$10] ; # ->
  ret i64 %22
}

define i64 @_prinl(i64) {
$1:
; # (prog1 (_prin Exe) (newline))
; # (_prin Exe)
  %1 = call i64 @_prin(i64 %0)
; # (newline)
  call void @newline()
  ret i64 %1
}

define i64 @_space(i64) {
$1:
; # (let X (eval (cadr Exe)) (ifn (nil? X) (let N (xCnt Exe X) (while...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (ifn (nil? X) (let N (xCnt Exe X) (while (ge0 (dec 'N)) (space)) ...
; # (nil? X)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$8, label %$7
$7:
; # (let N (xCnt Exe X) (while (ge0 (dec 'N)) (space)) X)
; # (xCnt Exe X)
  %15 = call i64 @xCnt(i64 %0, i64 %13)
; # (while (ge0 (dec 'N)) (space))
  br label %$10
$10:
  %16 = phi i64 [%15, %$7], [%19, %$11] ; # N
; # (dec 'N)
  %17 = sub i64 %16, 1
; # (ge0 (dec 'N))
  %18 = icmp sge i64 %17, 0
  br i1 %18, label %$11, label %$12
$11:
  %19 = phi i64 [%17, %$10] ; # N
; # (space)
  call void @space()
  br label %$10
$12:
  %20 = phi i64 [%17, %$10] ; # N
  br label %$9
$8:
; # (space)
  call void @space()
  br label %$9
$9:
  %21 = phi i64 [%13, %$12], [18, %$8] ; # ->
  ret i64 %21
}

define i64 @_print(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (++ X)) (print Y) (? (atom X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (++ X)) (print Y) (? (atom X) Y) (space)))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%20, %$8] ; # X
; # (let Y (eval (++ X)) (print Y) (? (atom X) Y) (space))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (print Y)
  call void @print(i64 %16)
; # (? (atom X) Y)
; # (atom X)
  %17 = and i64 %8, 15
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$10, label %$8
$10:
  %19 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %20 = phi i64 [%8, %$3] ; # X
; # (space)
  call void @space()
  br label %$2
$9:
  %21 = phi i64 [%19, %$10] ; # X
  %22 = phi i64 [%16, %$10] ; # ->
  ret i64 %22
}

define i64 @_printsp(i64) {
$1:
; # (prog1 (_print Exe) (space))
; # (_print Exe)
  %1 = call i64 @_print(i64 %0)
; # (space)
  call void @space()
  ret i64 %1
}

define i64 @_println(i64) {
$1:
; # (prog1 (_print Exe) (newline))
; # (_print Exe)
  %1 = call i64 @_print(i64 %0)
; # (newline)
  call void @newline()
  ret i64 %1
}

define i64 @_flush(i64) {
$1:
; # (if (flush (val $OutFile)) $T $Nil)
; # (val $OutFile)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (flush (val $OutFile))
  %2 = call i1 @flush(i8* %1)
  br i1 %2, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %3 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %3
}

define i64 @_rewind(i64) {
$1:
; # (let Out: (outFile (val $OutFile)) (if (and (Out:) (let Fd (Out: ...
; # (val $OutFile)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (if (and (Out:) (let Fd (Out: fd) (Out: ix 0) (and (seek0 Fd) (tr...
; # (and (Out:) (let Fd (Out: fd) (Out: ix 0) (and (seek0 Fd) (trunca...
; # (Out:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (let Fd (Out: fd) (Out: ix 0) (and (seek0 Fd) (truncate0 Fd)))
; # (Out: fd)
  %3 = getelementptr i8, i8* %1, i32 8
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (Out: ix 0)
  %6 = bitcast i8* %1 to i64*
  store i64 0, i64* %6
; # (and (seek0 Fd) (truncate0 Fd))
; # (seek0 Fd)
  %7 = call i1 @seek0(i32 %5)
  br i1 %7, label %$5, label %$4
$5:
; # (truncate0 Fd)
  %8 = call i1 @truncate0(i32 %5)
  br label %$4
$4:
  %9 = phi i1 [0, %$3], [%8, %$5] ; # ->
  br label %$2
$2:
  %10 = phi i1 [0, %$1], [%9, %$4] ; # ->
  br i1 %10, label %$6, label %$7
$6:
  br label %$8
$7:
  br label %$8
$8:
  %11 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$6], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7] ; # ->
  ret i64 %11
}

define i64 @_ext(i64) {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) Old (val $ExtN)) (set $ExtN (i3...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (val $ExtN)
  %5 = load i32, i32* @$ExtN
; # (set $ExtN (i32 N))
; # (i32 N)
  %6 = trunc i64 %4 to i32
  store i32 %6, i32* @$ExtN
; # (prog1 (run (cdr X)) (set $ExtN Old))
; # (cdr X)
  %7 = inttoptr i64 %3 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
; # (run (cdr X))
  br label %$2
$2:
  %10 = phi i64 [%9, %$1], [%32, %$11] ; # Prg
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
  %13 = getelementptr i64, i64* %11, i32 1
  %14 = load i64, i64* %13
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$5, label %$3
$5:
  %17 = phi i64 [%14, %$2] ; # Prg
  %18 = and i64 %12, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$8:
  br label %$6
$7:
  %20 = and i64 %12, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$9
$10:
  %22 = inttoptr i64 %12 to i64*
  %23 = load i64, i64* %22
  br label %$6
$9:
  %24 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %25 = phi i64 [%12, %$8], [%23, %$10], [%24, %$9] ; # ->
  br label %$4
$3:
  %26 = phi i64 [%14, %$2] ; # Prg
  %27 = and i64 %12, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$12, label %$11
$12:
  %29 = phi i64 [%26, %$3] ; # Prg
  %30 = call i64 @evList(i64 %12)
  %31 = icmp ne i64 %30, 0
  br label %$11
$11:
  %32 = phi i64 [%26, %$3], [%29, %$12] ; # Prg
  %33 = phi i1 [0, %$3], [%31, %$12] ; # ->
  br label %$2
$4:
  %34 = phi i64 [%17, %$6] ; # Prg
  %35 = phi i64 [%25, %$6] ; # ->
; # (set $ExtN Old)
  store i32 %5, i32* @$ExtN
  ret i64 %35
}

define i32 @getPlio() {
$1:
; # (let P (val $Ptr) (set $Ptr (inc P)) (i32 (val P)))
; # (val $Ptr)
  %0 = load i8*, i8** @$Ptr
; # (set $Ptr (inc P))
; # (inc P)
  %1 = getelementptr i8, i8* %0, i32 1
  store i8* %1, i8** @$Ptr
; # (val P)
  %2 = load i8, i8* %0
; # (i32 (val P))
  %3 = zext i8 %2 to i32
  ret i32 %3
}

define void @putPlio(i8) {
$1:
; # (let P (val $Ptr) (set P B) (when (== (set $Ptr (inc P)) (val $En...
; # (val $Ptr)
  %1 = load i8*, i8** @$Ptr
; # (set P B)
  store i8 %0, i8* %1
; # (when (== (set $Ptr (inc P)) (val $End)) (err 0 0 ($ "Size overfl...
; # (set $Ptr (inc P))
; # (inc P)
  %2 = getelementptr i8, i8* %1, i32 1
  store i8* %2, i8** @$Ptr
; # (val $End)
  %3 = load i8*, i8** @$End
; # (== (set $Ptr (inc P)) (val $End))
  %4 = icmp eq i8* %2, %3
  br i1 %4, label %$2, label %$3
$2:
; # (err 0 0 ($ "Size overflow") null)
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$42 to i8*), i8* null)
  unreachable
$3:
  ret void
}

define i64 @_plio(i64) {
$1:
; # (let (X (cdr Exe) P (i8* (if (cnt? (needNum Exe (eval (++ X)))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cnt? (needNum Exe (eval (++ X))))
  %18 = and i64 %15, 2
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  %20 = phi i64 [%7, %$8] ; # X
; # (int @)
  %21 = lshr i64 %15, 4
  br label %$11
$10:
  %22 = phi i64 [%7, %$8] ; # X
; # (dig @)
  %23 = add i64 %15, -4
; # (val (dig @))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  br label %$11
$11:
  %26 = phi i64 [%20, %$9], [%22, %$10] ; # X
  %27 = phi i64 [%21, %$9], [%25, %$10] ; # ->
; # (i8* (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @))...
  %28 = inttoptr i64 %27 to i8*
; # (set $Extn (val $ExtN) $Ptr P)
; # (val $ExtN)
  %29 = load i32, i32* @$ExtN
  store i32 %29, i32* @$Extn
  store i8* %28, i8** @$Ptr
; # (if (pair X) (let (N (evCnt Exe X) Y (eval (car (shift X)))) (set...
; # (pair X)
  %30 = and i64 %26, 15
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$12, label %$13
$12:
  %32 = phi i64 [%26, %$11] ; # X
; # (let (N (evCnt Exe X) Y (eval (car (shift X)))) (set $PutBin (fun...
; # (evCnt Exe X)
  %33 = call i64 @evCnt(i64 %0, i64 %32)
; # (shift X)
  %34 = inttoptr i64 %32 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  %36 = load i64, i64* %35
; # (car (shift X))
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (eval (car (shift X)))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$17, label %$16
$17:
  br label %$15
$16:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$19, label %$18
$19:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$15
$18:
  %45 = call i64 @evList(i64 %38)
  br label %$15
$15:
  %46 = phi i64 [%38, %$17], [%44, %$19], [%45, %$18] ; # ->
; # (set $PutBin (fun (void i8) putPlio) $End (ofs P N))
; # (fun (void i8) putPlio)
  store void(i8)* @putPlio, void(i8)** @$PutBin
; # (ofs P N)
  %47 = getelementptr i8, i8* %28, i64 %33
  store i8* %47, i8** @$End
; # (binPrint Y)
  call void @binPrint(i64 %46)
; # (val $Ptr)
  %48 = load i8*, i8** @$Ptr
; # (- (val $Ptr) P)
  %49 = ptrtoint i8* %48 to i64
  %50 = ptrtoint i8* %28 to i64
  %51 = sub i64 %49, %50
; # (cnt (- (val $Ptr) P))
  %52 = shl i64 %51, 4
  %53 = or i64 %52, 2
  br label %$14
$13:
  %54 = phi i64 [%26, %$11] ; # X
; # (set $GetBin (fun (i32) getPlio))
; # (fun (i32) getPlio)
  store i32()* @getPlio, i32()** @$GetBin
; # (if (binRead) @ $Nil)
; # (binRead)
  %55 = call i64 @binRead()
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$20, label %$21
$20:
  %57 = phi i64 [%54, %$13] ; # X
  br label %$22
$21:
  %58 = phi i64 [%54, %$13] ; # X
  br label %$22
$22:
  %59 = phi i64 [%57, %$20], [%58, %$21] ; # X
  %60 = phi i64 [%55, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$21] ; # ->
  br label %$14
$14:
  %61 = phi i64 [%36, %$15], [%59, %$22] ; # X
  %62 = phi i64 [%53, %$15], [%60, %$22] ; # ->
  ret i64 %62
}

define i64 @_rd(i64) {
$1:
; # (let X (save (eval (cadr Exe))) (cond ((=0 (val $InFile)) $Nil) (...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (cadr Exe)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (cond ((=0 (val $InFile)) $Nil) ((num? X) (let (P (push 3 NIL ZER...
; # (val $InFile)
  %22 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (=0 (val $InFile))
  %23 = icmp eq i8* %22, null
  br i1 %23, label %$9, label %$8
$9:
  br label %$7
$8:
; # (num? X)
  %24 = and i64 %13, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$11, label %$10
$11:
; # (let (P (push 3 NIL ZERO NIL) Q (link (ofs P 2)) Cnt (int X)) (co...
; # (push 3 NIL ZERO NIL)
  %26 = alloca i64, i64 4, align 16
  store i64 3, i64* %26
  %27 = getelementptr i64, i64* %26, i32 2
  store i64 2, i64* %27
; # (ofs P 2)
  %28 = getelementptr i64, i64* %26, i32 2
; # (link (ofs P 2))
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %31 = load i64, i64* %30
  %32 = inttoptr i64 %29 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %31, i64* %33
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %34
; # (int X)
  %35 = lshr i64 %13, 4
; # (cond ((=0 Cnt) $Nil) ((sign? X) (loop (when (lt0 (getBinary)) (:...
; # (=0 Cnt)
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$14, label %$13
$14:
  %37 = phi i64 [%35, %$11] ; # Cnt
  br label %$12
$13:
  %38 = phi i64 [%35, %$11] ; # Cnt
; # (sign? X)
  %39 = and i64 %13, 8
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$16, label %$15
$16:
  %41 = phi i64 [%38, %$13] ; # Cnt
; # (loop (when (lt0 (getBinary)) (: 1 (ret $Nil))) (byteNum (i8 @) P...
  br label %$17
$17:
  %42 = phi i64 [%41, %$16], [%55, %$20] ; # Cnt
; # (when (lt0 (getBinary)) (: 1 (ret $Nil)))
; # (getBinary)
  %43 = call i32 @getBinary()
; # (lt0 (getBinary))
  %44 = icmp slt i32 %43, 0
  br i1 %44, label %$18, label %$19
$18:
  %45 = phi i64 [%42, %$17] ; # Cnt
; # (: 1 (ret $Nil))
  br label %$-1
$-1:
  %46 = phi i64 [%45, %$18], [%72, %$26] ; # Cnt
; # (ret $Nil)
; # (drop *Safe)
  %47 = inttoptr i64 %15 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %50
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$19:
  %51 = phi i64 [%42, %$17] ; # Cnt
; # (i8 @)
  %52 = trunc i32 %43 to i8
; # (byteNum (i8 @) P)
  call void @byteNum(i8 %52, i64* %26)
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %53 = sub i64 %51, 1
; # (=0 (dec 'Cnt))
  %54 = icmp eq i64 %53, 0
  br i1 %54, label %$21, label %$20
$20:
  %55 = phi i64 [%53, %$19] ; # Cnt
  br label %$17
$21:
  %56 = phi i64 [%53, %$19] ; # Cnt
  %57 = phi i64 [0, %$19] ; # ->
; # (if (cnt? (val Q)) (twice @) (zapZero @))
; # (val Q)
  %58 = inttoptr i64 %29 to i64*
  %59 = load i64, i64* %58
; # (cnt? (val Q))
  %60 = and i64 %59, 2
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$22, label %$23
$22:
  %62 = phi i64 [%56, %$21] ; # Cnt
; # (twice @)
  %63 = call i64 @twice(i64 %59)
  br label %$24
$23:
  %64 = phi i64 [%56, %$21] ; # Cnt
; # (zapZero @)
  %65 = call i64 @zapZero(i64 %59)
  br label %$24
$24:
  %66 = phi i64 [%62, %$22], [%64, %$23] ; # Cnt
  %67 = phi i64 [%63, %$22], [%65, %$23] ; # ->
  br label %$12
$15:
  %68 = phi i64 [%38, %$13] ; # Cnt
; # (loop (when (lt0 (getBinary)) (goto 1)) (set Q (addu (cnt (i64 @)...
  br label %$25
$25:
  %69 = phi i64 [%68, %$15], [%85, %$28] ; # Cnt
; # (when (lt0 (getBinary)) (goto 1))
; # (getBinary)
  %70 = call i32 @getBinary()
; # (lt0 (getBinary))
  %71 = icmp slt i32 %70, 0
  br i1 %71, label %$26, label %$27
$26:
  %72 = phi i64 [%69, %$25] ; # Cnt
; # (goto 1)
  br label %$-1
$27:
  %73 = phi i64 [%69, %$25] ; # Cnt
; # (set Q (addu (cnt (i64 @)) (set Q (mulu (val Q) (hex "1002")))))
; # (i64 @)
  %74 = sext i32 %70 to i64
; # (cnt (i64 @))
  %75 = shl i64 %74, 4
  %76 = or i64 %75, 2
; # (set Q (mulu (val Q) (hex "1002")))
; # (val Q)
  %77 = inttoptr i64 %29 to i64*
  %78 = load i64, i64* %77
; # (mulu (val Q) (hex "1002"))
  %79 = call i64 @mulu(i64 %78, i64 4098)
  %80 = inttoptr i64 %29 to i64*
  store i64 %79, i64* %80
; # (addu (cnt (i64 @)) (set Q (mulu (val Q) (hex "1002"))))
  %81 = call i64 @addu(i64 %76, i64 %79)
  %82 = inttoptr i64 %29 to i64*
  store i64 %81, i64* %82
; # (? (=0 (dec 'Cnt)))
; # (dec 'Cnt)
  %83 = sub i64 %73, 1
; # (=0 (dec 'Cnt))
  %84 = icmp eq i64 %83, 0
  br i1 %84, label %$29, label %$28
$28:
  %85 = phi i64 [%83, %$27] ; # Cnt
  br label %$25
$29:
  %86 = phi i64 [%83, %$27] ; # Cnt
  %87 = phi i64 [0, %$27] ; # ->
; # (if (cnt? (val Q)) @ (zapZero @))
; # (val Q)
  %88 = inttoptr i64 %29 to i64*
  %89 = load i64, i64* %88
; # (cnt? (val Q))
  %90 = and i64 %89, 2
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$30, label %$31
$30:
  %92 = phi i64 [%86, %$29] ; # Cnt
  br label %$32
$31:
  %93 = phi i64 [%86, %$29] ; # Cnt
; # (zapZero @)
  %94 = call i64 @zapZero(i64 %89)
  br label %$32
$32:
  %95 = phi i64 [%92, %$30], [%93, %$31] ; # Cnt
  %96 = phi i64 [%89, %$30], [%94, %$31] ; # ->
  br label %$12
$12:
  %97 = phi i64 [%37, %$14], [%66, %$24], [%95, %$32] ; # Cnt
  %98 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$14], [%67, %$24], [%96, %$32] ; # ->
  br label %$7
$10:
; # (set $GetBin (fun (i32) getBinary) $Extn (val $ExtN))
; # (fun (i32) getBinary)
  store i32()* @getBinary, i32()** @$GetBin
; # (val $ExtN)
  %99 = load i32, i32* @$ExtN
  store i32 %99, i32* @$Extn
; # (if (binRead) @ X)
; # (binRead)
  %100 = call i64 @binRead()
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$33, label %$34
$33:
  br label %$35
$34:
  br label %$35
$35:
  %102 = phi i64 [%100, %$33], [%13, %$34] ; # ->
  br label %$7
$7:
  %103 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%98, %$12], [%102, %$35] ; # ->
; # (drop *Safe)
  %104 = inttoptr i64 %15 to i64*
  %105 = getelementptr i64, i64* %104, i32 1
  %106 = load i64, i64* %105
  %107 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %106, i64* %107
  ret i64 %103
}

define i64 @_pr(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (++ X)) (set $Extn (val $ExtN...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (++ X)) (set $Extn (val $ExtN)) (pr Y) (? (ato...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%21, %$8] ; # X
; # (let Y (eval (++ X)) (set $Extn (val $ExtN)) (pr Y) (? (atom X) Y...
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (set $Extn (val $ExtN))
; # (val $ExtN)
  %17 = load i32, i32* @$ExtN
  store i32 %17, i32* @$Extn
; # (pr Y)
  call void @pr(i64 %16)
; # (? (atom X) Y)
; # (atom X)
  %18 = and i64 %8, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$10, label %$8
$10:
  %20 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %21 = phi i64 [%8, %$3] ; # X
  br label %$2
$9:
  %22 = phi i64 [%20, %$10] ; # X
  %23 = phi i64 [%16, %$10] ; # ->
  ret i64 %23
}

define i64 @_wr(i64) {
$1:
; # (let X (cdr Exe) (loop (let N (eval (++ X)) (_putStdout (i8 (int ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let N (eval (++ X)) (_putStdout (i8 (int N))) (? (atom X) ...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%22, %$8] ; # X
; # (let N (eval (++ X)) (_putStdout (i8 (int N))) (? (atom X) N))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (int N)
  %17 = lshr i64 %16, 4
; # (i8 (int N))
  %18 = trunc i64 %17 to i8
; # (_putStdout (i8 (int N)))
  call void @_putStdout(i8 %18)
; # (? (atom X) N)
; # (atom X)
  %19 = and i64 %8, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$8
$10:
  %21 = phi i64 [%8, %$3] ; # X
  br label %$9
$8:
  %22 = phi i64 [%8, %$3] ; # X
  br label %$2
$9:
  %23 = phi i64 [%21, %$10] ; # X
  %24 = phi i64 [%16, %$10] ; # ->
  ret i64 %24
}

define i32 @getParse() {
$1:
; # (let P (val $Parser) (set $Chr (if (i32 (symByte P)) @ (let C (va...
; # (val $Parser)
  %0 = load i64*, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 112) to i64**)
; # (set $Chr (if (i32 (symByte P)) @ (let C (val 3 P) (set 3 P (shr ...
; # (if (i32 (symByte P)) @ (let C (val 3 P) (set 3 P (shr C 8)) (if ...
; # (symByte P)
  %1 = call i8 @symByte(i64* %0)
; # (i32 (symByte P))
  %2 = zext i8 %1 to i32
  %3 = icmp ne i32 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let C (val 3 P) (set 3 P (shr C 8)) (if C (i32 (i8 C)) -1))
; # (val 3 P)
  %4 = getelementptr i64, i64* %0, i32 2
  %5 = load i64, i64* %4
; # (set 3 P (shr C 8))
; # (shr C 8)
  %6 = lshr i64 %5, 8
  %7 = getelementptr i64, i64* %0, i32 2
  store i64 %6, i64* %7
; # (if C (i32 (i8 C)) -1)
  %8 = icmp ne i64 %5, 0
  br i1 %8, label %$5, label %$6
$5:
; # (i8 C)
  %9 = trunc i64 %5 to i8
; # (i32 (i8 C))
  %10 = zext i8 %9 to i32
  br label %$7
$6:
  br label %$7
$7:
  %11 = phi i32 [%10, %$5], [-1, %$6] ; # ->
  br label %$4
$4:
  %12 = phi i32 [%2, %$2], [%11, %$7] ; # ->
  store i32 %12, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  ret i32 %12
}

define i64 @parse(i64, i1, i64, i64) {
$1:
; # (let (Pars (val $Parser) In: (inFile (val $InFile)) Io: (ioFrame ...
; # (val $Parser)
  %4 = load i64*, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 112) to i64**)
; # (val $InFile)
  %5 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (b8 (ioFrame T))
  %6 = alloca i8, i64 24
; # (set $Parser (push 0 (save Nm) Eof))
; # (save Nm)
  %7 = alloca i64, i64 2, align 16
  %8 = ptrtoint i64* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 %0, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %11 = load i64, i64* %10
  %12 = inttoptr i64 %8 to i64*
  %13 = getelementptr i64, i64* %12, i32 1
  store i64 %11, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %8, i64* %14
; # (push 0 (save Nm) Eof)
  %15 = alloca i64, i64 3, align 16
  store i64 0, i64* %15
  %16 = getelementptr i64, i64* %15, i32 1
  store i64 %0, i64* %16
  %17 = getelementptr i64, i64* %15, i32 2
  store i64 %2, i64* %17
  store i64* %15, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 112) to i64**)
; # (when (In:) (In: next (val $Chr)) (set $InFile null))
; # (In:)
  %18 = icmp ne i8* %5, null
  br i1 %18, label %$2, label %$3
$2:
; # (In: next (val $Chr))
  %19 = getelementptr i8, i8* %5, i32 20
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  store i32 %21, i32* %20
; # (set $InFile null)
  store i8* null, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
  br label %$3
$3:
; # (set $Chr 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (Io: fun (val (i8** $Get)))
  %22 = getelementptr i8, i8* %6, i32 16
  %23 = bitcast i8* %22 to i8**
  %24 = bitcast i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**) to i8**
  %25 = load i8*, i8** %24
  store i8* %25, i8** %23
; # (set $Get (fun (i32) getParse))
; # (fun (i32) getParse)
  store i32()* @getParse, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
; # (Io: pid 0)
  %26 = getelementptr i8, i8* %6, i32 12
  %27 = bitcast i8* %26 to i32*
  store i32 0, i32* %27
; # (Io: fd 0)
  %28 = getelementptr i8, i8* %6, i32 8
  %29 = bitcast i8* %28 to i32*
  store i32 0, i32* %29
; # (Io: link (val $InFrames))
  %30 = bitcast i8* %6 to i8**
  %31 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
  store i8* %31, i8** %30
; # (set $InFrames (Io:))
; # (Io:)
  store i8* %6, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (when Skip (getParse))
  br i1 %1, label %$4, label %$5
$4:
; # (getParse)
  %32 = call i32 @getParse()
  br label %$5
$5:
; # (prog1 (cond ((=0 Set) (rdList)) ((== 1 Set) (read0 YES)) ((=0 (t...
; # (cond ((=0 Set) (rdList)) ((== 1 Set) (read0 YES)) ((=0 (token Se...
; # (=0 Set)
  %33 = icmp eq i64 %3, 0
  br i1 %33, label %$8, label %$7
$8:
; # (rdList)
  %34 = call i64 @rdList()
  br label %$6
$7:
; # (== 1 Set)
  %35 = icmp eq i64 1, %3
  br i1 %35, label %$10, label %$9
$10:
; # (read0 YES)
  %36 = call i64 @read0(i1 1)
  br label %$6
$9:
; # (token Set 0)
  %37 = call i64 @token(i64 %3, i32 0)
; # (=0 (token Set 0))
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$12, label %$11
$12:
  br label %$6
$11:
; # (let (R (save (cons @ $Nil)) P R) (while (token Set 0) (setq P (s...
; # (cons @ $Nil)
  %39 = call i64 @cons(i64 %37, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons @ $Nil))
  %40 = alloca i64, i64 2, align 16
  %41 = ptrtoint i64* %40 to i64
  %42 = inttoptr i64 %41 to i64*
  store i64 %39, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %44 = load i64, i64* %43
  %45 = inttoptr i64 %41 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  store i64 %44, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %41, i64* %47
; # (while (token Set 0) (setq P (set 2 P (cons @ $Nil))))
  br label %$13
$13:
  %48 = phi i64 [%39, %$11], [%52, %$14] ; # P
; # (token Set 0)
  %49 = call i64 @token(i64 %3, i32 0)
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$14, label %$15
$14:
  %51 = phi i64 [%48, %$13] ; # P
; # (set 2 P (cons @ $Nil))
; # (cons @ $Nil)
  %52 = call i64 @cons(i64 %49, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %53 = inttoptr i64 %51 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  store i64 %52, i64* %54
  br label %$13
$15:
  %55 = phi i64 [%48, %$13] ; # P
  br label %$6
$6:
  %56 = phi i64 [%34, %$8], [%36, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%39, %$15] ; # ->
; # (popInFiles)
  call void @popInFiles()
; # (set $Parser Pars)
  store i64* %4, i64** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 112) to i64**)
; # (drop *Safe)
  %57 = inttoptr i64 %8 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 %56
}

define void @putString(i8) {
$1:
; # (val $StrP)
  %1 = load i64*, i64** @$StrP
; # (byteSym B (val $StrP))
  call void @byteSym(i8 %0, i64* %1)
  ret void
}

define void @begString(i64*) {
$1:
; # (set $StrP P)
  store i64* %0, i64** @$StrP
; # (ofs (set $StrP P) 2)
  %1 = getelementptr i64, i64* %0, i32 2
; # (link (ofs (set $StrP P) 2))
  %2 = ptrtoint i64* %1 to i64
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = inttoptr i64 %2 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  store i64 %4, i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %2, i64* %7
; # (set 5 P (val (i64* $Put)) $Put (fun (void i8) putString))
; # (i64* $Put)
  %8 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i64*
; # (val (i64* $Put))
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %0, i32 4
  store i64 %9, i64* %10
; # (fun (void i8) putString)
  store void(i8)* @putString, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  ret void
}

define i64 @endString() {
$1:
; # (let (P (val $StrP) Q (ofs P 2)) (set (i64* $Put) (val 5 P)) (dro...
; # (val $StrP)
  %0 = load i64*, i64** @$StrP
; # (ofs P 2)
  %1 = getelementptr i64, i64* %0, i32 2
; # (set (i64* $Put) (val 5 P))
; # (i64* $Put)
  %2 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i64*
; # (val 5 P)
  %3 = getelementptr i64, i64* %0, i32 4
  %4 = load i64, i64* %3
  store i64 %4, i64* %2
; # (drop Q (consStr (val Q)))
  %5 = ptrtoint i64* %1 to i64
; # (val Q)
  %6 = load i64, i64* %1
; # (consStr (val Q))
  %7 = call i64 @consStr(i64 %6)
  %8 = inttoptr i64 %5 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %10, i64* %11
  ret i64 %7
}

define i64 @_any(i64) {
$1:
; # (cond ((nil? (needSymb Exe (eval (cadr Exe)))) @) ((sym? (val (ta...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$9, label %$8
$8:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$9:
; # (nil? (needSymb Exe (eval (cadr Exe))))
  %17 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %17, label %$11, label %$10
$11:
  br label %$2
$10:
; # (tail @)
  %18 = add i64 %13, -8
; # (val (tail @))
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (sym? (val (tail @)))
  %21 = and i64 %20, 8
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$13, label %$12
$13:
  br label %$2
$12:
; # (name @)
  br label %$14
$14:
  %23 = phi i64 [%20, %$12], [%29, %$15] ; # Tail
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$16, label %$15
$15:
  %26 = phi i64 [%23, %$14] ; # Tail
  %27 = inttoptr i64 %26 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
  br label %$14
$16:
  %30 = phi i64 [%23, %$14] ; # Tail
; # (parse (name @) YES (hex "20") 1)
  %31 = call i64 @parse(i64 %30, i1 1, i64 32, i64 1)
  br label %$2
$2:
  %32 = phi i64 [%13, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%31, %$16] ; # ->
  ret i64 %32
}

define i64 @_sym(i64) {
$1:
; # (let X (eval (cadr Exe)) (begString (push 4 NIL ZERO NIL NIL)) (p...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (push 4 NIL ZERO NIL NIL)
  %14 = alloca i64, i64 5, align 16
  store i64 4, i64* %14
  %15 = getelementptr i64, i64* %14, i32 2
  store i64 2, i64* %15
; # (begString (push 4 NIL ZERO NIL NIL))
  call void @begString(i64* %14)
; # (print X)
  call void @print(i64 %13)
; # (endString)
  %16 = call i64 @endString()
  ret i64 %16
}

define i64 @_str(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (cond ((nil? Y) Y) ((num? Y) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((nil? Y) Y) ((num? Y) (argErr Exe Y)) ((pair Y) (begString...
; # (nil? Y)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$9, label %$8
$9:
  %15 = phi i64 [%3, %$2] ; # X
  %16 = phi i64 [%13, %$2] ; # Y
  br label %$7
$8:
  %17 = phi i64 [%3, %$2] ; # X
  %18 = phi i64 [%13, %$2] ; # Y
; # (num? Y)
  %19 = and i64 %18, 6
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$11, label %$10
$11:
  %21 = phi i64 [%17, %$8] ; # X
  %22 = phi i64 [%18, %$8] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %22)
  unreachable
$10:
  %23 = phi i64 [%17, %$8] ; # X
  %24 = phi i64 [%18, %$8] ; # Y
; # (pair Y)
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$12
$13:
  %27 = phi i64 [%23, %$10] ; # X
  %28 = phi i64 [%24, %$10] ; # Y
; # (push 4 NIL ZERO NIL NIL)
  %29 = alloca i64, i64 5, align 16
  store i64 4, i64* %29
  %30 = getelementptr i64, i64* %29, i32 2
  store i64 2, i64* %30
; # (begString (push 4 NIL ZERO NIL NIL))
  call void @begString(i64* %29)
; # (loop (print (++ Y)) (? (atom Y)) (space))
  br label %$14
$14:
  %31 = phi i64 [%27, %$13], [%39, %$15] ; # X
  %32 = phi i64 [%28, %$13], [%40, %$15] ; # Y
; # (++ Y)
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = getelementptr i64, i64* %33, i32 1
  %36 = load i64, i64* %35
; # (print (++ Y))
  call void @print(i64 %34)
; # (? (atom Y))
; # (atom Y)
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$16, label %$15
$15:
  %39 = phi i64 [%31, %$14] ; # X
  %40 = phi i64 [%36, %$14] ; # Y
; # (space)
  call void @space()
  br label %$14
$16:
  %41 = phi i64 [%31, %$14] ; # X
  %42 = phi i64 [%36, %$14] ; # Y
  %43 = phi i64 [0, %$14] ; # ->
; # (endString)
  %44 = call i64 @endString()
  br label %$7
$12:
  %45 = phi i64 [%23, %$10] ; # X
  %46 = phi i64 [%24, %$10] ; # Y
; # (tail @)
  %47 = add i64 %24, -8
; # (val (tail @))
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (sym? (setq Y (val (tail @))))
  %50 = and i64 %49, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$18, label %$17
$18:
  %52 = phi i64 [%45, %$12] ; # X
  %53 = phi i64 [%49, %$12] ; # Y
  br label %$7
$17:
  %54 = phi i64 [%45, %$12] ; # X
  %55 = phi i64 [%49, %$12] ; # Y
; # (shift X)
  %56 = inttoptr i64 %54 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (atom (shift X))
  %59 = and i64 %58, 15
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$20, label %$19
$20:
  %61 = phi i64 [%58, %$17] ; # X
  %62 = phi i64 [%55, %$17] ; # Y
; # (name Y)
  br label %$21
$21:
  %63 = phi i64 [%62, %$20], [%69, %$22] ; # Tail
  %64 = and i64 %63, 6
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$23, label %$22
$22:
  %66 = phi i64 [%63, %$21] ; # Tail
  %67 = inttoptr i64 %66 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  br label %$21
$23:
  %70 = phi i64 [%63, %$21] ; # Tail
; # (parse (name Y) NO (hex "5D0A") 0)
  %71 = call i64 @parse(i64 %70, i1 0, i64 23818, i64 0)
  br label %$7
$19:
  %72 = phi i64 [%58, %$17] ; # X
  %73 = phi i64 [%55, %$17] ; # Y
; # (save Y (parse (name Y) NO 0 (save (evSym X))))
  %74 = alloca i64, i64 2, align 16
  %75 = ptrtoint i64* %74 to i64
  %76 = inttoptr i64 %75 to i64*
  store i64 %73, i64* %76
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %78 = load i64, i64* %77
  %79 = inttoptr i64 %75 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  store i64 %78, i64* %80
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %81
; # (name Y)
  br label %$24
$24:
  %82 = phi i64 [%73, %$19], [%88, %$25] ; # Tail
  %83 = and i64 %82, 6
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$26, label %$25
$25:
  %85 = phi i64 [%82, %$24] ; # Tail
  %86 = inttoptr i64 %85 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  %88 = load i64, i64* %87
  br label %$24
$26:
  %89 = phi i64 [%82, %$24] ; # Tail
; # (evSym X)
  %90 = call i64 @evSym(i64 %72)
; # (save (evSym X))
  %91 = alloca i64, i64 2, align 16
  %92 = ptrtoint i64* %91 to i64
  %93 = inttoptr i64 %92 to i64*
  store i64 %90, i64* %93
  %94 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %95 = load i64, i64* %94
  %96 = inttoptr i64 %92 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  store i64 %95, i64* %97
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %92, i64* %98
; # (parse (name Y) NO 0 (save (evSym X)))
  %99 = call i64 @parse(i64 %89, i1 0, i64 0, i64 %90)
  %100 = inttoptr i64 %75 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
  %103 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %102, i64* %103
  br label %$7
$7:
  %104 = phi i64 [%15, %$9], [%41, %$16], [%52, %$18], [%61, %$23], [%72, %$26] ; # X
  %105 = phi i64 [%16, %$9], [%42, %$16], [%53, %$18], [%62, %$23], [%73, %$26] ; # Y
  %106 = phi i64 [%16, %$9], [%44, %$16], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$18], [%71, %$23], [%99, %$26] ; # ->
  ret i64 %106
}

define i64 @repl(i64, i8*, i64) {
$1:
; # (when (num? X) (argErr Exe X))
; # (num? X)
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%2, %$1] ; # X
; # (argErr Exe X)
  call void @argErr(i64 %0, i64 %5)
  unreachable
$3:
  %6 = phi i64 [%2, %$1] ; # X
; # (if (and (sym? X) (== (firstByte X) (char "-"))) (let E (save (pa...
; # (and (sym? X) (== (firstByte X) (char "-")))
; # (sym? X)
  %7 = and i64 %6, 8
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  %9 = phi i64 [%6, %$3] ; # X
; # (firstByte X)
  %10 = call i8 @firstByte(i64 %9)
; # (== (firstByte X) (char "-"))
  %11 = icmp eq i8 %10, 45
  br label %$4
$4:
  %12 = phi i64 [%6, %$3], [%9, %$5] ; # X
  %13 = phi i1 [0, %$3], [%11, %$5] ; # ->
  br i1 %13, label %$6, label %$7
$6:
  %14 = phi i64 [%12, %$4] ; # X
; # (let E (save (parse (xName Exe X) YES (hex "5D0A") 0)) (evList E)...
; # (xName Exe X)
  %15 = call i64 @xName(i64 %0, i64 %14)
; # (parse (xName Exe X) YES (hex "5D0A") 0)
  %16 = call i64 @parse(i64 %15, i1 1, i64 23818, i64 0)
; # (save (parse (xName Exe X) YES (hex "5D0A") 0))
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %16, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (evList E)
  %25 = call i64 @evList(i64 %16)
; # (drop *Safe)
  %26 = inttoptr i64 %18 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %28, i64* %29
  br label %$8
$7:
  %30 = phi i64 [%12, %$4] ; # X
; # (when (and (nil? X) (not (val $Repl))) (set $Repl YES) (iSignal (...
; # (and (nil? X) (not (val $Repl)))
; # (nil? X)
  %31 = icmp eq i64 %30, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %31, label %$10, label %$9
$10:
  %32 = phi i64 [%30, %$7] ; # X
; # (val $Repl)
  %33 = load i1, i1* @$Repl
; # (not (val $Repl))
  %34 = icmp eq i1 %33, 0
  br label %$9
$9:
  %35 = phi i64 [%30, %$7], [%32, %$10] ; # X
  %36 = phi i1 [0, %$7], [%34, %$10] ; # ->
  br i1 %36, label %$11, label %$12
$11:
  %37 = phi i64 [%35, %$9] ; # X
; # (set $Repl YES)
  store i1 1, i1* @$Repl
; # (val SIGINT Sig)
  %38 = getelementptr i32, i32* @Sig, i32 1
  %39 = load i32, i32* %38
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car Args)) (func (; Args 1 priv~si...
  %40 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGINT Sig) (fun sig))
  call void @iSignal(i32 %39, i8* %40)
  br label %$12
$12:
  %41 = phi i64 [%35, %$9], [%37, %$11] ; # X
; # (let (Int (save (val $Intern)) P (b8 (ioFrame T)) V (link (push -...
; # (val $Intern)
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  %43 = load i64, i64* %42
; # (save (val $Intern))
  %44 = alloca i64, i64 2, align 16
  %45 = ptrtoint i64* %44 to i64
  %46 = inttoptr i64 %45 to i64*
  store i64 %43, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %48 = load i64, i64* %47
  %49 = inttoptr i64 %45 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  store i64 %48, i64* %50
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %51
; # (b8 (ioFrame T))
  %52 = alloca i8, i64 24
; # (push -ZERO NIL)
  %53 = alloca i64, i64 2, align 16
  %54 = ptrtoint i64* %53 to i64
  %55 = inttoptr i64 %54 to i64*
  store i64 10, i64* %55
; # (link (push -ZERO NIL))
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %57 = load i64, i64* %56
  %58 = inttoptr i64 %54 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %57, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %60
; # (push -ZERO NIL)
  %61 = alloca i64, i64 2, align 16
  %62 = ptrtoint i64* %61 to i64
  %63 = inttoptr i64 %62 to i64*
  store i64 10, i64* %63
; # (link (push -ZERO NIL))
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %65 = load i64, i64* %64
  %66 = inttoptr i64 %62 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %65, i64* %67
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %62, i64* %68
; # (rdOpen Exe X P)
  call void @rdOpen(i64 %0, i64 %41, i8* %52)
; # (pushInFiles P)
  call void @pushInFiles(i8* %52)
; # (set $Transient (set 2 $Transient $Nil))
; # (set 2 $Transient $Nil)
  %69 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %71
; # (loop (let Y (ifn (== (val $InFile) (val (val $InFiles))) (read1 ...
  br label %$13
$13:
  %72 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%186, %$46] ; # X
; # (let Y (ifn (== (val $InFile) (val (val $InFiles))) (read1 0) (co...
; # (ifn (== (val $InFile) (val (val $InFiles))) (read1 0) (cond ((=0...
; # (val $InFile)
  %73 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (val $InFiles)
  %74 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %75 = load i8*, i8** %74
; # (== (val $InFile) (val (val $InFiles)))
  %76 = icmp eq i8* %73, %75
  br i1 %76, label %$15, label %$14
$14:
  %77 = phi i64 [%72, %$13] ; # X
; # (read1 0)
  %78 = call i64 @read1(i32 0)
  br label %$16
$15:
  %79 = phi i64 [%72, %$13] ; # X
; # (cond ((=0 Prmt) (set $LinePrmt null)) ((or (nil? (runAt (val $Pr...
; # (=0 Prmt)
  %80 = icmp eq i8* %1, null
  br i1 %80, label %$19, label %$18
$19:
  %81 = phi i64 [%79, %$15] ; # X
; # (set $LinePrmt null)
  store i8* null, i8** @$LinePrmt
  br label %$17
$18:
  %82 = phi i64 [%79, %$15] ; # X
; # (or (nil? (runAt (val $Prompt))) (not (symb? @)))
; # (val $Prompt)
  %83 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 456) to i64) to i64*
  %84 = load i64, i64* %83
; # (runAt (val $Prompt))
  %85 = call i64 @runAt(i64 %84)
; # (nil? (runAt (val $Prompt)))
  %86 = icmp eq i64 %85, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %86, label %$20, label %$21
$21:
  %87 = phi i64 [%82, %$18] ; # X
; # (symb? @)
  %88 = xor i64 %85, 8
  %89 = and i64 %88, 14
  %90 = icmp eq i64 %89, 0
; # (not (symb? @))
  %91 = icmp eq i1 %90, 0
  br label %$20
$20:
  %92 = phi i64 [%82, %$18], [%87, %$21] ; # X
  %93 = phi i1 [1, %$18], [%91, %$21] ; # ->
  br i1 %93, label %$23, label %$22
$23:
  %94 = phi i64 [%92, %$20] ; # X
; # (set $LinePrmt Prmt)
  store i8* %1, i8** @$LinePrmt
  br label %$17
$22:
  %95 = phi i64 [%92, %$20] ; # X
; # (let (Nm (name (val (tail @))) N (bufSize Nm) P (set $ReplPrmt (a...
; # (tail @)
  %96 = add i64 %85, -8
; # (val (tail @))
  %97 = inttoptr i64 %96 to i64*
  %98 = load i64, i64* %97
; # (name (val (tail @)))
  br label %$24
$24:
  %99 = phi i64 [%98, %$22], [%105, %$25] ; # Tail
  %100 = and i64 %99, 6
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$26, label %$25
$25:
  %102 = phi i64 [%99, %$24] ; # Tail
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
  br label %$24
$26:
  %106 = phi i64 [%99, %$24] ; # Tail
; # (bufSize Nm)
  %107 = call i64 @bufSize(i64 %106)
; # (set $ReplPrmt (alloc (val $ReplPrmt) (+ N (strlen Prmt))))
; # (val $ReplPrmt)
  %108 = load i8*, i8** @$ReplPrmt
; # (strlen Prmt)
  %109 = call i64 @strlen(i8* %1)
; # (+ N (strlen Prmt))
  %110 = add i64 %107, %109
; # (alloc (val $ReplPrmt) (+ N (strlen Prmt)))
  %111 = call i8* @alloc(i8* %108, i64 %110)
  store i8* %111, i8** @$ReplPrmt
; # (bufString Nm P)
  %112 = call i8* @bufString(i64 %106, i8* %111)
; # (dec N)
  %113 = sub i64 %107, 1
; # (ofs P (dec N))
  %114 = getelementptr i8, i8* %111, i64 %113
; # (strcpy (ofs P (dec N)) Prmt)
  %115 = call i8* @strcpy(i8* %114, i8* %1)
; # (set $LinePrmt P)
  store i8* %111, i8** @$LinePrmt
  br label %$17
$17:
  %116 = phi i64 [%81, %$19], [%94, %$23], [%95, %$26] ; # X
  %117 = phi i8* [null, %$19], [%1, %$23], [%111, %$26] ; # ->
; # (prog1 (read1 (if (isatty 0) (char "^J") (i32 0))) (while (gt0 (v...
; # (if (isatty 0) (char "^J") (i32 0))
; # (isatty 0)
  %118 = call i32 @isatty(i32 0)
  %119 = icmp ne i32 %118, 0
  br i1 %119, label %$27, label %$28
$27:
  %120 = phi i64 [%116, %$17] ; # X
  br label %$29
$28:
  %121 = phi i64 [%116, %$17] ; # X
; # (i32 0)
  br label %$29
$29:
  %122 = phi i64 [%120, %$27], [%121, %$28] ; # X
  %123 = phi i32 [10, %$27], [0, %$28] ; # ->
; # (read1 (if (isatty 0) (char "^J") (i32 0)))
  %124 = call i64 @read1(i32 %123)
; # (while (gt0 (val $Chr)) (? (== (val $Chr) (char "^J")) (set $Chr ...
  br label %$30
$30:
  %125 = phi i64 [%122, %$29], [%142, %$37] ; # X
; # (val $Chr)
  %126 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (gt0 (val $Chr))
  %127 = icmp sgt i32 %126, 0
  br i1 %127, label %$31, label %$32
$31:
  %128 = phi i64 [%125, %$30] ; # X
; # (? (== (val $Chr) (char "^J")) (set $Chr 0))
; # (val $Chr)
  %129 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (== (val $Chr) (char "^J"))
  %130 = icmp eq i32 %129, 10
  br i1 %130, label %$34, label %$33
$34:
  %131 = phi i64 [%128, %$31] ; # X
; # (set $Chr 0)
  store i32 0, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  br label %$32
$33:
  %132 = phi i64 [%128, %$31] ; # X
; # (if (== (val $Chr) (char "#")) (comment) (? (> (val $Chr) (char "...
; # (val $Chr)
  %133 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (== (val $Chr) (char "#"))
  %134 = icmp eq i32 %133, 35
  br i1 %134, label %$35, label %$36
$35:
  %135 = phi i64 [%132, %$33] ; # X
; # (comment)
  call void @comment()
  br label %$37
$36:
  %136 = phi i64 [%132, %$33] ; # X
; # (? (> (val $Chr) (char " ")))
; # (val $Chr)
  %137 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
; # (> (val $Chr) (char " "))
  %138 = icmp sgt i32 %137, 32
  br i1 %138, label %$32, label %$38
$38:
  %139 = phi i64 [%136, %$36] ; # X
; # (call $Get)
  %140 = load i32()*, i32()** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 88) to i32()**)
  %141 = call i32 %140()
  br label %$37
$37:
  %142 = phi i64 [%135, %$35], [%139, %$38] ; # X
  br label %$30
$32:
  %143 = phi i64 [%125, %$30], [%131, %$34], [%136, %$36] ; # X
  br label %$16
$16:
  %144 = phi i64 [%77, %$14], [%143, %$32] ; # X
  %145 = phi i64 [%78, %$14], [%124, %$32] ; # ->
; # (? (nil? Y))
; # (nil? Y)
  %146 = icmp eq i64 %145, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %146, label %$40, label %$39
$39:
  %147 = phi i64 [%144, %$16] ; # X
; # (set V Y)
  %148 = inttoptr i64 %54 to i64*
  store i64 %145, i64* %148
; # (if (or (<> (val $InFile) (val (val $InFiles))) (val $Chr) (=0 Pr...
; # (or (<> (val $InFile) (val (val $InFiles))) (val $Chr) (=0 Prmt))...
; # (val $InFile)
  %149 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (val $InFiles)
  %150 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %151 = load i8*, i8** %150
; # (<> (val $InFile) (val (val $InFiles)))
  %152 = icmp ne i8* %149, %151
  br i1 %152, label %$41, label %$42
$42:
  %153 = phi i64 [%147, %$39] ; # X
; # (val $Chr)
  %154 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 72) to i32*)
  %155 = icmp ne i32 %154, 0
  br i1 %155, label %$41, label %$43
$43:
  %156 = phi i64 [%153, %$42] ; # X
; # (=0 Prmt)
  %157 = icmp eq i8* %1, null
  br label %$41
$41:
  %158 = phi i64 [%147, %$39], [%153, %$42], [%156, %$43] ; # X
  %159 = phi i1 [1, %$39], [1, %$42], [%157, %$43] ; # ->
  br i1 %159, label %$44, label %$45
$44:
  %160 = phi i64 [%158, %$41] ; # X
; # (eval Y)
  %161 = and i64 %145, 6
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$49, label %$48
$49:
  br label %$47
$48:
  %163 = and i64 %145, 8
  %164 = icmp ne i64 %163, 0
  br i1 %164, label %$51, label %$50
$51:
  %165 = inttoptr i64 %145 to i64*
  %166 = load i64, i64* %165
  br label %$47
$50:
  %167 = call i64 @evList(i64 %145)
  br label %$47
$47:
  %168 = phi i64 [%145, %$49], [%166, %$51], [%167, %$50] ; # ->
  br label %$46
$45:
  %169 = phi i64 [%158, %$41] ; # X
; # (flushAll)
  call void @flushAll()
; # (let A (set At (val $At)) (setq X (eval Y)) (set $At3 (val $At2) ...
; # (set At (val $At))
; # (val $At)
  %170 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %171 = load i64, i64* %170
  %172 = inttoptr i64 %62 to i64*
  store i64 %171, i64* %172
; # (eval Y)
  %173 = and i64 %145, 6
  %174 = icmp ne i64 %173, 0
  br i1 %174, label %$54, label %$53
$54:
  br label %$52
$53:
  %175 = and i64 %145, 8
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$56, label %$55
$56:
  %177 = inttoptr i64 %145 to i64*
  %178 = load i64, i64* %177
  br label %$52
$55:
  %179 = call i64 @evList(i64 %145)
  br label %$52
$52:
  %180 = phi i64 [%145, %$54], [%178, %$56], [%179, %$55] ; # ->
; # (set $At3 (val $At2) $At2 A $At X)
; # (val $At2)
  %181 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 424) to i64) to i64*
  store i64 %182, i64* %183
  %184 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %171, i64* %184
  %185 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %180, i64* %185
; # (outString ($ "-> "))
  call void @outString(i8* bitcast ([4 x i8]* @$43 to i8*))
; # (flushAll)
  call void @flushAll()
; # (print X)
  call void @print(i64 %180)
; # (newline)
  call void @newline()
  br label %$46
$46:
  %186 = phi i64 [%168, %$47], [%180, %$52] ; # X
  br label %$13
$40:
  %187 = phi i64 [%144, %$16] ; # X
  %188 = phi i64 [0, %$16] ; # ->
; # (popInFiles)
  call void @popInFiles()
; # (set $Transient (set 2 $Transient $Nil))
; # (set 2 $Transient $Nil)
  %189 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  %190 = getelementptr i64, i64* %189, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %190
  %191 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 0) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %191
; # (set $Intern Int)
  %192 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 120) to i64) to i64*
  store i64 %43, i64* %192
; # (drop *Safe)
  %193 = inttoptr i64 %45 to i64*
  %194 = getelementptr i64, i64* %193, i32 1
  %195 = load i64, i64* %194
  %196 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %195, i64* %196
  br label %$8
$8:
  %197 = phi i64 [%14, %$6], [%187, %$40] ; # X
  %198 = phi i64 [%25, %$6], [%187, %$40] ; # ->
  ret i64 %198
}

define i64 @loadAll(i64) {
$1:
; # (let X $Nil (loop (let (A (val $AV) P (val A)) (? (or (=0 P) (and...
; # (loop (let (A (val $AV) P (val A)) (? (or (=0 P) (and (== (val P)...
  br label %$2
$2:
  %1 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%19, %$7] ; # X
; # (let (A (val $AV) P (val A)) (? (or (=0 P) (and (== (val P) (char...
; # (val $AV)
  %2 = load i8**, i8*** @$AV
; # (val A)
  %3 = load i8*, i8** %2
; # (? (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P)))))
; # (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P))))
; # (=0 P)
  %4 = icmp eq i8* %3, null
  br i1 %4, label %$3, label %$4
$4:
  %5 = phi i64 [%1, %$2] ; # X
; # (and (== (val P) (char "-")) (=0 (val 2 P)))
; # (val P)
  %6 = load i8, i8* %3
; # (== (val P) (char "-"))
  %7 = icmp eq i8 %6, 45
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$4] ; # X
; # (val 2 P)
  %9 = getelementptr i8, i8* %3, i32 1
  %10 = load i8, i8* %9
; # (=0 (val 2 P))
  %11 = icmp eq i8 %10, 0
  br label %$5
$5:
  %12 = phi i64 [%5, %$4], [%8, %$6] ; # X
  %13 = phi i1 [0, %$4], [%11, %$6] ; # ->
  br label %$3
$3:
  %14 = phi i64 [%1, %$2], [%12, %$5] ; # X
  %15 = phi i1 [1, %$2], [%13, %$5] ; # ->
  br i1 %15, label %$8, label %$7
$7:
  %16 = phi i64 [%14, %$3] ; # X
; # (set $AV (inc A))
; # (inc A)
  %17 = getelementptr i8*, i8** %2, i32 1
  store i8** %17, i8*** @$AV
; # (mkStr P)
  %18 = call i64 @mkStr(i8* %3)
; # (repl Exe null (mkStr P))
  %19 = call i64 @repl(i64 %0, i8* null, i64 %18)
  br label %$2
$8:
  %20 = phi i64 [%14, %$3] ; # X
  %21 = phi i64 [0, %$3] ; # ->
  ret i64 %20
}

define i64 @_load(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (if (t? (eval (++ X))) (loadAll Exe...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (if (t? (eval (++ X))) (loadAll Exe) (repl Exe ($ ">...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%27, %$11] ; # X
; # (let Y (if (t? (eval (++ X))) (loadAll Exe) (repl Exe ($ "> ") @)...
; # (if (t? (eval (++ X))) (loadAll Exe) (repl Exe ($ "> ") @))
; # (++ X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
; # (eval (++ X))
  %9 = and i64 %6, 6
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  br label %$3
$4:
  %11 = and i64 %6, 8
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$7, label %$6
$7:
  %13 = inttoptr i64 %6 to i64*
  %14 = load i64, i64* %13
  br label %$3
$6:
  %15 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %16 = phi i64 [%6, %$5], [%14, %$7], [%15, %$6] ; # ->
; # (t? (eval (++ X)))
  %17 = icmp eq i64 %16, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %17, label %$8, label %$9
$8:
  %18 = phi i64 [%8, %$3] ; # X
; # (loadAll Exe)
  %19 = call i64 @loadAll(i64 %0)
  br label %$10
$9:
  %20 = phi i64 [%8, %$3] ; # X
; # (repl Exe ($ "> ") @)
  %21 = call i64 @repl(i64 %0, i8* bitcast ([3 x i8]* @$44 to i8*), i64 %16)
  br label %$10
$10:
  %22 = phi i64 [%18, %$8], [%20, %$9] ; # X
  %23 = phi i64 [%19, %$8], [%21, %$9] ; # ->
; # (? (atom X) Y)
; # (atom X)
  %24 = and i64 %22, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$13, label %$11
$13:
  %26 = phi i64 [%22, %$10] ; # X
  br label %$12
$11:
  %27 = phi i64 [%22, %$10] ; # X
  br label %$2
$12:
  %28 = phi i64 [%26, %$13] ; # X
  %29 = phi i64 [%23, %$13] ; # ->
  ret i64 %29
}

define void @dbfErr(i64) {
$1:
; # (err Exe 0 ($ "Bad DB file") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([12 x i8]* @$45 to i8*), i8* null)
  unreachable
}

define void @dbRdErr() {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "DB read: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([12 x i8]* @$46 to i8*), i8* %0)
  unreachable
}

define void @dbWrErr() {
$1:
; # (strErrno)
  %0 = call i8* @strErrno()
; # (err 0 0 ($ "DB write: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([13 x i8]* @$47 to i8*), i8* %0)
  unreachable
}

define void @jnlErr(i64) {
$1:
; # (err Exe 0 ($ "Bad Journal") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([12 x i8]* @$48 to i8*), i8* null)
  unreachable
}

define void @dbSyncErr(i64) {
$1:
; # (strErrno)
  %1 = call i8* @strErrno()
; # (err Exe 0 ($ "DB fsync error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([19 x i8]* @$49 to i8*), i8* %1)
  unreachable
}

define i64 @getAdr(i8*) {
$1:
; # (val 6 P)
  %1 = getelementptr i8, i8* %0, i32 5
  %2 = load i8, i8* %1
; # (i64 (val 6 P))
  %3 = zext i8 %2 to i64
; # (shl (i64 (val 6 P)) 8)
  %4 = shl i64 %3, 8
; # (val 5 P)
  %5 = getelementptr i8, i8* %0, i32 4
  %6 = load i8, i8* %5
; # (i64 (val 5 P))
  %7 = zext i8 %6 to i64
; # (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P)))
  %8 = or i64 %4, %7
; # (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8)
  %9 = shl i64 %8, 8
; # (val 4 P)
  %10 = getelementptr i8, i8* %0, i32 3
  %11 = load i8, i8* %10
; # (i64 (val 4 P))
  %12 = zext i8 %11 to i64
; # (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8) (i64 (val ...
  %13 = or i64 %9, %12
; # (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8) (i64 ...
  %14 = shl i64 %13, 8
; # (val 3 P)
  %15 = getelementptr i8, i8* %0, i32 2
  %16 = load i8, i8* %15
; # (i64 (val 3 P))
  %17 = zext i8 %16 to i64
; # (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) 8) (i...
  %18 = or i64 %14, %17
; # (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P))) ...
  %19 = shl i64 %18, 8
; # (val 2 P)
  %20 = getelementptr i8, i8* %0, i32 1
  %21 = load i8, i8* %20
; # (i64 (val 2 P))
  %22 = zext i8 %21 to i64
; # (| (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val 5 P)...
  %23 = or i64 %19, %22
; # (shl (| (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (val...
  %24 = shl i64 %23, 8
; # (val P)
  %25 = load i8, i8* %0
; # (i64 (val P))
  %26 = zext i8 %25 to i64
; # (| (shl (| (shl (| (shl (| (shl (| (shl (i64 (val 6 P)) 8) (i64 (...
  %27 = or i64 %24, %26
  ret i64 %27
}

define void @setAdr(i64, i8*) {
$1:
; # (set P (i8 N))
; # (i8 N)
  %2 = trunc i64 %0 to i8
  store i8 %2, i8* %1
; # (set 2 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %3 = lshr i64 %0, 8
; # (i8 (setq N (shr N 8)))
  %4 = trunc i64 %3 to i8
  %5 = getelementptr i8, i8* %1, i32 1
  store i8 %4, i8* %5
; # (set 3 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %6 = lshr i64 %3, 8
; # (i8 (setq N (shr N 8)))
  %7 = trunc i64 %6 to i8
  %8 = getelementptr i8, i8* %1, i32 2
  store i8 %7, i8* %8
; # (set 4 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %9 = lshr i64 %6, 8
; # (i8 (setq N (shr N 8)))
  %10 = trunc i64 %9 to i8
  %11 = getelementptr i8, i8* %1, i32 3
  store i8 %10, i8* %11
; # (set 5 P (i8 (setq N (shr N 8))))
; # (shr N 8)
  %12 = lshr i64 %9, 8
; # (i8 (setq N (shr N 8)))
  %13 = trunc i64 %12 to i8
  %14 = getelementptr i8, i8* %1, i32 4
  store i8 %13, i8* %14
; # (set 6 P (i8 (shr N 8)))
; # (shr N 8)
  %15 = lshr i64 %12, 8
; # (i8 (shr N 8))
  %16 = trunc i64 %15 to i8
  %17 = getelementptr i8, i8* %1, i32 5
  store i8 %16, i8* %17
  ret void
}

define i1 @dbfBuf(i8*) {
$1:
; # (let N (| (shl (i32 (val 2 P)) 8) (i32 (val P))) (and (> (val $DB...
; # (val 2 P)
  %1 = getelementptr i8, i8* %0, i32 1
  %2 = load i8, i8* %1
; # (i32 (val 2 P))
  %3 = zext i8 %2 to i32
; # (shl (i32 (val 2 P)) 8)
  %4 = shl i32 %3, 8
; # (val P)
  %5 = load i8, i8* %0
; # (i32 (val P))
  %6 = zext i8 %5 to i32
; # (| (shl (i32 (val 2 P)) 8) (i32 (val P)))
  %7 = or i32 %4, %6
; # (and (> (val $DBs) N) (prog (set $DbFile (ofs (val $DbFiles) (* N...
; # (val $DBs)
  %8 = load i32, i32* @$DBs
; # (> (val $DBs) N)
  %9 = icmp sgt i32 %8, %7
  br i1 %9, label %$3, label %$2
$3:
; # (set $DbFile (ofs (val $DbFiles) (* N (dbFile T))))
; # (val $DbFiles)
  %10 = load i8*, i8** @$DbFiles
; # (* N (dbFile T))
  %11 = mul i32 %7, 42
; # (ofs (val $DbFiles) (* N (dbFile T)))
  %12 = getelementptr i8, i8* %10, i32 %11
  store i8* %12, i8** @$DbFile
  br label %$2
$2:
  %13 = phi i1 [0, %$1], [1, %$3] ; # ->
  ret i1 %13
}

define void @rdLockDb() {
$1:
; # (unless (== $T (val $Solo)) (while (lt0 (rdLock ((dbFile (val $Db...
; # (val $Solo)
  %0 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  %1 = load i64, i64* %0
; # (== $T (val $Solo))
  %2 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %1
  br i1 %2, label %$3, label %$2
$2:
; # (while (lt0 (rdLock ((dbFile (val $DbFiles)) fd) 0 1 YES)) (unles...
  br label %$4
$4:
; # (val $DbFiles)
  %3 = load i8*, i8** @$DbFiles
; # ((dbFile (val $DbFiles)) fd)
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (rdLock ((dbFile (val $DbFiles)) fd) 0 1 YES)
  %6 = call i32 @rdLock(i32 %5, i64 0, i64 1)
; # (lt0 (rdLock ((dbFile (val $DbFiles)) fd) 0 1 YES))
  %7 = icmp slt i32 %6, 0
  br i1 %7, label %$5, label %$6
$5:
; # (unless (== (gErrno) EINTR) (lockErr))
; # (gErrno)
  %8 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %9 = icmp eq i32 %8, 2
  br i1 %9, label %$8, label %$7
$7:
; # (lockErr)
  call void @lockErr()
  unreachable
$8:
  br label %$4
$6:
  br label %$3
$3:
  ret void
}

define void @wrLockDb() {
$1:
; # (unless (== $T (val $Solo)) (while (lt0 (wrLock ((dbFile (val $Db...
; # (val $Solo)
  %0 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  %1 = load i64, i64* %0
; # (== $T (val $Solo))
  %2 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %1
  br i1 %2, label %$3, label %$2
$2:
; # (while (lt0 (wrLock ((dbFile (val $DbFiles)) fd) 0 1 YES)) (unles...
  br label %$4
$4:
; # (val $DbFiles)
  %3 = load i8*, i8** @$DbFiles
; # ((dbFile (val $DbFiles)) fd)
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (wrLock ((dbFile (val $DbFiles)) fd) 0 1 YES)
  %6 = call i32 @wrLock(i32 %5, i64 0, i64 1, i32 1)
; # (lt0 (wrLock ((dbFile (val $DbFiles)) fd) 0 1 YES))
  %7 = icmp slt i32 %6, 0
  br i1 %7, label %$5, label %$6
$5:
; # (unless (== (gErrno) EINTR) (lockErr))
; # (gErrno)
  %8 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %9 = icmp eq i32 %8, 2
  br i1 %9, label %$8, label %$7
$7:
; # (lockErr)
  call void @lockErr()
  unreachable
$8:
  br label %$4
$6:
  br label %$3
$3:
  ret void
}

define void @unLockDb(i64) {
$1:
; # (unless (== $T (val $Solo)) (unless Len (let (P (val $DbFiles) C ...
; # (val $Solo)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  %2 = load i64, i64* %1
; # (== $T (val $Solo))
  %3 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %2
  br i1 %3, label %$3, label %$2
$2:
; # (unless Len (let (P (val $DbFiles) C (val $DBs)) (while (dec 'C) ...
  %4 = icmp ne i64 %0, 0
  br i1 %4, label %$5, label %$4
$4:
; # (let (P (val $DbFiles) C (val $DBs)) (while (dec 'C) (let Db: (db...
; # (val $DbFiles)
  %5 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %6 = load i32, i32* @$DBs
; # (while (dec 'C) (let Db: (dbFile (setq P (ofs P (dbFile T)))) (wh...
  br label %$6
$6:
  %7 = phi i8* [%5, %$4], [%24, %$10] ; # P
  %8 = phi i32 [%6, %$4], [%25, %$10] ; # C
; # (dec 'C)
  %9 = sub i32 %8, 1
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %$7, label %$8
$7:
  %11 = phi i8* [%7, %$6] ; # P
  %12 = phi i32 [%9, %$6] ; # C
; # (let Db: (dbFile (setq P (ofs P (dbFile T)))) (when (Db: lck) (un...
; # (ofs P (dbFile T))
  %13 = getelementptr i8, i8* %11, i32 42
; # (when (Db: lck) (unLock (Db: fd) 0 0) (Db: lck NO))
; # (Db: lck)
  %14 = getelementptr i8, i8* %13, i32 40
  %15 = bitcast i8* %14 to i1*
  %16 = load i1, i1* %15
  br i1 %16, label %$9, label %$10
$9:
  %17 = phi i8* [%13, %$7] ; # P
  %18 = phi i32 [%12, %$7] ; # C
; # (Db: fd)
  %19 = bitcast i8* %13 to i32*
  %20 = load i32, i32* %19
; # (unLock (Db: fd) 0 0)
  %21 = call i32 @unLock(i32 %20, i64 0, i64 0)
; # (Db: lck NO)
  %22 = getelementptr i8, i8* %13, i32 40
  %23 = bitcast i8* %22 to i1*
  store i1 0, i1* %23
  br label %$10
$10:
  %24 = phi i8* [%13, %$7], [%17, %$9] ; # P
  %25 = phi i32 [%12, %$7], [%18, %$9] ; # C
  br label %$6
$8:
  %26 = phi i8* [%7, %$6] ; # P
  %27 = phi i32 [%9, %$6] ; # C
; # (set $Solo ZERO)
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  store i64 2, i64* %28
  br label %$5
$5:
; # (val $DbFiles)
  %29 = load i8*, i8** @$DbFiles
; # ((dbFile (val $DbFiles)) fd)
  %30 = bitcast i8* %29 to i32*
  %31 = load i32, i32* %30
; # (unLock ((dbFile (val $DbFiles)) fd) 0 Len)
  %32 = call i32 @unLock(i32 %31, i64 0, i64 %0)
  br label %$3
$3:
  ret void
}

define i32 @tryLock(i64, i64) {
$1:
; # (let Db: (dbFile (val $DbFile)) (loop (when (ge0 (wrLock (Db: fd)...
; # (val $DbFile)
  %2 = load i8*, i8** @$DbFile
; # (loop (when (ge0 (wrLock (Db: fd) N Len NO)) (Db: lck YES) (cond ...
  br label %$2
$2:
; # (when (ge0 (wrLock (Db: fd) N Len NO)) (Db: lck YES) (cond ((=0 N...
; # (Db: fd)
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3
; # (wrLock (Db: fd) N Len NO)
  %5 = call i32 @wrLock(i32 %4, i64 %0, i64 %1, i32 0)
; # (ge0 (wrLock (Db: fd) N Len NO))
  %6 = icmp sge i32 %5, 0
  br i1 %6, label %$3, label %$4
$3:
; # (Db: lck YES)
  %7 = getelementptr i8, i8* %2, i32 40
  %8 = bitcast i8* %7 to i1*
  store i1 1, i1* %8
; # (cond ((=0 N) (set $Solo $T)) ((== $T (val $Solo)) (set $Solo $Ni...
; # (=0 N)
  %9 = icmp eq i64 %0, 0
  br i1 %9, label %$7, label %$6
$7:
; # (set $Solo $T)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), i64* %10
  br label %$5
$6:
; # (val $Solo)
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  %12 = load i64, i64* %11
; # (== $T (val $Solo))
  %13 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %12
  br i1 %13, label %$9, label %$8
$9:
; # (set $Solo $Nil)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %14
  br label %$5
$8:
  br label %$5
$5:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [0, %$8] ; # ->
; # (ret 0)
  ret i32 0
$4:
; # (unless (or (== (gErrno) EINTR) (== @ EACCES) (== @ EAGAIN)) (loc...
; # (or (== (gErrno) EINTR) (== @ EACCES) (== @ EAGAIN))
; # (gErrno)
  %16 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %17 = icmp eq i32 %16, 2
  br i1 %17, label %$10, label %$11
$11:
; # (== @ EACCES)
  %18 = icmp eq i32 %16, 5
  br i1 %18, label %$10, label %$12
$12:
; # (== @ EAGAIN)
  %19 = icmp eq i32 %16, 4
  br label %$10
$10:
  %20 = phi i1 [1, %$4], [1, %$11], [%19, %$12] ; # ->
  br i1 %20, label %$14, label %$13
$13:
; # (lockErr)
  call void @lockErr()
  unreachable
$14:
; # (let Pid T (while (lt0 (setq Pid (getLock (Db: fd) N Len))) (unle...
; # (while (lt0 (setq Pid (getLock (Db: fd) N Len))) (unless (== (gEr...
  br label %$15
$15:
; # (Db: fd)
  %21 = bitcast i8* %2 to i32*
  %22 = load i32, i32* %21
; # (getLock (Db: fd) N Len)
  %23 = call i32 @getLock(i32 %22, i64 %0, i64 %1)
; # (lt0 (setq Pid (getLock (Db: fd) N Len)))
  %24 = icmp slt i32 %23, 0
  br i1 %24, label %$16, label %$17
$16:
  %25 = phi i32 [%23, %$15] ; # Pid
; # (unless (== (gErrno) EINTR) (lockErr))
; # (gErrno)
  %26 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %27 = icmp eq i32 %26, 2
  br i1 %27, label %$19, label %$18
$18:
  %28 = phi i32 [%25, %$16] ; # Pid
; # (lockErr)
  call void @lockErr()
  unreachable
$19:
  %29 = phi i32 [%25, %$16] ; # Pid
  br label %$15
$17:
  %30 = phi i32 [%23, %$15] ; # Pid
; # (when (gt0 Pid) (ret Pid))
; # (gt0 Pid)
  %31 = icmp sgt i32 %30, 0
  br i1 %31, label %$20, label %$21
$20:
  %32 = phi i32 [%30, %$17] ; # Pid
; # (ret Pid)
  ret i32 %32
$21:
  %33 = phi i32 [%30, %$17] ; # Pid
  br label %$2
}

define void @lockJnl() {
$1:
; # (while (lt0 (wrLock (fileno (val $DbJnl)) 0 0 YES)) (unless (== (...
  br label %$2
$2:
; # (val $DbJnl)
  %0 = load i8*, i8** @$DbJnl
; # (fileno (val $DbJnl))
  %1 = call i32 @fileno(i8* %0)
; # (wrLock (fileno (val $DbJnl)) 0 0 YES)
  %2 = call i32 @wrLock(i32 %1, i64 0, i64 0, i32 1)
; # (lt0 (wrLock (fileno (val $DbJnl)) 0 0 YES))
  %3 = icmp slt i32 %2, 0
  br i1 %3, label %$3, label %$4
$3:
; # (unless (== (gErrno) EINTR) (lockErr))
; # (gErrno)
  %4 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %5 = icmp eq i32 %4, 2
  br i1 %5, label %$6, label %$5
$5:
; # (lockErr)
  call void @lockErr()
  unreachable
$6:
  br label %$2
$4:
  ret void
}

define void @unLockJnl() {
$1:
; # (let Jnl (val $DbJnl) (fflush Jnl) (unLock (fileno Jnl) 0 0))
; # (val $DbJnl)
  %0 = load i8*, i8** @$DbJnl
; # (fflush Jnl)
  %1 = call i32 @fflush(i8* %0)
; # (fileno Jnl)
  %2 = call i32 @fileno(i8* %0)
; # (unLock (fileno Jnl) 0 0)
  %3 = call i32 @unLock(i32 %2, i64 0, i64 0)
  ret void
}

define void @blkPeek(i64, i8*, i32) {
$1:
; # (let Db: (dbFile (val $DbFile)) (unless (== Siz (i32 (pread (Db: ...
; # (val $DbFile)
  %3 = load i8*, i8** @$DbFile
; # (unless (== Siz (i32 (pread (Db: fd) Buf (i64 Siz) Pos))) (dbRdEr...
; # (Db: fd)
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (i64 Siz)
  %6 = sext i32 %2 to i64
; # (pread (Db: fd) Buf (i64 Siz) Pos)
  %7 = call i64 @pread(i32 %5, i8* %1, i64 %6, i64 %0)
; # (i32 (pread (Db: fd) Buf (i64 Siz) Pos))
  %8 = trunc i64 %7 to i32
; # (== Siz (i32 (pread (Db: fd) Buf (i64 Siz) Pos)))
  %9 = icmp eq i32 %2, %8
  br i1 %9, label %$3, label %$2
$2:
; # (dbRdErr)
  call void @dbRdErr()
  unreachable
$3:
  ret void
}

define i8* @rdBlock(i64) {
$1:
; # (let (Db: (dbFile (val $DbFile)) Blk (val $DbBlock)) (blkPeek (sh...
; # (val $DbFile)
  %1 = load i8*, i8** @$DbFile
; # (val $DbBlock)
  %2 = load i8*, i8** @$DbBlock
; # (set $BlkIndex N)
  store i64 %0, i64* @$BlkIndex
; # (Db: sh)
  %3 = getelementptr i8, i8* %1, i32 8
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (i64 (Db: sh))
  %6 = sext i32 %5 to i64
; # (shl (set $BlkIndex N) (i64 (Db: sh)))
  %7 = shl i64 %0, %6
; # (Db: siz)
  %8 = getelementptr i8, i8* %1, i32 12
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (blkPeek (shl (set $BlkIndex N) (i64 (Db: sh))) Blk (Db: siz))
  call void @blkPeek(i64 %7, i8* %2, i32 %10)
; # (set $BlkLink (& (getAdr Blk) BLKMASK) $BlkEnd (ofs Blk (+ (Db: s...
; # (getAdr Blk)
  %11 = call i64 @getAdr(i8* %2)
; # (& (getAdr Blk) BLKMASK)
  %12 = and i64 %11, -64
  store i64 %12, i64* @$BlkLink
; # (Db: siz)
  %13 = getelementptr i8, i8* %1, i32 12
  %14 = bitcast i8* %13 to i32*
  %15 = load i32, i32* %14
; # (+ (Db: siz) BLK)
  %16 = add i32 %15, 6
; # (ofs Blk (+ (Db: siz) BLK))
  %17 = getelementptr i8, i8* %2, i32 %16
  store i8* %17, i8** @$BlkEnd
; # (ofs Blk BLK)
  %18 = getelementptr i8, i8* %2, i32 6
  store i8* %18, i8** @$BlkPtr
  ret i8* %18
}

define void @blkPoke(i64, i8*, i32) {
$1:
; # (let Db: (dbFile (val $DbFile)) (unless (== Siz (i32 (pwrite (Db:...
; # (val $DbFile)
  %3 = load i8*, i8** @$DbFile
; # (unless (== Siz (i32 (pwrite (Db: fd) Buf (i64 Siz) Pos))) (dbWrE...
; # (Db: fd)
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (i64 Siz)
  %6 = sext i32 %2 to i64
; # (pwrite (Db: fd) Buf (i64 Siz) Pos)
  %7 = call i64 @pwrite(i32 %5, i8* %1, i64 %6, i64 %0)
; # (i32 (pwrite (Db: fd) Buf (i64 Siz) Pos))
  %8 = trunc i64 %7 to i32
; # (== Siz (i32 (pwrite (Db: fd) Buf (i64 Siz) Pos)))
  %9 = icmp eq i32 %2, %8
  br i1 %9, label %$3, label %$2
$2:
; # (dbWrErr)
  call void @dbWrErr()
  unreachable
$3:
; # (let Jnl (val $DbJnl) (when Jnl (putc_unlocked (if (== Siz (Db: s...
; # (val $DbJnl)
  %10 = load i8*, i8** @$DbJnl
; # (when Jnl (putc_unlocked (if (== Siz (Db: siz)) 0 Siz) Jnl) (let ...
  %11 = icmp ne i8* %10, null
  br i1 %11, label %$4, label %$5
$4:
; # (if (== Siz (Db: siz)) 0 Siz)
; # (Db: siz)
  %12 = getelementptr i8, i8* %3, i32 12
  %13 = bitcast i8* %12 to i32*
  %14 = load i32, i32* %13
; # (== Siz (Db: siz))
  %15 = icmp eq i32 %2, %14
  br i1 %15, label %$6, label %$7
$6:
  br label %$8
$7:
  br label %$8
$8:
  %16 = phi i32 [0, %$6], [%2, %$7] ; # ->
; # (putc_unlocked (if (== Siz (Db: siz)) 0 Siz) Jnl)
  %17 = call i32 @putc_unlocked(i32 %16, i8* %10)
; # (let P (b8 (+ BLK 2)) (set P (i8 (Db: db))) (set 2 P (i8 (shr (Db...
; # (+ BLK 2)
; # (b8 (+ BLK 2))
  %18 = alloca i8, i64 8
; # (set P (i8 (Db: db)))
; # (Db: db)
  %19 = getelementptr i8, i8* %3, i32 4
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* %20
; # (i8 (Db: db))
  %22 = trunc i32 %21 to i8
  store i8 %22, i8* %18
; # (set 2 P (i8 (shr (Db: db) 8)))
; # (Db: db)
  %23 = getelementptr i8, i8* %3, i32 4
  %24 = bitcast i8* %23 to i32*
  %25 = load i32, i32* %24
; # (shr (Db: db) 8)
  %26 = lshr i32 %25, 8
; # (i8 (shr (Db: db) 8))
  %27 = trunc i32 %26 to i8
  %28 = getelementptr i8, i8* %18, i32 1
  store i8 %27, i8* %28
; # (Db: sh)
  %29 = getelementptr i8, i8* %3, i32 8
  %30 = bitcast i8* %29 to i32*
  %31 = load i32, i32* %30
; # (i64 (Db: sh))
  %32 = sext i32 %31 to i64
; # (shr Pos (i64 (Db: sh)))
  %33 = lshr i64 %0, %32
; # (ofs P 2)
  %34 = getelementptr i8, i8* %18, i32 2
; # (setAdr (shr Pos (i64 (Db: sh))) (ofs P 2))
  call void @setAdr(i64 %33, i8* %34)
; # (unless (and (== 1 (fwrite P (+ BLK 2) 1 Jnl)) (== 1 (fwrite Buf ...
; # (and (== 1 (fwrite P (+ BLK 2) 1 Jnl)) (== 1 (fwrite Buf Siz 1 Jn...
; # (+ BLK 2)
; # (fwrite P (+ BLK 2) 1 Jnl)
  %35 = call i32 @fwrite(i8* %18, i32 8, i32 1, i8* %10)
; # (== 1 (fwrite P (+ BLK 2) 1 Jnl))
  %36 = icmp eq i32 1, %35
  br i1 %36, label %$10, label %$9
$10:
; # (fwrite Buf Siz 1 Jnl)
  %37 = call i32 @fwrite(i8* %1, i32 %2, i32 1, i8* %10)
; # (== 1 (fwrite Buf Siz 1 Jnl))
  %38 = icmp eq i32 1, %37
  br label %$9
$9:
  %39 = phi i1 [0, %$8], [%38, %$10] ; # ->
  br i1 %39, label %$12, label %$11
$11:
; # (strErrno)
  %40 = call i8* @strErrno()
; # (err 0 0 ($ "Journal write: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([18 x i8]* @$50 to i8*), i8* %40)
  unreachable
$12:
  br label %$5
$5:
  ret void
}

define void @wrBlock() {
$1:
; # (let Db: (dbFile (val $DbFile)) (blkPoke (shl (val $BlkIndex) (i6...
; # (val $DbFile)
  %0 = load i8*, i8** @$DbFile
; # (val $BlkIndex)
  %1 = load i64, i64* @$BlkIndex
; # (Db: sh)
  %2 = getelementptr i8, i8* %0, i32 8
  %3 = bitcast i8* %2 to i32*
  %4 = load i32, i32* %3
; # (i64 (Db: sh))
  %5 = sext i32 %4 to i64
; # (shl (val $BlkIndex) (i64 (Db: sh)))
  %6 = shl i64 %1, %5
; # (val $DbBlock)
  %7 = load i8*, i8** @$DbBlock
; # (Db: siz)
  %8 = getelementptr i8, i8* %0, i32 12
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (blkPoke (shl (val $BlkIndex) (i64 (Db: sh))) (val $DbBlock) (Db:...
  call void @blkPoke(i64 %6, i8* %7, i32 %10)
  ret void
}

define void @logBlock() {
$1:
; # (let (Db: (dbFile (val $DbFile)) Log (val $DbLog) P (b8 (+ BLK 2)...
; # (val $DbFile)
  %0 = load i8*, i8** @$DbFile
; # (val $DbLog)
  %1 = load i8*, i8** @$DbLog
; # (+ BLK 2)
; # (b8 (+ BLK 2))
  %2 = alloca i8, i64 8
; # (set P (i8 (Db: db)))
; # (Db: db)
  %3 = getelementptr i8, i8* %0, i32 4
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (i8 (Db: db))
  %6 = trunc i32 %5 to i8
  store i8 %6, i8* %2
; # (set 2 P (i8 (shr (Db: db) 8)))
; # (Db: db)
  %7 = getelementptr i8, i8* %0, i32 4
  %8 = bitcast i8* %7 to i32*
  %9 = load i32, i32* %8
; # (shr (Db: db) 8)
  %10 = lshr i32 %9, 8
; # (i8 (shr (Db: db) 8))
  %11 = trunc i32 %10 to i8
  %12 = getelementptr i8, i8* %2, i32 1
  store i8 %11, i8* %12
; # (val $BlkIndex)
  %13 = load i64, i64* @$BlkIndex
; # (ofs P 2)
  %14 = getelementptr i8, i8* %2, i32 2
; # (setAdr (val $BlkIndex) (ofs P 2))
  call void @setAdr(i64 %13, i8* %14)
; # (unless (and (== 1 (fwrite P (+ BLK 2) 1 Log)) (== 1 (fwrite (val...
; # (and (== 1 (fwrite P (+ BLK 2) 1 Log)) (== 1 (fwrite (val $DbBloc...
; # (+ BLK 2)
; # (fwrite P (+ BLK 2) 1 Log)
  %15 = call i32 @fwrite(i8* %2, i32 8, i32 1, i8* %1)
; # (== 1 (fwrite P (+ BLK 2) 1 Log))
  %16 = icmp eq i32 1, %15
  br i1 %16, label %$3, label %$2
$3:
; # (val $DbBlock)
  %17 = load i8*, i8** @$DbBlock
; # (Db: siz)
  %18 = getelementptr i8, i8* %0, i32 12
  %19 = bitcast i8* %18 to i32*
  %20 = load i32, i32* %19
; # (fwrite (val $DbBlock) (Db: siz) 1 Log)
  %21 = call i32 @fwrite(i8* %17, i32 %20, i32 1, i8* %1)
; # (== 1 (fwrite (val $DbBlock) (Db: siz) 1 Log))
  %22 = icmp eq i32 1, %21
  br label %$2
$2:
  %23 = phi i1 [0, %$1], [%22, %$3] ; # ->
  br i1 %23, label %$5, label %$4
$4:
; # (strErrno)
  %24 = call i8* @strErrno()
; # (err 0 0 ($ "Log write: %s") (strErrno))
  call void @err(i64 0, i64 0, i8* bitcast ([14 x i8]* @$51 to i8*), i8* %24)
  unreachable
$5:
  ret void
}

define i64 @newBlock() {
$1:
; # (let (Db: (dbFile (val $DbFile)) Siz (Db: siz) P (b8 (i64 Siz))) ...
; # (val $DbFile)
  %0 = load i8*, i8** @$DbFile
; # (Db: siz)
  %1 = getelementptr i8, i8* %0, i32 12
  %2 = bitcast i8* %1 to i32*
  %3 = load i32, i32* %2
; # (i64 Siz)
  %4 = sext i32 %3 to i64
; # (b8 (i64 Siz))
  %5 = alloca i8, i64 %4
; # (* 2 BLK)
; # (blkPeek 0 P (* 2 BLK))
  call void @blkPeek(i64 0, i8* %5, i32 12)
; # (let N (getAdr P) (cond ((and N (Db: flu)) (blkPeek (shl N (i64 (...
; # (getAdr P)
  %6 = call i64 @getAdr(i8* %5)
; # (cond ((and N (Db: flu)) (blkPeek (shl N (i64 (Db: sh))) P BLK) (...
; # (and N (Db: flu))
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  %8 = phi i64 [%6, %$1] ; # N
; # (Db: flu)
  %9 = getelementptr i8, i8* %0, i32 32
  %10 = bitcast i8* %9 to i64*
  %11 = load i64, i64* %10
  %12 = icmp ne i64 %11, 0
  br label %$3
$3:
  %13 = phi i64 [%6, %$1], [%8, %$4] ; # N
  %14 = phi i1 [0, %$1], [%12, %$4] ; # ->
  br i1 %14, label %$6, label %$5
$6:
  %15 = phi i64 [%13, %$3] ; # N
; # (Db: sh)
  %16 = getelementptr i8, i8* %0, i32 8
  %17 = bitcast i8* %16 to i32*
  %18 = load i32, i32* %17
; # (i64 (Db: sh))
  %19 = sext i32 %18 to i64
; # (shl N (i64 (Db: sh)))
  %20 = shl i64 %15, %19
; # (blkPeek (shl N (i64 (Db: sh))) P BLK)
  call void @blkPeek(i64 %20, i8* %5, i32 6)
; # (Db: flu (dec (Db: flu)))
  %21 = getelementptr i8, i8* %0, i32 32
  %22 = bitcast i8* %21 to i64*
  %23 = getelementptr i8, i8* %0, i32 32
  %24 = bitcast i8* %23 to i64*
  %25 = load i64, i64* %24
  %26 = sub i64 %25, 1
  store i64 %26, i64* %22
  br label %$2
$5:
  %27 = phi i64 [%13, %$3] ; # N
; # (ofs P BLK)
  %28 = getelementptr i8, i8* %5, i32 6
; # (getAdr (ofs P BLK))
  %29 = call i64 @getAdr(i8* %28)
; # (== (setq N (getAdr (ofs P BLK))) (hex "FFFFFFFFFFC0"))
  %30 = icmp eq i64 %29, 281474976710592
  br i1 %30, label %$8, label %$7
$8:
  %31 = phi i64 [%29, %$5] ; # N
; # (err 0 0 ($ "DB Oversize") null)
  call void @err(i64 0, i64 0, i8* bitcast ([12 x i8]* @$52 to i8*), i8* null)
  unreachable
$7:
  %32 = phi i64 [%29, %$5] ; # N
; # (+ N BLKSIZE)
  %33 = add i64 %32, 64
; # (ofs P BLK)
  %34 = getelementptr i8, i8* %5, i32 6
; # (setAdr (+ N BLKSIZE) (ofs P BLK))
  call void @setAdr(i64 %33, i8* %34)
  br label %$2
$2:
  %35 = phi i64 [%15, %$6], [%32, %$7] ; # N
; # (* 2 BLK)
; # (blkPoke 0 P (* 2 BLK))
  call void @blkPoke(i64 0, i8* %5, i32 12)
; # (i64 Siz)
  %36 = sext i32 %3 to i64
; # (memset P 0 (i64 Siz))
  call void @llvm.memset.p0i8.p0i8.i64(i8* %5, i8 0, i64 %36, i1 0)
; # (Db: sh)
  %37 = getelementptr i8, i8* %0, i32 8
  %38 = bitcast i8* %37 to i32*
  %39 = load i32, i32* %38
; # (i64 (Db: sh))
  %40 = sext i32 %39 to i64
; # (shl N (i64 (Db: sh)))
  %41 = shl i64 %35, %40
; # (blkPoke (shl N (i64 (Db: sh))) P Siz)
  call void @blkPoke(i64 %41, i8* %5, i32 %3)
  ret i64 %35
}

define i64 @newId(i64, i32) {
$1:
; # (when (>= (dec 'N) (val $DBs)) (dbfErr Exe))
; # (dec 'N)
  %2 = sub i32 %1, 1
; # (val $DBs)
  %3 = load i32, i32* @$DBs
; # (>= (dec 'N) (val $DBs))
  %4 = icmp sge i32 %2, %3
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i32 [%2, %$1] ; # N
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$3:
  %6 = phi i32 [%2, %$1] ; # N
; # (set $DbFile (ofs (val $DbFiles) (* N (dbFile T))))
; # (val $DbFiles)
  %7 = load i8*, i8** @$DbFiles
; # (* N (dbFile T))
  %8 = mul i32 %6, 42
; # (ofs (val $DbFiles) (* N (dbFile T)))
  %9 = getelementptr i8, i8* %7, i32 %8
  store i8* %9, i8** @$DbFile
; # (unless (val $DbLog) (set $Protect (inc (val $Protect))))
; # (val $DbLog)
  %10 = load i8*, i8** @$DbLog
  %11 = icmp ne i8* %10, null
  br i1 %11, label %$5, label %$4
$4:
  %12 = phi i32 [%6, %$3] ; # N
; # (set $Protect (inc (val $Protect)))
; # (val $Protect)
  %13 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (inc (val $Protect))
  %14 = add i32 %13, 1
  store i32 %14, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  br label %$5
$5:
  %15 = phi i32 [%6, %$3], [%12, %$4] ; # N
; # (wrLockDb)
  call void @wrLockDb()
; # (when (val $DbJnl) (lockJnl))
; # (val $DbJnl)
  %16 = load i8*, i8** @$DbJnl
  %17 = icmp ne i8* %16, null
  br i1 %17, label %$6, label %$7
$6:
  %18 = phi i32 [%15, %$5] ; # N
; # (lockJnl)
  call void @lockJnl()
  br label %$7
$7:
  %19 = phi i32 [%15, %$5], [%18, %$6] ; # N
; # (prog1 (extNm ((dbFile (val $DbFile)) db) (newBlock)) (when (val ...
; # (val $DbFile)
  %20 = load i8*, i8** @$DbFile
; # ((dbFile (val $DbFile)) db)
  %21 = getelementptr i8, i8* %20, i32 4
  %22 = bitcast i8* %21 to i32*
  %23 = load i32, i32* %22
; # (newBlock)
  %24 = call i64 @newBlock()
; # (extNm ((dbFile (val $DbFile)) db) (newBlock))
  %25 = call i64 @extNm(i32 %23, i64 %24)
; # (when (val $DbJnl) (unLockJnl))
; # (val $DbJnl)
  %26 = load i8*, i8** @$DbJnl
  %27 = icmp ne i8* %26, null
  br i1 %27, label %$8, label %$9
$8:
  %28 = phi i32 [%19, %$7] ; # N
; # (unLockJnl)
  call void @unLockJnl()
  br label %$9
$9:
  %29 = phi i32 [%19, %$7], [%28, %$8] ; # N
; # (unLockDb 1)
  call void @unLockDb(i64 1)
; # (unless (val $DbLog) (set $Protect (dec (val $Protect))))
; # (val $DbLog)
  %30 = load i8*, i8** @$DbLog
  %31 = icmp ne i8* %30, null
  br i1 %31, label %$11, label %$10
$10:
  %32 = phi i32 [%29, %$9] ; # N
; # (set $Protect (dec (val $Protect)))
; # (val $Protect)
  %33 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (dec (val $Protect))
  %34 = sub i32 %33, 1
  store i32 %34, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  br label %$11
$11:
  %35 = phi i32 [%29, %$9], [%32, %$10] ; # N
  ret i64 %25
}

define i1 @isLife(i64) {
$1:
; # (let (Nm (name (& (val (tail Sym)) -9)) N (objId Nm)) (when N (co...
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (& (val (tail Sym)) -9)
  %4 = and i64 %3, -9
; # (name (& (val (tail Sym)) -9))
  br label %$2
$2:
  %5 = phi i64 [%4, %$1], [%11, %$3] ; # Tail
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$3:
  %8 = phi i64 [%5, %$2] ; # Tail
  %9 = inttoptr i64 %8 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
  br label %$2
$4:
  %12 = phi i64 [%5, %$2] ; # Tail
; # (objId Nm)
  %13 = call i64 @objId(i64 %12)
; # (when N (cond ((> (val $DBs) (objFile Nm)) (setq Nm (add Nm Nm)) ...
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$5, label %$6
$5:
  %15 = phi i64 [%12, %$4] ; # Nm
; # (cond ((> (val $DBs) (objFile Nm)) (setq Nm (add Nm Nm)) (when @@...
; # (val $DBs)
  %16 = load i32, i32* @$DBs
; # (objFile Nm)
  %17 = call i32 @objFile(i64 %15)
; # (> (val $DBs) (objFile Nm))
  %18 = icmp sgt i32 %16, %17
  br i1 %18, label %$9, label %$8
$9:
  %19 = phi i64 [%15, %$5] ; # Nm
; # (add Nm Nm)
  %20 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %19, i64 %19)
  %21 = extractvalue {i64, i1} %20, 1
  %22 = extractvalue {i64, i1} %20, 0
; # (when @@ (ret YES))
  br i1 %21, label %$10, label %$11
$10:
  %23 = phi i64 [%22, %$9] ; # Nm
; # (ret YES)
  ret i1 1
$11:
  %24 = phi i64 [%22, %$9] ; # Nm
; # (add Nm Nm)
  %25 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %24, i64 %24)
  %26 = extractvalue {i64, i1} %25, 1
  %27 = extractvalue {i64, i1} %25, 0
; # (when @@ (ret YES))
  br i1 %26, label %$12, label %$13
$12:
  %28 = phi i64 [%24, %$11] ; # Nm
; # (ret YES)
  ret i1 1
$13:
  %29 = phi i64 [%24, %$11] ; # Nm
; # (let (Db: (dbFile (set $DbFile (ofs (val $DbFiles) (* N (dbFile T...
; # (set $DbFile (ofs (val $DbFiles) (* N (dbFile T))))
; # (val $DbFiles)
  %30 = load i8*, i8** @$DbFiles
; # (* N (dbFile T))
  %31 = mul i64 %13, 42
; # (ofs (val $DbFiles) (* N (dbFile T)))
  %32 = getelementptr i8, i8* %30, i64 %31
  store i8* %32, i8** @$DbFile
; # (* BLK 2)
; # (b8 (* BLK 2))
  %33 = alloca i8, i64 12
; # (blkPeek BLK P BLK)
  call void @blkPeek(i64 6, i8* %33, i32 6)
; # (when (> (getAdr P) N) (blkPeek (shl N (i64 (Db: sh))) P BLK) (wh...
; # (getAdr P)
  %34 = call i64 @getAdr(i8* %33)
; # (> (getAdr P) N)
  %35 = icmp ugt i64 %34, %13
  br i1 %35, label %$14, label %$15
$14:
  %36 = phi i64 [%29, %$13] ; # Nm
; # (Db: sh)
  %37 = getelementptr i8, i8* %32, i32 8
  %38 = bitcast i8* %37 to i32*
  %39 = load i32, i32* %38
; # (i64 (Db: sh))
  %40 = sext i32 %39 to i64
; # (shl N (i64 (Db: sh)))
  %41 = shl i64 %13, %40
; # (blkPeek (shl N (i64 (Db: sh))) P BLK)
  call void @blkPeek(i64 %41, i8* %33, i32 6)
; # (when (== 1 (& (val P) BLKTAG)) (ret YES))
; # (val P)
  %42 = load i8, i8* %33
; # (& (val P) BLKTAG)
  %43 = and i8 %42, 63
; # (== 1 (& (val P) BLKTAG))
  %44 = icmp eq i8 1, %43
  br i1 %44, label %$16, label %$17
$16:
  %45 = phi i64 [%36, %$14] ; # Nm
; # (ret YES)
  ret i1 1
$17:
  %46 = phi i64 [%36, %$14] ; # Nm
  br label %$15
$15:
  %47 = phi i64 [%29, %$13], [%46, %$17] ; # Nm
  br label %$7
$8:
  %48 = phi i64 [%15, %$5] ; # Nm
; # (val $Ext)
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 504) to i64) to i64*
  %50 = load i64, i64* %49
; # (pair (val $Ext))
  %51 = and i64 %50, 15
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %$19, label %$18
$19:
  %53 = phi i64 [%48, %$8] ; # Nm
; # (ret YES)
  ret i1 1
$18:
  %54 = phi i64 [%48, %$8] ; # Nm
  br label %$7
$7:
  %55 = phi i64 [%47, %$15], [%54, %$18] ; # Nm
  br label %$6
$6:
  %56 = phi i64 [%12, %$4], [%55, %$7] ; # Nm
  ret i1 0
}

define i64 @_extQ(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (and (symb? X) (sym? (val (tail X)))...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (and (symb? X) (sym? (val (tail X))) (isLife X)) X $Nil)
; # (and (symb? X) (sym? (val (tail X))) (isLife X))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (tail X)
  %17 = add i64 %13, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$7
$9:
; # (isLife X)
  %22 = call i1 @isLife(i64 %13)
  br label %$7
$7:
  %23 = phi i1 [0, %$2], [0, %$8], [%22, %$9] ; # ->
  br i1 %23, label %$10, label %$11
$10:
  br label %$12
$11:
  br label %$12
$12:
  %24 = phi i64 [%13, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  ret i64 %24
}

define void @cleanUp(i64) {
$1:
; # (let (P (b8 BLK) Db: (dbFile (val $DbFile))) (blkPeek 0 P BLK) (l...
; # (b8 BLK)
  %1 = alloca i8, i64 6
; # (val $DbFile)
  %2 = load i8*, i8** @$DbFile
; # (blkPeek 0 P BLK)
  call void @blkPeek(i64 0, i8* %1, i32 6)
; # (let Free (getAdr P) (setAdr N P) (blkPoke 0 P BLK) (loop (let Po...
; # (getAdr P)
  %3 = call i64 @getAdr(i8* %1)
; # (setAdr N P)
  call void @setAdr(i64 %0, i8* %1)
; # (blkPoke 0 P BLK)
  call void @blkPoke(i64 0, i8* %1, i32 6)
; # (loop (let Pos (shl N (i64 (Db: sh))) (blkPeek Pos P BLK) (set P ...
  br label %$2
$2:
  %4 = phi i64 [%0, %$1], [%15, %$3] ; # N
; # (let Pos (shl N (i64 (Db: sh))) (blkPeek Pos P BLK) (set P (& (va...
; # (Db: sh)
  %5 = getelementptr i8, i8* %2, i32 8
  %6 = bitcast i8* %5 to i32*
  %7 = load i32, i32* %6
; # (i64 (Db: sh))
  %8 = sext i32 %7 to i64
; # (shl N (i64 (Db: sh)))
  %9 = shl i64 %4, %8
; # (blkPeek Pos P BLK)
  call void @blkPeek(i64 %9, i8* %1, i32 6)
; # (set P (& (val P) BLKMASK))
; # (val P)
  %10 = load i8, i8* %1
; # (& (val P) BLKMASK)
  %11 = and i8 %10, -64
  store i8 %11, i8* %1
; # (? (=0 (setq N (getAdr P))) (setAdr Free P) (blkPoke Pos P BLK))
; # (getAdr P)
  %12 = call i64 @getAdr(i8* %1)
; # (=0 (setq N (getAdr P)))
  %13 = icmp eq i64 %12, 0
  br i1 %13, label %$5, label %$3
$5:
  %14 = phi i64 [%12, %$2] ; # N
; # (setAdr Free P)
  call void @setAdr(i64 %3, i8* %1)
; # (blkPoke Pos P BLK)
  call void @blkPoke(i64 %9, i8* %1, i32 6)
  br label %$4
$3:
  %15 = phi i64 [%12, %$2] ; # N
; # (blkPoke Pos P BLK)
  call void @blkPoke(i64 %9, i8* %1, i32 6)
  br label %$2
$4:
  %16 = phi i64 [%14, %$5] ; # N
  ret void
}

define i32 @getBlock() {
$1:
; # (let P (val $BlkPtr) (when (== P (val $BlkEnd)) (unless (val $Blk...
; # (val $BlkPtr)
  %0 = load i8*, i8** @$BlkPtr
; # (when (== P (val $BlkEnd)) (unless (val $BlkLink) (ret 0)) (setq ...
; # (val $BlkEnd)
  %1 = load i8*, i8** @$BlkEnd
; # (== P (val $BlkEnd))
  %2 = icmp eq i8* %0, %1
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i8* [%0, %$1] ; # P
; # (unless (val $BlkLink) (ret 0))
; # (val $BlkLink)
  %4 = load i64, i64* @$BlkLink
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$5, label %$4
$4:
  %6 = phi i8* [%3, %$2] ; # P
; # (ret 0)
  ret i32 0
$5:
  %7 = phi i8* [%3, %$2] ; # P
; # (rdBlock @)
  %8 = call i8* @rdBlock(i64 %4)
  br label %$3
$3:
  %9 = phi i8* [%0, %$1], [%8, %$5] ; # P
; # (set $BlkPtr (inc P))
; # (inc P)
  %10 = getelementptr i8, i8* %9, i32 1
  store i8* %10, i8** @$BlkPtr
; # (val P)
  %11 = load i8, i8* %9
; # (i32 (val P))
  %12 = zext i8 %11 to i32
  ret i32 %12
}

define void @putBlock(i8) {
$1:
; # (let P (val $BlkPtr) (when (== P (val $BlkEnd)) (let Link (val $B...
; # (val $BlkPtr)
  %1 = load i8*, i8** @$BlkPtr
; # (when (== P (val $BlkEnd)) (let Link (val $BlkLink) (ifn Link (le...
; # (val $BlkEnd)
  %2 = load i8*, i8** @$BlkEnd
; # (== P (val $BlkEnd))
  %3 = icmp eq i8* %1, %2
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i8* [%1, %$1] ; # P
; # (let Link (val $BlkLink) (ifn Link (let (New (newBlock) Cnt (i64 ...
; # (val $BlkLink)
  %5 = load i64, i64* @$BlkLink
; # (ifn Link (let (New (newBlock) Cnt (i64 (val P))) (setAdr (| New ...
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$4
$4:
  %7 = phi i8* [%4, %$2] ; # P
; # (let (New (newBlock) Cnt (i64 (val P))) (setAdr (| New Cnt) (val ...
; # (newBlock)
  %8 = call i64 @newBlock()
; # (val P)
  %9 = load i8, i8* %7
; # (i64 (val P))
  %10 = zext i8 %9 to i64
; # (| New Cnt)
  %11 = or i64 %8, %10
; # (val $DbBlock)
  %12 = load i8*, i8** @$DbBlock
; # (setAdr (| New Cnt) (val $DbBlock))
  call void @setAdr(i64 %11, i8* %12)
; # (wrBlock)
  call void @wrBlock()
; # (set $BlkIndex New)
  store i64 %8, i64* @$BlkIndex
; # (if (== Cnt BLKTAG) Cnt (inc Cnt))
; # (== Cnt BLKTAG)
  %13 = icmp eq i64 %10, 63
  br i1 %13, label %$7, label %$8
$7:
  %14 = phi i8* [%7, %$4] ; # P
  br label %$9
$8:
  %15 = phi i8* [%7, %$4] ; # P
; # (inc Cnt)
  %16 = add i64 %10, 1
  br label %$9
$9:
  %17 = phi i8* [%14, %$7], [%15, %$8] ; # P
  %18 = phi i64 [%10, %$7], [%16, %$8] ; # ->
; # (val $DbBlock)
  %19 = load i8*, i8** @$DbBlock
; # (setAdr (if (== Cnt BLKTAG) Cnt (inc Cnt)) (setq P (val $DbBlock)...
  call void @setAdr(i64 %18, i8* %19)
; # (ofs P BLK)
  %20 = getelementptr i8, i8* %19, i32 6
  br label %$6
$5:
  %21 = phi i8* [%4, %$2] ; # P
; # (wrBlock)
  call void @wrBlock()
; # (rdBlock Link)
  %22 = call i8* @rdBlock(i64 %5)
  br label %$6
$6:
  %23 = phi i8* [%20, %$9], [%22, %$5] ; # P
  %24 = phi i8* [%20, %$9], [%22, %$5] ; # ->
  br label %$3
$3:
  %25 = phi i8* [%1, %$1], [%23, %$6] ; # P
; # (set P B)
  store i8 %0, i8* %25
; # (set $BlkPtr (inc P))
; # (inc P)
  %26 = getelementptr i8, i8* %25, i32 1
  store i8* %26, i8** @$BlkPtr
  ret void
}

define i64 @_rollback(i64) {
$1:
; # (if (and (=0 (val $DBs)) (atom (val $Ext))) $Nil (let (Tos 0 P (v...
; # (and (=0 (val $DBs)) (atom (val $Ext)))
; # (val $DBs)
  %1 = load i32, i32* @$DBs
; # (=0 (val $DBs))
  %2 = icmp eq i32 %1, 0
  br i1 %2, label %$3, label %$2
$3:
; # (val $Ext)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 504) to i64) to i64*
  %4 = load i64, i64* %3
; # (atom (val $Ext))
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br label %$2
$2:
  %7 = phi i1 [0, %$1], [%6, %$3] ; # ->
  br i1 %7, label %$4, label %$5
$4:
  br label %$6
$5:
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (cdr P) (? (atom ...
; # (val $Extern)
  %8 = load i64, i64* @$Extern
; # (loop (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @)...
  br label %$7
$7:
  %9 = phi i64 [0, %$5], [%109, %$18] ; # Tos
  %10 = phi i64 [%8, %$5], [%110, %$18] ; # P
; # (loop (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set ...
  br label %$8
$8:
  %11 = phi i64 [%9, %$7], [%22, %$9] ; # Tos
  %12 = phi i64 [%10, %$7], [%18, %$9] ; # P
; # (let X (cdr P) (? (atom (cdr X))) (let Y P (setq P @) (set 2 X To...
; # (cdr P)
  %13 = inttoptr i64 %12 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (? (atom (cdr X)))
; # (cdr X)
  %16 = inttoptr i64 %15 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (atom (cdr X))
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$9
$9:
  %21 = phi i64 [%11, %$8] ; # Tos
  %22 = phi i64 [%12, %$8] ; # P
; # (let Y P (setq P @) (set 2 X Tos) (setq Tos Y))
; # (set 2 X Tos)
  %23 = inttoptr i64 %15 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %21, i64* %24
  br label %$8
$10:
  %25 = phi i64 [%11, %$8] ; # Tos
  %26 = phi i64 [%12, %$8] ; # P
  %27 = phi i64 [0, %$8] ; # ->
; # (loop (let (S (val P) Tail (val (tail S))) (unless (num? Tail) (s...
  br label %$11
$11:
  %28 = phi i64 [%25, %$10], [%106, %$24] ; # Tos
  %29 = phi i64 [%26, %$10], [%107, %$24] ; # P
; # (let (S (val P) Tail (val (tail S))) (unless (num? Tail) (setq Ta...
; # (val P)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (tail S)
  %32 = add i64 %31, -8
; # (val (tail S))
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (unless (num? Tail) (setq Tail (& Tail -9)) (loop (? (num? (shift...
; # (num? Tail)
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$12:
  %37 = phi i64 [%28, %$11] ; # Tos
  %38 = phi i64 [%29, %$11] ; # P
  %39 = phi i64 [%34, %$11] ; # Tail
; # (& Tail -9)
  %40 = and i64 %39, -9
; # (loop (? (num? (shift Tail))))
  br label %$14
$14:
  %41 = phi i64 [%37, %$12], [%49, %$15] ; # Tos
  %42 = phi i64 [%38, %$12], [%50, %$15] ; # P
  %43 = phi i64 [%40, %$12], [%51, %$15] ; # Tail
; # (? (num? (shift Tail)))
; # (shift Tail)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (num? (shift Tail))
  %47 = and i64 %46, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$16, label %$15
$15:
  %49 = phi i64 [%41, %$14] ; # Tos
  %50 = phi i64 [%42, %$14] ; # P
  %51 = phi i64 [%46, %$14] ; # Tail
  br label %$14
$16:
  %52 = phi i64 [%41, %$14] ; # Tos
  %53 = phi i64 [%42, %$14] ; # P
  %54 = phi i64 [%46, %$14] ; # Tail
  %55 = phi i64 [0, %$14] ; # ->
; # (sym Tail)
  %56 = or i64 %54, 8
  br label %$13
$13:
  %57 = phi i64 [%28, %$11], [%52, %$16] ; # Tos
  %58 = phi i64 [%29, %$11], [%53, %$16] ; # P
  %59 = phi i64 [%34, %$11], [%56, %$16] ; # Tail
; # (set (tail S) (shr (shl Tail 2) 2))
; # (tail S)
  %60 = add i64 %31, -8
; # (shl Tail 2)
  %61 = shl i64 %59, 2
; # (shr (shl Tail 2) 2)
  %62 = lshr i64 %61, 2
  %63 = inttoptr i64 %60 to i64*
  store i64 %62, i64* %63
; # (set S $Nil)
  %64 = inttoptr i64 %31 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %64
; # (let X (cdr P) (? (pair (car X)) (let Y P (setq P @) (set X Tos) ...
; # (cdr P)
  %65 = inttoptr i64 %58 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (? (pair (car X)) (let Y P (setq P @) (set X Tos) (setq Tos (| Y ...
; # (car X)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (pair (car X))
  %70 = and i64 %69, 15
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %$19, label %$17
$19:
  %72 = phi i64 [%57, %$13] ; # Tos
  %73 = phi i64 [%58, %$13] ; # P
; # (let Y P (setq P @) (set X Tos) (setq Tos (| Y 8)))
; # (set X Tos)
  %74 = inttoptr i64 %67 to i64*
  store i64 %72, i64* %74
; # (| Y 8)
  %75 = or i64 %73, 8
  br label %$18
$17:
  %76 = phi i64 [%57, %$13] ; # Tos
  %77 = phi i64 [%58, %$13] ; # P
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$20
$20:
  %78 = phi i64 [%76, %$17], [%104, %$23] ; # Tos
  %79 = phi i64 [%77, %$17], [%99, %$23] ; # P
; # (unless Tos (goto 1))
  %80 = icmp ne i64 %78, 0
  br i1 %80, label %$22, label %$21
$21:
  %81 = phi i64 [%78, %$20] ; # Tos
  %82 = phi i64 [%79, %$20] ; # P
; # (goto 1)
  br label %$-1
$22:
  %83 = phi i64 [%78, %$20] ; # Tos
  %84 = phi i64 [%79, %$20] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set ...
; # (& Tos 8)
  %85 = and i64 %83, 8
; # (=0 (& Tos 8))
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$25, label %$23
$25:
  %87 = phi i64 [%83, %$22] ; # Tos
  %88 = phi i64 [%84, %$22] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %89 = inttoptr i64 %87 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  %91 = load i64, i64* %90
; # (cdr Y)
  %92 = inttoptr i64 %91 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
; # (set 2 Y P)
  %95 = inttoptr i64 %91 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %88, i64* %96
  br label %$24
$23:
  %97 = phi i64 [%83, %$22] ; # Tos
  %98 = phi i64 [%84, %$22] ; # P
; # (& Tos -9)
  %99 = and i64 %97, -9
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %100 = inttoptr i64 %99 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
; # (car Y)
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
; # (set Y P)
  %105 = inttoptr i64 %102 to i64*
  store i64 %98, i64* %105
  br label %$20
$24:
  %106 = phi i64 [%94, %$25] ; # Tos
  %107 = phi i64 [%87, %$25] ; # P
  %108 = phi i64 [%87, %$25] ; # ->
  br label %$11
$18:
  %109 = phi i64 [%75, %$19] ; # Tos
  %110 = phi i64 [%69, %$19] ; # P
  %111 = phi i64 [%75, %$19] ; # ->
  br label %$7
$26:
; # (: 1 (when (pair (val $Zap)) (set @ $Nil)))
  br label %$-1
$-1:
; # (when (pair (val $Zap)) (set @ $Nil))
; # (val $Zap)
  %112 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %113 = load i64, i64* %112
; # (pair (val $Zap))
  %114 = and i64 %113, 15
  %115 = icmp eq i64 %114, 0
  br i1 %115, label %$27, label %$28
$27:
; # (set @ $Nil)
  %116 = inttoptr i64 %113 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %116
  br label %$28
$28:
; # (when (val $DBs) (unLockDb 0))
; # (val $DBs)
  %117 = load i32, i32* @$DBs
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %$29, label %$30
$29:
; # (unLockDb 0)
  call void @unLockDb(i64 0)
  br label %$30
$30:
; # (unsync)
  call void @unsync()
  br label %$6
$6:
  %119 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$30] ; # ->
  ret i64 %119
}

define i64 @_extern(i64) {
$1:
; # (let (Sym (needSymb Exe (eval (cadr Exe))) Nm (name (& (val (tail...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needSymb Exe (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %13)
  unreachable
$8:
; # (tail Sym)
  %17 = add i64 %13, -8
; # (val (tail Sym))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (& (val (tail Sym)) -9)
  %20 = and i64 %19, -9
; # (name (& (val (tail Sym)) -9))
  br label %$9
$9:
  %21 = phi i64 [%20, %$8], [%27, %$10] ; # Tail
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$10:
  %24 = phi i64 [%21, %$9] ; # Tail
  %25 = inttoptr i64 %24 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
  br label %$9
$11:
  %28 = phi i64 [%21, %$9] ; # Tail
; # (when (== Nm ZERO) (ret $Nil))
; # (== Nm ZERO)
  %29 = icmp eq i64 %28, 2
  br i1 %29, label %$12, label %$13
$12:
  %30 = phi i64 [%13, %$11] ; # Sym
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$13:
  %31 = phi i64 [%13, %$11] ; # Sym
; # (let (P (push 0 Nm) C (symChar P) F (i32 0)) (when (== C (char "{...
; # (push 0 Nm)
  %32 = alloca i64, i64 2, align 16
  store i64 0, i64* %32
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %28, i64* %33
; # (symChar P)
  %34 = call i32 @symChar(i64* %32)
; # (i32 0)
; # (when (== C (char "{")) (setq C (symChar P)))
; # (== C (char "{"))
  %35 = icmp eq i32 %34, 123
  br i1 %35, label %$14, label %$15
$14:
  %36 = phi i64 [%31, %$13] ; # Sym
  %37 = phi i32 [%34, %$13] ; # C
  %38 = phi i32 [0, %$13] ; # F
; # (symChar P)
  %39 = call i32 @symChar(i64* %32)
  br label %$15
$15:
  %40 = phi i64 [%31, %$13], [%36, %$14] ; # Sym
  %41 = phi i32 [%34, %$13], [%39, %$14] ; # C
  %42 = phi i32 [0, %$13], [%38, %$14] ; # F
; # (while (>= C (char "@")) (when (> C (char "O")) (ret $Nil)) (setq...
  br label %$16
$16:
  %43 = phi i64 [%40, %$15], [%54, %$20] ; # Sym
  %44 = phi i32 [%41, %$15], [%60, %$20] ; # C
  %45 = phi i32 [%42, %$15], [%59, %$20] ; # F
; # (>= C (char "@"))
  %46 = icmp sge i32 %44, 64
  br i1 %46, label %$17, label %$18
$17:
  %47 = phi i64 [%43, %$16] ; # Sym
  %48 = phi i32 [%44, %$16] ; # C
  %49 = phi i32 [%45, %$16] ; # F
; # (when (> C (char "O")) (ret $Nil))
; # (> C (char "O"))
  %50 = icmp sgt i32 %48, 79
  br i1 %50, label %$19, label %$20
$19:
  %51 = phi i64 [%47, %$17] ; # Sym
  %52 = phi i32 [%48, %$17] ; # C
  %53 = phi i32 [%49, %$17] ; # F
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$20:
  %54 = phi i64 [%47, %$17] ; # Sym
  %55 = phi i32 [%48, %$17] ; # C
  %56 = phi i32 [%49, %$17] ; # F
; # (shl F 4)
  %57 = shl i32 %56, 4
; # (- C (char "@"))
  %58 = sub i32 %55, 64
; # (| (shl F 4) (- C (char "@")))
  %59 = or i32 %57, %58
; # (symChar P)
  %60 = call i32 @symChar(i64* %32)
  br label %$16
$18:
  %61 = phi i64 [%43, %$16] ; # Sym
  %62 = phi i32 [%44, %$16] ; # C
  %63 = phi i32 [%45, %$16] ; # F
; # (let N 0 (loop (unless (and (>= C (char "0")) (>= (char "7") C)) ...
; # (loop (unless (and (>= C (char "0")) (>= (char "7") C)) (ret $Nil...
  br label %$21
$21:
  %64 = phi i64 [%61, %$18], [%103, %$28] ; # Sym
  %65 = phi i32 [%62, %$18], [%104, %$28] ; # C
  %66 = phi i32 [%63, %$18], [%105, %$28] ; # F
  %67 = phi i64 [0, %$18], [%106, %$28] ; # N
; # (unless (and (>= C (char "0")) (>= (char "7") C)) (ret $Nil))
; # (and (>= C (char "0")) (>= (char "7") C))
; # (>= C (char "0"))
  %68 = icmp sge i32 %65, 48
  br i1 %68, label %$23, label %$22
$23:
  %69 = phi i64 [%64, %$21] ; # Sym
  %70 = phi i32 [%65, %$21] ; # C
  %71 = phi i32 [%66, %$21] ; # F
  %72 = phi i64 [%67, %$21] ; # N
; # (>= (char "7") C)
  %73 = icmp sge i32 55, %70
  br label %$22
$22:
  %74 = phi i64 [%64, %$21], [%69, %$23] ; # Sym
  %75 = phi i32 [%65, %$21], [%70, %$23] ; # C
  %76 = phi i32 [%66, %$21], [%71, %$23] ; # F
  %77 = phi i64 [%67, %$21], [%72, %$23] ; # N
  %78 = phi i1 [0, %$21], [%73, %$23] ; # ->
  br i1 %78, label %$25, label %$24
$24:
  %79 = phi i64 [%74, %$22] ; # Sym
  %80 = phi i32 [%75, %$22] ; # C
  %81 = phi i32 [%76, %$22] ; # F
  %82 = phi i64 [%77, %$22] ; # N
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$25:
  %83 = phi i64 [%74, %$22] ; # Sym
  %84 = phi i32 [%75, %$22] ; # C
  %85 = phi i32 [%76, %$22] ; # F
  %86 = phi i64 [%77, %$22] ; # N
; # (shl N 3)
  %87 = shl i64 %86, 3
; # (- C (char "0"))
  %88 = sub i32 %84, 48
; # (i64 (- C (char "0")))
  %89 = sext i32 %88 to i64
; # (| (shl N 3) (i64 (- C (char "0"))))
  %90 = or i64 %87, %89
; # (? (or (=0 (setq C (symChar P))) (== C (char "}"))))
; # (or (=0 (setq C (symChar P))) (== C (char "}")))
; # (symChar P)
  %91 = call i32 @symChar(i64* %32)
; # (=0 (setq C (symChar P)))
  %92 = icmp eq i32 %91, 0
  br i1 %92, label %$26, label %$27
$27:
  %93 = phi i64 [%83, %$25] ; # Sym
  %94 = phi i32 [%91, %$25] ; # C
  %95 = phi i32 [%85, %$25] ; # F
  %96 = phi i64 [%90, %$25] ; # N
; # (== C (char "}"))
  %97 = icmp eq i32 %94, 125
  br label %$26
$26:
  %98 = phi i64 [%83, %$25], [%93, %$27] ; # Sym
  %99 = phi i32 [%91, %$25], [%94, %$27] ; # C
  %100 = phi i32 [%85, %$25], [%95, %$27] ; # F
  %101 = phi i64 [%90, %$25], [%96, %$27] ; # N
  %102 = phi i1 [1, %$25], [%97, %$27] ; # ->
  br i1 %102, label %$29, label %$28
$28:
  %103 = phi i64 [%98, %$26] ; # Sym
  %104 = phi i32 [%99, %$26] ; # C
  %105 = phi i32 [%100, %$26] ; # F
  %106 = phi i64 [%101, %$26] ; # N
  br label %$21
$29:
  %107 = phi i64 [%98, %$26] ; # Sym
  %108 = phi i32 [%99, %$26] ; # C
  %109 = phi i32 [%100, %$26] ; # F
  %110 = phi i64 [%101, %$26] ; # N
  %111 = phi i64 [0, %$26] ; # ->
; # (if (isLife (setq Sym (extern (extNm F N)))) Sym $Nil)
; # (extNm F N)
  %112 = call i64 @extNm(i32 %109, i64 %110)
; # (extern (extNm F N))
  %113 = call i64 @extern(i64 %112)
; # (isLife (setq Sym (extern (extNm F N))))
  %114 = call i1 @isLife(i64 %113)
  br i1 %114, label %$30, label %$31
$30:
  %115 = phi i64 [%113, %$29] ; # Sym
  %116 = phi i32 [%108, %$29] ; # C
  %117 = phi i32 [%109, %$29] ; # F
  %118 = phi i64 [%110, %$29] ; # N
  br label %$32
$31:
  %119 = phi i64 [%113, %$29] ; # Sym
  %120 = phi i32 [%108, %$29] ; # C
  %121 = phi i32 [%109, %$29] ; # F
  %122 = phi i64 [%110, %$29] ; # N
  br label %$32
$32:
  %123 = phi i64 [%115, %$30], [%119, %$31] ; # Sym
  %124 = phi i32 [%116, %$30], [%120, %$31] ; # C
  %125 = phi i32 [%117, %$30], [%121, %$31] ; # F
  %126 = phi i64 [%118, %$30], [%122, %$31] ; # N
  %127 = phi i64 [%115, %$30], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$31] ; # ->
  ret i64 %127
}

define void @ignLog() {
$1:
; # (stderrMsg ($ "Discarding incomplete transaction^J") null)
  %0 = call i8* @stderrMsg(i8* bitcast ([35 x i8]* @$53 to i8*), i8* null)
  ret void
}

define i1 @transaction() {
$1:
; # (let (Log (val $DbLog) A (b8 BLK)) (fseek0 Log) (if (fread A 2 1 ...
; # (val $DbLog)
  %0 = load i8*, i8** @$DbLog
; # (b8 BLK)
  %1 = alloca i8, i64 6
; # (fseek0 Log)
  %2 = call i1 @fseek0(i8* %0)
; # (if (fread A 2 1 Log) (loop (? (== (val (i16* A)) (hex "FFFF")) Y...
; # (fread A 2 1 Log)
  %3 = call i32 @fread(i8* %1, i32 2, i32 1, i8* %0)
  %4 = icmp ne i32 %3, 0
  br i1 %4, label %$2, label %$3
$2:
; # (loop (? (== (val (i16* A)) (hex "FFFF")) YES) (? (or (not (dbfBu...
  br label %$5
$5:
; # (? (== (val (i16* A)) (hex "FFFF")) YES)
; # (i16* A)
  %5 = bitcast i8* %1 to i16*
; # (val (i16* A))
  %6 = load i16, i16* %5
; # (== (val (i16* A)) (hex "FFFF"))
  %7 = icmp eq i16 %6, 65535
  br i1 %7, label %$8, label %$6
$8:
  br label %$7
$6:
; # (? (or (not (dbfBuf A)) (<> (fread A BLK 1 Log) 1) (not (fseekOfs...
; # (or (not (dbfBuf A)) (<> (fread A BLK 1 Log) 1) (not (fseekOfs Lo...
; # (dbfBuf A)
  %8 = call i1 @dbfBuf(i8* %1)
; # (not (dbfBuf A))
  %9 = icmp eq i1 %8, 0
  br i1 %9, label %$9, label %$10
$10:
; # (fread A BLK 1 Log)
  %10 = call i32 @fread(i8* %1, i32 6, i32 1, i8* %0)
; # (<> (fread A BLK 1 Log) 1)
  %11 = icmp ne i32 %10, 1
  br i1 %11, label %$9, label %$11
$11:
; # (val $DbFile)
  %12 = load i8*, i8** @$DbFile
; # ((dbFile (val $DbFile)) siz)
  %13 = getelementptr i8, i8* %12, i32 12
  %14 = bitcast i8* %13 to i32*
  %15 = load i32, i32* %14
; # (fseekOfs Log ((dbFile (val $DbFile)) siz))
  %16 = call i1 @fseekOfs(i8* %0, i32 %15)
; # (not (fseekOfs Log ((dbFile (val $DbFile)) siz)))
  %17 = icmp eq i1 %16, 0
  br i1 %17, label %$9, label %$12
$12:
; # (fread A 2 1 Log)
  %18 = call i32 @fread(i8* %1, i32 2, i32 1, i8* %0)
; # (<> (fread A 2 1 Log) 1)
  %19 = icmp ne i32 %18, 1
  br label %$9
$9:
  %20 = phi i1 [1, %$6], [1, %$10], [1, %$11], [%19, %$12] ; # ->
  br i1 %20, label %$14, label %$13
$14:
; # (ignLog)
  call void @ignLog()
  br label %$7
$13:
  br label %$5
$7:
  %21 = phi i1 [1, %$8], [0, %$14] ; # ->
  br label %$4
$3:
; # (unless (feof Log) (ignLog))
; # (feof Log)
  %22 = call i32 @feof(i8* %0)
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %$16, label %$15
$15:
; # (ignLog)
  call void @ignLog()
  br label %$16
$16:
  br label %$4
$4:
  %24 = phi i1 [%21, %$7], [0, %$16] ; # ->
  ret i1 %24
}

define void @fsyncDB(i64) {
$1:
; # (let (P (val $DbFiles) C (val $DBs)) (loop (let Db: (dbFile P) (w...
; # (val $DbFiles)
  %1 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %2 = load i32, i32* @$DBs
; # (loop (let Db: (dbFile P) (when (and (Db: drt) (lt0 (fsync (Db: f...
  br label %$2
$2:
  %3 = phi i8* [%1, %$1], [%25, %$7] ; # P
  %4 = phi i32 [%2, %$1], [%24, %$7] ; # C
; # (let Db: (dbFile P) (when (and (Db: drt) (lt0 (fsync (Db: fd)))) ...
; # (when (and (Db: drt) (lt0 (fsync (Db: fd)))) (dbSyncErr Exe))
; # (and (Db: drt) (lt0 (fsync (Db: fd))))
; # (Db: drt)
  %5 = getelementptr i8, i8* %3, i32 41
  %6 = bitcast i8* %5 to i1*
  %7 = load i1, i1* %6
  br i1 %7, label %$4, label %$3
$4:
  %8 = phi i8* [%3, %$2] ; # P
  %9 = phi i32 [%4, %$2] ; # C
; # (Db: fd)
  %10 = bitcast i8* %3 to i32*
  %11 = load i32, i32* %10
; # (fsync (Db: fd))
  %12 = call i32 @fsync(i32 %11)
; # (lt0 (fsync (Db: fd)))
  %13 = icmp slt i32 %12, 0
  br label %$3
$3:
  %14 = phi i8* [%3, %$2], [%8, %$4] ; # P
  %15 = phi i32 [%4, %$2], [%9, %$4] ; # C
  %16 = phi i1 [0, %$2], [%13, %$4] ; # ->
  br i1 %16, label %$5, label %$6
$5:
  %17 = phi i8* [%14, %$3] ; # P
  %18 = phi i32 [%15, %$3] ; # C
; # (dbSyncErr Exe)
  call void @dbSyncErr(i64 %0)
  unreachable
$6:
  %19 = phi i8* [%14, %$3] ; # P
  %20 = phi i32 [%15, %$3] ; # C
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %21 = sub i32 %20, 1
; # (=0 (dec 'C))
  %22 = icmp eq i32 %21, 0
  br i1 %22, label %$8, label %$7
$7:
  %23 = phi i8* [%19, %$6] ; # P
  %24 = phi i32 [%21, %$6] ; # C
; # (ofs P (dbFile T))
  %25 = getelementptr i8, i8* %23, i32 42
  br label %$2
$8:
  %26 = phi i8* [%19, %$6] ; # P
  %27 = phi i32 [%21, %$6] ; # C
  %28 = phi i64 [0, %$6] ; # ->
  ret void
}

define void @restore(i64) {
$1:
; # (stderrMsg ($ "Last transaction not completed: Rollback^J") null)...
  %1 = call i8* @stderrMsg(i8* bitcast ([42 x i8]* @$54 to i8*), i8* null)
; # (let Log (val $DbLog) (fseek0 Log) (let (P (val $DbFiles) C (val ...
; # (val $DbLog)
  %2 = load i8*, i8** @$DbLog
; # (fseek0 Log)
  %3 = call i1 @fseek0(i8* %2)
; # (let (P (val $DbFiles) C (val $DBs)) (loop ((dbFile P) drt NO) (?...
; # (val $DbFiles)
  %4 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %5 = load i32, i32* @$DBs
; # (loop ((dbFile P) drt NO) (? (=0 (dec 'C))) (setq P (ofs P (dbFil...
  br label %$2
$2:
  %6 = phi i8* [%4, %$1], [%14, %$3] ; # P
  %7 = phi i32 [%5, %$1], [%13, %$3] ; # C
; # ((dbFile P) drt NO)
  %8 = getelementptr i8, i8* %6, i32 41
  %9 = bitcast i8* %8 to i1*
  store i1 0, i1* %9
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %10 = sub i32 %7, 1
; # (=0 (dec 'C))
  %11 = icmp eq i32 %10, 0
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i8* [%6, %$2] ; # P
  %13 = phi i32 [%10, %$2] ; # C
; # (ofs P (dbFile T))
  %14 = getelementptr i8, i8* %12, i32 42
  br label %$2
$4:
  %15 = phi i8* [%6, %$2] ; # P
  %16 = phi i32 [%10, %$2] ; # C
  %17 = phi i64 [0, %$2] ; # ->
; # (let (A (b8 BLK) Buf (b8 (i64 (val $MaxBlkSize)))) (loop (unless ...
; # (b8 BLK)
  %18 = alloca i8, i64 6
; # (val $MaxBlkSize)
  %19 = load i32, i32* @$MaxBlkSize
; # (i64 (val $MaxBlkSize))
  %20 = sext i32 %19 to i64
; # (b8 (i64 (val $MaxBlkSize)))
  %21 = alloca i8, i64 %20
; # (loop (unless (== (fread A 2 1 Log) 1) (jnlErr Exe)) (? (== (val ...
  br label %$5
$5:
; # (unless (== (fread A 2 1 Log) 1) (jnlErr Exe))
; # (fread A 2 1 Log)
  %22 = call i32 @fread(i8* %18, i32 2, i32 1, i8* %2)
; # (== (fread A 2 1 Log) 1)
  %23 = icmp eq i32 %22, 1
  br i1 %23, label %$7, label %$6
$6:
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$7:
; # (? (== (val (i16* A)) (hex "FFFF")))
; # (i16* A)
  %24 = bitcast i8* %18 to i16*
; # (val (i16* A))
  %25 = load i16, i16* %24
; # (== (val (i16* A)) (hex "FFFF"))
  %26 = icmp eq i16 %25, 65535
  br i1 %26, label %$9, label %$8
$8:
; # (unless (dbfBuf A) (jnlErr Exe))
; # (dbfBuf A)
  %27 = call i1 @dbfBuf(i8* %18)
  br i1 %27, label %$11, label %$10
$10:
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$11:
; # (let Db: (dbFile (val $DbFile)) (unless (and (== (fread A BLK 1 L...
; # (val $DbFile)
  %28 = load i8*, i8** @$DbFile
; # (unless (and (== (fread A BLK 1 Log) 1) (== (fread Buf (Db: siz) ...
; # (and (== (fread A BLK 1 Log) 1) (== (fread Buf (Db: siz) 1 Log) 1...
; # (fread A BLK 1 Log)
  %29 = call i32 @fread(i8* %18, i32 6, i32 1, i8* %2)
; # (== (fread A BLK 1 Log) 1)
  %30 = icmp eq i32 %29, 1
  br i1 %30, label %$13, label %$12
$13:
; # (Db: siz)
  %31 = getelementptr i8, i8* %28, i32 12
  %32 = bitcast i8* %31 to i32*
  %33 = load i32, i32* %32
; # (fread Buf (Db: siz) 1 Log)
  %34 = call i32 @fread(i8* %21, i32 %33, i32 1, i8* %2)
; # (== (fread Buf (Db: siz) 1 Log) 1)
  %35 = icmp eq i32 %34, 1
  br label %$12
$12:
  %36 = phi i1 [0, %$11], [%35, %$13] ; # ->
  br i1 %36, label %$15, label %$14
$14:
; # (jnlErr Exe)
  call void @jnlErr(i64 %0)
  unreachable
$15:
; # (unless (== (pwrite (Db: fd) Buf (i64 (Db: siz)) (shl (getAdr A) ...
; # (Db: fd)
  %37 = bitcast i8* %28 to i32*
  %38 = load i32, i32* %37
; # (Db: siz)
  %39 = getelementptr i8, i8* %28, i32 12
  %40 = bitcast i8* %39 to i32*
  %41 = load i32, i32* %40
; # (i64 (Db: siz))
  %42 = sext i32 %41 to i64
; # (getAdr A)
  %43 = call i64 @getAdr(i8* %18)
; # (Db: sh)
  %44 = getelementptr i8, i8* %28, i32 8
  %45 = bitcast i8* %44 to i32*
  %46 = load i32, i32* %45
; # (i64 (Db: sh))
  %47 = sext i32 %46 to i64
; # (shl (getAdr A) (i64 (Db: sh)))
  %48 = shl i64 %43, %47
; # (pwrite (Db: fd) Buf (i64 (Db: siz)) (shl (getAdr A) (i64 (Db: sh...
  %49 = call i64 @pwrite(i32 %38, i8* %21, i64 %42, i64 %48)
; # (Db: siz)
  %50 = getelementptr i8, i8* %28, i32 12
  %51 = bitcast i8* %50 to i32*
  %52 = load i32, i32* %51
; # (i64 (Db: siz))
  %53 = sext i32 %52 to i64
; # (== (pwrite (Db: fd) Buf (i64 (Db: siz)) (shl (getAdr A) (i64 (Db...
  %54 = icmp eq i64 %49, %53
  br i1 %54, label %$17, label %$16
$16:
; # (dbWrErr)
  call void @dbWrErr()
  unreachable
$17:
; # (Db: drt YES)
  %55 = getelementptr i8, i8* %28, i32 41
  %56 = bitcast i8* %55 to i1*
  store i1 1, i1* %56
  br label %$5
$9:
  %57 = phi i64 [0, %$7] ; # ->
; # (fsyncDB Exe)
  call void @fsyncDB(i64 %0)
  ret void
}

define void @truncLog(i64) {
$1:
; # (let Log (val $DbLog) (unless (and (fseek0 Log) (truncate0 (filen...
; # (val $DbLog)
  %1 = load i8*, i8** @$DbLog
; # (unless (and (fseek0 Log) (truncate0 (fileno Log))) (err Exe 0 ($...
; # (and (fseek0 Log) (truncate0 (fileno Log)))
; # (fseek0 Log)
  %2 = call i1 @fseek0(i8* %1)
  br i1 %2, label %$3, label %$2
$3:
; # (fileno Log)
  %3 = call i32 @fileno(i8* %1)
; # (truncate0 (fileno Log))
  %4 = call i1 @truncate0(i32 %3)
  br label %$2
$2:
  %5 = phi i1 [0, %$1], [%4, %$3] ; # ->
  br i1 %5, label %$5, label %$4
$4:
; # (strErrno)
  %6 = call i8* @strErrno()
; # (err Exe 0 ($ "Log truncate error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([23 x i8]* @$55 to i8*), i8* %6)
  unreachable
$5:
  ret void
}

define i64 @_pool(i64) {
$1:
; # (let (X (cdr Exe) Sym1 (save (evSym X)) Dbs (save (evLst (shift X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (save (evSym X))
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 %4, i64* %7
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %12
; # (shift X)
  %13 = inttoptr i64 %3 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (evLst (shift X))
  %16 = call i64 @evLst(i64 %15)
; # (save (evLst (shift X)))
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %16, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (shift X)
  %25 = inttoptr i64 %15 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (evSym (shift X))
  %28 = call i64 @evSym(i64 %27)
; # (save (evSym (shift X)))
  %29 = alloca i64, i64 2, align 16
  %30 = ptrtoint i64* %29 to i64
  %31 = inttoptr i64 %30 to i64*
  store i64 %28, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %30 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  store i64 %33, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %36
; # (shift X)
  %37 = inttoptr i64 %27 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (evSym (shift X))
  %40 = call i64 @evSym(i64 %39)
; # (save (evSym (shift X)))
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %40, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %45 = load i64, i64* %44
  %46 = inttoptr i64 %42 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %48
; # (set $Solo ZERO)
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 376) to i64) to i64*
  store i64 2, i64* %49
; # (when (val $DBs) (_rollback ZERO) (let (P (val $DbFiles) C @) (lo...
; # (val $DBs)
  %50 = load i32, i32* @$DBs
  %51 = icmp ne i32 %50, 0
  br i1 %51, label %$2, label %$3
$2:
  %52 = phi i64 [%16, %$1] ; # Dbs
; # (_rollback ZERO)
  %53 = call i64 @_rollback(i64 2)
; # (let (P (val $DbFiles) C @) (loop (let Db: (dbFile P) (close (Db:...
; # (val $DbFiles)
  %54 = load i8*, i8** @$DbFiles
; # (loop (let Db: (dbFile P) (close (Db: fd)) (free (Db: mark))) (? ...
  br label %$4
$4:
  %55 = phi i64 [%52, %$2], [%66, %$5] ; # Dbs
  %56 = phi i8* [%54, %$2], [%69, %$5] ; # P
  %57 = phi i32 [%50, %$2], [%68, %$5] ; # C
; # (let Db: (dbFile P) (close (Db: fd)) (free (Db: mark)))
; # (Db: fd)
  %58 = bitcast i8* %56 to i32*
  %59 = load i32, i32* %58
; # (close (Db: fd))
  %60 = call i32 @close(i32 %59)
; # (Db: mark)
  %61 = getelementptr i8, i8* %56, i32 16
  %62 = bitcast i8* %61 to i8**
  %63 = load i8*, i8** %62
; # (free (Db: mark))
  call void @free(i8* %63)
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %64 = sub i32 %57, 1
; # (=0 (dec 'C))
  %65 = icmp eq i32 %64, 0
  br i1 %65, label %$6, label %$5
$5:
  %66 = phi i64 [%55, %$4] ; # Dbs
  %67 = phi i8* [%56, %$4] ; # P
  %68 = phi i32 [%64, %$4] ; # C
; # (ofs P (dbFile T))
  %69 = getelementptr i8, i8* %67, i32 42
  br label %$4
$6:
  %70 = phi i64 [%55, %$4] ; # Dbs
  %71 = phi i8* [%56, %$4] ; # P
  %72 = phi i32 [%64, %$4] ; # C
  %73 = phi i64 [0, %$4] ; # ->
; # (set $DBs 0)
  store i32 0, i32* @$DBs
; # (when (val $DbJnl) (fclose @) (set $DbJnl null))
; # (val $DbJnl)
  %74 = load i8*, i8** @$DbJnl
  %75 = icmp ne i8* %74, null
  br i1 %75, label %$7, label %$8
$7:
  %76 = phi i64 [%70, %$6] ; # Dbs
; # (fclose @)
  %77 = call i32 @fclose(i8* %74)
; # (set $DbJnl null)
  store i8* null, i8** @$DbJnl
  br label %$8
$8:
  %78 = phi i64 [%70, %$6], [%76, %$7] ; # Dbs
; # (when (val $DbLog) (fclose @) (set $DbLog null))
; # (val $DbLog)
  %79 = load i8*, i8** @$DbLog
  %80 = icmp ne i8* %79, null
  br i1 %80, label %$9, label %$10
$9:
  %81 = phi i64 [%78, %$8] ; # Dbs
; # (fclose @)
  %82 = call i32 @fclose(i8* %79)
; # (set $DbLog null)
  store i8* null, i8** @$DbLog
  br label %$10
$10:
  %83 = phi i64 [%78, %$8], [%81, %$9] ; # Dbs
  br label %$3
$3:
  %84 = phi i64 [%16, %$1], [%83, %$10] ; # Dbs
; # (unless (nil? Sym1) (let (Nm (xName Exe Sym1) Len (pathSize Nm) B...
; # (nil? Sym1)
  %85 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %85, label %$12, label %$11
$11:
  %86 = phi i64 [%84, %$3] ; # Dbs
; # (let (Nm (xName Exe Sym1) Len (pathSize Nm) Buf (pathString Nm (b...
; # (xName Exe Sym1)
  %87 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %88 = call i64 @pathSize(i64 %87)
; # (+ Len 4)
  %89 = add i64 %88, 4
; # (b8 (+ Len 4))
  %90 = alloca i8, i64 %89
; # (pathString Nm (b8 (+ Len 4)))
  %91 = call i8* @pathString(i64 %87, i8* %90)
; # (ofs Buf Len)
  %92 = getelementptr i8, i8* %91, i64 %88
; # (when (pair Dbs) (let L Dbs (while (pair (shift L)) (inc 'Siz (db...
; # (pair Dbs)
  %93 = and i64 %86, 15
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %$13, label %$14
$13:
  %95 = phi i64 [%86, %$11] ; # Dbs
  %96 = phi i64 [42, %$11] ; # Siz
; # (let L Dbs (while (pair (shift L)) (inc 'Siz (dbFile T))))
; # (while (pair (shift L)) (inc 'Siz (dbFile T)))
  br label %$15
$15:
  %97 = phi i64 [%95, %$13], [%105, %$16] ; # Dbs
  %98 = phi i64 [%96, %$13], [%108, %$16] ; # Siz
  %99 = phi i64 [%95, %$13], [%107, %$16] ; # L
; # (shift L)
  %100 = inttoptr i64 %99 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
; # (pair (shift L))
  %103 = and i64 %102, 15
  %104 = icmp eq i64 %103, 0
  br i1 %104, label %$16, label %$17
$16:
  %105 = phi i64 [%97, %$15] ; # Dbs
  %106 = phi i64 [%98, %$15] ; # Siz
  %107 = phi i64 [%102, %$15] ; # L
; # (inc 'Siz (dbFile T))
  %108 = add i64 %106, 42
  br label %$15
$17:
  %109 = phi i64 [%97, %$15] ; # Dbs
  %110 = phi i64 [%98, %$15] ; # Siz
  %111 = phi i64 [%102, %$15] ; # L
  br label %$14
$14:
  %112 = phi i64 [%86, %$11], [%109, %$17] ; # Dbs
  %113 = phi i64 [42, %$11], [%110, %$17] ; # Siz
; # (let (Db: (dbFile (set $DbFiles (alloc (val $DbFiles) Siz))) P (b...
; # (set $DbFiles (alloc (val $DbFiles) Siz))
; # (val $DbFiles)
  %114 = load i8*, i8** @$DbFiles
; # (alloc (val $DbFiles) Siz)
  %115 = call i8* @alloc(i8* %114, i64 %113)
  store i8* %115, i8** @$DbFiles
; # (+ BLK BLK 1)
; # (b8 (+ BLK BLK 1))
  %116 = alloca i8, i64 13
; # (i32 0)
; # (i32 0)
; # (loop (Db: db Fnr) (if (atom Dbs) (Db: sh 2) (set (bufAo End Fnr)...
  br label %$18
$18:
  %117 = phi i64 [%112, %$14], [%265, %$36] ; # Dbs
  %118 = phi i64 [%113, %$14], [%266, %$36] ; # Siz
  %119 = phi i32 [0, %$14], [%267, %$36] ; # Fnr
  %120 = phi i32 [0, %$14], [%268, %$36] ; # Max
; # (Db: db Fnr)
  %121 = getelementptr i8, i8* %115, i32 4
  %122 = bitcast i8* %121 to i32*
  store i32 %119, i32* %122
; # (if (atom Dbs) (Db: sh 2) (set (bufAo End Fnr) 0) (Db: sh (i32 (+...
; # (atom Dbs)
  %123 = and i64 %117, 15
  %124 = icmp ne i64 %123, 0
  br i1 %124, label %$19, label %$20
$19:
  %125 = phi i64 [%117, %$18] ; # Dbs
  %126 = phi i64 [%118, %$18] ; # Siz
  %127 = phi i32 [%119, %$18] ; # Fnr
  %128 = phi i32 [%120, %$18] ; # Max
; # (Db: sh 2)
  %129 = getelementptr i8, i8* %115, i32 8
  %130 = bitcast i8* %129 to i32*
  store i32 2, i32* %130
  br label %$21
$20:
  %131 = phi i64 [%117, %$18] ; # Dbs
  %132 = phi i64 [%118, %$18] ; # Siz
  %133 = phi i32 [%119, %$18] ; # Fnr
  %134 = phi i32 [%120, %$18] ; # Max
; # (set (bufAo End Fnr) 0)
; # (bufAo End Fnr)
  %135 = call i8* @bufAo(i8* %92, i32 %133)
  store i8 0, i8* %135
; # (Db: sh (i32 (++ Dbs)))
  %136 = getelementptr i8, i8* %115, i32 8
  %137 = bitcast i8* %136 to i32*
  %138 = inttoptr i64 %131 to i64*
  %139 = load i64, i64* %138
  %140 = getelementptr i64, i64* %138, i32 1
  %141 = load i64, i64* %140
  %142 = trunc i64 %139 to i32
  store i32 %142, i32* %137
  br label %$21
$21:
  %143 = phi i64 [%125, %$19], [%141, %$20] ; # Dbs
  %144 = phi i64 [%126, %$19], [%132, %$20] ; # Siz
  %145 = phi i32 [%127, %$19], [%133, %$20] ; # Fnr
  %146 = phi i32 [%128, %$19], [%134, %$20] ; # Max
  %147 = phi i32 [2, %$19], [%142, %$20] ; # ->
; # (set $DbFile (Db:))
; # (Db:)
  store i8* %115, i8** @$DbFile
; # (cond ((ge0 (Db: fd (openRdWr Buf))) (blkPeek 0 P (+ BLK BLK 1)) ...
; # (Db: fd (openRdWr Buf))
  %148 = bitcast i8* %115 to i32*
  %149 = call i32 @openRdWr(i8* %91)
  store i32 %149, i32* %148
; # (ge0 (Db: fd (openRdWr Buf)))
  %150 = icmp sge i32 %149, 0
  br i1 %150, label %$24, label %$23
$24:
  %151 = phi i64 [%143, %$21] ; # Dbs
  %152 = phi i64 [%144, %$21] ; # Siz
  %153 = phi i32 [%145, %$21] ; # Fnr
  %154 = phi i32 [%146, %$21] ; # Max
; # (+ BLK BLK 1)
; # (blkPeek 0 P (+ BLK BLK 1))
  call void @blkPeek(i64 0, i8* %116, i32 13)
; # (Db: siz (shl (i32 BLKSIZE) (Db: sh (i32 (val (+ BLK BLK) P)))))
  %155 = getelementptr i8, i8* %115, i32 12
  %156 = bitcast i8* %155 to i32*
  %157 = getelementptr i8, i8* %115, i32 8
  %158 = bitcast i8* %157 to i32*
  %159 = getelementptr i8, i8* %116, i32 11
  %160 = load i8, i8* %159
  %161 = zext i8 %160 to i32
  store i32 %161, i32* %158
  %162 = shl i32 64, %161
  store i32 %162, i32* %156
  br label %$22
$23:
  %163 = phi i64 [%143, %$21] ; # Dbs
  %164 = phi i64 [%144, %$21] ; # Siz
  %165 = phi i32 [%145, %$21] ; # Fnr
  %166 = phi i32 [%146, %$21] ; # Max
; # (and (== (gErrno) ENOENT) (ge0 (Db: fd (openRdWrExcl Buf))))
; # (gErrno)
  %167 = call i32 @gErrno()
; # (== (gErrno) ENOENT)
  %168 = icmp eq i32 %167, 1
  br i1 %168, label %$26, label %$25
$26:
  %169 = phi i64 [%163, %$23] ; # Dbs
  %170 = phi i64 [%164, %$23] ; # Siz
  %171 = phi i32 [%165, %$23] ; # Fnr
  %172 = phi i32 [%166, %$23] ; # Max
; # (Db: fd (openRdWrExcl Buf))
  %173 = bitcast i8* %115 to i32*
  %174 = call i32 @openRdWrExcl(i8* %91)
  store i32 %174, i32* %173
; # (ge0 (Db: fd (openRdWrExcl Buf)))
  %175 = icmp sge i32 %174, 0
  br label %$25
$25:
  %176 = phi i64 [%163, %$23], [%169, %$26] ; # Dbs
  %177 = phi i64 [%164, %$23], [%170, %$26] ; # Siz
  %178 = phi i32 [%165, %$23], [%171, %$26] ; # Fnr
  %179 = phi i32 [%166, %$23], [%172, %$26] ; # Max
  %180 = phi i1 [0, %$23], [%175, %$26] ; # ->
  br i1 %180, label %$28, label %$27
$28:
  %181 = phi i64 [%176, %$25] ; # Dbs
  %182 = phi i64 [%177, %$25] ; # Siz
  %183 = phi i32 [%178, %$25] ; # Fnr
  %184 = phi i32 [%179, %$25] ; # Max
; # (let (N (shl (i32 BLKSIZE) (Db: sh)) Stk (stack) Blk (b8 (i64 (Db...
; # (i32 BLKSIZE)
; # (Db: sh)
  %185 = getelementptr i8, i8* %115, i32 8
  %186 = bitcast i8* %185 to i32*
  %187 = load i32, i32* %186
; # (shl (i32 BLKSIZE) (Db: sh))
  %188 = shl i32 64, %187
; # (stack)
  %189 = call i8* @llvm.stacksave()
; # (Db: siz N)
  %190 = getelementptr i8, i8* %115, i32 12
  %191 = bitcast i8* %190 to i32*
  store i32 %188, i32* %191
; # (i64 (Db: siz N))
  %192 = sext i32 %188 to i64
; # (b8 (i64 (Db: siz N)))
  %193 = alloca i8, i64 %192
; # (i64 N)
  %194 = sext i32 %188 to i64
; # (memset Blk 0 (i64 N))
  call void @llvm.memset.p0i8.p0i8.i64(i8* %193, i8 0, i64 %194, i1 0)
; # (if (== (Db:) (val $DbFiles)) (* 2 BLKSIZE) BLKSIZE)
; # (Db:)
; # (val $DbFiles)
  %195 = load i8*, i8** @$DbFiles
; # (== (Db:) (val $DbFiles))
  %196 = icmp eq i8* %115, %195
  br i1 %196, label %$29, label %$30
$29:
  %197 = phi i64 [%181, %$28] ; # Dbs
  %198 = phi i64 [%182, %$28] ; # Siz
  %199 = phi i32 [%183, %$28] ; # Fnr
  %200 = phi i32 [%184, %$28] ; # Max
; # (* 2 BLKSIZE)
  br label %$31
$30:
  %201 = phi i64 [%181, %$28] ; # Dbs
  %202 = phi i64 [%182, %$28] ; # Siz
  %203 = phi i32 [%183, %$28] ; # Fnr
  %204 = phi i32 [%184, %$28] ; # Max
  br label %$31
$31:
  %205 = phi i64 [%197, %$29], [%201, %$30] ; # Dbs
  %206 = phi i64 [%198, %$29], [%202, %$30] ; # Siz
  %207 = phi i32 [%199, %$29], [%203, %$30] ; # Fnr
  %208 = phi i32 [%200, %$29], [%204, %$30] ; # Max
  %209 = phi i64 [128, %$29], [64, %$30] ; # ->
; # (ofs Blk BLK)
  %210 = getelementptr i8, i8* %193, i32 6
; # (setAdr (if (== (Db:) (val $DbFiles)) (* 2 BLKSIZE) BLKSIZE) (ofs...
  call void @setAdr(i64 %209, i8* %210)
; # (set (inc (* 2 BLK)) Blk (i8 (Db: sh)))
; # (* 2 BLK)
; # (inc (* 2 BLK))
; # (Db: sh)
  %211 = getelementptr i8, i8* %115, i32 8
  %212 = bitcast i8* %211 to i32*
  %213 = load i32, i32* %212
; # (i8 (Db: sh))
  %214 = trunc i32 %213 to i8
  %215 = getelementptr i8, i8* %193, i32 12
  store i8 %214, i8* %215
; # (blkPoke 0 Blk N)
  call void @blkPoke(i64 0, i8* %193, i32 %188)
; # (when (== (Db:) (val $DbFiles)) (memset Blk 0 16) (setAdr 1 Blk) ...
; # (Db:)
; # (val $DbFiles)
  %216 = load i8*, i8** @$DbFiles
; # (== (Db:) (val $DbFiles))
  %217 = icmp eq i8* %115, %216
  br i1 %217, label %$32, label %$33
$32:
  %218 = phi i64 [%205, %$31] ; # Dbs
  %219 = phi i64 [%206, %$31] ; # Siz
  %220 = phi i32 [%207, %$31] ; # Fnr
  %221 = phi i32 [%208, %$31] ; # Max
; # (memset Blk 0 16)
  call void @llvm.memset.p0i8.p0i8.i64(i8* %193, i8 0, i64 16, i1 0)
; # (setAdr 1 Blk)
  call void @setAdr(i64 1, i8* %193)
; # (Db: siz)
  %222 = getelementptr i8, i8* %115, i32 12
  %223 = bitcast i8* %222 to i32*
  %224 = load i32, i32* %223
; # (i64 (Db: siz))
  %225 = sext i32 %224 to i64
; # (blkPoke (i64 (Db: siz)) Blk N)
  call void @blkPoke(i64 %225, i8* %193, i32 %188)
  br label %$33
$33:
  %226 = phi i64 [%205, %$31], [%218, %$32] ; # Dbs
  %227 = phi i64 [%206, %$31], [%219, %$32] ; # Siz
  %228 = phi i32 [%207, %$31], [%220, %$32] ; # Fnr
  %229 = phi i32 [%208, %$31], [%221, %$32] ; # Max
; # (stack Stk)
  call void @llvm.stackrestore(i8* %189)
; # (Db: fd)
  %230 = bitcast i8* %115 to i32*
  %231 = load i32, i32* %230
; # (closeOnExec Exe (Db: fd))
  call void @closeOnExec(i64 %0, i32 %231)
; # (when (> (Db: siz) Max) (setq Max @))
; # (Db: siz)
  %232 = getelementptr i8, i8* %115, i32 12
  %233 = bitcast i8* %232 to i32*
  %234 = load i32, i32* %233
; # (> (Db: siz) Max)
  %235 = icmp sgt i32 %234, %229
  br i1 %235, label %$34, label %$35
$34:
  %236 = phi i64 [%226, %$33] ; # Dbs
  %237 = phi i64 [%227, %$33] ; # Siz
  %238 = phi i32 [%228, %$33] ; # Fnr
  %239 = phi i32 [%229, %$33] ; # Max
  br label %$35
$35:
  %240 = phi i64 [%226, %$33], [%236, %$34] ; # Dbs
  %241 = phi i64 [%227, %$33], [%237, %$34] ; # Siz
  %242 = phi i32 [%228, %$33], [%238, %$34] ; # Fnr
  %243 = phi i32 [%229, %$33], [%234, %$34] ; # Max
; # (Db: mark null)
  %244 = getelementptr i8, i8* %115, i32 16
  %245 = bitcast i8* %244 to i8**
  store i8* null, i8** %245
; # (Db: mrks 0)
  %246 = getelementptr i8, i8* %115, i32 24
  %247 = bitcast i8* %246 to i64*
  store i64 0, i64* %247
; # (Db: flu 0)
  %248 = getelementptr i8, i8* %115, i32 32
  %249 = bitcast i8* %248 to i64*
  store i64 0, i64* %249
; # (Db: lck (Db: drt NO))
  %250 = getelementptr i8, i8* %115, i32 40
  %251 = bitcast i8* %250 to i1*
  %252 = getelementptr i8, i8* %115, i32 41
  %253 = bitcast i8* %252 to i1*
  store i1 0, i1* %253
  store i1 0, i1* %251
  br label %$22
$27:
  %254 = phi i64 [%176, %$25] ; # Dbs
  %255 = phi i64 [%177, %$25] ; # Siz
  %256 = phi i32 [%178, %$25] ; # Fnr
  %257 = phi i32 [%179, %$25] ; # Max
; # (openErr Exe Sym1)
  call void @openErr(i64 %0, i64 %4)
  unreachable
$22:
  %258 = phi i64 [%151, %$24], [%240, %$35] ; # Dbs
  %259 = phi i64 [%152, %$24], [%241, %$35] ; # Siz
  %260 = phi i32 [%153, %$24], [%242, %$35] ; # Fnr
  %261 = phi i32 [%154, %$24], [%243, %$35] ; # Max
; # (inc 'Fnr)
  %262 = add i32 %260, 1
; # (? (atom Dbs))
; # (atom Dbs)
  %263 = and i64 %258, 15
  %264 = icmp ne i64 %263, 0
  br i1 %264, label %$37, label %$36
$36:
  %265 = phi i64 [%258, %$22] ; # Dbs
  %266 = phi i64 [%259, %$22] ; # Siz
  %267 = phi i32 [%262, %$22] ; # Fnr
  %268 = phi i32 [%261, %$22] ; # Max
  br label %$18
$37:
  %269 = phi i64 [%258, %$22] ; # Dbs
  %270 = phi i64 [%259, %$22] ; # Siz
  %271 = phi i32 [%262, %$22] ; # Fnr
  %272 = phi i32 [%261, %$22] ; # Max
  %273 = phi i64 [0, %$22] ; # ->
; # (set $DBs Fnr $MaxBlkSize Max $DbBlock (alloc (val $DbBlock) (i64...
  store i32 %271, i32* @$DBs
  store i32 %272, i32* @$MaxBlkSize
; # (val $DbBlock)
  %274 = load i8*, i8** @$DbBlock
; # (i64 Max)
  %275 = sext i32 %272 to i64
; # (alloc (val $DbBlock) (i64 Max))
  %276 = call i8* @alloc(i8* %274, i64 %275)
  store i8* %276, i8** @$DbBlock
; # (unless (nil? Sym2) (let Nm (xName Exe Sym2) (unless (fopen (path...
; # (nil? Sym2)
  %277 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %277, label %$39, label %$38
$38:
  %278 = phi i64 [%269, %$37] ; # Dbs
; # (let Nm (xName Exe Sym2) (unless (fopen (pathString Nm (b8 (pathS...
; # (xName Exe Sym2)
  %279 = call i64 @xName(i64 %0, i64 %28)
; # (unless (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a")) (openE...
; # (pathSize Nm)
  %280 = call i64 @pathSize(i64 %279)
; # (b8 (pathSize Nm))
  %281 = alloca i8, i64 %280
; # (pathString Nm (b8 (pathSize Nm)))
  %282 = call i8* @pathString(i64 %279, i8* %281)
; # (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a"))
  %283 = call i8* @fopen(i8* %282, i8* bitcast ([2 x i8]* @$56 to i8*))
  %284 = icmp ne i8* %283, null
  br i1 %284, label %$41, label %$40
$40:
  %285 = phi i64 [%278, %$38] ; # Dbs
; # (openErr Exe Sym2)
  call void @openErr(i64 %0, i64 %28)
  unreachable
$41:
  %286 = phi i64 [%278, %$38] ; # Dbs
; # (set $DbJnl @)
  store i8* %283, i8** @$DbJnl
; # (fileno @)
  %287 = call i32 @fileno(i8* %283)
; # (closeOnExec Exe (fileno @))
  call void @closeOnExec(i64 %0, i32 %287)
  br label %$39
$39:
  %288 = phi i64 [%269, %$37], [%286, %$41] ; # Dbs
; # (unless (nil? Sym3) (let Nm (xName Exe Sym3) (unless (fopen (path...
; # (nil? Sym3)
  %289 = icmp eq i64 %40, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %289, label %$43, label %$42
$42:
  %290 = phi i64 [%288, %$39] ; # Dbs
; # (let Nm (xName Exe Sym3) (unless (fopen (pathString Nm (b8 (pathS...
; # (xName Exe Sym3)
  %291 = call i64 @xName(i64 %0, i64 %40)
; # (unless (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a+")) (open...
; # (pathSize Nm)
  %292 = call i64 @pathSize(i64 %291)
; # (b8 (pathSize Nm))
  %293 = alloca i8, i64 %292
; # (pathString Nm (b8 (pathSize Nm)))
  %294 = call i8* @pathString(i64 %291, i8* %293)
; # (fopen (pathString Nm (b8 (pathSize Nm))) ($ "a+"))
  %295 = call i8* @fopen(i8* %294, i8* bitcast ([3 x i8]* @$57 to i8*))
  %296 = icmp ne i8* %295, null
  br i1 %296, label %$45, label %$44
$44:
  %297 = phi i64 [%290, %$42] ; # Dbs
; # (openErr Exe Sym3)
  call void @openErr(i64 %0, i64 %40)
  unreachable
$45:
  %298 = phi i64 [%290, %$42] ; # Dbs
; # (set $DbLog @)
  store i8* %295, i8** @$DbLog
; # (fileno @)
  %299 = call i32 @fileno(i8* %295)
; # (closeOnExec Exe (fileno @))
  call void @closeOnExec(i64 %0, i32 %299)
; # (when (transaction) (restore Exe))
; # (transaction)
  %300 = call i1 @transaction()
  br i1 %300, label %$46, label %$47
$46:
  %301 = phi i64 [%298, %$45] ; # Dbs
; # (restore Exe)
  call void @restore(i64 %0)
  br label %$47
$47:
  %302 = phi i64 [%298, %$45], [%301, %$46] ; # Dbs
; # (truncLog Exe)
  call void @truncLog(i64 %0)
  br label %$43
$43:
  %303 = phi i64 [%288, %$39], [%302, %$47] ; # Dbs
  br label %$12
$12:
  %304 = phi i64 [%84, %$3], [%303, %$43] ; # Dbs
; # (drop *Safe)
  %305 = inttoptr i64 %6 to i64*
  %306 = getelementptr i64, i64* %305, i32 1
  %307 = load i64, i64* %306
  %308 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %307, i64* %308
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
}

define i64 @_pool2(i64) {
$1:
  ret i64 %0
}

define i64 @_journal(i64) {
$1:
  ret i64 %0
}

define i64 @_id(i64) {
$1:
  ret i64 %0
}

define i64 @_blk(i64) {
$1:
  ret i64 %0
}

define i64 @_seq(i64) {
$1:
  ret i64 %0
}

define i64 @_lieu(i64) {
$1:
  ret i64 %0
}

define i64 @_lock(i64) {
$1:
  ret i64 %0
}

define void @db(i64, i64, i64) {
$1:
; # (save Sym)
  %3 = alloca i64, i64 2, align 16
  %4 = ptrtoint i64* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  store i64 %1, i64* %5
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %7 = load i64, i64* %6
  %8 = inttoptr i64 %4 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  store i64 %7, i64* %9
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %4, i64* %10
; # (let F (objFile Tail) (if (>= F (val $DBs)) (let Ext (val $Ext) (...
; # (objFile Tail)
  %11 = call i32 @objFile(i64 %2)
; # (if (>= F (val $DBs)) (let Ext (val $Ext) (if (or (atom Ext) (> (...
; # (val $DBs)
  %12 = load i32, i32* @$DBs
; # (>= F (val $DBs))
  %13 = icmp sge i32 %11, %12
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%2, %$1] ; # Tail
  %15 = phi i32 [%11, %$1] ; # F
; # (let Ext (val $Ext) (if (or (atom Ext) (> (i32 (int (caar @))) (i...
; # (val $Ext)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 504) to i64) to i64*
  %17 = load i64, i64* %16
; # (if (or (atom Ext) (> (i32 (int (caar @))) (inc 'F))) (dbfErr Exe...
; # (or (atom Ext) (> (i32 (int (caar @))) (inc 'F)))
; # (atom Ext)
  %18 = and i64 %17, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$5, label %$6
$6:
  %20 = phi i64 [%14, %$2] ; # Tail
  %21 = phi i32 [%15, %$2] ; # F
  %22 = phi i64 [%17, %$2] ; # Ext
; # (caar @)
  %23 = inttoptr i64 %17 to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (int (caar @))
  %27 = lshr i64 %26, 4
; # (i32 (int (caar @)))
  %28 = trunc i64 %27 to i32
; # (inc 'F)
  %29 = add i32 %21, 1
; # (> (i32 (int (caar @))) (inc 'F))
  %30 = icmp sgt i32 %28, %29
  br label %$5
$5:
  %31 = phi i64 [%14, %$2], [%20, %$6] ; # Tail
  %32 = phi i32 [%15, %$2], [%29, %$6] ; # F
  %33 = phi i64 [%17, %$2], [%22, %$6] ; # Ext
  %34 = phi i1 [1, %$2], [%30, %$6] ; # ->
  br i1 %34, label %$7, label %$8
$7:
  %35 = phi i64 [%31, %$5] ; # Tail
  %36 = phi i32 [%32, %$5] ; # F
  %37 = phi i64 [%33, %$5] ; # Ext
; # (dbfErr Exe)
  call void @dbfErr(i64 %0)
  unreachable
$8:
  %38 = phi i64 [%31, %$5] ; # Tail
  %39 = phi i32 [%32, %$5] ; # F
  %40 = phi i64 [%33, %$5] ; # Ext
; # (while (and (pair (cdr Ext)) (>= F (i32 (int (caar @))))) (shift ...
  br label %$10
$10:
  %41 = phi i64 [%38, %$8], [%63, %$13] ; # Tail
  %42 = phi i32 [%39, %$8], [%64, %$13] ; # F
  %43 = phi i64 [%40, %$8], [%68, %$13] ; # Ext
; # (and (pair (cdr Ext)) (>= F (i32 (int (caar @)))))
; # (cdr Ext)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (pair (cdr Ext))
  %47 = and i64 %46, 15
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %$12, label %$11
$12:
  %49 = phi i64 [%41, %$10] ; # Tail
  %50 = phi i32 [%42, %$10] ; # F
  %51 = phi i64 [%43, %$10] ; # Ext
; # (caar @)
  %52 = inttoptr i64 %46 to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (int (caar @))
  %56 = lshr i64 %55, 4
; # (i32 (int (caar @)))
  %57 = trunc i64 %56 to i32
; # (>= F (i32 (int (caar @))))
  %58 = icmp sge i32 %50, %57
  br label %$11
$11:
  %59 = phi i64 [%41, %$10], [%49, %$12] ; # Tail
  %60 = phi i32 [%42, %$10], [%50, %$12] ; # F
  %61 = phi i64 [%43, %$10], [%51, %$12] ; # Ext
  %62 = phi i1 [0, %$10], [%58, %$12] ; # ->
  br i1 %62, label %$13, label %$14
$13:
  %63 = phi i64 [%59, %$11] ; # Tail
  %64 = phi i32 [%60, %$11] ; # F
  %65 = phi i64 [%61, %$11] ; # Ext
; # (shift Ext)
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
  br label %$10
$14:
  %69 = phi i64 [%59, %$11] ; # Tail
  %70 = phi i32 [%60, %$11] ; # F
  %71 = phi i64 [%61, %$11] ; # Ext
; # (let (V (push NIL $Nil ZERO Sym) E (push NIL V ZERO (cdar Ext))) ...
; # (push NIL $Nil ZERO Sym)
  %72 = alloca i64, i64 4, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = add i64 %73, 8
  %75 = inttoptr i64 %74 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %75
  %76 = add i64 %73, 16
  %77 = inttoptr i64 %76 to i64*
  store i64 2, i64* %77
  %78 = add i64 %73, 24
  %79 = inttoptr i64 %78 to i64*
  store i64 %1, i64* %79
; # (cdar Ext)
  %80 = inttoptr i64 %71 to i64*
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (push NIL V ZERO (cdar Ext))
  %85 = alloca i64, i64 4, align 16
  %86 = ptrtoint i64* %85 to i64
  %87 = add i64 %86, 8
  %88 = inttoptr i64 %87 to i64*
  store i64 %73, i64* %88
  %89 = add i64 %86, 16
  %90 = inttoptr i64 %89 to i64*
  store i64 2, i64* %90
  %91 = add i64 %86, 24
  %92 = inttoptr i64 %91 to i64*
  store i64 %84, i64* %92
; # (set V (ofs V 3) E (ofs E 3))
; # (ofs V 3)
  %93 = add i64 %73, 24
  %94 = inttoptr i64 %73 to i64*
  store i64 %93, i64* %94
; # (ofs E 3)
  %95 = add i64 %86, 24
  %96 = inttoptr i64 %86 to i64*
  store i64 %95, i64* %96
; # (let X (evList E) (set Sym (++ X)) (if (atom X) (set (tail Sym) T...
; # (evList E)
  %97 = call i64 @evList(i64 %86)
; # (set Sym (++ X))
; # (++ X)
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
  %100 = getelementptr i64, i64* %98, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 %1 to i64*
  store i64 %99, i64* %102
; # (if (atom X) (set (tail Sym) Tail) (set (tail Sym) (sym X)) (whil...
; # (atom X)
  %103 = and i64 %101, 15
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$15, label %$16
$15:
  %105 = phi i64 [%69, %$14] ; # Tail
  %106 = phi i32 [%70, %$14] ; # F
  %107 = phi i64 [%71, %$14] ; # Ext
  %108 = phi i64 [%101, %$14] ; # X
; # (set (tail Sym) Tail)
; # (tail Sym)
  %109 = add i64 %1, -8
  %110 = inttoptr i64 %109 to i64*
  store i64 %105, i64* %110
  br label %$17
$16:
  %111 = phi i64 [%69, %$14] ; # Tail
  %112 = phi i32 [%70, %$14] ; # F
  %113 = phi i64 [%71, %$14] ; # Ext
  %114 = phi i64 [%101, %$14] ; # X
; # (set (tail Sym) (sym X))
; # (tail Sym)
  %115 = add i64 %1, -8
; # (sym X)
  %116 = or i64 %114, 8
  %117 = inttoptr i64 %115 to i64*
  store i64 %116, i64* %117
; # (while (pair (cdr X)) (setq X @))
  br label %$18
$18:
  %118 = phi i64 [%111, %$16], [%127, %$19] ; # Tail
  %119 = phi i32 [%112, %$16], [%128, %$19] ; # F
  %120 = phi i64 [%113, %$16], [%129, %$19] ; # Ext
  %121 = phi i64 [%114, %$16], [%124, %$19] ; # X
; # (cdr X)
  %122 = inttoptr i64 %121 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  %124 = load i64, i64* %123
; # (pair (cdr X))
  %125 = and i64 %124, 15
  %126 = icmp eq i64 %125, 0
  br i1 %126, label %$19, label %$20
$19:
  %127 = phi i64 [%118, %$18] ; # Tail
  %128 = phi i32 [%119, %$18] ; # F
  %129 = phi i64 [%120, %$18] ; # Ext
  %130 = phi i64 [%121, %$18] ; # X
  br label %$18
$20:
  %131 = phi i64 [%118, %$18] ; # Tail
  %132 = phi i32 [%119, %$18] ; # F
  %133 = phi i64 [%120, %$18] ; # Ext
  %134 = phi i64 [%121, %$18] ; # X
; # (set 2 X Tail)
  %135 = inttoptr i64 %134 to i64*
  %136 = getelementptr i64, i64* %135, i32 1
  store i64 %131, i64* %136
  br label %$17
$17:
  %137 = phi i64 [%105, %$15], [%131, %$20] ; # Tail
  %138 = phi i32 [%106, %$15], [%132, %$20] ; # F
  %139 = phi i64 [%107, %$15], [%133, %$20] ; # Ext
  %140 = phi i64 [%108, %$15], [%134, %$20] ; # X
  %141 = phi i64 [%105, %$15], [%131, %$20] ; # ->
  br label %$9
$9:
  %142 = phi i64 [%137, %$17] ; # Tail
  %143 = phi i32 [%138, %$17] ; # F
  %144 = phi i64 [%139, %$17] ; # Ext
  %145 = phi i64 [%141, %$17] ; # ->
  br label %$4
$3:
  %146 = phi i64 [%2, %$1] ; # Tail
  %147 = phi i32 [%11, %$1] ; # F
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %148 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %149 = mul i32 %147, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %150 = getelementptr i8, i8* %148, i32 %149
  store i8* %150, i8** @$DbFile
; # (rdLockDb)
  call void @rdLockDb()
; # (let Blk (ofs (rdBlock (shl (objId Tail) 6)) (- BLK)) (unless (==...
; # (objId Tail)
  %151 = call i64 @objId(i64 %146)
; # (shl (objId Tail) 6)
  %152 = shl i64 %151, 6
; # (rdBlock (shl (objId Tail) 6))
  %153 = call i8* @rdBlock(i64 %152)
; # (- BLK)
; # (ofs (rdBlock (shl (objId Tail) 6)) (- BLK))
  %154 = getelementptr i8, i8* %153, i32 -6
; # (unless (== 1 (& (val Blk) BLKTAG)) (err Exe 0 ($ "Bad ID") null)...
; # (val Blk)
  %155 = load i8, i8* %154
; # (& (val Blk) BLKTAG)
  %156 = and i8 %155, 63
; # (== 1 (& (val Blk) BLKTAG))
  %157 = icmp eq i8 1, %156
  br i1 %157, label %$22, label %$21
$21:
  %158 = phi i64 [%146, %$3] ; # Tail
  %159 = phi i32 [%147, %$3] ; # F
; # (err Exe 0 ($ "Bad ID") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([7 x i8]* @$58 to i8*), i8* null)
  unreachable
$22:
  %160 = phi i64 [%146, %$3] ; # Tail
  %161 = phi i32 [%147, %$3] ; # F
; # (set $GetBin (fun (i32) getBlock) $Extn 0)
; # (fun (i32) getBlock)
  store i32()* @getBlock, i32()** @$GetBin
  store i32 0, i32* @$Extn
; # (set Sym (binRead))
; # (binRead)
  %162 = call i64 @binRead()
  %163 = inttoptr i64 %1 to i64*
  store i64 %162, i64* %163
; # (if (nil? (binRead)) (set (tail Sym) Tail) (set (tail Sym) (sym (...
; # (binRead)
  %164 = call i64 @binRead()
; # (nil? (binRead))
  %165 = icmp eq i64 %164, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %165, label %$23, label %$24
$23:
  %166 = phi i64 [%160, %$22] ; # Tail
  %167 = phi i32 [%161, %$22] ; # F
; # (set (tail Sym) Tail)
; # (tail Sym)
  %168 = add i64 %1, -8
  %169 = inttoptr i64 %168 to i64*
  store i64 %166, i64* %169
  br label %$25
$24:
  %170 = phi i64 [%160, %$22] ; # Tail
  %171 = phi i32 [%161, %$22] ; # F
; # (set (tail Sym) (sym (setq Tail (cons @ Tail))))
; # (tail Sym)
  %172 = add i64 %1, -8
; # (cons @ Tail)
  %173 = call i64 @cons(i64 %164, i64 %170)
; # (sym (setq Tail (cons @ Tail)))
  %174 = or i64 %173, 8
  %175 = inttoptr i64 %172 to i64*
  store i64 %174, i64* %175
; # (unless (t? (binRead)) (set Tail (cons @ (val Tail))))
; # (binRead)
  %176 = call i64 @binRead()
; # (t? (binRead))
  %177 = icmp eq i64 %176, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %177, label %$27, label %$26
$26:
  %178 = phi i64 [%173, %$24] ; # Tail
  %179 = phi i32 [%171, %$24] ; # F
; # (set Tail (cons @ (val Tail)))
; # (val Tail)
  %180 = inttoptr i64 %178 to i64*
  %181 = load i64, i64* %180
; # (cons @ (val Tail))
  %182 = call i64 @cons(i64 %176, i64 %181)
  %183 = inttoptr i64 %178 to i64*
  store i64 %182, i64* %183
  br label %$27
$27:
  %184 = phi i64 [%173, %$24], [%178, %$26] ; # Tail
  %185 = phi i32 [%171, %$24], [%179, %$26] ; # F
; # (until (nil? (binRead)) (set 2 Tail (cons @ (shift Tail))) (unles...
  br label %$28
$28:
  %186 = phi i64 [%184, %$27], [%206, %$32] ; # Tail
  %187 = phi i32 [%185, %$27], [%207, %$32] ; # F
; # (binRead)
  %188 = call i64 @binRead()
; # (nil? (binRead))
  %189 = icmp eq i64 %188, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %189, label %$30, label %$29
$29:
  %190 = phi i64 [%186, %$28] ; # Tail
  %191 = phi i32 [%187, %$28] ; # F
; # (set 2 Tail (cons @ (shift Tail)))
; # (shift Tail)
  %192 = inttoptr i64 %190 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
; # (cons @ (shift Tail))
  %195 = call i64 @cons(i64 %188, i64 %194)
  %196 = inttoptr i64 %190 to i64*
  %197 = getelementptr i64, i64* %196, i32 1
  store i64 %195, i64* %197
; # (unless (t? (binRead)) (set Tail (cons @ (val Tail))))
; # (binRead)
  %198 = call i64 @binRead()
; # (t? (binRead))
  %199 = icmp eq i64 %198, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %199, label %$32, label %$31
$31:
  %200 = phi i64 [%194, %$29] ; # Tail
  %201 = phi i32 [%191, %$29] ; # F
; # (set Tail (cons @ (val Tail)))
; # (val Tail)
  %202 = inttoptr i64 %200 to i64*
  %203 = load i64, i64* %202
; # (cons @ (val Tail))
  %204 = call i64 @cons(i64 %198, i64 %203)
  %205 = inttoptr i64 %200 to i64*
  store i64 %204, i64* %205
  br label %$32
$32:
  %206 = phi i64 [%194, %$29], [%200, %$31] ; # Tail
  %207 = phi i32 [%191, %$29], [%201, %$31] ; # F
  br label %$28
$30:
  %208 = phi i64 [%186, %$28] ; # Tail
  %209 = phi i32 [%187, %$28] ; # F
  br label %$25
$25:
  %210 = phi i64 [%166, %$23], [%208, %$30] ; # Tail
  %211 = phi i32 [%167, %$23], [%209, %$30] ; # F
; # (unLockDb 1)
  call void @unLockDb(i64 1)
  br label %$4
$4:
  %212 = phi i64 [%142, %$9], [%210, %$25] ; # Tail
  %213 = phi i32 [%143, %$9], [%211, %$25] ; # F
; # (drop *Safe)
  %214 = inttoptr i64 %4 to i64*
  %215 = getelementptr i64, i64* %214, i32 1
  %216 = load i64, i64* %215
  %217 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %216, i64* %217
  ret void
}

define void @dbFetch(i64, i64) {
$1:
; # (let Nm (val (tail Sym)) (when (and (num? Nm) (prog (setq Nm (add...
; # (tail Sym)
  %2 = add i64 %1, -8
; # (val (tail Sym))
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (when (and (num? Nm) (prog (setq Nm (add Nm Nm)) (not @@)) (prog ...
; # (and (num? Nm) (prog (setq Nm (add Nm Nm)) (not @@)) (prog (setq ...
; # (num? Nm)
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$3:
  %7 = phi i64 [%4, %$1] ; # Nm
; # (add Nm Nm)
  %8 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %7, i64 %7)
  %9 = extractvalue {i64, i1} %8, 1
  %10 = extractvalue {i64, i1} %8, 0
; # (not @@)
  %11 = icmp eq i1 %9, 0
  br i1 %11, label %$4, label %$2
$4:
  %12 = phi i64 [%10, %$3] ; # Nm
; # (add Nm Nm)
  %13 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %12, i64 %12)
  %14 = extractvalue {i64, i1} %13, 1
  %15 = extractvalue {i64, i1} %13, 0
; # (not @@)
  %16 = icmp eq i1 %14, 0
  br label %$2
$2:
  %17 = phi i64 [%4, %$1], [%10, %$3], [%15, %$4] ; # Nm
  %18 = phi i1 [0, %$1], [0, %$3], [%16, %$4] ; # ->
  br i1 %18, label %$5, label %$6
$5:
  %19 = phi i64 [%17, %$2] ; # Nm
; # (set (tail Sym) (setq Nm (shr 1 Nm 2)))
; # (tail Sym)
  %20 = add i64 %1, -8
; # (shr 1 Nm 2)
  %21 = call i64 @llvm.fshr.i64(i64 1, i64 %19, i64 2)
  %22 = inttoptr i64 %20 to i64*
  store i64 %21, i64* %22
; # (db Exe Sym Nm)
  tail call void @db(i64 %0, i64 %1, i64 %21)
  br label %$6
$6:
  %23 = phi i64 [%17, %$2], [%21, %$5] ; # Nm
  ret void
}

define void @dbTouch(i64, i64) {
$1:
; # (let (Q (tail Sym) Nm (val Q)) (unless (num? Nm) (setq Nm (& Nm -...
; # (tail Sym)
  %2 = add i64 %1, -8
; # (val Q)
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
; # (unless (num? Nm) (setq Nm (& Nm -9)) (loop (setq Q (ofs Nm 1)) (...
; # (num? Nm)
  %5 = and i64 %4, 6
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%2, %$1] ; # Q
  %8 = phi i64 [%4, %$1] ; # Nm
; # (& Nm -9)
  %9 = and i64 %8, -9
; # (loop (setq Q (ofs Nm 1)) (? (num? (setq Nm (car Q)))))
  br label %$4
$4:
  %10 = phi i64 [%7, %$2], [%17, %$5] ; # Q
  %11 = phi i64 [%9, %$2], [%18, %$5] ; # Nm
; # (ofs Nm 1)
  %12 = add i64 %11, 1
; # (? (num? (setq Nm (car Q))))
; # (car Q)
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (num? (setq Nm (car Q)))
  %15 = and i64 %14, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$6, label %$5
$5:
  %17 = phi i64 [%12, %$4] ; # Q
  %18 = phi i64 [%14, %$4] ; # Nm
  br label %$4
$6:
  %19 = phi i64 [%12, %$4] ; # Q
  %20 = phi i64 [%14, %$4] ; # Nm
  %21 = phi i64 [0, %$4] ; # ->
  br label %$3
$3:
  %22 = phi i64 [%2, %$1], [%19, %$6] ; # Q
  %23 = phi i64 [%4, %$1], [%20, %$6] ; # Nm
; # (add Nm Nm)
  %24 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %23, i64 %23)
  %25 = extractvalue {i64, i1} %24, 1
  %26 = extractvalue {i64, i1} %24, 0
; # (unless @@ (setq Nm (add Nm Nm)) (set Q (setq Nm (shr 2 Nm 2))) (...
  br i1 %25, label %$8, label %$7
$7:
  %27 = phi i64 [%22, %$3] ; # Q
  %28 = phi i64 [%26, %$3] ; # Nm
; # (add Nm Nm)
  %29 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %28, i64 %28)
  %30 = extractvalue {i64, i1} %29, 1
  %31 = extractvalue {i64, i1} %29, 0
; # (set Q (setq Nm (shr 2 Nm 2)))
; # (shr 2 Nm 2)
  %32 = call i64 @llvm.fshr.i64(i64 2, i64 %31, i64 2)
  %33 = inttoptr i64 %27 to i64*
  store i64 %32, i64* %33
; # (unless @@ (tailcall (db Exe Sym Nm)))
  br i1 %30, label %$10, label %$9
$9:
  %34 = phi i64 [%27, %$7] ; # Q
  %35 = phi i64 [%32, %$7] ; # Nm
; # (db Exe Sym Nm)
  tail call void @db(i64 %0, i64 %1, i64 %35)
  br label %$10
$10:
  %36 = phi i64 [%27, %$7], [%34, %$9] ; # Q
  %37 = phi i64 [%32, %$7], [%35, %$9] ; # Nm
  br label %$8
$8:
  %38 = phi i64 [%22, %$3], [%36, %$10] ; # Q
  %39 = phi i64 [%26, %$3], [%37, %$10] ; # Nm
  ret void
}

define i64 @_touch(i64) {
$1:
; # (let X (eval (cadr Exe)) (when (and (symb? X) (sym? (val (tail X)...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (when (and (symb? X) (sym? (val (tail X)))) (dbTouch Exe X))
; # (and (symb? X) (sym? (val (tail X))))
; # (symb? X)
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$7
$8:
; # (tail X)
  %17 = add i64 %13, -8
; # (val (tail X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (sym? (val (tail X)))
  %20 = and i64 %19, 8
  %21 = icmp ne i64 %20, 0
  br label %$7
$7:
  %22 = phi i1 [0, %$2], [%21, %$8] ; # ->
  br i1 %22, label %$9, label %$10
$9:
; # (dbTouch Exe X)
  call void @dbTouch(i64 %0, i64 %13)
  br label %$10
$10:
  ret i64 %13
}

define void @dbZap(i64) {
$1:
; # (let Tail (val (tail Sym)) (unless (num? Tail) (setq Tail (& Tail...
; # (tail Sym)
  %1 = add i64 %0, -8
; # (val (tail Sym))
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (unless (num? Tail) (setq Tail (& Tail -9)) (loop (? (num? (shift...
; # (num? Tail)
  %4 = and i64 %3, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$3, label %$2
$2:
  %6 = phi i64 [%3, %$1] ; # Tail
; # (& Tail -9)
  %7 = and i64 %6, -9
; # (loop (? (num? (shift Tail))))
  br label %$4
$4:
  %8 = phi i64 [%7, %$2], [%14, %$5] ; # Tail
; # (? (num? (shift Tail)))
; # (shift Tail)
  %9 = inttoptr i64 %8 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (num? (shift Tail))
  %12 = and i64 %11, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$5:
  %14 = phi i64 [%11, %$4] ; # Tail
  br label %$4
$6:
  %15 = phi i64 [%11, %$4] ; # Tail
  %16 = phi i64 [0, %$4] ; # ->
; # (sym Tail)
  %17 = or i64 %15, 8
  br label %$3
$3:
  %18 = phi i64 [%3, %$1], [%17, %$6] ; # Tail
; # (set (tail Sym) (shr 3 (shl Tail 2) 2))
; # (tail Sym)
  %19 = add i64 %0, -8
; # (shl Tail 2)
  %20 = shl i64 %18, 2
; # (shr 3 (shl Tail 2) 2)
  %21 = call i64 @llvm.fshr.i64(i64 3, i64 %20, i64 2)
  %22 = inttoptr i64 %19 to i64*
  store i64 %21, i64* %22
; # (set Sym $Nil)
  %23 = inttoptr i64 %0 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %23
  ret void
}

define i64 @_commit(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Notify NO) (unless (val ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (unless (val $DbLog) (set $Protect (inc (val $Protect))))
; # (val $DbLog)
  %24 = load i8*, i8** @$DbLog
  %25 = icmp ne i8* %24, null
  br i1 %25, label %$8, label %$7
$7:
  %26 = phi i64 [%7, %$2] ; # X
  %27 = phi i64 [%15, %$2] ; # Y
  %28 = phi i1 [0, %$2] ; # Notify
; # (set $Protect (inc (val $Protect)))
; # (val $Protect)
  %29 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (inc (val $Protect))
  %30 = add i32 %29, 1
  store i32 %30, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  br label %$8
$8:
  %31 = phi i64 [%7, %$2], [%26, %$7] ; # X
  %32 = phi i64 [%15, %$2], [%27, %$7] ; # Y
  %33 = phi i1 [0, %$2], [%28, %$7] ; # Notify
; # (wrLockDb)
  call void @wrLockDb()
; # (when (val $DbJnl) (lockJnl))
; # (val $DbJnl)
  %34 = load i8*, i8** @$DbJnl
  %35 = icmp ne i8* %34, null
  br i1 %35, label %$9, label %$10
$9:
  %36 = phi i64 [%31, %$8] ; # X
  %37 = phi i64 [%32, %$8] ; # Y
  %38 = phi i1 [%33, %$8] ; # Notify
; # (lockJnl)
  call void @lockJnl()
  br label %$10
$10:
  %39 = phi i64 [%31, %$8], [%36, %$9] ; # X
  %40 = phi i64 [%32, %$8], [%37, %$9] ; # Y
  %41 = phi i1 [%33, %$8], [%38, %$9] ; # Notify
; # (when (val $DbLog) (let (P (val $DbFiles) C (val $DBs)) (loop ((d...
; # (val $DbLog)
  %42 = load i8*, i8** @$DbLog
  %43 = icmp ne i8* %42, null
  br i1 %43, label %$11, label %$12
$11:
  %44 = phi i64 [%39, %$10] ; # X
  %45 = phi i64 [%40, %$10] ; # Y
  %46 = phi i1 [%41, %$10] ; # Notify
; # (let (P (val $DbFiles) C (val $DBs)) (loop ((dbFile P) drt NO) ((...
; # (val $DbFiles)
  %47 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %48 = load i32, i32* @$DBs
; # (loop ((dbFile P) drt NO) ((dbFile P) flu 0) (? (=0 (dec 'C))) (s...
  br label %$13
$13:
  %49 = phi i64 [%44, %$11], [%60, %$14] ; # X
  %50 = phi i64 [%45, %$11], [%61, %$14] ; # Y
  %51 = phi i1 [%46, %$11], [%62, %$14] ; # Notify
  %52 = phi i8* [%47, %$11], [%65, %$14] ; # P
  %53 = phi i32 [%48, %$11], [%64, %$14] ; # C
; # ((dbFile P) drt NO)
  %54 = getelementptr i8, i8* %52, i32 41
  %55 = bitcast i8* %54 to i1*
  store i1 0, i1* %55
; # ((dbFile P) flu 0)
  %56 = getelementptr i8, i8* %52, i32 32
  %57 = bitcast i8* %56 to i64*
  store i64 0, i64* %57
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %58 = sub i32 %53, 1
; # (=0 (dec 'C))
  %59 = icmp eq i32 %58, 0
  br i1 %59, label %$15, label %$14
$14:
  %60 = phi i64 [%49, %$13] ; # X
  %61 = phi i64 [%50, %$13] ; # Y
  %62 = phi i1 [%51, %$13] ; # Notify
  %63 = phi i8* [%52, %$13] ; # P
  %64 = phi i32 [%58, %$13] ; # C
; # (ofs P (dbFile T))
  %65 = getelementptr i8, i8* %63, i32 42
  br label %$13
$15:
  %66 = phi i64 [%49, %$13] ; # X
  %67 = phi i64 [%50, %$13] ; # Y
  %68 = phi i1 [%51, %$13] ; # Notify
  %69 = phi i8* [%52, %$13] ; # P
  %70 = phi i32 [%58, %$13] ; # C
  %71 = phi i64 [0, %$13] ; # ->
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (cdr P) (? (atom ...
; # (val $Extern)
  %72 = load i64, i64* @$Extern
; # (loop (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @)...
  br label %$16
$16:
  %73 = phi i64 [%66, %$15], [%264, %$34] ; # X
  %74 = phi i64 [%67, %$15], [%265, %$34] ; # Y
  %75 = phi i1 [%68, %$15], [%266, %$34] ; # Notify
  %76 = phi i64 [0, %$15], [%267, %$34] ; # Tos
  %77 = phi i64 [%72, %$15], [%268, %$34] ; # P
; # (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set ...
  br label %$17
$17:
  %78 = phi i64 [%73, %$16], [%78, %$18] ; # X
  %79 = phi i64 [%74, %$16], [%91, %$18] ; # Y
  %80 = phi i1 [%75, %$16], [%92, %$18] ; # Notify
  %81 = phi i64 [%76, %$16], [%94, %$18] ; # Tos
  %82 = phi i64 [%77, %$16], [%87, %$18] ; # P
; # (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set X Tos)...
; # (cdr P)
  %83 = inttoptr i64 %82 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  %85 = load i64, i64* %84
; # (? (atom (car X)))
; # (car X)
  %86 = inttoptr i64 %85 to i64*
  %87 = load i64, i64* %86
; # (atom (car X))
  %88 = and i64 %87, 15
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$19, label %$18
$18:
  %90 = phi i64 [%85, %$17] ; # X
  %91 = phi i64 [%79, %$17] ; # Y
  %92 = phi i1 [%80, %$17] ; # Notify
  %93 = phi i64 [%81, %$17] ; # Tos
  %94 = phi i64 [%82, %$17] ; # P
; # (let Y P (setq P @) (set X Tos) (setq Tos Y))
; # (set X Tos)
  %95 = inttoptr i64 %90 to i64*
  store i64 %93, i64* %95
  br label %$17
$19:
  %96 = phi i64 [%85, %$17] ; # X
  %97 = phi i64 [%79, %$17] ; # Y
  %98 = phi i1 [%80, %$17] ; # Notify
  %99 = phi i64 [%81, %$17] ; # Tos
  %100 = phi i64 [%82, %$17] ; # P
  %101 = phi i64 [0, %$17] ; # ->
; # (loop (let (Nm (name (& (val (tail (val P))) -9)) N (add Nm Nm)) ...
  br label %$20
$20:
  %102 = phi i64 [%96, %$19], [%258, %$40] ; # X
  %103 = phi i64 [%97, %$19], [%259, %$40] ; # Y
  %104 = phi i1 [%98, %$19], [%260, %$40] ; # Notify
  %105 = phi i64 [%99, %$19], [%261, %$40] ; # Tos
  %106 = phi i64 [%100, %$19], [%262, %$40] ; # P
; # (let (Nm (name (& (val (tail (val P))) -9)) N (add Nm Nm)) (when ...
; # (val P)
  %107 = inttoptr i64 %106 to i64*
  %108 = load i64, i64* %107
; # (tail (val P))
  %109 = add i64 %108, -8
; # (val (tail (val P)))
  %110 = inttoptr i64 %109 to i64*
  %111 = load i64, i64* %110
; # (& (val (tail (val P))) -9)
  %112 = and i64 %111, -9
; # (name (& (val (tail (val P))) -9))
  br label %$21
$21:
  %113 = phi i64 [%112, %$20], [%119, %$22] ; # Tail
  %114 = and i64 %113, 6
  %115 = icmp ne i64 %114, 0
  br i1 %115, label %$23, label %$22
$22:
  %116 = phi i64 [%113, %$21] ; # Tail
  %117 = inttoptr i64 %116 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  %119 = load i64, i64* %118
  br label %$21
$23:
  %120 = phi i64 [%113, %$21] ; # Tail
; # (add Nm Nm)
  %121 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %120, i64 %120)
  %122 = extractvalue {i64, i1} %121, 1
  %123 = extractvalue {i64, i1} %121, 0
; # (when @@ (let F (objFile Nm) (when (> (val $DBs) F) (set $DbFile ...
  br i1 %122, label %$24, label %$25
$24:
  %124 = phi i64 [%102, %$23] ; # X
  %125 = phi i64 [%103, %$23] ; # Y
  %126 = phi i1 [%104, %$23] ; # Notify
  %127 = phi i64 [%105, %$23] ; # Tos
  %128 = phi i64 [%106, %$23] ; # P
; # (let F (objFile Nm) (when (> (val $DBs) F) (set $DbFile (ofs (val...
; # (objFile Nm)
  %129 = call i32 @objFile(i64 %120)
; # (when (> (val $DBs) F) (set $DbFile (ofs (val $DbFiles) (* F (dbF...
; # (val $DBs)
  %130 = load i32, i32* @$DBs
; # (> (val $DBs) F)
  %131 = icmp sgt i32 %130, %129
  br i1 %131, label %$26, label %$27
$26:
  %132 = phi i64 [%124, %$24] ; # X
  %133 = phi i64 [%125, %$24] ; # Y
  %134 = phi i1 [%126, %$24] ; # Notify
  %135 = phi i64 [%127, %$24] ; # Tos
  %136 = phi i64 [%128, %$24] ; # P
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %137 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %138 = mul i32 %129, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %139 = getelementptr i8, i8* %137, i32 %138
  store i8* %139, i8** @$DbFile
; # (objId Nm)
  %140 = call i64 @objId(i64 %120)
; # (shl (objId Nm) 6)
  %141 = shl i64 %140, 6
; # (rdBlock (shl (objId Nm) 6))
  %142 = call i8* @rdBlock(i64 %141)
; # (loop (logBlock) (? (=0 (val $BlkLink))) (rdBlock @))
  br label %$28
$28:
  %143 = phi i64 [%132, %$26], [%150, %$29] ; # X
  %144 = phi i64 [%133, %$26], [%151, %$29] ; # Y
  %145 = phi i1 [%134, %$26], [%152, %$29] ; # Notify
  %146 = phi i64 [%135, %$26], [%153, %$29] ; # Tos
  %147 = phi i64 [%136, %$26], [%154, %$29] ; # P
; # (logBlock)
  call void @logBlock()
; # (? (=0 (val $BlkLink)))
; # (val $BlkLink)
  %148 = load i64, i64* @$BlkLink
; # (=0 (val $BlkLink))
  %149 = icmp eq i64 %148, 0
  br i1 %149, label %$30, label %$29
$29:
  %150 = phi i64 [%143, %$28] ; # X
  %151 = phi i64 [%144, %$28] ; # Y
  %152 = phi i1 [%145, %$28] ; # Notify
  %153 = phi i64 [%146, %$28] ; # Tos
  %154 = phi i64 [%147, %$28] ; # P
; # (rdBlock @)
  %155 = call i8* @rdBlock(i64 %148)
  br label %$28
$30:
  %156 = phi i64 [%143, %$28] ; # X
  %157 = phi i64 [%144, %$28] ; # Y
  %158 = phi i1 [%145, %$28] ; # Notify
  %159 = phi i64 [%146, %$28] ; # Tos
  %160 = phi i64 [%147, %$28] ; # P
  %161 = phi i64 [0, %$28] ; # ->
; # (let Db: (dbFile (val $DbFile)) (Db: drt YES) (add N N) (unless @...
; # (val $DbFile)
  %162 = load i8*, i8** @$DbFile
; # (Db: drt YES)
  %163 = getelementptr i8, i8* %162, i32 41
  %164 = bitcast i8* %163 to i1*
  store i1 1, i1* %164
; # (add N N)
  %165 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %123, i64 %123)
  %166 = extractvalue {i64, i1} %165, 1
  %167 = extractvalue {i64, i1} %165, 0
; # (unless @@ (Db: flu (inc (Db: flu))))
  br i1 %166, label %$32, label %$31
$31:
  %168 = phi i64 [%156, %$30] ; # X
  %169 = phi i64 [%157, %$30] ; # Y
  %170 = phi i1 [%158, %$30] ; # Notify
  %171 = phi i64 [%159, %$30] ; # Tos
  %172 = phi i64 [%160, %$30] ; # P
; # (Db: flu (inc (Db: flu)))
  %173 = getelementptr i8, i8* %162, i32 32
  %174 = bitcast i8* %173 to i64*
  %175 = getelementptr i8, i8* %162, i32 32
  %176 = bitcast i8* %175 to i64*
  %177 = load i64, i64* %176
  %178 = add i64 %177, 1
  store i64 %178, i64* %174
  br label %$32
$32:
  %179 = phi i64 [%156, %$30], [%168, %$31] ; # X
  %180 = phi i64 [%157, %$30], [%169, %$31] ; # Y
  %181 = phi i1 [%158, %$30], [%170, %$31] ; # Notify
  %182 = phi i64 [%159, %$30], [%171, %$31] ; # Tos
  %183 = phi i64 [%160, %$30], [%172, %$31] ; # P
  br label %$27
$27:
  %184 = phi i64 [%124, %$24], [%179, %$32] ; # X
  %185 = phi i64 [%125, %$24], [%180, %$32] ; # Y
  %186 = phi i1 [%126, %$24], [%181, %$32] ; # Notify
  %187 = phi i64 [%127, %$24], [%182, %$32] ; # Tos
  %188 = phi i64 [%128, %$24], [%183, %$32] ; # P
  br label %$25
$25:
  %189 = phi i64 [%102, %$23], [%184, %$27] ; # X
  %190 = phi i64 [%103, %$23], [%185, %$27] ; # Y
  %191 = phi i1 [%104, %$23], [%186, %$27] ; # Notify
  %192 = phi i64 [%105, %$23], [%187, %$27] ; # Tos
  %193 = phi i64 [%106, %$23], [%188, %$27] ; # P
; # (let X (cdr P) (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos...
; # (cdr P)
  %194 = inttoptr i64 %193 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
; # (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos) (setq Tos (| ...
; # (cdr X)
  %197 = inttoptr i64 %196 to i64*
  %198 = getelementptr i64, i64* %197, i32 1
  %199 = load i64, i64* %198
; # (pair (cdr X))
  %200 = and i64 %199, 15
  %201 = icmp eq i64 %200, 0
  br i1 %201, label %$35, label %$33
$35:
  %202 = phi i64 [%196, %$25] ; # X
  %203 = phi i64 [%190, %$25] ; # Y
  %204 = phi i1 [%191, %$25] ; # Notify
  %205 = phi i64 [%192, %$25] ; # Tos
  %206 = phi i64 [%193, %$25] ; # P
; # (let Y P (setq P @) (set 2 X Tos) (setq Tos (| Y 8)))
; # (set 2 X Tos)
  %207 = inttoptr i64 %202 to i64*
  %208 = getelementptr i64, i64* %207, i32 1
  store i64 %205, i64* %208
; # (| Y 8)
  %209 = or i64 %206, 8
  br label %$34
$33:
  %210 = phi i64 [%196, %$25] ; # X
  %211 = phi i64 [%190, %$25] ; # Y
  %212 = phi i1 [%191, %$25] ; # Notify
  %213 = phi i64 [%192, %$25] ; # Tos
  %214 = phi i64 [%193, %$25] ; # P
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$36
$36:
  %215 = phi i64 [%189, %$33], [%244, %$39] ; # X
  %216 = phi i64 [%211, %$33], [%245, %$39] ; # Y
  %217 = phi i1 [%212, %$33], [%246, %$39] ; # Notify
  %218 = phi i64 [%213, %$33], [%255, %$39] ; # Tos
  %219 = phi i64 [%214, %$33], [%249, %$39] ; # P
; # (unless Tos (goto 1))
  %220 = icmp ne i64 %218, 0
  br i1 %220, label %$38, label %$37
$37:
  %221 = phi i64 [%215, %$36] ; # X
  %222 = phi i64 [%216, %$36] ; # Y
  %223 = phi i1 [%217, %$36] ; # Notify
  %224 = phi i64 [%218, %$36] ; # Tos
  %225 = phi i64 [%219, %$36] ; # P
; # (goto 1)
  br label %$-1
$38:
  %226 = phi i64 [%215, %$36] ; # X
  %227 = phi i64 [%216, %$36] ; # Y
  %228 = phi i1 [%217, %$36] ; # Notify
  %229 = phi i64 [%218, %$36] ; # Tos
  %230 = phi i64 [%219, %$36] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set ...
; # (& Tos 8)
  %231 = and i64 %229, 8
; # (=0 (& Tos 8))
  %232 = icmp eq i64 %231, 0
  br i1 %232, label %$41, label %$39
$41:
  %233 = phi i64 [%226, %$38] ; # X
  %234 = phi i64 [%227, %$38] ; # Y
  %235 = phi i1 [%228, %$38] ; # Notify
  %236 = phi i64 [%229, %$38] ; # Tos
  %237 = phi i64 [%230, %$38] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %238 = inttoptr i64 %236 to i64*
  %239 = getelementptr i64, i64* %238, i32 1
  %240 = load i64, i64* %239
; # (car Y)
  %241 = inttoptr i64 %240 to i64*
  %242 = load i64, i64* %241
; # (set Y P)
  %243 = inttoptr i64 %240 to i64*
  store i64 %237, i64* %243
  br label %$40
$39:
  %244 = phi i64 [%226, %$38] ; # X
  %245 = phi i64 [%227, %$38] ; # Y
  %246 = phi i1 [%228, %$38] ; # Notify
  %247 = phi i64 [%229, %$38] ; # Tos
  %248 = phi i64 [%230, %$38] ; # P
; # (& Tos -9)
  %249 = and i64 %247, -9
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %250 = inttoptr i64 %249 to i64*
  %251 = getelementptr i64, i64* %250, i32 1
  %252 = load i64, i64* %251
; # (cdr Y)
  %253 = inttoptr i64 %252 to i64*
  %254 = getelementptr i64, i64* %253, i32 1
  %255 = load i64, i64* %254
; # (set 2 Y P)
  %256 = inttoptr i64 %252 to i64*
  %257 = getelementptr i64, i64* %256, i32 1
  store i64 %248, i64* %257
  br label %$36
$40:
  %258 = phi i64 [%233, %$41] ; # X
  %259 = phi i64 [%234, %$41] ; # Y
  %260 = phi i1 [%235, %$41] ; # Notify
  %261 = phi i64 [%242, %$41] ; # Tos
  %262 = phi i64 [%236, %$41] ; # P
  %263 = phi i64 [%236, %$41] ; # ->
  br label %$20
$34:
  %264 = phi i64 [%202, %$35] ; # X
  %265 = phi i64 [%203, %$35] ; # Y
  %266 = phi i1 [%204, %$35] ; # Notify
  %267 = phi i64 [%209, %$35] ; # Tos
  %268 = phi i64 [%199, %$35] ; # P
  %269 = phi i64 [%209, %$35] ; # ->
  br label %$16
$42:
; # (: 1 (let (P (val $DbFiles) C (val $DBs)) (loop (when ((dbFile P)...
  br label %$-1
$-1:
  %270 = phi i64 [%221, %$37], [%264, %$42] ; # X
  %271 = phi i64 [%222, %$37], [%265, %$42] ; # Y
  %272 = phi i1 [%223, %$37], [%266, %$42] ; # Notify
; # (let (P (val $DbFiles) C (val $DBs)) (loop (when ((dbFile P) flu)...
; # (val $DbFiles)
  %273 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %274 = load i32, i32* @$DBs
; # (loop (when ((dbFile P) flu) (let N @ (set $DbFile P) (rdBlock 0)...
  br label %$43
$43:
  %275 = phi i64 [%270, %$-1], [%327, %$50] ; # X
  %276 = phi i64 [%271, %$-1], [%328, %$50] ; # Y
  %277 = phi i1 [%272, %$-1], [%329, %$50] ; # Notify
  %278 = phi i8* [%273, %$-1], [%332, %$50] ; # P
  %279 = phi i32 [%274, %$-1], [%331, %$50] ; # C
; # (when ((dbFile P) flu) (let N @ (set $DbFile P) (rdBlock 0) (loop...
; # ((dbFile P) flu)
  %280 = getelementptr i8, i8* %278, i32 32
  %281 = bitcast i8* %280 to i64*
  %282 = load i64, i64* %281
  %283 = icmp ne i64 %282, 0
  br i1 %283, label %$44, label %$45
$44:
  %284 = phi i64 [%275, %$43] ; # X
  %285 = phi i64 [%276, %$43] ; # Y
  %286 = phi i1 [%277, %$43] ; # Notify
  %287 = phi i8* [%278, %$43] ; # P
  %288 = phi i32 [%279, %$43] ; # C
; # (let N @ (set $DbFile P) (rdBlock 0) (loop (logBlock) (? (=0 (dec...
; # (set $DbFile P)
  store i8* %287, i8** @$DbFile
; # (rdBlock 0)
  %289 = call i8* @rdBlock(i64 0)
; # (loop (logBlock) (? (=0 (dec 'N))) (? (=0 (val $BlkLink))) (rdBlo...
  br label %$46
$46:
  %290 = phi i64 [%284, %$44], [%306, %$49] ; # X
  %291 = phi i64 [%285, %$44], [%307, %$49] ; # Y
  %292 = phi i1 [%286, %$44], [%308, %$49] ; # Notify
  %293 = phi i8* [%287, %$44], [%309, %$49] ; # P
  %294 = phi i32 [%288, %$44], [%310, %$49] ; # C
  %295 = phi i64 [%282, %$44], [%311, %$49] ; # N
; # (logBlock)
  call void @logBlock()
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %296 = sub i64 %295, 1
; # (=0 (dec 'N))
  %297 = icmp eq i64 %296, 0
  br i1 %297, label %$48, label %$47
$47:
  %298 = phi i64 [%290, %$46] ; # X
  %299 = phi i64 [%291, %$46] ; # Y
  %300 = phi i1 [%292, %$46] ; # Notify
  %301 = phi i8* [%293, %$46] ; # P
  %302 = phi i32 [%294, %$46] ; # C
  %303 = phi i64 [%296, %$46] ; # N
; # (? (=0 (val $BlkLink)))
; # (val $BlkLink)
  %304 = load i64, i64* @$BlkLink
; # (=0 (val $BlkLink))
  %305 = icmp eq i64 %304, 0
  br i1 %305, label %$48, label %$49
$49:
  %306 = phi i64 [%298, %$47] ; # X
  %307 = phi i64 [%299, %$47] ; # Y
  %308 = phi i1 [%300, %$47] ; # Notify
  %309 = phi i8* [%301, %$47] ; # P
  %310 = phi i32 [%302, %$47] ; # C
  %311 = phi i64 [%303, %$47] ; # N
; # (rdBlock @)
  %312 = call i8* @rdBlock(i64 %304)
  br label %$46
$48:
  %313 = phi i64 [%290, %$46], [%298, %$47] ; # X
  %314 = phi i64 [%291, %$46], [%299, %$47] ; # Y
  %315 = phi i1 [%292, %$46], [%300, %$47] ; # Notify
  %316 = phi i8* [%293, %$46], [%301, %$47] ; # P
  %317 = phi i32 [%294, %$46], [%302, %$47] ; # C
  %318 = phi i64 [%296, %$46], [%303, %$47] ; # N
  %319 = phi i64 [0, %$46], [0, %$47] ; # ->
  br label %$45
$45:
  %320 = phi i64 [%275, %$43], [%313, %$48] ; # X
  %321 = phi i64 [%276, %$43], [%314, %$48] ; # Y
  %322 = phi i1 [%277, %$43], [%315, %$48] ; # Notify
  %323 = phi i8* [%278, %$43], [%316, %$48] ; # P
  %324 = phi i32 [%279, %$43], [%317, %$48] ; # C
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %325 = sub i32 %324, 1
; # (=0 (dec 'C))
  %326 = icmp eq i32 %325, 0
  br i1 %326, label %$51, label %$50
$50:
  %327 = phi i64 [%320, %$45] ; # X
  %328 = phi i64 [%321, %$45] ; # Y
  %329 = phi i1 [%322, %$45] ; # Notify
  %330 = phi i8* [%323, %$45] ; # P
  %331 = phi i32 [%325, %$45] ; # C
; # (ofs P (dbFile T))
  %332 = getelementptr i8, i8* %330, i32 42
  br label %$43
$51:
  %333 = phi i64 [%320, %$45] ; # X
  %334 = phi i64 [%321, %$45] ; # Y
  %335 = phi i1 [%322, %$45] ; # Notify
  %336 = phi i8* [%323, %$45] ; # P
  %337 = phi i32 [%325, %$45] ; # C
  %338 = phi i64 [0, %$45] ; # ->
; # (let Log (val $DbLog) (putc_unlocked (hex "FF") Log) (putc_unlock...
; # (val $DbLog)
  %339 = load i8*, i8** @$DbLog
; # (putc_unlocked (hex "FF") Log)
  %340 = call i32 @putc_unlocked(i32 255, i8* %339)
; # (putc_unlocked (hex "FF") Log)
  %341 = call i32 @putc_unlocked(i32 255, i8* %339)
; # (fflush Log)
  %342 = call i32 @fflush(i8* %339)
; # (when (lt0 (fsync (fileno Log))) (err Exe 0 ($ "Transaction fsync...
; # (fileno Log)
  %343 = call i32 @fileno(i8* %339)
; # (fsync (fileno Log))
  %344 = call i32 @fsync(i32 %343)
; # (lt0 (fsync (fileno Log)))
  %345 = icmp slt i32 %344, 0
  br i1 %345, label %$52, label %$53
$52:
  %346 = phi i64 [%333, %$51] ; # X
  %347 = phi i64 [%334, %$51] ; # Y
  %348 = phi i1 [%335, %$51] ; # Notify
; # (strErrno)
  %349 = call i8* @strErrno()
; # (err Exe 0 ($ "Transaction fsync error: %s") (strErrno))
  call void @err(i64 %0, i64 0, i8* bitcast ([28 x i8]* @$59 to i8*), i8* %349)
  unreachable
$53:
  %350 = phi i64 [%333, %$51] ; # X
  %351 = phi i64 [%334, %$51] ; # Y
  %352 = phi i1 [%335, %$51] ; # Notify
  br label %$12
$12:
  %353 = phi i64 [%39, %$10], [%350, %$53] ; # X
  %354 = phi i64 [%40, %$10], [%351, %$53] ; # Y
  %355 = phi i1 [%41, %$10], [%352, %$53] ; # Notify
; # (++ X)
  %356 = inttoptr i64 %353 to i64*
  %357 = load i64, i64* %356
  %358 = getelementptr i64, i64* %356, i32 1
  %359 = load i64, i64* %358
; # (eval (++ X))
  %360 = and i64 %357, 6
  %361 = icmp ne i64 %360, 0
  br i1 %361, label %$56, label %$55
$56:
  br label %$54
$55:
  %362 = and i64 %357, 8
  %363 = icmp ne i64 %362, 0
  br i1 %363, label %$58, label %$57
$58:
  %364 = inttoptr i64 %357 to i64*
  %365 = load i64, i64* %364
  br label %$54
$57:
  %366 = call i64 @evList(i64 %357)
  br label %$54
$54:
  %367 = phi i64 [%357, %$56], [%365, %$58], [%366, %$57] ; # ->
; # (when (and (not (nil? Y)) (or (val $Tell) (val $Children))) (setq...
; # (and (not (nil? Y)) (or (val $Tell) (val $Children)))
; # (nil? Y)
  %368 = icmp eq i64 %354, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %369 = icmp eq i1 %368, 0
  br i1 %369, label %$60, label %$59
$60:
  %370 = phi i64 [%359, %$54] ; # X
  %371 = phi i64 [%354, %$54] ; # Y
  %372 = phi i1 [%355, %$54] ; # Notify
; # (or (val $Tell) (val $Children))
; # (val $Tell)
  %373 = load i32, i32* @$Tell
  %374 = icmp ne i32 %373, 0
  br i1 %374, label %$61, label %$62
$62:
  %375 = phi i64 [%370, %$60] ; # X
  %376 = phi i64 [%371, %$60] ; # Y
  %377 = phi i1 [%372, %$60] ; # Notify
; # (val $Children)
  %378 = load i64, i64* @$Children
  %379 = icmp ne i64 %378, 0
  br label %$61
$61:
  %380 = phi i64 [%370, %$60], [%375, %$62] ; # X
  %381 = phi i64 [%371, %$60], [%376, %$62] ; # Y
  %382 = phi i1 [%372, %$60], [%377, %$62] ; # Notify
  %383 = phi i1 [1, %$60], [%379, %$62] ; # ->
  br label %$59
$59:
  %384 = phi i64 [%359, %$54], [%380, %$61] ; # X
  %385 = phi i64 [%354, %$54], [%381, %$61] ; # Y
  %386 = phi i1 [%355, %$54], [%382, %$61] ; # Notify
  %387 = phi i1 [0, %$54], [%383, %$61] ; # ->
  br i1 %387, label %$63, label %$64
$63:
  %388 = phi i64 [%384, %$59] ; # X
  %389 = phi i64 [%385, %$59] ; # Y
  %390 = phi i1 [%386, %$59] ; # Notify
; # (set $BufX (val $TellBuf) $PtrX (val $Ptr) $EndX (val $End))
; # (val $TellBuf)
  %391 = load i8*, i8** @$TellBuf
  store i8* %391, i8** @$BufX
; # (val $Ptr)
  %392 = load i8*, i8** @$Ptr
  store i8* %392, i8** @$PtrX
; # (val $End)
  %393 = load i8*, i8** @$End
  store i8* %393, i8** @$EndX
; # (val PipeBufSize)
  %394 = load i64, i64* @PipeBufSize
; # (b8 (val PipeBufSize))
  %395 = alloca i8, i64 %394
; # (tellBeg (b8 (val PipeBufSize)))
  call void @tellBeg(i8* %395)
; # (stkChk Exe)
  %396 = load i8*, i8** @$StkLimit
  %397 = call i8* @llvm.stacksave()
  %398 = icmp ugt i8* %396, %397
  br i1 %398, label %$65, label %$66
$65:
  call void @stkErr(i64 %0)
  unreachable
$66:
; # (prTell Y)
  call void @prTell(i64 %389)
  br label %$64
$64:
  %399 = phi i64 [%384, %$59], [%388, %$66] ; # X
  %400 = phi i64 [%385, %$59], [%389, %$66] ; # Y
  %401 = phi i1 [%386, %$59], [1, %$66] ; # Notify
; # (let (Tos 0 P (val $Extern)) (loop (loop (let X (cdr P) (? (atom ...
; # (val $Extern)
  %402 = load i64, i64* @$Extern
; # (loop (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @)...
  br label %$67
$67:
  %403 = phi i64 [%399, %$64], [%841, %$107] ; # X
  %404 = phi i64 [%400, %$64], [%842, %$107] ; # Y
  %405 = phi i1 [%401, %$64], [%843, %$107] ; # Notify
  %406 = phi i64 [0, %$64], [%844, %$107] ; # Tos
  %407 = phi i64 [%402, %$64], [%845, %$107] ; # P
; # (loop (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set ...
  br label %$68
$68:
  %408 = phi i64 [%403, %$67], [%408, %$69] ; # X
  %409 = phi i64 [%404, %$67], [%421, %$69] ; # Y
  %410 = phi i1 [%405, %$67], [%422, %$69] ; # Notify
  %411 = phi i64 [%406, %$67], [%424, %$69] ; # Tos
  %412 = phi i64 [%407, %$67], [%417, %$69] ; # P
; # (let X (cdr P) (? (atom (car X))) (let Y P (setq P @) (set X Tos)...
; # (cdr P)
  %413 = inttoptr i64 %412 to i64*
  %414 = getelementptr i64, i64* %413, i32 1
  %415 = load i64, i64* %414
; # (? (atom (car X)))
; # (car X)
  %416 = inttoptr i64 %415 to i64*
  %417 = load i64, i64* %416
; # (atom (car X))
  %418 = and i64 %417, 15
  %419 = icmp ne i64 %418, 0
  br i1 %419, label %$70, label %$69
$69:
  %420 = phi i64 [%415, %$68] ; # X
  %421 = phi i64 [%409, %$68] ; # Y
  %422 = phi i1 [%410, %$68] ; # Notify
  %423 = phi i64 [%411, %$68] ; # Tos
  %424 = phi i64 [%412, %$68] ; # P
; # (let Y P (setq P @) (set X Tos) (setq Tos Y))
; # (set X Tos)
  %425 = inttoptr i64 %420 to i64*
  store i64 %423, i64* %425
  br label %$68
$70:
  %426 = phi i64 [%415, %$68] ; # X
  %427 = phi i64 [%409, %$68] ; # Y
  %428 = phi i1 [%410, %$68] ; # Notify
  %429 = phi i64 [%411, %$68] ; # Tos
  %430 = phi i64 [%412, %$68] ; # P
  %431 = phi i64 [0, %$68] ; # ->
; # (loop (let (S (val P) Q (tail S) Nm (val Q)) (unless (num? Nm) (s...
  br label %$71
$71:
  %432 = phi i64 [%426, %$70], [%835, %$113] ; # X
  %433 = phi i64 [%427, %$70], [%836, %$113] ; # Y
  %434 = phi i1 [%428, %$70], [%837, %$113] ; # Notify
  %435 = phi i64 [%429, %$70], [%838, %$113] ; # Tos
  %436 = phi i64 [%430, %$70], [%839, %$113] ; # P
; # (let (S (val P) Q (tail S) Nm (val Q)) (unless (num? Nm) (setq Nm...
; # (val P)
  %437 = inttoptr i64 %436 to i64*
  %438 = load i64, i64* %437
; # (tail S)
  %439 = add i64 %438, -8
; # (val Q)
  %440 = inttoptr i64 %439 to i64*
  %441 = load i64, i64* %440
; # (unless (num? Nm) (setq Nm (& Nm -9)) (loop (setq Q (ofs Nm 1)) (...
; # (num? Nm)
  %442 = and i64 %441, 6
  %443 = icmp ne i64 %442, 0
  br i1 %443, label %$73, label %$72
$72:
  %444 = phi i64 [%432, %$71] ; # X
  %445 = phi i64 [%433, %$71] ; # Y
  %446 = phi i1 [%434, %$71] ; # Notify
  %447 = phi i64 [%435, %$71] ; # Tos
  %448 = phi i64 [%436, %$71] ; # P
  %449 = phi i64 [%439, %$71] ; # Q
  %450 = phi i64 [%441, %$71] ; # Nm
; # (& Nm -9)
  %451 = and i64 %450, -9
; # (loop (setq Q (ofs Nm 1)) (? (num? (setq Nm (car Q)))))
  br label %$74
$74:
  %452 = phi i64 [%444, %$72], [%464, %$75] ; # X
  %453 = phi i64 [%445, %$72], [%465, %$75] ; # Y
  %454 = phi i1 [%446, %$72], [%466, %$75] ; # Notify
  %455 = phi i64 [%447, %$72], [%467, %$75] ; # Tos
  %456 = phi i64 [%448, %$72], [%468, %$75] ; # P
  %457 = phi i64 [%449, %$72], [%469, %$75] ; # Q
  %458 = phi i64 [%451, %$72], [%470, %$75] ; # Nm
; # (ofs Nm 1)
  %459 = add i64 %458, 1
; # (? (num? (setq Nm (car Q))))
; # (car Q)
  %460 = inttoptr i64 %459 to i64*
  %461 = load i64, i64* %460
; # (num? (setq Nm (car Q)))
  %462 = and i64 %461, 6
  %463 = icmp ne i64 %462, 0
  br i1 %463, label %$76, label %$75
$75:
  %464 = phi i64 [%452, %$74] ; # X
  %465 = phi i64 [%453, %$74] ; # Y
  %466 = phi i1 [%454, %$74] ; # Notify
  %467 = phi i64 [%455, %$74] ; # Tos
  %468 = phi i64 [%456, %$74] ; # P
  %469 = phi i64 [%459, %$74] ; # Q
  %470 = phi i64 [%461, %$74] ; # Nm
  br label %$74
$76:
  %471 = phi i64 [%452, %$74] ; # X
  %472 = phi i64 [%453, %$74] ; # Y
  %473 = phi i1 [%454, %$74] ; # Notify
  %474 = phi i64 [%455, %$74] ; # Tos
  %475 = phi i64 [%456, %$74] ; # P
  %476 = phi i64 [%459, %$74] ; # Q
  %477 = phi i64 [%461, %$74] ; # Nm
  %478 = phi i64 [0, %$74] ; # ->
  br label %$73
$73:
  %479 = phi i64 [%432, %$71], [%471, %$76] ; # X
  %480 = phi i64 [%433, %$71], [%472, %$76] ; # Y
  %481 = phi i1 [%434, %$71], [%473, %$76] ; # Notify
  %482 = phi i64 [%435, %$71], [%474, %$76] ; # Tos
  %483 = phi i64 [%436, %$71], [%475, %$76] ; # P
  %484 = phi i64 [%439, %$71], [%476, %$76] ; # Q
  %485 = phi i64 [%441, %$71], [%477, %$76] ; # Nm
; # (let N (add Nm Nm) (when @@ (let F (objFile Nm) (add N N) (cond (...
; # (add Nm Nm)
  %486 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %485, i64 %485)
  %487 = extractvalue {i64, i1} %486, 1
  %488 = extractvalue {i64, i1} %486, 0
; # (when @@ (let F (objFile Nm) (add N N) (cond (@@ (set Q (shr N 2)...
  br i1 %487, label %$77, label %$78
$77:
  %489 = phi i64 [%479, %$73] ; # X
  %490 = phi i64 [%480, %$73] ; # Y
  %491 = phi i1 [%481, %$73] ; # Notify
  %492 = phi i64 [%482, %$73] ; # Tos
  %493 = phi i64 [%483, %$73] ; # P
  %494 = phi i64 [%484, %$73] ; # Q
  %495 = phi i64 [%485, %$73] ; # Nm
; # (let F (objFile Nm) (add N N) (cond (@@ (set Q (shr N 2)) (when (...
; # (objFile Nm)
  %496 = call i32 @objFile(i64 %495)
; # (add N N)
  %497 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %488, i64 %488)
  %498 = extractvalue {i64, i1} %497, 1
  %499 = extractvalue {i64, i1} %497, 0
; # (cond (@@ (set Q (shr N 2)) (when (> (val $DBs) F) (set $DbFile (...
  br i1 %498, label %$81, label %$80
$81:
  %500 = phi i64 [%489, %$77] ; # X
  %501 = phi i64 [%490, %$77] ; # Y
  %502 = phi i1 [%491, %$77] ; # Notify
  %503 = phi i64 [%492, %$77] ; # Tos
  %504 = phi i64 [%493, %$77] ; # P
  %505 = phi i64 [%494, %$77] ; # Q
  %506 = phi i64 [%495, %$77] ; # Nm
; # (set Q (shr N 2))
; # (shr N 2)
  %507 = lshr i64 %488, 2
  %508 = inttoptr i64 %505 to i64*
  store i64 %507, i64* %508
; # (when (> (val $DBs) F) (set $DbFile (ofs (val $DbFiles) (* F (dbF...
; # (val $DBs)
  %509 = load i32, i32* @$DBs
; # (> (val $DBs) F)
  %510 = icmp sgt i32 %509, %496
  br i1 %510, label %$82, label %$83
$82:
  %511 = phi i64 [%500, %$81] ; # X
  %512 = phi i64 [%501, %$81] ; # Y
  %513 = phi i1 [%502, %$81] ; # Notify
  %514 = phi i64 [%503, %$81] ; # Tos
  %515 = phi i64 [%504, %$81] ; # P
  %516 = phi i64 [%505, %$81] ; # Q
  %517 = phi i64 [%506, %$81] ; # Nm
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %518 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %519 = mul i32 %496, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %520 = getelementptr i8, i8* %518, i32 %519
  store i8* %520, i8** @$DbFile
; # (i64 F)
  %521 = sext i32 %496 to i64
; # (shl (i64 F) 6)
  %522 = shl i64 %521, 6
; # (cleanUp (shl (i64 F) 6))
  call void @cleanUp(i64 %522)
; # (when Notify (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (-...
  br i1 %513, label %$84, label %$85
$84:
  %523 = phi i64 [%511, %$82] ; # X
  %524 = phi i64 [%512, %$82] ; # Y
  %525 = phi i1 [%513, %$82] ; # Notify
  %526 = phi i64 [%514, %$82] ; # Tos
  %527 = phi i64 [%515, %$82] ; # P
  %528 = phi i64 [%516, %$82] ; # Q
  %529 = phi i64 [%517, %$82] ; # Nm
; # (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (- (val PipeBuf...
; # (val $TellBuf)
  %530 = load i8*, i8** @$TellBuf
; # (when (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10))) (tellEnd 0...
; # (val $Ptr)
  %531 = load i8*, i8** @$Ptr
; # (val PipeBufSize)
  %532 = load i64, i64* @PipeBufSize
; # (- (val PipeBufSize) 10)
  %533 = sub i64 %532, 10
; # (ofs P (- (val PipeBufSize) 10))
  %534 = getelementptr i8, i8* %530, i64 %533
; # (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10)))
  %535 = icmp uge i8* %531, %534
  br i1 %535, label %$86, label %$87
$86:
  %536 = phi i64 [%523, %$84] ; # X
  %537 = phi i64 [%524, %$84] ; # Y
  %538 = phi i1 [%525, %$84] ; # Notify
  %539 = phi i64 [%526, %$84] ; # Tos
  %540 = phi i64 [%528, %$84] ; # Q
  %541 = phi i64 [%529, %$84] ; # Nm
  %542 = phi i8* [%530, %$84] ; # P
; # (tellEnd 0)
  call void @tellEnd(i32 0)
; # (set (inc 'P 8) BEG $Ptr (inc P))
; # (inc 'P 8)
  %543 = getelementptr i8, i8* %542, i32 8
  store i8 1, i8* %543
; # (inc P)
  %544 = getelementptr i8, i8* %543, i32 1
  store i8* %544, i8** @$Ptr
; # (prTell Y)
  call void @prTell(i64 %537)
  br label %$87
$87:
  %545 = phi i64 [%523, %$84], [%536, %$86] ; # X
  %546 = phi i64 [%524, %$84], [%537, %$86] ; # Y
  %547 = phi i1 [%525, %$84], [%538, %$86] ; # Notify
  %548 = phi i64 [%526, %$84], [%539, %$86] ; # Tos
  %549 = phi i64 [%528, %$84], [%540, %$86] ; # Q
  %550 = phi i64 [%529, %$84], [%541, %$86] ; # Nm
  %551 = phi i8* [%530, %$84], [%543, %$86] ; # P
; # (prTell S)
  call void @prTell(i64 %438)
  br label %$85
$85:
  %552 = phi i64 [%511, %$82], [%545, %$87] ; # X
  %553 = phi i64 [%512, %$82], [%546, %$87] ; # Y
  %554 = phi i1 [%513, %$82], [%547, %$87] ; # Notify
  %555 = phi i64 [%514, %$82], [%548, %$87] ; # Tos
  %556 = phi i64 [%515, %$82], [%527, %$87] ; # P
  %557 = phi i64 [%516, %$82], [%549, %$87] ; # Q
  %558 = phi i64 [%517, %$82], [%550, %$87] ; # Nm
  br label %$83
$83:
  %559 = phi i64 [%500, %$81], [%552, %$85] ; # X
  %560 = phi i64 [%501, %$81], [%553, %$85] ; # Y
  %561 = phi i1 [%502, %$81], [%554, %$85] ; # Notify
  %562 = phi i64 [%503, %$81], [%555, %$85] ; # Tos
  %563 = phi i64 [%504, %$81], [%556, %$85] ; # P
  %564 = phi i64 [%505, %$81], [%557, %$85] ; # Q
  %565 = phi i64 [%506, %$81], [%558, %$85] ; # Nm
  br label %$79
$80:
  %566 = phi i64 [%489, %$77] ; # X
  %567 = phi i64 [%490, %$77] ; # Y
  %568 = phi i1 [%491, %$77] ; # Notify
  %569 = phi i64 [%492, %$77] ; # Tos
  %570 = phi i64 [%493, %$77] ; # P
  %571 = phi i64 [%494, %$77] ; # Q
  %572 = phi i64 [%495, %$77] ; # Nm
; # (set Q (shr 1 N 2))
; # (shr 1 N 2)
  %573 = call i64 @llvm.fshr.i64(i64 1, i64 %488, i64 2)
  %574 = inttoptr i64 %571 to i64*
  store i64 %573, i64* %574
; # (when (> (val $DBs) F) (set $DbFile (ofs (val $DbFiles) (* F (dbF...
; # (val $DBs)
  %575 = load i32, i32* @$DBs
; # (> (val $DBs) F)
  %576 = icmp sgt i32 %575, %496
  br i1 %576, label %$88, label %$89
$88:
  %577 = phi i64 [%566, %$80] ; # X
  %578 = phi i64 [%567, %$80] ; # Y
  %579 = phi i1 [%568, %$80] ; # Notify
  %580 = phi i64 [%569, %$80] ; # Tos
  %581 = phi i64 [%570, %$80] ; # P
  %582 = phi i64 [%571, %$80] ; # Q
  %583 = phi i64 [%572, %$80] ; # Nm
; # (set $DbFile (ofs (val $DbFiles) (* F (dbFile T))))
; # (val $DbFiles)
  %584 = load i8*, i8** @$DbFiles
; # (* F (dbFile T))
  %585 = mul i32 %496, 42
; # (ofs (val $DbFiles) (* F (dbFile T)))
  %586 = getelementptr i8, i8* %584, i32 %585
  store i8* %586, i8** @$DbFile
; # (let Blk (ofs (rdBlock (shl (objId Nm) 6)) (- BLK)) (set Blk (| (...
; # (objId Nm)
  %587 = call i64 @objId(i64 %583)
; # (shl (objId Nm) 6)
  %588 = shl i64 %587, 6
; # (rdBlock (shl (objId Nm) 6))
  %589 = call i8* @rdBlock(i64 %588)
; # (- BLK)
; # (ofs (rdBlock (shl (objId Nm) 6)) (- BLK))
  %590 = getelementptr i8, i8* %589, i32 -6
; # (set Blk (| (val Blk) 1) $PutBin (fun (void i8) putBlock) $Extn 0...
; # (val Blk)
  %591 = load i8, i8* %590
; # (| (val Blk) 1)
  %592 = or i8 %591, 1
  store i8 %592, i8* %590
; # (fun (void i8) putBlock)
  store void(i8)* @putBlock, void(i8)** @$PutBin
  store i32 0, i32* @$Extn
; # (val S)
  %593 = inttoptr i64 %438 to i64*
  %594 = load i64, i64* %593
; # (binPrint (val S))
  call void @binPrint(i64 %594)
; # (let L (& (val (tail S)) -9) (until (num? L) (let V (++ L) (nond ...
; # (tail S)
  %595 = add i64 %438, -8
; # (val (tail S))
  %596 = inttoptr i64 %595 to i64*
  %597 = load i64, i64* %596
; # (& (val (tail S)) -9)
  %598 = and i64 %597, -9
; # (until (num? L) (let V (++ L) (nond ((atom V) (unless (nil? (cdr ...
  br label %$90
$90:
  %599 = phi i64 [%577, %$88], [%678, %$93] ; # X
  %600 = phi i64 [%578, %$88], [%679, %$93] ; # Y
  %601 = phi i1 [%579, %$88], [%680, %$93] ; # Notify
  %602 = phi i64 [%580, %$88], [%681, %$93] ; # Tos
  %603 = phi i64 [%581, %$88], [%682, %$93] ; # P
  %604 = phi i64 [%582, %$88], [%683, %$93] ; # Q
  %605 = phi i64 [%583, %$88], [%684, %$93] ; # Nm
  %606 = phi i64 [%598, %$88], [%685, %$93] ; # L
; # (num? L)
  %607 = and i64 %606, 6
  %608 = icmp ne i64 %607, 0
  br i1 %608, label %$92, label %$91
$91:
  %609 = phi i64 [%599, %$90] ; # X
  %610 = phi i64 [%600, %$90] ; # Y
  %611 = phi i1 [%601, %$90] ; # Notify
  %612 = phi i64 [%602, %$90] ; # Tos
  %613 = phi i64 [%603, %$90] ; # P
  %614 = phi i64 [%604, %$90] ; # Q
  %615 = phi i64 [%605, %$90] ; # Nm
  %616 = phi i64 [%606, %$90] ; # L
; # (let V (++ L) (nond ((atom V) (unless (nil? (cdr V)) (binPrint @)...
; # (++ L)
  %617 = inttoptr i64 %616 to i64*
  %618 = load i64, i64* %617
  %619 = getelementptr i64, i64* %617, i32 1
  %620 = load i64, i64* %619
; # (nond ((atom V) (unless (nil? (cdr V)) (binPrint @) (binPrint (ca...
; # (atom V)
  %621 = and i64 %618, 15
  %622 = icmp ne i64 %621, 0
  br i1 %622, label %$94, label %$95
$95:
  %623 = phi i64 [%609, %$91] ; # X
  %624 = phi i64 [%610, %$91] ; # Y
  %625 = phi i1 [%611, %$91] ; # Notify
  %626 = phi i64 [%612, %$91] ; # Tos
  %627 = phi i64 [%613, %$91] ; # P
  %628 = phi i64 [%614, %$91] ; # Q
  %629 = phi i64 [%615, %$91] ; # Nm
  %630 = phi i64 [%620, %$91] ; # L
; # (unless (nil? (cdr V)) (binPrint @) (binPrint (car V)))
; # (cdr V)
  %631 = inttoptr i64 %618 to i64*
  %632 = getelementptr i64, i64* %631, i32 1
  %633 = load i64, i64* %632
; # (nil? (cdr V))
  %634 = icmp eq i64 %633, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %634, label %$97, label %$96
$96:
  %635 = phi i64 [%623, %$95] ; # X
  %636 = phi i64 [%624, %$95] ; # Y
  %637 = phi i1 [%625, %$95] ; # Notify
  %638 = phi i64 [%626, %$95] ; # Tos
  %639 = phi i64 [%627, %$95] ; # P
  %640 = phi i64 [%628, %$95] ; # Q
  %641 = phi i64 [%629, %$95] ; # Nm
  %642 = phi i64 [%630, %$95] ; # L
; # (binPrint @)
  call void @binPrint(i64 %633)
; # (car V)
  %643 = inttoptr i64 %618 to i64*
  %644 = load i64, i64* %643
; # (binPrint (car V))
  call void @binPrint(i64 %644)
  br label %$97
$97:
  %645 = phi i64 [%623, %$95], [%635, %$96] ; # X
  %646 = phi i64 [%624, %$95], [%636, %$96] ; # Y
  %647 = phi i1 [%625, %$95], [%637, %$96] ; # Notify
  %648 = phi i64 [%626, %$95], [%638, %$96] ; # Tos
  %649 = phi i64 [%627, %$95], [%639, %$96] ; # P
  %650 = phi i64 [%628, %$95], [%640, %$96] ; # Q
  %651 = phi i64 [%629, %$95], [%641, %$96] ; # Nm
  %652 = phi i64 [%630, %$95], [%642, %$96] ; # L
  br label %$93
$94:
  %653 = phi i64 [%609, %$91] ; # X
  %654 = phi i64 [%610, %$91] ; # Y
  %655 = phi i1 [%611, %$91] ; # Notify
  %656 = phi i64 [%612, %$91] ; # Tos
  %657 = phi i64 [%613, %$91] ; # P
  %658 = phi i64 [%614, %$91] ; # Q
  %659 = phi i64 [%615, %$91] ; # Nm
  %660 = phi i64 [%620, %$91] ; # L
; # (nil? V)
  %661 = icmp eq i64 %618, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %661, label %$98, label %$99
$99:
  %662 = phi i64 [%653, %$94] ; # X
  %663 = phi i64 [%654, %$94] ; # Y
  %664 = phi i1 [%655, %$94] ; # Notify
  %665 = phi i64 [%656, %$94] ; # Tos
  %666 = phi i64 [%657, %$94] ; # P
  %667 = phi i64 [%658, %$94] ; # Q
  %668 = phi i64 [%659, %$94] ; # Nm
  %669 = phi i64 [%660, %$94] ; # L
; # (binPrint V)
  call void @binPrint(i64 %618)
; # (binPrint $T)
  call void @binPrint(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64))
  br label %$93
$98:
  %670 = phi i64 [%653, %$94] ; # X
  %671 = phi i64 [%654, %$94] ; # Y
  %672 = phi i1 [%655, %$94] ; # Notify
  %673 = phi i64 [%656, %$94] ; # Tos
  %674 = phi i64 [%657, %$94] ; # P
  %675 = phi i64 [%658, %$94] ; # Q
  %676 = phi i64 [%659, %$94] ; # Nm
  %677 = phi i64 [%660, %$94] ; # L
  br label %$93
$93:
  %678 = phi i64 [%645, %$97], [%662, %$99], [%670, %$98] ; # X
  %679 = phi i64 [%646, %$97], [%663, %$99], [%671, %$98] ; # Y
  %680 = phi i1 [%647, %$97], [%664, %$99], [%672, %$98] ; # Notify
  %681 = phi i64 [%648, %$97], [%665, %$99], [%673, %$98] ; # Tos
  %682 = phi i64 [%649, %$97], [%666, %$99], [%674, %$98] ; # P
  %683 = phi i64 [%650, %$97], [%667, %$99], [%675, %$98] ; # Q
  %684 = phi i64 [%651, %$97], [%668, %$99], [%676, %$98] ; # Nm
  %685 = phi i64 [%652, %$97], [%669, %$99], [%677, %$98] ; # L
  br label %$90
$92:
  %686 = phi i64 [%599, %$90] ; # X
  %687 = phi i64 [%600, %$90] ; # Y
  %688 = phi i1 [%601, %$90] ; # Notify
  %689 = phi i64 [%602, %$90] ; # Tos
  %690 = phi i64 [%603, %$90] ; # P
  %691 = phi i64 [%604, %$90] ; # Q
  %692 = phi i64 [%605, %$90] ; # Nm
  %693 = phi i64 [%606, %$90] ; # L
; # (putBlock NIX)
  call void @putBlock(i8 0)
; # (val $DbBlock)
  %694 = load i8*, i8** @$DbBlock
; # (val (val $DbBlock))
  %695 = load i8, i8* %694
; # (& (val (val $DbBlock)) BLKTAG)
  %696 = and i8 %695, 63
; # (i64 (& (val (val $DbBlock)) BLKTAG))
  %697 = zext i8 %696 to i64
; # (setAdr (i64 (& (val (val $DbBlock)) BLKTAG)) Blk)
  call void @setAdr(i64 %697, i8* %590)
; # (wrBlock)
  call void @wrBlock()
; # (when (val $BlkLink) (cleanUp @))
; # (val $BlkLink)
  %698 = load i64, i64* @$BlkLink
  %699 = icmp ne i64 %698, 0
  br i1 %699, label %$100, label %$101
$100:
  %700 = phi i64 [%686, %$92] ; # X
  %701 = phi i64 [%687, %$92] ; # Y
  %702 = phi i1 [%688, %$92] ; # Notify
  %703 = phi i64 [%689, %$92] ; # Tos
  %704 = phi i64 [%690, %$92] ; # P
  %705 = phi i64 [%691, %$92] ; # Q
  %706 = phi i64 [%692, %$92] ; # Nm
; # (cleanUp @)
  call void @cleanUp(i64 %698)
  br label %$101
$101:
  %707 = phi i64 [%686, %$92], [%700, %$100] ; # X
  %708 = phi i64 [%687, %$92], [%701, %$100] ; # Y
  %709 = phi i1 [%688, %$92], [%702, %$100] ; # Notify
  %710 = phi i64 [%689, %$92], [%703, %$100] ; # Tos
  %711 = phi i64 [%690, %$92], [%704, %$100] ; # P
  %712 = phi i64 [%691, %$92], [%705, %$100] ; # Q
  %713 = phi i64 [%692, %$92], [%706, %$100] ; # Nm
; # (when Notify (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (-...
  br i1 %709, label %$102, label %$103
$102:
  %714 = phi i64 [%707, %$101] ; # X
  %715 = phi i64 [%708, %$101] ; # Y
  %716 = phi i1 [%709, %$101] ; # Notify
  %717 = phi i64 [%710, %$101] ; # Tos
  %718 = phi i64 [%711, %$101] ; # P
  %719 = phi i64 [%712, %$101] ; # Q
  %720 = phi i64 [%713, %$101] ; # Nm
; # (let P (val $TellBuf) (when (>= (val $Ptr) (ofs P (- (val PipeBuf...
; # (val $TellBuf)
  %721 = load i8*, i8** @$TellBuf
; # (when (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10))) (tellEnd 0...
; # (val $Ptr)
  %722 = load i8*, i8** @$Ptr
; # (val PipeBufSize)
  %723 = load i64, i64* @PipeBufSize
; # (- (val PipeBufSize) 10)
  %724 = sub i64 %723, 10
; # (ofs P (- (val PipeBufSize) 10))
  %725 = getelementptr i8, i8* %721, i64 %724
; # (>= (val $Ptr) (ofs P (- (val PipeBufSize) 10)))
  %726 = icmp uge i8* %722, %725
  br i1 %726, label %$104, label %$105
$104:
  %727 = phi i64 [%714, %$102] ; # X
  %728 = phi i64 [%715, %$102] ; # Y
  %729 = phi i1 [%716, %$102] ; # Notify
  %730 = phi i64 [%717, %$102] ; # Tos
  %731 = phi i64 [%719, %$102] ; # Q
  %732 = phi i64 [%720, %$102] ; # Nm
  %733 = phi i8* [%721, %$102] ; # P
; # (tellEnd 0)
  call void @tellEnd(i32 0)
; # (set (inc 'P 8) BEG $Ptr (inc P))
; # (inc 'P 8)
  %734 = getelementptr i8, i8* %733, i32 8
  store i8 1, i8* %734
; # (inc P)
  %735 = getelementptr i8, i8* %734, i32 1
  store i8* %735, i8** @$Ptr
; # (prTell Y)
  call void @prTell(i64 %728)
  br label %$105
$105:
  %736 = phi i64 [%714, %$102], [%727, %$104] ; # X
  %737 = phi i64 [%715, %$102], [%728, %$104] ; # Y
  %738 = phi i1 [%716, %$102], [%729, %$104] ; # Notify
  %739 = phi i64 [%717, %$102], [%730, %$104] ; # Tos
  %740 = phi i64 [%719, %$102], [%731, %$104] ; # Q
  %741 = phi i64 [%720, %$102], [%732, %$104] ; # Nm
  %742 = phi i8* [%721, %$102], [%734, %$104] ; # P
; # (prTell S)
  call void @prTell(i64 %438)
  br label %$103
$103:
  %743 = phi i64 [%707, %$101], [%736, %$105] ; # X
  %744 = phi i64 [%708, %$101], [%737, %$105] ; # Y
  %745 = phi i1 [%709, %$101], [%738, %$105] ; # Notify
  %746 = phi i64 [%710, %$101], [%739, %$105] ; # Tos
  %747 = phi i64 [%711, %$101], [%718, %$105] ; # P
  %748 = phi i64 [%712, %$101], [%740, %$105] ; # Q
  %749 = phi i64 [%713, %$101], [%741, %$105] ; # Nm
  br label %$89
$89:
  %750 = phi i64 [%566, %$80], [%743, %$103] ; # X
  %751 = phi i64 [%567, %$80], [%744, %$103] ; # Y
  %752 = phi i1 [%568, %$80], [%745, %$103] ; # Notify
  %753 = phi i64 [%569, %$80], [%746, %$103] ; # Tos
  %754 = phi i64 [%570, %$80], [%747, %$103] ; # P
  %755 = phi i64 [%571, %$80], [%748, %$103] ; # Q
  %756 = phi i64 [%572, %$80], [%749, %$103] ; # Nm
  br label %$79
$79:
  %757 = phi i64 [%559, %$83], [%750, %$89] ; # X
  %758 = phi i64 [%560, %$83], [%751, %$89] ; # Y
  %759 = phi i1 [%561, %$83], [%752, %$89] ; # Notify
  %760 = phi i64 [%562, %$83], [%753, %$89] ; # Tos
  %761 = phi i64 [%563, %$83], [%754, %$89] ; # P
  %762 = phi i64 [%564, %$83], [%755, %$89] ; # Q
  %763 = phi i64 [%565, %$83], [%756, %$89] ; # Nm
  br label %$78
$78:
  %764 = phi i64 [%479, %$73], [%757, %$79] ; # X
  %765 = phi i64 [%480, %$73], [%758, %$79] ; # Y
  %766 = phi i1 [%481, %$73], [%759, %$79] ; # Notify
  %767 = phi i64 [%482, %$73], [%760, %$79] ; # Tos
  %768 = phi i64 [%483, %$73], [%761, %$79] ; # P
  %769 = phi i64 [%484, %$73], [%762, %$79] ; # Q
  %770 = phi i64 [%485, %$73], [%763, %$79] ; # Nm
; # (let X (cdr P) (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos...
; # (cdr P)
  %771 = inttoptr i64 %768 to i64*
  %772 = getelementptr i64, i64* %771, i32 1
  %773 = load i64, i64* %772
; # (? (pair (cdr X)) (let Y P (setq P @) (set 2 X Tos) (setq Tos (| ...
; # (cdr X)
  %774 = inttoptr i64 %773 to i64*
  %775 = getelementptr i64, i64* %774, i32 1
  %776 = load i64, i64* %775
; # (pair (cdr X))
  %777 = and i64 %776, 15
  %778 = icmp eq i64 %777, 0
  br i1 %778, label %$108, label %$106
$108:
  %779 = phi i64 [%773, %$78] ; # X
  %780 = phi i64 [%765, %$78] ; # Y
  %781 = phi i1 [%766, %$78] ; # Notify
  %782 = phi i64 [%767, %$78] ; # Tos
  %783 = phi i64 [%768, %$78] ; # P
; # (let Y P (setq P @) (set 2 X Tos) (setq Tos (| Y 8)))
; # (set 2 X Tos)
  %784 = inttoptr i64 %779 to i64*
  %785 = getelementptr i64, i64* %784, i32 1
  store i64 %782, i64* %785
; # (| Y 8)
  %786 = or i64 %783, 8
  br label %$107
$106:
  %787 = phi i64 [%773, %$78] ; # X
  %788 = phi i64 [%765, %$78] ; # Y
  %789 = phi i1 [%766, %$78] ; # Notify
  %790 = phi i64 [%767, %$78] ; # Tos
  %791 = phi i64 [%768, %$78] ; # P
; # (loop (unless Tos (goto 2)) (? (=0 (& Tos 8)) (let (X Tos Y (cdr ...
  br label %$109
$109:
  %792 = phi i64 [%764, %$106], [%821, %$112] ; # X
  %793 = phi i64 [%788, %$106], [%822, %$112] ; # Y
  %794 = phi i1 [%789, %$106], [%823, %$112] ; # Notify
  %795 = phi i64 [%790, %$106], [%832, %$112] ; # Tos
  %796 = phi i64 [%791, %$106], [%826, %$112] ; # P
; # (unless Tos (goto 2))
  %797 = icmp ne i64 %795, 0
  br i1 %797, label %$111, label %$110
$110:
  %798 = phi i64 [%792, %$109] ; # X
  %799 = phi i64 [%793, %$109] ; # Y
  %800 = phi i1 [%794, %$109] ; # Notify
  %801 = phi i64 [%795, %$109] ; # Tos
  %802 = phi i64 [%796, %$109] ; # P
; # (goto 2)
  br label %$-2
$111:
  %803 = phi i64 [%792, %$109] ; # X
  %804 = phi i64 [%793, %$109] ; # Y
  %805 = phi i1 [%794, %$109] ; # Notify
  %806 = phi i64 [%795, %$109] ; # Tos
  %807 = phi i64 [%796, %$109] ; # P
; # (? (=0 (& Tos 8)) (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set ...
; # (& Tos 8)
  %808 = and i64 %806, 8
; # (=0 (& Tos 8))
  %809 = icmp eq i64 %808, 0
  br i1 %809, label %$114, label %$112
$114:
  %810 = phi i64 [%803, %$111] ; # X
  %811 = phi i64 [%804, %$111] ; # Y
  %812 = phi i1 [%805, %$111] ; # Notify
  %813 = phi i64 [%806, %$111] ; # Tos
  %814 = phi i64 [%807, %$111] ; # P
; # (let (X Tos Y (cdr X)) (setq Tos (car Y)) (set Y P) (setq P X))
; # (cdr X)
  %815 = inttoptr i64 %813 to i64*
  %816 = getelementptr i64, i64* %815, i32 1
  %817 = load i64, i64* %816
; # (car Y)
  %818 = inttoptr i64 %817 to i64*
  %819 = load i64, i64* %818
; # (set Y P)
  %820 = inttoptr i64 %817 to i64*
  store i64 %814, i64* %820
  br label %$113
$112:
  %821 = phi i64 [%803, %$111] ; # X
  %822 = phi i64 [%804, %$111] ; # Y
  %823 = phi i1 [%805, %$111] ; # Notify
  %824 = phi i64 [%806, %$111] ; # Tos
  %825 = phi i64 [%807, %$111] ; # P
; # (& Tos -9)
  %826 = and i64 %824, -9
; # (let (X Tos Y (cdr X)) (setq Tos (cdr Y)) (set 2 Y P) (setq P X))...
; # (cdr X)
  %827 = inttoptr i64 %826 to i64*
  %828 = getelementptr i64, i64* %827, i32 1
  %829 = load i64, i64* %828
; # (cdr Y)
  %830 = inttoptr i64 %829 to i64*
  %831 = getelementptr i64, i64* %830, i32 1
  %832 = load i64, i64* %831
; # (set 2 Y P)
  %833 = inttoptr i64 %829 to i64*
  %834 = getelementptr i64, i64* %833, i32 1
  store i64 %825, i64* %834
  br label %$109
$113:
  %835 = phi i64 [%810, %$114] ; # X
  %836 = phi i64 [%811, %$114] ; # Y
  %837 = phi i1 [%812, %$114] ; # Notify
  %838 = phi i64 [%819, %$114] ; # Tos
  %839 = phi i64 [%813, %$114] ; # P
  %840 = phi i64 [%813, %$114] ; # ->
  br label %$71
$107:
  %841 = phi i64 [%779, %$108] ; # X
  %842 = phi i64 [%780, %$108] ; # Y
  %843 = phi i1 [%781, %$108] ; # Notify
  %844 = phi i64 [%786, %$108] ; # Tos
  %845 = phi i64 [%776, %$108] ; # P
  %846 = phi i64 [%786, %$108] ; # ->
  br label %$67
$115:
; # (: 2 (when Notify (tellEnd 0) (set $TellBuf (val $BufX) $Ptr (val...
  br label %$-2
$-2:
  %847 = phi i64 [%798, %$110], [%841, %$115] ; # X
  %848 = phi i64 [%799, %$110], [%842, %$115] ; # Y
  %849 = phi i1 [%800, %$110], [%843, %$115] ; # Notify
; # (when Notify (tellEnd 0) (set $TellBuf (val $BufX) $Ptr (val $Ptr...
  br i1 %849, label %$116, label %$117
$116:
  %850 = phi i64 [%847, %$-2] ; # X
  %851 = phi i64 [%848, %$-2] ; # Y
  %852 = phi i1 [%849, %$-2] ; # Notify
; # (tellEnd 0)
  call void @tellEnd(i32 0)
; # (set $TellBuf (val $BufX) $Ptr (val $PtrX) $End (val $EndX))
; # (val $BufX)
  %853 = load i8*, i8** @$BufX
  store i8* %853, i8** @$TellBuf
; # (val $PtrX)
  %854 = load i8*, i8** @$PtrX
  store i8* %854, i8** @$Ptr
; # (val $EndX)
  %855 = load i8*, i8** @$EndX
  store i8* %855, i8** @$End
  br label %$117
$117:
  %856 = phi i64 [%847, %$-2], [%850, %$116] ; # X
  %857 = phi i64 [%848, %$-2], [%851, %$116] ; # Y
  %858 = phi i1 [%849, %$-2], [%852, %$116] ; # Notify
; # (car X)
  %859 = inttoptr i64 %856 to i64*
  %860 = load i64, i64* %859
; # (eval (car X))
  %861 = and i64 %860, 6
  %862 = icmp ne i64 %861, 0
  br i1 %862, label %$120, label %$119
$120:
  br label %$118
$119:
  %863 = and i64 %860, 8
  %864 = icmp ne i64 %863, 0
  br i1 %864, label %$122, label %$121
$122:
  %865 = inttoptr i64 %860 to i64*
  %866 = load i64, i64* %865
  br label %$118
$121:
  %867 = call i64 @evList(i64 %860)
  br label %$118
$118:
  %868 = phi i64 [%860, %$120], [%866, %$122], [%867, %$121] ; # ->
; # (when (val $DbJnl) (unLockJnl))
; # (val $DbJnl)
  %869 = load i8*, i8** @$DbJnl
  %870 = icmp ne i8* %869, null
  br i1 %870, label %$123, label %$124
$123:
  %871 = phi i64 [%856, %$118] ; # X
  %872 = phi i64 [%857, %$118] ; # Y
  %873 = phi i1 [%858, %$118] ; # Notify
; # (unLockJnl)
  call void @unLockJnl()
  br label %$124
$124:
  %874 = phi i64 [%856, %$118], [%871, %$123] ; # X
  %875 = phi i64 [%857, %$118], [%872, %$123] ; # Y
  %876 = phi i1 [%858, %$118], [%873, %$123] ; # Notify
; # (when (pair (val $Zap)) (let (Z @ Out (val $OutFile) Nm (xName Ex...
; # (val $Zap)
  %877 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 488) to i64) to i64*
  %878 = load i64, i64* %877
; # (pair (val $Zap))
  %879 = and i64 %878, 15
  %880 = icmp eq i64 %879, 0
  br i1 %880, label %$125, label %$126
$125:
  %881 = phi i64 [%874, %$124] ; # X
  %882 = phi i64 [%875, %$124] ; # Y
  %883 = phi i1 [%876, %$124] ; # Notify
; # (let (Z @ Out (val $OutFile) Nm (xName Exe (cdr Z)) S (pathString...
; # (val $OutFile)
  %884 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (cdr Z)
  %885 = inttoptr i64 %878 to i64*
  %886 = getelementptr i64, i64* %885, i32 1
  %887 = load i64, i64* %886
; # (xName Exe (cdr Z))
  %888 = call i64 @xName(i64 %0, i64 %887)
; # (pathSize Nm)
  %889 = call i64 @pathSize(i64 %888)
; # (b8 (pathSize Nm))
  %890 = alloca i8, i64 %889
; # (pathString Nm (b8 (pathSize Nm)))
  %891 = call i8* @pathString(i64 %888, i8* %890)
; # (b8 (outFile T))
  %892 = alloca i8, i64 4109
; # (when (lt0 (openWrAppend S)) (openErr Exe (cdr Z)))
; # (openWrAppend S)
  %893 = call i32 @openWrAppend(i8* %891)
; # (lt0 (openWrAppend S))
  %894 = icmp slt i32 %893, 0
  br i1 %894, label %$127, label %$128
$127:
  %895 = phi i64 [%881, %$125] ; # X
  %896 = phi i64 [%882, %$125] ; # Y
  %897 = phi i1 [%883, %$125] ; # Notify
; # (cdr Z)
  %898 = inttoptr i64 %878 to i64*
  %899 = getelementptr i64, i64* %898, i32 1
  %900 = load i64, i64* %899
; # (openErr Exe (cdr Z))
  call void @openErr(i64 %0, i64 %900)
  unreachable
$128:
  %901 = phi i64 [%881, %$125] ; # X
  %902 = phi i64 [%882, %$125] ; # Y
  %903 = phi i1 [%883, %$125] ; # Notify
; # (Out: fd @)
  %904 = getelementptr i8, i8* %892, i32 8
  %905 = bitcast i8* %904 to i32*
  store i32 %893, i32* %905
; # (Out: ix 0)
  %906 = bitcast i8* %892 to i64*
  store i64 0, i64* %906
; # (Out: tty NO)
  %907 = getelementptr i8, i8* %892, i32 4108
  %908 = bitcast i8* %907 to i1*
  store i1 0, i1* %908
; # (set $OutFile (Out:) $PutBin (fun (void i8) _putStdout) $Extn 0)
; # (Out:)
  store i8* %892, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** @$PutBin
  store i32 0, i32* @$Extn
; # (let Y (car Z) (while (pair Y) (binPrint (++ Y))) (flush (Out:)) ...
; # (car Z)
  %909 = inttoptr i64 %878 to i64*
  %910 = load i64, i64* %909
; # (while (pair Y) (binPrint (++ Y)))
  br label %$129
$129:
  %911 = phi i64 [%901, %$128], [%916, %$130] ; # X
  %912 = phi i1 [%903, %$128], [%917, %$130] ; # Notify
  %913 = phi i64 [%910, %$128], [%922, %$130] ; # Y
; # (pair Y)
  %914 = and i64 %913, 15
  %915 = icmp eq i64 %914, 0
  br i1 %915, label %$130, label %$131
$130:
  %916 = phi i64 [%911, %$129] ; # X
  %917 = phi i1 [%912, %$129] ; # Notify
  %918 = phi i64 [%913, %$129] ; # Y
; # (++ Y)
  %919 = inttoptr i64 %918 to i64*
  %920 = load i64, i64* %919
  %921 = getelementptr i64, i64* %919, i32 1
  %922 = load i64, i64* %921
; # (binPrint (++ Y))
  call void @binPrint(i64 %920)
  br label %$129
$131:
  %923 = phi i64 [%911, %$129] ; # X
  %924 = phi i1 [%912, %$129] ; # Notify
  %925 = phi i64 [%913, %$129] ; # Y
; # (Out:)
; # (flush (Out:))
  %926 = call i1 @flush(i8* %892)
; # (Out: fd)
  %927 = getelementptr i8, i8* %892, i32 8
  %928 = bitcast i8* %927 to i32*
  %929 = load i32, i32* %928
; # (close (Out: fd))
  %930 = call i32 @close(i32 %929)
; # (set Z $Nil)
  %931 = inttoptr i64 %878 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %931
; # (set $OutFile Out)
  store i8* %884, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
  br label %$126
$126:
  %932 = phi i64 [%874, %$124], [%923, %$131] ; # X
  %933 = phi i64 [%875, %$124], [%902, %$131] ; # Y
  %934 = phi i1 [%876, %$124], [%924, %$131] ; # Notify
; # (when (val $DbLog) (fsyncDB Exe) (truncLog Exe))
; # (val $DbLog)
  %935 = load i8*, i8** @$DbLog
  %936 = icmp ne i8* %935, null
  br i1 %936, label %$132, label %$133
$132:
  %937 = phi i64 [%932, %$126] ; # X
  %938 = phi i64 [%933, %$126] ; # Y
  %939 = phi i1 [%934, %$126] ; # Notify
; # (fsyncDB Exe)
  call void @fsyncDB(i64 %0)
; # (truncLog Exe)
  call void @truncLog(i64 %0)
  br label %$133
$133:
  %940 = phi i64 [%932, %$126], [%937, %$132] ; # X
  %941 = phi i64 [%933, %$126], [%938, %$132] ; # Y
  %942 = phi i1 [%934, %$126], [%939, %$132] ; # Notify
; # (unLockDb 0)
  call void @unLockDb(i64 0)
; # (unsync)
  call void @unsync()
; # (unless (val $DbLog) (set $Protect (dec (val $Protect))))
; # (val $DbLog)
  %943 = load i8*, i8** @$DbLog
  %944 = icmp ne i8* %943, null
  br i1 %944, label %$135, label %$134
$134:
  %945 = phi i64 [%940, %$133] ; # X
  %946 = phi i64 [%941, %$133] ; # Y
  %947 = phi i1 [%942, %$133] ; # Notify
; # (set $Protect (dec (val $Protect)))
; # (val $Protect)
  %948 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
; # (dec (val $Protect))
  %949 = sub i32 %948, 1
  store i32 %949, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 176) to i32*)
  br label %$135
$135:
  %950 = phi i64 [%940, %$133], [%945, %$134] ; # X
  %951 = phi i64 [%941, %$133], [%946, %$134] ; # Y
  %952 = phi i1 [%942, %$133], [%947, %$134] ; # Notify
; # (let (P (val $DbFiles) C (val $DBs)) (loop ((dbFile P) flu -1) (?...
; # (val $DbFiles)
  %953 = load i8*, i8** @$DbFiles
; # (val $DBs)
  %954 = load i32, i32* @$DBs
; # (loop ((dbFile P) flu -1) (? (=0 (dec 'C))) (setq P (ofs P (dbFil...
  br label %$136
$136:
  %955 = phi i64 [%950, %$135], [%964, %$137] ; # X
  %956 = phi i64 [%951, %$135], [%965, %$137] ; # Y
  %957 = phi i1 [%952, %$135], [%966, %$137] ; # Notify
  %958 = phi i8* [%953, %$135], [%969, %$137] ; # P
  %959 = phi i32 [%954, %$135], [%968, %$137] ; # C
; # ((dbFile P) flu -1)
  %960 = getelementptr i8, i8* %958, i32 32
  %961 = bitcast i8* %960 to i64*
  store i64 -1, i64* %961
; # (? (=0 (dec 'C)))
; # (dec 'C)
  %962 = sub i32 %959, 1
; # (=0 (dec 'C))
  %963 = icmp eq i32 %962, 0
  br i1 %963, label %$138, label %$137
$137:
  %964 = phi i64 [%955, %$136] ; # X
  %965 = phi i64 [%956, %$136] ; # Y
  %966 = phi i1 [%957, %$136] ; # Notify
  %967 = phi i8* [%958, %$136] ; # P
  %968 = phi i32 [%962, %$136] ; # C
; # (ofs P (dbFile T))
  %969 = getelementptr i8, i8* %967, i32 42
  br label %$136
$138:
  %970 = phi i64 [%955, %$136] ; # X
  %971 = phi i64 [%956, %$136] ; # Y
  %972 = phi i1 [%957, %$136] ; # Notify
  %973 = phi i8* [%958, %$136] ; # P
  %974 = phi i32 [%962, %$136] ; # C
  %975 = phi i64 [0, %$136] ; # ->
; # (drop *Safe)
  %976 = inttoptr i64 %17 to i64*
  %977 = getelementptr i64, i64* %976, i32 1
  %978 = load i64, i64* %977
  %979 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %978, i64* %979
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
}

define i64 @_mark(i64) {
$1:
  ret i64 %0
}

define i64 @_free(i64) {
$1:
  ret i64 %0
}

define i64 @_dbck(i64) {
$1:
  ret i64 %0
}

define i64 @_apply(i64) {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL)) (set ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %24 = add i64 %17, 24
; # (link (ofs E 3) T)
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
  %30 = inttoptr i64 %17 to i64*
  store i64 %24, i64* %30
; # (let (L (save (eval (car X))) P E) (while (pair (shift X)) (setq ...
; # (car X)
  %31 = inttoptr i64 %7 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$9, label %$8
$9:
  br label %$7
$8:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$11, label %$10
$11:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$7
$10:
  %39 = call i64 @evList(i64 %32)
  br label %$7
$7:
  %40 = phi i64 [%32, %$9], [%38, %$11], [%39, %$10] ; # ->
; # (save (eval (car X)))
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %40, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %45 = load i64, i64* %44
  %46 = inttoptr i64 %42 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %48
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$12
$12:
  %49 = phi i64 [%7, %$7], [%57, %$15] ; # X
  %50 = phi i64 [%40, %$7], [%58, %$15] ; # L
  %51 = phi i64 [%17, %$7], [%71, %$15] ; # P
; # (shift X)
  %52 = inttoptr i64 %49 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (pair (shift X))
  %55 = and i64 %54, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%54, %$12] ; # X
  %58 = phi i64 [%50, %$12] ; # L
  %59 = phi i64 [%51, %$12] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %60 = inttoptr i64 %57 to i64*
  %61 = load i64, i64* %60
; # (eval (car X))
  %62 = and i64 %61, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$17, label %$16
$17:
  br label %$15
$16:
  %64 = and i64 %61, 8
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$19, label %$18
$19:
  %66 = inttoptr i64 %61 to i64*
  %67 = load i64, i64* %66
  br label %$15
$18:
  %68 = call i64 @evList(i64 %61)
  br label %$15
$15:
  %69 = phi i64 [%61, %$17], [%67, %$19], [%68, %$18] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %70 = alloca i64, i64 5, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = add i64 %71, 8
  %73 = inttoptr i64 %72 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %73
  %74 = add i64 %71, 16
  %75 = inttoptr i64 %74 to i64*
  store i64 2, i64* %75
  %76 = add i64 %71, 24
  %77 = inttoptr i64 %76 to i64*
  store i64 %69, i64* %77
  %78 = inttoptr i64 %59 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %71, i64* %79
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %80 = add i64 %71, 24
; # (link (ofs P 3))
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %82 = load i64, i64* %81
  %83 = inttoptr i64 %80 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %82, i64* %84
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %85
  %86 = inttoptr i64 %71 to i64*
  store i64 %80, i64* %86
  br label %$12
$14:
  %87 = phi i64 [%54, %$12] ; # X
  %88 = phi i64 [%50, %$12] ; # L
  %89 = phi i64 [%51, %$12] ; # P
; # (while (pair L) (setq P (set 2 P (push NIL $Nil ZERO (++ L) NIL))...
  br label %$20
$20:
  %90 = phi i64 [%87, %$14], [%95, %$21] ; # X
  %91 = phi i64 [%88, %$14], [%101, %$21] ; # L
  %92 = phi i64 [%89, %$14], [%103, %$21] ; # P
; # (pair L)
  %93 = and i64 %91, 15
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %$21, label %$22
$21:
  %95 = phi i64 [%90, %$20] ; # X
  %96 = phi i64 [%91, %$20] ; # L
  %97 = phi i64 [%92, %$20] ; # P
; # (set 2 P (push NIL $Nil ZERO (++ L) NIL))
; # (++ L)
  %98 = inttoptr i64 %96 to i64*
  %99 = load i64, i64* %98
  %100 = getelementptr i64, i64* %98, i32 1
  %101 = load i64, i64* %100
; # (push NIL $Nil ZERO (++ L) NIL)
  %102 = alloca i64, i64 5, align 16
  %103 = ptrtoint i64* %102 to i64
  %104 = add i64 %103, 8
  %105 = inttoptr i64 %104 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %105
  %106 = add i64 %103, 16
  %107 = inttoptr i64 %106 to i64*
  store i64 2, i64* %107
  %108 = add i64 %103, 24
  %109 = inttoptr i64 %108 to i64*
  store i64 %99, i64* %109
  %110 = inttoptr i64 %97 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %103, i64* %111
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %112 = add i64 %103, 24
; # (link (ofs P 3))
  %113 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %114 = load i64, i64* %113
  %115 = inttoptr i64 %112 to i64*
  %116 = getelementptr i64, i64* %115, i32 1
  store i64 %114, i64* %116
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %112, i64* %117
  %118 = inttoptr i64 %103 to i64*
  store i64 %112, i64* %118
  br label %$20
$22:
  %119 = phi i64 [%90, %$20] ; # X
  %120 = phi i64 [%91, %$20] ; # L
  %121 = phi i64 [%92, %$20] ; # P
; # (evList E)
  %122 = call i64 @evList(i64 %17)
; # (drop *Safe)
  %123 = inttoptr i64 %24 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  %126 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %125, i64* %126
  ret i64 %122
}

define i64 @_pass(i64) {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL)) (set ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %24 = add i64 %17, 24
; # (link (ofs E 3) T)
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %26 = load i64, i64* %25
  %27 = inttoptr i64 %24 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  store i64 %26, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %24, i64* %29
  %30 = inttoptr i64 %17 to i64*
  store i64 %24, i64* %30
; # (let (L (val $Next) P E) (while (pair X) (setq P (set 2 P (push N...
; # (val $Next)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %32 = load i64, i64* %31
; # (while (pair X) (setq P (set 2 P (push NIL $Nil ZERO (eval (++ X)...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%44, %$10] ; # X
  %34 = phi i64 [%32, %$2], [%39, %$10] ; # L
  %35 = phi i64 [%17, %$2], [%54, %$10] ; # P
; # (pair X)
  %36 = and i64 %33, 15
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %$8, label %$9
$8:
  %38 = phi i64 [%33, %$7] ; # X
  %39 = phi i64 [%34, %$7] ; # L
  %40 = phi i64 [%35, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (++ X)) NIL))
; # (++ X)
  %41 = inttoptr i64 %38 to i64*
  %42 = load i64, i64* %41
  %43 = getelementptr i64, i64* %41, i32 1
  %44 = load i64, i64* %43
; # (eval (++ X))
  %45 = and i64 %42, 6
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$12, label %$11
$12:
  br label %$10
$11:
  %47 = and i64 %42, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$14, label %$13
$14:
  %49 = inttoptr i64 %42 to i64*
  %50 = load i64, i64* %49
  br label %$10
$13:
  %51 = call i64 @evList(i64 %42)
  br label %$10
$10:
  %52 = phi i64 [%42, %$12], [%50, %$14], [%51, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %53 = alloca i64, i64 5, align 16
  %54 = ptrtoint i64* %53 to i64
  %55 = add i64 %54, 8
  %56 = inttoptr i64 %55 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %56
  %57 = add i64 %54, 16
  %58 = inttoptr i64 %57 to i64*
  store i64 2, i64* %58
  %59 = add i64 %54, 24
  %60 = inttoptr i64 %59 to i64*
  store i64 %52, i64* %60
  %61 = inttoptr i64 %40 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %54, i64* %62
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %63 = add i64 %54, 24
; # (link (ofs P 3))
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %65 = load i64, i64* %64
  %66 = inttoptr i64 %63 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %65, i64* %67
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %63, i64* %68
  %69 = inttoptr i64 %54 to i64*
  store i64 %63, i64* %69
  br label %$7
$9:
  %70 = phi i64 [%33, %$7] ; # X
  %71 = phi i64 [%34, %$7] ; # L
  %72 = phi i64 [%35, %$7] ; # P
; # (while (pair L) (setq P (set 2 P (push NIL $Nil ZERO (cdr L) NIL)...
  br label %$15
$15:
  %73 = phi i64 [%70, %$9], [%78, %$16] ; # X
  %74 = phi i64 [%71, %$9], [%102, %$16] ; # L
  %75 = phi i64 [%72, %$9], [%85, %$16] ; # P
; # (pair L)
  %76 = and i64 %74, 15
  %77 = icmp eq i64 %76, 0
  br i1 %77, label %$16, label %$17
$16:
  %78 = phi i64 [%73, %$15] ; # X
  %79 = phi i64 [%74, %$15] ; # L
  %80 = phi i64 [%75, %$15] ; # P
; # (set 2 P (push NIL $Nil ZERO (cdr L) NIL))
; # (cdr L)
  %81 = inttoptr i64 %79 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (push NIL $Nil ZERO (cdr L) NIL)
  %84 = alloca i64, i64 5, align 16
  %85 = ptrtoint i64* %84 to i64
  %86 = add i64 %85, 8
  %87 = inttoptr i64 %86 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %87
  %88 = add i64 %85, 16
  %89 = inttoptr i64 %88 to i64*
  store i64 2, i64* %89
  %90 = add i64 %85, 24
  %91 = inttoptr i64 %90 to i64*
  store i64 %83, i64* %91
  %92 = inttoptr i64 %80 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  store i64 %85, i64* %93
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %94 = add i64 %85, 24
; # (link (ofs P 3))
  %95 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %96 = load i64, i64* %95
  %97 = inttoptr i64 %94 to i64*
  %98 = getelementptr i64, i64* %97, i32 1
  store i64 %96, i64* %98
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %94, i64* %99
  %100 = inttoptr i64 %85 to i64*
  store i64 %94, i64* %100
; # (car L)
  %101 = inttoptr i64 %79 to i64*
  %102 = load i64, i64* %101
  br label %$15
$17:
  %103 = phi i64 [%73, %$15] ; # X
  %104 = phi i64 [%74, %$15] ; # L
  %105 = phi i64 [%75, %$15] ; # P
; # (evList E)
  %106 = call i64 @evList(i64 %17)
; # (drop *Safe)
  %107 = inttoptr i64 %24 to i64*
  %108 = getelementptr i64, i64* %107, i32 1
  %109 = load i64, i64* %108
  %110 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %109, i64* %110
  ret i64 %106
}

define i64 @_maps(i64) {
$1:
; # (let (X (cdr Exe) R $Nil E (push NIL $Nil ZERO (eval (++ X)) NIL)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A Sym (save (needSymb Exe (eval (car X)))) V Sym) (se...
; # (car X)
  %33 = inttoptr i64 %7 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$9, label %$8
$9:
  br label %$7
$8:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$11, label %$10
$11:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$7
$10:
  %41 = call i64 @evList(i64 %34)
  br label %$7
$7:
  %42 = phi i64 [%34, %$9], [%40, %$11], [%41, %$10] ; # ->
; # (needSymb Exe (eval (car X)))
  %43 = xor i64 %42, 8
  %44 = and i64 %43, 14
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$13, label %$12
$12:
  call void @symErr(i64 %0, i64 %42)
  unreachable
$13:
; # (save (needSymb Exe (eval (car X))))
  %46 = alloca i64, i64 2, align 16
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 %42, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
  %51 = inttoptr i64 %47 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %50, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %53
; # (set Q V)
  %54 = inttoptr i64 %25 to i64*
  store i64 %42, i64* %54
; # (loop (setq P (set 2 P (push NIL $Nil ZERO V NIL))) (set P (link ...
  br label %$14
$14:
  %55 = phi i64 [%7, %$13], [%119, %$23] ; # X
  %56 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%120, %$23] ; # R
  %57 = phi i64 [%17, %$13], [%121, %$23] ; # P
  %58 = phi i64 [%25, %$13], [%122, %$23] ; # Q
  %59 = phi i64 [%42, %$13], [%123, %$23] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %60 = alloca i64, i64 5, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = add i64 %61, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
  %64 = add i64 %61, 16
  %65 = inttoptr i64 %64 to i64*
  store i64 2, i64* %65
  %66 = add i64 %61, 24
  %67 = inttoptr i64 %66 to i64*
  store i64 %59, i64* %67
  %68 = inttoptr i64 %57 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %61, i64* %69
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %70 = add i64 %61, 24
; # (link (ofs P 3))
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %75
  %76 = inttoptr i64 %61 to i64*
  store i64 %70, i64* %76
; # (? (atom (shift X)))
; # (shift X)
  %77 = inttoptr i64 %55 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  %79 = load i64, i64* %78
; # (atom (shift X))
  %80 = and i64 %79, 15
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$16, label %$15
$15:
  %82 = phi i64 [%79, %$14] ; # X
  %83 = phi i64 [%56, %$14] ; # R
  %84 = phi i64 [%61, %$14] ; # P
  %85 = phi i64 [%58, %$14] ; # Q
  %86 = phi i64 [%59, %$14] ; # V
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %87 = alloca i64, i64 2, align 16
  %88 = ptrtoint i64* %87 to i64
  %89 = inttoptr i64 %85 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %88, i64* %90
; # (car X)
  %91 = inttoptr i64 %82 to i64*
  %92 = load i64, i64* %91
; # (eval (car X))
  %93 = and i64 %92, 6
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$19, label %$18
$19:
  br label %$17
$18:
  %95 = and i64 %92, 8
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$21, label %$20
$21:
  %97 = inttoptr i64 %92 to i64*
  %98 = load i64, i64* %97
  br label %$17
$20:
  %99 = call i64 @evList(i64 %92)
  br label %$17
$17:
  %100 = phi i64 [%92, %$19], [%98, %$21], [%99, %$20] ; # ->
; # (save (eval (car X)))
  %101 = alloca i64, i64 2, align 16
  %102 = ptrtoint i64* %101 to i64
  %103 = inttoptr i64 %102 to i64*
  store i64 %100, i64* %103
  %104 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %105 = load i64, i64* %104
  %106 = inttoptr i64 %102 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  store i64 %105, i64* %107
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %102, i64* %108
; # (set Q V)
  %109 = inttoptr i64 %88 to i64*
  store i64 %100, i64* %109
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %110 = and i64 %100, 15
  %111 = icmp eq i64 %110, 0
  br i1 %111, label %$22, label %$23
$22:
  %112 = phi i64 [%82, %$17] ; # X
  %113 = phi i64 [%83, %$17] ; # R
  %114 = phi i64 [%84, %$17] ; # P
  %115 = phi i64 [%88, %$17] ; # Q
  %116 = phi i64 [%100, %$17] ; # V
; # (car V)
  %117 = inttoptr i64 %116 to i64*
  %118 = load i64, i64* %117
  br label %$23
$23:
  %119 = phi i64 [%82, %$17], [%112, %$22] ; # X
  %120 = phi i64 [%83, %$17], [%113, %$22] ; # R
  %121 = phi i64 [%84, %$17], [%114, %$22] ; # P
  %122 = phi i64 [%88, %$17], [%115, %$22] ; # Q
  %123 = phi i64 [%100, %$17], [%118, %$22] ; # V
  br label %$14
$16:
  %124 = phi i64 [%79, %$14] ; # X
  %125 = phi i64 [%56, %$14] ; # R
  %126 = phi i64 [%61, %$14] ; # P
  %127 = phi i64 [%58, %$14] ; # Q
  %128 = phi i64 [%59, %$14] ; # V
  %129 = phi i64 [0, %$14] ; # ->
; # (when (sym? (setq V (val (tail Sym)))) (dbFetch Exe Sym) (setq V ...
; # (tail Sym)
  %130 = add i64 %42, -8
; # (val (tail Sym))
  %131 = inttoptr i64 %130 to i64*
  %132 = load i64, i64* %131
; # (sym? (setq V (val (tail Sym))))
  %133 = and i64 %132, 8
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$24, label %$25
$24:
  %135 = phi i64 [%124, %$16] ; # X
  %136 = phi i64 [%125, %$16] ; # R
  %137 = phi i64 [%126, %$16] ; # P
  %138 = phi i64 [%127, %$16] ; # Q
  %139 = phi i64 [%132, %$16] ; # V
; # (dbFetch Exe Sym)
  call void @dbFetch(i64 %0, i64 %42)
; # (tail Sym)
  %140 = add i64 %42, -8
; # (val (tail Sym))
  %141 = inttoptr i64 %140 to i64*
  %142 = load i64, i64* %141
; # (& (val (tail Sym)) -9)
  %143 = and i64 %142, -9
  br label %$25
$25:
  %144 = phi i64 [%124, %$16], [%135, %$24] ; # X
  %145 = phi i64 [%125, %$16], [%136, %$24] ; # R
  %146 = phi i64 [%126, %$16], [%137, %$24] ; # P
  %147 = phi i64 [%127, %$16], [%138, %$24] ; # Q
  %148 = phi i64 [%132, %$16], [%143, %$24] ; # V
; # (set 4 (cdr E) (if (pair V) (car V) V))
; # (cdr E)
  %149 = inttoptr i64 %17 to i64*
  %150 = getelementptr i64, i64* %149, i32 1
  %151 = load i64, i64* %150
; # (if (pair V) (car V) V)
; # (pair V)
  %152 = and i64 %148, 15
  %153 = icmp eq i64 %152, 0
  br i1 %153, label %$26, label %$27
$26:
  %154 = phi i64 [%144, %$25] ; # X
  %155 = phi i64 [%145, %$25] ; # R
  %156 = phi i64 [%146, %$25] ; # P
  %157 = phi i64 [%147, %$25] ; # Q
  %158 = phi i64 [%148, %$25] ; # V
; # (car V)
  %159 = inttoptr i64 %158 to i64*
  %160 = load i64, i64* %159
  br label %$28
$27:
  %161 = phi i64 [%144, %$25] ; # X
  %162 = phi i64 [%145, %$25] ; # R
  %163 = phi i64 [%146, %$25] ; # P
  %164 = phi i64 [%147, %$25] ; # Q
  %165 = phi i64 [%148, %$25] ; # V
  br label %$28
$28:
  %166 = phi i64 [%154, %$26], [%161, %$27] ; # X
  %167 = phi i64 [%155, %$26], [%162, %$27] ; # R
  %168 = phi i64 [%156, %$26], [%163, %$27] ; # P
  %169 = phi i64 [%157, %$26], [%164, %$27] ; # Q
  %170 = phi i64 [%158, %$26], [%165, %$27] ; # V
  %171 = phi i64 [%160, %$26], [%165, %$27] ; # ->
  %172 = inttoptr i64 %151 to i64*
  %173 = getelementptr i64, i64* %172, i32 3
  store i64 %171, i64* %173
; # (set A V)
  %174 = inttoptr i64 %25 to i64*
  store i64 %170, i64* %174
; # (when (pair (car A)) (loop (setq R (evList E)) (? (atom (set A (c...
; # (car A)
  %175 = inttoptr i64 %25 to i64*
  %176 = load i64, i64* %175
; # (pair (car A))
  %177 = and i64 %176, 15
  %178 = icmp eq i64 %177, 0
  br i1 %178, label %$29, label %$30
$29:
  %179 = phi i64 [%166, %$28] ; # X
  %180 = phi i64 [%167, %$28] ; # R
; # (loop (setq R (evList E)) (? (atom (set A (cdar A)))) (let (P (cd...
  br label %$31
$31:
  %181 = phi i64 [%179, %$29], [%252, %$36] ; # X
  %182 = phi i64 [%180, %$29], [%253, %$36] ; # R
; # (evList E)
  %183 = call i64 @evList(i64 %17)
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %184 = inttoptr i64 %25 to i64*
  %185 = load i64, i64* %184
  %186 = inttoptr i64 %185 to i64*
  %187 = getelementptr i64, i64* %186, i32 1
  %188 = load i64, i64* %187
  %189 = inttoptr i64 %25 to i64*
  store i64 %188, i64* %189
; # (atom (set A (cdar A)))
  %190 = and i64 %188, 15
  %191 = icmp ne i64 %190, 0
  br i1 %191, label %$33, label %$32
$32:
  %192 = phi i64 [%181, %$31] ; # X
  %193 = phi i64 [%183, %$31] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %194 = inttoptr i64 %17 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
; # (set 4 P (car @))
; # (car @)
  %197 = inttoptr i64 %188 to i64*
  %198 = load i64, i64* %197
  %199 = inttoptr i64 %196 to i64*
  %200 = getelementptr i64, i64* %199, i32 3
  store i64 %198, i64* %200
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$34
$34:
  %201 = phi i64 [%192, %$32], [%245, %$37] ; # X
  %202 = phi i64 [%193, %$32], [%246, %$37] ; # R
  %203 = phi i64 [%196, %$32], [%247, %$37] ; # P
  %204 = phi i64 [%25, %$32], [%248, %$37] ; # Q
; # (shift P)
  %205 = inttoptr i64 %203 to i64*
  %206 = getelementptr i64, i64* %205, i32 1
  %207 = load i64, i64* %206
; # (pair (shift P))
  %208 = and i64 %207, 15
  %209 = icmp eq i64 %208, 0
  br i1 %209, label %$35, label %$36
$35:
  %210 = phi i64 [%201, %$34] ; # X
  %211 = phi i64 [%202, %$34] ; # R
  %212 = phi i64 [%207, %$34] ; # P
  %213 = phi i64 [%204, %$34] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %214 = inttoptr i64 %213 to i64*
  %215 = getelementptr i64, i64* %214, i32 1
  %216 = load i64, i64* %215
; # (car (shift Q))
  %217 = inttoptr i64 %216 to i64*
  %218 = load i64, i64* %217
; # (atom (car (shift Q)))
  %219 = and i64 %218, 15
  %220 = icmp ne i64 %219, 0
  br i1 %220, label %$39, label %$38
$39:
  %221 = phi i64 [%210, %$35] ; # X
  %222 = phi i64 [%211, %$35] ; # R
  %223 = phi i64 [%212, %$35] ; # P
  %224 = phi i64 [%216, %$35] ; # Q
  br label %$37
$38:
  %225 = phi i64 [%210, %$35] ; # X
  %226 = phi i64 [%211, %$35] ; # R
  %227 = phi i64 [%212, %$35] ; # P
  %228 = phi i64 [%216, %$35] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %229 = inttoptr i64 %218 to i64*
  %230 = getelementptr i64, i64* %229, i32 1
  %231 = load i64, i64* %230
  %232 = inttoptr i64 %228 to i64*
  store i64 %231, i64* %232
; # (atom (set Q (cdr @)))
  %233 = and i64 %231, 15
  %234 = icmp ne i64 %233, 0
  br i1 %234, label %$41, label %$40
$41:
  %235 = phi i64 [%225, %$38] ; # X
  %236 = phi i64 [%226, %$38] ; # R
  %237 = phi i64 [%227, %$38] ; # P
  %238 = phi i64 [%228, %$38] ; # Q
  br label %$37
$40:
  %239 = phi i64 [%225, %$38] ; # X
  %240 = phi i64 [%226, %$38] ; # R
  %241 = phi i64 [%227, %$38] ; # P
  %242 = phi i64 [%228, %$38] ; # Q
; # (car @)
  %243 = inttoptr i64 %231 to i64*
  %244 = load i64, i64* %243
  br label %$37
$37:
  %245 = phi i64 [%221, %$39], [%235, %$41], [%239, %$40] ; # X
  %246 = phi i64 [%222, %$39], [%236, %$41], [%240, %$40] ; # R
  %247 = phi i64 [%223, %$39], [%237, %$41], [%241, %$40] ; # P
  %248 = phi i64 [%224, %$39], [%238, %$41], [%242, %$40] ; # Q
  %249 = phi i64 [%218, %$39], [%231, %$41], [%244, %$40] ; # ->
  %250 = inttoptr i64 %212 to i64*
  %251 = getelementptr i64, i64* %250, i32 3
  store i64 %249, i64* %251
  br label %$34
$36:
  %252 = phi i64 [%201, %$34] ; # X
  %253 = phi i64 [%202, %$34] ; # R
  %254 = phi i64 [%207, %$34] ; # P
  %255 = phi i64 [%204, %$34] ; # Q
  br label %$31
$33:
  %256 = phi i64 [%181, %$31] ; # X
  %257 = phi i64 [%183, %$31] ; # R
  %258 = phi i64 [0, %$31] ; # ->
  br label %$30
$30:
  %259 = phi i64 [%166, %$28], [%256, %$33] ; # X
  %260 = phi i64 [%167, %$28], [%257, %$33] ; # R
; # (drop *Safe)
  %261 = inttoptr i64 %26 to i64*
  %262 = getelementptr i64, i64* %261, i32 1
  %263 = load i64, i64* %262
  %264 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %263, i64* %264
  ret i64 %260
}

define i64 @_map(i64) {
$1:
; # (let (X (cdr Exe) R $Nil E (push NIL $Nil ZERO (eval (car X)) NIL...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %14 = alloca i64, i64 5, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = add i64 %15, 8
  %17 = inttoptr i64 %16 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %17
  %18 = add i64 %15, 16
  %19 = inttoptr i64 %18 to i64*
  store i64 2, i64* %19
  %20 = add i64 %15, 24
  %21 = inttoptr i64 %20 to i64*
  store i64 %13, i64* %21
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %22 = add i64 %15, 24
; # (link (ofs E 3) T)
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %22 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 %15 to i64*
  store i64 %22, i64* %28
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %29 = phi i64 [%3, %$2], [%37, %$10] ; # X
  %30 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%38, %$10] ; # R
  %31 = phi i64 [%15, %$2], [%51, %$10] ; # P
; # (shift X)
  %32 = inttoptr i64 %29 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (pair (shift X))
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$8, label %$9
$8:
  %37 = phi i64 [%34, %$7] ; # X
  %38 = phi i64 [%30, %$7] ; # R
  %39 = phi i64 [%31, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %40 = inttoptr i64 %37 to i64*
  %41 = load i64, i64* %40
; # (eval (car X))
  %42 = and i64 %41, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$12, label %$11
$12:
  br label %$10
$11:
  %44 = and i64 %41, 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$14, label %$13
$14:
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
  br label %$10
$13:
  %48 = call i64 @evList(i64 %41)
  br label %$10
$10:
  %49 = phi i64 [%41, %$12], [%47, %$14], [%48, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %50 = alloca i64, i64 5, align 16
  %51 = ptrtoint i64* %50 to i64
  %52 = add i64 %51, 8
  %53 = inttoptr i64 %52 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %53
  %54 = add i64 %51, 16
  %55 = inttoptr i64 %54 to i64*
  store i64 2, i64* %55
  %56 = add i64 %51, 24
  %57 = inttoptr i64 %56 to i64*
  store i64 %49, i64* %57
  %58 = inttoptr i64 %39 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  store i64 %51, i64* %59
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %60 = add i64 %51, 24
; # (link (ofs P 3))
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %62 = load i64, i64* %61
  %63 = inttoptr i64 %60 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  store i64 %62, i64* %64
  %65 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %65
  %66 = inttoptr i64 %51 to i64*
  store i64 %60, i64* %66
  br label %$7
$9:
  %67 = phi i64 [%34, %$7] ; # X
  %68 = phi i64 [%30, %$7] ; # R
  %69 = phi i64 [%31, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P))) (setq R (evList E)) (lo...
  br label %$15
$15:
  %70 = phi i64 [%67, %$9], [%111, %$22] ; # X
  %71 = phi i64 [%68, %$9], [%112, %$22] ; # R
; # (let P (cdr E) (? (atom (val 4 P))) (setq R (evList E)) (loop (wh...
; # (cdr E)
  %72 = inttoptr i64 %15 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (? (atom (val 4 P)))
; # (val 4 P)
  %75 = inttoptr i64 %74 to i64*
  %76 = getelementptr i64, i64* %75, i32 3
  %77 = load i64, i64* %76
; # (atom (val 4 P))
  %78 = and i64 %77, 15
  %79 = icmp ne i64 %78, 0
  br i1 %79, label %$17, label %$16
$16:
  %80 = phi i64 [%70, %$15] ; # X
  %81 = phi i64 [%71, %$15] ; # R
  %82 = phi i64 [%74, %$15] ; # P
; # (evList E)
  %83 = call i64 @evList(i64 %15)
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$18
$18:
  %84 = phi i64 [%80, %$16], [%108, %$21] ; # X
  %85 = phi i64 [%83, %$16], [%109, %$21] ; # R
  %86 = phi i64 [%82, %$16], [%110, %$21] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 3
  %89 = load i64, i64* %88
; # (pair (val 4 P))
  %90 = and i64 %89, 15
  %91 = icmp eq i64 %90, 0
  br i1 %91, label %$19, label %$20
$19:
  %92 = phi i64 [%84, %$18] ; # X
  %93 = phi i64 [%85, %$18] ; # R
  %94 = phi i64 [%86, %$18] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %95 = inttoptr i64 %89 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
  %98 = inttoptr i64 %94 to i64*
  %99 = getelementptr i64, i64* %98, i32 3
  store i64 %97, i64* %99
  br label %$20
$20:
  %100 = phi i64 [%84, %$18], [%92, %$19] ; # X
  %101 = phi i64 [%85, %$18], [%93, %$19] ; # R
  %102 = phi i64 [%86, %$18], [%94, %$19] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
; # (atom (shift P))
  %106 = and i64 %105, 15
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$22, label %$21
$21:
  %108 = phi i64 [%100, %$20] ; # X
  %109 = phi i64 [%101, %$20] ; # R
  %110 = phi i64 [%105, %$20] ; # P
  br label %$18
$22:
  %111 = phi i64 [%100, %$20] ; # X
  %112 = phi i64 [%101, %$20] ; # R
  %113 = phi i64 [%105, %$20] ; # P
  %114 = phi i64 [0, %$20] ; # ->
  br label %$15
$17:
  %115 = phi i64 [%70, %$15] ; # X
  %116 = phi i64 [%71, %$15] ; # R
  %117 = phi i64 [0, %$15] ; # ->
; # (drop *Safe)
  %118 = inttoptr i64 %22 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %120, i64* %121
  ret i64 %116
}

define i64 @_mapc(i64) {
$1:
; # (let (X (cdr Exe) R $Nil E (push NIL $Nil ZERO (eval (++ X)) NIL)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%92, %$15] ; # X
  %34 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%93, %$15] ; # R
  %35 = phi i64 [%17, %$2], [%94, %$15] ; # P
  %36 = phi i64 [%25, %$2], [%97, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %37 = inttoptr i64 %33 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$10, label %$9
$10:
  br label %$8
$9:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$12, label %$11
$12:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$8
$11:
  %45 = call i64 @evList(i64 %38)
  br label %$8
$8:
  %46 = phi i64 [%38, %$10], [%44, %$12], [%45, %$11] ; # ->
; # (save (eval (car X)))
  %47 = alloca i64, i64 2, align 16
  %48 = ptrtoint i64* %47 to i64
  %49 = inttoptr i64 %48 to i64*
  store i64 %46, i64* %49
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %48 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  store i64 %51, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %54
  %55 = inttoptr i64 %36 to i64*
  store i64 %46, i64* %55
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %56 = and i64 %46, 15
  %57 = icmp eq i64 %56, 0
  br i1 %57, label %$13, label %$14
$13:
  %58 = phi i64 [%33, %$8] ; # X
  %59 = phi i64 [%34, %$8] ; # R
  %60 = phi i64 [%35, %$8] ; # P
  %61 = phi i64 [%36, %$8] ; # Q
  %62 = phi i64 [%46, %$8] ; # V
; # (car V)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  br label %$14
$14:
  %65 = phi i64 [%33, %$8], [%58, %$13] ; # X
  %66 = phi i64 [%34, %$8], [%59, %$13] ; # R
  %67 = phi i64 [%35, %$8], [%60, %$13] ; # P
  %68 = phi i64 [%36, %$8], [%61, %$13] ; # Q
  %69 = phi i64 [%46, %$8], [%64, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %70 = alloca i64, i64 5, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = add i64 %71, 8
  %73 = inttoptr i64 %72 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %73
  %74 = add i64 %71, 16
  %75 = inttoptr i64 %74 to i64*
  store i64 2, i64* %75
  %76 = add i64 %71, 24
  %77 = inttoptr i64 %76 to i64*
  store i64 %69, i64* %77
  %78 = inttoptr i64 %67 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %71, i64* %79
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %80 = add i64 %71, 24
; # (link (ofs P 3))
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %82 = load i64, i64* %81
  %83 = inttoptr i64 %80 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %82, i64* %84
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %85
  %86 = inttoptr i64 %71 to i64*
  store i64 %80, i64* %86
; # (? (atom (shift X)))
; # (shift X)
  %87 = inttoptr i64 %65 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
; # (atom (shift X))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$16, label %$15
$15:
  %92 = phi i64 [%89, %$14] ; # X
  %93 = phi i64 [%66, %$14] ; # R
  %94 = phi i64 [%71, %$14] ; # P
  %95 = phi i64 [%68, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %96 = alloca i64, i64 2, align 16
  %97 = ptrtoint i64* %96 to i64
  %98 = inttoptr i64 %95 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  store i64 %97, i64* %99
  br label %$7
$16:
  %100 = phi i64 [%89, %$14] ; # X
  %101 = phi i64 [%66, %$14] ; # R
  %102 = phi i64 [%71, %$14] ; # P
  %103 = phi i64 [%68, %$14] ; # Q
  %104 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (setq R (evList E)) (? (atom (set A (c...
; # (car A)
  %105 = inttoptr i64 %25 to i64*
  %106 = load i64, i64* %105
; # (pair (car A))
  %107 = and i64 %106, 15
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %$17, label %$18
$17:
  %109 = phi i64 [%100, %$16] ; # X
  %110 = phi i64 [%101, %$16] ; # R
; # (loop (setq R (evList E)) (? (atom (set A (cdar A)))) (let (P (cd...
  br label %$19
$19:
  %111 = phi i64 [%109, %$17], [%182, %$24] ; # X
  %112 = phi i64 [%110, %$17], [%183, %$24] ; # R
; # (evList E)
  %113 = call i64 @evList(i64 %17)
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %114 = inttoptr i64 %25 to i64*
  %115 = load i64, i64* %114
  %116 = inttoptr i64 %115 to i64*
  %117 = getelementptr i64, i64* %116, i32 1
  %118 = load i64, i64* %117
  %119 = inttoptr i64 %25 to i64*
  store i64 %118, i64* %119
; # (atom (set A (cdar A)))
  %120 = and i64 %118, 15
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$21, label %$20
$20:
  %122 = phi i64 [%111, %$19] ; # X
  %123 = phi i64 [%113, %$19] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %124 = inttoptr i64 %17 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
; # (set 4 P (car @))
; # (car @)
  %127 = inttoptr i64 %118 to i64*
  %128 = load i64, i64* %127
  %129 = inttoptr i64 %126 to i64*
  %130 = getelementptr i64, i64* %129, i32 3
  store i64 %128, i64* %130
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$22
$22:
  %131 = phi i64 [%122, %$20], [%175, %$25] ; # X
  %132 = phi i64 [%123, %$20], [%176, %$25] ; # R
  %133 = phi i64 [%126, %$20], [%177, %$25] ; # P
  %134 = phi i64 [%25, %$20], [%178, %$25] ; # Q
; # (shift P)
  %135 = inttoptr i64 %133 to i64*
  %136 = getelementptr i64, i64* %135, i32 1
  %137 = load i64, i64* %136
; # (pair (shift P))
  %138 = and i64 %137, 15
  %139 = icmp eq i64 %138, 0
  br i1 %139, label %$23, label %$24
$23:
  %140 = phi i64 [%131, %$22] ; # X
  %141 = phi i64 [%132, %$22] ; # R
  %142 = phi i64 [%137, %$22] ; # P
  %143 = phi i64 [%134, %$22] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (car (shift Q))
  %147 = inttoptr i64 %146 to i64*
  %148 = load i64, i64* %147
; # (atom (car (shift Q)))
  %149 = and i64 %148, 15
  %150 = icmp ne i64 %149, 0
  br i1 %150, label %$27, label %$26
$27:
  %151 = phi i64 [%140, %$23] ; # X
  %152 = phi i64 [%141, %$23] ; # R
  %153 = phi i64 [%142, %$23] ; # P
  %154 = phi i64 [%146, %$23] ; # Q
  br label %$25
$26:
  %155 = phi i64 [%140, %$23] ; # X
  %156 = phi i64 [%141, %$23] ; # R
  %157 = phi i64 [%142, %$23] ; # P
  %158 = phi i64 [%146, %$23] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %159 = inttoptr i64 %148 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  %161 = load i64, i64* %160
  %162 = inttoptr i64 %158 to i64*
  store i64 %161, i64* %162
; # (atom (set Q (cdr @)))
  %163 = and i64 %161, 15
  %164 = icmp ne i64 %163, 0
  br i1 %164, label %$29, label %$28
$29:
  %165 = phi i64 [%155, %$26] ; # X
  %166 = phi i64 [%156, %$26] ; # R
  %167 = phi i64 [%157, %$26] ; # P
  %168 = phi i64 [%158, %$26] ; # Q
  br label %$25
$28:
  %169 = phi i64 [%155, %$26] ; # X
  %170 = phi i64 [%156, %$26] ; # R
  %171 = phi i64 [%157, %$26] ; # P
  %172 = phi i64 [%158, %$26] ; # Q
; # (car @)
  %173 = inttoptr i64 %161 to i64*
  %174 = load i64, i64* %173
  br label %$25
$25:
  %175 = phi i64 [%151, %$27], [%165, %$29], [%169, %$28] ; # X
  %176 = phi i64 [%152, %$27], [%166, %$29], [%170, %$28] ; # R
  %177 = phi i64 [%153, %$27], [%167, %$29], [%171, %$28] ; # P
  %178 = phi i64 [%154, %$27], [%168, %$29], [%172, %$28] ; # Q
  %179 = phi i64 [%148, %$27], [%161, %$29], [%174, %$28] ; # ->
  %180 = inttoptr i64 %142 to i64*
  %181 = getelementptr i64, i64* %180, i32 3
  store i64 %179, i64* %181
  br label %$22
$24:
  %182 = phi i64 [%131, %$22] ; # X
  %183 = phi i64 [%132, %$22] ; # R
  %184 = phi i64 [%137, %$22] ; # P
  %185 = phi i64 [%134, %$22] ; # Q
  br label %$19
$21:
  %186 = phi i64 [%111, %$19] ; # X
  %187 = phi i64 [%113, %$19] ; # R
  %188 = phi i64 [0, %$19] ; # ->
  br label %$18
$18:
  %189 = phi i64 [%100, %$16], [%186, %$21] ; # X
  %190 = phi i64 [%101, %$16], [%187, %$21] ; # R
; # (drop *Safe)
  %191 = inttoptr i64 %26 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
  %194 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %193, i64* %194
  ret i64 %190
}

define i64 @_maplist(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (car X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
; # (eval (car X))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$4, label %$3
$4:
  br label %$2
$3:
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$6, label %$5
$6:
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
  br label %$2
$5:
  %20 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %21 = phi i64 [%13, %$4], [%19, %$6], [%20, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %22 = alloca i64, i64 5, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = add i64 %23, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %25
  %26 = add i64 %23, 16
  %27 = inttoptr i64 %26 to i64*
  store i64 2, i64* %27
  %28 = add i64 %23, 24
  %29 = inttoptr i64 %28 to i64*
  store i64 %21, i64* %29
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %30 = add i64 %23, 24
; # (link (ofs E 3))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %30 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 %23 to i64*
  store i64 %30, i64* %36
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %37 = phi i64 [%3, %$2], [%46, %$10] ; # X
  %38 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%47, %$10] ; # R
  %39 = phi i64 [0, %$2], [%48, %$10] ; # L
  %40 = phi i64 [%23, %$2], [%61, %$10] ; # P
; # (shift X)
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (pair (shift X))
  %44 = and i64 %43, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$8, label %$9
$8:
  %46 = phi i64 [%43, %$7] ; # X
  %47 = phi i64 [%38, %$7] ; # R
  %48 = phi i64 [%39, %$7] ; # L
  %49 = phi i64 [%40, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %50 = inttoptr i64 %46 to i64*
  %51 = load i64, i64* %50
; # (eval (car X))
  %52 = and i64 %51, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$12, label %$11
$12:
  br label %$10
$11:
  %54 = and i64 %51, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$14, label %$13
$14:
  %56 = inttoptr i64 %51 to i64*
  %57 = load i64, i64* %56
  br label %$10
$13:
  %58 = call i64 @evList(i64 %51)
  br label %$10
$10:
  %59 = phi i64 [%51, %$12], [%57, %$14], [%58, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %60 = alloca i64, i64 5, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = add i64 %61, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
  %64 = add i64 %61, 16
  %65 = inttoptr i64 %64 to i64*
  store i64 2, i64* %65
  %66 = add i64 %61, 24
  %67 = inttoptr i64 %66 to i64*
  store i64 %59, i64* %67
  %68 = inttoptr i64 %49 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %61, i64* %69
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %70 = add i64 %61, 24
; # (link (ofs P 3))
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %75
  %76 = inttoptr i64 %61 to i64*
  store i64 %70, i64* %76
  br label %$7
$9:
  %77 = phi i64 [%43, %$7] ; # X
  %78 = phi i64 [%38, %$7] ; # R
  %79 = phi i64 [%39, %$7] ; # L
  %80 = phi i64 [%40, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P))) (let Y (cons (evList E)...
  br label %$15
$15:
  %81 = phi i64 [%77, %$9], [%146, %$25] ; # X
  %82 = phi i64 [%78, %$9], [%147, %$25] ; # R
  %83 = phi i64 [%79, %$9], [%148, %$25] ; # L
; # (let P (cdr E) (? (atom (val 4 P))) (let Y (cons (evList E) $Nil)...
; # (cdr E)
  %84 = inttoptr i64 %23 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (? (atom (val 4 P)))
; # (val 4 P)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 3
  %89 = load i64, i64* %88
; # (atom (val 4 P))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$17, label %$16
$16:
  %92 = phi i64 [%81, %$15] ; # X
  %93 = phi i64 [%82, %$15] ; # R
  %94 = phi i64 [%83, %$15] ; # L
  %95 = phi i64 [%86, %$15] ; # P
; # (let Y (cons (evList E) $Nil) (setq L (if L (set 2 L Y) (setq R (...
; # (evList E)
  %96 = call i64 @evList(i64 %23)
; # (cons (evList E) $Nil)
  %97 = call i64 @cons(i64 %96, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %98 = icmp ne i64 %94, 0
  br i1 %98, label %$18, label %$19
$18:
  %99 = phi i64 [%92, %$16] ; # X
  %100 = phi i64 [%93, %$16] ; # R
  %101 = phi i64 [%94, %$16] ; # L
  %102 = phi i64 [%95, %$16] ; # P
; # (set 2 L Y)
  %103 = inttoptr i64 %101 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  store i64 %97, i64* %104
  br label %$20
$19:
  %105 = phi i64 [%92, %$16] ; # X
  %106 = phi i64 [%93, %$16] ; # R
  %107 = phi i64 [%94, %$16] ; # L
  %108 = phi i64 [%95, %$16] ; # P
; # (safe Y)
  %109 = inttoptr i64 %5 to i64*
  store i64 %97, i64* %109
  br label %$20
$20:
  %110 = phi i64 [%99, %$18], [%105, %$19] ; # X
  %111 = phi i64 [%100, %$18], [%97, %$19] ; # R
  %112 = phi i64 [%101, %$18], [%107, %$19] ; # L
  %113 = phi i64 [%102, %$18], [%108, %$19] ; # P
  %114 = phi i64 [%97, %$18], [%97, %$19] ; # ->
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$21
$21:
  %115 = phi i64 [%110, %$20], [%142, %$24] ; # X
  %116 = phi i64 [%111, %$20], [%143, %$24] ; # R
  %117 = phi i64 [%114, %$20], [%144, %$24] ; # L
  %118 = phi i64 [%113, %$20], [%145, %$24] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %119 = inttoptr i64 %118 to i64*
  %120 = getelementptr i64, i64* %119, i32 3
  %121 = load i64, i64* %120
; # (pair (val 4 P))
  %122 = and i64 %121, 15
  %123 = icmp eq i64 %122, 0
  br i1 %123, label %$22, label %$23
$22:
  %124 = phi i64 [%115, %$21] ; # X
  %125 = phi i64 [%116, %$21] ; # R
  %126 = phi i64 [%117, %$21] ; # L
  %127 = phi i64 [%118, %$21] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %128 = inttoptr i64 %121 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 %127 to i64*
  %132 = getelementptr i64, i64* %131, i32 3
  store i64 %130, i64* %132
  br label %$23
$23:
  %133 = phi i64 [%115, %$21], [%124, %$22] ; # X
  %134 = phi i64 [%116, %$21], [%125, %$22] ; # R
  %135 = phi i64 [%117, %$21], [%126, %$22] ; # L
  %136 = phi i64 [%118, %$21], [%127, %$22] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %137 = inttoptr i64 %136 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
; # (atom (shift P))
  %140 = and i64 %139, 15
  %141 = icmp ne i64 %140, 0
  br i1 %141, label %$25, label %$24
$24:
  %142 = phi i64 [%133, %$23] ; # X
  %143 = phi i64 [%134, %$23] ; # R
  %144 = phi i64 [%135, %$23] ; # L
  %145 = phi i64 [%139, %$23] ; # P
  br label %$21
$25:
  %146 = phi i64 [%133, %$23] ; # X
  %147 = phi i64 [%134, %$23] ; # R
  %148 = phi i64 [%135, %$23] ; # L
  %149 = phi i64 [%139, %$23] ; # P
  %150 = phi i64 [0, %$23] ; # ->
  br label %$15
$17:
  %151 = phi i64 [%81, %$15] ; # X
  %152 = phi i64 [%82, %$15] ; # R
  %153 = phi i64 [%83, %$15] ; # L
  %154 = phi i64 [0, %$15] ; # ->
; # (drop *Safe)
  %155 = inttoptr i64 %5 to i64*
  %156 = getelementptr i64, i64* %155, i32 1
  %157 = load i64, i64* %156
  %158 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %157, i64* %158
  ret i64 %152
}

define i64 @_mapcar(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %55, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %57 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (cons (evList E) $Nil) (setq L ...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (let Y (cons (evList E) $Nil) (setq L (if L (set 2 L Y) (se...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%220, %$27] ; # X
  %126 = phi i64 [%123, %$17], [%221, %$27] ; # R
  %127 = phi i64 [%124, %$17], [%222, %$27] ; # L
; # (let Y (cons (evList E) $Nil) (setq L (if L (set 2 L Y) (setq R (...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (cons (evList E) $Nil)
  %129 = call i64 @cons(i64 %128, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %130 = icmp ne i64 %127, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # L
; # (set 2 L Y)
  %134 = inttoptr i64 %133 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  store i64 %129, i64* %135
  br label %$22
$21:
  %136 = phi i64 [%125, %$19] ; # X
  %137 = phi i64 [%126, %$19] ; # R
  %138 = phi i64 [%127, %$19] ; # L
; # (safe Y)
  %139 = inttoptr i64 %5 to i64*
  store i64 %129, i64* %139
  br label %$22
$22:
  %140 = phi i64 [%131, %$20], [%136, %$21] ; # X
  %141 = phi i64 [%132, %$20], [%129, %$21] ; # R
  %142 = phi i64 [%133, %$20], [%138, %$21] ; # L
  %143 = phi i64 [%129, %$20], [%129, %$21] ; # ->
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %144 = inttoptr i64 %33 to i64*
  %145 = load i64, i64* %144
  %146 = inttoptr i64 %145 to i64*
  %147 = getelementptr i64, i64* %146, i32 1
  %148 = load i64, i64* %147
  %149 = inttoptr i64 %33 to i64*
  store i64 %148, i64* %149
; # (atom (set A (cdar A)))
  %150 = and i64 %148, 15
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$24, label %$23
$23:
  %152 = phi i64 [%140, %$22] ; # X
  %153 = phi i64 [%141, %$22] ; # R
  %154 = phi i64 [%143, %$22] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %155 = inttoptr i64 %25 to i64*
  %156 = getelementptr i64, i64* %155, i32 1
  %157 = load i64, i64* %156
; # (set 4 P (car @))
; # (car @)
  %158 = inttoptr i64 %148 to i64*
  %159 = load i64, i64* %158
  %160 = inttoptr i64 %157 to i64*
  %161 = getelementptr i64, i64* %160, i32 3
  store i64 %159, i64* %161
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$25
$25:
  %162 = phi i64 [%152, %$23], [%212, %$28] ; # X
  %163 = phi i64 [%153, %$23], [%213, %$28] ; # R
  %164 = phi i64 [%154, %$23], [%214, %$28] ; # L
  %165 = phi i64 [%157, %$23], [%215, %$28] ; # P
  %166 = phi i64 [%33, %$23], [%216, %$28] ; # Q
; # (shift P)
  %167 = inttoptr i64 %165 to i64*
  %168 = getelementptr i64, i64* %167, i32 1
  %169 = load i64, i64* %168
; # (pair (shift P))
  %170 = and i64 %169, 15
  %171 = icmp eq i64 %170, 0
  br i1 %171, label %$26, label %$27
$26:
  %172 = phi i64 [%162, %$25] ; # X
  %173 = phi i64 [%163, %$25] ; # R
  %174 = phi i64 [%164, %$25] ; # L
  %175 = phi i64 [%169, %$25] ; # P
  %176 = phi i64 [%166, %$25] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %177 = inttoptr i64 %176 to i64*
  %178 = getelementptr i64, i64* %177, i32 1
  %179 = load i64, i64* %178
; # (car (shift Q))
  %180 = inttoptr i64 %179 to i64*
  %181 = load i64, i64* %180
; # (atom (car (shift Q)))
  %182 = and i64 %181, 15
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$30, label %$29
$30:
  %184 = phi i64 [%172, %$26] ; # X
  %185 = phi i64 [%173, %$26] ; # R
  %186 = phi i64 [%174, %$26] ; # L
  %187 = phi i64 [%175, %$26] ; # P
  %188 = phi i64 [%179, %$26] ; # Q
  br label %$28
$29:
  %189 = phi i64 [%172, %$26] ; # X
  %190 = phi i64 [%173, %$26] ; # R
  %191 = phi i64 [%174, %$26] ; # L
  %192 = phi i64 [%175, %$26] ; # P
  %193 = phi i64 [%179, %$26] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %194 = inttoptr i64 %181 to i64*
  %195 = getelementptr i64, i64* %194, i32 1
  %196 = load i64, i64* %195
  %197 = inttoptr i64 %193 to i64*
  store i64 %196, i64* %197
; # (atom (set Q (cdr @)))
  %198 = and i64 %196, 15
  %199 = icmp ne i64 %198, 0
  br i1 %199, label %$32, label %$31
$32:
  %200 = phi i64 [%189, %$29] ; # X
  %201 = phi i64 [%190, %$29] ; # R
  %202 = phi i64 [%191, %$29] ; # L
  %203 = phi i64 [%192, %$29] ; # P
  %204 = phi i64 [%193, %$29] ; # Q
  br label %$28
$31:
  %205 = phi i64 [%189, %$29] ; # X
  %206 = phi i64 [%190, %$29] ; # R
  %207 = phi i64 [%191, %$29] ; # L
  %208 = phi i64 [%192, %$29] ; # P
  %209 = phi i64 [%193, %$29] ; # Q
; # (car @)
  %210 = inttoptr i64 %196 to i64*
  %211 = load i64, i64* %210
  br label %$28
$28:
  %212 = phi i64 [%184, %$30], [%200, %$32], [%205, %$31] ; # X
  %213 = phi i64 [%185, %$30], [%201, %$32], [%206, %$31] ; # R
  %214 = phi i64 [%186, %$30], [%202, %$32], [%207, %$31] ; # L
  %215 = phi i64 [%187, %$30], [%203, %$32], [%208, %$31] ; # P
  %216 = phi i64 [%188, %$30], [%204, %$32], [%209, %$31] ; # Q
  %217 = phi i64 [%181, %$30], [%196, %$32], [%211, %$31] ; # ->
  %218 = inttoptr i64 %175 to i64*
  %219 = getelementptr i64, i64* %218, i32 3
  store i64 %217, i64* %219
  br label %$25
$27:
  %220 = phi i64 [%162, %$25] ; # X
  %221 = phi i64 [%163, %$25] ; # R
  %222 = phi i64 [%164, %$25] ; # L
  %223 = phi i64 [%169, %$25] ; # P
  %224 = phi i64 [%166, %$25] ; # Q
  br label %$19
$24:
  %225 = phi i64 [%140, %$22] ; # X
  %226 = phi i64 [%141, %$22] ; # R
  %227 = phi i64 [%143, %$22] ; # L
  %228 = phi i64 [0, %$22] ; # ->
  br label %$18
$18:
  %229 = phi i64 [%112, %$16], [%225, %$24] ; # X
  %230 = phi i64 [%113, %$16], [%226, %$24] ; # R
  %231 = phi i64 [%114, %$16], [%227, %$24] ; # L
; # (drop *Safe)
  %232 = inttoptr i64 %5 to i64*
  %233 = getelementptr i64, i64* %232, i32 1
  %234 = load i64, i64* %233
  %235 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %234, i64* %235
  ret i64 %230
}

define i64 @_mapcon(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (car X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
; # (eval (car X))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$4, label %$3
$4:
  br label %$2
$3:
  %16 = and i64 %13, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$6, label %$5
$6:
  %18 = inttoptr i64 %13 to i64*
  %19 = load i64, i64* %18
  br label %$2
$5:
  %20 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %21 = phi i64 [%13, %$4], [%19, %$6], [%20, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %22 = alloca i64, i64 5, align 16
  %23 = ptrtoint i64* %22 to i64
  %24 = add i64 %23, 8
  %25 = inttoptr i64 %24 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %25
  %26 = add i64 %23, 16
  %27 = inttoptr i64 %26 to i64*
  store i64 2, i64* %27
  %28 = add i64 %23, 24
  %29 = inttoptr i64 %28 to i64*
  store i64 %21, i64* %29
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %30 = add i64 %23, 24
; # (link (ofs E 3))
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %30 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %35
  %36 = inttoptr i64 %23 to i64*
  store i64 %30, i64* %36
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %37 = phi i64 [%3, %$2], [%46, %$10] ; # X
  %38 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%47, %$10] ; # R
  %39 = phi i64 [0, %$2], [%48, %$10] ; # L
  %40 = phi i64 [%23, %$2], [%61, %$10] ; # P
; # (shift X)
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (pair (shift X))
  %44 = and i64 %43, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$8, label %$9
$8:
  %46 = phi i64 [%43, %$7] ; # X
  %47 = phi i64 [%38, %$7] ; # R
  %48 = phi i64 [%39, %$7] ; # L
  %49 = phi i64 [%40, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %50 = inttoptr i64 %46 to i64*
  %51 = load i64, i64* %50
; # (eval (car X))
  %52 = and i64 %51, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$12, label %$11
$12:
  br label %$10
$11:
  %54 = and i64 %51, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$14, label %$13
$14:
  %56 = inttoptr i64 %51 to i64*
  %57 = load i64, i64* %56
  br label %$10
$13:
  %58 = call i64 @evList(i64 %51)
  br label %$10
$10:
  %59 = phi i64 [%51, %$12], [%57, %$14], [%58, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %60 = alloca i64, i64 5, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = add i64 %61, 8
  %63 = inttoptr i64 %62 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
  %64 = add i64 %61, 16
  %65 = inttoptr i64 %64 to i64*
  store i64 2, i64* %65
  %66 = add i64 %61, 24
  %67 = inttoptr i64 %66 to i64*
  store i64 %59, i64* %67
  %68 = inttoptr i64 %49 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %61, i64* %69
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %70 = add i64 %61, 24
; # (link (ofs P 3))
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
  %73 = inttoptr i64 %70 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  store i64 %72, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %75
  %76 = inttoptr i64 %61 to i64*
  store i64 %70, i64* %76
  br label %$7
$9:
  %77 = phi i64 [%43, %$7] ; # X
  %78 = phi i64 [%38, %$7] ; # R
  %79 = phi i64 [%39, %$7] ; # L
  %80 = phi i64 [%40, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P))) (let Y (evList E) (when...
  br label %$15
$15:
  %81 = phi i64 [%77, %$9], [%175, %$30] ; # X
  %82 = phi i64 [%78, %$9], [%176, %$30] ; # R
  %83 = phi i64 [%79, %$9], [%177, %$30] ; # L
; # (let P (cdr E) (? (atom (val 4 P))) (let Y (evList E) (when (pair...
; # (cdr E)
  %84 = inttoptr i64 %23 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (? (atom (val 4 P)))
; # (val 4 P)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 3
  %89 = load i64, i64* %88
; # (atom (val 4 P))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$17, label %$16
$16:
  %92 = phi i64 [%81, %$15] ; # X
  %93 = phi i64 [%82, %$15] ; # R
  %94 = phi i64 [%83, %$15] ; # L
  %95 = phi i64 [%86, %$15] ; # P
; # (let Y (evList E) (when (pair Y) (setq L (if L (let Z L (while (p...
; # (evList E)
  %96 = call i64 @evList(i64 %23)
; # (when (pair Y) (setq L (if L (let Z L (while (pair (cdr Z)) (setq...
; # (pair Y)
  %97 = and i64 %96, 15
  %98 = icmp eq i64 %97, 0
  br i1 %98, label %$18, label %$19
$18:
  %99 = phi i64 [%92, %$16] ; # X
  %100 = phi i64 [%93, %$16] ; # R
  %101 = phi i64 [%94, %$16] ; # L
  %102 = phi i64 [%95, %$16] ; # P
; # (if L (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y)) (se...
  %103 = icmp ne i64 %101, 0
  br i1 %103, label %$20, label %$21
$20:
  %104 = phi i64 [%99, %$18] ; # X
  %105 = phi i64 [%100, %$18] ; # R
  %106 = phi i64 [%101, %$18] ; # L
  %107 = phi i64 [%102, %$18] ; # P
; # (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y))
; # (while (pair (cdr Z)) (setq Z @))
  br label %$23
$23:
  %108 = phi i64 [%104, %$20], [%118, %$24] ; # X
  %109 = phi i64 [%105, %$20], [%119, %$24] ; # R
  %110 = phi i64 [%106, %$20], [%120, %$24] ; # L
  %111 = phi i64 [%107, %$20], [%121, %$24] ; # P
  %112 = phi i64 [%106, %$20], [%115, %$24] ; # Z
; # (cdr Z)
  %113 = inttoptr i64 %112 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  %115 = load i64, i64* %114
; # (pair (cdr Z))
  %116 = and i64 %115, 15
  %117 = icmp eq i64 %116, 0
  br i1 %117, label %$24, label %$25
$24:
  %118 = phi i64 [%108, %$23] ; # X
  %119 = phi i64 [%109, %$23] ; # R
  %120 = phi i64 [%110, %$23] ; # L
  %121 = phi i64 [%111, %$23] ; # P
  %122 = phi i64 [%112, %$23] ; # Z
  br label %$23
$25:
  %123 = phi i64 [%108, %$23] ; # X
  %124 = phi i64 [%109, %$23] ; # R
  %125 = phi i64 [%110, %$23] ; # L
  %126 = phi i64 [%111, %$23] ; # P
  %127 = phi i64 [%112, %$23] ; # Z
; # (set 2 Z Y)
  %128 = inttoptr i64 %127 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  store i64 %96, i64* %129
  br label %$22
$21:
  %130 = phi i64 [%99, %$18] ; # X
  %131 = phi i64 [%100, %$18] ; # R
  %132 = phi i64 [%101, %$18] ; # L
  %133 = phi i64 [%102, %$18] ; # P
; # (safe Y)
  %134 = inttoptr i64 %5 to i64*
  store i64 %96, i64* %134
  br label %$22
$22:
  %135 = phi i64 [%123, %$25], [%130, %$21] ; # X
  %136 = phi i64 [%124, %$25], [%96, %$21] ; # R
  %137 = phi i64 [%125, %$25], [%132, %$21] ; # L
  %138 = phi i64 [%126, %$25], [%133, %$21] ; # P
  %139 = phi i64 [%96, %$25], [%96, %$21] ; # ->
  br label %$19
$19:
  %140 = phi i64 [%92, %$16], [%135, %$22] ; # X
  %141 = phi i64 [%93, %$16], [%136, %$22] ; # R
  %142 = phi i64 [%94, %$16], [%139, %$22] ; # L
  %143 = phi i64 [%95, %$16], [%138, %$22] ; # P
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$26
$26:
  %144 = phi i64 [%140, %$19], [%171, %$29] ; # X
  %145 = phi i64 [%141, %$19], [%172, %$29] ; # R
  %146 = phi i64 [%142, %$19], [%173, %$29] ; # L
  %147 = phi i64 [%143, %$19], [%174, %$29] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %148 = inttoptr i64 %147 to i64*
  %149 = getelementptr i64, i64* %148, i32 3
  %150 = load i64, i64* %149
; # (pair (val 4 P))
  %151 = and i64 %150, 15
  %152 = icmp eq i64 %151, 0
  br i1 %152, label %$27, label %$28
$27:
  %153 = phi i64 [%144, %$26] ; # X
  %154 = phi i64 [%145, %$26] ; # R
  %155 = phi i64 [%146, %$26] ; # L
  %156 = phi i64 [%147, %$26] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %157 = inttoptr i64 %150 to i64*
  %158 = getelementptr i64, i64* %157, i32 1
  %159 = load i64, i64* %158
  %160 = inttoptr i64 %156 to i64*
  %161 = getelementptr i64, i64* %160, i32 3
  store i64 %159, i64* %161
  br label %$28
$28:
  %162 = phi i64 [%144, %$26], [%153, %$27] ; # X
  %163 = phi i64 [%145, %$26], [%154, %$27] ; # R
  %164 = phi i64 [%146, %$26], [%155, %$27] ; # L
  %165 = phi i64 [%147, %$26], [%156, %$27] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %166 = inttoptr i64 %165 to i64*
  %167 = getelementptr i64, i64* %166, i32 1
  %168 = load i64, i64* %167
; # (atom (shift P))
  %169 = and i64 %168, 15
  %170 = icmp ne i64 %169, 0
  br i1 %170, label %$30, label %$29
$29:
  %171 = phi i64 [%162, %$28] ; # X
  %172 = phi i64 [%163, %$28] ; # R
  %173 = phi i64 [%164, %$28] ; # L
  %174 = phi i64 [%168, %$28] ; # P
  br label %$26
$30:
  %175 = phi i64 [%162, %$28] ; # X
  %176 = phi i64 [%163, %$28] ; # R
  %177 = phi i64 [%164, %$28] ; # L
  %178 = phi i64 [%168, %$28] ; # P
  %179 = phi i64 [0, %$28] ; # ->
  br label %$15
$17:
  %180 = phi i64 [%81, %$15] ; # X
  %181 = phi i64 [%82, %$15] ; # R
  %182 = phi i64 [%83, %$15] ; # L
  %183 = phi i64 [0, %$15] ; # ->
; # (drop *Safe)
  %184 = inttoptr i64 %5 to i64*
  %185 = getelementptr i64, i64* %184, i32 1
  %186 = load i64, i64* %185
  %187 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %186, i64* %187
  ret i64 %181
}

define i64 @_mapcan(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %55, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %57 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (evList E) (when (pair Y) (setq...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (let Y (evList E) (when (pair Y) (setq L (if L (let Z L (wh...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%244, %$32] ; # X
  %126 = phi i64 [%123, %$17], [%245, %$32] ; # R
  %127 = phi i64 [%124, %$17], [%246, %$32] ; # L
; # (let Y (evList E) (when (pair Y) (setq L (if L (let Z L (while (p...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (when (pair Y) (setq L (if L (let Z L (while (pair (cdr Z)) (setq...
; # (pair Y)
  %129 = and i64 %128, 15
  %130 = icmp eq i64 %129, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # L
; # (if L (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y)) (se...
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$22, label %$23
$22:
  %135 = phi i64 [%131, %$20] ; # X
  %136 = phi i64 [%132, %$20] ; # R
  %137 = phi i64 [%133, %$20] ; # L
; # (let Z L (while (pair (cdr Z)) (setq Z @)) (set 2 Z Y))
; # (while (pair (cdr Z)) (setq Z @))
  br label %$25
$25:
  %138 = phi i64 [%135, %$22], [%147, %$26] ; # X
  %139 = phi i64 [%136, %$22], [%148, %$26] ; # R
  %140 = phi i64 [%137, %$22], [%149, %$26] ; # L
  %141 = phi i64 [%137, %$22], [%144, %$26] ; # Z
; # (cdr Z)
  %142 = inttoptr i64 %141 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  %144 = load i64, i64* %143
; # (pair (cdr Z))
  %145 = and i64 %144, 15
  %146 = icmp eq i64 %145, 0
  br i1 %146, label %$26, label %$27
$26:
  %147 = phi i64 [%138, %$25] ; # X
  %148 = phi i64 [%139, %$25] ; # R
  %149 = phi i64 [%140, %$25] ; # L
  %150 = phi i64 [%141, %$25] ; # Z
  br label %$25
$27:
  %151 = phi i64 [%138, %$25] ; # X
  %152 = phi i64 [%139, %$25] ; # R
  %153 = phi i64 [%140, %$25] ; # L
  %154 = phi i64 [%141, %$25] ; # Z
; # (set 2 Z Y)
  %155 = inttoptr i64 %154 to i64*
  %156 = getelementptr i64, i64* %155, i32 1
  store i64 %128, i64* %156
  br label %$24
$23:
  %157 = phi i64 [%131, %$20] ; # X
  %158 = phi i64 [%132, %$20] ; # R
  %159 = phi i64 [%133, %$20] ; # L
; # (safe Y)
  %160 = inttoptr i64 %5 to i64*
  store i64 %128, i64* %160
  br label %$24
$24:
  %161 = phi i64 [%151, %$27], [%157, %$23] ; # X
  %162 = phi i64 [%152, %$27], [%128, %$23] ; # R
  %163 = phi i64 [%153, %$27], [%159, %$23] ; # L
  %164 = phi i64 [%128, %$27], [%128, %$23] ; # ->
  br label %$21
$21:
  %165 = phi i64 [%125, %$19], [%161, %$24] ; # X
  %166 = phi i64 [%126, %$19], [%162, %$24] ; # R
  %167 = phi i64 [%127, %$19], [%164, %$24] ; # L
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %168 = inttoptr i64 %33 to i64*
  %169 = load i64, i64* %168
  %170 = inttoptr i64 %169 to i64*
  %171 = getelementptr i64, i64* %170, i32 1
  %172 = load i64, i64* %171
  %173 = inttoptr i64 %33 to i64*
  store i64 %172, i64* %173
; # (atom (set A (cdar A)))
  %174 = and i64 %172, 15
  %175 = icmp ne i64 %174, 0
  br i1 %175, label %$29, label %$28
$28:
  %176 = phi i64 [%165, %$21] ; # X
  %177 = phi i64 [%166, %$21] ; # R
  %178 = phi i64 [%167, %$21] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %179 = inttoptr i64 %25 to i64*
  %180 = getelementptr i64, i64* %179, i32 1
  %181 = load i64, i64* %180
; # (set 4 P (car @))
; # (car @)
  %182 = inttoptr i64 %172 to i64*
  %183 = load i64, i64* %182
  %184 = inttoptr i64 %181 to i64*
  %185 = getelementptr i64, i64* %184, i32 3
  store i64 %183, i64* %185
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$30
$30:
  %186 = phi i64 [%176, %$28], [%236, %$33] ; # X
  %187 = phi i64 [%177, %$28], [%237, %$33] ; # R
  %188 = phi i64 [%178, %$28], [%238, %$33] ; # L
  %189 = phi i64 [%181, %$28], [%239, %$33] ; # P
  %190 = phi i64 [%33, %$28], [%240, %$33] ; # Q
; # (shift P)
  %191 = inttoptr i64 %189 to i64*
  %192 = getelementptr i64, i64* %191, i32 1
  %193 = load i64, i64* %192
; # (pair (shift P))
  %194 = and i64 %193, 15
  %195 = icmp eq i64 %194, 0
  br i1 %195, label %$31, label %$32
$31:
  %196 = phi i64 [%186, %$30] ; # X
  %197 = phi i64 [%187, %$30] ; # R
  %198 = phi i64 [%188, %$30] ; # L
  %199 = phi i64 [%193, %$30] ; # P
  %200 = phi i64 [%190, %$30] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %201 = inttoptr i64 %200 to i64*
  %202 = getelementptr i64, i64* %201, i32 1
  %203 = load i64, i64* %202
; # (car (shift Q))
  %204 = inttoptr i64 %203 to i64*
  %205 = load i64, i64* %204
; # (atom (car (shift Q)))
  %206 = and i64 %205, 15
  %207 = icmp ne i64 %206, 0
  br i1 %207, label %$35, label %$34
$35:
  %208 = phi i64 [%196, %$31] ; # X
  %209 = phi i64 [%197, %$31] ; # R
  %210 = phi i64 [%198, %$31] ; # L
  %211 = phi i64 [%199, %$31] ; # P
  %212 = phi i64 [%203, %$31] ; # Q
  br label %$33
$34:
  %213 = phi i64 [%196, %$31] ; # X
  %214 = phi i64 [%197, %$31] ; # R
  %215 = phi i64 [%198, %$31] ; # L
  %216 = phi i64 [%199, %$31] ; # P
  %217 = phi i64 [%203, %$31] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %218 = inttoptr i64 %205 to i64*
  %219 = getelementptr i64, i64* %218, i32 1
  %220 = load i64, i64* %219
  %221 = inttoptr i64 %217 to i64*
  store i64 %220, i64* %221
; # (atom (set Q (cdr @)))
  %222 = and i64 %220, 15
  %223 = icmp ne i64 %222, 0
  br i1 %223, label %$37, label %$36
$37:
  %224 = phi i64 [%213, %$34] ; # X
  %225 = phi i64 [%214, %$34] ; # R
  %226 = phi i64 [%215, %$34] ; # L
  %227 = phi i64 [%216, %$34] ; # P
  %228 = phi i64 [%217, %$34] ; # Q
  br label %$33
$36:
  %229 = phi i64 [%213, %$34] ; # X
  %230 = phi i64 [%214, %$34] ; # R
  %231 = phi i64 [%215, %$34] ; # L
  %232 = phi i64 [%216, %$34] ; # P
  %233 = phi i64 [%217, %$34] ; # Q
; # (car @)
  %234 = inttoptr i64 %220 to i64*
  %235 = load i64, i64* %234
  br label %$33
$33:
  %236 = phi i64 [%208, %$35], [%224, %$37], [%229, %$36] ; # X
  %237 = phi i64 [%209, %$35], [%225, %$37], [%230, %$36] ; # R
  %238 = phi i64 [%210, %$35], [%226, %$37], [%231, %$36] ; # L
  %239 = phi i64 [%211, %$35], [%227, %$37], [%232, %$36] ; # P
  %240 = phi i64 [%212, %$35], [%228, %$37], [%233, %$36] ; # Q
  %241 = phi i64 [%205, %$35], [%220, %$37], [%235, %$36] ; # ->
  %242 = inttoptr i64 %199 to i64*
  %243 = getelementptr i64, i64* %242, i32 3
  store i64 %241, i64* %243
  br label %$30
$32:
  %244 = phi i64 [%186, %$30] ; # X
  %245 = phi i64 [%187, %$30] ; # R
  %246 = phi i64 [%188, %$30] ; # L
  %247 = phi i64 [%193, %$30] ; # P
  %248 = phi i64 [%190, %$30] ; # Q
  br label %$19
$29:
  %249 = phi i64 [%165, %$21] ; # X
  %250 = phi i64 [%166, %$21] ; # R
  %251 = phi i64 [%167, %$21] ; # L
  %252 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %253 = phi i64 [%112, %$16], [%249, %$29] ; # X
  %254 = phi i64 [%113, %$16], [%250, %$29] ; # R
  %255 = phi i64 [%114, %$16], [%251, %$29] ; # L
; # (drop *Safe)
  %256 = inttoptr i64 %5 to i64*
  %257 = getelementptr i64, i64* %256, i32 1
  %258 = load i64, i64* %257
  %259 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %258, i64* %259
  ret i64 %254
}

define i64 @_filter(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %55, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %57 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (unless (nil? (evList E)) (let Y (cons...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (unless (nil? (evList E)) (let Y (cons (caar A) $Nil) (setq...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%231, %$29] ; # X
  %126 = phi i64 [%123, %$17], [%232, %$29] ; # R
  %127 = phi i64 [%124, %$17], [%233, %$29] ; # L
; # (unless (nil? (evList E)) (let Y (cons (caar A) $Nil) (setq L (if...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (nil? (evList E))
  %129 = icmp eq i64 %128, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %129, label %$21, label %$20
$20:
  %130 = phi i64 [%125, %$19] ; # X
  %131 = phi i64 [%126, %$19] ; # R
  %132 = phi i64 [%127, %$19] ; # L
; # (let Y (cons (caar A) $Nil) (setq L (if L (set 2 L Y) (setq R (sa...
; # (caar A)
  %133 = inttoptr i64 %33 to i64*
  %134 = load i64, i64* %133
  %135 = inttoptr i64 %134 to i64*
  %136 = load i64, i64* %135
; # (cons (caar A) $Nil)
  %137 = call i64 @cons(i64 %136, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %138 = icmp ne i64 %132, 0
  br i1 %138, label %$22, label %$23
$22:
  %139 = phi i64 [%130, %$20] ; # X
  %140 = phi i64 [%131, %$20] ; # R
  %141 = phi i64 [%132, %$20] ; # L
; # (set 2 L Y)
  %142 = inttoptr i64 %141 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  store i64 %137, i64* %143
  br label %$24
$23:
  %144 = phi i64 [%130, %$20] ; # X
  %145 = phi i64 [%131, %$20] ; # R
  %146 = phi i64 [%132, %$20] ; # L
; # (safe Y)
  %147 = inttoptr i64 %5 to i64*
  store i64 %137, i64* %147
  br label %$24
$24:
  %148 = phi i64 [%139, %$22], [%144, %$23] ; # X
  %149 = phi i64 [%140, %$22], [%137, %$23] ; # R
  %150 = phi i64 [%141, %$22], [%146, %$23] ; # L
  %151 = phi i64 [%137, %$22], [%137, %$23] ; # ->
  br label %$21
$21:
  %152 = phi i64 [%125, %$19], [%148, %$24] ; # X
  %153 = phi i64 [%126, %$19], [%149, %$24] ; # R
  %154 = phi i64 [%127, %$19], [%151, %$24] ; # L
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %155 = inttoptr i64 %33 to i64*
  %156 = load i64, i64* %155
  %157 = inttoptr i64 %156 to i64*
  %158 = getelementptr i64, i64* %157, i32 1
  %159 = load i64, i64* %158
  %160 = inttoptr i64 %33 to i64*
  store i64 %159, i64* %160
; # (atom (set A (cdar A)))
  %161 = and i64 %159, 15
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$26, label %$25
$25:
  %163 = phi i64 [%152, %$21] ; # X
  %164 = phi i64 [%153, %$21] ; # R
  %165 = phi i64 [%154, %$21] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %166 = inttoptr i64 %25 to i64*
  %167 = getelementptr i64, i64* %166, i32 1
  %168 = load i64, i64* %167
; # (set 4 P (car @))
; # (car @)
  %169 = inttoptr i64 %159 to i64*
  %170 = load i64, i64* %169
  %171 = inttoptr i64 %168 to i64*
  %172 = getelementptr i64, i64* %171, i32 3
  store i64 %170, i64* %172
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$27
$27:
  %173 = phi i64 [%163, %$25], [%223, %$30] ; # X
  %174 = phi i64 [%164, %$25], [%224, %$30] ; # R
  %175 = phi i64 [%165, %$25], [%225, %$30] ; # L
  %176 = phi i64 [%168, %$25], [%226, %$30] ; # P
  %177 = phi i64 [%33, %$25], [%227, %$30] ; # Q
; # (shift P)
  %178 = inttoptr i64 %176 to i64*
  %179 = getelementptr i64, i64* %178, i32 1
  %180 = load i64, i64* %179
; # (pair (shift P))
  %181 = and i64 %180, 15
  %182 = icmp eq i64 %181, 0
  br i1 %182, label %$28, label %$29
$28:
  %183 = phi i64 [%173, %$27] ; # X
  %184 = phi i64 [%174, %$27] ; # R
  %185 = phi i64 [%175, %$27] ; # L
  %186 = phi i64 [%180, %$27] ; # P
  %187 = phi i64 [%177, %$27] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %188 = inttoptr i64 %187 to i64*
  %189 = getelementptr i64, i64* %188, i32 1
  %190 = load i64, i64* %189
; # (car (shift Q))
  %191 = inttoptr i64 %190 to i64*
  %192 = load i64, i64* %191
; # (atom (car (shift Q)))
  %193 = and i64 %192, 15
  %194 = icmp ne i64 %193, 0
  br i1 %194, label %$32, label %$31
$32:
  %195 = phi i64 [%183, %$28] ; # X
  %196 = phi i64 [%184, %$28] ; # R
  %197 = phi i64 [%185, %$28] ; # L
  %198 = phi i64 [%186, %$28] ; # P
  %199 = phi i64 [%190, %$28] ; # Q
  br label %$30
$31:
  %200 = phi i64 [%183, %$28] ; # X
  %201 = phi i64 [%184, %$28] ; # R
  %202 = phi i64 [%185, %$28] ; # L
  %203 = phi i64 [%186, %$28] ; # P
  %204 = phi i64 [%190, %$28] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %205 = inttoptr i64 %192 to i64*
  %206 = getelementptr i64, i64* %205, i32 1
  %207 = load i64, i64* %206
  %208 = inttoptr i64 %204 to i64*
  store i64 %207, i64* %208
; # (atom (set Q (cdr @)))
  %209 = and i64 %207, 15
  %210 = icmp ne i64 %209, 0
  br i1 %210, label %$34, label %$33
$34:
  %211 = phi i64 [%200, %$31] ; # X
  %212 = phi i64 [%201, %$31] ; # R
  %213 = phi i64 [%202, %$31] ; # L
  %214 = phi i64 [%203, %$31] ; # P
  %215 = phi i64 [%204, %$31] ; # Q
  br label %$30
$33:
  %216 = phi i64 [%200, %$31] ; # X
  %217 = phi i64 [%201, %$31] ; # R
  %218 = phi i64 [%202, %$31] ; # L
  %219 = phi i64 [%203, %$31] ; # P
  %220 = phi i64 [%204, %$31] ; # Q
; # (car @)
  %221 = inttoptr i64 %207 to i64*
  %222 = load i64, i64* %221
  br label %$30
$30:
  %223 = phi i64 [%195, %$32], [%211, %$34], [%216, %$33] ; # X
  %224 = phi i64 [%196, %$32], [%212, %$34], [%217, %$33] ; # R
  %225 = phi i64 [%197, %$32], [%213, %$34], [%218, %$33] ; # L
  %226 = phi i64 [%198, %$32], [%214, %$34], [%219, %$33] ; # P
  %227 = phi i64 [%199, %$32], [%215, %$34], [%220, %$33] ; # Q
  %228 = phi i64 [%192, %$32], [%207, %$34], [%222, %$33] ; # ->
  %229 = inttoptr i64 %186 to i64*
  %230 = getelementptr i64, i64* %229, i32 3
  store i64 %228, i64* %230
  br label %$27
$29:
  %231 = phi i64 [%173, %$27] ; # X
  %232 = phi i64 [%174, %$27] ; # R
  %233 = phi i64 [%175, %$27] ; # L
  %234 = phi i64 [%180, %$27] ; # P
  %235 = phi i64 [%177, %$27] ; # Q
  br label %$19
$26:
  %236 = phi i64 [%152, %$21] ; # X
  %237 = phi i64 [%153, %$21] ; # R
  %238 = phi i64 [%154, %$21] ; # L
  %239 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %240 = phi i64 [%112, %$16], [%236, %$26] ; # X
  %241 = phi i64 [%113, %$16], [%237, %$26] ; # R
  %242 = phi i64 [%114, %$16], [%238, %$26] ; # L
; # (drop *Safe)
  %243 = inttoptr i64 %5 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  %245 = load i64, i64* %244
  %246 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %245, i64* %246
  ret i64 %241
}

define i64 @_extract(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [0, %$2], [%105, %$15] ; # L
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %55, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %57 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # L
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # L
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # L
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # L
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (unless (nil? (evList E)) (let Y (cons...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # L
; # (loop (unless (nil? (evList E)) (let Y (cons @ $Nil) (setq L (if ...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%227, %$29] ; # X
  %126 = phi i64 [%123, %$17], [%228, %$29] ; # R
  %127 = phi i64 [%124, %$17], [%229, %$29] ; # L
; # (unless (nil? (evList E)) (let Y (cons @ $Nil) (setq L (if L (set...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (nil? (evList E))
  %129 = icmp eq i64 %128, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %129, label %$21, label %$20
$20:
  %130 = phi i64 [%125, %$19] ; # X
  %131 = phi i64 [%126, %$19] ; # R
  %132 = phi i64 [%127, %$19] ; # L
; # (let Y (cons @ $Nil) (setq L (if L (set 2 L Y) (setq R (safe Y)))...
; # (cons @ $Nil)
  %133 = call i64 @cons(i64 %128, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %134 = icmp ne i64 %132, 0
  br i1 %134, label %$22, label %$23
$22:
  %135 = phi i64 [%130, %$20] ; # X
  %136 = phi i64 [%131, %$20] ; # R
  %137 = phi i64 [%132, %$20] ; # L
; # (set 2 L Y)
  %138 = inttoptr i64 %137 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  store i64 %133, i64* %139
  br label %$24
$23:
  %140 = phi i64 [%130, %$20] ; # X
  %141 = phi i64 [%131, %$20] ; # R
  %142 = phi i64 [%132, %$20] ; # L
; # (safe Y)
  %143 = inttoptr i64 %5 to i64*
  store i64 %133, i64* %143
  br label %$24
$24:
  %144 = phi i64 [%135, %$22], [%140, %$23] ; # X
  %145 = phi i64 [%136, %$22], [%133, %$23] ; # R
  %146 = phi i64 [%137, %$22], [%142, %$23] ; # L
  %147 = phi i64 [%133, %$22], [%133, %$23] ; # ->
  br label %$21
$21:
  %148 = phi i64 [%125, %$19], [%144, %$24] ; # X
  %149 = phi i64 [%126, %$19], [%145, %$24] ; # R
  %150 = phi i64 [%127, %$19], [%147, %$24] ; # L
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %151 = inttoptr i64 %33 to i64*
  %152 = load i64, i64* %151
  %153 = inttoptr i64 %152 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
  %156 = inttoptr i64 %33 to i64*
  store i64 %155, i64* %156
; # (atom (set A (cdar A)))
  %157 = and i64 %155, 15
  %158 = icmp ne i64 %157, 0
  br i1 %158, label %$26, label %$25
$25:
  %159 = phi i64 [%148, %$21] ; # X
  %160 = phi i64 [%149, %$21] ; # R
  %161 = phi i64 [%150, %$21] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %162 = inttoptr i64 %25 to i64*
  %163 = getelementptr i64, i64* %162, i32 1
  %164 = load i64, i64* %163
; # (set 4 P (car @))
; # (car @)
  %165 = inttoptr i64 %155 to i64*
  %166 = load i64, i64* %165
  %167 = inttoptr i64 %164 to i64*
  %168 = getelementptr i64, i64* %167, i32 3
  store i64 %166, i64* %168
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$27
$27:
  %169 = phi i64 [%159, %$25], [%219, %$30] ; # X
  %170 = phi i64 [%160, %$25], [%220, %$30] ; # R
  %171 = phi i64 [%161, %$25], [%221, %$30] ; # L
  %172 = phi i64 [%164, %$25], [%222, %$30] ; # P
  %173 = phi i64 [%33, %$25], [%223, %$30] ; # Q
; # (shift P)
  %174 = inttoptr i64 %172 to i64*
  %175 = getelementptr i64, i64* %174, i32 1
  %176 = load i64, i64* %175
; # (pair (shift P))
  %177 = and i64 %176, 15
  %178 = icmp eq i64 %177, 0
  br i1 %178, label %$28, label %$29
$28:
  %179 = phi i64 [%169, %$27] ; # X
  %180 = phi i64 [%170, %$27] ; # R
  %181 = phi i64 [%171, %$27] ; # L
  %182 = phi i64 [%176, %$27] ; # P
  %183 = phi i64 [%173, %$27] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %184 = inttoptr i64 %183 to i64*
  %185 = getelementptr i64, i64* %184, i32 1
  %186 = load i64, i64* %185
; # (car (shift Q))
  %187 = inttoptr i64 %186 to i64*
  %188 = load i64, i64* %187
; # (atom (car (shift Q)))
  %189 = and i64 %188, 15
  %190 = icmp ne i64 %189, 0
  br i1 %190, label %$32, label %$31
$32:
  %191 = phi i64 [%179, %$28] ; # X
  %192 = phi i64 [%180, %$28] ; # R
  %193 = phi i64 [%181, %$28] ; # L
  %194 = phi i64 [%182, %$28] ; # P
  %195 = phi i64 [%186, %$28] ; # Q
  br label %$30
$31:
  %196 = phi i64 [%179, %$28] ; # X
  %197 = phi i64 [%180, %$28] ; # R
  %198 = phi i64 [%181, %$28] ; # L
  %199 = phi i64 [%182, %$28] ; # P
  %200 = phi i64 [%186, %$28] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %201 = inttoptr i64 %188 to i64*
  %202 = getelementptr i64, i64* %201, i32 1
  %203 = load i64, i64* %202
  %204 = inttoptr i64 %200 to i64*
  store i64 %203, i64* %204
; # (atom (set Q (cdr @)))
  %205 = and i64 %203, 15
  %206 = icmp ne i64 %205, 0
  br i1 %206, label %$34, label %$33
$34:
  %207 = phi i64 [%196, %$31] ; # X
  %208 = phi i64 [%197, %$31] ; # R
  %209 = phi i64 [%198, %$31] ; # L
  %210 = phi i64 [%199, %$31] ; # P
  %211 = phi i64 [%200, %$31] ; # Q
  br label %$30
$33:
  %212 = phi i64 [%196, %$31] ; # X
  %213 = phi i64 [%197, %$31] ; # R
  %214 = phi i64 [%198, %$31] ; # L
  %215 = phi i64 [%199, %$31] ; # P
  %216 = phi i64 [%200, %$31] ; # Q
; # (car @)
  %217 = inttoptr i64 %203 to i64*
  %218 = load i64, i64* %217
  br label %$30
$30:
  %219 = phi i64 [%191, %$32], [%207, %$34], [%212, %$33] ; # X
  %220 = phi i64 [%192, %$32], [%208, %$34], [%213, %$33] ; # R
  %221 = phi i64 [%193, %$32], [%209, %$34], [%214, %$33] ; # L
  %222 = phi i64 [%194, %$32], [%210, %$34], [%215, %$33] ; # P
  %223 = phi i64 [%195, %$32], [%211, %$34], [%216, %$33] ; # Q
  %224 = phi i64 [%188, %$32], [%203, %$34], [%218, %$33] ; # ->
  %225 = inttoptr i64 %182 to i64*
  %226 = getelementptr i64, i64* %225, i32 3
  store i64 %224, i64* %226
  br label %$27
$29:
  %227 = phi i64 [%169, %$27] ; # X
  %228 = phi i64 [%170, %$27] ; # R
  %229 = phi i64 [%171, %$27] ; # L
  %230 = phi i64 [%176, %$27] ; # P
  %231 = phi i64 [%173, %$27] ; # Q
  br label %$19
$26:
  %232 = phi i64 [%148, %$21] ; # X
  %233 = phi i64 [%149, %$21] ; # R
  %234 = phi i64 [%150, %$21] ; # L
  %235 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %236 = phi i64 [%112, %$16], [%232, %$26] ; # X
  %237 = phi i64 [%113, %$16], [%233, %$26] ; # R
  %238 = phi i64 [%114, %$16], [%234, %$26] ; # L
; # (drop *Safe)
  %239 = inttoptr i64 %5 to i64*
  %240 = getelementptr i64, i64* %239, i32 1
  %241 = load i64, i64* %240
  %242 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %241, i64* %242
  ret i64 %237
}

define i64 @_seek(i64) {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (car X)) NIL)) (set...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %14 = alloca i64, i64 5, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = add i64 %15, 8
  %17 = inttoptr i64 %16 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %17
  %18 = add i64 %15, 16
  %19 = inttoptr i64 %18 to i64*
  store i64 2, i64* %19
  %20 = add i64 %15, 24
  %21 = inttoptr i64 %20 to i64*
  store i64 %13, i64* %21
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %22 = add i64 %15, 24
; # (link (ofs E 3) T)
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %24 = load i64, i64* %23
  %25 = inttoptr i64 %22 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  store i64 %24, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %22, i64* %27
  %28 = inttoptr i64 %15 to i64*
  store i64 %22, i64* %28
; # (let P E (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ...
; # (while (pair (shift X)) (setq P (set 2 P (push NIL $Nil ZERO (eva...
  br label %$7
$7:
  %29 = phi i64 [%3, %$2], [%36, %$10] ; # X
  %30 = phi i64 [%15, %$2], [%49, %$10] ; # P
; # (shift X)
  %31 = inttoptr i64 %29 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
; # (pair (shift X))
  %34 = and i64 %33, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$8, label %$9
$8:
  %36 = phi i64 [%33, %$7] ; # X
  %37 = phi i64 [%30, %$7] ; # P
; # (set 2 P (push NIL $Nil ZERO (eval (car X)) NIL))
; # (car X)
  %38 = inttoptr i64 %36 to i64*
  %39 = load i64, i64* %38
; # (eval (car X))
  %40 = and i64 %39, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  br label %$10
$11:
  %42 = and i64 %39, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$14, label %$13
$14:
  %44 = inttoptr i64 %39 to i64*
  %45 = load i64, i64* %44
  br label %$10
$13:
  %46 = call i64 @evList(i64 %39)
  br label %$10
$10:
  %47 = phi i64 [%39, %$12], [%45, %$14], [%46, %$13] ; # ->
; # (push NIL $Nil ZERO (eval (car X)) NIL)
  %48 = alloca i64, i64 5, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = add i64 %49, 8
  %51 = inttoptr i64 %50 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %51
  %52 = add i64 %49, 16
  %53 = inttoptr i64 %52 to i64*
  store i64 2, i64* %53
  %54 = add i64 %49, 24
  %55 = inttoptr i64 %54 to i64*
  store i64 %47, i64* %55
  %56 = inttoptr i64 %37 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  store i64 %49, i64* %57
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %58 = add i64 %49, 24
; # (link (ofs P 3))
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %58 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %63
  %64 = inttoptr i64 %49 to i64*
  store i64 %58, i64* %64
  br label %$7
$9:
  %65 = phi i64 [%33, %$7] ; # X
  %66 = phi i64 [%30, %$7] ; # P
; # (loop (let P (cdr E) (? (atom (val 4 P)) $Nil) (? (not (nil? (evL...
  br label %$15
$15:
  %67 = phi i64 [%65, %$9], [%114, %$25] ; # X
; # (let P (cdr E) (? (atom (val 4 P)) $Nil) (? (not (nil? (evList E)...
; # (cdr E)
  %68 = inttoptr i64 %15 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
; # (? (atom (val 4 P)) $Nil)
; # (val 4 P)
  %71 = inttoptr i64 %70 to i64*
  %72 = getelementptr i64, i64* %71, i32 3
  %73 = load i64, i64* %72
; # (atom (val 4 P))
  %74 = and i64 %73, 15
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$18, label %$16
$18:
  %76 = phi i64 [%67, %$15] ; # X
  %77 = phi i64 [%70, %$15] ; # P
  br label %$17
$16:
  %78 = phi i64 [%67, %$15] ; # X
  %79 = phi i64 [%70, %$15] ; # P
; # (? (not (nil? (evList E))) (set $At2 @) (val 4 P))
; # (evList E)
  %80 = call i64 @evList(i64 %15)
; # (nil? (evList E))
  %81 = icmp eq i64 %80, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (evList E)))
  %82 = icmp eq i1 %81, 0
  br i1 %82, label %$20, label %$19
$20:
  %83 = phi i64 [%78, %$16] ; # X
  %84 = phi i64 [%79, %$16] ; # P
; # (set $At2 @)
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %80, i64* %85
; # (val 4 P)
  %86 = inttoptr i64 %84 to i64*
  %87 = getelementptr i64, i64* %86, i32 3
  %88 = load i64, i64* %87
  br label %$17
$19:
  %89 = phi i64 [%78, %$16] ; # X
  %90 = phi i64 [%79, %$16] ; # P
; # (loop (when (pair (val 4 P)) (set 4 P (cdr @))) (? (atom (shift P...
  br label %$21
$21:
  %91 = phi i64 [%89, %$19], [%112, %$24] ; # X
  %92 = phi i64 [%90, %$19], [%113, %$24] ; # P
; # (when (pair (val 4 P)) (set 4 P (cdr @)))
; # (val 4 P)
  %93 = inttoptr i64 %92 to i64*
  %94 = getelementptr i64, i64* %93, i32 3
  %95 = load i64, i64* %94
; # (pair (val 4 P))
  %96 = and i64 %95, 15
  %97 = icmp eq i64 %96, 0
  br i1 %97, label %$22, label %$23
$22:
  %98 = phi i64 [%91, %$21] ; # X
  %99 = phi i64 [%92, %$21] ; # P
; # (set 4 P (cdr @))
; # (cdr @)
  %100 = inttoptr i64 %95 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  %102 = load i64, i64* %101
  %103 = inttoptr i64 %99 to i64*
  %104 = getelementptr i64, i64* %103, i32 3
  store i64 %102, i64* %104
  br label %$23
$23:
  %105 = phi i64 [%91, %$21], [%98, %$22] ; # X
  %106 = phi i64 [%92, %$21], [%99, %$22] ; # P
; # (? (atom (shift P)))
; # (shift P)
  %107 = inttoptr i64 %106 to i64*
  %108 = getelementptr i64, i64* %107, i32 1
  %109 = load i64, i64* %108
; # (atom (shift P))
  %110 = and i64 %109, 15
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$25, label %$24
$24:
  %112 = phi i64 [%105, %$23] ; # X
  %113 = phi i64 [%109, %$23] ; # P
  br label %$21
$25:
  %114 = phi i64 [%105, %$23] ; # X
  %115 = phi i64 [%109, %$23] ; # P
  %116 = phi i64 [0, %$23] ; # ->
  br label %$15
$17:
  %117 = phi i64 [%76, %$18], [%83, %$20] ; # X
  %118 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$18], [%88, %$20] ; # ->
; # (drop *Safe)
  %119 = inttoptr i64 %22 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  %122 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %121, i64* %122
  ret i64 %118
}

define i64 @_find(i64) {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL) A (pus...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%89, %$15] ; # X
  %34 = phi i64 [%17, %$2], [%90, %$15] ; # P
  %35 = phi i64 [%25, %$2], [%93, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (eval (car X))
  %38 = and i64 %37, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  br label %$8
$9:
  %40 = and i64 %37, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  %42 = inttoptr i64 %37 to i64*
  %43 = load i64, i64* %42
  br label %$8
$11:
  %44 = call i64 @evList(i64 %37)
  br label %$8
$8:
  %45 = phi i64 [%37, %$10], [%43, %$12], [%44, %$11] ; # ->
; # (save (eval (car X)))
  %46 = alloca i64, i64 2, align 16
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 %45, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
  %51 = inttoptr i64 %47 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %50, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %53
  %54 = inttoptr i64 %35 to i64*
  store i64 %45, i64* %54
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %55 = and i64 %45, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%33, %$8] ; # X
  %58 = phi i64 [%34, %$8] ; # P
  %59 = phi i64 [%35, %$8] ; # Q
  %60 = phi i64 [%45, %$8] ; # V
; # (car V)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  br label %$14
$14:
  %63 = phi i64 [%33, %$8], [%57, %$13] ; # X
  %64 = phi i64 [%34, %$8], [%58, %$13] ; # P
  %65 = phi i64 [%35, %$8], [%59, %$13] ; # Q
  %66 = phi i64 [%45, %$8], [%62, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %67 = alloca i64, i64 5, align 16
  %68 = ptrtoint i64* %67 to i64
  %69 = add i64 %68, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %70
  %71 = add i64 %68, 16
  %72 = inttoptr i64 %71 to i64*
  store i64 2, i64* %72
  %73 = add i64 %68, 24
  %74 = inttoptr i64 %73 to i64*
  store i64 %66, i64* %74
  %75 = inttoptr i64 %64 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %68, i64* %76
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %77 = add i64 %68, 24
; # (link (ofs P 3))
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
  %83 = inttoptr i64 %68 to i64*
  store i64 %77, i64* %83
; # (? (atom (shift X)))
; # (shift X)
  %84 = inttoptr i64 %63 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (atom (shift X))
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$16, label %$15
$15:
  %89 = phi i64 [%86, %$14] ; # X
  %90 = phi i64 [%68, %$14] ; # P
  %91 = phi i64 [%65, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$7
$16:
  %96 = phi i64 [%86, %$14] ; # X
  %97 = phi i64 [%68, %$14] ; # P
  %98 = phi i64 [%65, %$14] ; # Q
  %99 = phi i64 [0, %$14] ; # ->
; # (if (atom (car A)) $Nil (loop (? (not (nil? (evList E))) (set $At...
; # (car A)
  %100 = inttoptr i64 %25 to i64*
  %101 = load i64, i64* %100
; # (atom (car A))
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$17, label %$18
$17:
  %104 = phi i64 [%96, %$16] ; # X
  br label %$19
$18:
  %105 = phi i64 [%96, %$16] ; # X
; # (loop (? (not (nil? (evList E))) (set $At2 @) (caar A)) (? (atom ...
  br label %$20
$20:
  %106 = phi i64 [%105, %$18], [%178, %$28] ; # X
; # (? (not (nil? (evList E))) (set $At2 @) (caar A))
; # (evList E)
  %107 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %108 = icmp eq i64 %107, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (evList E)))
  %109 = icmp eq i1 %108, 0
  br i1 %109, label %$23, label %$21
$23:
  %110 = phi i64 [%106, %$20] ; # X
; # (set $At2 @)
  %111 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %107, i64* %111
; # (caar A)
  %112 = inttoptr i64 %25 to i64*
  %113 = load i64, i64* %112
  %114 = inttoptr i64 %113 to i64*
  %115 = load i64, i64* %114
  br label %$22
$21:
  %116 = phi i64 [%106, %$20] ; # X
; # (? (atom (set A (cdar A))) $Nil)
; # (set A (cdar A))
; # (cdar A)
  %117 = inttoptr i64 %25 to i64*
  %118 = load i64, i64* %117
  %119 = inttoptr i64 %118 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  %122 = inttoptr i64 %25 to i64*
  store i64 %121, i64* %122
; # (atom (set A (cdar A)))
  %123 = and i64 %121, 15
  %124 = icmp ne i64 %123, 0
  br i1 %124, label %$25, label %$24
$25:
  %125 = phi i64 [%116, %$21] ; # X
  br label %$22
$24:
  %126 = phi i64 [%116, %$21] ; # X
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %127 = inttoptr i64 %17 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  %129 = load i64, i64* %128
; # (set 4 P (car @))
; # (car @)
  %130 = inttoptr i64 %121 to i64*
  %131 = load i64, i64* %130
  %132 = inttoptr i64 %129 to i64*
  %133 = getelementptr i64, i64* %132, i32 3
  store i64 %131, i64* %133
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$26
$26:
  %134 = phi i64 [%126, %$24], [%172, %$29] ; # X
  %135 = phi i64 [%129, %$24], [%173, %$29] ; # P
  %136 = phi i64 [%25, %$24], [%174, %$29] ; # Q
; # (shift P)
  %137 = inttoptr i64 %135 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  %139 = load i64, i64* %138
; # (pair (shift P))
  %140 = and i64 %139, 15
  %141 = icmp eq i64 %140, 0
  br i1 %141, label %$27, label %$28
$27:
  %142 = phi i64 [%134, %$26] ; # X
  %143 = phi i64 [%139, %$26] ; # P
  %144 = phi i64 [%136, %$26] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %145 = inttoptr i64 %144 to i64*
  %146 = getelementptr i64, i64* %145, i32 1
  %147 = load i64, i64* %146
; # (car (shift Q))
  %148 = inttoptr i64 %147 to i64*
  %149 = load i64, i64* %148
; # (atom (car (shift Q)))
  %150 = and i64 %149, 15
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$31, label %$30
$31:
  %152 = phi i64 [%142, %$27] ; # X
  %153 = phi i64 [%143, %$27] ; # P
  %154 = phi i64 [%147, %$27] ; # Q
  br label %$29
$30:
  %155 = phi i64 [%142, %$27] ; # X
  %156 = phi i64 [%143, %$27] ; # P
  %157 = phi i64 [%147, %$27] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %158 = inttoptr i64 %149 to i64*
  %159 = getelementptr i64, i64* %158, i32 1
  %160 = load i64, i64* %159
  %161 = inttoptr i64 %157 to i64*
  store i64 %160, i64* %161
; # (atom (set Q (cdr @)))
  %162 = and i64 %160, 15
  %163 = icmp ne i64 %162, 0
  br i1 %163, label %$33, label %$32
$33:
  %164 = phi i64 [%155, %$30] ; # X
  %165 = phi i64 [%156, %$30] ; # P
  %166 = phi i64 [%157, %$30] ; # Q
  br label %$29
$32:
  %167 = phi i64 [%155, %$30] ; # X
  %168 = phi i64 [%156, %$30] ; # P
  %169 = phi i64 [%157, %$30] ; # Q
; # (car @)
  %170 = inttoptr i64 %160 to i64*
  %171 = load i64, i64* %170
  br label %$29
$29:
  %172 = phi i64 [%152, %$31], [%164, %$33], [%167, %$32] ; # X
  %173 = phi i64 [%153, %$31], [%165, %$33], [%168, %$32] ; # P
  %174 = phi i64 [%154, %$31], [%166, %$33], [%169, %$32] ; # Q
  %175 = phi i64 [%149, %$31], [%160, %$33], [%171, %$32] ; # ->
  %176 = inttoptr i64 %143 to i64*
  %177 = getelementptr i64, i64* %176, i32 3
  store i64 %175, i64* %177
  br label %$26
$28:
  %178 = phi i64 [%134, %$26] ; # X
  %179 = phi i64 [%139, %$26] ; # P
  %180 = phi i64 [%136, %$26] ; # Q
  br label %$20
$22:
  %181 = phi i64 [%110, %$23], [%125, %$25] ; # X
  %182 = phi i64 [%115, %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$25] ; # ->
  br label %$19
$19:
  %183 = phi i64 [%104, %$17], [%181, %$22] ; # X
  %184 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [%182, %$22] ; # ->
; # (drop *Safe)
  %185 = inttoptr i64 %26 to i64*
  %186 = getelementptr i64, i64* %185, i32 1
  %187 = load i64, i64* %186
  %188 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %187, i64* %188
  ret i64 %184
}

define i64 @_pick(i64) {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL) A (pus...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%89, %$15] ; # X
  %34 = phi i64 [%17, %$2], [%90, %$15] ; # P
  %35 = phi i64 [%25, %$2], [%93, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (eval (car X))
  %38 = and i64 %37, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  br label %$8
$9:
  %40 = and i64 %37, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  %42 = inttoptr i64 %37 to i64*
  %43 = load i64, i64* %42
  br label %$8
$11:
  %44 = call i64 @evList(i64 %37)
  br label %$8
$8:
  %45 = phi i64 [%37, %$10], [%43, %$12], [%44, %$11] ; # ->
; # (save (eval (car X)))
  %46 = alloca i64, i64 2, align 16
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 %45, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
  %51 = inttoptr i64 %47 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %50, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %53
  %54 = inttoptr i64 %35 to i64*
  store i64 %45, i64* %54
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %55 = and i64 %45, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%33, %$8] ; # X
  %58 = phi i64 [%34, %$8] ; # P
  %59 = phi i64 [%35, %$8] ; # Q
  %60 = phi i64 [%45, %$8] ; # V
; # (car V)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  br label %$14
$14:
  %63 = phi i64 [%33, %$8], [%57, %$13] ; # X
  %64 = phi i64 [%34, %$8], [%58, %$13] ; # P
  %65 = phi i64 [%35, %$8], [%59, %$13] ; # Q
  %66 = phi i64 [%45, %$8], [%62, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %67 = alloca i64, i64 5, align 16
  %68 = ptrtoint i64* %67 to i64
  %69 = add i64 %68, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %70
  %71 = add i64 %68, 16
  %72 = inttoptr i64 %71 to i64*
  store i64 2, i64* %72
  %73 = add i64 %68, 24
  %74 = inttoptr i64 %73 to i64*
  store i64 %66, i64* %74
  %75 = inttoptr i64 %64 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %68, i64* %76
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %77 = add i64 %68, 24
; # (link (ofs P 3))
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
  %83 = inttoptr i64 %68 to i64*
  store i64 %77, i64* %83
; # (? (atom (shift X)))
; # (shift X)
  %84 = inttoptr i64 %63 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (atom (shift X))
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$16, label %$15
$15:
  %89 = phi i64 [%86, %$14] ; # X
  %90 = phi i64 [%68, %$14] ; # P
  %91 = phi i64 [%65, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$7
$16:
  %96 = phi i64 [%86, %$14] ; # X
  %97 = phi i64 [%68, %$14] ; # P
  %98 = phi i64 [%65, %$14] ; # Q
  %99 = phi i64 [0, %$14] ; # ->
; # (if (atom (car A)) $Nil (loop (? (not (nil? (evList E))) @) (? (a...
; # (car A)
  %100 = inttoptr i64 %25 to i64*
  %101 = load i64, i64* %100
; # (atom (car A))
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$17, label %$18
$17:
  %104 = phi i64 [%96, %$16] ; # X
  br label %$19
$18:
  %105 = phi i64 [%96, %$16] ; # X
; # (loop (? (not (nil? (evList E))) @) (? (atom (set A (cdar A))) $N...
  br label %$20
$20:
  %106 = phi i64 [%105, %$18], [%173, %$28] ; # X
; # (? (not (nil? (evList E))) @)
; # (evList E)
  %107 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %108 = icmp eq i64 %107, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (evList E)))
  %109 = icmp eq i1 %108, 0
  br i1 %109, label %$23, label %$21
$23:
  %110 = phi i64 [%106, %$20] ; # X
  br label %$22
$21:
  %111 = phi i64 [%106, %$20] ; # X
; # (? (atom (set A (cdar A))) $Nil)
; # (set A (cdar A))
; # (cdar A)
  %112 = inttoptr i64 %25 to i64*
  %113 = load i64, i64* %112
  %114 = inttoptr i64 %113 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
  %117 = inttoptr i64 %25 to i64*
  store i64 %116, i64* %117
; # (atom (set A (cdar A)))
  %118 = and i64 %116, 15
  %119 = icmp ne i64 %118, 0
  br i1 %119, label %$25, label %$24
$25:
  %120 = phi i64 [%111, %$21] ; # X
  br label %$22
$24:
  %121 = phi i64 [%111, %$21] ; # X
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %122 = inttoptr i64 %17 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  %124 = load i64, i64* %123
; # (set 4 P (car @))
; # (car @)
  %125 = inttoptr i64 %116 to i64*
  %126 = load i64, i64* %125
  %127 = inttoptr i64 %124 to i64*
  %128 = getelementptr i64, i64* %127, i32 3
  store i64 %126, i64* %128
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$26
$26:
  %129 = phi i64 [%121, %$24], [%167, %$29] ; # X
  %130 = phi i64 [%124, %$24], [%168, %$29] ; # P
  %131 = phi i64 [%25, %$24], [%169, %$29] ; # Q
; # (shift P)
  %132 = inttoptr i64 %130 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  %134 = load i64, i64* %133
; # (pair (shift P))
  %135 = and i64 %134, 15
  %136 = icmp eq i64 %135, 0
  br i1 %136, label %$27, label %$28
$27:
  %137 = phi i64 [%129, %$26] ; # X
  %138 = phi i64 [%134, %$26] ; # P
  %139 = phi i64 [%131, %$26] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %140 = inttoptr i64 %139 to i64*
  %141 = getelementptr i64, i64* %140, i32 1
  %142 = load i64, i64* %141
; # (car (shift Q))
  %143 = inttoptr i64 %142 to i64*
  %144 = load i64, i64* %143
; # (atom (car (shift Q)))
  %145 = and i64 %144, 15
  %146 = icmp ne i64 %145, 0
  br i1 %146, label %$31, label %$30
$31:
  %147 = phi i64 [%137, %$27] ; # X
  %148 = phi i64 [%138, %$27] ; # P
  %149 = phi i64 [%142, %$27] ; # Q
  br label %$29
$30:
  %150 = phi i64 [%137, %$27] ; # X
  %151 = phi i64 [%138, %$27] ; # P
  %152 = phi i64 [%142, %$27] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %153 = inttoptr i64 %144 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
  %156 = inttoptr i64 %152 to i64*
  store i64 %155, i64* %156
; # (atom (set Q (cdr @)))
  %157 = and i64 %155, 15
  %158 = icmp ne i64 %157, 0
  br i1 %158, label %$33, label %$32
$33:
  %159 = phi i64 [%150, %$30] ; # X
  %160 = phi i64 [%151, %$30] ; # P
  %161 = phi i64 [%152, %$30] ; # Q
  br label %$29
$32:
  %162 = phi i64 [%150, %$30] ; # X
  %163 = phi i64 [%151, %$30] ; # P
  %164 = phi i64 [%152, %$30] ; # Q
; # (car @)
  %165 = inttoptr i64 %155 to i64*
  %166 = load i64, i64* %165
  br label %$29
$29:
  %167 = phi i64 [%147, %$31], [%159, %$33], [%162, %$32] ; # X
  %168 = phi i64 [%148, %$31], [%160, %$33], [%163, %$32] ; # P
  %169 = phi i64 [%149, %$31], [%161, %$33], [%164, %$32] ; # Q
  %170 = phi i64 [%144, %$31], [%155, %$33], [%166, %$32] ; # ->
  %171 = inttoptr i64 %138 to i64*
  %172 = getelementptr i64, i64* %171, i32 3
  store i64 %170, i64* %172
  br label %$26
$28:
  %173 = phi i64 [%129, %$26] ; # X
  %174 = phi i64 [%134, %$26] ; # P
  %175 = phi i64 [%131, %$26] ; # Q
  br label %$20
$22:
  %176 = phi i64 [%110, %$23], [%120, %$25] ; # X
  %177 = phi i64 [%107, %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$25] ; # ->
  br label %$19
$19:
  %178 = phi i64 [%104, %$17], [%176, %$22] ; # X
  %179 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [%177, %$22] ; # ->
; # (drop *Safe)
  %180 = inttoptr i64 %26 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
  %183 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %182, i64* %183
  ret i64 %179
}

define i64 @_fully(i64) {
$1:
; # (let (X (cdr Exe) E (push NIL $Nil ZERO (eval (++ X)) NIL) A (pus...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%89, %$15] ; # X
  %34 = phi i64 [%17, %$2], [%90, %$15] ; # P
  %35 = phi i64 [%25, %$2], [%93, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (eval (car X))
  %38 = and i64 %37, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$10, label %$9
$10:
  br label %$8
$9:
  %40 = and i64 %37, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$12, label %$11
$12:
  %42 = inttoptr i64 %37 to i64*
  %43 = load i64, i64* %42
  br label %$8
$11:
  %44 = call i64 @evList(i64 %37)
  br label %$8
$8:
  %45 = phi i64 [%37, %$10], [%43, %$12], [%44, %$11] ; # ->
; # (save (eval (car X)))
  %46 = alloca i64, i64 2, align 16
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 %45, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
  %51 = inttoptr i64 %47 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %50, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %53
  %54 = inttoptr i64 %35 to i64*
  store i64 %45, i64* %54
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %55 = and i64 %45, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%33, %$8] ; # X
  %58 = phi i64 [%34, %$8] ; # P
  %59 = phi i64 [%35, %$8] ; # Q
  %60 = phi i64 [%45, %$8] ; # V
; # (car V)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  br label %$14
$14:
  %63 = phi i64 [%33, %$8], [%57, %$13] ; # X
  %64 = phi i64 [%34, %$8], [%58, %$13] ; # P
  %65 = phi i64 [%35, %$8], [%59, %$13] ; # Q
  %66 = phi i64 [%45, %$8], [%62, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %67 = alloca i64, i64 5, align 16
  %68 = ptrtoint i64* %67 to i64
  %69 = add i64 %68, 8
  %70 = inttoptr i64 %69 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %70
  %71 = add i64 %68, 16
  %72 = inttoptr i64 %71 to i64*
  store i64 2, i64* %72
  %73 = add i64 %68, 24
  %74 = inttoptr i64 %73 to i64*
  store i64 %66, i64* %74
  %75 = inttoptr i64 %64 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %68, i64* %76
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %77 = add i64 %68, 24
; # (link (ofs P 3))
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %79 = load i64, i64* %78
  %80 = inttoptr i64 %77 to i64*
  %81 = getelementptr i64, i64* %80, i32 1
  store i64 %79, i64* %81
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %82
  %83 = inttoptr i64 %68 to i64*
  store i64 %77, i64* %83
; # (? (atom (shift X)))
; # (shift X)
  %84 = inttoptr i64 %63 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (atom (shift X))
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$16, label %$15
$15:
  %89 = phi i64 [%86, %$14] ; # X
  %90 = phi i64 [%68, %$14] ; # P
  %91 = phi i64 [%65, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$7
$16:
  %96 = phi i64 [%86, %$14] ; # X
  %97 = phi i64 [%68, %$14] ; # P
  %98 = phi i64 [%65, %$14] ; # Q
  %99 = phi i64 [0, %$14] ; # ->
; # (if (atom (car A)) $T (loop (? (nil? (evList E)) @) (? (atom (set...
; # (car A)
  %100 = inttoptr i64 %25 to i64*
  %101 = load i64, i64* %100
; # (atom (car A))
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$17, label %$18
$17:
  %104 = phi i64 [%96, %$16] ; # X
  br label %$19
$18:
  %105 = phi i64 [%96, %$16] ; # X
; # (loop (? (nil? (evList E)) @) (? (atom (set A (cdar A))) $T) (let...
  br label %$20
$20:
  %106 = phi i64 [%105, %$18], [%172, %$28] ; # X
; # (? (nil? (evList E)) @)
; # (evList E)
  %107 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %108 = icmp eq i64 %107, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %108, label %$23, label %$21
$23:
  %109 = phi i64 [%106, %$20] ; # X
  br label %$22
$21:
  %110 = phi i64 [%106, %$20] ; # X
; # (? (atom (set A (cdar A))) $T)
; # (set A (cdar A))
; # (cdar A)
  %111 = inttoptr i64 %25 to i64*
  %112 = load i64, i64* %111
  %113 = inttoptr i64 %112 to i64*
  %114 = getelementptr i64, i64* %113, i32 1
  %115 = load i64, i64* %114
  %116 = inttoptr i64 %25 to i64*
  store i64 %115, i64* %116
; # (atom (set A (cdar A)))
  %117 = and i64 %115, 15
  %118 = icmp ne i64 %117, 0
  br i1 %118, label %$25, label %$24
$25:
  %119 = phi i64 [%110, %$21] ; # X
  br label %$22
$24:
  %120 = phi i64 [%110, %$21] ; # X
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %121 = inttoptr i64 %17 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  %123 = load i64, i64* %122
; # (set 4 P (car @))
; # (car @)
  %124 = inttoptr i64 %115 to i64*
  %125 = load i64, i64* %124
  %126 = inttoptr i64 %123 to i64*
  %127 = getelementptr i64, i64* %126, i32 3
  store i64 %125, i64* %127
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$26
$26:
  %128 = phi i64 [%120, %$24], [%166, %$29] ; # X
  %129 = phi i64 [%123, %$24], [%167, %$29] ; # P
  %130 = phi i64 [%25, %$24], [%168, %$29] ; # Q
; # (shift P)
  %131 = inttoptr i64 %129 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  %133 = load i64, i64* %132
; # (pair (shift P))
  %134 = and i64 %133, 15
  %135 = icmp eq i64 %134, 0
  br i1 %135, label %$27, label %$28
$27:
  %136 = phi i64 [%128, %$26] ; # X
  %137 = phi i64 [%133, %$26] ; # P
  %138 = phi i64 [%130, %$26] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %139 = inttoptr i64 %138 to i64*
  %140 = getelementptr i64, i64* %139, i32 1
  %141 = load i64, i64* %140
; # (car (shift Q))
  %142 = inttoptr i64 %141 to i64*
  %143 = load i64, i64* %142
; # (atom (car (shift Q)))
  %144 = and i64 %143, 15
  %145 = icmp ne i64 %144, 0
  br i1 %145, label %$31, label %$30
$31:
  %146 = phi i64 [%136, %$27] ; # X
  %147 = phi i64 [%137, %$27] ; # P
  %148 = phi i64 [%141, %$27] ; # Q
  br label %$29
$30:
  %149 = phi i64 [%136, %$27] ; # X
  %150 = phi i64 [%137, %$27] ; # P
  %151 = phi i64 [%141, %$27] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %152 = inttoptr i64 %143 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
  %155 = inttoptr i64 %151 to i64*
  store i64 %154, i64* %155
; # (atom (set Q (cdr @)))
  %156 = and i64 %154, 15
  %157 = icmp ne i64 %156, 0
  br i1 %157, label %$33, label %$32
$33:
  %158 = phi i64 [%149, %$30] ; # X
  %159 = phi i64 [%150, %$30] ; # P
  %160 = phi i64 [%151, %$30] ; # Q
  br label %$29
$32:
  %161 = phi i64 [%149, %$30] ; # X
  %162 = phi i64 [%150, %$30] ; # P
  %163 = phi i64 [%151, %$30] ; # Q
; # (car @)
  %164 = inttoptr i64 %154 to i64*
  %165 = load i64, i64* %164
  br label %$29
$29:
  %166 = phi i64 [%146, %$31], [%158, %$33], [%161, %$32] ; # X
  %167 = phi i64 [%147, %$31], [%159, %$33], [%162, %$32] ; # P
  %168 = phi i64 [%148, %$31], [%160, %$33], [%163, %$32] ; # Q
  %169 = phi i64 [%143, %$31], [%154, %$33], [%165, %$32] ; # ->
  %170 = inttoptr i64 %137 to i64*
  %171 = getelementptr i64, i64* %170, i32 3
  store i64 %169, i64* %171
  br label %$26
$28:
  %172 = phi i64 [%128, %$26] ; # X
  %173 = phi i64 [%133, %$26] ; # P
  %174 = phi i64 [%130, %$26] ; # Q
  br label %$20
$22:
  %175 = phi i64 [%109, %$23], [%119, %$25] ; # X
  %176 = phi i64 [%107, %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$25] ; # ->
  br label %$19
$19:
  %177 = phi i64 [%104, %$17], [%175, %$22] ; # X
  %178 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$17], [%176, %$22] ; # ->
; # (drop *Safe)
  %179 = inttoptr i64 %26 to i64*
  %180 = getelementptr i64, i64* %179, i32 1
  %181 = load i64, i64* %180
  %182 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %181, i64* %182
  ret i64 %178
}

define i64 @_cnt(i64) {
$1:
; # (let (X (cdr Exe) R ZERO E (push NIL $Nil ZERO (eval (++ X)) NIL)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %16 = alloca i64, i64 5, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = add i64 %17, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %19
  %20 = add i64 %17, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 2, i64* %21
  %22 = add i64 %17, 24
  %23 = inttoptr i64 %22 to i64*
  store i64 %15, i64* %23
; # (push NIL NIL)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
; # (set E (link (ofs E 3) T))
; # (ofs E 3)
  %26 = add i64 %17, 24
; # (link (ofs E 3) T)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %26 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %26, i64* %31
  %32 = inttoptr i64 %17 to i64*
  store i64 %26, i64* %32
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %33 = phi i64 [%7, %$2], [%92, %$15] ; # X
  %34 = phi i64 [2, %$2], [%93, %$15] ; # R
  %35 = phi i64 [%17, %$2], [%94, %$15] ; # P
  %36 = phi i64 [%25, %$2], [%97, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %37 = inttoptr i64 %33 to i64*
  %38 = load i64, i64* %37
; # (eval (car X))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$10, label %$9
$10:
  br label %$8
$9:
  %41 = and i64 %38, 8
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$12, label %$11
$12:
  %43 = inttoptr i64 %38 to i64*
  %44 = load i64, i64* %43
  br label %$8
$11:
  %45 = call i64 @evList(i64 %38)
  br label %$8
$8:
  %46 = phi i64 [%38, %$10], [%44, %$12], [%45, %$11] ; # ->
; # (save (eval (car X)))
  %47 = alloca i64, i64 2, align 16
  %48 = ptrtoint i64* %47 to i64
  %49 = inttoptr i64 %48 to i64*
  store i64 %46, i64* %49
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %48 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  store i64 %51, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %54
  %55 = inttoptr i64 %36 to i64*
  store i64 %46, i64* %55
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %56 = and i64 %46, 15
  %57 = icmp eq i64 %56, 0
  br i1 %57, label %$13, label %$14
$13:
  %58 = phi i64 [%33, %$8] ; # X
  %59 = phi i64 [%34, %$8] ; # R
  %60 = phi i64 [%35, %$8] ; # P
  %61 = phi i64 [%36, %$8] ; # Q
  %62 = phi i64 [%46, %$8] ; # V
; # (car V)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  br label %$14
$14:
  %65 = phi i64 [%33, %$8], [%58, %$13] ; # X
  %66 = phi i64 [%34, %$8], [%59, %$13] ; # R
  %67 = phi i64 [%35, %$8], [%60, %$13] ; # P
  %68 = phi i64 [%36, %$8], [%61, %$13] ; # Q
  %69 = phi i64 [%46, %$8], [%64, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %70 = alloca i64, i64 5, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = add i64 %71, 8
  %73 = inttoptr i64 %72 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %73
  %74 = add i64 %71, 16
  %75 = inttoptr i64 %74 to i64*
  store i64 2, i64* %75
  %76 = add i64 %71, 24
  %77 = inttoptr i64 %76 to i64*
  store i64 %69, i64* %77
  %78 = inttoptr i64 %67 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %71, i64* %79
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %80 = add i64 %71, 24
; # (link (ofs P 3))
  %81 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %82 = load i64, i64* %81
  %83 = inttoptr i64 %80 to i64*
  %84 = getelementptr i64, i64* %83, i32 1
  store i64 %82, i64* %84
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %80, i64* %85
  %86 = inttoptr i64 %71 to i64*
  store i64 %80, i64* %86
; # (? (atom (shift X)))
; # (shift X)
  %87 = inttoptr i64 %65 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
; # (atom (shift X))
  %90 = and i64 %89, 15
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$16, label %$15
$15:
  %92 = phi i64 [%89, %$14] ; # X
  %93 = phi i64 [%66, %$14] ; # R
  %94 = phi i64 [%71, %$14] ; # P
  %95 = phi i64 [%68, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %96 = alloca i64, i64 2, align 16
  %97 = ptrtoint i64* %96 to i64
  %98 = inttoptr i64 %95 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  store i64 %97, i64* %99
  br label %$7
$16:
  %100 = phi i64 [%89, %$14] ; # X
  %101 = phi i64 [%66, %$14] ; # R
  %102 = phi i64 [%71, %$14] ; # P
  %103 = phi i64 [%68, %$14] ; # Q
  %104 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (unless (nil? (evList E)) (inc 'R (hex...
; # (car A)
  %105 = inttoptr i64 %25 to i64*
  %106 = load i64, i64* %105
; # (pair (car A))
  %107 = and i64 %106, 15
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %$17, label %$18
$17:
  %109 = phi i64 [%100, %$16] ; # X
  %110 = phi i64 [%101, %$16] ; # R
; # (loop (unless (nil? (evList E)) (inc 'R (hex "10"))) (? (atom (se...
  br label %$19
$19:
  %111 = phi i64 [%109, %$17], [%188, %$26] ; # X
  %112 = phi i64 [%110, %$17], [%189, %$26] ; # R
; # (unless (nil? (evList E)) (inc 'R (hex "10")))
; # (evList E)
  %113 = call i64 @evList(i64 %17)
; # (nil? (evList E))
  %114 = icmp eq i64 %113, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %114, label %$21, label %$20
$20:
  %115 = phi i64 [%111, %$19] ; # X
  %116 = phi i64 [%112, %$19] ; # R
; # (inc 'R (hex "10"))
  %117 = add i64 %116, 16
  br label %$21
$21:
  %118 = phi i64 [%111, %$19], [%115, %$20] ; # X
  %119 = phi i64 [%112, %$19], [%117, %$20] ; # R
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %120 = inttoptr i64 %25 to i64*
  %121 = load i64, i64* %120
  %122 = inttoptr i64 %121 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  %124 = load i64, i64* %123
  %125 = inttoptr i64 %25 to i64*
  store i64 %124, i64* %125
; # (atom (set A (cdar A)))
  %126 = and i64 %124, 15
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$23, label %$22
$22:
  %128 = phi i64 [%118, %$21] ; # X
  %129 = phi i64 [%119, %$21] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %130 = inttoptr i64 %17 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  %132 = load i64, i64* %131
; # (set 4 P (car @))
; # (car @)
  %133 = inttoptr i64 %124 to i64*
  %134 = load i64, i64* %133
  %135 = inttoptr i64 %132 to i64*
  %136 = getelementptr i64, i64* %135, i32 3
  store i64 %134, i64* %136
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %137 = phi i64 [%128, %$22], [%181, %$27] ; # X
  %138 = phi i64 [%129, %$22], [%182, %$27] ; # R
  %139 = phi i64 [%132, %$22], [%183, %$27] ; # P
  %140 = phi i64 [%25, %$22], [%184, %$27] ; # Q
; # (shift P)
  %141 = inttoptr i64 %139 to i64*
  %142 = getelementptr i64, i64* %141, i32 1
  %143 = load i64, i64* %142
; # (pair (shift P))
  %144 = and i64 %143, 15
  %145 = icmp eq i64 %144, 0
  br i1 %145, label %$25, label %$26
$25:
  %146 = phi i64 [%137, %$24] ; # X
  %147 = phi i64 [%138, %$24] ; # R
  %148 = phi i64 [%143, %$24] ; # P
  %149 = phi i64 [%140, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %150 = inttoptr i64 %149 to i64*
  %151 = getelementptr i64, i64* %150, i32 1
  %152 = load i64, i64* %151
; # (car (shift Q))
  %153 = inttoptr i64 %152 to i64*
  %154 = load i64, i64* %153
; # (atom (car (shift Q)))
  %155 = and i64 %154, 15
  %156 = icmp ne i64 %155, 0
  br i1 %156, label %$29, label %$28
$29:
  %157 = phi i64 [%146, %$25] ; # X
  %158 = phi i64 [%147, %$25] ; # R
  %159 = phi i64 [%148, %$25] ; # P
  %160 = phi i64 [%152, %$25] ; # Q
  br label %$27
$28:
  %161 = phi i64 [%146, %$25] ; # X
  %162 = phi i64 [%147, %$25] ; # R
  %163 = phi i64 [%148, %$25] ; # P
  %164 = phi i64 [%152, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %165 = inttoptr i64 %154 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
  %168 = inttoptr i64 %164 to i64*
  store i64 %167, i64* %168
; # (atom (set Q (cdr @)))
  %169 = and i64 %167, 15
  %170 = icmp ne i64 %169, 0
  br i1 %170, label %$31, label %$30
$31:
  %171 = phi i64 [%161, %$28] ; # X
  %172 = phi i64 [%162, %$28] ; # R
  %173 = phi i64 [%163, %$28] ; # P
  %174 = phi i64 [%164, %$28] ; # Q
  br label %$27
$30:
  %175 = phi i64 [%161, %$28] ; # X
  %176 = phi i64 [%162, %$28] ; # R
  %177 = phi i64 [%163, %$28] ; # P
  %178 = phi i64 [%164, %$28] ; # Q
; # (car @)
  %179 = inttoptr i64 %167 to i64*
  %180 = load i64, i64* %179
  br label %$27
$27:
  %181 = phi i64 [%157, %$29], [%171, %$31], [%175, %$30] ; # X
  %182 = phi i64 [%158, %$29], [%172, %$31], [%176, %$30] ; # R
  %183 = phi i64 [%159, %$29], [%173, %$31], [%177, %$30] ; # P
  %184 = phi i64 [%160, %$29], [%174, %$31], [%178, %$30] ; # Q
  %185 = phi i64 [%154, %$29], [%167, %$31], [%180, %$30] ; # ->
  %186 = inttoptr i64 %148 to i64*
  %187 = getelementptr i64, i64* %186, i32 3
  store i64 %185, i64* %187
  br label %$24
$26:
  %188 = phi i64 [%137, %$24] ; # X
  %189 = phi i64 [%138, %$24] ; # R
  %190 = phi i64 [%143, %$24] ; # P
  %191 = phi i64 [%140, %$24] ; # Q
  br label %$19
$23:
  %192 = phi i64 [%118, %$21] ; # X
  %193 = phi i64 [%119, %$21] ; # R
  %194 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %195 = phi i64 [%100, %$16], [%192, %$23] ; # X
  %196 = phi i64 [%101, %$16], [%193, %$23] ; # R
; # (drop *Safe)
  %197 = inttoptr i64 %26 to i64*
  %198 = getelementptr i64, i64* %197, i32 1
  %199 = load i64, i64* %198
  %200 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %199, i64* %200
  ret i64 %196
}

define i64 @_sum(i64) {
$1:
; # (let (X (cdr Exe) R (save ZERO) E (push NIL $Nil ZERO (eval (++ X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save ZERO)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 2, i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%100, %$15] ; # X
  %42 = phi i64 [2, %$2], [%101, %$15] ; # R
  %43 = phi i64 [%25, %$2], [%102, %$15] ; # P
  %44 = phi i64 [%33, %$2], [%105, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %45 = inttoptr i64 %41 to i64*
  %46 = load i64, i64* %45
; # (eval (car X))
  %47 = and i64 %46, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$10, label %$9
$10:
  br label %$8
$9:
  %49 = and i64 %46, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$12, label %$11
$12:
  %51 = inttoptr i64 %46 to i64*
  %52 = load i64, i64* %51
  br label %$8
$11:
  %53 = call i64 @evList(i64 %46)
  br label %$8
$8:
  %54 = phi i64 [%46, %$10], [%52, %$12], [%53, %$11] ; # ->
; # (save (eval (car X)))
  %55 = alloca i64, i64 2, align 16
  %56 = ptrtoint i64* %55 to i64
  %57 = inttoptr i64 %56 to i64*
  store i64 %54, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 %56 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %59, i64* %61
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %56, i64* %62
  %63 = inttoptr i64 %44 to i64*
  store i64 %54, i64* %63
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %64 = and i64 %54, 15
  %65 = icmp eq i64 %64, 0
  br i1 %65, label %$13, label %$14
$13:
  %66 = phi i64 [%41, %$8] ; # X
  %67 = phi i64 [%42, %$8] ; # R
  %68 = phi i64 [%43, %$8] ; # P
  %69 = phi i64 [%44, %$8] ; # Q
  %70 = phi i64 [%54, %$8] ; # V
; # (car V)
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
  br label %$14
$14:
  %73 = phi i64 [%41, %$8], [%66, %$13] ; # X
  %74 = phi i64 [%42, %$8], [%67, %$13] ; # R
  %75 = phi i64 [%43, %$8], [%68, %$13] ; # P
  %76 = phi i64 [%44, %$8], [%69, %$13] ; # Q
  %77 = phi i64 [%54, %$8], [%72, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %78 = alloca i64, i64 5, align 16
  %79 = ptrtoint i64* %78 to i64
  %80 = add i64 %79, 8
  %81 = inttoptr i64 %80 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %81
  %82 = add i64 %79, 16
  %83 = inttoptr i64 %82 to i64*
  store i64 2, i64* %83
  %84 = add i64 %79, 24
  %85 = inttoptr i64 %84 to i64*
  store i64 %77, i64* %85
  %86 = inttoptr i64 %75 to i64*
  %87 = getelementptr i64, i64* %86, i32 1
  store i64 %79, i64* %87
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %88 = add i64 %79, 24
; # (link (ofs P 3))
  %89 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %90 = load i64, i64* %89
  %91 = inttoptr i64 %88 to i64*
  %92 = getelementptr i64, i64* %91, i32 1
  store i64 %90, i64* %92
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %88, i64* %93
  %94 = inttoptr i64 %79 to i64*
  store i64 %88, i64* %94
; # (? (atom (shift X)))
; # (shift X)
  %95 = inttoptr i64 %73 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
; # (atom (shift X))
  %98 = and i64 %97, 15
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$16, label %$15
$15:
  %100 = phi i64 [%97, %$14] ; # X
  %101 = phi i64 [%74, %$14] ; # R
  %102 = phi i64 [%79, %$14] ; # P
  %103 = phi i64 [%76, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %104 = alloca i64, i64 2, align 16
  %105 = ptrtoint i64* %104 to i64
  %106 = inttoptr i64 %103 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  store i64 %105, i64* %107
  br label %$7
$16:
  %108 = phi i64 [%97, %$14] ; # X
  %109 = phi i64 [%74, %$14] ; # R
  %110 = phi i64 [%79, %$14] ; # P
  %111 = phi i64 [%76, %$14] ; # Q
  %112 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (when (num? (evList E)) (save @ (setq ...
; # (car A)
  %113 = inttoptr i64 %33 to i64*
  %114 = load i64, i64* %113
; # (pair (car A))
  %115 = and i64 %114, 15
  %116 = icmp eq i64 %115, 0
  br i1 %116, label %$17, label %$18
$17:
  %117 = phi i64 [%108, %$16] ; # X
  %118 = phi i64 [%109, %$16] ; # R
; # (loop (when (num? (evList E)) (save @ (setq R (safe (adds R @))))...
  br label %$19
$19:
  %119 = phi i64 [%117, %$17], [%210, %$26] ; # X
  %120 = phi i64 [%118, %$17], [%211, %$26] ; # R
; # (when (num? (evList E)) (save @ (setq R (safe (adds R @)))))
; # (evList E)
  %121 = call i64 @evList(i64 %25)
; # (num? (evList E))
  %122 = and i64 %121, 6
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$20, label %$21
$20:
  %124 = phi i64 [%119, %$19] ; # X
  %125 = phi i64 [%120, %$19] ; # R
; # (save @ (setq R (safe (adds R @))))
  %126 = alloca i64, i64 2, align 16
  %127 = ptrtoint i64* %126 to i64
  %128 = inttoptr i64 %127 to i64*
  store i64 %121, i64* %128
  %129 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %130 = load i64, i64* %129
  %131 = inttoptr i64 %127 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  store i64 %130, i64* %132
  %133 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %127, i64* %133
; # (adds R @)
  %134 = call i64 @adds(i64 %125, i64 %121)
; # (safe (adds R @))
  %135 = inttoptr i64 %5 to i64*
  store i64 %134, i64* %135
  %136 = inttoptr i64 %127 to i64*
  %137 = getelementptr i64, i64* %136, i32 1
  %138 = load i64, i64* %137
  %139 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %138, i64* %139
  br label %$21
$21:
  %140 = phi i64 [%119, %$19], [%124, %$20] ; # X
  %141 = phi i64 [%120, %$19], [%134, %$20] ; # R
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %142 = inttoptr i64 %33 to i64*
  %143 = load i64, i64* %142
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %33 to i64*
  store i64 %146, i64* %147
; # (atom (set A (cdar A)))
  %148 = and i64 %146, 15
  %149 = icmp ne i64 %148, 0
  br i1 %149, label %$23, label %$22
$22:
  %150 = phi i64 [%140, %$21] ; # X
  %151 = phi i64 [%141, %$21] ; # R
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %152 = inttoptr i64 %25 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
; # (set 4 P (car @))
; # (car @)
  %155 = inttoptr i64 %146 to i64*
  %156 = load i64, i64* %155
  %157 = inttoptr i64 %154 to i64*
  %158 = getelementptr i64, i64* %157, i32 3
  store i64 %156, i64* %158
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %159 = phi i64 [%150, %$22], [%203, %$27] ; # X
  %160 = phi i64 [%151, %$22], [%204, %$27] ; # R
  %161 = phi i64 [%154, %$22], [%205, %$27] ; # P
  %162 = phi i64 [%33, %$22], [%206, %$27] ; # Q
; # (shift P)
  %163 = inttoptr i64 %161 to i64*
  %164 = getelementptr i64, i64* %163, i32 1
  %165 = load i64, i64* %164
; # (pair (shift P))
  %166 = and i64 %165, 15
  %167 = icmp eq i64 %166, 0
  br i1 %167, label %$25, label %$26
$25:
  %168 = phi i64 [%159, %$24] ; # X
  %169 = phi i64 [%160, %$24] ; # R
  %170 = phi i64 [%165, %$24] ; # P
  %171 = phi i64 [%162, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %172 = inttoptr i64 %171 to i64*
  %173 = getelementptr i64, i64* %172, i32 1
  %174 = load i64, i64* %173
; # (car (shift Q))
  %175 = inttoptr i64 %174 to i64*
  %176 = load i64, i64* %175
; # (atom (car (shift Q)))
  %177 = and i64 %176, 15
  %178 = icmp ne i64 %177, 0
  br i1 %178, label %$29, label %$28
$29:
  %179 = phi i64 [%168, %$25] ; # X
  %180 = phi i64 [%169, %$25] ; # R
  %181 = phi i64 [%170, %$25] ; # P
  %182 = phi i64 [%174, %$25] ; # Q
  br label %$27
$28:
  %183 = phi i64 [%168, %$25] ; # X
  %184 = phi i64 [%169, %$25] ; # R
  %185 = phi i64 [%170, %$25] ; # P
  %186 = phi i64 [%174, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %187 = inttoptr i64 %176 to i64*
  %188 = getelementptr i64, i64* %187, i32 1
  %189 = load i64, i64* %188
  %190 = inttoptr i64 %186 to i64*
  store i64 %189, i64* %190
; # (atom (set Q (cdr @)))
  %191 = and i64 %189, 15
  %192 = icmp ne i64 %191, 0
  br i1 %192, label %$31, label %$30
$31:
  %193 = phi i64 [%183, %$28] ; # X
  %194 = phi i64 [%184, %$28] ; # R
  %195 = phi i64 [%185, %$28] ; # P
  %196 = phi i64 [%186, %$28] ; # Q
  br label %$27
$30:
  %197 = phi i64 [%183, %$28] ; # X
  %198 = phi i64 [%184, %$28] ; # R
  %199 = phi i64 [%185, %$28] ; # P
  %200 = phi i64 [%186, %$28] ; # Q
; # (car @)
  %201 = inttoptr i64 %189 to i64*
  %202 = load i64, i64* %201
  br label %$27
$27:
  %203 = phi i64 [%179, %$29], [%193, %$31], [%197, %$30] ; # X
  %204 = phi i64 [%180, %$29], [%194, %$31], [%198, %$30] ; # R
  %205 = phi i64 [%181, %$29], [%195, %$31], [%199, %$30] ; # P
  %206 = phi i64 [%182, %$29], [%196, %$31], [%200, %$30] ; # Q
  %207 = phi i64 [%176, %$29], [%189, %$31], [%202, %$30] ; # ->
  %208 = inttoptr i64 %170 to i64*
  %209 = getelementptr i64, i64* %208, i32 3
  store i64 %207, i64* %209
  br label %$24
$26:
  %210 = phi i64 [%159, %$24] ; # X
  %211 = phi i64 [%160, %$24] ; # R
  %212 = phi i64 [%165, %$24] ; # P
  %213 = phi i64 [%162, %$24] ; # Q
  br label %$19
$23:
  %214 = phi i64 [%140, %$21] ; # X
  %215 = phi i64 [%141, %$21] ; # R
  %216 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %217 = phi i64 [%108, %$16], [%214, %$23] ; # X
  %218 = phi i64 [%109, %$16], [%215, %$23] ; # R
; # (drop *Safe)
  %219 = inttoptr i64 %5 to i64*
  %220 = getelementptr i64, i64* %219, i32 1
  %221 = load i64, i64* %220
  %222 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %221, i64* %222
  ret i64 %218
}

define i64 @_maxi(i64) {
$1:
; # (let (X (cdr Exe) R $Nil R2 (save $Nil) E (push NIL $Nil ZERO (ev...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%105, %$15] ; # R2
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %55, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %57 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # R2
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # R2
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # R2
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # R2
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (evList E) (when (gt0 (compare ...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # R2
; # (loop (let Y (evList E) (when (gt0 (compare Y R2)) (setq R (caar ...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%218, %$26] ; # X
  %126 = phi i64 [%123, %$17], [%219, %$26] ; # R
  %127 = phi i64 [%124, %$17], [%220, %$26] ; # R2
; # (let Y (evList E) (when (gt0 (compare Y R2)) (setq R (caar A)) (s...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (when (gt0 (compare Y R2)) (setq R (caar A)) (setq R2 (safe Y)))
; # (compare Y R2)
  %129 = call i64 @compare(i64 %128, i64 %127)
; # (gt0 (compare Y R2))
  %130 = icmp sgt i64 %129, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # R2
; # (caar A)
  %134 = inttoptr i64 %33 to i64*
  %135 = load i64, i64* %134
  %136 = inttoptr i64 %135 to i64*
  %137 = load i64, i64* %136
; # (safe Y)
  %138 = inttoptr i64 %5 to i64*
  store i64 %128, i64* %138
  br label %$21
$21:
  %139 = phi i64 [%125, %$19], [%131, %$20] ; # X
  %140 = phi i64 [%126, %$19], [%137, %$20] ; # R
  %141 = phi i64 [%127, %$19], [%128, %$20] ; # R2
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %142 = inttoptr i64 %33 to i64*
  %143 = load i64, i64* %142
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %33 to i64*
  store i64 %146, i64* %147
; # (atom (set A (cdar A)))
  %148 = and i64 %146, 15
  %149 = icmp ne i64 %148, 0
  br i1 %149, label %$23, label %$22
$22:
  %150 = phi i64 [%139, %$21] ; # X
  %151 = phi i64 [%140, %$21] ; # R
  %152 = phi i64 [%141, %$21] ; # R2
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %153 = inttoptr i64 %25 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
; # (set 4 P (car @))
; # (car @)
  %156 = inttoptr i64 %146 to i64*
  %157 = load i64, i64* %156
  %158 = inttoptr i64 %155 to i64*
  %159 = getelementptr i64, i64* %158, i32 3
  store i64 %157, i64* %159
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %160 = phi i64 [%150, %$22], [%210, %$27] ; # X
  %161 = phi i64 [%151, %$22], [%211, %$27] ; # R
  %162 = phi i64 [%152, %$22], [%212, %$27] ; # R2
  %163 = phi i64 [%155, %$22], [%213, %$27] ; # P
  %164 = phi i64 [%33, %$22], [%214, %$27] ; # Q
; # (shift P)
  %165 = inttoptr i64 %163 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
; # (pair (shift P))
  %168 = and i64 %167, 15
  %169 = icmp eq i64 %168, 0
  br i1 %169, label %$25, label %$26
$25:
  %170 = phi i64 [%160, %$24] ; # X
  %171 = phi i64 [%161, %$24] ; # R
  %172 = phi i64 [%162, %$24] ; # R2
  %173 = phi i64 [%167, %$24] ; # P
  %174 = phi i64 [%164, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %175 = inttoptr i64 %174 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  %177 = load i64, i64* %176
; # (car (shift Q))
  %178 = inttoptr i64 %177 to i64*
  %179 = load i64, i64* %178
; # (atom (car (shift Q)))
  %180 = and i64 %179, 15
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$29, label %$28
$29:
  %182 = phi i64 [%170, %$25] ; # X
  %183 = phi i64 [%171, %$25] ; # R
  %184 = phi i64 [%172, %$25] ; # R2
  %185 = phi i64 [%173, %$25] ; # P
  %186 = phi i64 [%177, %$25] ; # Q
  br label %$27
$28:
  %187 = phi i64 [%170, %$25] ; # X
  %188 = phi i64 [%171, %$25] ; # R
  %189 = phi i64 [%172, %$25] ; # R2
  %190 = phi i64 [%173, %$25] ; # P
  %191 = phi i64 [%177, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %192 = inttoptr i64 %179 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
  %195 = inttoptr i64 %191 to i64*
  store i64 %194, i64* %195
; # (atom (set Q (cdr @)))
  %196 = and i64 %194, 15
  %197 = icmp ne i64 %196, 0
  br i1 %197, label %$31, label %$30
$31:
  %198 = phi i64 [%187, %$28] ; # X
  %199 = phi i64 [%188, %$28] ; # R
  %200 = phi i64 [%189, %$28] ; # R2
  %201 = phi i64 [%190, %$28] ; # P
  %202 = phi i64 [%191, %$28] ; # Q
  br label %$27
$30:
  %203 = phi i64 [%187, %$28] ; # X
  %204 = phi i64 [%188, %$28] ; # R
  %205 = phi i64 [%189, %$28] ; # R2
  %206 = phi i64 [%190, %$28] ; # P
  %207 = phi i64 [%191, %$28] ; # Q
; # (car @)
  %208 = inttoptr i64 %194 to i64*
  %209 = load i64, i64* %208
  br label %$27
$27:
  %210 = phi i64 [%182, %$29], [%198, %$31], [%203, %$30] ; # X
  %211 = phi i64 [%183, %$29], [%199, %$31], [%204, %$30] ; # R
  %212 = phi i64 [%184, %$29], [%200, %$31], [%205, %$30] ; # R2
  %213 = phi i64 [%185, %$29], [%201, %$31], [%206, %$30] ; # P
  %214 = phi i64 [%186, %$29], [%202, %$31], [%207, %$30] ; # Q
  %215 = phi i64 [%179, %$29], [%194, %$31], [%209, %$30] ; # ->
  %216 = inttoptr i64 %173 to i64*
  %217 = getelementptr i64, i64* %216, i32 3
  store i64 %215, i64* %217
  br label %$24
$26:
  %218 = phi i64 [%160, %$24] ; # X
  %219 = phi i64 [%161, %$24] ; # R
  %220 = phi i64 [%162, %$24] ; # R2
  %221 = phi i64 [%167, %$24] ; # P
  %222 = phi i64 [%164, %$24] ; # Q
  br label %$19
$23:
  %223 = phi i64 [%139, %$21] ; # X
  %224 = phi i64 [%140, %$21] ; # R
  %225 = phi i64 [%141, %$21] ; # R2
  %226 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %227 = phi i64 [%112, %$16], [%223, %$23] ; # X
  %228 = phi i64 [%113, %$16], [%224, %$23] ; # R
  %229 = phi i64 [%114, %$16], [%225, %$23] ; # R2
; # (set $At2 R2)
  %230 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %229, i64* %230
; # (drop *Safe)
  %231 = inttoptr i64 %5 to i64*
  %232 = getelementptr i64, i64* %231, i32 1
  %233 = load i64, i64* %232
  %234 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %233, i64* %234
  ret i64 %228
}

define i64 @_mini(i64) {
$1:
; # (let (X (cdr Exe) R $Nil R2 (save $T) E (push NIL $Nil ZERO (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $T)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %34 = add i64 %25, 24
; # (link (ofs E 3))
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %34 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %34, i64* %39
  %40 = inttoptr i64 %25 to i64*
  store i64 %34, i64* %40
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$7
$7:
  %41 = phi i64 [%15, %$2], [%103, %$15] ; # X
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%104, %$15] ; # R
  %43 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$2], [%105, %$15] ; # R2
  %44 = phi i64 [%25, %$2], [%106, %$15] ; # P
  %45 = phi i64 [%33, %$2], [%109, %$15] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
; # (eval (car X))
  %48 = and i64 %47, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$10, label %$9
$10:
  br label %$8
$9:
  %50 = and i64 %47, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$12, label %$11
$12:
  %52 = inttoptr i64 %47 to i64*
  %53 = load i64, i64* %52
  br label %$8
$11:
  %54 = call i64 @evList(i64 %47)
  br label %$8
$8:
  %55 = phi i64 [%47, %$10], [%53, %$12], [%54, %$11] ; # ->
; # (save (eval (car X)))
  %56 = alloca i64, i64 2, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %55, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %57 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %57, i64* %63
  %64 = inttoptr i64 %45 to i64*
  store i64 %55, i64* %64
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %65 = and i64 %55, 15
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$13, label %$14
$13:
  %67 = phi i64 [%41, %$8] ; # X
  %68 = phi i64 [%42, %$8] ; # R
  %69 = phi i64 [%43, %$8] ; # R2
  %70 = phi i64 [%44, %$8] ; # P
  %71 = phi i64 [%45, %$8] ; # Q
  %72 = phi i64 [%55, %$8] ; # V
; # (car V)
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
  br label %$14
$14:
  %75 = phi i64 [%41, %$8], [%67, %$13] ; # X
  %76 = phi i64 [%42, %$8], [%68, %$13] ; # R
  %77 = phi i64 [%43, %$8], [%69, %$13] ; # R2
  %78 = phi i64 [%44, %$8], [%70, %$13] ; # P
  %79 = phi i64 [%45, %$8], [%71, %$13] ; # Q
  %80 = phi i64 [%55, %$8], [%74, %$13] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %81 = alloca i64, i64 5, align 16
  %82 = ptrtoint i64* %81 to i64
  %83 = add i64 %82, 8
  %84 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %84
  %85 = add i64 %82, 16
  %86 = inttoptr i64 %85 to i64*
  store i64 2, i64* %86
  %87 = add i64 %82, 24
  %88 = inttoptr i64 %87 to i64*
  store i64 %80, i64* %88
  %89 = inttoptr i64 %78 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %82, i64* %90
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %91 = add i64 %82, 24
; # (link (ofs P 3))
  %92 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %93 = load i64, i64* %92
  %94 = inttoptr i64 %91 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %96
  %97 = inttoptr i64 %82 to i64*
  store i64 %91, i64* %97
; # (? (atom (shift X)))
; # (shift X)
  %98 = inttoptr i64 %75 to i64*
  %99 = getelementptr i64, i64* %98, i32 1
  %100 = load i64, i64* %99
; # (atom (shift X))
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$16, label %$15
$15:
  %103 = phi i64 [%100, %$14] ; # X
  %104 = phi i64 [%76, %$14] ; # R
  %105 = phi i64 [%77, %$14] ; # R2
  %106 = phi i64 [%82, %$14] ; # P
  %107 = phi i64 [%79, %$14] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %108 = alloca i64, i64 2, align 16
  %109 = ptrtoint i64* %108 to i64
  %110 = inttoptr i64 %107 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$7
$16:
  %112 = phi i64 [%100, %$14] ; # X
  %113 = phi i64 [%76, %$14] ; # R
  %114 = phi i64 [%77, %$14] ; # R2
  %115 = phi i64 [%82, %$14] ; # P
  %116 = phi i64 [%79, %$14] ; # Q
  %117 = phi i64 [0, %$14] ; # ->
; # (when (pair (car A)) (loop (let Y (evList E) (when (lt0 (compare ...
; # (car A)
  %118 = inttoptr i64 %33 to i64*
  %119 = load i64, i64* %118
; # (pair (car A))
  %120 = and i64 %119, 15
  %121 = icmp eq i64 %120, 0
  br i1 %121, label %$17, label %$18
$17:
  %122 = phi i64 [%112, %$16] ; # X
  %123 = phi i64 [%113, %$16] ; # R
  %124 = phi i64 [%114, %$16] ; # R2
; # (loop (let Y (evList E) (when (lt0 (compare Y R2)) (setq R (caar ...
  br label %$19
$19:
  %125 = phi i64 [%122, %$17], [%218, %$26] ; # X
  %126 = phi i64 [%123, %$17], [%219, %$26] ; # R
  %127 = phi i64 [%124, %$17], [%220, %$26] ; # R2
; # (let Y (evList E) (when (lt0 (compare Y R2)) (setq R (caar A)) (s...
; # (evList E)
  %128 = call i64 @evList(i64 %25)
; # (when (lt0 (compare Y R2)) (setq R (caar A)) (setq R2 (safe Y)))
; # (compare Y R2)
  %129 = call i64 @compare(i64 %128, i64 %127)
; # (lt0 (compare Y R2))
  %130 = icmp slt i64 %129, 0
  br i1 %130, label %$20, label %$21
$20:
  %131 = phi i64 [%125, %$19] ; # X
  %132 = phi i64 [%126, %$19] ; # R
  %133 = phi i64 [%127, %$19] ; # R2
; # (caar A)
  %134 = inttoptr i64 %33 to i64*
  %135 = load i64, i64* %134
  %136 = inttoptr i64 %135 to i64*
  %137 = load i64, i64* %136
; # (safe Y)
  %138 = inttoptr i64 %5 to i64*
  store i64 %128, i64* %138
  br label %$21
$21:
  %139 = phi i64 [%125, %$19], [%131, %$20] ; # X
  %140 = phi i64 [%126, %$19], [%137, %$20] ; # R
  %141 = phi i64 [%127, %$19], [%128, %$20] ; # R2
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %142 = inttoptr i64 %33 to i64*
  %143 = load i64, i64* %142
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %33 to i64*
  store i64 %146, i64* %147
; # (atom (set A (cdar A)))
  %148 = and i64 %146, 15
  %149 = icmp ne i64 %148, 0
  br i1 %149, label %$23, label %$22
$22:
  %150 = phi i64 [%139, %$21] ; # X
  %151 = phi i64 [%140, %$21] ; # R
  %152 = phi i64 [%141, %$21] ; # R2
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %153 = inttoptr i64 %25 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  %155 = load i64, i64* %154
; # (set 4 P (car @))
; # (car @)
  %156 = inttoptr i64 %146 to i64*
  %157 = load i64, i64* %156
  %158 = inttoptr i64 %155 to i64*
  %159 = getelementptr i64, i64* %158, i32 3
  store i64 %157, i64* %159
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$24
$24:
  %160 = phi i64 [%150, %$22], [%210, %$27] ; # X
  %161 = phi i64 [%151, %$22], [%211, %$27] ; # R
  %162 = phi i64 [%152, %$22], [%212, %$27] ; # R2
  %163 = phi i64 [%155, %$22], [%213, %$27] ; # P
  %164 = phi i64 [%33, %$22], [%214, %$27] ; # Q
; # (shift P)
  %165 = inttoptr i64 %163 to i64*
  %166 = getelementptr i64, i64* %165, i32 1
  %167 = load i64, i64* %166
; # (pair (shift P))
  %168 = and i64 %167, 15
  %169 = icmp eq i64 %168, 0
  br i1 %169, label %$25, label %$26
$25:
  %170 = phi i64 [%160, %$24] ; # X
  %171 = phi i64 [%161, %$24] ; # R
  %172 = phi i64 [%162, %$24] ; # R2
  %173 = phi i64 [%167, %$24] ; # P
  %174 = phi i64 [%164, %$24] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %175 = inttoptr i64 %174 to i64*
  %176 = getelementptr i64, i64* %175, i32 1
  %177 = load i64, i64* %176
; # (car (shift Q))
  %178 = inttoptr i64 %177 to i64*
  %179 = load i64, i64* %178
; # (atom (car (shift Q)))
  %180 = and i64 %179, 15
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$29, label %$28
$29:
  %182 = phi i64 [%170, %$25] ; # X
  %183 = phi i64 [%171, %$25] ; # R
  %184 = phi i64 [%172, %$25] ; # R2
  %185 = phi i64 [%173, %$25] ; # P
  %186 = phi i64 [%177, %$25] ; # Q
  br label %$27
$28:
  %187 = phi i64 [%170, %$25] ; # X
  %188 = phi i64 [%171, %$25] ; # R
  %189 = phi i64 [%172, %$25] ; # R2
  %190 = phi i64 [%173, %$25] ; # P
  %191 = phi i64 [%177, %$25] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %192 = inttoptr i64 %179 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
  %195 = inttoptr i64 %191 to i64*
  store i64 %194, i64* %195
; # (atom (set Q (cdr @)))
  %196 = and i64 %194, 15
  %197 = icmp ne i64 %196, 0
  br i1 %197, label %$31, label %$30
$31:
  %198 = phi i64 [%187, %$28] ; # X
  %199 = phi i64 [%188, %$28] ; # R
  %200 = phi i64 [%189, %$28] ; # R2
  %201 = phi i64 [%190, %$28] ; # P
  %202 = phi i64 [%191, %$28] ; # Q
  br label %$27
$30:
  %203 = phi i64 [%187, %$28] ; # X
  %204 = phi i64 [%188, %$28] ; # R
  %205 = phi i64 [%189, %$28] ; # R2
  %206 = phi i64 [%190, %$28] ; # P
  %207 = phi i64 [%191, %$28] ; # Q
; # (car @)
  %208 = inttoptr i64 %194 to i64*
  %209 = load i64, i64* %208
  br label %$27
$27:
  %210 = phi i64 [%182, %$29], [%198, %$31], [%203, %$30] ; # X
  %211 = phi i64 [%183, %$29], [%199, %$31], [%204, %$30] ; # R
  %212 = phi i64 [%184, %$29], [%200, %$31], [%205, %$30] ; # R2
  %213 = phi i64 [%185, %$29], [%201, %$31], [%206, %$30] ; # P
  %214 = phi i64 [%186, %$29], [%202, %$31], [%207, %$30] ; # Q
  %215 = phi i64 [%179, %$29], [%194, %$31], [%209, %$30] ; # ->
  %216 = inttoptr i64 %173 to i64*
  %217 = getelementptr i64, i64* %216, i32 3
  store i64 %215, i64* %217
  br label %$24
$26:
  %218 = phi i64 [%160, %$24] ; # X
  %219 = phi i64 [%161, %$24] ; # R
  %220 = phi i64 [%162, %$24] ; # R2
  %221 = phi i64 [%167, %$24] ; # P
  %222 = phi i64 [%164, %$24] ; # Q
  br label %$19
$23:
  %223 = phi i64 [%139, %$21] ; # X
  %224 = phi i64 [%140, %$21] ; # R
  %225 = phi i64 [%141, %$21] ; # R2
  %226 = phi i64 [0, %$21] ; # ->
  br label %$18
$18:
  %227 = phi i64 [%112, %$16], [%223, %$23] ; # X
  %228 = phi i64 [%113, %$16], [%224, %$23] ; # R
  %229 = phi i64 [%114, %$16], [%225, %$23] ; # R2
; # (set $At2 R2)
  %230 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %229, i64* %230
; # (drop *Safe)
  %231 = inttoptr i64 %5 to i64*
  %232 = getelementptr i64, i64* %231, i32 1
  %233 = load i64, i64* %232
  %234 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %233, i64* %234
  ret i64 %228
}

define void @fish(i64, i64, i64, i64) {
$1:
; # (set P V)
  %4 = inttoptr i64 %2 to i64*
  store i64 %1, i64* %4
; # (nond ((nil? (evList E)) (set R (cons V (val R)))) ((atom V) (unl...
; # (evList E)
  %5 = call i64 @evList(i64 %0)
; # (nil? (evList E))
  %6 = icmp eq i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %6, label %$3, label %$4
$4:
; # (set R (cons V (val R)))
; # (val R)
  %7 = inttoptr i64 %3 to i64*
  %8 = load i64, i64* %7
; # (cons V (val R))
  %9 = call i64 @cons(i64 %1, i64 %8)
  %10 = inttoptr i64 %3 to i64*
  store i64 %9, i64* %10
  br label %$2
$3:
; # (atom V)
  %11 = and i64 %1, 15
  %12 = icmp ne i64 %11, 0
  br i1 %12, label %$5, label %$6
$6:
; # (unless (nil? (cdr V)) (fish E @ P R))
; # (cdr V)
  %13 = inttoptr i64 %1 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (nil? (cdr V))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$8, label %$7
$7:
; # (fish E @ P R)
  call void @fish(i64 %0, i64 %15, i64 %2, i64 %3)
  br label %$8
$8:
; # (car V)
  %17 = inttoptr i64 %1 to i64*
  %18 = load i64, i64* %17
; # (fish E (car V) P R)
  tail call void @fish(i64 %0, i64 %18, i64 %2, i64 %3)
  br label %$2
$5:
  br label %$2
$2:
  ret void
}

define i64 @_fish(i64) {
$1:
; # (let (X (cdr Exe) R (link (push $Nil NIL) T) P (push NIL $Nil ZER...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (push $Nil NIL)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
; # (link (push $Nil NIL) T)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (push NIL $Nil ZERO NIL)
  %12 = alloca i64, i64 4, align 16
  %13 = ptrtoint i64* %12 to i64
  %14 = add i64 %13, 8
  %15 = inttoptr i64 %14 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %15
  %16 = add i64 %13, 16
  %17 = inttoptr i64 %16 to i64*
  store i64 2, i64* %17
; # (++ X)
  %18 = inttoptr i64 %3 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
; # (eval (++ X))
  %22 = and i64 %19, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$4, label %$3
$4:
  br label %$2
$3:
  %24 = and i64 %19, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$6, label %$5
$6:
  %26 = inttoptr i64 %19 to i64*
  %27 = load i64, i64* %26
  br label %$2
$5:
  %28 = call i64 @evList(i64 %19)
  br label %$2
$2:
  %29 = phi i64 [%19, %$4], [%27, %$6], [%28, %$5] ; # ->
; # (push NIL P ZERO (eval (++ X)) NIL)
  %30 = alloca i64, i64 5, align 16
  %31 = ptrtoint i64* %30 to i64
  %32 = add i64 %31, 8
  %33 = inttoptr i64 %32 to i64*
  store i64 %13, i64* %33
  %34 = add i64 %31, 16
  %35 = inttoptr i64 %34 to i64*
  store i64 2, i64* %35
  %36 = add i64 %31, 24
  %37 = inttoptr i64 %36 to i64*
  store i64 %29, i64* %37
; # (set P (ofs P 3) E (link (ofs E 3)))
; # (ofs P 3)
  %38 = add i64 %13, 24
  %39 = inttoptr i64 %13 to i64*
  store i64 %38, i64* %39
; # (ofs E 3)
  %40 = add i64 %31, 24
; # (link (ofs E 3))
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %42 = load i64, i64* %41
  %43 = inttoptr i64 %40 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %42, i64* %44
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %45
  %46 = inttoptr i64 %31 to i64*
  store i64 %40, i64* %46
; # (let V (save (eval (car X))) (fish E V (ofs P 3) R) (val R))
; # (car X)
  %47 = inttoptr i64 %21 to i64*
  %48 = load i64, i64* %47
; # (eval (car X))
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$9, label %$8
$9:
  br label %$7
$8:
  %51 = and i64 %48, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$11, label %$10
$11:
  %53 = inttoptr i64 %48 to i64*
  %54 = load i64, i64* %53
  br label %$7
$10:
  %55 = call i64 @evList(i64 %48)
  br label %$7
$7:
  %56 = phi i64 [%48, %$9], [%54, %$11], [%55, %$10] ; # ->
; # (save (eval (car X)))
  %57 = alloca i64, i64 2, align 16
  %58 = ptrtoint i64* %57 to i64
  %59 = inttoptr i64 %58 to i64*
  store i64 %56, i64* %59
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %61 = load i64, i64* %60
  %62 = inttoptr i64 %58 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 %61, i64* %63
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %64
; # (ofs P 3)
  %65 = add i64 %13, 24
; # (fish E V (ofs P 3) R)
  call void @fish(i64 %31, i64 %56, i64 %65, i64 %5)
; # (val R)
  %66 = inttoptr i64 %5 to i64*
  %67 = load i64, i64* %66
; # (drop *Safe)
  %68 = inttoptr i64 %5 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %71
  ret i64 %67
}

define i64 @_by(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil) L 0 E (push NIL $Nil ZERO (eval (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (++ X)
  %12 = inttoptr i64 %3 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$4, label %$3
$4:
  br label %$2
$3:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$6, label %$5
$6:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$2
$5:
  %22 = call i64 @evList(i64 %13)
  br label %$2
$2:
  %23 = phi i64 [%13, %$4], [%21, %$6], [%22, %$5] ; # ->
; # (push NIL $Nil ZERO (eval (++ X)) NIL)
  %24 = alloca i64, i64 5, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = add i64 %25, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
  %28 = add i64 %25, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %25, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %23, i64* %31
; # (push NIL NIL)
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
; # (++ X)
  %34 = inttoptr i64 %15 to i64*
  %35 = load i64, i64* %34
  %36 = getelementptr i64, i64* %34, i32 1
  %37 = load i64, i64* %36
; # (eval (++ X))
  %38 = and i64 %35, 6
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$9, label %$8
$9:
  br label %$7
$8:
  %40 = and i64 %35, 8
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$11, label %$10
$11:
  %42 = inttoptr i64 %35 to i64*
  %43 = load i64, i64* %42
  br label %$7
$10:
  %44 = call i64 @evList(i64 %35)
  br label %$7
$7:
  %45 = phi i64 [%35, %$9], [%43, %$11], [%44, %$10] ; # ->
; # (save (eval (++ X)))
  %46 = alloca i64, i64 2, align 16
  %47 = ptrtoint i64* %46 to i64
  %48 = inttoptr i64 %47 to i64*
  store i64 %45, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %50 = load i64, i64* %49
  %51 = inttoptr i64 %47 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  store i64 %50, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %53
; # (set E (link (ofs E 3)))
; # (ofs E 3)
  %54 = add i64 %25, 24
; # (link (ofs E 3))
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %56 = load i64, i64* %55
  %57 = inttoptr i64 %54 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %59
  %60 = inttoptr i64 %25 to i64*
  store i64 %54, i64* %60
; # (let (P E Q A) (loop (let V (set Q (save (eval (car X)))) (when (...
; # (loop (let V (set Q (save (eval (car X)))) (when (pair V) (setq V...
  br label %$12
$12:
  %61 = phi i64 [%37, %$7], [%123, %$20] ; # X
  %62 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%124, %$20] ; # R
  %63 = phi i64 [0, %$7], [%125, %$20] ; # L
  %64 = phi i64 [%25, %$7], [%126, %$20] ; # P
  %65 = phi i64 [%33, %$7], [%129, %$20] ; # Q
; # (let V (set Q (save (eval (car X)))) (when (pair V) (setq V (car ...
; # (set Q (save (eval (car X))))
; # (car X)
  %66 = inttoptr i64 %61 to i64*
  %67 = load i64, i64* %66
; # (eval (car X))
  %68 = and i64 %67, 6
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$15, label %$14
$15:
  br label %$13
$14:
  %70 = and i64 %67, 8
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$17, label %$16
$17:
  %72 = inttoptr i64 %67 to i64*
  %73 = load i64, i64* %72
  br label %$13
$16:
  %74 = call i64 @evList(i64 %67)
  br label %$13
$13:
  %75 = phi i64 [%67, %$15], [%73, %$17], [%74, %$16] ; # ->
; # (save (eval (car X)))
  %76 = alloca i64, i64 2, align 16
  %77 = ptrtoint i64* %76 to i64
  %78 = inttoptr i64 %77 to i64*
  store i64 %75, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %80 = load i64, i64* %79
  %81 = inttoptr i64 %77 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  store i64 %80, i64* %82
  %83 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %83
  %84 = inttoptr i64 %65 to i64*
  store i64 %75, i64* %84
; # (when (pair V) (setq V (car V)))
; # (pair V)
  %85 = and i64 %75, 15
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$18, label %$19
$18:
  %87 = phi i64 [%61, %$13] ; # X
  %88 = phi i64 [%62, %$13] ; # R
  %89 = phi i64 [%63, %$13] ; # L
  %90 = phi i64 [%64, %$13] ; # P
  %91 = phi i64 [%65, %$13] ; # Q
  %92 = phi i64 [%75, %$13] ; # V
; # (car V)
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
  br label %$19
$19:
  %95 = phi i64 [%61, %$13], [%87, %$18] ; # X
  %96 = phi i64 [%62, %$13], [%88, %$18] ; # R
  %97 = phi i64 [%63, %$13], [%89, %$18] ; # L
  %98 = phi i64 [%64, %$13], [%90, %$18] ; # P
  %99 = phi i64 [%65, %$13], [%91, %$18] ; # Q
  %100 = phi i64 [%75, %$13], [%94, %$18] ; # V
; # (set 2 P (push NIL $Nil ZERO V NIL))
; # (push NIL $Nil ZERO V NIL)
  %101 = alloca i64, i64 5, align 16
  %102 = ptrtoint i64* %101 to i64
  %103 = add i64 %102, 8
  %104 = inttoptr i64 %103 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %104
  %105 = add i64 %102, 16
  %106 = inttoptr i64 %105 to i64*
  store i64 2, i64* %106
  %107 = add i64 %102, 24
  %108 = inttoptr i64 %107 to i64*
  store i64 %100, i64* %108
  %109 = inttoptr i64 %98 to i64*
  %110 = getelementptr i64, i64* %109, i32 1
  store i64 %102, i64* %110
; # (set P (link (ofs P 3)))
; # (ofs P 3)
  %111 = add i64 %102, 24
; # (link (ofs P 3))
  %112 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %113 = load i64, i64* %112
  %114 = inttoptr i64 %111 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  store i64 %113, i64* %115
  %116 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %111, i64* %116
  %117 = inttoptr i64 %102 to i64*
  store i64 %111, i64* %117
; # (? (atom (shift X)))
; # (shift X)
  %118 = inttoptr i64 %95 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
; # (atom (shift X))
  %121 = and i64 %120, 15
  %122 = icmp ne i64 %121, 0
  br i1 %122, label %$21, label %$20
$20:
  %123 = phi i64 [%120, %$19] ; # X
  %124 = phi i64 [%96, %$19] ; # R
  %125 = phi i64 [%97, %$19] ; # L
  %126 = phi i64 [%102, %$19] ; # P
  %127 = phi i64 [%99, %$19] ; # Q
; # (set 2 Q (push NIL NIL))
; # (push NIL NIL)
  %128 = alloca i64, i64 2, align 16
  %129 = ptrtoint i64* %128 to i64
  %130 = inttoptr i64 %127 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  store i64 %129, i64* %131
  br label %$12
$21:
  %132 = phi i64 [%120, %$19] ; # X
  %133 = phi i64 [%96, %$19] ; # R
  %134 = phi i64 [%97, %$19] ; # L
  %135 = phi i64 [%102, %$19] ; # P
  %136 = phi i64 [%99, %$19] ; # Q
  %137 = phi i64 [0, %$19] ; # ->
; # (when (pair (car A)) (loop (let Y (cons (cons (evList E) (caar A)...
; # (car A)
  %138 = inttoptr i64 %33 to i64*
  %139 = load i64, i64* %138
; # (pair (car A))
  %140 = and i64 %139, 15
  %141 = icmp eq i64 %140, 0
  br i1 %141, label %$22, label %$23
$22:
  %142 = phi i64 [%132, %$21] ; # X
  %143 = phi i64 [%133, %$21] ; # R
  %144 = phi i64 [%134, %$21] ; # L
; # (loop (let Y (cons (cons (evList E) (caar A)) $Nil) (setq L (if L...
  br label %$24
$24:
  %145 = phi i64 [%142, %$22], [%245, %$32] ; # X
  %146 = phi i64 [%143, %$22], [%246, %$32] ; # R
  %147 = phi i64 [%144, %$22], [%247, %$32] ; # L
; # (let Y (cons (cons (evList E) (caar A)) $Nil) (setq L (if L (set ...
; # (evList E)
  %148 = call i64 @evList(i64 %25)
; # (caar A)
  %149 = inttoptr i64 %33 to i64*
  %150 = load i64, i64* %149
  %151 = inttoptr i64 %150 to i64*
  %152 = load i64, i64* %151
; # (cons (evList E) (caar A))
  %153 = call i64 @cons(i64 %148, i64 %152)
; # (cons (cons (evList E) (caar A)) $Nil)
  %154 = call i64 @cons(i64 %153, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if L (set 2 L Y) (setq R (safe Y)))
  %155 = icmp ne i64 %147, 0
  br i1 %155, label %$25, label %$26
$25:
  %156 = phi i64 [%145, %$24] ; # X
  %157 = phi i64 [%146, %$24] ; # R
  %158 = phi i64 [%147, %$24] ; # L
; # (set 2 L Y)
  %159 = inttoptr i64 %158 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  store i64 %154, i64* %160
  br label %$27
$26:
  %161 = phi i64 [%145, %$24] ; # X
  %162 = phi i64 [%146, %$24] ; # R
  %163 = phi i64 [%147, %$24] ; # L
; # (safe Y)
  %164 = inttoptr i64 %5 to i64*
  store i64 %154, i64* %164
  br label %$27
$27:
  %165 = phi i64 [%156, %$25], [%161, %$26] ; # X
  %166 = phi i64 [%157, %$25], [%154, %$26] ; # R
  %167 = phi i64 [%158, %$25], [%163, %$26] ; # L
  %168 = phi i64 [%154, %$25], [%154, %$26] ; # ->
; # (? (atom (set A (cdar A))))
; # (set A (cdar A))
; # (cdar A)
  %169 = inttoptr i64 %33 to i64*
  %170 = load i64, i64* %169
  %171 = inttoptr i64 %170 to i64*
  %172 = getelementptr i64, i64* %171, i32 1
  %173 = load i64, i64* %172
  %174 = inttoptr i64 %33 to i64*
  store i64 %173, i64* %174
; # (atom (set A (cdar A)))
  %175 = and i64 %173, 15
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$29, label %$28
$28:
  %177 = phi i64 [%165, %$27] ; # X
  %178 = phi i64 [%166, %$27] ; # R
  %179 = phi i64 [%168, %$27] ; # L
; # (let (P (cdr E) Q A) (set 4 P (car @)) (while (pair (shift P)) (s...
; # (cdr E)
  %180 = inttoptr i64 %25 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  %182 = load i64, i64* %181
; # (set 4 P (car @))
; # (car @)
  %183 = inttoptr i64 %173 to i64*
  %184 = load i64, i64* %183
  %185 = inttoptr i64 %182 to i64*
  %186 = getelementptr i64, i64* %185, i32 3
  store i64 %184, i64* %186
; # (while (pair (shift P)) (set 4 P (cond ((atom (car (shift Q))) @)...
  br label %$30
$30:
  %187 = phi i64 [%177, %$28], [%237, %$33] ; # X
  %188 = phi i64 [%178, %$28], [%238, %$33] ; # R
  %189 = phi i64 [%179, %$28], [%239, %$33] ; # L
  %190 = phi i64 [%182, %$28], [%240, %$33] ; # P
  %191 = phi i64 [%33, %$28], [%241, %$33] ; # Q
; # (shift P)
  %192 = inttoptr i64 %190 to i64*
  %193 = getelementptr i64, i64* %192, i32 1
  %194 = load i64, i64* %193
; # (pair (shift P))
  %195 = and i64 %194, 15
  %196 = icmp eq i64 %195, 0
  br i1 %196, label %$31, label %$32
$31:
  %197 = phi i64 [%187, %$30] ; # X
  %198 = phi i64 [%188, %$30] ; # R
  %199 = phi i64 [%189, %$30] ; # L
  %200 = phi i64 [%194, %$30] ; # P
  %201 = phi i64 [%191, %$30] ; # Q
; # (set 4 P (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @)))...
; # (cond ((atom (car (shift Q))) @) ((atom (set Q (cdr @))) @) (T (c...
; # (shift Q)
  %202 = inttoptr i64 %201 to i64*
  %203 = getelementptr i64, i64* %202, i32 1
  %204 = load i64, i64* %203
; # (car (shift Q))
  %205 = inttoptr i64 %204 to i64*
  %206 = load i64, i64* %205
; # (atom (car (shift Q)))
  %207 = and i64 %206, 15
  %208 = icmp ne i64 %207, 0
  br i1 %208, label %$35, label %$34
$35:
  %209 = phi i64 [%197, %$31] ; # X
  %210 = phi i64 [%198, %$31] ; # R
  %211 = phi i64 [%199, %$31] ; # L
  %212 = phi i64 [%200, %$31] ; # P
  %213 = phi i64 [%204, %$31] ; # Q
  br label %$33
$34:
  %214 = phi i64 [%197, %$31] ; # X
  %215 = phi i64 [%198, %$31] ; # R
  %216 = phi i64 [%199, %$31] ; # L
  %217 = phi i64 [%200, %$31] ; # P
  %218 = phi i64 [%204, %$31] ; # Q
; # (set Q (cdr @))
; # (cdr @)
  %219 = inttoptr i64 %206 to i64*
  %220 = getelementptr i64, i64* %219, i32 1
  %221 = load i64, i64* %220
  %222 = inttoptr i64 %218 to i64*
  store i64 %221, i64* %222
; # (atom (set Q (cdr @)))
  %223 = and i64 %221, 15
  %224 = icmp ne i64 %223, 0
  br i1 %224, label %$37, label %$36
$37:
  %225 = phi i64 [%214, %$34] ; # X
  %226 = phi i64 [%215, %$34] ; # R
  %227 = phi i64 [%216, %$34] ; # L
  %228 = phi i64 [%217, %$34] ; # P
  %229 = phi i64 [%218, %$34] ; # Q
  br label %$33
$36:
  %230 = phi i64 [%214, %$34] ; # X
  %231 = phi i64 [%215, %$34] ; # R
  %232 = phi i64 [%216, %$34] ; # L
  %233 = phi i64 [%217, %$34] ; # P
  %234 = phi i64 [%218, %$34] ; # Q
; # (car @)
  %235 = inttoptr i64 %221 to i64*
  %236 = load i64, i64* %235
  br label %$33
$33:
  %237 = phi i64 [%209, %$35], [%225, %$37], [%230, %$36] ; # X
  %238 = phi i64 [%210, %$35], [%226, %$37], [%231, %$36] ; # R
  %239 = phi i64 [%211, %$35], [%227, %$37], [%232, %$36] ; # L
  %240 = phi i64 [%212, %$35], [%228, %$37], [%233, %$36] ; # P
  %241 = phi i64 [%213, %$35], [%229, %$37], [%234, %$36] ; # Q
  %242 = phi i64 [%206, %$35], [%221, %$37], [%236, %$36] ; # ->
  %243 = inttoptr i64 %200 to i64*
  %244 = getelementptr i64, i64* %243, i32 3
  store i64 %242, i64* %244
  br label %$30
$32:
  %245 = phi i64 [%187, %$30] ; # X
  %246 = phi i64 [%188, %$30] ; # R
  %247 = phi i64 [%189, %$30] ; # L
  %248 = phi i64 [%194, %$30] ; # P
  %249 = phi i64 [%191, %$30] ; # Q
  br label %$24
$29:
  %250 = phi i64 [%165, %$27] ; # X
  %251 = phi i64 [%166, %$27] ; # R
  %252 = phi i64 [%168, %$27] ; # L
  %253 = phi i64 [0, %$27] ; # ->
; # (set 4 E Fun2 4 (cdr E) R)
  %254 = inttoptr i64 %25 to i64*
  %255 = getelementptr i64, i64* %254, i32 3
  store i64 %45, i64* %255
; # (cdr E)
  %256 = inttoptr i64 %25 to i64*
  %257 = getelementptr i64, i64* %256, i32 1
  %258 = load i64, i64* %257
  %259 = inttoptr i64 %258 to i64*
  %260 = getelementptr i64, i64* %259, i32 3
  store i64 %251, i64* %260
; # (let Z (setq R (safe (evList E))) (loop (set Z (cdar Z)) (? (atom...
; # (evList E)
  %261 = call i64 @evList(i64 %25)
; # (safe (evList E))
  %262 = inttoptr i64 %5 to i64*
  store i64 %261, i64* %262
; # (loop (set Z (cdar Z)) (? (atom (shift Z))))
  br label %$38
$38:
  %263 = phi i64 [%250, %$29], [%278, %$39] ; # X
  %264 = phi i64 [%261, %$29], [%279, %$39] ; # R
  %265 = phi i64 [%252, %$29], [%280, %$39] ; # L
  %266 = phi i64 [%261, %$29], [%281, %$39] ; # Z
; # (set Z (cdar Z))
; # (cdar Z)
  %267 = inttoptr i64 %266 to i64*
  %268 = load i64, i64* %267
  %269 = inttoptr i64 %268 to i64*
  %270 = getelementptr i64, i64* %269, i32 1
  %271 = load i64, i64* %270
  %272 = inttoptr i64 %266 to i64*
  store i64 %271, i64* %272
; # (? (atom (shift Z)))
; # (shift Z)
  %273 = inttoptr i64 %266 to i64*
  %274 = getelementptr i64, i64* %273, i32 1
  %275 = load i64, i64* %274
; # (atom (shift Z))
  %276 = and i64 %275, 15
  %277 = icmp ne i64 %276, 0
  br i1 %277, label %$40, label %$39
$39:
  %278 = phi i64 [%263, %$38] ; # X
  %279 = phi i64 [%264, %$38] ; # R
  %280 = phi i64 [%265, %$38] ; # L
  %281 = phi i64 [%275, %$38] ; # Z
  br label %$38
$40:
  %282 = phi i64 [%263, %$38] ; # X
  %283 = phi i64 [%264, %$38] ; # R
  %284 = phi i64 [%265, %$38] ; # L
  %285 = phi i64 [%275, %$38] ; # Z
  %286 = phi i64 [0, %$38] ; # ->
  br label %$23
$23:
  %287 = phi i64 [%132, %$21], [%282, %$40] ; # X
  %288 = phi i64 [%133, %$21], [%283, %$40] ; # R
  %289 = phi i64 [%134, %$21], [%284, %$40] ; # L
; # (drop *Safe)
  %290 = inttoptr i64 %5 to i64*
  %291 = getelementptr i64, i64* %290, i32 1
  %292 = load i64, i64* %291
  %293 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %292, i64* %293
  ret i64 %288
}

define i8* @tabComplete(i8*) {
$1:
; # (if (nil? (val $Tab)) null (let (V (push NIL $Nil ZERO NIL NIL) E...
; # (val $Tab)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 472) to i64) to i64*
  %2 = load i64, i64* %1
; # (nil? (val $Tab))
  %3 = icmp eq i64 %2, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let (V (push NIL $Nil ZERO NIL NIL) E (push NIL V ZERO @ NIL)) (...
; # (push NIL $Nil ZERO NIL NIL)
  %4 = alloca i64, i64 5, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = add i64 %5, 8
  %7 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %7
  %8 = add i64 %5, 16
  %9 = inttoptr i64 %8 to i64*
  store i64 2, i64* %9
; # (push NIL V ZERO @ NIL)
  %10 = alloca i64, i64 5, align 16
  %11 = ptrtoint i64* %10 to i64
  %12 = add i64 %11, 8
  %13 = inttoptr i64 %12 to i64*
  store i64 %5, i64* %13
  %14 = add i64 %11, 16
  %15 = inttoptr i64 %14 to i64*
  store i64 2, i64* %15
  %16 = add i64 %11, 24
  %17 = inttoptr i64 %16 to i64*
  store i64 %2, i64* %17
; # (set 4 V (nond (Text $Nil) ((val Text) $T) (NIL (mkStr Text))))
; # (nond (Text $Nil) ((val Text) $T) (NIL (mkStr Text)))
  %18 = icmp ne i8* %0, null
  br i1 %18, label %$6, label %$7
$7:
  br label %$5
$6:
; # (val Text)
  %19 = load i8, i8* %0
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %$8, label %$9
$9:
  br label %$5
$8:
; # (mkStr Text)
  %21 = call i64 @mkStr(i8* %0)
  br label %$5
$5:
  %22 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$9], [%21, %$8] ; # ->
  %23 = inttoptr i64 %5 to i64*
  %24 = getelementptr i64, i64* %23, i32 3
  store i64 %22, i64* %24
; # (set V (link (ofs V 3) T) E (link (ofs E 3)))
; # (ofs V 3)
  %25 = add i64 %5, 24
; # (link (ofs V 3) T)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %25 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  store i64 %27, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %30
  %31 = inttoptr i64 %5 to i64*
  store i64 %25, i64* %31
; # (ofs E 3)
  %32 = add i64 %11, 24
; # (link (ofs E 3))
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %32 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  store i64 %34, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %37
  %38 = inttoptr i64 %11 to i64*
  store i64 %32, i64* %38
; # (if (nil? (evList E)) null (let Nm (name (val (tail (xSym @)))) (...
; # (evList E)
  %39 = call i64 @evList(i64 %11)
; # (nil? (evList E))
  %40 = icmp eq i64 %39, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %40, label %$10, label %$11
$10:
  br label %$12
$11:
; # (let Nm (name (val (tail (xSym @)))) (strdup (bufString Nm (b8 (b...
; # (xSym @)
  %41 = call i64 @xSym(i64 %39)
; # (tail (xSym @))
  %42 = add i64 %41, -8
; # (val (tail (xSym @)))
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (name (val (tail (xSym @))))
  br label %$13
$13:
  %45 = phi i64 [%44, %$11], [%51, %$14] ; # Tail
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$15, label %$14
$14:
  %48 = phi i64 [%45, %$13] ; # Tail
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  br label %$13
$15:
  %52 = phi i64 [%45, %$13] ; # Tail
; # (bufSize Nm)
  %53 = call i64 @bufSize(i64 %52)
; # (b8 (bufSize Nm))
  %54 = alloca i8, i64 %53
; # (bufString Nm (b8 (bufSize Nm)))
  %55 = call i8* @bufString(i64 %52, i8* %54)
; # (strdup (bufString Nm (b8 (bufSize Nm))))
  %56 = call i8* @strdup(i8* %55)
  br label %$12
$12:
  %57 = phi i8* [null, %$10], [%56, %$15] ; # ->
; # (drop *Safe)
  %58 = inttoptr i64 %25 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %61
  br label %$4
$4:
  %62 = phi i8* [null, %$2], [%57, %$12] ; # ->
  ret i8* %62
}

define void @redefMsg(i64, i64) {
$1:
; # (let (Out (val $OutFile) Put (val (i8** $Put))) (set $OutFile (va...
; # (val $OutFile)
  %2 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (i8** $Put)
  %3 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i8**
; # (val (i8** $Put))
  %4 = load i8*, i8** %3
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %5 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %6 = getelementptr i8*, i8** %5, i32 2
  %7 = load i8*, i8** %6
  store i8* %7, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
; # (outString ($ "# "))
  call void @outString(i8* bitcast ([3 x i8]* @$60 to i8*))
; # (print Sym)
  call void @print(i64 %0)
; # (when Sym2 (space) (print @))
  %8 = icmp ne i64 %1, 0
  br i1 %8, label %$2, label %$3
$2:
; # (space)
  call void @space()
; # (print @)
  call void @print(i64 %1)
  br label %$3
$3:
; # (outString ($ " redefined^J"))
  call void @outString(i8* bitcast ([12 x i8]* @$61 to i8*))
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %9 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i8**
  store i8* %4, i8** %9
  store i8* %2, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
  ret void
}

define void @putSrc(i64, i64) {
$1:
; # (unless (or (nil? (val $Dbg)) (sym? (val (tail Sym)))) (let In: (...
; # (or (nil? (val $Dbg)) (sym? (val (tail Sym))))
; # (val $Dbg)
  %2 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  %3 = load i64, i64* %2
; # (nil? (val $Dbg))
  %4 = icmp eq i64 %3, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %4, label %$2, label %$3
$3:
; # (tail Sym)
  %5 = add i64 %0, -8
; # (val (tail Sym))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (sym? (val (tail Sym)))
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
  br label %$2
$2:
  %10 = phi i1 [1, %$1], [%9, %$3] ; # ->
  br i1 %10, label %$5, label %$4
$4:
; # (let In: (inFile (val $InFile)) (when (and (In:) (In: name)) (let...
; # (val $InFile)
  %11 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (when (and (In:) (In: name)) (let (Dbg (get Sym $Dbg) Src (cons (...
; # (and (In:) (In: name))
; # (In:)
  %12 = icmp ne i8* %11, null
  br i1 %12, label %$7, label %$6
$7:
; # (In: name)
  %13 = getelementptr i8, i8* %11, i32 24
  %14 = bitcast i8* %13 to i8**
  %15 = load i8*, i8** %14
  %16 = icmp ne i8* %15, null
  br label %$6
$6:
  %17 = phi i1 [0, %$4], [%16, %$7] ; # ->
  br i1 %17, label %$8, label %$9
$8:
; # (let (Dbg (get Sym $Dbg) Src (cons (cnt (i64 (In: src))) (mkStr (...
; # (get Sym $Dbg)
  %18 = call i64 @get(i64 %0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64))
; # (In: src)
  %19 = getelementptr i8, i8* %11, i32 36
  %20 = bitcast i8* %19 to i32*
  %21 = load i32, i32* %20
; # (i64 (In: src))
  %22 = sext i32 %21 to i64
; # (cnt (i64 (In: src)))
  %23 = shl i64 %22, 4
  %24 = or i64 %23, 2
; # (In: name)
  %25 = getelementptr i8, i8* %11, i32 24
  %26 = bitcast i8* %25 to i8**
  %27 = load i8*, i8** %26
; # (mkStr (In: name))
  %28 = call i64 @mkStr(i8* %27)
; # (cons (cnt (i64 (In: src))) (mkStr (In: name)))
  %29 = call i64 @cons(i64 %24, i64 %28)
; # (cond ((=0 Key) (if (nil? Dbg) (put Sym $Dbg (cons Src $Nil)) (se...
; # (=0 Key)
  %30 = icmp eq i64 %1, 0
  br i1 %30, label %$12, label %$11
$12:
; # (if (nil? Dbg) (put Sym $Dbg (cons Src $Nil)) (set Dbg Src))
; # (nil? Dbg)
  %31 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %31, label %$13, label %$14
$13:
; # (cons Src $Nil)
  %32 = call i64 @cons(i64 %29, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (put Sym $Dbg (cons Src $Nil))
  call void @put(i64 %0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64), i64 %32)
  br label %$15
$14:
; # (set Dbg Src)
  %33 = inttoptr i64 %18 to i64*
  store i64 %29, i64* %33
  br label %$15
$15:
  br label %$10
$11:
; # (nil? Dbg)
  %34 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %34, label %$17, label %$16
$17:
; # (cons Src $Nil)
  %35 = call i64 @cons(i64 %29, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons $Nil (cons Src $Nil))
  %36 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64 %35)
; # (put Sym $Dbg (cons $Nil (cons Src $Nil)))
  call void @put(i64 %0, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64), i64 %36)
  br label %$10
$16:
; # (let X Dbg (loop (? (atom (shift X)) (set 2 Dbg (cons (cons Key S...
; # (loop (? (atom (shift X)) (set 2 Dbg (cons (cons Key Src) (cdr Db...
  br label %$18
$18:
  %37 = phi i64 [%18, %$16], [%62, %$22] ; # X
; # (? (atom (shift X)) (set 2 Dbg (cons (cons Key Src) (cdr Dbg))))
; # (shift X)
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (atom (shift X))
  %41 = and i64 %40, 15
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$21, label %$19
$21:
  %43 = phi i64 [%40, %$18] ; # X
; # (set 2 Dbg (cons (cons Key Src) (cdr Dbg)))
; # (cons Key Src)
  %44 = call i64 @cons(i64 %1, i64 %29)
; # (cdr Dbg)
  %45 = inttoptr i64 %18 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (cons (cons Key Src) (cdr Dbg))
  %48 = call i64 @cons(i64 %44, i64 %47)
  %49 = inttoptr i64 %18 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  store i64 %48, i64* %50
  br label %$20
$19:
  %51 = phi i64 [%40, %$18] ; # X
; # (? (== (caar X) Key) (set 2 (car X) Src))
; # (caar X)
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (== (caar X) Key)
  %56 = icmp eq i64 %55, %1
  br i1 %56, label %$23, label %$22
$23:
  %57 = phi i64 [%51, %$19] ; # X
; # (set 2 (car X) Src)
; # (car X)
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 %59 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %29, i64* %61
  br label %$20
$22:
  %62 = phi i64 [%51, %$19] ; # X
  br label %$18
$20:
  %63 = phi i64 [%43, %$21], [%57, %$23] ; # X
  %64 = phi i64 [%48, %$21], [%29, %$23] ; # ->
  br label %$10
$10:
  br label %$9
$9:
  br label %$5
$5:
  ret void
}

define void @redefine(i64, i64, i64) {
$1:
; # (needChkVar Exe Sym)
  %3 = and i64 %1, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  call void @varErr(i64 %0, i64 %1)
  unreachable
$3:
  %5 = icmp uge i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$5, label %$4
$5:
  %6 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %1
  br label %$4
$4:
  %7 = phi i1 [0, %$3], [%6, %$5] ; # ->
  br i1 %7, label %$6, label %$7
$6:
  call void @protErr(i64 %0, i64 %1)
  unreachable
$7:
; # (let V (val Sym) (unless (or (nil? V) (== V Sym) (equal V Val)) (...
; # (val Sym)
  %8 = inttoptr i64 %1 to i64*
  %9 = load i64, i64* %8
; # (unless (or (nil? V) (== V Sym) (equal V Val)) (redefMsg Sym 0))
; # (or (nil? V) (== V Sym) (equal V Val))
; # (nil? V)
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$8, label %$9
$9:
; # (== V Sym)
  %11 = icmp eq i64 %9, %1
  br i1 %11, label %$8, label %$10
$10:
; # (equal V Val)
  %12 = call i1 @equal(i64 %9, i64 %2)
  br label %$8
$8:
  %13 = phi i1 [1, %$7], [1, %$9], [%12, %$10] ; # ->
  br i1 %13, label %$12, label %$11
$11:
; # (redefMsg Sym 0)
  call void @redefMsg(i64 %1, i64 0)
  br label %$12
$12:
; # (set Sym Val)
  %14 = inttoptr i64 %1 to i64*
  store i64 %2, i64* %14
; # (putSrc Sym 0)
  call void @putSrc(i64 %1, i64 0)
  ret void
}

define i64 @_quote(i64) {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  ret i64 %3
}

define i64 @_as(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (car X))) @ (cdr X)))
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (car X))) @ (cdr X))
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (car X)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (cdr X)
  %15 = inttoptr i64 %3 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
  br label %$9
$9:
  %18 = phi i64 [%13, %$7], [%17, %$8] ; # ->
  ret i64 %18
}

define i64 @_lit(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (or (num? X) (nil? X) (t? X) (and (p...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (or (num? X) (nil? X) (t? X) (and (pair X) (num? (car X)))) X...
; # (or (num? X) (nil? X) (t? X) (and (pair X) (num? (car X))))
; # (num? X)
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
; # (nil? X)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$9
$9:
; # (t? X)
  %17 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %17, label %$7, label %$10
$10:
; # (and (pair X) (num? (car X)))
; # (pair X)
  %18 = and i64 %13, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$12, label %$11
$12:
; # (car X)
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
; # (num? (car X))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br label %$11
$11:
  %24 = phi i1 [0, %$10], [%23, %$12] ; # ->
  br label %$7
$7:
  %25 = phi i1 [1, %$2], [1, %$8], [1, %$9], [%24, %$11] ; # ->
  br i1 %25, label %$13, label %$14
$13:
  br label %$15
$14:
; # (cons $Quote X)
  %26 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 168) to i64), i64 %13)
  br label %$15
$15:
  %27 = phi i64 [%13, %$13], [%26, %$14] ; # ->
  ret i64 %27
}

define i64 @_eval(i64) {
$1:
; # (let (X (cdr Exe) E (eval (car X))) (cond ((num? E) E) ((sym? E) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((num? E) E) ((sym? E) (val E)) ((atom (shift X)) (evList E...
; # (num? E)
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%3, %$2] ; # X
  br label %$7
$8:
  %17 = phi i64 [%3, %$2] ; # X
; # (sym? E)
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
  %20 = phi i64 [%17, %$8] ; # X
; # (val E)
  %21 = inttoptr i64 %13 to i64*
  %22 = load i64, i64* %21
  br label %$7
$10:
  %23 = phi i64 [%17, %$8] ; # X
; # (shift X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$13, label %$12
$13:
  %29 = phi i64 [%26, %$10] ; # X
; # (evList E)
  %30 = call i64 @evList(i64 %13)
  br label %$7
$12:
  %31 = phi i64 [%26, %$10] ; # X
; # (save E (let N (needCnt Exe (eval (car X))) (when (setq N (int N)...
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
  %34 = inttoptr i64 %33 to i64*
  store i64 %13, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %33 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %33, i64* %39
; # (let N (needCnt Exe (eval (car X))) (when (setq N (int N)) (let B...
; # (car X)
  %40 = inttoptr i64 %31 to i64*
  %41 = load i64, i64* %40
; # (eval (car X))
  %42 = and i64 %41, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$16, label %$15
$16:
  br label %$14
$15:
  %44 = and i64 %41, 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$18, label %$17
$18:
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
  br label %$14
$17:
  %48 = call i64 @evList(i64 %41)
  br label %$14
$14:
  %49 = phi i64 [%41, %$16], [%47, %$18], [%48, %$17] ; # ->
; # (needCnt Exe (eval (car X)))
  %50 = and i64 %49, 2
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$19:
  call void @cntErr(i64 %0, i64 %49)
  unreachable
$20:
; # (when (setq N (int N)) (let Bnd (val $Bind) (loop (? (=0 Bnd)) (?...
; # (int N)
  %52 = lshr i64 %49, 4
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$21, label %$22
$21:
  %54 = phi i64 [%31, %$20] ; # X
  %55 = phi i64 [%52, %$20] ; # N
; # (let Bnd (val $Bind) (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bn...
; # (val $Bind)
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %57 = load i64, i64* %56
; # (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bnd)) (prog (set $At (v...
  br label %$23
$23:
  %58 = phi i64 [%54, %$21], [%81, %$28] ; # X
  %59 = phi i64 [%55, %$21], [%82, %$28] ; # N
  %60 = phi i64 [%57, %$21], [%86, %$28] ; # Bnd
; # (? (=0 Bnd))
; # (=0 Bnd)
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %$25, label %$24
$24:
  %62 = phi i64 [%58, %$23] ; # X
  %63 = phi i64 [%59, %$23] ; # N
  %64 = phi i64 [%60, %$23] ; # Bnd
; # (? (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec '...
; # (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec 'N))...
; # (val 2 Bnd)
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (== $At (val 2 Bnd))
  %68 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %67
  br i1 %68, label %$27, label %$26
$27:
  %69 = phi i64 [%62, %$24] ; # X
  %70 = phi i64 [%63, %$24] ; # N
  %71 = phi i64 [%64, %$24] ; # Bnd
; # (set $At (val Bnd))
; # (val Bnd)
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %73, i64* %74
; # (dec 'N)
  %75 = sub i64 %70, 1
; # (=0 (dec 'N))
  %76 = icmp eq i64 %75, 0
  br label %$26
$26:
  %77 = phi i64 [%62, %$24], [%69, %$27] ; # X
  %78 = phi i64 [%63, %$24], [%75, %$27] ; # N
  %79 = phi i64 [%64, %$24], [%71, %$27] ; # Bnd
  %80 = phi i1 [0, %$24], [%76, %$27] ; # ->
  br i1 %80, label %$25, label %$28
$28:
  %81 = phi i64 [%77, %$26] ; # X
  %82 = phi i64 [%78, %$26] ; # N
  %83 = phi i64 [%79, %$26] ; # Bnd
; # (val 3 Bnd)
  %84 = inttoptr i64 %83 to i64*
  %85 = getelementptr i64, i64* %84, i32 2
  %86 = load i64, i64* %85
  br label %$23
$25:
  %87 = phi i64 [%58, %$23], [%77, %$26] ; # X
  %88 = phi i64 [%59, %$23], [%78, %$26] ; # N
  %89 = phi i64 [%60, %$23], [%79, %$26] ; # Bnd
  %90 = phi i64 [0, %$23], [0, %$26] ; # ->
  br label %$22
$22:
  %91 = phi i64 [%31, %$20], [%87, %$25] ; # X
  %92 = phi i64 [%52, %$20], [%88, %$25] ; # N
; # (evList E)
  %93 = call i64 @evList(i64 %13)
  %94 = inttoptr i64 %33 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %96, i64* %97
  br label %$7
$7:
  %98 = phi i64 [%16, %$9], [%20, %$11], [%29, %$13], [%91, %$22] ; # X
  %99 = phi i64 [%13, %$9], [%22, %$11], [%30, %$13], [%93, %$22] ; # ->
  ret i64 %99
}

define i64 @_run(i64) {
$1:
; # (let (X (cdr Exe) E (eval (car X))) (cond ((num? E) E) ((sym? E) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((num? E) E) ((sym? E) (val E)) ((atom (shift X)) (runAt E)...
; # (num? E)
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%3, %$2] ; # X
  br label %$7
$8:
  %17 = phi i64 [%3, %$2] ; # X
; # (sym? E)
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
  %20 = phi i64 [%17, %$8] ; # X
; # (val E)
  %21 = inttoptr i64 %13 to i64*
  %22 = load i64, i64* %21
  br label %$7
$10:
  %23 = phi i64 [%17, %$8] ; # X
; # (shift X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$13, label %$12
$13:
  %29 = phi i64 [%26, %$10] ; # X
; # (runAt E)
  %30 = call i64 @runAt(i64 %13)
  br label %$7
$12:
  %31 = phi i64 [%26, %$10] ; # X
; # (save E (let N (needCnt Exe (eval (car X))) (when (setq N (int N)...
  %32 = alloca i64, i64 2, align 16
  %33 = ptrtoint i64* %32 to i64
  %34 = inttoptr i64 %33 to i64*
  store i64 %13, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %33 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  store i64 %36, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %33, i64* %39
; # (let N (needCnt Exe (eval (car X))) (when (setq N (int N)) (let B...
; # (car X)
  %40 = inttoptr i64 %31 to i64*
  %41 = load i64, i64* %40
; # (eval (car X))
  %42 = and i64 %41, 6
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$16, label %$15
$16:
  br label %$14
$15:
  %44 = and i64 %41, 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$18, label %$17
$18:
  %46 = inttoptr i64 %41 to i64*
  %47 = load i64, i64* %46
  br label %$14
$17:
  %48 = call i64 @evList(i64 %41)
  br label %$14
$14:
  %49 = phi i64 [%41, %$16], [%47, %$18], [%48, %$17] ; # ->
; # (needCnt Exe (eval (car X)))
  %50 = and i64 %49, 2
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$20, label %$19
$19:
  call void @cntErr(i64 %0, i64 %49)
  unreachable
$20:
; # (when (setq N (int N)) (let Bnd (val $Bind) (loop (? (=0 Bnd)) (?...
; # (int N)
  %52 = lshr i64 %49, 4
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$21, label %$22
$21:
  %54 = phi i64 [%31, %$20] ; # X
  %55 = phi i64 [%52, %$20] ; # N
; # (let Bnd (val $Bind) (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bn...
; # (val $Bind)
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %57 = load i64, i64* %56
; # (loop (? (=0 Bnd)) (? (and (== $At (val 2 Bnd)) (prog (set $At (v...
  br label %$23
$23:
  %58 = phi i64 [%54, %$21], [%81, %$28] ; # X
  %59 = phi i64 [%55, %$21], [%82, %$28] ; # N
  %60 = phi i64 [%57, %$21], [%86, %$28] ; # Bnd
; # (? (=0 Bnd))
; # (=0 Bnd)
  %61 = icmp eq i64 %60, 0
  br i1 %61, label %$25, label %$24
$24:
  %62 = phi i64 [%58, %$23] ; # X
  %63 = phi i64 [%59, %$23] ; # N
  %64 = phi i64 [%60, %$23] ; # Bnd
; # (? (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec '...
; # (and (== $At (val 2 Bnd)) (prog (set $At (val Bnd)) (=0 (dec 'N))...
; # (val 2 Bnd)
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
; # (== $At (val 2 Bnd))
  %68 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %67
  br i1 %68, label %$27, label %$26
$27:
  %69 = phi i64 [%62, %$24] ; # X
  %70 = phi i64 [%63, %$24] ; # N
  %71 = phi i64 [%64, %$24] ; # Bnd
; # (set $At (val Bnd))
; # (val Bnd)
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %73, i64* %74
; # (dec 'N)
  %75 = sub i64 %70, 1
; # (=0 (dec 'N))
  %76 = icmp eq i64 %75, 0
  br label %$26
$26:
  %77 = phi i64 [%62, %$24], [%69, %$27] ; # X
  %78 = phi i64 [%63, %$24], [%75, %$27] ; # N
  %79 = phi i64 [%64, %$24], [%71, %$27] ; # Bnd
  %80 = phi i1 [0, %$24], [%76, %$27] ; # ->
  br i1 %80, label %$25, label %$28
$28:
  %81 = phi i64 [%77, %$26] ; # X
  %82 = phi i64 [%78, %$26] ; # N
  %83 = phi i64 [%79, %$26] ; # Bnd
; # (val 3 Bnd)
  %84 = inttoptr i64 %83 to i64*
  %85 = getelementptr i64, i64* %84, i32 2
  %86 = load i64, i64* %85
  br label %$23
$25:
  %87 = phi i64 [%58, %$23], [%77, %$26] ; # X
  %88 = phi i64 [%59, %$23], [%78, %$26] ; # N
  %89 = phi i64 [%60, %$23], [%79, %$26] ; # Bnd
  %90 = phi i64 [0, %$23], [0, %$26] ; # ->
  br label %$22
$22:
  %91 = phi i64 [%31, %$20], [%87, %$25] ; # X
  %92 = phi i64 [%52, %$20], [%88, %$25] ; # N
; # (runAt E)
  %93 = call i64 @runAt(i64 %13)
  %94 = inttoptr i64 %33 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %96, i64* %97
  br label %$7
$7:
  %98 = phi i64 [%16, %$9], [%20, %$11], [%29, %$13], [%91, %$22] ; # X
  %99 = phi i64 [%13, %$9], [%22, %$11], [%30, %$13], [%93, %$22] ; # ->
  ret i64 %99
}

define i64 @_def(i64) {
$1:
; # (let (X (cdr Exe) Sym (save (needSymb Exe (eval (++ X)))) Y (save...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needSymb Exe (eval (++ X)))
  %16 = xor i64 %15, 8
  %17 = and i64 %16, 14
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$8, label %$7
$7:
  call void @symErr(i64 %0, i64 %15)
  unreachable
$8:
; # (save (needSymb Exe (eval (++ X))))
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %15, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (++ X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
  %29 = getelementptr i64, i64* %27, i32 1
  %30 = load i64, i64* %29
; # (eval (++ X))
  %31 = and i64 %28, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$10
$11:
  br label %$9
$10:
  %33 = and i64 %28, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$12
$13:
  %35 = inttoptr i64 %28 to i64*
  %36 = load i64, i64* %35
  br label %$9
$12:
  %37 = call i64 @evList(i64 %28)
  br label %$9
$9:
  %38 = phi i64 [%28, %$11], [%36, %$13], [%37, %$12] ; # ->
; # (save (eval (++ X)))
  %39 = alloca i64, i64 2, align 16
  %40 = ptrtoint i64* %39 to i64
  %41 = inttoptr i64 %40 to i64*
  store i64 %38, i64* %41
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %43 = load i64, i64* %42
  %44 = inttoptr i64 %40 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  store i64 %43, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %46
; # (if (pair X) (let Val (save (eval (car X))) (when (sym? (val (tai...
; # (pair X)
  %47 = and i64 %30, 15
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %$14, label %$15
$14:
; # (let Val (save (eval (car X))) (when (sym? (val (tail Sym))) (if ...
; # (car X)
  %49 = inttoptr i64 %30 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$19, label %$18
$19:
  br label %$17
$18:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$21, label %$20
$21:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$17
$20:
  %57 = call i64 @evList(i64 %50)
  br label %$17
$17:
  %58 = phi i64 [%50, %$19], [%56, %$21], [%57, %$20] ; # ->
; # (save (eval (car X)))
  %59 = alloca i64, i64 2, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = inttoptr i64 %60 to i64*
  store i64 %58, i64* %61
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %63 = load i64, i64* %62
  %64 = inttoptr i64 %60 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  store i64 %63, i64* %65
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %66
; # (when (sym? (val (tail Sym))) (if (nil? Y) (dbFetch Exe Sym) (dbT...
; # (tail Sym)
  %67 = add i64 %15, -8
; # (val (tail Sym))
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (sym? (val (tail Sym)))
  %70 = and i64 %69, 8
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$22, label %$23
$22:
; # (if (nil? Y) (dbFetch Exe Sym) (dbTouch Exe Sym))
; # (nil? Y)
  %72 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %72, label %$24, label %$25
$24:
; # (dbFetch Exe Sym)
  call void @dbFetch(i64 %0, i64 %15)
  br label %$26
$25:
; # (dbTouch Exe Sym)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$26
$26:
  br label %$23
$23:
; # (let V (get Sym Y) (unless (or (nil? V) (equal V Val)) (redefMsg ...
; # (get Sym Y)
  %73 = call i64 @get(i64 %15, i64 %38)
; # (unless (or (nil? V) (equal V Val)) (redefMsg Sym Y))
; # (or (nil? V) (equal V Val))
; # (nil? V)
  %74 = icmp eq i64 %73, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %74, label %$27, label %$28
$28:
; # (equal V Val)
  %75 = call i1 @equal(i64 %73, i64 %58)
  br label %$27
$27:
  %76 = phi i1 [1, %$23], [%75, %$28] ; # ->
  br i1 %76, label %$30, label %$29
$29:
; # (redefMsg Sym Y)
  call void @redefMsg(i64 %15, i64 %38)
  br label %$30
$30:
; # (put Sym Y Val)
  call void @put(i64 %15, i64 %38, i64 %58)
; # (putSrc Sym Y)
  call void @putSrc(i64 %15, i64 %38)
  br label %$16
$15:
; # (chkVar Exe Sym)
  %77 = icmp uge i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %77, label %$32, label %$31
$32:
  %78 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %15
  br label %$31
$31:
  %79 = phi i1 [0, %$15], [%78, %$32] ; # ->
  br i1 %79, label %$33, label %$34
$33:
  call void @protErr(i64 %0, i64 %15)
  unreachable
$34:
; # (when (sym? (val (tail Sym))) (dbTouch Exe Sym))
; # (tail Sym)
  %80 = add i64 %15, -8
; # (val (tail Sym))
  %81 = inttoptr i64 %80 to i64*
  %82 = load i64, i64* %81
; # (sym? (val (tail Sym)))
  %83 = and i64 %82, 8
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$35, label %$36
$35:
; # (dbTouch Exe Sym)
  call void @dbTouch(i64 %0, i64 %15)
  br label %$36
$36:
; # (let V (val Sym) (unless (or (nil? V) (== V Sym) (equal V Y)) (re...
; # (val Sym)
  %85 = inttoptr i64 %15 to i64*
  %86 = load i64, i64* %85
; # (unless (or (nil? V) (== V Sym) (equal V Y)) (redefMsg Sym 0))
; # (or (nil? V) (== V Sym) (equal V Y))
; # (nil? V)
  %87 = icmp eq i64 %86, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %87, label %$37, label %$38
$38:
; # (== V Sym)
  %88 = icmp eq i64 %86, %15
  br i1 %88, label %$37, label %$39
$39:
; # (equal V Y)
  %89 = call i1 @equal(i64 %86, i64 %38)
  br label %$37
$37:
  %90 = phi i1 [1, %$36], [1, %$38], [%89, %$39] ; # ->
  br i1 %90, label %$41, label %$40
$40:
; # (redefMsg Sym 0)
  call void @redefMsg(i64 %15, i64 0)
  br label %$41
$41:
; # (set Sym Y)
  %91 = inttoptr i64 %15 to i64*
  store i64 %38, i64* %91
; # (putSrc Sym 0)
  call void @putSrc(i64 %15, i64 0)
  br label %$16
$16:
; # (drop *Safe)
  %92 = inttoptr i64 %20 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  %94 = load i64, i64* %93
  %95 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %94, i64* %95
  ret i64 %15
}

define i64 @_de(i64) {
$1:
; # (let S (cadr Exe) (redefine Exe S (cddr Exe)) S)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (cddr Exe)
  %6 = inttoptr i64 %0 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %8 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (redefine Exe S (cddr Exe))
  call void @redefine(i64 %0, i64 %5, i64 %11)
  ret i64 %5
}

define i64 @_dm(i64) {
$1:
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @evMethod(i64, i64, i64, i64, i64) {
$1:
; # (let (X (cdr Lst) Y (car Exe) P (set $Bind (push (val $At) $At (v...
; # (cdr Lst)
  %5 = inttoptr i64 %4 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car Exe)
  %8 = inttoptr i64 %3 to i64*
  %9 = load i64, i64* %8
; # (set $Bind (push (val $At) $At (val $Bind) Lst))
; # (val $At)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %11 = load i64, i64* %10
; # (val $Bind)
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %13 = load i64, i64* %12
; # (push (val $At) $At (val $Bind) Lst)
  %14 = alloca i64, i64 4, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %11, i64* %16
  %17 = add i64 %15, 8
  %18 = inttoptr i64 %17 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), i64* %18
  %19 = add i64 %15, 16
  %20 = inttoptr i64 %19 to i64*
  store i64 %13, i64* %20
  %21 = add i64 %15, 24
  %22 = inttoptr i64 %21 to i64*
  store i64 %4, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %15, i64* %23
; # (set $Bind (setq P (push $This Obj P)))
; # (push $This Obj P)
  %24 = alloca i64, i64 3, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64), i64* %26
  %27 = add i64 %25, 8
  %28 = inttoptr i64 %27 to i64*
  store i64 %0, i64* %28
  %29 = add i64 %25, 16
  %30 = inttoptr i64 %29 to i64*
  store i64 %15, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %25, i64* %31
; # (while (pair Y) (set $Bind (setq P (push (eval (++ X)) (++ Y) P))...
  br label %$2
$2:
  %32 = phi i64 [%7, %$1], [%43, %$5] ; # X
  %33 = phi i64 [%9, %$1], [%55, %$5] ; # Y
  %34 = phi i64 [%25, %$1], [%57, %$5] ; # P
; # (pair Y)
  %35 = and i64 %33, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$3, label %$4
$3:
  %37 = phi i64 [%32, %$2] ; # X
  %38 = phi i64 [%33, %$2] ; # Y
  %39 = phi i64 [%34, %$2] ; # P
; # (set $Bind (setq P (push (eval (++ X)) (++ Y) P)))
; # (++ X)
  %40 = inttoptr i64 %37 to i64*
  %41 = load i64, i64* %40
  %42 = getelementptr i64, i64* %40, i32 1
  %43 = load i64, i64* %42
; # (eval (++ X))
  %44 = and i64 %41, 6
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %$7, label %$6
$7:
  br label %$5
$6:
  %46 = and i64 %41, 8
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$9, label %$8
$9:
  %48 = inttoptr i64 %41 to i64*
  %49 = load i64, i64* %48
  br label %$5
$8:
  %50 = call i64 @evList(i64 %41)
  br label %$5
$5:
  %51 = phi i64 [%41, %$7], [%49, %$9], [%50, %$8] ; # ->
; # (++ Y)
  %52 = inttoptr i64 %38 to i64*
  %53 = load i64, i64* %52
  %54 = getelementptr i64, i64* %52, i32 1
  %55 = load i64, i64* %54
; # (push (eval (++ X)) (++ Y) P)
  %56 = alloca i64, i64 3, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %51, i64* %58
  %59 = add i64 %57, 8
  %60 = inttoptr i64 %59 to i64*
  store i64 %53, i64* %60
  %61 = add i64 %57, 16
  %62 = inttoptr i64 %61 to i64*
  store i64 %39, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %57, i64* %63
  br label %$2
$4:
  %64 = phi i64 [%32, %$2] ; # X
  %65 = phi i64 [%33, %$2] ; # Y
  %66 = phi i64 [%34, %$2] ; # P
; # (prog1 (if (== Y $At) (let (Link (val $Link) Next (val $Next)) (i...
; # (if (== Y $At) (let (Link (val $Link) Next (val $Next)) (if (atom...
; # (== Y $At)
  %67 = icmp eq i64 %65, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %67, label %$10, label %$11
$10:
  %68 = phi i64 [%64, %$4] ; # X
  %69 = phi i64 [%65, %$4] ; # Y
  %70 = phi i64 [%66, %$4] ; # P
; # (let (Link (val $Link) Next (val $Next)) (if (atom X) (set $Next ...
; # (val $Link)
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %72 = load i64, i64* %71
; # (val $Next)
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %74 = load i64, i64* %73
; # (if (atom X) (set $Next $Nil) (let (L (push NIL (eval (++ X)) NIL...
; # (atom X)
  %75 = and i64 %68, 15
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$13, label %$14
$13:
  %77 = phi i64 [%68, %$10] ; # X
  %78 = phi i64 [%69, %$10] ; # Y
  %79 = phi i64 [%70, %$10] ; # P
; # (set $Next $Nil)
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %80
  br label %$15
$14:
  %81 = phi i64 [%68, %$10] ; # X
  %82 = phi i64 [%69, %$10] ; # Y
  %83 = phi i64 [%70, %$10] ; # P
; # (let (L (push NIL (eval (++ X)) NIL) Q L) (link (ofs L 1)) (while...
; # (++ X)
  %84 = inttoptr i64 %81 to i64*
  %85 = load i64, i64* %84
  %86 = getelementptr i64, i64* %84, i32 1
  %87 = load i64, i64* %86
; # (eval (++ X))
  %88 = and i64 %85, 6
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$18, label %$17
$18:
  br label %$16
$17:
  %90 = and i64 %85, 8
  %91 = icmp ne i64 %90, 0
  br i1 %91, label %$20, label %$19
$20:
  %92 = inttoptr i64 %85 to i64*
  %93 = load i64, i64* %92
  br label %$16
$19:
  %94 = call i64 @evList(i64 %85)
  br label %$16
$16:
  %95 = phi i64 [%85, %$18], [%93, %$20], [%94, %$19] ; # ->
; # (push NIL (eval (++ X)) NIL)
  %96 = alloca i64, i64 3, align 16
  %97 = ptrtoint i64* %96 to i64
  %98 = add i64 %97, 8
  %99 = inttoptr i64 %98 to i64*
  store i64 %95, i64* %99
; # (ofs L 1)
  %100 = add i64 %97, 8
; # (link (ofs L 1))
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %102 = load i64, i64* %101
  %103 = inttoptr i64 %100 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  store i64 %102, i64* %104
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %100, i64* %105
; # (while (pair X) (setq L (set L (push NIL (eval (++ X)) NIL))) (li...
  br label %$21
$21:
  %106 = phi i64 [%87, %$16], [%119, %$24] ; # X
  %107 = phi i64 [%82, %$16], [%113, %$24] ; # Y
  %108 = phi i64 [%83, %$16], [%114, %$24] ; # P
  %109 = phi i64 [%97, %$16], [%129, %$24] ; # L
; # (pair X)
  %110 = and i64 %106, 15
  %111 = icmp eq i64 %110, 0
  br i1 %111, label %$22, label %$23
$22:
  %112 = phi i64 [%106, %$21] ; # X
  %113 = phi i64 [%107, %$21] ; # Y
  %114 = phi i64 [%108, %$21] ; # P
  %115 = phi i64 [%109, %$21] ; # L
; # (set L (push NIL (eval (++ X)) NIL))
; # (++ X)
  %116 = inttoptr i64 %112 to i64*
  %117 = load i64, i64* %116
  %118 = getelementptr i64, i64* %116, i32 1
  %119 = load i64, i64* %118
; # (eval (++ X))
  %120 = and i64 %117, 6
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$26, label %$25
$26:
  br label %$24
$25:
  %122 = and i64 %117, 8
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$28, label %$27
$28:
  %124 = inttoptr i64 %117 to i64*
  %125 = load i64, i64* %124
  br label %$24
$27:
  %126 = call i64 @evList(i64 %117)
  br label %$24
$24:
  %127 = phi i64 [%117, %$26], [%125, %$28], [%126, %$27] ; # ->
; # (push NIL (eval (++ X)) NIL)
  %128 = alloca i64, i64 3, align 16
  %129 = ptrtoint i64* %128 to i64
  %130 = add i64 %129, 8
  %131 = inttoptr i64 %130 to i64*
  store i64 %127, i64* %131
  %132 = inttoptr i64 %115 to i64*
  store i64 %129, i64* %132
; # (ofs L 1)
  %133 = add i64 %129, 8
; # (link (ofs L 1))
  %134 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %135 = load i64, i64* %134
  %136 = inttoptr i64 %133 to i64*
  %137 = getelementptr i64, i64* %136, i32 1
  store i64 %135, i64* %137
  %138 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %133, i64* %138
  br label %$21
$23:
  %139 = phi i64 [%106, %$21] ; # X
  %140 = phi i64 [%107, %$21] ; # Y
  %141 = phi i64 [%108, %$21] ; # P
  %142 = phi i64 [%109, %$21] ; # L
; # (set L $Nil $Next Q)
  %143 = inttoptr i64 %142 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %143
  %144 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 %97, i64* %144
  br label %$15
$15:
  %145 = phi i64 [%77, %$13], [%139, %$23] ; # X
  %146 = phi i64 [%78, %$13], [%140, %$23] ; # Y
  %147 = phi i64 [%79, %$13], [%141, %$23] ; # P
  %148 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%97, %$23] ; # ->
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$29
$29:
  %149 = phi i64 [%145, %$15], [%160, %$30] ; # X
  %150 = phi i64 [%146, %$15], [%161, %$30] ; # Y
  %151 = phi i64 [%147, %$15], [%165, %$30] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %152 = inttoptr i64 %151 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
; # (xchg Sym P)
  %155 = inttoptr i64 %154 to i64*
  %156 = load i64, i64* %155
  %157 = inttoptr i64 %151 to i64*
  %158 = load i64, i64* %157
  store i64 %158, i64* %155
  store i64 %156, i64* %157
; # (? (== $At Sym))
; # (== $At Sym)
  %159 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %154
  br i1 %159, label %$31, label %$30
$30:
  %160 = phi i64 [%149, %$29] ; # X
  %161 = phi i64 [%150, %$29] ; # Y
  %162 = phi i64 [%151, %$29] ; # P
; # (val 3 P)
  %163 = inttoptr i64 %162 to i64*
  %164 = getelementptr i64, i64* %163, i32 2
  %165 = load i64, i64* %164
  br label %$29
$31:
  %166 = phi i64 [%149, %$29] ; # X
  %167 = phi i64 [%150, %$29] ; # Y
  %168 = phi i64 [%151, %$29] ; # P
  %169 = phi i64 [0, %$29] ; # ->
; # (let (C (val $Cls) K (val $Key)) (prog1 (run (cdr Exe)) (set $Key...
; # (val $Cls)
  %170 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 136) to i64) to i64*
  %171 = load i64, i64* %170
; # (val $Key)
  %172 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 144) to i64) to i64*
  %173 = load i64, i64* %172
; # (prog1 (run (cdr Exe)) (set $Key K $Cls C $Next Next $Link Link))...
; # (cdr Exe)
  %174 = inttoptr i64 %3 to i64*
  %175 = getelementptr i64, i64* %174, i32 1
  %176 = load i64, i64* %175
; # (run (cdr Exe))
  br label %$32
$32:
  %177 = phi i64 [%176, %$31], [%199, %$41] ; # Prg
  %178 = inttoptr i64 %177 to i64*
  %179 = load i64, i64* %178
  %180 = getelementptr i64, i64* %178, i32 1
  %181 = load i64, i64* %180
  %182 = and i64 %181, 15
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$35, label %$33
$35:
  %184 = phi i64 [%181, %$32] ; # Prg
  %185 = and i64 %179, 6
  %186 = icmp ne i64 %185, 0
  br i1 %186, label %$38, label %$37
$38:
  br label %$36
$37:
  %187 = and i64 %179, 8
  %188 = icmp ne i64 %187, 0
  br i1 %188, label %$40, label %$39
$40:
  %189 = inttoptr i64 %179 to i64*
  %190 = load i64, i64* %189
  br label %$36
$39:
  %191 = call i64 @evList(i64 %179)
  br label %$36
$36:
  %192 = phi i64 [%179, %$38], [%190, %$40], [%191, %$39] ; # ->
  br label %$34
$33:
  %193 = phi i64 [%181, %$32] ; # Prg
  %194 = and i64 %179, 15
  %195 = icmp eq i64 %194, 0
  br i1 %195, label %$42, label %$41
$42:
  %196 = phi i64 [%193, %$33] ; # Prg
  %197 = call i64 @evList(i64 %179)
  %198 = icmp ne i64 %197, 0
  br label %$41
$41:
  %199 = phi i64 [%193, %$33], [%196, %$42] ; # Prg
  %200 = phi i1 [0, %$33], [%198, %$42] ; # ->
  br label %$32
$34:
  %201 = phi i64 [%184, %$36] ; # Prg
  %202 = phi i64 [%192, %$36] ; # ->
; # (set $Key K $Cls C $Next Next $Link Link)
  %203 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 144) to i64) to i64*
  store i64 %173, i64* %203
  %204 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 136) to i64) to i64*
  store i64 %171, i64* %204
  %205 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 %74, i64* %205
  %206 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %72, i64* %206
  br label %$12
$11:
  %207 = phi i64 [%64, %$4] ; # X
  %208 = phi i64 [%65, %$4] ; # Y
  %209 = phi i64 [%66, %$4] ; # P
; # (unless (== Y $Nil) (set $Bind (push (val Y) Y P) Y X))
; # (== Y $Nil)
  %210 = icmp eq i64 %208, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %210, label %$44, label %$43
$43:
  %211 = phi i64 [%207, %$11] ; # X
  %212 = phi i64 [%208, %$11] ; # Y
  %213 = phi i64 [%209, %$11] ; # P
; # (set $Bind (push (val Y) Y P) Y X)
; # (val Y)
  %214 = inttoptr i64 %212 to i64*
  %215 = load i64, i64* %214
; # (push (val Y) Y P)
  %216 = alloca i64, i64 3, align 16
  %217 = ptrtoint i64* %216 to i64
  %218 = inttoptr i64 %217 to i64*
  store i64 %215, i64* %218
  %219 = add i64 %217, 8
  %220 = inttoptr i64 %219 to i64*
  store i64 %212, i64* %220
  %221 = add i64 %217, 16
  %222 = inttoptr i64 %221 to i64*
  store i64 %213, i64* %222
  %223 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %217, i64* %223
  %224 = inttoptr i64 %212 to i64*
  store i64 %211, i64* %224
  br label %$44
$44:
  %225 = phi i64 [%207, %$11], [%211, %$43] ; # X
  %226 = phi i64 [%208, %$11], [%212, %$43] ; # Y
  %227 = phi i64 [%209, %$11], [%213, %$43] ; # P
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$45
$45:
  %228 = phi i64 [%225, %$44], [%239, %$46] ; # X
  %229 = phi i64 [%226, %$44], [%240, %$46] ; # Y
  %230 = phi i64 [%227, %$44], [%244, %$46] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %231 = inttoptr i64 %230 to i64*
  %232 = getelementptr i64, i64* %231, i32 1
  %233 = load i64, i64* %232
; # (xchg Sym P)
  %234 = inttoptr i64 %233 to i64*
  %235 = load i64, i64* %234
  %236 = inttoptr i64 %230 to i64*
  %237 = load i64, i64* %236
  store i64 %237, i64* %234
  store i64 %235, i64* %236
; # (? (== $At Sym))
; # (== $At Sym)
  %238 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %233
  br i1 %238, label %$47, label %$46
$46:
  %239 = phi i64 [%228, %$45] ; # X
  %240 = phi i64 [%229, %$45] ; # Y
  %241 = phi i64 [%230, %$45] ; # P
; # (val 3 P)
  %242 = inttoptr i64 %241 to i64*
  %243 = getelementptr i64, i64* %242, i32 2
  %244 = load i64, i64* %243
  br label %$45
$47:
  %245 = phi i64 [%228, %$45] ; # X
  %246 = phi i64 [%229, %$45] ; # Y
  %247 = phi i64 [%230, %$45] ; # P
  %248 = phi i64 [0, %$45] ; # ->
; # (let (C (val $Cls) K (val $Key)) (set $Cls Cls) (set $Key Key) (p...
; # (val $Cls)
  %249 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 136) to i64) to i64*
  %250 = load i64, i64* %249
; # (val $Key)
  %251 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 144) to i64) to i64*
  %252 = load i64, i64* %251
; # (set $Cls Cls)
  %253 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 136) to i64) to i64*
  store i64 %1, i64* %253
; # (set $Key Key)
  %254 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 144) to i64) to i64*
  store i64 %2, i64* %254
; # (prog1 (run (cdr Exe)) (set $Key K $Cls C))
; # (cdr Exe)
  %255 = inttoptr i64 %3 to i64*
  %256 = getelementptr i64, i64* %255, i32 1
  %257 = load i64, i64* %256
; # (run (cdr Exe))
  br label %$48
$48:
  %258 = phi i64 [%257, %$47], [%280, %$57] ; # Prg
  %259 = inttoptr i64 %258 to i64*
  %260 = load i64, i64* %259
  %261 = getelementptr i64, i64* %259, i32 1
  %262 = load i64, i64* %261
  %263 = and i64 %262, 15
  %264 = icmp ne i64 %263, 0
  br i1 %264, label %$51, label %$49
$51:
  %265 = phi i64 [%262, %$48] ; # Prg
  %266 = and i64 %260, 6
  %267 = icmp ne i64 %266, 0
  br i1 %267, label %$54, label %$53
$54:
  br label %$52
$53:
  %268 = and i64 %260, 8
  %269 = icmp ne i64 %268, 0
  br i1 %269, label %$56, label %$55
$56:
  %270 = inttoptr i64 %260 to i64*
  %271 = load i64, i64* %270
  br label %$52
$55:
  %272 = call i64 @evList(i64 %260)
  br label %$52
$52:
  %273 = phi i64 [%260, %$54], [%271, %$56], [%272, %$55] ; # ->
  br label %$50
$49:
  %274 = phi i64 [%262, %$48] ; # Prg
  %275 = and i64 %260, 15
  %276 = icmp eq i64 %275, 0
  br i1 %276, label %$58, label %$57
$58:
  %277 = phi i64 [%274, %$49] ; # Prg
  %278 = call i64 @evList(i64 %260)
  %279 = icmp ne i64 %278, 0
  br label %$57
$57:
  %280 = phi i64 [%274, %$49], [%277, %$58] ; # Prg
  %281 = phi i1 [0, %$49], [%279, %$58] ; # ->
  br label %$48
$50:
  %282 = phi i64 [%265, %$52] ; # Prg
  %283 = phi i64 [%273, %$52] ; # ->
; # (set $Key K $Cls C)
  %284 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 144) to i64) to i64*
  store i64 %252, i64* %284
  %285 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 136) to i64) to i64*
  store i64 %250, i64* %285
  br label %$12
$12:
  %286 = phi i64 [%166, %$34], [%245, %$50] ; # X
  %287 = phi i64 [%167, %$34], [%246, %$50] ; # Y
  %288 = phi i64 [%168, %$34], [%247, %$50] ; # P
  %289 = phi i64 [%202, %$34], [%283, %$50] ; # ->
; # (val $Bind)
  %290 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %291 = load i64, i64* %290
; # (loop (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq...
  br label %$59
$59:
  %292 = phi i64 [%286, %$12], [%302, %$60] ; # X
  %293 = phi i64 [%287, %$12], [%303, %$60] ; # Y
  %294 = phi i64 [%291, %$12], [%307, %$60] ; # P
; # (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq P (va...
; # (val 2 P)
  %295 = inttoptr i64 %294 to i64*
  %296 = getelementptr i64, i64* %295, i32 1
  %297 = load i64, i64* %296
; # (set Sym (val P))
; # (val P)
  %298 = inttoptr i64 %294 to i64*
  %299 = load i64, i64* %298
  %300 = inttoptr i64 %297 to i64*
  store i64 %299, i64* %300
; # (? (== $At Sym))
; # (== $At Sym)
  %301 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %297
  br i1 %301, label %$61, label %$60
$60:
  %302 = phi i64 [%292, %$59] ; # X
  %303 = phi i64 [%293, %$59] ; # Y
  %304 = phi i64 [%294, %$59] ; # P
; # (val 3 P)
  %305 = inttoptr i64 %304 to i64*
  %306 = getelementptr i64, i64* %305, i32 2
  %307 = load i64, i64* %306
  br label %$59
$61:
  %308 = phi i64 [%292, %$59] ; # X
  %309 = phi i64 [%293, %$59] ; # Y
  %310 = phi i64 [%294, %$59] ; # P
  %311 = phi i64 [0, %$59] ; # ->
; # (set $Bind (val 3 P))
; # (val 3 P)
  %312 = inttoptr i64 %310 to i64*
  %313 = getelementptr i64, i64* %312, i32 2
  %314 = load i64, i64* %313
  %315 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %314, i64* %315
  ret i64 %289
}

define i64 @_meth(i64) {
$1:
  ret i64 %0
}

define i64 @_box(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (consSym ZERO (eval (cadr Exe)))
  %14 = call i64 @consSym(i64 2, i64 %13)
  ret i64 %14
}

define i64 @_new(i64) {
$1:
  ret i64 %0
}

define i64 @_type(i64) {
$1:
  ret i64 %0
}

define i64 @_isa(i64) {
$1:
  ret i64 %0
}

define i64 @_method(i64) {
$1:
  ret i64 %0
}

define i64 @_send(i64) {
$1:
  ret i64 %0
}

define i64 @_try(i64) {
$1:
  ret i64 %0
}

define i64 @_super(i64) {
$1:
  ret i64 %0
}

define i64 @_extra(i64) {
$1:
  ret i64 %0
}

define i64 @_and(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (nil? Y) Y) (set ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (nil? Y) Y) (set $At Y) (? (atom (...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%25, %$11] ; # X
; # (let Y (eval (car X)) (? (nil? Y) Y) (set $At Y) (? (atom (shift ...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (nil? Y) Y)
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$10, label %$8
$10:
  %16 = phi i64 [%4, %$3] ; # X
  br label %$9
$8:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %14, i64* %18
; # (? (atom (shift X)) Y)
; # (shift X)
  %19 = inttoptr i64 %17 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
; # (atom (shift X))
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$11
$12:
  %24 = phi i64 [%21, %$8] ; # X
  br label %$9
$11:
  %25 = phi i64 [%21, %$8] ; # X
  br label %$2
$9:
  %26 = phi i64 [%16, %$10], [%24, %$12] ; # X
  %27 = phi i64 [%14, %$10], [%14, %$12] ; # ->
  ret i64 %27
}

define i64 @_or(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (not (nil? Y)) (s...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y)) (? (at...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%26, %$11] ; # X
; # (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y)) (? (atom (sh...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (not (nil? Y)) (set $At Y))
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %16 = icmp eq i1 %15, 0
  br i1 %16, label %$10, label %$8
$10:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %14, i64* %18
  br label %$9
$8:
  %19 = phi i64 [%4, %$3] ; # X
; # (? (atom (shift X)) Y)
; # (shift X)
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (atom (shift X))
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%22, %$8] ; # X
  br label %$9
$11:
  %26 = phi i64 [%22, %$8] ; # X
  br label %$2
$9:
  %27 = phi i64 [%17, %$10], [%25, %$12] ; # X
  %28 = phi i64 [%14, %$10], [%14, %$12] ; # ->
  ret i64 %28
}

define i64 @_nand(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (nil? Y) $T) (set...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (nil? Y) $T) (set $At Y) (? (atom ...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%25, %$11] ; # X
; # (let Y (eval (car X)) (? (nil? Y) $T) (set $At Y) (? (atom (shift...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (nil? Y) $T)
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %15, label %$10, label %$8
$10:
  %16 = phi i64 [%4, %$3] ; # X
  br label %$9
$8:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %14, i64* %18
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %19 = inttoptr i64 %17 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
; # (atom (shift X))
  %22 = and i64 %21, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$11
$12:
  %24 = phi i64 [%21, %$8] ; # X
  br label %$9
$11:
  %25 = phi i64 [%21, %$8] ; # X
  br label %$2
$9:
  %26 = phi i64 [%16, %$10], [%24, %$12] ; # X
  %27 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %27
}

define i64 @_nor(i64) {
$1:
; # (let X (cdr Exe) (loop (let Y (eval (car X)) (? (not (nil? Y)) (s...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y) $Nil) (...
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%26, %$11] ; # X
; # (let Y (eval (car X)) (? (not (nil? Y)) (set $At Y) $Nil) (? (ato...
; # (car X)
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (eval (car X))
  %7 = and i64 %6, 6
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$5, label %$4
$5:
  br label %$3
$4:
  %9 = and i64 %6, 8
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$7, label %$6
$7:
  %11 = inttoptr i64 %6 to i64*
  %12 = load i64, i64* %11
  br label %$3
$6:
  %13 = call i64 @evList(i64 %6)
  br label %$3
$3:
  %14 = phi i64 [%6, %$5], [%12, %$7], [%13, %$6] ; # ->
; # (? (not (nil? Y)) (set $At Y) $Nil)
; # (nil? Y)
  %15 = icmp eq i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Y))
  %16 = icmp eq i1 %15, 0
  br i1 %16, label %$10, label %$8
$10:
  %17 = phi i64 [%4, %$3] ; # X
; # (set $At Y)
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %14, i64* %18
  br label %$9
$8:
  %19 = phi i64 [%4, %$3] ; # X
; # (? (atom (shift X)) $T)
; # (shift X)
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (atom (shift X))
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%22, %$8] ; # X
  br label %$9
$11:
  %26 = phi i64 [%22, %$8] ; # X
  br label %$2
$9:
  %27 = phi i64 [%17, %$10], [%25, %$12] ; # X
  %28 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$12] ; # ->
  ret i64 %28
}

define i64 @_xor(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (if (nil? (eval (car X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (if (nil? (eval (car X))) @ $T) (if (nil...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (if (nil? (eval (car X))) @ $T)
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (eval (car X))
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$12, label %$11
$12:
  br label %$10
$11:
  %22 = and i64 %19, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = inttoptr i64 %19 to i64*
  %25 = load i64, i64* %24
  br label %$10
$13:
  %26 = call i64 @evList(i64 %19)
  br label %$10
$10:
  %27 = phi i64 [%19, %$12], [%25, %$14], [%26, %$13] ; # ->
; # (nil? (eval (car X)))
  %28 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %28, label %$15, label %$16
$15:
  %29 = phi i64 [%17, %$10] ; # X
  br label %$17
$16:
  %30 = phi i64 [%17, %$10] ; # X
  br label %$17
$17:
  %31 = phi i64 [%29, %$15], [%30, %$16] ; # X
  %32 = phi i64 [%27, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$16] ; # ->
  br label %$9
$8:
  %33 = phi i64 [%7, %$2] ; # X
; # (if (nil? (eval (car X))) $T $Nil)
; # (car X)
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (eval (car X))
  %36 = and i64 %35, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$20, label %$19
$20:
  br label %$18
$19:
  %38 = and i64 %35, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$22, label %$21
$22:
  %40 = inttoptr i64 %35 to i64*
  %41 = load i64, i64* %40
  br label %$18
$21:
  %42 = call i64 @evList(i64 %35)
  br label %$18
$18:
  %43 = phi i64 [%35, %$20], [%41, %$22], [%42, %$21] ; # ->
; # (nil? (eval (car X)))
  %44 = icmp eq i64 %43, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %44, label %$23, label %$24
$23:
  %45 = phi i64 [%33, %$18] ; # X
  br label %$25
$24:
  %46 = phi i64 [%33, %$18] ; # X
  br label %$25
$25:
  %47 = phi i64 [%45, %$23], [%46, %$24] ; # X
  %48 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$23], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$24] ; # ->
  br label %$9
$9:
  %49 = phi i64 [%31, %$17], [%47, %$25] ; # X
  %50 = phi i64 [%32, %$17], [%48, %$25] ; # ->
  ret i64 %50
}

define i64 @_bool(i64) {
$1:
; # (if (nil? (eval (cadr Exe))) @ $T)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_not(i64) {
$1:
; # (if (nil? (eval (cadr Exe))) $T (set $At @) $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (set $At @)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %13, i64* %15
  br label %$9
$9:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_nil(i64) {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (exec (cdr Exe))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%16, %$5] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %6, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  %11 = phi i64 [%8, %$2] ; # Prg
  %12 = call i64 @evList(i64 %6)
  br label %$4
$4:
  %13 = phi i64 [%8, %$2], [%11, %$3] ; # Prg
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$6, label %$5
$5:
  %16 = phi i64 [%13, %$4] ; # Prg
  br label %$2
$6:
  %17 = phi i64 [%13, %$4] ; # Prg
  %18 = phi i64 [0, %$4] ; # ->
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_t(i64) {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (exec (cdr Exe))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%16, %$5] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %6, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$3, label %$4
$3:
  %11 = phi i64 [%8, %$2] ; # Prg
  %12 = call i64 @evList(i64 %6)
  br label %$4
$4:
  %13 = phi i64 [%8, %$2], [%11, %$3] ; # Prg
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$6, label %$5
$5:
  %16 = phi i64 [%13, %$4] ; # Prg
  br label %$2
$6:
  %17 = phi i64 [%13, %$4] ; # Prg
  %18 = phi i64 [0, %$4] ; # ->
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
}

define i64 @_prog(i64) {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (run (cdr Exe))
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%26, %$11] ; # Prg
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = getelementptr i64, i64* %5, i32 1
  %8 = load i64, i64* %7
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$5, label %$3
$5:
  %11 = phi i64 [%8, %$2] ; # Prg
  %12 = and i64 %6, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$8, label %$7
$8:
  br label %$6
$7:
  %14 = and i64 %6, 8
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$10, label %$9
$10:
  %16 = inttoptr i64 %6 to i64*
  %17 = load i64, i64* %16
  br label %$6
$9:
  %18 = call i64 @evList(i64 %6)
  br label %$6
$6:
  %19 = phi i64 [%6, %$8], [%17, %$10], [%18, %$9] ; # ->
  br label %$4
$3:
  %20 = phi i64 [%8, %$2] ; # Prg
  %21 = and i64 %6, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$12, label %$11
$12:
  %23 = phi i64 [%20, %$3] ; # Prg
  %24 = call i64 @evList(i64 %6)
  %25 = icmp ne i64 %24, 0
  br label %$11
$11:
  %26 = phi i64 [%20, %$3], [%23, %$12] ; # Prg
  %27 = phi i1 [0, %$3], [%25, %$12] ; # ->
  br label %$2
$4:
  %28 = phi i64 [%11, %$6] ; # Prg
  %29 = phi i64 [%19, %$6] ; # ->
  ret i64 %29
}

define i64 @_prog1(i64) {
$1:
; # (let X (cdr Exe) (prog1 (set $At (save (eval (++ X)))) (exec X)))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog1 (set $At (save (eval (++ X)))) (exec X))
; # (set $At (save (eval (++ X))))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %15, i64* %24
; # (exec X)
  br label %$7
$7:
  %25 = phi i64 [%7, %$2], [%37, %$10] ; # Prg
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
  %28 = getelementptr i64, i64* %26, i32 1
  %29 = load i64, i64* %28
  %30 = and i64 %27, 15
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$8, label %$9
$8:
  %32 = phi i64 [%29, %$7] ; # Prg
  %33 = call i64 @evList(i64 %27)
  br label %$9
$9:
  %34 = phi i64 [%29, %$7], [%32, %$8] ; # Prg
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$11, label %$10
$10:
  %37 = phi i64 [%34, %$9] ; # Prg
  br label %$7
$11:
  %38 = phi i64 [%34, %$9] ; # Prg
  %39 = phi i64 [0, %$9] ; # ->
; # (drop *Safe)
  %40 = inttoptr i64 %17 to i64*
  %41 = getelementptr i64, i64* %40, i32 1
  %42 = load i64, i64* %41
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %43
  ret i64 %15
}

define i64 @_prog2(i64) {
$1:
; # (let X (cdr Exe) (prog2 (eval (++ X)) (set $At (save (eval (++ X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (prog2 (eval (++ X)) (set $At (save (eval (++ X)))) (exec X))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (set $At (save (eval (++ X))))
; # (++ X)
  %16 = inttoptr i64 %7 to i64*
  %17 = load i64, i64* %16
  %18 = getelementptr i64, i64* %16, i32 1
  %19 = load i64, i64* %18
; # (eval (++ X))
  %20 = and i64 %17, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$8
$9:
  br label %$7
$8:
  %22 = and i64 %17, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$11:
  %24 = inttoptr i64 %17 to i64*
  %25 = load i64, i64* %24
  br label %$7
$10:
  %26 = call i64 @evList(i64 %17)
  br label %$7
$7:
  %27 = phi i64 [%17, %$9], [%25, %$11], [%26, %$10] ; # ->
; # (save (eval (++ X)))
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %27, i64* %36
; # (exec X)
  br label %$12
$12:
  %37 = phi i64 [%19, %$7], [%49, %$15] ; # Prg
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
  %40 = getelementptr i64, i64* %38, i32 1
  %41 = load i64, i64* %40
  %42 = and i64 %39, 15
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %$13, label %$14
$13:
  %44 = phi i64 [%41, %$12] ; # Prg
  %45 = call i64 @evList(i64 %39)
  br label %$14
$14:
  %46 = phi i64 [%41, %$12], [%44, %$13] ; # Prg
  %47 = and i64 %46, 15
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$16, label %$15
$15:
  %49 = phi i64 [%46, %$14] ; # Prg
  br label %$12
$16:
  %50 = phi i64 [%46, %$14] ; # Prg
  %51 = phi i64 [0, %$14] ; # ->
; # (drop *Safe)
  %52 = inttoptr i64 %29 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %54, i64* %55
  ret i64 %27
}

define i64 @_if(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (run (cdr X)) (set $At ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (run (cdr X)) (set $At @) (eval (car X))...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (cdr X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (run (cdr X))
  br label %$10
$10:
  %21 = phi i64 [%20, %$7], [%43, %$19] ; # Prg
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  %24 = getelementptr i64, i64* %22, i32 1
  %25 = load i64, i64* %24
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$13, label %$11
$13:
  %28 = phi i64 [%25, %$10] ; # Prg
  %29 = and i64 %23, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$16, label %$15
$16:
  br label %$14
$15:
  %31 = and i64 %23, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$18, label %$17
$18:
  %33 = inttoptr i64 %23 to i64*
  %34 = load i64, i64* %33
  br label %$14
$17:
  %35 = call i64 @evList(i64 %23)
  br label %$14
$14:
  %36 = phi i64 [%23, %$16], [%34, %$18], [%35, %$17] ; # ->
  br label %$12
$11:
  %37 = phi i64 [%25, %$10] ; # Prg
  %38 = and i64 %23, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$20, label %$19
$20:
  %40 = phi i64 [%37, %$11] ; # Prg
  %41 = call i64 @evList(i64 %23)
  %42 = icmp ne i64 %41, 0
  br label %$19
$19:
  %43 = phi i64 [%37, %$11], [%40, %$20] ; # Prg
  %44 = phi i1 [0, %$11], [%42, %$20] ; # ->
  br label %$10
$12:
  %45 = phi i64 [%28, %$14] ; # Prg
  %46 = phi i64 [%36, %$14] ; # ->
  br label %$9
$8:
  %47 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %15, i64* %48
; # (car X)
  %49 = inttoptr i64 %47 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$23, label %$22
$23:
  br label %$21
$22:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$25, label %$24
$25:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$21
$24:
  %57 = call i64 @evList(i64 %50)
  br label %$21
$21:
  %58 = phi i64 [%50, %$23], [%56, %$25], [%57, %$24] ; # ->
  br label %$9
$9:
  %59 = phi i64 [%17, %$12], [%47, %$21] ; # X
  %60 = phi i64 [%46, %$12], [%58, %$21] ; # ->
  ret i64 %60
}

define i64 @_ifn(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (eval (car X)) (set $At...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (eval (car X)) (set $At @) (run (cdr X))...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (eval (car X))
  %20 = and i64 %19, 6
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$12, label %$11
$12:
  br label %$10
$11:
  %22 = and i64 %19, 8
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = inttoptr i64 %19 to i64*
  %25 = load i64, i64* %24
  br label %$10
$13:
  %26 = call i64 @evList(i64 %19)
  br label %$10
$10:
  %27 = phi i64 [%19, %$12], [%25, %$14], [%26, %$13] ; # ->
  br label %$9
$8:
  %28 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %15, i64* %29
; # (cdr X)
  %30 = inttoptr i64 %28 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (run (cdr X))
  br label %$15
$15:
  %33 = phi i64 [%32, %$8], [%55, %$24] ; # Prg
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
  %36 = getelementptr i64, i64* %34, i32 1
  %37 = load i64, i64* %36
  %38 = and i64 %37, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$18, label %$16
$18:
  %40 = phi i64 [%37, %$15] ; # Prg
  %41 = and i64 %35, 6
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$21, label %$20
$21:
  br label %$19
$20:
  %43 = and i64 %35, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$23, label %$22
$23:
  %45 = inttoptr i64 %35 to i64*
  %46 = load i64, i64* %45
  br label %$19
$22:
  %47 = call i64 @evList(i64 %35)
  br label %$19
$19:
  %48 = phi i64 [%35, %$21], [%46, %$23], [%47, %$22] ; # ->
  br label %$17
$16:
  %49 = phi i64 [%37, %$15] ; # Prg
  %50 = and i64 %35, 15
  %51 = icmp eq i64 %50, 0
  br i1 %51, label %$25, label %$24
$25:
  %52 = phi i64 [%49, %$16] ; # Prg
  %53 = call i64 @evList(i64 %35)
  %54 = icmp ne i64 %53, 0
  br label %$24
$24:
  %55 = phi i64 [%49, %$16], [%52, %$25] ; # Prg
  %56 = phi i1 [0, %$16], [%54, %$25] ; # ->
  br label %$15
$17:
  %57 = phi i64 [%40, %$19] ; # Prg
  %58 = phi i64 [%48, %$19] ; # ->
  br label %$9
$9:
  %59 = phi i64 [%17, %$10], [%28, %$17] ; # X
  %60 = phi i64 [%27, %$10], [%58, %$17] ; # ->
  ret i64 %60
}

define i64 @_if2(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (if (nil? (eval (++ X))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (if (nil? (eval (++ X))) (run (cdr (cddr...
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (if (nil? (eval (++ X))) (run (cdr (cddr X))) (set $At @) (eval (...
; # (++ X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  %20 = getelementptr i64, i64* %18, i32 1
  %21 = load i64, i64* %20
; # (eval (++ X))
  %22 = and i64 %19, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$11
$12:
  br label %$10
$11:
  %24 = and i64 %19, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$14, label %$13
$14:
  %26 = inttoptr i64 %19 to i64*
  %27 = load i64, i64* %26
  br label %$10
$13:
  %28 = call i64 @evList(i64 %19)
  br label %$10
$10:
  %29 = phi i64 [%19, %$12], [%27, %$14], [%28, %$13] ; # ->
; # (nil? (eval (++ X)))
  %30 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %30, label %$15, label %$16
$15:
  %31 = phi i64 [%21, %$10] ; # X
; # (cddr X)
  %32 = inttoptr i64 %31 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
  %35 = inttoptr i64 %34 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
; # (cdr (cddr X))
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
; # (run (cdr (cddr X)))
  br label %$18
$18:
  %41 = phi i64 [%40, %$15], [%63, %$27] ; # Prg
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
  %44 = getelementptr i64, i64* %42, i32 1
  %45 = load i64, i64* %44
  %46 = and i64 %45, 15
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$21, label %$19
$21:
  %48 = phi i64 [%45, %$18] ; # Prg
  %49 = and i64 %43, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$24, label %$23
$24:
  br label %$22
$23:
  %51 = and i64 %43, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$26, label %$25
$26:
  %53 = inttoptr i64 %43 to i64*
  %54 = load i64, i64* %53
  br label %$22
$25:
  %55 = call i64 @evList(i64 %43)
  br label %$22
$22:
  %56 = phi i64 [%43, %$24], [%54, %$26], [%55, %$25] ; # ->
  br label %$20
$19:
  %57 = phi i64 [%45, %$18] ; # Prg
  %58 = and i64 %43, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$28, label %$27
$28:
  %60 = phi i64 [%57, %$19] ; # Prg
  %61 = call i64 @evList(i64 %43)
  %62 = icmp ne i64 %61, 0
  br label %$27
$27:
  %63 = phi i64 [%57, %$19], [%60, %$28] ; # Prg
  %64 = phi i1 [0, %$19], [%62, %$28] ; # ->
  br label %$18
$20:
  %65 = phi i64 [%48, %$22] ; # Prg
  %66 = phi i64 [%56, %$22] ; # ->
  br label %$17
$16:
  %67 = phi i64 [%21, %$10] ; # X
; # (set $At @)
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %29, i64* %68
; # (cddr X)
  %69 = inttoptr i64 %67 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 %71 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (car (cddr X))
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
; # (eval (car (cddr X)))
  %77 = and i64 %76, 6
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %$31, label %$30
$31:
  br label %$29
$30:
  %79 = and i64 %76, 8
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$33, label %$32
$33:
  %81 = inttoptr i64 %76 to i64*
  %82 = load i64, i64* %81
  br label %$29
$32:
  %83 = call i64 @evList(i64 %76)
  br label %$29
$29:
  %84 = phi i64 [%76, %$31], [%82, %$33], [%83, %$32] ; # ->
  br label %$17
$17:
  %85 = phi i64 [%31, %$20], [%67, %$29] ; # X
  %86 = phi i64 [%66, %$20], [%84, %$29] ; # ->
  br label %$9
$8:
  %87 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %88 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %15, i64* %88
; # (if (nil? (eval (++ X))) (eval (cadr X)) (set $At @) (eval (car X...
; # (++ X)
  %89 = inttoptr i64 %87 to i64*
  %90 = load i64, i64* %89
  %91 = getelementptr i64, i64* %89, i32 1
  %92 = load i64, i64* %91
; # (eval (++ X))
  %93 = and i64 %90, 6
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$36, label %$35
$36:
  br label %$34
$35:
  %95 = and i64 %90, 8
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$38, label %$37
$38:
  %97 = inttoptr i64 %90 to i64*
  %98 = load i64, i64* %97
  br label %$34
$37:
  %99 = call i64 @evList(i64 %90)
  br label %$34
$34:
  %100 = phi i64 [%90, %$36], [%98, %$38], [%99, %$37] ; # ->
; # (nil? (eval (++ X)))
  %101 = icmp eq i64 %100, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %101, label %$39, label %$40
$39:
  %102 = phi i64 [%92, %$34] ; # X
; # (cadr X)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
  %106 = inttoptr i64 %105 to i64*
  %107 = load i64, i64* %106
; # (eval (cadr X))
  %108 = and i64 %107, 6
  %109 = icmp ne i64 %108, 0
  br i1 %109, label %$44, label %$43
$44:
  br label %$42
$43:
  %110 = and i64 %107, 8
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$46, label %$45
$46:
  %112 = inttoptr i64 %107 to i64*
  %113 = load i64, i64* %112
  br label %$42
$45:
  %114 = call i64 @evList(i64 %107)
  br label %$42
$42:
  %115 = phi i64 [%107, %$44], [%113, %$46], [%114, %$45] ; # ->
  br label %$41
$40:
  %116 = phi i64 [%92, %$34] ; # X
; # (set $At @)
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %100, i64* %117
; # (car X)
  %118 = inttoptr i64 %116 to i64*
  %119 = load i64, i64* %118
; # (eval (car X))
  %120 = and i64 %119, 6
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$49, label %$48
$49:
  br label %$47
$48:
  %122 = and i64 %119, 8
  %123 = icmp ne i64 %122, 0
  br i1 %123, label %$51, label %$50
$51:
  %124 = inttoptr i64 %119 to i64*
  %125 = load i64, i64* %124
  br label %$47
$50:
  %126 = call i64 @evList(i64 %119)
  br label %$47
$47:
  %127 = phi i64 [%119, %$49], [%125, %$51], [%126, %$50] ; # ->
  br label %$41
$41:
  %128 = phi i64 [%102, %$42], [%116, %$47] ; # X
  %129 = phi i64 [%115, %$42], [%127, %$47] ; # ->
  br label %$9
$9:
  %130 = phi i64 [%85, %$17], [%128, %$41] ; # X
  %131 = phi i64 [%86, %$17], [%129, %$41] ; # ->
  ret i64 %131
}

define i64 @_when(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) @ (set $At @) (run X)))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) @ (set $At @) (run X))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
  br label %$9
$8:
  %18 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %15, i64* %19
; # (run X)
  br label %$10
$10:
  %20 = phi i64 [%18, %$8], [%42, %$19] ; # Prg
  %21 = inttoptr i64 %20 to i64*
  %22 = load i64, i64* %21
  %23 = getelementptr i64, i64* %21, i32 1
  %24 = load i64, i64* %23
  %25 = and i64 %24, 15
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$11
$13:
  %27 = phi i64 [%24, %$10] ; # Prg
  %28 = and i64 %22, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$16, label %$15
$16:
  br label %$14
$15:
  %30 = and i64 %22, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$18, label %$17
$18:
  %32 = inttoptr i64 %22 to i64*
  %33 = load i64, i64* %32
  br label %$14
$17:
  %34 = call i64 @evList(i64 %22)
  br label %$14
$14:
  %35 = phi i64 [%22, %$16], [%33, %$18], [%34, %$17] ; # ->
  br label %$12
$11:
  %36 = phi i64 [%24, %$10] ; # Prg
  %37 = and i64 %22, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$20, label %$19
$20:
  %39 = phi i64 [%36, %$11] ; # Prg
  %40 = call i64 @evList(i64 %22)
  %41 = icmp ne i64 %40, 0
  br label %$19
$19:
  %42 = phi i64 [%36, %$11], [%39, %$20] ; # Prg
  %43 = phi i1 [0, %$11], [%41, %$20] ; # ->
  br label %$10
$12:
  %44 = phi i64 [%27, %$14] ; # Prg
  %45 = phi i64 [%35, %$14] ; # ->
  br label %$9
$9:
  %46 = phi i64 [%17, %$7], [%18, %$12] ; # X
  %47 = phi i64 [%15, %$7], [%45, %$12] ; # ->
  ret i64 %47
}

define i64 @_unless(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (eval (++ X))) (run X) (set $At @) $Ni...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (eval (++ X))) (run X) (set $At @) $Nil)
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (nil? (eval (++ X)))
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$7, label %$8
$7:
  %17 = phi i64 [%7, %$2] ; # X
; # (run X)
  br label %$10
$10:
  %18 = phi i64 [%17, %$7], [%40, %$19] ; # Prg
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = getelementptr i64, i64* %19, i32 1
  %22 = load i64, i64* %21
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$13, label %$11
$13:
  %25 = phi i64 [%22, %$10] ; # Prg
  %26 = and i64 %20, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$16, label %$15
$16:
  br label %$14
$15:
  %28 = and i64 %20, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$18, label %$17
$18:
  %30 = inttoptr i64 %20 to i64*
  %31 = load i64, i64* %30
  br label %$14
$17:
  %32 = call i64 @evList(i64 %20)
  br label %$14
$14:
  %33 = phi i64 [%20, %$16], [%31, %$18], [%32, %$17] ; # ->
  br label %$12
$11:
  %34 = phi i64 [%22, %$10] ; # Prg
  %35 = and i64 %20, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$20, label %$19
$20:
  %37 = phi i64 [%34, %$11] ; # Prg
  %38 = call i64 @evList(i64 %20)
  %39 = icmp ne i64 %38, 0
  br label %$19
$19:
  %40 = phi i64 [%34, %$11], [%37, %$20] ; # Prg
  %41 = phi i1 [0, %$11], [%39, %$20] ; # ->
  br label %$10
$12:
  %42 = phi i64 [%25, %$14] ; # Prg
  %43 = phi i64 [%33, %$14] ; # ->
  br label %$9
$8:
  %44 = phi i64 [%7, %$2] ; # X
; # (set $At @)
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %15, i64* %45
  br label %$9
$9:
  %46 = phi i64 [%17, %$12], [%44, %$8] ; # X
  %47 = phi i64 [%43, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %47
}

define i64 @_cond(i64) {
$1:
; # (let X Exe (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (not...
; # (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (not (nil? (eva...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%54, %$11] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %2 = inttoptr i64 %1 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (atom (shift X))
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%4, %$2] ; # X
  br label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
; # (let Y (car X) (? (not (nil? (eval (car Y)))) (set $At @) (run (c...
; # (car X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (? (not (nil? (eval (car Y)))) (set $At @) (run (cdr Y)))
; # (car Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car Y))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  br label %$6
$7:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$9
$10:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$6
$9:
  %19 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %20 = phi i64 [%12, %$8], [%18, %$10], [%19, %$9] ; # ->
; # (nil? (eval (car Y)))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (car Y))))
  %22 = icmp eq i1 %21, 0
  br i1 %22, label %$12, label %$11
$12:
  %23 = phi i64 [%8, %$6] ; # X
; # (set $At @)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %20, i64* %24
; # (cdr Y)
  %25 = inttoptr i64 %10 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (run (cdr Y))
  br label %$13
$13:
  %28 = phi i64 [%27, %$12], [%50, %$22] ; # Prg
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  %31 = getelementptr i64, i64* %29, i32 1
  %32 = load i64, i64* %31
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$16, label %$14
$16:
  %35 = phi i64 [%32, %$13] ; # Prg
  %36 = and i64 %30, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$19, label %$18
$19:
  br label %$17
$18:
  %38 = and i64 %30, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$21, label %$20
$21:
  %40 = inttoptr i64 %30 to i64*
  %41 = load i64, i64* %40
  br label %$17
$20:
  %42 = call i64 @evList(i64 %30)
  br label %$17
$17:
  %43 = phi i64 [%30, %$19], [%41, %$21], [%42, %$20] ; # ->
  br label %$15
$14:
  %44 = phi i64 [%32, %$13] ; # Prg
  %45 = and i64 %30, 15
  %46 = icmp eq i64 %45, 0
  br i1 %46, label %$23, label %$22
$23:
  %47 = phi i64 [%44, %$14] ; # Prg
  %48 = call i64 @evList(i64 %30)
  %49 = icmp ne i64 %48, 0
  br label %$22
$22:
  %50 = phi i64 [%44, %$14], [%47, %$23] ; # Prg
  %51 = phi i1 [0, %$14], [%49, %$23] ; # ->
  br label %$13
$15:
  %52 = phi i64 [%35, %$17] ; # Prg
  %53 = phi i64 [%43, %$17] ; # ->
  br label %$4
$11:
  %54 = phi i64 [%8, %$6] ; # X
  br label %$2
$4:
  %55 = phi i64 [%7, %$5], [%23, %$15] ; # X
  %56 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%53, %$15] ; # ->
  ret i64 %56
}

define i64 @_nond(i64) {
$1:
; # (let X Exe (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (nil...
; # (loop (? (atom (shift X)) $Nil) (let Y (car X) (? (nil? (eval (ca...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%52, %$11] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %2 = inttoptr i64 %1 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (atom (shift X))
  %5 = and i64 %4, 15
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$5, label %$3
$5:
  %7 = phi i64 [%4, %$2] ; # X
  br label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
; # (let Y (car X) (? (nil? (eval (car Y))) (run (cdr Y))))
; # (car X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (? (nil? (eval (car Y))) (run (cdr Y)))
; # (car Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car Y))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  br label %$6
$7:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$9
$10:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$6
$9:
  %19 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %20 = phi i64 [%12, %$8], [%18, %$10], [%19, %$9] ; # ->
; # (nil? (eval (car Y)))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$12, label %$11
$12:
  %22 = phi i64 [%8, %$6] ; # X
; # (cdr Y)
  %23 = inttoptr i64 %10 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (run (cdr Y))
  br label %$13
$13:
  %26 = phi i64 [%25, %$12], [%48, %$22] ; # Prg
  %27 = inttoptr i64 %26 to i64*
  %28 = load i64, i64* %27
  %29 = getelementptr i64, i64* %27, i32 1
  %30 = load i64, i64* %29
  %31 = and i64 %30, 15
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$14
$16:
  %33 = phi i64 [%30, %$13] ; # Prg
  %34 = and i64 %28, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$19, label %$18
$19:
  br label %$17
$18:
  %36 = and i64 %28, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$21, label %$20
$21:
  %38 = inttoptr i64 %28 to i64*
  %39 = load i64, i64* %38
  br label %$17
$20:
  %40 = call i64 @evList(i64 %28)
  br label %$17
$17:
  %41 = phi i64 [%28, %$19], [%39, %$21], [%40, %$20] ; # ->
  br label %$15
$14:
  %42 = phi i64 [%30, %$13] ; # Prg
  %43 = and i64 %28, 15
  %44 = icmp eq i64 %43, 0
  br i1 %44, label %$23, label %$22
$23:
  %45 = phi i64 [%42, %$14] ; # Prg
  %46 = call i64 @evList(i64 %28)
  %47 = icmp ne i64 %46, 0
  br label %$22
$22:
  %48 = phi i64 [%42, %$14], [%45, %$23] ; # Prg
  %49 = phi i1 [0, %$14], [%47, %$23] ; # ->
  br label %$13
$15:
  %50 = phi i64 [%33, %$17] ; # Prg
  %51 = phi i64 [%41, %$17] ; # ->
  br label %$4
$11:
  %52 = phi i64 [%8, %$6] ; # X
; # (set $At @)
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %20, i64* %53
  br label %$2
$4:
  %54 = phi i64 [%7, %$5], [%22, %$15] ; # X
  %55 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%51, %$15] ; # ->
  ret i64 %55
}

define i64 @_case(i64) {
$1:
; # (let (X (cdr Exe) A (set $At (eval (car X)))) (loop (? (atom (shi...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set $At (eval (car X)))
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %13, i64* %14
; # (loop (? (atom (shift X)) $Nil) (let (Y (car X) Z (car Y)) (? (or...
  br label %$7
$7:
  %15 = phi i64 [%3, %$2], [%83, %$22] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %16 = inttoptr i64 %15 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (atom (shift X))
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$8
$10:
  %21 = phi i64 [%18, %$7] ; # X
  br label %$9
$8:
  %22 = phi i64 [%18, %$7] ; # X
; # (let (Y (car X) Z (car Y)) (? (or (t? Z) (if (atom Z) (equal Z A)...
; # (car X)
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (car Y)
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (? (or (t? Z) (if (atom Z) (equal Z A) (member A Z))) (run (cdr Y...
; # (or (t? Z) (if (atom Z) (equal Z A) (member A Z)))
; # (t? Z)
  %27 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %27, label %$11, label %$12
$12:
  %28 = phi i64 [%22, %$8] ; # X
; # (if (atom Z) (equal Z A) (member A Z))
; # (atom Z)
  %29 = and i64 %26, 15
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$13, label %$14
$13:
  %31 = phi i64 [%28, %$12] ; # X
; # (equal Z A)
  %32 = call i1 @equal(i64 %26, i64 %13)
  br label %$15
$14:
  %33 = phi i64 [%28, %$12] ; # X
; # (member A Z)
  br label %$16
$16:
  %34 = phi i64 [%26, %$14], [%46, %$20] ; # L
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$19, label %$17
$19:
  %37 = phi i64 [%34, %$16] ; # L
  br label %$18
$17:
  %38 = phi i64 [%34, %$16] ; # L
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
  %41 = call i1 @equal(i64 %13, i64 %40)
  br i1 %41, label %$21, label %$20
$21:
  %42 = phi i64 [%38, %$17] ; # L
  br label %$18
$20:
  %43 = phi i64 [%38, %$17] ; # L
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
  br label %$16
$18:
  %47 = phi i64 [%37, %$19], [%42, %$21] ; # L
  %48 = phi i1 [0, %$19], [1, %$21] ; # ->
  br label %$15
$15:
  %49 = phi i64 [%31, %$13], [%33, %$18] ; # X
  %50 = phi i1 [%32, %$13], [%48, %$18] ; # ->
  br label %$11
$11:
  %51 = phi i64 [%22, %$8], [%49, %$15] ; # X
  %52 = phi i1 [1, %$8], [%50, %$15] ; # ->
  br i1 %52, label %$23, label %$22
$23:
  %53 = phi i64 [%51, %$11] ; # X
; # (cdr Y)
  %54 = inttoptr i64 %24 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
; # (run (cdr Y))
  br label %$24
$24:
  %57 = phi i64 [%56, %$23], [%79, %$33] ; # Prg
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
  %60 = getelementptr i64, i64* %58, i32 1
  %61 = load i64, i64* %60
  %62 = and i64 %61, 15
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$27, label %$25
$27:
  %64 = phi i64 [%61, %$24] ; # Prg
  %65 = and i64 %59, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$30, label %$29
$30:
  br label %$28
$29:
  %67 = and i64 %59, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$32, label %$31
$32:
  %69 = inttoptr i64 %59 to i64*
  %70 = load i64, i64* %69
  br label %$28
$31:
  %71 = call i64 @evList(i64 %59)
  br label %$28
$28:
  %72 = phi i64 [%59, %$30], [%70, %$32], [%71, %$31] ; # ->
  br label %$26
$25:
  %73 = phi i64 [%61, %$24] ; # Prg
  %74 = and i64 %59, 15
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$34, label %$33
$34:
  %76 = phi i64 [%73, %$25] ; # Prg
  %77 = call i64 @evList(i64 %59)
  %78 = icmp ne i64 %77, 0
  br label %$33
$33:
  %79 = phi i64 [%73, %$25], [%76, %$34] ; # Prg
  %80 = phi i1 [0, %$25], [%78, %$34] ; # ->
  br label %$24
$26:
  %81 = phi i64 [%64, %$28] ; # Prg
  %82 = phi i64 [%72, %$28] ; # ->
  br label %$9
$22:
  %83 = phi i64 [%51, %$11] ; # X
  br label %$7
$9:
  %84 = phi i64 [%21, %$10], [%53, %$26] ; # X
  %85 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [%82, %$26] ; # ->
  ret i64 %85
}

define i64 @_casq(i64) {
$1:
; # (let (X (cdr Exe) A (set $At (eval (car X)))) (loop (? (atom (shi...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set $At (eval (car X)))
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %13, i64* %14
; # (loop (? (atom (shift X)) $Nil) (let (Y (car X) Z (car Y)) (? (or...
  br label %$7
$7:
  %15 = phi i64 [%3, %$2], [%78, %$20] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %16 = inttoptr i64 %15 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (atom (shift X))
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$10, label %$8
$10:
  %21 = phi i64 [%18, %$7] ; # X
  br label %$9
$8:
  %22 = phi i64 [%18, %$7] ; # X
; # (let (Y (car X) Z (car Y)) (? (or (t? Z) (== Z A) (memq A Z)) (ru...
; # (car X)
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (car Y)
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (? (or (t? Z) (== Z A) (memq A Z)) (run (cdr Y)))
; # (or (t? Z) (== Z A) (memq A Z))
; # (t? Z)
  %27 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %27, label %$11, label %$12
$12:
  %28 = phi i64 [%22, %$8] ; # X
; # (== Z A)
  %29 = icmp eq i64 %26, %13
  br i1 %29, label %$11, label %$13
$13:
  %30 = phi i64 [%28, %$12] ; # X
; # (memq A Z)
  br label %$14
$14:
  %31 = phi i64 [%26, %$13], [%43, %$18] ; # L
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$15
$17:
  %34 = phi i64 [%31, %$14] ; # L
  br label %$16
$15:
  %35 = phi i64 [%31, %$14] ; # L
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
  %38 = icmp eq i64 %13, %37
  br i1 %38, label %$19, label %$18
$19:
  %39 = phi i64 [%35, %$15] ; # L
  br label %$16
$18:
  %40 = phi i64 [%35, %$15] ; # L
  %41 = inttoptr i64 %40 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
  br label %$14
$16:
  %44 = phi i64 [%34, %$17], [%39, %$19] ; # L
  %45 = phi i1 [0, %$17], [1, %$19] ; # ->
  br label %$11
$11:
  %46 = phi i64 [%22, %$8], [%28, %$12], [%30, %$16] ; # X
  %47 = phi i1 [1, %$8], [1, %$12], [%45, %$16] ; # ->
  br i1 %47, label %$21, label %$20
$21:
  %48 = phi i64 [%46, %$11] ; # X
; # (cdr Y)
  %49 = inttoptr i64 %24 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (run (cdr Y))
  br label %$22
$22:
  %52 = phi i64 [%51, %$21], [%74, %$31] ; # Prg
  %53 = inttoptr i64 %52 to i64*
  %54 = load i64, i64* %53
  %55 = getelementptr i64, i64* %53, i32 1
  %56 = load i64, i64* %55
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$25, label %$23
$25:
  %59 = phi i64 [%56, %$22] ; # Prg
  %60 = and i64 %54, 6
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$28, label %$27
$28:
  br label %$26
$27:
  %62 = and i64 %54, 8
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$30, label %$29
$30:
  %64 = inttoptr i64 %54 to i64*
  %65 = load i64, i64* %64
  br label %$26
$29:
  %66 = call i64 @evList(i64 %54)
  br label %$26
$26:
  %67 = phi i64 [%54, %$28], [%65, %$30], [%66, %$29] ; # ->
  br label %$24
$23:
  %68 = phi i64 [%56, %$22] ; # Prg
  %69 = and i64 %54, 15
  %70 = icmp eq i64 %69, 0
  br i1 %70, label %$32, label %$31
$32:
  %71 = phi i64 [%68, %$23] ; # Prg
  %72 = call i64 @evList(i64 %54)
  %73 = icmp ne i64 %72, 0
  br label %$31
$31:
  %74 = phi i64 [%68, %$23], [%71, %$32] ; # Prg
  %75 = phi i1 [0, %$23], [%73, %$32] ; # ->
  br label %$22
$24:
  %76 = phi i64 [%59, %$26] ; # Prg
  %77 = phi i64 [%67, %$26] ; # ->
  br label %$9
$20:
  %78 = phi i64 [%46, %$11] ; # X
  br label %$7
$9:
  %79 = phi i64 [%21, %$10], [%48, %$24] ; # X
  %80 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [%77, %$24] ; # ->
  ret i64 %80
}

define i64 @_state(i64) {
$1:
; # (let (X (cdr Exe) Var (save (needChkVar Exe (eval (car X))))) (lo...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needChkVar Exe (eval (car X)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = icmp uge i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$10, label %$9
$10:
  %17 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %13
  br label %$9
$9:
  %18 = phi i1 [0, %$8], [%17, %$10] ; # ->
  br i1 %18, label %$11, label %$12
$11:
  call void @protErr(i64 %0, i64 %13)
  unreachable
$12:
; # (save (needChkVar Exe (eval (car X))))
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %13, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (loop (? (atom (shift X)) $Nil) (let (Y (car X) Z (car Y)) (when ...
  br label %$13
$13:
  %27 = phi i64 [%3, %$12], [%120, %$28] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %28 = inttoptr i64 %27 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (atom (shift X))
  %31 = and i64 %30, 15
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$14
$16:
  %33 = phi i64 [%30, %$13] ; # X
  br label %$15
$14:
  %34 = phi i64 [%30, %$13] ; # X
; # (let (Y (car X) Z (car Y)) (when (or (t? Z) (let V (val Var) (or ...
; # (car X)
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (car Y)
  %37 = inttoptr i64 %36 to i64*
  %38 = load i64, i64* %37
; # (when (or (t? Z) (let V (val Var) (or (== Z V) (memq V Z)))) (? (...
; # (or (t? Z) (let V (val Var) (or (== Z V) (memq V Z))))
; # (t? Z)
  %39 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %39, label %$17, label %$18
$18:
  %40 = phi i64 [%34, %$14] ; # X
  %41 = phi i64 [%36, %$14] ; # Y
; # (let V (val Var) (or (== Z V) (memq V Z)))
; # (val Var)
  %42 = inttoptr i64 %13 to i64*
  %43 = load i64, i64* %42
; # (or (== Z V) (memq V Z))
; # (== Z V)
  %44 = icmp eq i64 %38, %43
  br i1 %44, label %$19, label %$20
$20:
  %45 = phi i64 [%40, %$18] ; # X
  %46 = phi i64 [%41, %$18] ; # Y
; # (memq V Z)
  br label %$21
$21:
  %47 = phi i64 [%38, %$20], [%59, %$25] ; # L
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$24, label %$22
$24:
  %50 = phi i64 [%47, %$21] ; # L
  br label %$23
$22:
  %51 = phi i64 [%47, %$21] ; # L
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
  %54 = icmp eq i64 %43, %53
  br i1 %54, label %$26, label %$25
$26:
  %55 = phi i64 [%51, %$22] ; # L
  br label %$23
$25:
  %56 = phi i64 [%51, %$22] ; # L
  %57 = inttoptr i64 %56 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  br label %$21
$23:
  %60 = phi i64 [%50, %$24], [%55, %$26] ; # L
  %61 = phi i1 [0, %$24], [1, %$26] ; # ->
  br label %$19
$19:
  %62 = phi i64 [%40, %$18], [%45, %$23] ; # X
  %63 = phi i64 [%41, %$18], [%46, %$23] ; # Y
  %64 = phi i1 [1, %$18], [%61, %$23] ; # ->
  br label %$17
$17:
  %65 = phi i64 [%34, %$14], [%62, %$19] ; # X
  %66 = phi i64 [%36, %$14], [%63, %$19] ; # Y
  %67 = phi i1 [1, %$14], [%64, %$19] ; # ->
  br i1 %67, label %$27, label %$28
$27:
  %68 = phi i64 [%65, %$17] ; # X
  %69 = phi i64 [%66, %$17] ; # Y
; # (? (not (nil? (eval (car (shift Y))))) (set Var (set $At @)) (run...
; # (shift Y)
  %70 = inttoptr i64 %69 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
; # (car (shift Y))
  %73 = inttoptr i64 %72 to i64*
  %74 = load i64, i64* %73
; # (eval (car (shift Y)))
  %75 = and i64 %74, 6
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$31, label %$30
$31:
  br label %$29
$30:
  %77 = and i64 %74, 8
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %$33, label %$32
$33:
  %79 = inttoptr i64 %74 to i64*
  %80 = load i64, i64* %79
  br label %$29
$32:
  %81 = call i64 @evList(i64 %74)
  br label %$29
$29:
  %82 = phi i64 [%74, %$31], [%80, %$33], [%81, %$32] ; # ->
; # (nil? (eval (car (shift Y))))
  %83 = icmp eq i64 %82, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (car (shift Y)))))
  %84 = icmp eq i1 %83, 0
  br i1 %84, label %$35, label %$34
$35:
  %85 = phi i64 [%68, %$29] ; # X
  %86 = phi i64 [%72, %$29] ; # Y
; # (set Var (set $At @))
; # (set $At @)
  %87 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %82, i64* %87
  %88 = inttoptr i64 %13 to i64*
  store i64 %82, i64* %88
; # (cdr Y)
  %89 = inttoptr i64 %86 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  %91 = load i64, i64* %90
; # (run (cdr Y))
  br label %$36
$36:
  %92 = phi i64 [%91, %$35], [%114, %$45] ; # Prg
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
  %95 = getelementptr i64, i64* %93, i32 1
  %96 = load i64, i64* %95
  %97 = and i64 %96, 15
  %98 = icmp ne i64 %97, 0
  br i1 %98, label %$39, label %$37
$39:
  %99 = phi i64 [%96, %$36] ; # Prg
  %100 = and i64 %94, 6
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$42, label %$41
$42:
  br label %$40
$41:
  %102 = and i64 %94, 8
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$44, label %$43
$44:
  %104 = inttoptr i64 %94 to i64*
  %105 = load i64, i64* %104
  br label %$40
$43:
  %106 = call i64 @evList(i64 %94)
  br label %$40
$40:
  %107 = phi i64 [%94, %$42], [%105, %$44], [%106, %$43] ; # ->
  br label %$38
$37:
  %108 = phi i64 [%96, %$36] ; # Prg
  %109 = and i64 %94, 15
  %110 = icmp eq i64 %109, 0
  br i1 %110, label %$46, label %$45
$46:
  %111 = phi i64 [%108, %$37] ; # Prg
  %112 = call i64 @evList(i64 %94)
  %113 = icmp ne i64 %112, 0
  br label %$45
$45:
  %114 = phi i64 [%108, %$37], [%111, %$46] ; # Prg
  %115 = phi i1 [0, %$37], [%113, %$46] ; # ->
  br label %$36
$38:
  %116 = phi i64 [%99, %$40] ; # Prg
  %117 = phi i64 [%107, %$40] ; # ->
  br label %$15
$34:
  %118 = phi i64 [%68, %$29] ; # X
  %119 = phi i64 [%72, %$29] ; # Y
  br label %$28
$28:
  %120 = phi i64 [%65, %$17], [%118, %$34] ; # X
  %121 = phi i64 [%66, %$17], [%119, %$34] ; # Y
  br label %$13
$15:
  %122 = phi i64 [%33, %$16], [%85, %$38] ; # X
  %123 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%117, %$38] ; # ->
; # (drop *Safe)
  %124 = inttoptr i64 %20 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
  %127 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %126, i64* %127
  ret i64 %123
}

define i64 @_while(i64) {
$1:
; # (let (X (cdr Exe) E (++ X) R (save $Nil)) (until (nil? (eval E)) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (save $Nil)
  %8 = alloca i64, i64 2, align 16
  %9 = ptrtoint i64* %8 to i64
  %10 = inttoptr i64 %9 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %12 = load i64, i64* %11
  %13 = inttoptr i64 %9 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  store i64 %12, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %9, i64* %15
; # (until (nil? (eval E)) (set $At @) (setq R (safe (run X))))
  br label %$2
$2:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%53, %$12] ; # R
; # (eval E)
  %17 = and i64 %5, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %5, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %5 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %24 = phi i64 [%5, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (nil? (eval E))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %25, label %$9, label %$8
$8:
  %26 = phi i64 [%16, %$3] ; # R
; # (set $At @)
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %24, i64* %27
; # (run X)
  br label %$10
$10:
  %28 = phi i64 [%7, %$8], [%50, %$19] ; # Prg
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
  %31 = getelementptr i64, i64* %29, i32 1
  %32 = load i64, i64* %31
  %33 = and i64 %32, 15
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$11
$13:
  %35 = phi i64 [%32, %$10] ; # Prg
  %36 = and i64 %30, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$16, label %$15
$16:
  br label %$14
$15:
  %38 = and i64 %30, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$18, label %$17
$18:
  %40 = inttoptr i64 %30 to i64*
  %41 = load i64, i64* %40
  br label %$14
$17:
  %42 = call i64 @evList(i64 %30)
  br label %$14
$14:
  %43 = phi i64 [%30, %$16], [%41, %$18], [%42, %$17] ; # ->
  br label %$12
$11:
  %44 = phi i64 [%32, %$10] ; # Prg
  %45 = and i64 %30, 15
  %46 = icmp eq i64 %45, 0
  br i1 %46, label %$20, label %$19
$20:
  %47 = phi i64 [%44, %$11] ; # Prg
  %48 = call i64 @evList(i64 %30)
  %49 = icmp ne i64 %48, 0
  br label %$19
$19:
  %50 = phi i64 [%44, %$11], [%47, %$20] ; # Prg
  %51 = phi i1 [0, %$11], [%49, %$20] ; # ->
  br label %$10
$12:
  %52 = phi i64 [%35, %$14] ; # Prg
  %53 = phi i64 [%43, %$14] ; # ->
; # (safe (run X))
  %54 = inttoptr i64 %9 to i64*
  store i64 %53, i64* %54
  br label %$2
$9:
  %55 = phi i64 [%16, %$3] ; # R
; # (drop *Safe)
  %56 = inttoptr i64 %9 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %55
}

define i64 @_until(i64) {
$1:
; # (let (X (cdr Exe) E (++ X) R (save $Nil)) (while (nil? (eval E)) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (save $Nil)
  %8 = alloca i64, i64 2, align 16
  %9 = ptrtoint i64* %8 to i64
  %10 = inttoptr i64 %9 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %12 = load i64, i64* %11
  %13 = inttoptr i64 %9 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  store i64 %12, i64* %14
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %9, i64* %15
; # (while (nil? (eval E)) (setq R (safe (run X))))
  br label %$2
$2:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1], [%52, %$12] ; # R
; # (eval E)
  %17 = and i64 %5, 6
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$5, label %$4
$5:
  br label %$3
$4:
  %19 = and i64 %5, 8
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$7, label %$6
$7:
  %21 = inttoptr i64 %5 to i64*
  %22 = load i64, i64* %21
  br label %$3
$6:
  %23 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %24 = phi i64 [%5, %$5], [%22, %$7], [%23, %$6] ; # ->
; # (nil? (eval E))
  %25 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %25, label %$8, label %$9
$8:
  %26 = phi i64 [%16, %$3] ; # R
; # (run X)
  br label %$10
$10:
  %27 = phi i64 [%7, %$8], [%49, %$19] ; # Prg
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
  %30 = getelementptr i64, i64* %28, i32 1
  %31 = load i64, i64* %30
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$11
$13:
  %34 = phi i64 [%31, %$10] ; # Prg
  %35 = and i64 %29, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$16, label %$15
$16:
  br label %$14
$15:
  %37 = and i64 %29, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$18, label %$17
$18:
  %39 = inttoptr i64 %29 to i64*
  %40 = load i64, i64* %39
  br label %$14
$17:
  %41 = call i64 @evList(i64 %29)
  br label %$14
$14:
  %42 = phi i64 [%29, %$16], [%40, %$18], [%41, %$17] ; # ->
  br label %$12
$11:
  %43 = phi i64 [%31, %$10] ; # Prg
  %44 = and i64 %29, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$20, label %$19
$20:
  %46 = phi i64 [%43, %$11] ; # Prg
  %47 = call i64 @evList(i64 %29)
  %48 = icmp ne i64 %47, 0
  br label %$19
$19:
  %49 = phi i64 [%43, %$11], [%46, %$20] ; # Prg
  %50 = phi i1 [0, %$11], [%48, %$20] ; # ->
  br label %$10
$12:
  %51 = phi i64 [%34, %$14] ; # Prg
  %52 = phi i64 [%42, %$14] ; # ->
; # (safe (run X))
  %53 = inttoptr i64 %9 to i64*
  store i64 %52, i64* %53
  br label %$2
$9:
  %54 = phi i64 [%16, %$3] ; # R
; # (set $At @)
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %24, i64* %55
; # (drop *Safe)
  %56 = inttoptr i64 %9 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %54
}

define i64 @_at(i64) {
$1:
; # (let (X (cdr Exe) Y (needPair Exe (eval (car X))) Z (cdr Y)) (con...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (needPair Exe (eval (car X)))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @pairErr(i64 %0, i64 %13)
  unreachable
$8:
; # (cdr Y)
  %16 = inttoptr i64 %13 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (cond ((nil? Z) @) ((< (+ (car Y) (hex "10")) Z) (set Y @) $Nil) ...
; # (nil? Z)
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %19, label %$11, label %$10
$11:
  br label %$9
$10:
; # (car Y)
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
; # (+ (car Y) (hex "10"))
  %22 = add i64 %21, 16
; # (< (+ (car Y) (hex "10")) Z)
  %23 = icmp ult i64 %22, %18
  br i1 %23, label %$13, label %$12
$13:
; # (set Y @)
  %24 = inttoptr i64 %13 to i64*
  store i64 %22, i64* %24
  br label %$9
$12:
; # (set Y ZERO)
  %25 = inttoptr i64 %13 to i64*
  store i64 2, i64* %25
; # (cdr X)
  %26 = inttoptr i64 %3 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (run (cdr X))
  br label %$14
$14:
  %29 = phi i64 [%28, %$12], [%51, %$23] ; # Prg
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
  %32 = getelementptr i64, i64* %30, i32 1
  %33 = load i64, i64* %32
  %34 = and i64 %33, 15
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$17, label %$15
$17:
  %36 = phi i64 [%33, %$14] ; # Prg
  %37 = and i64 %31, 6
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$20, label %$19
$20:
  br label %$18
$19:
  %39 = and i64 %31, 8
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$22, label %$21
$22:
  %41 = inttoptr i64 %31 to i64*
  %42 = load i64, i64* %41
  br label %$18
$21:
  %43 = call i64 @evList(i64 %31)
  br label %$18
$18:
  %44 = phi i64 [%31, %$20], [%42, %$22], [%43, %$21] ; # ->
  br label %$16
$15:
  %45 = phi i64 [%33, %$14] ; # Prg
  %46 = and i64 %31, 15
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %$24, label %$23
$24:
  %48 = phi i64 [%45, %$15] ; # Prg
  %49 = call i64 @evList(i64 %31)
  %50 = icmp ne i64 %49, 0
  br label %$23
$23:
  %51 = phi i64 [%45, %$15], [%48, %$24] ; # Prg
  %52 = phi i1 [0, %$15], [%50, %$24] ; # ->
  br label %$14
$16:
  %53 = phi i64 [%36, %$18] ; # Prg
  %54 = phi i64 [%44, %$18] ; # ->
  br label %$9
$9:
  %55 = phi i64 [%18, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%54, %$16] ; # ->
  ret i64 %55
}

define i64 @loop1(i64) {
$1:
; # (loop (let E (car X) (unless (num? E) (setq E (cond ((sym? E) (va...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%141, %$49] ; # X
; # (let E (car X) (unless (num? E) (setq E (cond ((sym? E) (val E)) ...
; # (car X)
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (unless (num? E) (setq E (cond ((sym? E) (val E)) ((nil? (car E))...
; # (num? E)
  %4 = and i64 %3, 6
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$4, label %$3
$3:
  %6 = phi i64 [%1, %$2] ; # X
  %7 = phi i64 [%3, %$2] ; # E
; # (cond ((sym? E) (val E)) ((nil? (car E)) (? (nil? (eval (car (shi...
; # (sym? E)
  %8 = and i64 %7, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = phi i64 [%6, %$3] ; # X
  %11 = phi i64 [%7, %$3] ; # E
; # (val E)
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
  br label %$5
$6:
  %14 = phi i64 [%6, %$3] ; # X
  %15 = phi i64 [%7, %$3] ; # E
; # (car E)
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (nil? (car E))
  %18 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$9, label %$8
$9:
  %19 = phi i64 [%14, %$6] ; # X
  %20 = phi i64 [%15, %$6] ; # E
; # (? (nil? (eval (car (shift E)))) (run (cdr E)))
; # (shift E)
  %21 = inttoptr i64 %20 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (car (shift E))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
; # (eval (car (shift E)))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$12, label %$11
$12:
  br label %$10
$11:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$14, label %$13
$14:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$10
$13:
  %32 = call i64 @evList(i64 %25)
  br label %$10
$10:
  %33 = phi i64 [%25, %$12], [%31, %$14], [%32, %$13] ; # ->
; # (nil? (eval (car (shift E))))
  %34 = icmp eq i64 %33, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %34, label %$17, label %$15
$17:
  %35 = phi i64 [%19, %$10] ; # X
  %36 = phi i64 [%23, %$10] ; # E
; # (cdr E)
  %37 = inttoptr i64 %36 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (run (cdr E))
  br label %$18
$18:
  %40 = phi i64 [%39, %$17], [%62, %$27] ; # Prg
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = getelementptr i64, i64* %41, i32 1
  %44 = load i64, i64* %43
  %45 = and i64 %44, 15
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$21, label %$19
$21:
  %47 = phi i64 [%44, %$18] ; # Prg
  %48 = and i64 %42, 6
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$24, label %$23
$24:
  br label %$22
$23:
  %50 = and i64 %42, 8
  %51 = icmp ne i64 %50, 0
  br i1 %51, label %$26, label %$25
$26:
  %52 = inttoptr i64 %42 to i64*
  %53 = load i64, i64* %52
  br label %$22
$25:
  %54 = call i64 @evList(i64 %42)
  br label %$22
$22:
  %55 = phi i64 [%42, %$24], [%53, %$26], [%54, %$25] ; # ->
  br label %$20
$19:
  %56 = phi i64 [%44, %$18] ; # Prg
  %57 = and i64 %42, 15
  %58 = icmp eq i64 %57, 0
  br i1 %58, label %$28, label %$27
$28:
  %59 = phi i64 [%56, %$19] ; # Prg
  %60 = call i64 @evList(i64 %42)
  %61 = icmp ne i64 %60, 0
  br label %$27
$27:
  %62 = phi i64 [%56, %$19], [%59, %$28] ; # Prg
  %63 = phi i1 [0, %$19], [%61, %$28] ; # ->
  br label %$18
$20:
  %64 = phi i64 [%47, %$22] ; # Prg
  %65 = phi i64 [%55, %$22] ; # ->
  br label %$16
$15:
  %66 = phi i64 [%19, %$10] ; # X
  %67 = phi i64 [%23, %$10] ; # E
; # (set $At @)
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %33, i64* %68
  br label %$5
$8:
  %69 = phi i64 [%14, %$6] ; # X
  %70 = phi i64 [%15, %$6] ; # E
; # (car E)
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
; # (t? (car E))
  %73 = icmp eq i64 %72, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %73, label %$30, label %$29
$30:
  %74 = phi i64 [%69, %$8] ; # X
  %75 = phi i64 [%70, %$8] ; # E
; # (? (not (nil? (eval (car (shift E))))) (set $At @) (run (cdr E)))...
; # (shift E)
  %76 = inttoptr i64 %75 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (car (shift E))
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
; # (eval (car (shift E)))
  %81 = and i64 %80, 6
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$33, label %$32
$33:
  br label %$31
$32:
  %83 = and i64 %80, 8
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$35, label %$34
$35:
  %85 = inttoptr i64 %80 to i64*
  %86 = load i64, i64* %85
  br label %$31
$34:
  %87 = call i64 @evList(i64 %80)
  br label %$31
$31:
  %88 = phi i64 [%80, %$33], [%86, %$35], [%87, %$34] ; # ->
; # (nil? (eval (car (shift E))))
  %89 = icmp eq i64 %88, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (car (shift E)))))
  %90 = icmp eq i1 %89, 0
  br i1 %90, label %$37, label %$36
$37:
  %91 = phi i64 [%74, %$31] ; # X
  %92 = phi i64 [%78, %$31] ; # E
; # (set $At @)
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %88, i64* %93
; # (cdr E)
  %94 = inttoptr i64 %92 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
; # (run (cdr E))
  br label %$38
$38:
  %97 = phi i64 [%96, %$37], [%119, %$47] ; # Prg
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
  %100 = getelementptr i64, i64* %98, i32 1
  %101 = load i64, i64* %100
  %102 = and i64 %101, 15
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$41, label %$39
$41:
  %104 = phi i64 [%101, %$38] ; # Prg
  %105 = and i64 %99, 6
  %106 = icmp ne i64 %105, 0
  br i1 %106, label %$44, label %$43
$44:
  br label %$42
$43:
  %107 = and i64 %99, 8
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$46, label %$45
$46:
  %109 = inttoptr i64 %99 to i64*
  %110 = load i64, i64* %109
  br label %$42
$45:
  %111 = call i64 @evList(i64 %99)
  br label %$42
$42:
  %112 = phi i64 [%99, %$44], [%110, %$46], [%111, %$45] ; # ->
  br label %$40
$39:
  %113 = phi i64 [%101, %$38] ; # Prg
  %114 = and i64 %99, 15
  %115 = icmp eq i64 %114, 0
  br i1 %115, label %$48, label %$47
$48:
  %116 = phi i64 [%113, %$39] ; # Prg
  %117 = call i64 @evList(i64 %99)
  %118 = icmp ne i64 %117, 0
  br label %$47
$47:
  %119 = phi i64 [%113, %$39], [%116, %$48] ; # Prg
  %120 = phi i1 [0, %$39], [%118, %$48] ; # ->
  br label %$38
$40:
  %121 = phi i64 [%104, %$42] ; # Prg
  %122 = phi i64 [%112, %$42] ; # ->
  br label %$16
$36:
  %123 = phi i64 [%74, %$31] ; # X
  %124 = phi i64 [%78, %$31] ; # E
  br label %$5
$29:
  %125 = phi i64 [%69, %$8] ; # X
  %126 = phi i64 [%70, %$8] ; # E
; # (evList E)
  %127 = call i64 @evList(i64 %126)
  br label %$5
$5:
  %128 = phi i64 [%10, %$7], [%66, %$15], [%123, %$36], [%125, %$29] ; # X
  %129 = phi i64 [%11, %$7], [%67, %$15], [%124, %$36], [%126, %$29] ; # E
  %130 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%88, %$36], [%127, %$29] ; # ->
  br label %$4
$4:
  %131 = phi i64 [%1, %$2], [%128, %$5] ; # X
  %132 = phi i64 [%3, %$2], [%130, %$5] ; # E
; # (? (atom (shift X)) (| E 1))
; # (shift X)
  %133 = inttoptr i64 %131 to i64*
  %134 = getelementptr i64, i64* %133, i32 1
  %135 = load i64, i64* %134
; # (atom (shift X))
  %136 = and i64 %135, 15
  %137 = icmp ne i64 %136, 0
  br i1 %137, label %$50, label %$49
$50:
  %138 = phi i64 [%135, %$4] ; # X
  %139 = phi i64 [%132, %$4] ; # E
; # (| E 1)
  %140 = or i64 %139, 1
  br label %$16
$49:
  %141 = phi i64 [%135, %$4] ; # X
  %142 = phi i64 [%132, %$4] ; # E
  br label %$2
$16:
  %143 = phi i64 [%35, %$20], [%91, %$40], [%138, %$50] ; # X
  %144 = phi i64 [%65, %$20], [%122, %$40], [%140, %$50] ; # ->
  ret i64 %144
}

define i64 @loop2(i64) {
$1:
; # (loop (let X Y (loop (let E (car X) (when (pair E) (cond ((nil? (...
  br label %$2
$2:
; # (let X Y (loop (let E (car X) (when (pair E) (cond ((nil? (car E)...
; # (loop (let E (car X) (when (pair E) (cond ((nil? (car E)) (when (...
  br label %$3
$3:
  %1 = phi i64 [%0, %$2], [%128, %$47] ; # X
; # (let E (car X) (when (pair E) (cond ((nil? (car E)) (when (nil? (...
; # (car X)
  %2 = inttoptr i64 %1 to i64*
  %3 = load i64, i64* %2
; # (when (pair E) (cond ((nil? (car E)) (when (nil? (eval (car (shif...
; # (pair E)
  %4 = and i64 %3, 15
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$4, label %$5
$4:
  %6 = phi i64 [%1, %$3] ; # X
  %7 = phi i64 [%3, %$3] ; # E
; # (cond ((nil? (car E)) (when (nil? (eval (car (shift E)))) (ret (r...
; # (car E)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (nil? (car E))
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$8, label %$7
$8:
  %11 = phi i64 [%6, %$4] ; # X
  %12 = phi i64 [%7, %$4] ; # E
; # (when (nil? (eval (car (shift E)))) (ret (run (cdr E))))
; # (shift E)
  %13 = inttoptr i64 %12 to i64*
  %14 = getelementptr i64, i64* %13, i32 1
  %15 = load i64, i64* %14
; # (car (shift E))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (eval (car (shift E)))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
  br label %$9
$10:
  %20 = and i64 %17, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$13, label %$12
$13:
  %22 = inttoptr i64 %17 to i64*
  %23 = load i64, i64* %22
  br label %$9
$12:
  %24 = call i64 @evList(i64 %17)
  br label %$9
$9:
  %25 = phi i64 [%17, %$11], [%23, %$13], [%24, %$12] ; # ->
; # (nil? (eval (car (shift E))))
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %26, label %$14, label %$15
$14:
  %27 = phi i64 [%11, %$9] ; # X
  %28 = phi i64 [%15, %$9] ; # E
; # (cdr E)
  %29 = inttoptr i64 %28 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (run (cdr E))
  br label %$16
$16:
  %32 = phi i64 [%31, %$14], [%54, %$25] ; # Prg
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = getelementptr i64, i64* %33, i32 1
  %36 = load i64, i64* %35
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$19, label %$17
$19:
  %39 = phi i64 [%36, %$16] ; # Prg
  %40 = and i64 %34, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$22, label %$21
$22:
  br label %$20
$21:
  %42 = and i64 %34, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$24, label %$23
$24:
  %44 = inttoptr i64 %34 to i64*
  %45 = load i64, i64* %44
  br label %$20
$23:
  %46 = call i64 @evList(i64 %34)
  br label %$20
$20:
  %47 = phi i64 [%34, %$22], [%45, %$24], [%46, %$23] ; # ->
  br label %$18
$17:
  %48 = phi i64 [%36, %$16] ; # Prg
  %49 = and i64 %34, 15
  %50 = icmp eq i64 %49, 0
  br i1 %50, label %$26, label %$25
$26:
  %51 = phi i64 [%48, %$17] ; # Prg
  %52 = call i64 @evList(i64 %34)
  %53 = icmp ne i64 %52, 0
  br label %$25
$25:
  %54 = phi i64 [%48, %$17], [%51, %$26] ; # Prg
  %55 = phi i1 [0, %$17], [%53, %$26] ; # ->
  br label %$16
$18:
  %56 = phi i64 [%39, %$20] ; # Prg
  %57 = phi i64 [%47, %$20] ; # ->
; # (ret (run (cdr E)))
  ret i64 %57
$15:
  %58 = phi i64 [%11, %$9] ; # X
  %59 = phi i64 [%15, %$9] ; # E
; # (set $At @)
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %25, i64* %60
  br label %$6
$7:
  %61 = phi i64 [%6, %$4] ; # X
  %62 = phi i64 [%7, %$4] ; # E
; # (car E)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (t? (car E))
  %65 = icmp eq i64 %64, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %65, label %$28, label %$27
$28:
  %66 = phi i64 [%61, %$7] ; # X
  %67 = phi i64 [%62, %$7] ; # E
; # (unless (nil? (eval (car (shift E)))) (set $At @) (ret (run (cdr ...
; # (shift E)
  %68 = inttoptr i64 %67 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  %70 = load i64, i64* %69
; # (car (shift E))
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
; # (eval (car (shift E)))
  %73 = and i64 %72, 6
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$31, label %$30
$31:
  br label %$29
$30:
  %75 = and i64 %72, 8
  %76 = icmp ne i64 %75, 0
  br i1 %76, label %$33, label %$32
$33:
  %77 = inttoptr i64 %72 to i64*
  %78 = load i64, i64* %77
  br label %$29
$32:
  %79 = call i64 @evList(i64 %72)
  br label %$29
$29:
  %80 = phi i64 [%72, %$31], [%78, %$33], [%79, %$32] ; # ->
; # (nil? (eval (car (shift E))))
  %81 = icmp eq i64 %80, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %81, label %$35, label %$34
$34:
  %82 = phi i64 [%66, %$29] ; # X
  %83 = phi i64 [%70, %$29] ; # E
; # (set $At @)
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %80, i64* %84
; # (cdr E)
  %85 = inttoptr i64 %83 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  %87 = load i64, i64* %86
; # (run (cdr E))
  br label %$36
$36:
  %88 = phi i64 [%87, %$34], [%110, %$45] ; # Prg
  %89 = inttoptr i64 %88 to i64*
  %90 = load i64, i64* %89
  %91 = getelementptr i64, i64* %89, i32 1
  %92 = load i64, i64* %91
  %93 = and i64 %92, 15
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$39, label %$37
$39:
  %95 = phi i64 [%92, %$36] ; # Prg
  %96 = and i64 %90, 6
  %97 = icmp ne i64 %96, 0
  br i1 %97, label %$42, label %$41
$42:
  br label %$40
$41:
  %98 = and i64 %90, 8
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$44, label %$43
$44:
  %100 = inttoptr i64 %90 to i64*
  %101 = load i64, i64* %100
  br label %$40
$43:
  %102 = call i64 @evList(i64 %90)
  br label %$40
$40:
  %103 = phi i64 [%90, %$42], [%101, %$44], [%102, %$43] ; # ->
  br label %$38
$37:
  %104 = phi i64 [%92, %$36] ; # Prg
  %105 = and i64 %90, 15
  %106 = icmp eq i64 %105, 0
  br i1 %106, label %$46, label %$45
$46:
  %107 = phi i64 [%104, %$37] ; # Prg
  %108 = call i64 @evList(i64 %90)
  %109 = icmp ne i64 %108, 0
  br label %$45
$45:
  %110 = phi i64 [%104, %$37], [%107, %$46] ; # Prg
  %111 = phi i1 [0, %$37], [%109, %$46] ; # ->
  br label %$36
$38:
  %112 = phi i64 [%95, %$40] ; # Prg
  %113 = phi i64 [%103, %$40] ; # ->
; # (ret (run (cdr E)))
  ret i64 %113
$35:
  %114 = phi i64 [%66, %$29] ; # X
  %115 = phi i64 [%70, %$29] ; # E
  br label %$6
$27:
  %116 = phi i64 [%61, %$7] ; # X
  %117 = phi i64 [%62, %$7] ; # E
; # (evList E)
  %118 = call i64 @evList(i64 %117)
  br label %$6
$6:
  %119 = phi i64 [%58, %$15], [%114, %$35], [%116, %$27] ; # X
  %120 = phi i64 [%59, %$15], [%115, %$35], [%117, %$27] ; # E
  br label %$5
$5:
  %121 = phi i64 [%1, %$3], [%119, %$6] ; # X
  %122 = phi i64 [%3, %$3], [%120, %$6] ; # E
; # (? (atom (shift X)))
; # (shift X)
  %123 = inttoptr i64 %121 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
; # (atom (shift X))
  %126 = and i64 %125, 15
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$48, label %$47
$47:
  %128 = phi i64 [%125, %$5] ; # X
  br label %$3
$48:
  %129 = phi i64 [%125, %$5] ; # X
  %130 = phi i64 [0, %$5] ; # ->
  br label %$2
}

define i64 @_do(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((nil? Y) Y) ((cnt? Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((nil? Y) Y) ((cnt? Y) (let N (int Y) (if (or (sign? Y) (=0...
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  br label %$7
$8:
; # (cnt? Y)
  %17 = and i64 %15, 2
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (let N (int Y) (if (or (sign? Y) (=0 N)) $Nil (loop (let R (loop1...
; # (int Y)
  %19 = lshr i64 %15, 4
; # (if (or (sign? Y) (=0 N)) $Nil (loop (let R (loop1 X) (? (=0 (& R...
; # (or (sign? Y) (=0 N))
; # (sign? Y)
  %20 = and i64 %15, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$12, label %$13
$13:
  %22 = phi i64 [%19, %$11] ; # N
; # (=0 N)
  %23 = icmp eq i64 %22, 0
  br label %$12
$12:
  %24 = phi i64 [%19, %$11], [%22, %$13] ; # N
  %25 = phi i1 [1, %$11], [%23, %$13] ; # ->
  br i1 %25, label %$14, label %$15
$14:
  %26 = phi i64 [%24, %$12] ; # N
  br label %$16
$15:
  %27 = phi i64 [%24, %$12] ; # N
; # (loop (let R (loop1 X) (? (=0 (& R 1)) R) (? (=0 (dec 'N)) (& R -...
  br label %$17
$17:
  %28 = phi i64 [%27, %$15], [%38, %$21] ; # N
; # (let R (loop1 X) (? (=0 (& R 1)) R) (? (=0 (dec 'N)) (& R -2)))
; # (loop1 X)
  %29 = call i64 @loop1(i64 %7)
; # (? (=0 (& R 1)) R)
; # (& R 1)
  %30 = and i64 %29, 1
; # (=0 (& R 1))
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$20, label %$18
$20:
  %32 = phi i64 [%28, %$17] ; # N
  br label %$19
$18:
  %33 = phi i64 [%28, %$17] ; # N
; # (? (=0 (dec 'N)) (& R -2))
; # (dec 'N)
  %34 = sub i64 %33, 1
; # (=0 (dec 'N))
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$22, label %$21
$22:
  %36 = phi i64 [%34, %$18] ; # N
; # (& R -2)
  %37 = and i64 %29, -2
  br label %$19
$21:
  %38 = phi i64 [%34, %$18] ; # N
  br label %$17
$19:
  %39 = phi i64 [%32, %$20], [%36, %$22] ; # N
  %40 = phi i64 [%29, %$20], [%37, %$22] ; # ->
  br label %$16
$16:
  %41 = phi i64 [%26, %$14], [%39, %$19] ; # N
  %42 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$14], [%40, %$19] ; # ->
  br label %$7
$10:
; # (loop2 X)
  %43 = call i64 @loop2(i64 %7)
  br label %$7
$7:
  %44 = phi i64 [%15, %$9], [%42, %$16], [%43, %$10] ; # ->
  ret i64 %44
}

define i64 @_loop(i64) {
$1:
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (loop2 (cdr Exe))
  %4 = tail call i64 @loop2(i64 %3)
  ret i64 %4
}

define i64 @_for(i64) {
$1:
; # (let (X (cdr Exe) Y (++ X) P (set $Bind (push NIL NIL (val $Bind)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (set $Bind (push NIL NIL (val $Bind)))
; # (val $Bind)
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %9 = load i64, i64* %8
; # (push NIL NIL (val $Bind))
  %10 = alloca i64, i64 3, align 16
  %11 = ptrtoint i64* %10 to i64
  %12 = add i64 %11, 16
  %13 = inttoptr i64 %12 to i64*
  store i64 %9, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %11, i64* %14
; # (cond ((atom Y) (set P (val Y) 2 P Y) (let V (eval (++ X)) (if (n...
; # (atom Y)
  %15 = and i64 %5, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$4, label %$3
$4:
  %17 = phi i64 [%7, %$1] ; # X
  %18 = phi i64 [%5, %$1] ; # Y
  %19 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (set P (val Y) 2 P Y)
; # (val Y)
  %20 = inttoptr i64 %18 to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %11 to i64*
  store i64 %21, i64* %22
  %23 = inttoptr i64 %11 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %18, i64* %24
; # (let V (eval (++ X)) (if (num? V) (unless (sign? V) (set Y ZERO) ...
; # (++ X)
  %25 = inttoptr i64 %17 to i64*
  %26 = load i64, i64* %25
  %27 = getelementptr i64, i64* %25, i32 1
  %28 = load i64, i64* %27
; # (eval (++ X))
  %29 = and i64 %26, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$7, label %$6
$7:
  br label %$5
$6:
  %31 = and i64 %26, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  %33 = inttoptr i64 %26 to i64*
  %34 = load i64, i64* %33
  br label %$5
$8:
  %35 = call i64 @evList(i64 %26)
  br label %$5
$5:
  %36 = phi i64 [%26, %$7], [%34, %$9], [%35, %$8] ; # ->
; # (if (num? V) (unless (sign? V) (set Y ZERO) (loop (? (> (+ (val Y...
; # (num? V)
  %37 = and i64 %36, 6
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$10, label %$11
$10:
  %39 = phi i64 [%28, %$5] ; # X
  %40 = phi i64 [%18, %$5] ; # Y
  %41 = phi i64 [%19, %$5] ; # R
  %42 = phi i64 [%36, %$5] ; # V
; # (unless (sign? V) (set Y ZERO) (loop (? (> (+ (val Y) (hex "10"))...
; # (sign? V)
  %43 = and i64 %42, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$14, label %$13
$13:
  %45 = phi i64 [%39, %$10] ; # X
  %46 = phi i64 [%40, %$10] ; # Y
  %47 = phi i64 [%41, %$10] ; # R
  %48 = phi i64 [%42, %$10] ; # V
; # (set Y ZERO)
  %49 = inttoptr i64 %46 to i64*
  store i64 2, i64* %49
; # (loop (? (> (+ (val Y) (hex "10")) V) (setq R (& R -2))) (set Y @...
  br label %$15
$15:
  %50 = phi i64 [%45, %$13], [%71, %$19] ; # X
  %51 = phi i64 [%46, %$13], [%72, %$19] ; # Y
  %52 = phi i64 [%47, %$13], [%73, %$19] ; # R
  %53 = phi i64 [%48, %$13], [%74, %$19] ; # V
; # (? (> (+ (val Y) (hex "10")) V) (setq R (& R -2)))
; # (val Y)
  %54 = inttoptr i64 %51 to i64*
  %55 = load i64, i64* %54
; # (+ (val Y) (hex "10"))
  %56 = add i64 %55, 16
; # (> (+ (val Y) (hex "10")) V)
  %57 = icmp ugt i64 %56, %53
  br i1 %57, label %$18, label %$16
$18:
  %58 = phi i64 [%50, %$15] ; # X
  %59 = phi i64 [%51, %$15] ; # Y
  %60 = phi i64 [%52, %$15] ; # R
  %61 = phi i64 [%53, %$15] ; # V
; # (& R -2)
  %62 = and i64 %60, -2
  br label %$17
$16:
  %63 = phi i64 [%50, %$15] ; # X
  %64 = phi i64 [%51, %$15] ; # Y
  %65 = phi i64 [%52, %$15] ; # R
  %66 = phi i64 [%53, %$15] ; # V
; # (set Y @)
  %67 = inttoptr i64 %64 to i64*
  store i64 %56, i64* %67
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %68 = call i64 @loop1(i64 %63)
; # (& (setq R (loop1 X)) 1)
  %69 = and i64 %68, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %70 = icmp eq i64 %69, 0
  br i1 %70, label %$17, label %$19
$19:
  %71 = phi i64 [%63, %$16] ; # X
  %72 = phi i64 [%64, %$16] ; # Y
  %73 = phi i64 [%68, %$16] ; # R
  %74 = phi i64 [%66, %$16] ; # V
  br label %$15
$17:
  %75 = phi i64 [%58, %$18], [%63, %$16] ; # X
  %76 = phi i64 [%59, %$18], [%64, %$16] ; # Y
  %77 = phi i64 [%62, %$18], [%68, %$16] ; # R
  %78 = phi i64 [%61, %$18], [%66, %$16] ; # V
  %79 = phi i64 [%62, %$18], [0, %$16] ; # ->
  br label %$14
$14:
  %80 = phi i64 [%39, %$10], [%75, %$17] ; # X
  %81 = phi i64 [%40, %$10], [%76, %$17] ; # Y
  %82 = phi i64 [%41, %$10], [%77, %$17] ; # R
  %83 = phi i64 [%42, %$10], [%78, %$17] ; # V
  br label %$12
$11:
  %84 = phi i64 [%28, %$5] ; # X
  %85 = phi i64 [%18, %$5] ; # Y
  %86 = phi i64 [%19, %$5] ; # R
  %87 = phi i64 [%36, %$5] ; # V
; # (save V (loop (? (atom V) (setq R (& R -2))) (set Y (++ V)) (? (=...
  %88 = alloca i64, i64 2, align 16
  %89 = ptrtoint i64* %88 to i64
  %90 = inttoptr i64 %89 to i64*
  store i64 %87, i64* %90
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %92 = load i64, i64* %91
  %93 = inttoptr i64 %89 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  store i64 %92, i64* %94
  %95 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %89, i64* %95
; # (loop (? (atom V) (setq R (& R -2))) (set Y (++ V)) (? (=0 (& (se...
  br label %$20
$20:
  %96 = phi i64 [%84, %$11], [%119, %$24] ; # X
  %97 = phi i64 [%85, %$11], [%120, %$24] ; # Y
  %98 = phi i64 [%86, %$11], [%121, %$24] ; # R
  %99 = phi i64 [%87, %$11], [%122, %$24] ; # V
; # (? (atom V) (setq R (& R -2)))
; # (atom V)
  %100 = and i64 %99, 15
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$23, label %$21
$23:
  %102 = phi i64 [%96, %$20] ; # X
  %103 = phi i64 [%97, %$20] ; # Y
  %104 = phi i64 [%98, %$20] ; # R
  %105 = phi i64 [%99, %$20] ; # V
; # (& R -2)
  %106 = and i64 %104, -2
  br label %$22
$21:
  %107 = phi i64 [%96, %$20] ; # X
  %108 = phi i64 [%97, %$20] ; # Y
  %109 = phi i64 [%98, %$20] ; # R
  %110 = phi i64 [%99, %$20] ; # V
; # (set Y (++ V))
; # (++ V)
  %111 = inttoptr i64 %110 to i64*
  %112 = load i64, i64* %111
  %113 = getelementptr i64, i64* %111, i32 1
  %114 = load i64, i64* %113
  %115 = inttoptr i64 %108 to i64*
  store i64 %112, i64* %115
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %116 = call i64 @loop1(i64 %107)
; # (& (setq R (loop1 X)) 1)
  %117 = and i64 %116, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %118 = icmp eq i64 %117, 0
  br i1 %118, label %$22, label %$24
$24:
  %119 = phi i64 [%107, %$21] ; # X
  %120 = phi i64 [%108, %$21] ; # Y
  %121 = phi i64 [%116, %$21] ; # R
  %122 = phi i64 [%114, %$21] ; # V
  br label %$20
$22:
  %123 = phi i64 [%102, %$23], [%107, %$21] ; # X
  %124 = phi i64 [%103, %$23], [%108, %$21] ; # Y
  %125 = phi i64 [%106, %$23], [%116, %$21] ; # R
  %126 = phi i64 [%105, %$23], [%114, %$21] ; # V
  %127 = phi i64 [%106, %$23], [0, %$21] ; # ->
  %128 = inttoptr i64 %89 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %130, i64* %131
  br label %$12
$12:
  %132 = phi i64 [%80, %$14], [%123, %$22] ; # X
  %133 = phi i64 [%81, %$14], [%124, %$22] ; # Y
  %134 = phi i64 [%82, %$14], [%125, %$22] ; # R
  %135 = phi i64 [%83, %$14], [%126, %$22] ; # V
  br label %$2
$3:
  %136 = phi i64 [%7, %$1] ; # X
  %137 = phi i64 [%5, %$1] ; # Y
  %138 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (cdr Y)
  %139 = inttoptr i64 %137 to i64*
  %140 = getelementptr i64, i64* %139, i32 1
  %141 = load i64, i64* %140
; # (atom (cdr Y))
  %142 = and i64 %141, 15
  %143 = icmp ne i64 %142, 0
  br i1 %143, label %$26, label %$25
$26:
  %144 = phi i64 [%136, %$3] ; # X
  %145 = phi i64 [%137, %$3] ; # Y
  %146 = phi i64 [%138, %$3] ; # R
; # (let Sym2 @ (set P (val (setq Y (car Y))) 2 P Y) (let (Q (set $Bi...
; # (set P (val (setq Y (car Y))) 2 P Y)
; # (car Y)
  %147 = inttoptr i64 %145 to i64*
  %148 = load i64, i64* %147
; # (val (setq Y (car Y)))
  %149 = inttoptr i64 %148 to i64*
  %150 = load i64, i64* %149
  %151 = inttoptr i64 %11 to i64*
  store i64 %150, i64* %151
  %152 = inttoptr i64 %11 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  store i64 %148, i64* %153
; # (let (Q (set $Bind (push (val Sym2) Sym2 (val $Bind))) V (save (e...
; # (set $Bind (push (val Sym2) Sym2 (val $Bind)))
; # (val Sym2)
  %154 = inttoptr i64 %141 to i64*
  %155 = load i64, i64* %154
; # (val $Bind)
  %156 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %157 = load i64, i64* %156
; # (push (val Sym2) Sym2 (val $Bind))
  %158 = alloca i64, i64 3, align 16
  %159 = ptrtoint i64* %158 to i64
  %160 = inttoptr i64 %159 to i64*
  store i64 %155, i64* %160
  %161 = add i64 %159, 8
  %162 = inttoptr i64 %161 to i64*
  store i64 %141, i64* %162
  %163 = add i64 %159, 16
  %164 = inttoptr i64 %163 to i64*
  store i64 %157, i64* %164
  %165 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %159, i64* %165
; # (++ X)
  %166 = inttoptr i64 %144 to i64*
  %167 = load i64, i64* %166
  %168 = getelementptr i64, i64* %166, i32 1
  %169 = load i64, i64* %168
; # (eval (++ X))
  %170 = and i64 %167, 6
  %171 = icmp ne i64 %170, 0
  br i1 %171, label %$29, label %$28
$29:
  br label %$27
$28:
  %172 = and i64 %167, 8
  %173 = icmp ne i64 %172, 0
  br i1 %173, label %$31, label %$30
$31:
  %174 = inttoptr i64 %167 to i64*
  %175 = load i64, i64* %174
  br label %$27
$30:
  %176 = call i64 @evList(i64 %167)
  br label %$27
$27:
  %177 = phi i64 [%167, %$29], [%175, %$31], [%176, %$30] ; # ->
; # (save (eval (++ X)))
  %178 = alloca i64, i64 2, align 16
  %179 = ptrtoint i64* %178 to i64
  %180 = inttoptr i64 %179 to i64*
  store i64 %177, i64* %180
  %181 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %182 = load i64, i64* %181
  %183 = inttoptr i64 %179 to i64*
  %184 = getelementptr i64, i64* %183, i32 1
  store i64 %182, i64* %184
  %185 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %179, i64* %185
; # (set Y ONE)
  %186 = inttoptr i64 %148 to i64*
  store i64 18, i64* %186
; # (loop (? (atom V) (setq R (& R -2))) (set Sym2 (++ V)) (? (=0 (& ...
  br label %$32
$32:
  %187 = phi i64 [%169, %$27], [%210, %$36] ; # X
  %188 = phi i64 [%148, %$27], [%211, %$36] ; # Y
  %189 = phi i64 [%146, %$27], [%212, %$36] ; # R
  %190 = phi i64 [%177, %$27], [%213, %$36] ; # V
; # (? (atom V) (setq R (& R -2)))
; # (atom V)
  %191 = and i64 %190, 15
  %192 = icmp ne i64 %191, 0
  br i1 %192, label %$35, label %$33
$35:
  %193 = phi i64 [%187, %$32] ; # X
  %194 = phi i64 [%188, %$32] ; # Y
  %195 = phi i64 [%189, %$32] ; # R
  %196 = phi i64 [%190, %$32] ; # V
; # (& R -2)
  %197 = and i64 %195, -2
  br label %$34
$33:
  %198 = phi i64 [%187, %$32] ; # X
  %199 = phi i64 [%188, %$32] ; # Y
  %200 = phi i64 [%189, %$32] ; # R
  %201 = phi i64 [%190, %$32] ; # V
; # (set Sym2 (++ V))
; # (++ V)
  %202 = inttoptr i64 %201 to i64*
  %203 = load i64, i64* %202
  %204 = getelementptr i64, i64* %202, i32 1
  %205 = load i64, i64* %204
  %206 = inttoptr i64 %141 to i64*
  store i64 %203, i64* %206
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %207 = call i64 @loop1(i64 %198)
; # (& (setq R (loop1 X)) 1)
  %208 = and i64 %207, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %209 = icmp eq i64 %208, 0
  br i1 %209, label %$34, label %$36
$36:
  %210 = phi i64 [%198, %$33] ; # X
  %211 = phi i64 [%199, %$33] ; # Y
  %212 = phi i64 [%207, %$33] ; # R
  %213 = phi i64 [%205, %$33] ; # V
; # (set Y (+ (val Y) (hex "10")))
; # (val Y)
  %214 = inttoptr i64 %211 to i64*
  %215 = load i64, i64* %214
; # (+ (val Y) (hex "10"))
  %216 = add i64 %215, 16
  %217 = inttoptr i64 %211 to i64*
  store i64 %216, i64* %217
  br label %$32
$34:
  %218 = phi i64 [%193, %$35], [%198, %$33] ; # X
  %219 = phi i64 [%194, %$35], [%199, %$33] ; # Y
  %220 = phi i64 [%197, %$35], [%207, %$33] ; # R
  %221 = phi i64 [%196, %$35], [%205, %$33] ; # V
  %222 = phi i64 [%197, %$35], [0, %$33] ; # ->
; # (set Sym2 (val Q))
; # (val Q)
  %223 = inttoptr i64 %159 to i64*
  %224 = load i64, i64* %223
  %225 = inttoptr i64 %141 to i64*
  store i64 %224, i64* %225
; # (drop *Safe)
  %226 = inttoptr i64 %179 to i64*
  %227 = getelementptr i64, i64* %226, i32 1
  %228 = load i64, i64* %227
  %229 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %228, i64* %229
  br label %$2
$25:
  %230 = phi i64 [%136, %$3] ; # X
  %231 = phi i64 [%137, %$3] ; # Y
  %232 = phi i64 [%138, %$3] ; # R
; # (car Y)
  %233 = inttoptr i64 %231 to i64*
  %234 = load i64, i64* %233
; # (atom (car Y))
  %235 = and i64 %234, 15
  %236 = icmp ne i64 %235, 0
  br i1 %236, label %$38, label %$37
$38:
  %237 = phi i64 [%230, %$25] ; # X
  %238 = phi i64 [%231, %$25] ; # Y
  %239 = phi i64 [%232, %$25] ; # R
; # (let Z (cdr Y) (set P (val (setq Y @)) 2 P Y Y (eval (++ Z))) (sa...
; # (cdr Y)
  %240 = inttoptr i64 %238 to i64*
  %241 = getelementptr i64, i64* %240, i32 1
  %242 = load i64, i64* %241
; # (set P (val (setq Y @)) 2 P Y Y (eval (++ Z)))
; # (val (setq Y @))
  %243 = inttoptr i64 %234 to i64*
  %244 = load i64, i64* %243
  %245 = inttoptr i64 %11 to i64*
  store i64 %244, i64* %245
  %246 = inttoptr i64 %11 to i64*
  %247 = getelementptr i64, i64* %246, i32 1
  store i64 %234, i64* %247
; # (++ Z)
  %248 = inttoptr i64 %242 to i64*
  %249 = load i64, i64* %248
  %250 = getelementptr i64, i64* %248, i32 1
  %251 = load i64, i64* %250
; # (eval (++ Z))
  %252 = and i64 %249, 6
  %253 = icmp ne i64 %252, 0
  br i1 %253, label %$41, label %$40
$41:
  br label %$39
$40:
  %254 = and i64 %249, 8
  %255 = icmp ne i64 %254, 0
  br i1 %255, label %$43, label %$42
$43:
  %256 = inttoptr i64 %249 to i64*
  %257 = load i64, i64* %256
  br label %$39
$42:
  %258 = call i64 @evList(i64 %249)
  br label %$39
$39:
  %259 = phi i64 [%249, %$41], [%257, %$43], [%258, %$42] ; # ->
  %260 = inttoptr i64 %234 to i64*
  store i64 %259, i64* %260
; # (save R (loop (? (nil? (eval (car Z)))) (set $At @) (? (=0 (& (se...
  %261 = alloca i64, i64 2, align 16
  %262 = ptrtoint i64* %261 to i64
  %263 = inttoptr i64 %262 to i64*
  store i64 %239, i64* %263
  %264 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %265 = load i64, i64* %264
  %266 = inttoptr i64 %262 to i64*
  %267 = getelementptr i64, i64* %266, i32 1
  store i64 %265, i64* %267
  %268 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %262, i64* %268
; # (loop (? (nil? (eval (car Z)))) (set $At @) (? (=0 (& (setq R (lo...
  br label %$44
$44:
  %269 = phi i64 [%237, %$39], [%334, %$54] ; # X
  %270 = phi i64 [%234, %$39], [%335, %$54] ; # Y
  %271 = phi i64 [%239, %$39], [%336, %$54] ; # R
  %272 = phi i64 [%251, %$39], [%337, %$54] ; # Z
; # (? (nil? (eval (car Z))))
; # (car Z)
  %273 = inttoptr i64 %272 to i64*
  %274 = load i64, i64* %273
; # (eval (car Z))
  %275 = and i64 %274, 6
  %276 = icmp ne i64 %275, 0
  br i1 %276, label %$47, label %$46
$47:
  br label %$45
$46:
  %277 = and i64 %274, 8
  %278 = icmp ne i64 %277, 0
  br i1 %278, label %$49, label %$48
$49:
  %279 = inttoptr i64 %274 to i64*
  %280 = load i64, i64* %279
  br label %$45
$48:
  %281 = call i64 @evList(i64 %274)
  br label %$45
$45:
  %282 = phi i64 [%274, %$47], [%280, %$49], [%281, %$48] ; # ->
; # (nil? (eval (car Z)))
  %283 = icmp eq i64 %282, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %283, label %$51, label %$50
$50:
  %284 = phi i64 [%269, %$45] ; # X
  %285 = phi i64 [%270, %$45] ; # Y
  %286 = phi i64 [%271, %$45] ; # R
  %287 = phi i64 [%272, %$45] ; # Z
; # (set $At @)
  %288 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %282, i64* %288
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %289 = call i64 @loop1(i64 %284)
; # (& (setq R (loop1 X)) 1)
  %290 = and i64 %289, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %291 = icmp eq i64 %290, 0
  br i1 %291, label %$51, label %$52
$52:
  %292 = phi i64 [%284, %$50] ; # X
  %293 = phi i64 [%285, %$50] ; # Y
  %294 = phi i64 [%289, %$50] ; # R
  %295 = phi i64 [%287, %$50] ; # Z
; # (& R -2)
  %296 = and i64 %294, -2
; # (safe (setq R (& R -2)))
  %297 = inttoptr i64 %262 to i64*
  store i64 %296, i64* %297
; # (when (pair (cdr Z)) (set Y (run @)))
; # (cdr Z)
  %298 = inttoptr i64 %295 to i64*
  %299 = getelementptr i64, i64* %298, i32 1
  %300 = load i64, i64* %299
; # (pair (cdr Z))
  %301 = and i64 %300, 15
  %302 = icmp eq i64 %301, 0
  br i1 %302, label %$53, label %$54
$53:
  %303 = phi i64 [%292, %$52] ; # X
  %304 = phi i64 [%293, %$52] ; # Y
  %305 = phi i64 [%296, %$52] ; # R
  %306 = phi i64 [%295, %$52] ; # Z
; # (set Y (run @))
; # (run @)
  br label %$55
$55:
  %307 = phi i64 [%300, %$53], [%329, %$64] ; # Prg
  %308 = inttoptr i64 %307 to i64*
  %309 = load i64, i64* %308
  %310 = getelementptr i64, i64* %308, i32 1
  %311 = load i64, i64* %310
  %312 = and i64 %311, 15
  %313 = icmp ne i64 %312, 0
  br i1 %313, label %$58, label %$56
$58:
  %314 = phi i64 [%311, %$55] ; # Prg
  %315 = and i64 %309, 6
  %316 = icmp ne i64 %315, 0
  br i1 %316, label %$61, label %$60
$61:
  br label %$59
$60:
  %317 = and i64 %309, 8
  %318 = icmp ne i64 %317, 0
  br i1 %318, label %$63, label %$62
$63:
  %319 = inttoptr i64 %309 to i64*
  %320 = load i64, i64* %319
  br label %$59
$62:
  %321 = call i64 @evList(i64 %309)
  br label %$59
$59:
  %322 = phi i64 [%309, %$61], [%320, %$63], [%321, %$62] ; # ->
  br label %$57
$56:
  %323 = phi i64 [%311, %$55] ; # Prg
  %324 = and i64 %309, 15
  %325 = icmp eq i64 %324, 0
  br i1 %325, label %$65, label %$64
$65:
  %326 = phi i64 [%323, %$56] ; # Prg
  %327 = call i64 @evList(i64 %309)
  %328 = icmp ne i64 %327, 0
  br label %$64
$64:
  %329 = phi i64 [%323, %$56], [%326, %$65] ; # Prg
  %330 = phi i1 [0, %$56], [%328, %$65] ; # ->
  br label %$55
$57:
  %331 = phi i64 [%314, %$59] ; # Prg
  %332 = phi i64 [%322, %$59] ; # ->
  %333 = inttoptr i64 %304 to i64*
  store i64 %332, i64* %333
  br label %$54
$54:
  %334 = phi i64 [%292, %$52], [%303, %$57] ; # X
  %335 = phi i64 [%293, %$52], [%304, %$57] ; # Y
  %336 = phi i64 [%296, %$52], [%305, %$57] ; # R
  %337 = phi i64 [%295, %$52], [%306, %$57] ; # Z
  br label %$44
$51:
  %338 = phi i64 [%269, %$45], [%284, %$50] ; # X
  %339 = phi i64 [%270, %$45], [%285, %$50] ; # Y
  %340 = phi i64 [%271, %$45], [%289, %$50] ; # R
  %341 = phi i64 [%272, %$45], [%287, %$50] ; # Z
  %342 = phi i64 [0, %$45], [0, %$50] ; # ->
  %343 = inttoptr i64 %262 to i64*
  %344 = getelementptr i64, i64* %343, i32 1
  %345 = load i64, i64* %344
  %346 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %345, i64* %346
  br label %$2
$37:
  %347 = phi i64 [%230, %$25] ; # X
  %348 = phi i64 [%231, %$25] ; # Y
  %349 = phi i64 [%232, %$25] ; # R
; # (let (Sym2 (cdr @) Z (cdr Y)) (set P (val (setq Y (car @))) 2 P Y...
; # (cdr @)
  %350 = inttoptr i64 %234 to i64*
  %351 = getelementptr i64, i64* %350, i32 1
  %352 = load i64, i64* %351
; # (cdr Y)
  %353 = inttoptr i64 %348 to i64*
  %354 = getelementptr i64, i64* %353, i32 1
  %355 = load i64, i64* %354
; # (set P (val (setq Y (car @))) 2 P Y)
; # (car @)
  %356 = inttoptr i64 %234 to i64*
  %357 = load i64, i64* %356
; # (val (setq Y (car @)))
  %358 = inttoptr i64 %357 to i64*
  %359 = load i64, i64* %358
  %360 = inttoptr i64 %11 to i64*
  store i64 %359, i64* %360
  %361 = inttoptr i64 %11 to i64*
  %362 = getelementptr i64, i64* %361, i32 1
  store i64 %357, i64* %362
; # (save R (let Q (set $Bind (push (val Sym2) Sym2 (val $Bind))) (se...
  %363 = alloca i64, i64 2, align 16
  %364 = ptrtoint i64* %363 to i64
  %365 = inttoptr i64 %364 to i64*
  store i64 %349, i64* %365
  %366 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %367 = load i64, i64* %366
  %368 = inttoptr i64 %364 to i64*
  %369 = getelementptr i64, i64* %368, i32 1
  store i64 %367, i64* %369
  %370 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %364, i64* %370
; # (let Q (set $Bind (push (val Sym2) Sym2 (val $Bind))) (set Sym2 (...
; # (set $Bind (push (val Sym2) Sym2 (val $Bind)))
; # (val Sym2)
  %371 = inttoptr i64 %352 to i64*
  %372 = load i64, i64* %371
; # (val $Bind)
  %373 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %374 = load i64, i64* %373
; # (push (val Sym2) Sym2 (val $Bind))
  %375 = alloca i64, i64 3, align 16
  %376 = ptrtoint i64* %375 to i64
  %377 = inttoptr i64 %376 to i64*
  store i64 %372, i64* %377
  %378 = add i64 %376, 8
  %379 = inttoptr i64 %378 to i64*
  store i64 %352, i64* %379
  %380 = add i64 %376, 16
  %381 = inttoptr i64 %380 to i64*
  store i64 %374, i64* %381
  %382 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %376, i64* %382
; # (set Sym2 (save (eval (++ Z))) Y ONE)
; # (++ Z)
  %383 = inttoptr i64 %355 to i64*
  %384 = load i64, i64* %383
  %385 = getelementptr i64, i64* %383, i32 1
  %386 = load i64, i64* %385
; # (eval (++ Z))
  %387 = and i64 %384, 6
  %388 = icmp ne i64 %387, 0
  br i1 %388, label %$68, label %$67
$68:
  br label %$66
$67:
  %389 = and i64 %384, 8
  %390 = icmp ne i64 %389, 0
  br i1 %390, label %$70, label %$69
$70:
  %391 = inttoptr i64 %384 to i64*
  %392 = load i64, i64* %391
  br label %$66
$69:
  %393 = call i64 @evList(i64 %384)
  br label %$66
$66:
  %394 = phi i64 [%384, %$68], [%392, %$70], [%393, %$69] ; # ->
; # (save (eval (++ Z)))
  %395 = alloca i64, i64 2, align 16
  %396 = ptrtoint i64* %395 to i64
  %397 = inttoptr i64 %396 to i64*
  store i64 %394, i64* %397
  %398 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %399 = load i64, i64* %398
  %400 = inttoptr i64 %396 to i64*
  %401 = getelementptr i64, i64* %400, i32 1
  store i64 %399, i64* %401
  %402 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %396, i64* %402
  %403 = inttoptr i64 %352 to i64*
  store i64 %394, i64* %403
  %404 = inttoptr i64 %357 to i64*
  store i64 18, i64* %404
; # (loop (? (nil? (eval (car Z)))) (set $At @) (? (=0 (& (setq R (lo...
  br label %$71
$71:
  %405 = phi i64 [%347, %$66], [%470, %$81] ; # X
  %406 = phi i64 [%357, %$66], [%471, %$81] ; # Y
  %407 = phi i64 [%349, %$66], [%472, %$81] ; # R
  %408 = phi i64 [%386, %$66], [%473, %$81] ; # Z
; # (? (nil? (eval (car Z))))
; # (car Z)
  %409 = inttoptr i64 %408 to i64*
  %410 = load i64, i64* %409
; # (eval (car Z))
  %411 = and i64 %410, 6
  %412 = icmp ne i64 %411, 0
  br i1 %412, label %$74, label %$73
$74:
  br label %$72
$73:
  %413 = and i64 %410, 8
  %414 = icmp ne i64 %413, 0
  br i1 %414, label %$76, label %$75
$76:
  %415 = inttoptr i64 %410 to i64*
  %416 = load i64, i64* %415
  br label %$72
$75:
  %417 = call i64 @evList(i64 %410)
  br label %$72
$72:
  %418 = phi i64 [%410, %$74], [%416, %$76], [%417, %$75] ; # ->
; # (nil? (eval (car Z)))
  %419 = icmp eq i64 %418, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %419, label %$78, label %$77
$77:
  %420 = phi i64 [%405, %$72] ; # X
  %421 = phi i64 [%406, %$72] ; # Y
  %422 = phi i64 [%407, %$72] ; # R
  %423 = phi i64 [%408, %$72] ; # Z
; # (set $At @)
  %424 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %418, i64* %424
; # (? (=0 (& (setq R (loop1 X)) 1)))
; # (loop1 X)
  %425 = call i64 @loop1(i64 %420)
; # (& (setq R (loop1 X)) 1)
  %426 = and i64 %425, 1
; # (=0 (& (setq R (loop1 X)) 1))
  %427 = icmp eq i64 %426, 0
  br i1 %427, label %$78, label %$79
$79:
  %428 = phi i64 [%420, %$77] ; # X
  %429 = phi i64 [%421, %$77] ; # Y
  %430 = phi i64 [%425, %$77] ; # R
  %431 = phi i64 [%423, %$77] ; # Z
; # (& R -2)
  %432 = and i64 %430, -2
; # (safe (setq R (& R -2)))
  %433 = inttoptr i64 %364 to i64*
  store i64 %432, i64* %433
; # (when (pair (cdr Z)) (set Sym2 (run @)))
; # (cdr Z)
  %434 = inttoptr i64 %431 to i64*
  %435 = getelementptr i64, i64* %434, i32 1
  %436 = load i64, i64* %435
; # (pair (cdr Z))
  %437 = and i64 %436, 15
  %438 = icmp eq i64 %437, 0
  br i1 %438, label %$80, label %$81
$80:
  %439 = phi i64 [%428, %$79] ; # X
  %440 = phi i64 [%429, %$79] ; # Y
  %441 = phi i64 [%432, %$79] ; # R
  %442 = phi i64 [%431, %$79] ; # Z
; # (set Sym2 (run @))
; # (run @)
  br label %$82
$82:
  %443 = phi i64 [%436, %$80], [%465, %$91] ; # Prg
  %444 = inttoptr i64 %443 to i64*
  %445 = load i64, i64* %444
  %446 = getelementptr i64, i64* %444, i32 1
  %447 = load i64, i64* %446
  %448 = and i64 %447, 15
  %449 = icmp ne i64 %448, 0
  br i1 %449, label %$85, label %$83
$85:
  %450 = phi i64 [%447, %$82] ; # Prg
  %451 = and i64 %445, 6
  %452 = icmp ne i64 %451, 0
  br i1 %452, label %$88, label %$87
$88:
  br label %$86
$87:
  %453 = and i64 %445, 8
  %454 = icmp ne i64 %453, 0
  br i1 %454, label %$90, label %$89
$90:
  %455 = inttoptr i64 %445 to i64*
  %456 = load i64, i64* %455
  br label %$86
$89:
  %457 = call i64 @evList(i64 %445)
  br label %$86
$86:
  %458 = phi i64 [%445, %$88], [%456, %$90], [%457, %$89] ; # ->
  br label %$84
$83:
  %459 = phi i64 [%447, %$82] ; # Prg
  %460 = and i64 %445, 15
  %461 = icmp eq i64 %460, 0
  br i1 %461, label %$92, label %$91
$92:
  %462 = phi i64 [%459, %$83] ; # Prg
  %463 = call i64 @evList(i64 %445)
  %464 = icmp ne i64 %463, 0
  br label %$91
$91:
  %465 = phi i64 [%459, %$83], [%462, %$92] ; # Prg
  %466 = phi i1 [0, %$83], [%464, %$92] ; # ->
  br label %$82
$84:
  %467 = phi i64 [%450, %$86] ; # Prg
  %468 = phi i64 [%458, %$86] ; # ->
  %469 = inttoptr i64 %352 to i64*
  store i64 %468, i64* %469
  br label %$81
$81:
  %470 = phi i64 [%428, %$79], [%439, %$84] ; # X
  %471 = phi i64 [%429, %$79], [%440, %$84] ; # Y
  %472 = phi i64 [%432, %$79], [%441, %$84] ; # R
  %473 = phi i64 [%431, %$79], [%442, %$84] ; # Z
; # (set Y (+ (val Y) (hex "10")))
; # (val Y)
  %474 = inttoptr i64 %471 to i64*
  %475 = load i64, i64* %474
; # (+ (val Y) (hex "10"))
  %476 = add i64 %475, 16
  %477 = inttoptr i64 %471 to i64*
  store i64 %476, i64* %477
  br label %$71
$78:
  %478 = phi i64 [%405, %$72], [%420, %$77] ; # X
  %479 = phi i64 [%406, %$72], [%421, %$77] ; # Y
  %480 = phi i64 [%407, %$72], [%425, %$77] ; # R
  %481 = phi i64 [%408, %$72], [%423, %$77] ; # Z
  %482 = phi i64 [0, %$72], [0, %$77] ; # ->
; # (set Sym2 (val Q))
; # (val Q)
  %483 = inttoptr i64 %376 to i64*
  %484 = load i64, i64* %483
  %485 = inttoptr i64 %352 to i64*
  store i64 %484, i64* %485
  %486 = inttoptr i64 %364 to i64*
  %487 = getelementptr i64, i64* %486, i32 1
  %488 = load i64, i64* %487
  %489 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %488, i64* %489
  br label %$2
$2:
  %490 = phi i64 [%132, %$12], [%218, %$34], [%338, %$51], [%478, %$78] ; # X
  %491 = phi i64 [%133, %$12], [%219, %$34], [%339, %$51], [%479, %$78] ; # Y
  %492 = phi i64 [%134, %$12], [%220, %$34], [%340, %$51], [%480, %$78] ; # R
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %493 = inttoptr i64 %11 to i64*
  %494 = load i64, i64* %493
  %495 = inttoptr i64 %491 to i64*
  store i64 %494, i64* %495
; # (val 3 P)
  %496 = inttoptr i64 %11 to i64*
  %497 = getelementptr i64, i64* %496, i32 2
  %498 = load i64, i64* %497
  %499 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %498, i64* %499
  ret i64 %492
}

define i64 @_with(i64) {
$1:
; # (let (X (cdr Exe) Y (needVar Exe (eval (++ X)))) (if (nil? Y) Y (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needVar Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %15)
  unreachable
$8:
; # (if (nil? Y) Y (let P (set $Bind (push (val $This) $This (val $Bi...
; # (nil? Y)
  %18 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$9, label %$10
$9:
  br label %$11
$10:
; # (let P (set $Bind (push (val $This) $This (val $Bind))) (set $Thi...
; # (set $Bind (push (val $This) $This (val $Bind)))
; # (val $This)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %20 = load i64, i64* %19
; # (val $Bind)
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %22 = load i64, i64* %21
; # (push (val $This) $This (val $Bind))
  %23 = alloca i64, i64 3, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64), i64* %27
  %28 = add i64 %24, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 %22, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %24, i64* %30
; # (set $This Y)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %15, i64* %31
; # (prog1 (run X) (set $This (val P) $Bind (val 3 P)))
; # (run X)
  br label %$12
$12:
  %32 = phi i64 [%7, %$10], [%54, %$21] ; # Prg
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = getelementptr i64, i64* %33, i32 1
  %36 = load i64, i64* %35
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$13
$15:
  %39 = phi i64 [%36, %$12] ; # Prg
  %40 = and i64 %34, 6
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$18, label %$17
$18:
  br label %$16
$17:
  %42 = and i64 %34, 8
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$20, label %$19
$20:
  %44 = inttoptr i64 %34 to i64*
  %45 = load i64, i64* %44
  br label %$16
$19:
  %46 = call i64 @evList(i64 %34)
  br label %$16
$16:
  %47 = phi i64 [%34, %$18], [%45, %$20], [%46, %$19] ; # ->
  br label %$14
$13:
  %48 = phi i64 [%36, %$12] ; # Prg
  %49 = and i64 %34, 15
  %50 = icmp eq i64 %49, 0
  br i1 %50, label %$22, label %$21
$22:
  %51 = phi i64 [%48, %$13] ; # Prg
  %52 = call i64 @evList(i64 %34)
  %53 = icmp ne i64 %52, 0
  br label %$21
$21:
  %54 = phi i64 [%48, %$13], [%51, %$22] ; # Prg
  %55 = phi i1 [0, %$13], [%53, %$22] ; # ->
  br label %$12
$14:
  %56 = phi i64 [%39, %$16] ; # Prg
  %57 = phi i64 [%47, %$16] ; # ->
; # (set $This (val P) $Bind (val 3 P))
; # (val P)
  %58 = inttoptr i64 %24 to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  store i64 %59, i64* %60
; # (val 3 P)
  %61 = inttoptr i64 %24 to i64*
  %62 = getelementptr i64, i64* %61, i32 2
  %63 = load i64, i64* %62
  %64 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %63, i64* %64
  br label %$11
$11:
  %65 = phi i64 [%15, %$9], [%57, %$14] ; # ->
  ret i64 %65
}

define i64 @_bind(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((num? Y) (argErr Exe Y)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((num? Y) (argErr Exe Y)) ((nil? Y) (run X)) ((sym? Y) (let...
; # (num? Y)
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = phi i64 [%15, %$2] ; # Y
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %18)
  unreachable
$8:
  %19 = phi i64 [%15, %$2] ; # Y
; # (nil? Y)
  %20 = icmp eq i64 %19, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %20, label %$11, label %$10
$11:
  %21 = phi i64 [%19, %$8] ; # Y
; # (run X)
  br label %$12
$12:
  %22 = phi i64 [%7, %$11], [%44, %$21] ; # Prg
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
  %25 = getelementptr i64, i64* %23, i32 1
  %26 = load i64, i64* %25
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$15, label %$13
$15:
  %29 = phi i64 [%26, %$12] ; # Prg
  %30 = and i64 %24, 6
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$18, label %$17
$18:
  br label %$16
$17:
  %32 = and i64 %24, 8
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$20, label %$19
$20:
  %34 = inttoptr i64 %24 to i64*
  %35 = load i64, i64* %34
  br label %$16
$19:
  %36 = call i64 @evList(i64 %24)
  br label %$16
$16:
  %37 = phi i64 [%24, %$18], [%35, %$20], [%36, %$19] ; # ->
  br label %$14
$13:
  %38 = phi i64 [%26, %$12] ; # Prg
  %39 = and i64 %24, 15
  %40 = icmp eq i64 %39, 0
  br i1 %40, label %$22, label %$21
$22:
  %41 = phi i64 [%38, %$13] ; # Prg
  %42 = call i64 @evList(i64 %24)
  %43 = icmp ne i64 %42, 0
  br label %$21
$21:
  %44 = phi i64 [%38, %$13], [%41, %$22] ; # Prg
  %45 = phi i1 [0, %$13], [%43, %$22] ; # ->
  br label %$12
$14:
  %46 = phi i64 [%29, %$16] ; # Prg
  %47 = phi i64 [%37, %$16] ; # ->
  br label %$7
$10:
  %48 = phi i64 [%19, %$8] ; # Y
; # (sym? Y)
  %49 = and i64 %48, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$24, label %$23
$24:
  %51 = phi i64 [%48, %$10] ; # Y
; # (let P (set $Bind (push (val Y) Y (val $Bind))) (prog1 (run X) (s...
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
; # (val $Bind)
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %55 = load i64, i64* %54
; # (push (val Y) Y (val $Bind))
  %56 = alloca i64, i64 3, align 16
  %57 = ptrtoint i64* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  store i64 %53, i64* %58
  %59 = add i64 %57, 8
  %60 = inttoptr i64 %59 to i64*
  store i64 %51, i64* %60
  %61 = add i64 %57, 16
  %62 = inttoptr i64 %61 to i64*
  store i64 %55, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %57, i64* %63
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$25
$25:
  %64 = phi i64 [%7, %$24], [%86, %$34] ; # Prg
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = getelementptr i64, i64* %65, i32 1
  %68 = load i64, i64* %67
  %69 = and i64 %68, 15
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$28, label %$26
$28:
  %71 = phi i64 [%68, %$25] ; # Prg
  %72 = and i64 %66, 6
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$31, label %$30
$31:
  br label %$29
$30:
  %74 = and i64 %66, 8
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$33, label %$32
$33:
  %76 = inttoptr i64 %66 to i64*
  %77 = load i64, i64* %76
  br label %$29
$32:
  %78 = call i64 @evList(i64 %66)
  br label %$29
$29:
  %79 = phi i64 [%66, %$31], [%77, %$33], [%78, %$32] ; # ->
  br label %$27
$26:
  %80 = phi i64 [%68, %$25] ; # Prg
  %81 = and i64 %66, 15
  %82 = icmp eq i64 %81, 0
  br i1 %82, label %$35, label %$34
$35:
  %83 = phi i64 [%80, %$26] ; # Prg
  %84 = call i64 @evList(i64 %66)
  %85 = icmp ne i64 %84, 0
  br label %$34
$34:
  %86 = phi i64 [%80, %$26], [%83, %$35] ; # Prg
  %87 = phi i1 [0, %$26], [%85, %$35] ; # ->
  br label %$25
$27:
  %88 = phi i64 [%71, %$29] ; # Prg
  %89 = phi i64 [%79, %$29] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %90 = inttoptr i64 %57 to i64*
  %91 = load i64, i64* %90
  %92 = inttoptr i64 %51 to i64*
  store i64 %91, i64* %92
; # (val 3 P)
  %93 = inttoptr i64 %57 to i64*
  %94 = getelementptr i64, i64* %93, i32 2
  %95 = load i64, i64* %94
  %96 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %95, i64* %96
  br label %$7
$23:
  %97 = phi i64 [%48, %$10] ; # Y
; # (let (P (val $Bind) Q P) (loop (let Z (++ Y) (when (num? Z) (argE...
; # (val $Bind)
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %99 = load i64, i64* %98
; # (loop (let Z (++ Y) (when (num? Z) (argErr Exe Y)) (if (sym? Z) (...
  br label %$36
$36:
  %100 = phi i64 [%97, %$23], [%149, %$42] ; # Y
  %101 = phi i64 [%99, %$23], [%150, %$42] ; # P
; # (let Z (++ Y) (when (num? Z) (argErr Exe Y)) (if (sym? Z) (set $B...
; # (++ Y)
  %102 = inttoptr i64 %100 to i64*
  %103 = load i64, i64* %102
  %104 = getelementptr i64, i64* %102, i32 1
  %105 = load i64, i64* %104
; # (when (num? Z) (argErr Exe Y))
; # (num? Z)
  %106 = and i64 %103, 6
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$37, label %$38
$37:
  %108 = phi i64 [%105, %$36] ; # Y
  %109 = phi i64 [%101, %$36] ; # P
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %108)
  unreachable
$38:
  %110 = phi i64 [%105, %$36] ; # Y
  %111 = phi i64 [%101, %$36] ; # P
; # (if (sym? Z) (set $Bind (setq P (push (val Z) Z P))) (let S (car ...
; # (sym? Z)
  %112 = and i64 %103, 8
  %113 = icmp ne i64 %112, 0
  br i1 %113, label %$39, label %$40
$39:
  %114 = phi i64 [%110, %$38] ; # Y
  %115 = phi i64 [%111, %$38] ; # P
; # (set $Bind (setq P (push (val Z) Z P)))
; # (val Z)
  %116 = inttoptr i64 %103 to i64*
  %117 = load i64, i64* %116
; # (push (val Z) Z P)
  %118 = alloca i64, i64 3, align 16
  %119 = ptrtoint i64* %118 to i64
  %120 = inttoptr i64 %119 to i64*
  store i64 %117, i64* %120
  %121 = add i64 %119, 8
  %122 = inttoptr i64 %121 to i64*
  store i64 %103, i64* %122
  %123 = add i64 %119, 16
  %124 = inttoptr i64 %123 to i64*
  store i64 %115, i64* %124
  %125 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %119, i64* %125
  br label %$41
$40:
  %126 = phi i64 [%110, %$38] ; # Y
  %127 = phi i64 [%111, %$38] ; # P
; # (let S (car Z) (set $Bind (setq P (push (val S) S P)) S (cdr Z)))...
; # (car Z)
  %128 = inttoptr i64 %103 to i64*
  %129 = load i64, i64* %128
; # (set $Bind (setq P (push (val S) S P)) S (cdr Z))
; # (val S)
  %130 = inttoptr i64 %129 to i64*
  %131 = load i64, i64* %130
; # (push (val S) S P)
  %132 = alloca i64, i64 3, align 16
  %133 = ptrtoint i64* %132 to i64
  %134 = inttoptr i64 %133 to i64*
  store i64 %131, i64* %134
  %135 = add i64 %133, 8
  %136 = inttoptr i64 %135 to i64*
  store i64 %129, i64* %136
  %137 = add i64 %133, 16
  %138 = inttoptr i64 %137 to i64*
  store i64 %127, i64* %138
  %139 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %133, i64* %139
; # (cdr Z)
  %140 = inttoptr i64 %103 to i64*
  %141 = getelementptr i64, i64* %140, i32 1
  %142 = load i64, i64* %141
  %143 = inttoptr i64 %129 to i64*
  store i64 %142, i64* %143
  br label %$41
$41:
  %144 = phi i64 [%114, %$39], [%126, %$40] ; # Y
  %145 = phi i64 [%119, %$39], [%133, %$40] ; # P
  %146 = phi i64 [%119, %$39], [%142, %$40] ; # ->
; # (? (atom Y))
; # (atom Y)
  %147 = and i64 %144, 15
  %148 = icmp ne i64 %147, 0
  br i1 %148, label %$43, label %$42
$42:
  %149 = phi i64 [%144, %$41] ; # Y
  %150 = phi i64 [%145, %$41] ; # P
  br label %$36
$43:
  %151 = phi i64 [%144, %$41] ; # Y
  %152 = phi i64 [%145, %$41] ; # P
  %153 = phi i64 [0, %$41] ; # ->
; # (prog1 (run X) (loop (set (val 2 P) (val P)) (? (== Q (setq P (va...
; # (run X)
  br label %$44
$44:
  %154 = phi i64 [%7, %$43], [%176, %$53] ; # Prg
  %155 = inttoptr i64 %154 to i64*
  %156 = load i64, i64* %155
  %157 = getelementptr i64, i64* %155, i32 1
  %158 = load i64, i64* %157
  %159 = and i64 %158, 15
  %160 = icmp ne i64 %159, 0
  br i1 %160, label %$47, label %$45
$47:
  %161 = phi i64 [%158, %$44] ; # Prg
  %162 = and i64 %156, 6
  %163 = icmp ne i64 %162, 0
  br i1 %163, label %$50, label %$49
$50:
  br label %$48
$49:
  %164 = and i64 %156, 8
  %165 = icmp ne i64 %164, 0
  br i1 %165, label %$52, label %$51
$52:
  %166 = inttoptr i64 %156 to i64*
  %167 = load i64, i64* %166
  br label %$48
$51:
  %168 = call i64 @evList(i64 %156)
  br label %$48
$48:
  %169 = phi i64 [%156, %$50], [%167, %$52], [%168, %$51] ; # ->
  br label %$46
$45:
  %170 = phi i64 [%158, %$44] ; # Prg
  %171 = and i64 %156, 15
  %172 = icmp eq i64 %171, 0
  br i1 %172, label %$54, label %$53
$54:
  %173 = phi i64 [%170, %$45] ; # Prg
  %174 = call i64 @evList(i64 %156)
  %175 = icmp ne i64 %174, 0
  br label %$53
$53:
  %176 = phi i64 [%170, %$45], [%173, %$54] ; # Prg
  %177 = phi i1 [0, %$45], [%175, %$54] ; # ->
  br label %$44
$46:
  %178 = phi i64 [%161, %$48] ; # Prg
  %179 = phi i64 [%169, %$48] ; # ->
; # (loop (set (val 2 P) (val P)) (? (== Q (setq P (val 3 P)))))
  br label %$55
$55:
  %180 = phi i64 [%151, %$46], [%192, %$56] ; # Y
  %181 = phi i64 [%152, %$46], [%193, %$56] ; # P
; # (set (val 2 P) (val P))
; # (val 2 P)
  %182 = inttoptr i64 %181 to i64*
  %183 = getelementptr i64, i64* %182, i32 1
  %184 = load i64, i64* %183
; # (val P)
  %185 = inttoptr i64 %181 to i64*
  %186 = load i64, i64* %185
  %187 = inttoptr i64 %184 to i64*
  store i64 %186, i64* %187
; # (? (== Q (setq P (val 3 P))))
; # (val 3 P)
  %188 = inttoptr i64 %181 to i64*
  %189 = getelementptr i64, i64* %188, i32 2
  %190 = load i64, i64* %189
; # (== Q (setq P (val 3 P)))
  %191 = icmp eq i64 %99, %190
  br i1 %191, label %$57, label %$56
$56:
  %192 = phi i64 [%180, %$55] ; # Y
  %193 = phi i64 [%190, %$55] ; # P
  br label %$55
$57:
  %194 = phi i64 [%180, %$55] ; # Y
  %195 = phi i64 [%190, %$55] ; # P
  %196 = phi i64 [0, %$55] ; # ->
; # (set $Bind P)
  %197 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %195, i64* %197
  br label %$7
$7:
  %198 = phi i64 [%21, %$14], [%51, %$27], [%194, %$57] ; # Y
  %199 = phi i64 [%47, %$14], [%89, %$27], [%179, %$57] ; # ->
  ret i64 %199
}

define i64 @_job(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) P (val $Bind) Q P) (whil...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (val $Bind)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %25 = load i64, i64* %24
; # (while (pair Y) (let (Z (++ Y) S (car Z)) (set $Bind (setq P (pus...
  br label %$7
$7:
  %26 = phi i64 [%15, %$2], [%35, %$8] ; # Y
  %27 = phi i64 [%25, %$2], [%41, %$8] ; # P
; # (pair Y)
  %28 = and i64 %26, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%26, %$7] ; # Y
  %31 = phi i64 [%27, %$7] ; # P
; # (let (Z (++ Y) S (car Z)) (set $Bind (setq P (push (val S) S P Z)...
; # (++ Y)
  %32 = inttoptr i64 %30 to i64*
  %33 = load i64, i64* %32
  %34 = getelementptr i64, i64* %32, i32 1
  %35 = load i64, i64* %34
; # (car Z)
  %36 = inttoptr i64 %33 to i64*
  %37 = load i64, i64* %36
; # (set $Bind (setq P (push (val S) S P Z)) S (cdr Z))
; # (val S)
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
; # (push (val S) S P Z)
  %40 = alloca i64, i64 4, align 16
  %41 = ptrtoint i64* %40 to i64
  %42 = inttoptr i64 %41 to i64*
  store i64 %39, i64* %42
  %43 = add i64 %41, 8
  %44 = inttoptr i64 %43 to i64*
  store i64 %37, i64* %44
  %45 = add i64 %41, 16
  %46 = inttoptr i64 %45 to i64*
  store i64 %31, i64* %46
  %47 = add i64 %41, 24
  %48 = inttoptr i64 %47 to i64*
  store i64 %33, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %41, i64* %49
; # (cdr Z)
  %50 = inttoptr i64 %33 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 %37 to i64*
  store i64 %52, i64* %53
  br label %$7
$9:
  %54 = phi i64 [%26, %$7] ; # Y
  %55 = phi i64 [%27, %$7] ; # P
; # (prog1 (run X) (until (== Q P) (let S (val 2 P) (set 2 (val 4 P) ...
; # (run X)
  br label %$10
$10:
  %56 = phi i64 [%7, %$9], [%78, %$19] ; # Prg
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
  %59 = getelementptr i64, i64* %57, i32 1
  %60 = load i64, i64* %59
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$13, label %$11
$13:
  %63 = phi i64 [%60, %$10] ; # Prg
  %64 = and i64 %58, 6
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$16, label %$15
$16:
  br label %$14
$15:
  %66 = and i64 %58, 8
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$18, label %$17
$18:
  %68 = inttoptr i64 %58 to i64*
  %69 = load i64, i64* %68
  br label %$14
$17:
  %70 = call i64 @evList(i64 %58)
  br label %$14
$14:
  %71 = phi i64 [%58, %$16], [%69, %$18], [%70, %$17] ; # ->
  br label %$12
$11:
  %72 = phi i64 [%60, %$10] ; # Prg
  %73 = and i64 %58, 15
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %$20, label %$19
$20:
  %75 = phi i64 [%72, %$11] ; # Prg
  %76 = call i64 @evList(i64 %58)
  %77 = icmp ne i64 %76, 0
  br label %$19
$19:
  %78 = phi i64 [%72, %$11], [%75, %$20] ; # Prg
  %79 = phi i1 [0, %$11], [%77, %$20] ; # ->
  br label %$10
$12:
  %80 = phi i64 [%63, %$14] ; # Prg
  %81 = phi i64 [%71, %$14] ; # ->
; # (until (== Q P) (let S (val 2 P) (set 2 (val 4 P) (val S)) (set S...
  br label %$21
$21:
  %82 = phi i64 [%54, %$12], [%85, %$22] ; # Y
  %83 = phi i64 [%55, %$12], [%102, %$22] ; # P
; # (== Q P)
  %84 = icmp eq i64 %25, %83
  br i1 %84, label %$23, label %$22
$22:
  %85 = phi i64 [%82, %$21] ; # Y
  %86 = phi i64 [%83, %$21] ; # P
; # (let S (val 2 P) (set 2 (val 4 P) (val S)) (set S (val P)))
; # (val 2 P)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
; # (set 2 (val 4 P) (val S))
; # (val 4 P)
  %90 = inttoptr i64 %86 to i64*
  %91 = getelementptr i64, i64* %90, i32 3
  %92 = load i64, i64* %91
; # (val S)
  %93 = inttoptr i64 %89 to i64*
  %94 = load i64, i64* %93
  %95 = inttoptr i64 %92 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %94, i64* %96
; # (set S (val P))
; # (val P)
  %97 = inttoptr i64 %86 to i64*
  %98 = load i64, i64* %97
  %99 = inttoptr i64 %89 to i64*
  store i64 %98, i64* %99
; # (val 3 P)
  %100 = inttoptr i64 %86 to i64*
  %101 = getelementptr i64, i64* %100, i32 2
  %102 = load i64, i64* %101
  br label %$21
$23:
  %103 = phi i64 [%82, %$21] ; # Y
  %104 = phi i64 [%83, %$21] ; # P
; # (set $Bind P)
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %104, i64* %105
; # (drop *Safe)
  %106 = inttoptr i64 %17 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
  %109 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %108, i64* %109
  ret i64 %81
}

define void @setDestruct(i64, i64) {
$1:
; # (loop (when (atom Val) (setq Val $Nil)) (let (P (++ Pat) V (++ Va...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%42, %$10] ; # Pat
  %3 = phi i64 [%1, %$1], [%43, %$10] ; # Val
; # (when (atom Val) (setq Val $Nil))
; # (atom Val)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$3, label %$4
$3:
  %6 = phi i64 [%2, %$2] ; # Pat
  %7 = phi i64 [%3, %$2] ; # Val
  br label %$4
$4:
  %8 = phi i64 [%2, %$2], [%6, %$3] ; # Pat
  %9 = phi i64 [%3, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # Val
; # (let (P (++ Pat) V (++ Val)) (if (atom P) (unless (nil? P) (set P...
; # (++ Pat)
  %10 = inttoptr i64 %8 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (++ Val)
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
; # (if (atom P) (unless (nil? P) (set P V)) (setDestruct P V))
; # (atom P)
  %18 = and i64 %11, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$5, label %$6
$5:
  %20 = phi i64 [%13, %$4] ; # Pat
  %21 = phi i64 [%17, %$4] ; # Val
; # (unless (nil? P) (set P V))
; # (nil? P)
  %22 = icmp eq i64 %11, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %22, label %$9, label %$8
$8:
  %23 = phi i64 [%20, %$5] ; # Pat
  %24 = phi i64 [%21, %$5] ; # Val
; # (set P V)
  %25 = inttoptr i64 %11 to i64*
  store i64 %15, i64* %25
  br label %$9
$9:
  %26 = phi i64 [%20, %$5], [%23, %$8] ; # Pat
  %27 = phi i64 [%21, %$5], [%24, %$8] ; # Val
  br label %$7
$6:
  %28 = phi i64 [%13, %$4] ; # Pat
  %29 = phi i64 [%17, %$4] ; # Val
; # (setDestruct P V)
  call void @setDestruct(i64 %11, i64 %15)
  br label %$7
$7:
  %30 = phi i64 [%26, %$9], [%28, %$6] ; # Pat
  %31 = phi i64 [%27, %$9], [%29, %$6] ; # Val
; # (? (atom Pat) (unless (nil? Pat) (set Pat Val)))
; # (atom Pat)
  %32 = and i64 %30, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$12, label %$10
$12:
  %34 = phi i64 [%30, %$7] ; # Pat
  %35 = phi i64 [%31, %$7] ; # Val
; # (unless (nil? Pat) (set Pat Val))
; # (nil? Pat)
  %36 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %36, label %$14, label %$13
$13:
  %37 = phi i64 [%34, %$12] ; # Pat
  %38 = phi i64 [%35, %$12] ; # Val
; # (set Pat Val)
  %39 = inttoptr i64 %37 to i64*
  store i64 %38, i64* %39
  br label %$14
$14:
  %40 = phi i64 [%34, %$12], [%37, %$13] ; # Pat
  %41 = phi i64 [%35, %$12], [%38, %$13] ; # Val
  br label %$11
$10:
  %42 = phi i64 [%30, %$7] ; # Pat
  %43 = phi i64 [%31, %$7] ; # Val
  br label %$2
$11:
  %44 = phi i64 [%40, %$14] ; # Pat
  %45 = phi i64 [%41, %$14] ; # Val
  ret void
}

define i64 @_let(i64) {
$1:
; # (let (X (cdr Exe) Y (++ X)) (if (atom Y) (let P (set $Bind (push ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (if (atom Y) (let P (set $Bind (push (val Y) Y (val $Bind))) (set...
; # (atom Y)
  %8 = and i64 %5, 15
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  %10 = phi i64 [%7, %$1] ; # X
  %11 = phi i64 [%5, %$1] ; # Y
; # (let P (set $Bind (push (val Y) Y (val $Bind))) (set Y (eval (++ ...
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %12 = inttoptr i64 %11 to i64*
  %13 = load i64, i64* %12
; # (val $Bind)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %15 = load i64, i64* %14
; # (push (val Y) Y (val $Bind))
  %16 = alloca i64, i64 3, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %13, i64* %18
  %19 = add i64 %17, 8
  %20 = inttoptr i64 %19 to i64*
  store i64 %11, i64* %20
  %21 = add i64 %17, 16
  %22 = inttoptr i64 %21 to i64*
  store i64 %15, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %17, i64* %23
; # (set Y (eval (++ X)))
; # (++ X)
  %24 = inttoptr i64 %10 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$7, label %$6
$7:
  br label %$5
$6:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$9, label %$8
$9:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$5
$8:
  %34 = call i64 @evList(i64 %25)
  br label %$5
$5:
  %35 = phi i64 [%25, %$7], [%33, %$9], [%34, %$8] ; # ->
  %36 = inttoptr i64 %11 to i64*
  store i64 %35, i64* %36
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$10
$10:
  %37 = phi i64 [%27, %$5], [%59, %$19] ; # Prg
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
  %40 = getelementptr i64, i64* %38, i32 1
  %41 = load i64, i64* %40
  %42 = and i64 %41, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$13, label %$11
$13:
  %44 = phi i64 [%41, %$10] ; # Prg
  %45 = and i64 %39, 6
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$16, label %$15
$16:
  br label %$14
$15:
  %47 = and i64 %39, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$18, label %$17
$18:
  %49 = inttoptr i64 %39 to i64*
  %50 = load i64, i64* %49
  br label %$14
$17:
  %51 = call i64 @evList(i64 %39)
  br label %$14
$14:
  %52 = phi i64 [%39, %$16], [%50, %$18], [%51, %$17] ; # ->
  br label %$12
$11:
  %53 = phi i64 [%41, %$10] ; # Prg
  %54 = and i64 %39, 15
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %$20, label %$19
$20:
  %56 = phi i64 [%53, %$11] ; # Prg
  %57 = call i64 @evList(i64 %39)
  %58 = icmp ne i64 %57, 0
  br label %$19
$19:
  %59 = phi i64 [%53, %$11], [%56, %$20] ; # Prg
  %60 = phi i1 [0, %$11], [%58, %$20] ; # ->
  br label %$10
$12:
  %61 = phi i64 [%44, %$14] ; # Prg
  %62 = phi i64 [%52, %$14] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %63 = inttoptr i64 %17 to i64*
  %64 = load i64, i64* %63
  %65 = inttoptr i64 %11 to i64*
  store i64 %64, i64* %65
; # (val 3 P)
  %66 = inttoptr i64 %17 to i64*
  %67 = getelementptr i64, i64* %66, i32 2
  %68 = load i64, i64* %67
  %69 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %68, i64* %69
  br label %$4
$3:
  %70 = phi i64 [%7, %$1] ; # X
  %71 = phi i64 [%5, %$1] ; # Y
; # (let (P (val $Bind) Q P) (loop (let Z (car Y) (if (atom Z) (set $...
; # (val $Bind)
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %73 = load i64, i64* %72
; # (loop (let Z (car Y) (if (atom Z) (set $Bind (setq P (push (val Z...
  br label %$21
$21:
  %74 = phi i64 [%70, %$3], [%282, %$54] ; # X
  %75 = phi i64 [%71, %$3], [%283, %$54] ; # Y
  %76 = phi i64 [%73, %$3], [%284, %$54] ; # P
; # (let Z (car Y) (if (atom Z) (set $Bind (setq P (push (val Z) Z P)...
; # (car Y)
  %77 = inttoptr i64 %75 to i64*
  %78 = load i64, i64* %77
; # (if (atom Z) (set $Bind (setq P (push (val Z) Z P)) Z (eval (car ...
; # (atom Z)
  %79 = and i64 %78, 15
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$22, label %$23
$22:
  %81 = phi i64 [%74, %$21] ; # X
  %82 = phi i64 [%75, %$21] ; # Y
  %83 = phi i64 [%76, %$21] ; # P
  %84 = phi i64 [%78, %$21] ; # Z
; # (set $Bind (setq P (push (val Z) Z P)) Z (eval (car (shift Y))))
; # (val Z)
  %85 = inttoptr i64 %84 to i64*
  %86 = load i64, i64* %85
; # (push (val Z) Z P)
  %87 = alloca i64, i64 3, align 16
  %88 = ptrtoint i64* %87 to i64
  %89 = inttoptr i64 %88 to i64*
  store i64 %86, i64* %89
  %90 = add i64 %88, 8
  %91 = inttoptr i64 %90 to i64*
  store i64 %84, i64* %91
  %92 = add i64 %88, 16
  %93 = inttoptr i64 %92 to i64*
  store i64 %83, i64* %93
  %94 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %88, i64* %94
; # (shift Y)
  %95 = inttoptr i64 %82 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
; # (car (shift Y))
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
; # (eval (car (shift Y)))
  %100 = and i64 %99, 6
  %101 = icmp ne i64 %100, 0
  br i1 %101, label %$27, label %$26
$27:
  br label %$25
$26:
  %102 = and i64 %99, 8
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$29, label %$28
$29:
  %104 = inttoptr i64 %99 to i64*
  %105 = load i64, i64* %104
  br label %$25
$28:
  %106 = call i64 @evList(i64 %99)
  br label %$25
$25:
  %107 = phi i64 [%99, %$27], [%105, %$29], [%106, %$28] ; # ->
  %108 = inttoptr i64 %84 to i64*
  store i64 %107, i64* %108
  br label %$24
$23:
  %109 = phi i64 [%74, %$21] ; # X
  %110 = phi i64 [%75, %$21] ; # Y
  %111 = phi i64 [%76, %$21] ; # P
  %112 = phi i64 [%78, %$21] ; # Z
; # (let Tos 0 (loop (loop (? (atom (car Z))) (let U Z (setq Z @) (se...
; # (loop (loop (? (atom (car Z))) (let U Z (setq Z @) (set U Tos) (s...
  br label %$30
$30:
  %113 = phi i64 [%109, %$23], [%249, %$38] ; # X
  %114 = phi i64 [%110, %$23], [%250, %$38] ; # Y
  %115 = phi i64 [%111, %$23], [%251, %$38] ; # P
  %116 = phi i64 [%112, %$23], [%252, %$38] ; # Z
  %117 = phi i64 [0, %$23], [%253, %$38] ; # Tos
; # (loop (? (atom (car Z))) (let U Z (setq Z @) (set U Tos) (setq To...
  br label %$31
$31:
  %118 = phi i64 [%113, %$30], [%127, %$32] ; # X
  %119 = phi i64 [%114, %$30], [%128, %$32] ; # Y
  %120 = phi i64 [%115, %$30], [%129, %$32] ; # P
  %121 = phi i64 [%116, %$30], [%124, %$32] ; # Z
  %122 = phi i64 [%117, %$30], [%130, %$32] ; # Tos
; # (? (atom (car Z)))
; # (car Z)
  %123 = inttoptr i64 %121 to i64*
  %124 = load i64, i64* %123
; # (atom (car Z))
  %125 = and i64 %124, 15
  %126 = icmp ne i64 %125, 0
  br i1 %126, label %$33, label %$32
$32:
  %127 = phi i64 [%118, %$31] ; # X
  %128 = phi i64 [%119, %$31] ; # Y
  %129 = phi i64 [%120, %$31] ; # P
  %130 = phi i64 [%121, %$31] ; # Z
  %131 = phi i64 [%122, %$31] ; # Tos
; # (let U Z (setq Z @) (set U Tos) (setq Tos U))
; # (set U Tos)
  %132 = inttoptr i64 %130 to i64*
  store i64 %131, i64* %132
  br label %$31
$33:
  %133 = phi i64 [%118, %$31] ; # X
  %134 = phi i64 [%119, %$31] ; # Y
  %135 = phi i64 [%120, %$31] ; # P
  %136 = phi i64 [%121, %$31] ; # Z
  %137 = phi i64 [%122, %$31] ; # Tos
  %138 = phi i64 [0, %$31] ; # ->
; # (let S (car Z) (unless (nil? S) (set $Bind (setq P (push (val S) ...
; # (car Z)
  %139 = inttoptr i64 %136 to i64*
  %140 = load i64, i64* %139
; # (unless (nil? S) (set $Bind (setq P (push (val S) S P))))
; # (nil? S)
  %141 = icmp eq i64 %140, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %141, label %$35, label %$34
$34:
  %142 = phi i64 [%133, %$33] ; # X
  %143 = phi i64 [%134, %$33] ; # Y
  %144 = phi i64 [%135, %$33] ; # P
  %145 = phi i64 [%136, %$33] ; # Z
  %146 = phi i64 [%137, %$33] ; # Tos
; # (set $Bind (setq P (push (val S) S P)))
; # (val S)
  %147 = inttoptr i64 %140 to i64*
  %148 = load i64, i64* %147
; # (push (val S) S P)
  %149 = alloca i64, i64 3, align 16
  %150 = ptrtoint i64* %149 to i64
  %151 = inttoptr i64 %150 to i64*
  store i64 %148, i64* %151
  %152 = add i64 %150, 8
  %153 = inttoptr i64 %152 to i64*
  store i64 %140, i64* %153
  %154 = add i64 %150, 16
  %155 = inttoptr i64 %154 to i64*
  store i64 %144, i64* %155
  %156 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %150, i64* %156
  br label %$35
$35:
  %157 = phi i64 [%133, %$33], [%142, %$34] ; # X
  %158 = phi i64 [%134, %$33], [%143, %$34] ; # Y
  %159 = phi i64 [%135, %$33], [%150, %$34] ; # P
  %160 = phi i64 [%136, %$33], [%145, %$34] ; # Z
  %161 = phi i64 [%137, %$33], [%146, %$34] ; # Tos
; # (loop (? (pair (cdr Z)) (let U Z (setq Z @) (set 2 U Tos) (setq T...
  br label %$36
$36:
  %162 = phi i64 [%157, %$35], [%243, %$46] ; # X
  %163 = phi i64 [%158, %$35], [%244, %$46] ; # Y
  %164 = phi i64 [%159, %$35], [%245, %$46] ; # P
  %165 = phi i64 [%160, %$35], [%246, %$46] ; # Z
  %166 = phi i64 [%161, %$35], [%247, %$46] ; # Tos
; # (? (pair (cdr Z)) (let U Z (setq Z @) (set 2 U Tos) (setq Tos (| ...
; # (cdr Z)
  %167 = inttoptr i64 %165 to i64*
  %168 = getelementptr i64, i64* %167, i32 1
  %169 = load i64, i64* %168
; # (pair (cdr Z))
  %170 = and i64 %169, 15
  %171 = icmp eq i64 %170, 0
  br i1 %171, label %$39, label %$37
$39:
  %172 = phi i64 [%162, %$36] ; # X
  %173 = phi i64 [%163, %$36] ; # Y
  %174 = phi i64 [%164, %$36] ; # P
  %175 = phi i64 [%165, %$36] ; # Z
  %176 = phi i64 [%166, %$36] ; # Tos
; # (let U Z (setq Z @) (set 2 U Tos) (setq Tos (| U 8)))
; # (set 2 U Tos)
  %177 = inttoptr i64 %175 to i64*
  %178 = getelementptr i64, i64* %177, i32 1
  store i64 %176, i64* %178
; # (| U 8)
  %179 = or i64 %175, 8
  br label %$38
$37:
  %180 = phi i64 [%162, %$36] ; # X
  %181 = phi i64 [%163, %$36] ; # Y
  %182 = phi i64 [%164, %$36] ; # P
  %183 = phi i64 [%165, %$36] ; # Z
  %184 = phi i64 [%166, %$36] ; # Tos
; # (let S @ (unless (nil? S) (set $Bind (setq P (push (val S) S P)))...
; # (unless (nil? S) (set $Bind (setq P (push (val S) S P))))
; # (nil? S)
  %185 = icmp eq i64 %169, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %185, label %$41, label %$40
$40:
  %186 = phi i64 [%180, %$37] ; # X
  %187 = phi i64 [%181, %$37] ; # Y
  %188 = phi i64 [%182, %$37] ; # P
  %189 = phi i64 [%183, %$37] ; # Z
  %190 = phi i64 [%184, %$37] ; # Tos
; # (set $Bind (setq P (push (val S) S P)))
; # (val S)
  %191 = inttoptr i64 %169 to i64*
  %192 = load i64, i64* %191
; # (push (val S) S P)
  %193 = alloca i64, i64 3, align 16
  %194 = ptrtoint i64* %193 to i64
  %195 = inttoptr i64 %194 to i64*
  store i64 %192, i64* %195
  %196 = add i64 %194, 8
  %197 = inttoptr i64 %196 to i64*
  store i64 %169, i64* %197
  %198 = add i64 %194, 16
  %199 = inttoptr i64 %198 to i64*
  store i64 %188, i64* %199
  %200 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %194, i64* %200
  br label %$41
$41:
  %201 = phi i64 [%180, %$37], [%186, %$40] ; # X
  %202 = phi i64 [%181, %$37], [%187, %$40] ; # Y
  %203 = phi i64 [%182, %$37], [%194, %$40] ; # P
  %204 = phi i64 [%183, %$37], [%189, %$40] ; # Z
  %205 = phi i64 [%184, %$37], [%190, %$40] ; # Tos
; # (loop (unless Tos (goto 1)) (? (=0 (& Tos 8)) (let U Tos (setq To...
  br label %$42
$42:
  %206 = phi i64 [%201, %$41], [%232, %$45] ; # X
  %207 = phi i64 [%202, %$41], [%233, %$45] ; # Y
  %208 = phi i64 [%203, %$41], [%234, %$45] ; # P
  %209 = phi i64 [%204, %$41], [%237, %$45] ; # Z
  %210 = phi i64 [%205, %$41], [%240, %$45] ; # Tos
; # (unless Tos (goto 1))
  %211 = icmp ne i64 %210, 0
  br i1 %211, label %$44, label %$43
$43:
  %212 = phi i64 [%206, %$42] ; # X
  %213 = phi i64 [%207, %$42] ; # Y
  %214 = phi i64 [%208, %$42] ; # P
  %215 = phi i64 [%209, %$42] ; # Z
  %216 = phi i64 [%210, %$42] ; # Tos
; # (goto 1)
  br label %$-1
$44:
  %217 = phi i64 [%206, %$42] ; # X
  %218 = phi i64 [%207, %$42] ; # Y
  %219 = phi i64 [%208, %$42] ; # P
  %220 = phi i64 [%209, %$42] ; # Z
  %221 = phi i64 [%210, %$42] ; # Tos
; # (? (=0 (& Tos 8)) (let U Tos (setq Tos (car U)) (set U Z) (setq Z...
; # (& Tos 8)
  %222 = and i64 %221, 8
; # (=0 (& Tos 8))
  %223 = icmp eq i64 %222, 0
  br i1 %223, label %$47, label %$45
$47:
  %224 = phi i64 [%217, %$44] ; # X
  %225 = phi i64 [%218, %$44] ; # Y
  %226 = phi i64 [%219, %$44] ; # P
  %227 = phi i64 [%220, %$44] ; # Z
  %228 = phi i64 [%221, %$44] ; # Tos
; # (let U Tos (setq Tos (car U)) (set U Z) (setq Z U))
; # (car U)
  %229 = inttoptr i64 %228 to i64*
  %230 = load i64, i64* %229
; # (set U Z)
  %231 = inttoptr i64 %228 to i64*
  store i64 %227, i64* %231
  br label %$46
$45:
  %232 = phi i64 [%217, %$44] ; # X
  %233 = phi i64 [%218, %$44] ; # Y
  %234 = phi i64 [%219, %$44] ; # P
  %235 = phi i64 [%220, %$44] ; # Z
  %236 = phi i64 [%221, %$44] ; # Tos
; # (let U (& Tos -9) (setq Tos (cdr U)) (set 2 U Z) (setq Z U))
; # (& Tos -9)
  %237 = and i64 %236, -9
; # (cdr U)
  %238 = inttoptr i64 %237 to i64*
  %239 = getelementptr i64, i64* %238, i32 1
  %240 = load i64, i64* %239
; # (set 2 U Z)
  %241 = inttoptr i64 %237 to i64*
  %242 = getelementptr i64, i64* %241, i32 1
  store i64 %235, i64* %242
  br label %$42
$46:
  %243 = phi i64 [%224, %$47] ; # X
  %244 = phi i64 [%225, %$47] ; # Y
  %245 = phi i64 [%226, %$47] ; # P
  %246 = phi i64 [%228, %$47] ; # Z
  %247 = phi i64 [%230, %$47] ; # Tos
  %248 = phi i64 [%228, %$47] ; # ->
  br label %$36
$38:
  %249 = phi i64 [%172, %$39] ; # X
  %250 = phi i64 [%173, %$39] ; # Y
  %251 = phi i64 [%174, %$39] ; # P
  %252 = phi i64 [%169, %$39] ; # Z
  %253 = phi i64 [%179, %$39] ; # Tos
  %254 = phi i64 [%179, %$39] ; # ->
  br label %$30
$48:
; # (: 1 (setDestruct (++ Y) (eval (car Y))))
  br label %$-1
$-1:
  %255 = phi i64 [%212, %$43], [%249, %$48] ; # X
  %256 = phi i64 [%213, %$43], [%250, %$48] ; # Y
  %257 = phi i64 [%214, %$43], [%251, %$48] ; # P
  %258 = phi i64 [%215, %$43], [%252, %$48] ; # Z
; # (++ Y)
  %259 = inttoptr i64 %256 to i64*
  %260 = load i64, i64* %259
  %261 = getelementptr i64, i64* %259, i32 1
  %262 = load i64, i64* %261
; # (car Y)
  %263 = inttoptr i64 %262 to i64*
  %264 = load i64, i64* %263
; # (eval (car Y))
  %265 = and i64 %264, 6
  %266 = icmp ne i64 %265, 0
  br i1 %266, label %$51, label %$50
$51:
  br label %$49
$50:
  %267 = and i64 %264, 8
  %268 = icmp ne i64 %267, 0
  br i1 %268, label %$53, label %$52
$53:
  %269 = inttoptr i64 %264 to i64*
  %270 = load i64, i64* %269
  br label %$49
$52:
  %271 = call i64 @evList(i64 %264)
  br label %$49
$49:
  %272 = phi i64 [%264, %$51], [%270, %$53], [%271, %$52] ; # ->
; # (setDestruct (++ Y) (eval (car Y)))
  call void @setDestruct(i64 %260, i64 %272)
  br label %$24
$24:
  %273 = phi i64 [%81, %$25], [%255, %$49] ; # X
  %274 = phi i64 [%97, %$25], [%262, %$49] ; # Y
  %275 = phi i64 [%88, %$25], [%257, %$49] ; # P
  %276 = phi i64 [%84, %$25], [%258, %$49] ; # Z
; # (? (atom (shift Y)))
; # (shift Y)
  %277 = inttoptr i64 %274 to i64*
  %278 = getelementptr i64, i64* %277, i32 1
  %279 = load i64, i64* %278
; # (atom (shift Y))
  %280 = and i64 %279, 15
  %281 = icmp ne i64 %280, 0
  br i1 %281, label %$55, label %$54
$54:
  %282 = phi i64 [%273, %$24] ; # X
  %283 = phi i64 [%279, %$24] ; # Y
  %284 = phi i64 [%275, %$24] ; # P
  br label %$21
$55:
  %285 = phi i64 [%273, %$24] ; # X
  %286 = phi i64 [%279, %$24] ; # Y
  %287 = phi i64 [%275, %$24] ; # P
  %288 = phi i64 [0, %$24] ; # ->
; # (prog1 (run X) (loop (set (val 2 P) (val P)) (? (== Q (setq P (va...
; # (run X)
  br label %$56
$56:
  %289 = phi i64 [%285, %$55], [%311, %$65] ; # Prg
  %290 = inttoptr i64 %289 to i64*
  %291 = load i64, i64* %290
  %292 = getelementptr i64, i64* %290, i32 1
  %293 = load i64, i64* %292
  %294 = and i64 %293, 15
  %295 = icmp ne i64 %294, 0
  br i1 %295, label %$59, label %$57
$59:
  %296 = phi i64 [%293, %$56] ; # Prg
  %297 = and i64 %291, 6
  %298 = icmp ne i64 %297, 0
  br i1 %298, label %$62, label %$61
$62:
  br label %$60
$61:
  %299 = and i64 %291, 8
  %300 = icmp ne i64 %299, 0
  br i1 %300, label %$64, label %$63
$64:
  %301 = inttoptr i64 %291 to i64*
  %302 = load i64, i64* %301
  br label %$60
$63:
  %303 = call i64 @evList(i64 %291)
  br label %$60
$60:
  %304 = phi i64 [%291, %$62], [%302, %$64], [%303, %$63] ; # ->
  br label %$58
$57:
  %305 = phi i64 [%293, %$56] ; # Prg
  %306 = and i64 %291, 15
  %307 = icmp eq i64 %306, 0
  br i1 %307, label %$66, label %$65
$66:
  %308 = phi i64 [%305, %$57] ; # Prg
  %309 = call i64 @evList(i64 %291)
  %310 = icmp ne i64 %309, 0
  br label %$65
$65:
  %311 = phi i64 [%305, %$57], [%308, %$66] ; # Prg
  %312 = phi i1 [0, %$57], [%310, %$66] ; # ->
  br label %$56
$58:
  %313 = phi i64 [%296, %$60] ; # Prg
  %314 = phi i64 [%304, %$60] ; # ->
; # (loop (set (val 2 P) (val P)) (? (== Q (setq P (val 3 P)))))
  br label %$67
$67:
  %315 = phi i64 [%285, %$58], [%328, %$68] ; # X
  %316 = phi i64 [%286, %$58], [%329, %$68] ; # Y
  %317 = phi i64 [%287, %$58], [%330, %$68] ; # P
; # (set (val 2 P) (val P))
; # (val 2 P)
  %318 = inttoptr i64 %317 to i64*
  %319 = getelementptr i64, i64* %318, i32 1
  %320 = load i64, i64* %319
; # (val P)
  %321 = inttoptr i64 %317 to i64*
  %322 = load i64, i64* %321
  %323 = inttoptr i64 %320 to i64*
  store i64 %322, i64* %323
; # (? (== Q (setq P (val 3 P))))
; # (val 3 P)
  %324 = inttoptr i64 %317 to i64*
  %325 = getelementptr i64, i64* %324, i32 2
  %326 = load i64, i64* %325
; # (== Q (setq P (val 3 P)))
  %327 = icmp eq i64 %73, %326
  br i1 %327, label %$69, label %$68
$68:
  %328 = phi i64 [%315, %$67] ; # X
  %329 = phi i64 [%316, %$67] ; # Y
  %330 = phi i64 [%326, %$67] ; # P
  br label %$67
$69:
  %331 = phi i64 [%315, %$67] ; # X
  %332 = phi i64 [%316, %$67] ; # Y
  %333 = phi i64 [%326, %$67] ; # P
  %334 = phi i64 [0, %$67] ; # ->
; # (set $Bind P)
  %335 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %333, i64* %335
  br label %$4
$4:
  %336 = phi i64 [%27, %$12], [%331, %$69] ; # X
  %337 = phi i64 [%11, %$12], [%332, %$69] ; # Y
  %338 = phi i64 [%62, %$12], [%314, %$69] ; # ->
  ret i64 %338
}

define i64 @_letQ(i64) {
$1:
; # (let (X (cdr Exe) Y (++ X)) (if (nil? (eval (car X))) @ (let P (s...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (if (nil? (eval (car X))) @ (let P (set $Bind (push (val Y) Y (va...
; # (car X)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car X))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (nil? (eval (car X)))
  %18 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %18, label %$7, label %$8
$7:
  br label %$9
$8:
; # (let P (set $Bind (push (val Y) Y (val $Bind))) (set Y @) (prog1 ...
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %19 = inttoptr i64 %5 to i64*
  %20 = load i64, i64* %19
; # (val $Bind)
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %22 = load i64, i64* %21
; # (push (val Y) Y (val $Bind))
  %23 = alloca i64, i64 3, align 16
  %24 = ptrtoint i64* %23 to i64
  %25 = inttoptr i64 %24 to i64*
  store i64 %20, i64* %25
  %26 = add i64 %24, 8
  %27 = inttoptr i64 %26 to i64*
  store i64 %5, i64* %27
  %28 = add i64 %24, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 %22, i64* %29
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %24, i64* %30
; # (set Y @)
  %31 = inttoptr i64 %5 to i64*
  store i64 %17, i64* %31
; # (prog1 (run (cdr X)) (set Y (val P) $Bind (val 3 P)))
; # (cdr X)
  %32 = inttoptr i64 %7 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (run (cdr X))
  br label %$10
$10:
  %35 = phi i64 [%34, %$8], [%57, %$19] ; # Prg
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
  %38 = getelementptr i64, i64* %36, i32 1
  %39 = load i64, i64* %38
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$13, label %$11
$13:
  %42 = phi i64 [%39, %$10] ; # Prg
  %43 = and i64 %37, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$16, label %$15
$16:
  br label %$14
$15:
  %45 = and i64 %37, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$18, label %$17
$18:
  %47 = inttoptr i64 %37 to i64*
  %48 = load i64, i64* %47
  br label %$14
$17:
  %49 = call i64 @evList(i64 %37)
  br label %$14
$14:
  %50 = phi i64 [%37, %$16], [%48, %$18], [%49, %$17] ; # ->
  br label %$12
$11:
  %51 = phi i64 [%39, %$10] ; # Prg
  %52 = and i64 %37, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$20, label %$19
$20:
  %54 = phi i64 [%51, %$11] ; # Prg
  %55 = call i64 @evList(i64 %37)
  %56 = icmp ne i64 %55, 0
  br label %$19
$19:
  %57 = phi i64 [%51, %$11], [%54, %$20] ; # Prg
  %58 = phi i1 [0, %$11], [%56, %$20] ; # ->
  br label %$10
$12:
  %59 = phi i64 [%42, %$14] ; # Prg
  %60 = phi i64 [%50, %$14] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %61 = inttoptr i64 %24 to i64*
  %62 = load i64, i64* %61
  %63 = inttoptr i64 %5 to i64*
  store i64 %62, i64* %63
; # (val 3 P)
  %64 = inttoptr i64 %24 to i64*
  %65 = getelementptr i64, i64* %64, i32 2
  %66 = load i64, i64* %65
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %66, i64* %67
  br label %$9
$9:
  %68 = phi i64 [%17, %$7], [%60, %$12] ; # ->
  ret i64 %68
}

define i64 @_use(i64) {
$1:
; # (let (X (cdr Exe) Y (++ X)) (if (atom Y) (let P (set $Bind (push ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (if (atom Y) (let P (set $Bind (push (val Y) Y (val $Bind))) (pro...
; # (atom Y)
  %8 = and i64 %5, 15
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  %10 = phi i64 [%5, %$1] ; # Y
; # (let P (set $Bind (push (val Y) Y (val $Bind))) (prog1 (run X) (s...
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (val $Bind)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %14 = load i64, i64* %13
; # (push (val Y) Y (val $Bind))
  %15 = alloca i64, i64 3, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %12, i64* %17
  %18 = add i64 %16, 8
  %19 = inttoptr i64 %18 to i64*
  store i64 %10, i64* %19
  %20 = add i64 %16, 16
  %21 = inttoptr i64 %20 to i64*
  store i64 %14, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %16, i64* %22
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$5
$5:
  %23 = phi i64 [%7, %$2], [%45, %$14] ; # Prg
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
  %28 = and i64 %27, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$8, label %$6
$8:
  %30 = phi i64 [%27, %$5] ; # Prg
  %31 = and i64 %25, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$10
$11:
  br label %$9
$10:
  %33 = and i64 %25, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$12
$13:
  %35 = inttoptr i64 %25 to i64*
  %36 = load i64, i64* %35
  br label %$9
$12:
  %37 = call i64 @evList(i64 %25)
  br label %$9
$9:
  %38 = phi i64 [%25, %$11], [%36, %$13], [%37, %$12] ; # ->
  br label %$7
$6:
  %39 = phi i64 [%27, %$5] ; # Prg
  %40 = and i64 %25, 15
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %$15, label %$14
$15:
  %42 = phi i64 [%39, %$6] ; # Prg
  %43 = call i64 @evList(i64 %25)
  %44 = icmp ne i64 %43, 0
  br label %$14
$14:
  %45 = phi i64 [%39, %$6], [%42, %$15] ; # Prg
  %46 = phi i1 [0, %$6], [%44, %$15] ; # ->
  br label %$5
$7:
  %47 = phi i64 [%30, %$9] ; # Prg
  %48 = phi i64 [%38, %$9] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %49 = inttoptr i64 %16 to i64*
  %50 = load i64, i64* %49
  %51 = inttoptr i64 %10 to i64*
  store i64 %50, i64* %51
; # (val 3 P)
  %52 = inttoptr i64 %16 to i64*
  %53 = getelementptr i64, i64* %52, i32 2
  %54 = load i64, i64* %53
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %54, i64* %55
  br label %$4
$3:
  %56 = phi i64 [%5, %$1] ; # Y
; # (let (P (val $Bind) Q P) (loop (let Z (car Y) (set $Bind (setq P ...
; # (val $Bind)
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %58 = load i64, i64* %57
; # (loop (let Z (car Y) (set $Bind (setq P (push (val Z) Z P)))) (? ...
  br label %$16
$16:
  %59 = phi i64 [%56, %$3], [%78, %$17] ; # Y
  %60 = phi i64 [%58, %$3], [%79, %$17] ; # P
; # (let Z (car Y) (set $Bind (setq P (push (val Z) Z P))))
; # (car Y)
  %61 = inttoptr i64 %59 to i64*
  %62 = load i64, i64* %61
; # (set $Bind (setq P (push (val Z) Z P)))
; # (val Z)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (push (val Z) Z P)
  %65 = alloca i64, i64 3, align 16
  %66 = ptrtoint i64* %65 to i64
  %67 = inttoptr i64 %66 to i64*
  store i64 %64, i64* %67
  %68 = add i64 %66, 8
  %69 = inttoptr i64 %68 to i64*
  store i64 %62, i64* %69
  %70 = add i64 %66, 16
  %71 = inttoptr i64 %70 to i64*
  store i64 %60, i64* %71
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %66, i64* %72
; # (? (atom (shift Y)))
; # (shift Y)
  %73 = inttoptr i64 %59 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
; # (atom (shift Y))
  %76 = and i64 %75, 15
  %77 = icmp ne i64 %76, 0
  br i1 %77, label %$18, label %$17
$17:
  %78 = phi i64 [%75, %$16] ; # Y
  %79 = phi i64 [%66, %$16] ; # P
  br label %$16
$18:
  %80 = phi i64 [%75, %$16] ; # Y
  %81 = phi i64 [%66, %$16] ; # P
  %82 = phi i64 [0, %$16] ; # ->
; # (prog1 (run X) (loop (set (val 2 P) (val P)) (? (== Q (setq P (va...
; # (run X)
  br label %$19
$19:
  %83 = phi i64 [%7, %$18], [%105, %$28] ; # Prg
  %84 = inttoptr i64 %83 to i64*
  %85 = load i64, i64* %84
  %86 = getelementptr i64, i64* %84, i32 1
  %87 = load i64, i64* %86
  %88 = and i64 %87, 15
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$22, label %$20
$22:
  %90 = phi i64 [%87, %$19] ; # Prg
  %91 = and i64 %85, 6
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$25, label %$24
$25:
  br label %$23
$24:
  %93 = and i64 %85, 8
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$27, label %$26
$27:
  %95 = inttoptr i64 %85 to i64*
  %96 = load i64, i64* %95
  br label %$23
$26:
  %97 = call i64 @evList(i64 %85)
  br label %$23
$23:
  %98 = phi i64 [%85, %$25], [%96, %$27], [%97, %$26] ; # ->
  br label %$21
$20:
  %99 = phi i64 [%87, %$19] ; # Prg
  %100 = and i64 %85, 15
  %101 = icmp eq i64 %100, 0
  br i1 %101, label %$29, label %$28
$29:
  %102 = phi i64 [%99, %$20] ; # Prg
  %103 = call i64 @evList(i64 %85)
  %104 = icmp ne i64 %103, 0
  br label %$28
$28:
  %105 = phi i64 [%99, %$20], [%102, %$29] ; # Prg
  %106 = phi i1 [0, %$20], [%104, %$29] ; # ->
  br label %$19
$21:
  %107 = phi i64 [%90, %$23] ; # Prg
  %108 = phi i64 [%98, %$23] ; # ->
; # (loop (set (val 2 P) (val P)) (? (== Q (setq P (val 3 P)))))
  br label %$30
$30:
  %109 = phi i64 [%80, %$21], [%121, %$31] ; # Y
  %110 = phi i64 [%81, %$21], [%122, %$31] ; # P
; # (set (val 2 P) (val P))
; # (val 2 P)
  %111 = inttoptr i64 %110 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  %113 = load i64, i64* %112
; # (val P)
  %114 = inttoptr i64 %110 to i64*
  %115 = load i64, i64* %114
  %116 = inttoptr i64 %113 to i64*
  store i64 %115, i64* %116
; # (? (== Q (setq P (val 3 P))))
; # (val 3 P)
  %117 = inttoptr i64 %110 to i64*
  %118 = getelementptr i64, i64* %117, i32 2
  %119 = load i64, i64* %118
; # (== Q (setq P (val 3 P)))
  %120 = icmp eq i64 %58, %119
  br i1 %120, label %$32, label %$31
$31:
  %121 = phi i64 [%109, %$30] ; # Y
  %122 = phi i64 [%119, %$30] ; # P
  br label %$30
$32:
  %123 = phi i64 [%109, %$30] ; # Y
  %124 = phi i64 [%119, %$30] ; # P
  %125 = phi i64 [0, %$30] ; # ->
; # (set $Bind P)
  %126 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %124, i64* %126
  br label %$4
$4:
  %127 = phi i64 [%10, %$7], [%123, %$32] ; # Y
  %128 = phi i64 [%48, %$7], [%108, %$32] ; # ->
  ret i64 %128
}

define i64 @_buf(i64) {
$1:
; # (let (X (cdr Exe) Y (++ X) Z (needCnt Exe (eval (++ X))) P (set $...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (++ X)
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
  %10 = getelementptr i64, i64* %8, i32 1
  %11 = load i64, i64* %10
; # (eval (++ X))
  %12 = and i64 %9, 6
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$4, label %$3
$4:
  br label %$2
$3:
  %14 = and i64 %9, 8
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$6, label %$5
$6:
  %16 = inttoptr i64 %9 to i64*
  %17 = load i64, i64* %16
  br label %$2
$5:
  %18 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %19 = phi i64 [%9, %$4], [%17, %$6], [%18, %$5] ; # ->
; # (needCnt Exe (eval (++ X)))
  %20 = and i64 %19, 2
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$8, label %$7
$7:
  call void @cntErr(i64 %0, i64 %19)
  unreachable
$8:
; # (set $Bind (push (val Y) Y (val $Bind)))
; # (val Y)
  %22 = inttoptr i64 %5 to i64*
  %23 = load i64, i64* %22
; # (val $Bind)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %25 = load i64, i64* %24
; # (push (val Y) Y (val $Bind))
  %26 = alloca i64, i64 3, align 16
  %27 = ptrtoint i64* %26 to i64
  %28 = inttoptr i64 %27 to i64*
  store i64 %23, i64* %28
  %29 = add i64 %27, 8
  %30 = inttoptr i64 %29 to i64*
  store i64 %5, i64* %30
  %31 = add i64 %27, 16
  %32 = inttoptr i64 %31 to i64*
  store i64 %25, i64* %32
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %27, i64* %33
; # (set Y (box64 (i64 (b8 (int Z)))))
; # (int Z)
  %34 = lshr i64 %19, 4
; # (b8 (int Z))
  %35 = alloca i8, i64 %34
; # (i64 (b8 (int Z)))
  %36 = ptrtoint i8* %35 to i64
; # (box64 (i64 (b8 (int Z))))
  %37 = and i64 %36, 17293822569102704640
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$9, label %$10
$9:
  %39 = call i64 @boxNum(i64 %36)
  br label %$11
$10:
  %40 = shl i64 %36, 4
  %41 = or i64 %40, 2
  br label %$11
$11:
  %42 = phi i64 [%39, %$9], [%41, %$10] ; # ->
  %43 = inttoptr i64 %5 to i64*
  store i64 %42, i64* %43
; # (prog1 (run X) (set Y (val P) $Bind (val 3 P)))
; # (run X)
  br label %$12
$12:
  %44 = phi i64 [%11, %$11], [%66, %$21] ; # Prg
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
  %47 = getelementptr i64, i64* %45, i32 1
  %48 = load i64, i64* %47
  %49 = and i64 %48, 15
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$15, label %$13
$15:
  %51 = phi i64 [%48, %$12] ; # Prg
  %52 = and i64 %46, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$18, label %$17
$18:
  br label %$16
$17:
  %54 = and i64 %46, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$20, label %$19
$20:
  %56 = inttoptr i64 %46 to i64*
  %57 = load i64, i64* %56
  br label %$16
$19:
  %58 = call i64 @evList(i64 %46)
  br label %$16
$16:
  %59 = phi i64 [%46, %$18], [%57, %$20], [%58, %$19] ; # ->
  br label %$14
$13:
  %60 = phi i64 [%48, %$12] ; # Prg
  %61 = and i64 %46, 15
  %62 = icmp eq i64 %61, 0
  br i1 %62, label %$22, label %$21
$22:
  %63 = phi i64 [%60, %$13] ; # Prg
  %64 = call i64 @evList(i64 %46)
  %65 = icmp ne i64 %64, 0
  br label %$21
$21:
  %66 = phi i64 [%60, %$13], [%63, %$22] ; # Prg
  %67 = phi i1 [0, %$13], [%65, %$22] ; # ->
  br label %$12
$14:
  %68 = phi i64 [%51, %$16] ; # Prg
  %69 = phi i64 [%59, %$16] ; # ->
; # (set Y (val P) $Bind (val 3 P))
; # (val P)
  %70 = inttoptr i64 %27 to i64*
  %71 = load i64, i64* %70
  %72 = inttoptr i64 %5 to i64*
  store i64 %71, i64* %72
; # (val 3 P)
  %73 = inttoptr i64 %27 to i64*
  %74 = getelementptr i64, i64* %73, i32 2
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %75, i64* %76
  ret i64 %69
}

define i64 @_catch(i64) {
$1:
; # (let (X (cdr Exe) Ca: (caFrame (b8 (+ (val JmpBufSize) (caFrame T...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val JmpBufSize)
  %4 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (caFrame T))
  %5 = add i64 %4, 216
; # (b8 (+ (val JmpBufSize) (caFrame T)))
  %6 = alloca i8, i64 %5
; # (Ca: tag (eval (++ X)))
  %7 = getelementptr i8, i8* %6, i32 8
  %8 = ptrtoint i8* %7 to i64
  %9 = inttoptr i64 %3 to i64*
  %10 = load i64, i64* %9
  %11 = getelementptr i64, i64* %9, i32 1
  %12 = load i64, i64* %11
  %13 = and i64 %10, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$4, label %$3
$4:
  br label %$2
$3:
  %15 = and i64 %10, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$6, label %$5
$6:
  %17 = inttoptr i64 %10 to i64*
  %18 = load i64, i64* %17
  br label %$2
$5:
  %19 = call i64 @evList(i64 %10)
  br label %$2
$2:
  %20 = phi i64 [%10, %$4], [%18, %$6], [%19, %$5] ; # ->
  %21 = inttoptr i64 %8 to i64*
  store i64 %20, i64* %21
; # (Ca: link (val $Catch))
  %22 = bitcast i8* %6 to i8**
  %23 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
  store i8* %23, i8** %22
; # (set $Catch (Ca:))
; # (Ca:)
  store i8* %6, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (Ca: fin ZERO)
  %24 = getelementptr i8, i8* %6, i32 16
  %25 = ptrtoint i8* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 2, i64* %26
; # (Ca: (env))
  %27 = getelementptr i8, i8* %6, i32 24
; # (i8* $Link)
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i8*
; # (memcpy (Ca: (env)) (env) (env T))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %27, i8* %28, i64 192, i1 0)
; # (prog1 (if (setjmp (Ca: (rst))) (val $Ret) (run X)) (set $Catch (...
; # (if (setjmp (Ca: (rst))) (val $Ret) (run X))
; # (Ca: (rst))
  %29 = getelementptr i8, i8* %6, i32 216
; # (setjmp (Ca: (rst)))
  %30 = call i32 @setjmp(i8* %29)
  %31 = icmp ne i32 %30, 0
  br i1 %31, label %$7, label %$8
$7:
  %32 = phi i64 [%12, %$2] ; # X
; # (val $Ret)
  %33 = load i64, i64* @$Ret
  br label %$9
$8:
  %34 = phi i64 [%12, %$2] ; # X
; # (run X)
  br label %$10
$10:
  %35 = phi i64 [%34, %$8], [%57, %$19] ; # Prg
  %36 = inttoptr i64 %35 to i64*
  %37 = load i64, i64* %36
  %38 = getelementptr i64, i64* %36, i32 1
  %39 = load i64, i64* %38
  %40 = and i64 %39, 15
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$13, label %$11
$13:
  %42 = phi i64 [%39, %$10] ; # Prg
  %43 = and i64 %37, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$16, label %$15
$16:
  br label %$14
$15:
  %45 = and i64 %37, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$18, label %$17
$18:
  %47 = inttoptr i64 %37 to i64*
  %48 = load i64, i64* %47
  br label %$14
$17:
  %49 = call i64 @evList(i64 %37)
  br label %$14
$14:
  %50 = phi i64 [%37, %$16], [%48, %$18], [%49, %$17] ; # ->
  br label %$12
$11:
  %51 = phi i64 [%39, %$10] ; # Prg
  %52 = and i64 %37, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$20, label %$19
$20:
  %54 = phi i64 [%51, %$11] ; # Prg
  %55 = call i64 @evList(i64 %37)
  %56 = icmp ne i64 %55, 0
  br label %$19
$19:
  %57 = phi i64 [%51, %$11], [%54, %$20] ; # Prg
  %58 = phi i1 [0, %$11], [%56, %$20] ; # ->
  br label %$10
$12:
  %59 = phi i64 [%42, %$14] ; # Prg
  %60 = phi i64 [%50, %$14] ; # ->
  br label %$9
$9:
  %61 = phi i64 [%32, %$7], [%34, %$12] ; # X
  %62 = phi i64 [%33, %$7], [%60, %$12] ; # ->
; # (set $Catch (Ca: link))
; # (Ca: link)
  %63 = bitcast i8* %6 to i8**
  %64 = load i8*, i8** %63
  store i8* %64, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
  ret i64 %62
}

define i64 @_throw(i64) {
$1:
; # (let (X (cdr Exe) Tag (eval (++ X))) (set $Ret (eval (car X))) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (set $Ret (eval (car X)))
; # (car X)
  %16 = inttoptr i64 %7 to i64*
  %17 = load i64, i64* %16
; # (eval (car X))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$8
$9:
  br label %$7
$8:
  %20 = and i64 %17, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$10
$11:
  %22 = inttoptr i64 %17 to i64*
  %23 = load i64, i64* %22
  br label %$7
$10:
  %24 = call i64 @evList(i64 %17)
  br label %$7
$7:
  %25 = phi i64 [%17, %$9], [%23, %$11], [%24, %$10] ; # ->
  store i64 %25, i64* @$Ret
; # (let Ca (val $Catch) (while Ca (let Ca: (caFrame Ca) (when (or (=...
; # (val $Catch)
  %26 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (while Ca (let Ca: (caFrame Ca) (when (or (== $T (Ca: tag)) (== T...
  br label %$12
$12:
  %27 = phi i8* [%26, %$7], [%47, %$18] ; # Ca
  %28 = icmp ne i8* %27, null
  br i1 %28, label %$13, label %$14
$13:
  %29 = phi i8* [%27, %$12] ; # Ca
; # (let Ca: (caFrame Ca) (when (or (== $T (Ca: tag)) (== Tag (Ca: ta...
; # (when (or (== $T (Ca: tag)) (== Tag (Ca: tag))) (unwind Ca) (long...
; # (or (== $T (Ca: tag)) (== Tag (Ca: tag)))
; # (Ca: tag)
  %30 = getelementptr i8, i8* %29, i32 8
  %31 = ptrtoint i8* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  %33 = load i64, i64* %32
; # (== $T (Ca: tag))
  %34 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %33
  br i1 %34, label %$15, label %$16
$16:
  %35 = phi i8* [%29, %$13] ; # Ca
; # (Ca: tag)
  %36 = getelementptr i8, i8* %29, i32 8
  %37 = ptrtoint i8* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
; # (== Tag (Ca: tag))
  %40 = icmp eq i64 %15, %39
  br label %$15
$15:
  %41 = phi i8* [%29, %$13], [%35, %$16] ; # Ca
  %42 = phi i1 [1, %$13], [%40, %$16] ; # ->
  br i1 %42, label %$17, label %$18
$17:
  %43 = phi i8* [%41, %$15] ; # Ca
; # (unwind Ca)
  call void @unwind(i8* %43)
; # (Ca: (rst))
  %44 = getelementptr i8, i8* %29, i32 216
; # (longjmp (Ca: (rst)) 1)
  call void @longjmp(i8* %44, i32 1)
  unreachable
$18:
  %45 = phi i8* [%41, %$15] ; # Ca
; # (Ca: link)
  %46 = bitcast i8* %29 to i8**
  %47 = load i8*, i8** %46
  br label %$12
$14:
  %48 = phi i8* [%27, %$12] ; # Ca
; # (err Exe Tag ($ "Tag not found") null)
  call void @err(i64 %0, i64 %15, i8* bitcast ([14 x i8]* @$62 to i8*), i8* null)
  unreachable
}

define i64 @_finally(i64) {
$1:
; # (let (X (cdr Exe) Ca: (caFrame (b8 (+ (val JmpBufSize) (caFrame T...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val JmpBufSize)
  %4 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (caFrame T))
  %5 = add i64 %4, 216
; # (b8 (+ (val JmpBufSize) (caFrame T)))
  %6 = alloca i8, i64 %5
; # (Ca: tag 0)
  %7 = getelementptr i8, i8* %6, i32 8
  %8 = ptrtoint i8* %7 to i64
  %9 = inttoptr i64 %8 to i64*
  store i64 0, i64* %9
; # (Ca: link (val $Catch))
  %10 = bitcast i8* %6 to i8**
  %11 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
  store i8* %11, i8** %10
; # (set $Catch (Ca:))
; # (Ca:)
  store i8* %6, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (Ca: fin (++ X))
  %12 = getelementptr i8, i8* %6, i32 16
  %13 = ptrtoint i8* %12 to i64
  %14 = inttoptr i64 %3 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
  %18 = inttoptr i64 %13 to i64*
  store i64 %15, i64* %18
; # (Ca: (env))
  %19 = getelementptr i8, i8* %6, i32 24
; # (i8* $Link)
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i8*
; # (memcpy (Ca: (env)) (env) (env T))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* %20, i64 192, i1 0)
; # (prog1 (save (run X)) (eval (Ca: fin)) (set $Catch (Ca: link)))
; # (run X)
  br label %$2
$2:
  %21 = phi i64 [%17, %$1], [%43, %$11] ; # Prg
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  %24 = getelementptr i64, i64* %22, i32 1
  %25 = load i64, i64* %24
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$5, label %$3
$5:
  %28 = phi i64 [%25, %$2] ; # Prg
  %29 = and i64 %23, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$8, label %$7
$8:
  br label %$6
$7:
  %31 = and i64 %23, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$10, label %$9
$10:
  %33 = inttoptr i64 %23 to i64*
  %34 = load i64, i64* %33
  br label %$6
$9:
  %35 = call i64 @evList(i64 %23)
  br label %$6
$6:
  %36 = phi i64 [%23, %$8], [%34, %$10], [%35, %$9] ; # ->
  br label %$4
$3:
  %37 = phi i64 [%25, %$2] ; # Prg
  %38 = and i64 %23, 15
  %39 = icmp eq i64 %38, 0
  br i1 %39, label %$12, label %$11
$12:
  %40 = phi i64 [%37, %$3] ; # Prg
  %41 = call i64 @evList(i64 %23)
  %42 = icmp ne i64 %41, 0
  br label %$11
$11:
  %43 = phi i64 [%37, %$3], [%40, %$12] ; # Prg
  %44 = phi i1 [0, %$3], [%42, %$12] ; # ->
  br label %$2
$4:
  %45 = phi i64 [%28, %$6] ; # Prg
  %46 = phi i64 [%36, %$6] ; # ->
; # (save (run X))
  %47 = alloca i64, i64 2, align 16
  %48 = ptrtoint i64* %47 to i64
  %49 = inttoptr i64 %48 to i64*
  store i64 %46, i64* %49
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %51 = load i64, i64* %50
  %52 = inttoptr i64 %48 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  store i64 %51, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %54
; # (Ca: fin)
  %55 = getelementptr i8, i8* %6, i32 16
  %56 = ptrtoint i8* %55 to i64
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
; # (eval (Ca: fin))
  %59 = and i64 %58, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$15, label %$14
$15:
  br label %$13
$14:
  %61 = and i64 %58, 8
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$17, label %$16
$17:
  %63 = inttoptr i64 %58 to i64*
  %64 = load i64, i64* %63
  br label %$13
$16:
  %65 = call i64 @evList(i64 %58)
  br label %$13
$13:
  %66 = phi i64 [%58, %$15], [%64, %$17], [%65, %$16] ; # ->
; # (set $Catch (Ca: link))
; # (Ca: link)
  %67 = bitcast i8* %6 to i8**
  %68 = load i8*, i8** %67
  store i8* %68, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 24) to i8**)
; # (drop *Safe)
  %69 = inttoptr i64 %48 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  ret i64 %46
}

define void @saveCoEnv(i8*) {
$1:
; # (let Src: (coroutine Src) (Src: at (val $At)) (memcpy (Src: (env)...
; # (Src: at (val $At))
  %1 = getelementptr i8, i8* %0, i32 32
  %2 = ptrtoint i8* %1 to i64
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %4 = load i64, i64* %3
  %5 = inttoptr i64 %2 to i64*
  store i64 %4, i64* %5
; # (Src: (env))
  %6 = getelementptr i8, i8* %0, i32 40
; # (i8* $Link)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i8*
; # (memcpy (Src: (env)) (env) (env T))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 192, i1 0)
  ret void
}

define i64 @loadCoEnv(i8*) {
$1:
; # (let Src: (coroutine Src) (memcpy (env) (Src: (env)) (env T)) (se...
; # (i8* $Link)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i8*
; # (Src: (env))
  %2 = getelementptr i8, i8* %0, i32 40
; # (memcpy (env) (Src: (env)) (env T))
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 192, i1 0)
; # (set $At (Src: at))
; # (Src: at)
  %3 = getelementptr i8, i8* %0, i32 32
  %4 = ptrtoint i8* %3 to i64
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %6, i64* %7
; # (Src: at 0)
  %8 = getelementptr i8, i8* %0, i32 32
  %9 = ptrtoint i8* %8 to i64
  %10 = inttoptr i64 %9 to i64*
  store i64 0, i64* %10
; # (val $Ret)
  %11 = load i64, i64* @$Ret
  ret i64 %11
}

define i64 @_co(i64) {
$1:
; # (let (X (cdr Exe) Tag (eval (++ X))) (unless (val $Coroutines) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (unless (val $Coroutines) (let Main: (coroutine (alloc null (+ (v...
; # (val $Coroutines)
  %16 = load i8*, i8** @$Coroutines
  %17 = icmp ne i8* %16, null
  br i1 %17, label %$8, label %$7
$7:
; # (let Main: (coroutine (alloc null (+ (val JmpBufSize) (coroutine ...
; # (val JmpBufSize)
  %18 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (coroutine T))
  %19 = add i64 %18, 232
; # (alloc null (+ (val JmpBufSize) (coroutine T)))
  %20 = call i8* @alloc(i8* null, i64 %19)
; # (Main: tag $T)
  %21 = ptrtoint i8* %20 to i64
  %22 = inttoptr i64 %21 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), i64* %22
; # (Main: next null)
  %23 = getelementptr i8, i8* %20, i32 8
  %24 = bitcast i8* %23 to i8**
  store i8* null, i8** %24
; # (Main: prg $Nil)
  %25 = getelementptr i8, i8* %20, i32 16
  %26 = ptrtoint i8* %25 to i64
  %27 = inttoptr i64 %26 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %27
; # (Main: lim null)
  %28 = getelementptr i8, i8* %20, i32 24
  %29 = bitcast i8* %28 to i8**
  store i8* null, i8** %29
; # (Main: at 0)
  %30 = getelementptr i8, i8* %20, i32 32
  %31 = ptrtoint i8* %30 to i64
  %32 = inttoptr i64 %31 to i64*
  store i64 0, i64* %32
; # (set $Coroutines (Main:))
; # (Main:)
  store i8* %20, i8** @$Coroutines
; # (let Co: (coFrame (alloc null (coFrame T))) (Co: link null) (Co: ...
; # (alloc null (coFrame T))
  %33 = call i8* @alloc(i8* null, i64 16)
; # (Co: link null)
  %34 = bitcast i8* %33 to i8**
  store i8* null, i8** %34
; # (Co: crt (Main:))
  %35 = getelementptr i8, i8* %33, i32 8
  %36 = bitcast i8* %35 to i8**
  store i8* %20, i8** %36
; # (set $CoFrames (Co:))
; # (Co:)
  store i8* %33, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
  br label %$8
$8:
; # (if (atom X) (let Crt (val $Coroutines) (loop (let Crt: (coroutin...
; # (atom X)
  %37 = and i64 %7, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$9, label %$10
$9:
; # (let Crt (val $Coroutines) (loop (let Crt: (coroutine Crt) (? (==...
; # (val $Coroutines)
  %39 = load i8*, i8** @$Coroutines
; # (loop (let Crt: (coroutine Crt) (? (== Tag (Crt: tag)) (Crt: tag ...
  br label %$12
$12:
  %40 = phi i8* [%39, %$9], [%53, %$16] ; # Crt
; # (let Crt: (coroutine Crt) (? (== Tag (Crt: tag)) (Crt: tag 0)) (?...
; # (? (== Tag (Crt: tag)) (Crt: tag 0))
; # (Crt: tag)
  %41 = ptrtoint i8* %40 to i64
  %42 = inttoptr i64 %41 to i64*
  %43 = load i64, i64* %42
; # (== Tag (Crt: tag))
  %44 = icmp eq i64 %15, %43
  br i1 %44, label %$15, label %$13
$15:
  %45 = phi i8* [%40, %$12] ; # Crt
; # (Crt: tag 0)
  %46 = ptrtoint i8* %40 to i64
  %47 = inttoptr i64 %46 to i64*
  store i64 0, i64* %47
  br label %$14
$13:
  %48 = phi i8* [%40, %$12] ; # Crt
; # (? (=0 (setq Crt (Crt: next))))
; # (Crt: next)
  %49 = getelementptr i8, i8* %40, i32 8
  %50 = bitcast i8* %49 to i8**
  %51 = load i8*, i8** %50
; # (=0 (setq Crt (Crt: next)))
  %52 = icmp eq i8* %51, null
  br i1 %52, label %$14, label %$16
$16:
  %53 = phi i8* [%51, %$13] ; # Crt
  br label %$12
$14:
  %54 = phi i8* [%45, %$15], [%51, %$13] ; # Crt
  %55 = phi i64 [0, %$15], [0, %$13] ; # ->
  br label %$11
$10:
; # (let (Src ((coFrame (val $CoFrames)) crt) Crt (val $Coroutines) P...
; # (val $CoFrames)
  %56 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
; # ((coFrame (val $CoFrames)) crt)
  %57 = getelementptr i8, i8* %56, i32 8
  %58 = bitcast i8* %57 to i8**
  %59 = load i8*, i8** %58
; # (val $Coroutines)
  %60 = load i8*, i8** @$Coroutines
; # (i8* null)
  %61 = inttoptr i64 0 to i8*
; # (saveCoEnv Src)
  call void @saveCoEnv(i8* %59)
; # (loop (let Crt: (coroutine Crt) (when (== Tag (Crt: tag)) (unless...
  br label %$17
$17:
  %62 = phi i8* [%60, %$10], [%112, %$26] ; # Crt
  %63 = phi i8* [%61, %$10], [%109, %$26] ; # P
; # (let Crt: (coroutine Crt) (when (== Tag (Crt: tag)) (unless ((cor...
; # (when (== Tag (Crt: tag)) (unless ((coroutine Crt) at) (err Exe T...
; # (Crt: tag)
  %64 = ptrtoint i8* %62 to i64
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
; # (== Tag (Crt: tag))
  %67 = icmp eq i64 %15, %66
  br i1 %67, label %$18, label %$19
$18:
  %68 = phi i8* [%62, %$17] ; # Crt
  %69 = phi i8* [%63, %$17] ; # P
; # (unless ((coroutine Crt) at) (err Exe Tag ($ "Reentrant coroutine...
; # ((coroutine Crt) at)
  %70 = getelementptr i8, i8* %68, i32 32
  %71 = ptrtoint i8* %70 to i64
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$21, label %$20
$20:
  %75 = phi i8* [%68, %$18] ; # Crt
  %76 = phi i8* [%69, %$18] ; # P
; # (err Exe Tag ($ "Reentrant coroutine") null)
  call void @err(i64 %0, i64 %15, i8* bitcast ([20 x i8]* @$63 to i8*), i8* null)
  unreachable
$21:
  %77 = phi i8* [%68, %$18] ; # Crt
  %78 = phi i8* [%69, %$18] ; # P
; # (when (setjmp ((coroutine Src) (rst))) (ret (loadCoEnv ((coFrame ...
; # ((coroutine Src) (rst))
  %79 = getelementptr i8, i8* %59, i32 232
; # (setjmp ((coroutine Src) (rst)))
  %80 = call i32 @setjmp(i8* %79)
  %81 = icmp ne i32 %80, 0
  br i1 %81, label %$22, label %$23
$22:
  %82 = phi i8* [%77, %$21] ; # Crt
  %83 = phi i8* [%78, %$21] ; # P
; # (val $CoFrames)
  %84 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
; # (i8** (val $CoFrames))
  %85 = bitcast i8* %84 to i8**
; # (val (i8** (val $CoFrames)))
  %86 = load i8*, i8** %85
; # ((coFrame (val (i8** (val $CoFrames)))) crt)
  %87 = getelementptr i8, i8* %86, i32 8
  %88 = bitcast i8* %87 to i8**
  %89 = load i8*, i8** %88
; # (loadCoEnv ((coFrame (val (i8** (val $CoFrames)))) crt))
  %90 = call i64 @loadCoEnv(i8* %89)
; # (ret (loadCoEnv ((coFrame (val (i8** (val $CoFrames)))) crt)))
  ret i64 %90
$23:
  %91 = phi i8* [%77, %$21] ; # Crt
  %92 = phi i8* [%78, %$21] ; # P
; # (set $Ret $Nil)
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* @$Ret
; # (Crt: (rst))
  %93 = getelementptr i8, i8* %62, i32 232
; # (longjmp (Crt: (rst)) 1)
  call void @longjmp(i8* %93, i32 1)
  unreachable
$19:
  %94 = phi i8* [%62, %$17] ; # Crt
  %95 = phi i8* [%63, %$17] ; # P
; # (unless (Crt: tag) (setq P Crt))
; # (Crt: tag)
  %96 = ptrtoint i8* %62 to i64
  %97 = inttoptr i64 %96 to i64*
  %98 = load i64, i64* %97
  %99 = icmp ne i64 %98, 0
  br i1 %99, label %$25, label %$24
$24:
  %100 = phi i8* [%94, %$19] ; # Crt
  %101 = phi i8* [%95, %$19] ; # P
  br label %$25
$25:
  %102 = phi i8* [%94, %$19], [%100, %$24] ; # Crt
  %103 = phi i8* [%95, %$19], [%100, %$24] ; # P
; # (? (=0 (Crt: next)))
; # (Crt: next)
  %104 = getelementptr i8, i8* %62, i32 8
  %105 = bitcast i8* %104 to i8**
  %106 = load i8*, i8** %105
; # (=0 (Crt: next))
  %107 = icmp eq i8* %106, null
  br i1 %107, label %$27, label %$26
$26:
  %108 = phi i8* [%102, %$25] ; # Crt
  %109 = phi i8* [%103, %$25] ; # P
; # (Crt: next)
  %110 = getelementptr i8, i8* %62, i32 8
  %111 = bitcast i8* %110 to i8**
  %112 = load i8*, i8** %111
  br label %$17
$27:
  %113 = phi i8* [%102, %$25] ; # Crt
  %114 = phi i8* [%103, %$25] ; # P
  %115 = phi i64 [0, %$25] ; # ->
; # (when (setjmp ((coroutine Src) (rst))) (ret (loadCoEnv ((coFrame ...
; # ((coroutine Src) (rst))
  %116 = getelementptr i8, i8* %59, i32 232
; # (setjmp ((coroutine Src) (rst)))
  %117 = call i32 @setjmp(i8* %116)
  %118 = icmp ne i32 %117, 0
  br i1 %118, label %$28, label %$29
$28:
  %119 = phi i8* [%113, %$27] ; # Crt
  %120 = phi i8* [%114, %$27] ; # P
; # (val $CoFrames)
  %121 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
; # (i8** (val $CoFrames))
  %122 = bitcast i8* %121 to i8**
; # (val (i8** (val $CoFrames)))
  %123 = load i8*, i8** %122
; # ((coFrame (val (i8** (val $CoFrames)))) crt)
  %124 = getelementptr i8, i8* %123, i32 8
  %125 = bitcast i8* %124 to i8**
  %126 = load i8*, i8** %125
; # (loadCoEnv ((coFrame (val (i8** (val $CoFrames)))) crt))
  %127 = call i64 @loadCoEnv(i8* %126)
; # (ret (loadCoEnv ((coFrame (val (i8** (val $CoFrames)))) crt)))
  ret i64 %127
$29:
  %128 = phi i8* [%113, %$27] ; # Crt
  %129 = phi i8* [%114, %$27] ; # P
; # (if P (stack P) (stack (if (== Crt (val $Coroutines)) (ofs (stack...
  %130 = icmp ne i8* %129, null
  br i1 %130, label %$30, label %$31
$30:
  %131 = phi i8* [%128, %$29] ; # Crt
  %132 = phi i8* [%129, %$29] ; # P
; # (stack P)
  call void @llvm.stackrestore(i8* %132)
  br label %$32
$31:
  %133 = phi i8* [%128, %$29] ; # Crt
  %134 = phi i8* [%129, %$29] ; # P
; # (if (== Crt (val $Coroutines)) (ofs (stack) (* -4 (val $StkSize))...
; # (val $Coroutines)
  %135 = load i8*, i8** @$Coroutines
; # (== Crt (val $Coroutines))
  %136 = icmp eq i8* %133, %135
  br i1 %136, label %$33, label %$34
$33:
  %137 = phi i8* [%133, %$31] ; # Crt
  %138 = phi i8* [%134, %$31] ; # P
; # (stack)
  %139 = call i8* @llvm.stacksave()
; # (val $StkSize)
  %140 = load i64, i64* @$StkSize
; # (* -4 (val $StkSize))
  %141 = mul i64 -4, %140
; # (ofs (stack) (* -4 (val $StkSize)))
  %142 = getelementptr i8, i8* %139, i64 %141
  br label %$35
$34:
  %143 = phi i8* [%133, %$31] ; # Crt
  %144 = phi i8* [%134, %$31] ; # P
; # (val $StkSize)
  %145 = load i64, i64* @$StkSize
; # (- (val $StkSize))
  %146 = sub i64 0, %145
; # (ofs Crt (- (val $StkSize)))
  %147 = getelementptr i8, i8* %143, i64 %146
  br label %$35
$35:
  %148 = phi i8* [%137, %$33], [%143, %$34] ; # Crt
  %149 = phi i8* [%138, %$33], [%144, %$34] ; # P
  %150 = phi i8* [%142, %$33], [%147, %$34] ; # ->
; # (stack (if (== Crt (val $Coroutines)) (ofs (stack) (* -4 (val $St...
  call void @llvm.stackrestore(i8* %150)
; # (val JmpBufSize)
  %151 = load i64, i64* @JmpBufSize
; # (+ (val JmpBufSize) (coroutine T))
  %152 = add i64 %151, 232
; # (b8 (+ (val JmpBufSize) (coroutine T)))
  %153 = alloca i8, i64 %152
; # ((coroutine Crt) next P)
  %154 = getelementptr i8, i8* %148, i32 8
  %155 = bitcast i8* %154 to i8**
  store i8* %153, i8** %155
; # ((coroutine P) next null)
  %156 = getelementptr i8, i8* %153, i32 8
  %157 = bitcast i8* %156 to i8**
  store i8* null, i8** %157
  br label %$32
$32:
  %158 = phi i8* [%131, %$30], [%148, %$35] ; # Crt
  %159 = phi i8* [%132, %$30], [%153, %$35] ; # P
; # (let (Co: (coFrame (b8 (coFrame T))) Dst: (coroutine P)) (Co: lin...
; # (b8 (coFrame T))
  %160 = alloca i8, i64 16
; # (Co: link (val $CoFrames))
  %161 = bitcast i8* %160 to i8**
  %162 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
  store i8* %162, i8** %161
; # (Co: crt P)
  %163 = getelementptr i8, i8* %160, i32 8
  %164 = bitcast i8* %163 to i8**
  store i8* %159, i8** %164
; # (set $CoFrames (Co:))
; # (Co:)
  store i8* %160, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
; # (Dst: tag Tag)
  %165 = ptrtoint i8* %159 to i64
  %166 = inttoptr i64 %165 to i64*
  store i64 %15, i64* %166
; # (Dst: prg X)
  %167 = getelementptr i8, i8* %159, i32 16
  %168 = ptrtoint i8* %167 to i64
  %169 = inttoptr i64 %168 to i64*
  store i64 %7, i64* %169
; # (Dst: lim null)
  %170 = getelementptr i8, i8* %159, i32 24
  %171 = bitcast i8* %170 to i8**
  store i8* null, i8** %171
; # (Dst: at 0)
  %172 = getelementptr i8, i8* %159, i32 32
  %173 = ptrtoint i8* %172 to i64
  %174 = inttoptr i64 %173 to i64*
  store i64 0, i64* %174
; # (set $Make 0 $Yoke 0)
  %175 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 0, i64* %175
  %176 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  store i64 0, i64* %176
; # (set $Ret (run X))
; # (run X)
  br label %$36
$36:
  %177 = phi i64 [%7, %$32], [%199, %$45] ; # Prg
  %178 = inttoptr i64 %177 to i64*
  %179 = load i64, i64* %178
  %180 = getelementptr i64, i64* %178, i32 1
  %181 = load i64, i64* %180
  %182 = and i64 %181, 15
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$39, label %$37
$39:
  %184 = phi i64 [%181, %$36] ; # Prg
  %185 = and i64 %179, 6
  %186 = icmp ne i64 %185, 0
  br i1 %186, label %$42, label %$41
$42:
  br label %$40
$41:
  %187 = and i64 %179, 8
  %188 = icmp ne i64 %187, 0
  br i1 %188, label %$44, label %$43
$44:
  %189 = inttoptr i64 %179 to i64*
  %190 = load i64, i64* %189
  br label %$40
$43:
  %191 = call i64 @evList(i64 %179)
  br label %$40
$40:
  %192 = phi i64 [%179, %$42], [%190, %$44], [%191, %$43] ; # ->
  br label %$38
$37:
  %193 = phi i64 [%181, %$36] ; # Prg
  %194 = and i64 %179, 15
  %195 = icmp eq i64 %194, 0
  br i1 %195, label %$46, label %$45
$46:
  %196 = phi i64 [%193, %$37] ; # Prg
  %197 = call i64 @evList(i64 %179)
  %198 = icmp ne i64 %197, 0
  br label %$45
$45:
  %199 = phi i64 [%193, %$37], [%196, %$46] ; # Prg
  %200 = phi i1 [0, %$37], [%198, %$46] ; # ->
  br label %$36
$38:
  %201 = phi i64 [%184, %$40] ; # Prg
  %202 = phi i64 [%192, %$40] ; # ->
  store i64 %202, i64* @$Ret
; # (Dst: tag 0)
  %203 = ptrtoint i8* %159 to i64
  %204 = inttoptr i64 %203 to i64*
  store i64 0, i64* %204
; # (val $CoFrames)
  %205 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
; # (i8** (val $CoFrames))
  %206 = bitcast i8* %205 to i8**
; # (val (i8** (val $CoFrames)))
  %207 = load i8*, i8** %206
; # ((coFrame (val (i8** (val $CoFrames)))) crt)
  %208 = getelementptr i8, i8* %207, i32 8
  %209 = bitcast i8* %208 to i8**
  %210 = load i8*, i8** %209
; # ((coroutine ((coFrame (val (i8** (val $CoFrames)))) crt)) (rst))
  %211 = getelementptr i8, i8* %210, i32 232
; # (longjmp ((coroutine ((coFrame (val (i8** (val $CoFrames)))) crt)...
  call void @longjmp(i8* %211, i32 1)
  unreachable
$11:
  %212 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$14] ; # ->
  ret i64 %212
}

define i64 @_yield(i64) {
$1:
; # (let (X (cdr Exe) Val (save (eval (++ X))) Tag (eval (++ X)) Crt ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (val $Coroutines)
  %36 = load i8*, i8** @$Coroutines
; # (unless Crt (err Exe 0 ($ "No coroutines") null))
  %37 = icmp ne i8* %36, null
  br i1 %37, label %$13, label %$12
$12:
  %38 = phi i8* [%36, %$7] ; # Crt
; # (err Exe 0 ($ "No coroutines") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([14 x i8]* @$64 to i8*), i8* null)
  unreachable
$13:
  %39 = phi i8* [%36, %$7] ; # Crt
; # (let (Co: (coFrame (val $CoFrames)) Dst: (coroutine (if (nil? Tag...
; # (val $CoFrames)
  %40 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 32) to i8**)
; # (if (nil? Tag) (if (Co: link) ((coFrame (Co: link)) crt) (err Exe...
; # (nil? Tag)
  %41 = icmp eq i64 %35, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %41, label %$14, label %$15
$14:
  %42 = phi i8* [%39, %$13] ; # Crt
; # (if (Co: link) ((coFrame (Co: link)) crt) (err Exe 0 ($ "Tag expe...
; # (Co: link)
  %43 = bitcast i8* %40 to i8**
  %44 = load i8*, i8** %43
  %45 = icmp ne i8* %44, null
  br i1 %45, label %$17, label %$18
$17:
  %46 = phi i8* [%42, %$14] ; # Crt
; # (Co: link)
  %47 = bitcast i8* %40 to i8**
  %48 = load i8*, i8** %47
; # ((coFrame (Co: link)) crt)
  %49 = getelementptr i8, i8* %48, i32 8
  %50 = bitcast i8* %49 to i8**
  %51 = load i8*, i8** %50
  br label %$19
$18:
  %52 = phi i8* [%42, %$14] ; # Crt
; # (err Exe 0 ($ "Tag expected") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([13 x i8]* @$65 to i8*), i8* null)
  unreachable
$19:
  %53 = phi i8* [%46, %$17] ; # Crt
  %54 = phi i8* [%51, %$17] ; # ->
  br label %$16
$15:
  %55 = phi i8* [%39, %$13] ; # Crt
; # (until (== Tag ((coroutine Crt) tag)) (unless (setq Crt ((corouti...
  br label %$20
$20:
  %56 = phi i8* [%55, %$15], [%67, %$24] ; # Crt
; # ((coroutine Crt) tag)
  %57 = ptrtoint i8* %56 to i64
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (== Tag ((coroutine Crt) tag))
  %60 = icmp eq i64 %35, %59
  br i1 %60, label %$22, label %$21
$21:
  %61 = phi i8* [%56, %$20] ; # Crt
; # (unless (setq Crt ((coroutine Crt) next)) (err Exe Tag ($ "Corout...
; # ((coroutine Crt) next)
  %62 = getelementptr i8, i8* %61, i32 8
  %63 = bitcast i8* %62 to i8**
  %64 = load i8*, i8** %63
  %65 = icmp ne i8* %64, null
  br i1 %65, label %$24, label %$23
$23:
  %66 = phi i8* [%64, %$21] ; # Crt
; # (err Exe Tag ($ "Coroutine not found") null)
  call void @err(i64 %0, i64 %35, i8* bitcast ([20 x i8]* @$66 to i8*), i8* null)
  unreachable
$24:
  %67 = phi i8* [%64, %$21] ; # Crt
  br label %$20
$22:
  %68 = phi i8* [%56, %$20] ; # Crt
; # (unless ((coroutine Crt) at) (err Exe Tag ($ "Reentrant coroutine...
; # ((coroutine Crt) at)
  %69 = getelementptr i8, i8* %68, i32 32
  %70 = ptrtoint i8* %69 to i64
  %71 = inttoptr i64 %70 to i64*
  %72 = load i64, i64* %71
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$26, label %$25
$25:
  %74 = phi i8* [%68, %$22] ; # Crt
; # (err Exe Tag ($ "Reentrant coroutine") null)
  call void @err(i64 %0, i64 %35, i8* bitcast ([20 x i8]* @$63 to i8*), i8* null)
  unreachable
$26:
  %75 = phi i8* [%68, %$22] ; # Crt
  br label %$16
$16:
  %76 = phi i8* [%53, %$19], [%75, %$26] ; # Crt
  %77 = phi i8* [%54, %$19], [%75, %$26] ; # ->
; # (Co: crt)
  %78 = getelementptr i8, i8* %40, i32 8
  %79 = bitcast i8* %78 to i8**
  %80 = load i8*, i8** %79
; # (saveCoEnv Src)
  call void @saveCoEnv(i8* %80)
; # (unless (setjmp ((coroutine Src) (rst))) (set $Ret Val) (longjmp ...
; # ((coroutine Src) (rst))
  %81 = getelementptr i8, i8* %80, i32 232
; # (setjmp ((coroutine Src) (rst)))
  %82 = call i32 @setjmp(i8* %81)
  %83 = icmp ne i32 %82, 0
  br i1 %83, label %$28, label %$27
$27:
  %84 = phi i8* [%76, %$16] ; # Crt
; # (set $Ret Val)
  store i64 %15, i64* @$Ret
; # (Dst: (rst))
  %85 = getelementptr i8, i8* %77, i32 232
; # (longjmp (Dst: (rst)) 1)
  call void @longjmp(i8* %85, i32 1)
  unreachable
$28:
  %86 = phi i8* [%76, %$16] ; # Crt
; # (loadCoEnv Src)
  %87 = call i64 @loadCoEnv(i8* %80)
; # (drop *Safe)
  %88 = inttoptr i64 %17 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %90, i64* %91
  ret i64 %87
}

define i64 @brkLoad(i64) {
$1:
; # (when (and (isatty 0) (isatty 1) (=0 (val $Break))) (let P (val $...
; # (and (isatty 0) (isatty 1) (=0 (val $Break)))
; # (isatty 0)
  %1 = call i32 @isatty(i32 0)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$3, label %$2
$3:
  %3 = phi i64 [%0, %$1] ; # Exe
; # (isatty 1)
  %4 = call i32 @isatty(i32 1)
  %5 = icmp ne i32 %4, 0
  br i1 %5, label %$4, label %$2
$4:
  %6 = phi i64 [%3, %$3] ; # Exe
; # (val $Break)
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 16) to i64) to i64*
  %8 = load i64, i64* %7
; # (=0 (val $Break))
  %9 = icmp eq i64 %8, 0
  br label %$2
$2:
  %10 = phi i64 [%0, %$1], [%3, %$3], [%6, %$4] ; # Exe
  %11 = phi i1 [0, %$1], [0, %$3], [%9, %$4] ; # ->
  br i1 %11, label %$5, label %$6
$5:
  %12 = phi i64 [%10, %$2] ; # Exe
; # (let P (val $Bind) (setq P (push (val $At) $At P 0)) (setq P (pus...
; # (val $Bind)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %14 = load i64, i64* %13
; # (val $At)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %16 = load i64, i64* %15
; # (push (val $At) $At P 0)
  %17 = alloca i64, i64 4, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %16, i64* %19
  %20 = add i64 %18, 8
  %21 = inttoptr i64 %20 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), i64* %21
  %22 = add i64 %18, 16
  %23 = inttoptr i64 %22 to i64*
  store i64 %14, i64* %23
  %24 = add i64 %18, 24
  %25 = inttoptr i64 %24 to i64*
  store i64 0, i64* %25
; # (val $Up)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64) to i64*
  %27 = load i64, i64* %26
; # (push (val $Up) $Up P)
  %28 = alloca i64, i64 3, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
  %31 = add i64 %29, 8
  %32 = inttoptr i64 %31 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64), i64* %32
  %33 = add i64 %29, 16
  %34 = inttoptr i64 %33 to i64*
  store i64 %18, i64* %34
; # (set $Up Exe)
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64) to i64*
  store i64 %12, i64* %35
; # (set $Break (set $Bind (push (val $Run) $Run P)))
; # (set $Bind (push (val $Run) $Run P))
; # (val $Run)
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  %37 = load i64, i64* %36
; # (push (val $Run) $Run P)
  %38 = alloca i64, i64 3, align 16
  %39 = ptrtoint i64* %38 to i64
  %40 = inttoptr i64 %39 to i64*
  store i64 %37, i64* %40
  %41 = add i64 %39, 8
  %42 = inttoptr i64 %41 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64), i64* %42
  %43 = add i64 %39, 16
  %44 = inttoptr i64 %43 to i64*
  store i64 %29, i64* %44
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %39, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 16) to i64) to i64*
  store i64 %39, i64* %46
; # (set $Run $Nil)
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %47
; # (let (Out (b8 (ioFrame T)) Io: (ioFrame Out)) (Io: fd 1) (Io: pid...
; # (b8 (ioFrame T))
  %48 = alloca i8, i64 24
; # (Io: fd 1)
  %49 = getelementptr i8, i8* %48, i32 8
  %50 = bitcast i8* %49 to i32*
  store i32 1, i32* %50
; # (Io: pid 0)
  %51 = getelementptr i8, i8* %48, i32 12
  %52 = bitcast i8* %51 to i32*
  store i32 0, i32* %52
; # (pushOutFiles Out)
  call void @pushOutFiles(i8* %48)
; # (print Exe)
  call void @print(i64 %12)
; # (newline)
  call void @newline()
; # (repl 0 ($ "! ") $Nil)
  %53 = call i64 @repl(i64 0, i8* bitcast ([3 x i8]* @$67 to i8*), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (popOutFiles)
  call void @popOutFiles()
; # (val $Up)
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64) to i64*
  %55 = load i64, i64* %54
; # (let P (val $Bind) (set $Run (val P)) (setq P (val 3 P)) (set $Up...
; # (val $Bind)
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %57 = load i64, i64* %56
; # (set $Run (val P))
; # (val P)
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  store i64 %59, i64* %60
; # (val 3 P)
  %61 = inttoptr i64 %57 to i64*
  %62 = getelementptr i64, i64* %61, i32 2
  %63 = load i64, i64* %62
; # (set $Up (val P))
; # (val P)
  %64 = inttoptr i64 %63 to i64*
  %65 = load i64, i64* %64
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64) to i64*
  store i64 %65, i64* %66
; # (val 3 P)
  %67 = inttoptr i64 %63 to i64*
  %68 = getelementptr i64, i64* %67, i32 2
  %69 = load i64, i64* %68
; # (set $At (val P))
; # (val P)
  %70 = inttoptr i64 %69 to i64*
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %71, i64* %72
; # (set $Bind (val 3 P))
; # (val 3 P)
  %73 = inttoptr i64 %69 to i64*
  %74 = getelementptr i64, i64* %73, i32 2
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %75, i64* %76
; # (set $Break 0)
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 16) to i64) to i64*
  store i64 0, i64* %77
  br label %$6
$6:
  %78 = phi i64 [%10, %$2], [%55, %$5] ; # Exe
  ret i64 %78
}

define i64 @_break(i64) {
$1:
; # (let X (cdr Exe) (unless (nil? (val $Dbg)) (setq X (brkLoad X))) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (nil? (val $Dbg)) (setq X (brkLoad X)))
; # (val $Dbg)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  %5 = load i64, i64* %4
; # (nil? (val $Dbg))
  %6 = icmp eq i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (brkLoad X)
  %8 = call i64 @brkLoad(i64 %7)
  br label %$3
$3:
  %9 = phi i64 [%3, %$1], [%8, %$2] ; # X
; # (eval X)
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  br label %$4
$5:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$8, label %$7
$8:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$4
$7:
  %16 = call i64 @evList(i64 %9)
  br label %$4
$4:
  %17 = phi i64 [%9, %$6], [%15, %$8], [%16, %$7] ; # ->
  ret i64 %17
}

define i64 @_e(i64) {
$1:
; # (let P (val $Break) (unless P (err Exe 0 ($ "No Break") null)) (l...
; # (val $Break)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 16) to i64) to i64*
  %2 = load i64, i64* %1
; # (unless P (err Exe 0 ($ "No Break") null))
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$3, label %$2
$2:
; # (err Exe 0 ($ "No Break") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([9 x i8]* @$68 to i8*), i8* null)
  unreachable
$3:
; # (let (Dbg (save (val $Dbg)) At (save (val $At)) Run (save (val $R...
; # (val $Dbg)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  %5 = load i64, i64* %4
; # (save (val $Dbg))
  %6 = alloca i64, i64 2, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = inttoptr i64 %7 to i64*
  store i64 %5, i64* %8
  %9 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %10 = load i64, i64* %9
  %11 = inttoptr i64 %7 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  store i64 %10, i64* %12
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %7, i64* %13
; # (val $At)
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %15 = load i64, i64* %14
; # (save (val $At))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (val $Run)
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  %25 = load i64, i64* %24
; # (save (val $Run))
  %26 = alloca i64, i64 2, align 16
  %27 = ptrtoint i64* %26 to i64
  %28 = inttoptr i64 %27 to i64*
  store i64 %25, i64* %28
  %29 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %30 = load i64, i64* %29
  %31 = inttoptr i64 %27 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  store i64 %30, i64* %32
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %27, i64* %33
; # (set $Dbg $Nil $At (val P) $Run (val (val 3 P)))
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %34
; # (val P)
  %35 = inttoptr i64 %2 to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %36, i64* %37
; # (val 3 P)
  %38 = inttoptr i64 %2 to i64*
  %39 = getelementptr i64, i64* %38, i32 2
  %40 = load i64, i64* %39
; # (val (val 3 P))
  %41 = inttoptr i64 %40 to i64*
  %42 = load i64, i64* %41
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  store i64 %42, i64* %43
; # (let (In (val $InFrames) Out (val $OutFrames)) (popInFiles) (popO...
; # (val $InFrames)
  %44 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (val $OutFrames)
  %45 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (popInFiles)
  call void @popInFiles()
; # (popOutFiles)
  call void @popOutFiles()
; # (prog1 (if (pair (cdr Exe)) (run @) (eval (val $Up))) (pushOutFil...
; # (if (pair (cdr Exe)) (run @) (eval (val $Up)))
; # (cdr Exe)
  %46 = inttoptr i64 %0 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
; # (pair (cdr Exe))
  %49 = and i64 %48, 15
  %50 = icmp eq i64 %49, 0
  br i1 %50, label %$4, label %$5
$4:
; # (run @)
  br label %$7
$7:
  %51 = phi i64 [%48, %$4], [%73, %$16] ; # Prg
  %52 = inttoptr i64 %51 to i64*
  %53 = load i64, i64* %52
  %54 = getelementptr i64, i64* %52, i32 1
  %55 = load i64, i64* %54
  %56 = and i64 %55, 15
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$10, label %$8
$10:
  %58 = phi i64 [%55, %$7] ; # Prg
  %59 = and i64 %53, 6
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$13, label %$12
$13:
  br label %$11
$12:
  %61 = and i64 %53, 8
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$15, label %$14
$15:
  %63 = inttoptr i64 %53 to i64*
  %64 = load i64, i64* %63
  br label %$11
$14:
  %65 = call i64 @evList(i64 %53)
  br label %$11
$11:
  %66 = phi i64 [%53, %$13], [%64, %$15], [%65, %$14] ; # ->
  br label %$9
$8:
  %67 = phi i64 [%55, %$7] ; # Prg
  %68 = and i64 %53, 15
  %69 = icmp eq i64 %68, 0
  br i1 %69, label %$17, label %$16
$17:
  %70 = phi i64 [%67, %$8] ; # Prg
  %71 = call i64 @evList(i64 %53)
  %72 = icmp ne i64 %71, 0
  br label %$16
$16:
  %73 = phi i64 [%67, %$8], [%70, %$17] ; # Prg
  %74 = phi i1 [0, %$8], [%72, %$17] ; # ->
  br label %$7
$9:
  %75 = phi i64 [%58, %$11] ; # Prg
  %76 = phi i64 [%66, %$11] ; # ->
  br label %$6
$5:
; # (val $Up)
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64) to i64*
  %78 = load i64, i64* %77
; # (eval (val $Up))
  %79 = and i64 %78, 6
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$20, label %$19
$20:
  br label %$18
$19:
  %81 = and i64 %78, 8
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$22, label %$21
$22:
  %83 = inttoptr i64 %78 to i64*
  %84 = load i64, i64* %83
  br label %$18
$21:
  %85 = call i64 @evList(i64 %78)
  br label %$18
$18:
  %86 = phi i64 [%78, %$20], [%84, %$22], [%85, %$21] ; # ->
  br label %$6
$6:
  %87 = phi i64 [%76, %$9], [%86, %$18] ; # ->
; # (pushOutFiles Out)
  call void @pushOutFiles(i8* %45)
; # (pushInFiles In)
  call void @pushInFiles(i8* %44)
; # (set $Run Run $At At $Dbg Dbg)
  %88 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 552) to i64) to i64*
  store i64 %25, i64* %88
  %89 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %15, i64* %89
  %90 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  store i64 %5, i64* %90
; # (drop *Safe)
  %91 = inttoptr i64 %7 to i64*
  %92 = getelementptr i64, i64* %91, i32 1
  %93 = load i64, i64* %92
  %94 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %93, i64* %94
  ret i64 %87
}

define void @trace(i32, i64) {
$1:
; # (when (> C 64) (setq C 64))
; # (> C 64)
  %2 = icmp sgt i32 %0, 64
  br i1 %2, label %$2, label %$3
$2:
  %3 = phi i32 [%0, %$1] ; # C
  br label %$3
$3:
  %4 = phi i32 [%0, %$1], [64, %$2] ; # C
; # (while (ge0 (dec 'C)) (space))
  br label %$4
$4:
  %5 = phi i32 [%4, %$3], [%8, %$5] ; # C
; # (dec 'C)
  %6 = sub i32 %5, 1
; # (ge0 (dec 'C))
  %7 = icmp sge i32 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i32 [%6, %$4] ; # C
; # (space)
  call void @space()
  br label %$4
$6:
  %9 = phi i32 [%6, %$4] ; # C
; # (if (atom X) (print @) (print (car X)) (space) (print (cdr X)) (s...
; # (atom X)
  %10 = and i64 %1, 15
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$7, label %$8
$7:
  %12 = phi i32 [%9, %$6] ; # C
; # (print @)
  call void @print(i64 %1)
  br label %$9
$8:
  %13 = phi i32 [%9, %$6] ; # C
; # (car X)
  %14 = inttoptr i64 %1 to i64*
  %15 = load i64, i64* %14
; # (print (car X))
  call void @print(i64 %15)
; # (space)
  call void @space()
; # (cdr X)
  %16 = inttoptr i64 %1 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  %18 = load i64, i64* %17
; # (print (cdr X))
  call void @print(i64 %18)
; # (space)
  call void @space()
; # (val $This)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 440) to i64) to i64*
  %20 = load i64, i64* %19
; # (print (val $This))
  call void @print(i64 %20)
  br label %$9
$9:
  %21 = phi i32 [%12, %$7], [%13, %$8] ; # C
  ret void
}

define i64 @_trace(i64) {
$1:
; # (let X (cdr Exe) (if (nil? (val $Dbg)) (run (cddr X)) (let (Out (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (nil? (val $Dbg)) (run (cddr X)) (let (Out (val $OutFile) Put...
; # (val $Dbg)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  %5 = load i64, i64* %4
; # (nil? (val $Dbg))
  %6 = icmp eq i64 %5, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %6, label %$2, label %$3
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (cddr X)
  %8 = inttoptr i64 %7 to i64*
  %9 = getelementptr i64, i64* %8, i32 1
  %10 = load i64, i64* %9
  %11 = inttoptr i64 %10 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
; # (run (cddr X))
  br label %$5
$5:
  %14 = phi i64 [%13, %$2], [%36, %$14] ; # Prg
  %15 = inttoptr i64 %14 to i64*
  %16 = load i64, i64* %15
  %17 = getelementptr i64, i64* %15, i32 1
  %18 = load i64, i64* %17
  %19 = and i64 %18, 15
  %20 = icmp ne i64 %19, 0
  br i1 %20, label %$8, label %$6
$8:
  %21 = phi i64 [%18, %$5] ; # Prg
  %22 = and i64 %16, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$11:
  br label %$9
$10:
  %24 = and i64 %16, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$13, label %$12
$13:
  %26 = inttoptr i64 %16 to i64*
  %27 = load i64, i64* %26
  br label %$9
$12:
  %28 = call i64 @evList(i64 %16)
  br label %$9
$9:
  %29 = phi i64 [%16, %$11], [%27, %$13], [%28, %$12] ; # ->
  br label %$7
$6:
  %30 = phi i64 [%18, %$5] ; # Prg
  %31 = and i64 %16, 15
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = phi i64 [%30, %$6] ; # Prg
  %34 = call i64 @evList(i64 %16)
  %35 = icmp ne i64 %34, 0
  br label %$14
$14:
  %36 = phi i64 [%30, %$6], [%33, %$15] ; # Prg
  %37 = phi i1 [0, %$6], [%35, %$15] ; # ->
  br label %$5
$7:
  %38 = phi i64 [%21, %$9] ; # Prg
  %39 = phi i64 [%29, %$9] ; # ->
  br label %$4
$3:
  %40 = phi i64 [%3, %$1] ; # X
; # (let (Out (val $OutFile) Put (val (i8** $Put))) (set $OutFile (va...
; # (val $OutFile)
  %41 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (i8** $Put)
  %42 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i8**
; # (val (i8** $Put))
  %43 = load i8*, i8** %42
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %44 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %45 = getelementptr i8*, i8** %44, i32 2
  %46 = load i8*, i8** %45
  store i8* %46, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
; # (let (Y (++ X) Z (++ X)) (trace (set $Trace (inc (val $Trace))) Y...
; # (++ X)
  %47 = inttoptr i64 %40 to i64*
  %48 = load i64, i64* %47
  %49 = getelementptr i64, i64* %47, i32 1
  %50 = load i64, i64* %49
; # (++ X)
  %51 = inttoptr i64 %50 to i64*
  %52 = load i64, i64* %51
  %53 = getelementptr i64, i64* %51, i32 1
  %54 = load i64, i64* %53
; # (set $Trace (inc (val $Trace)))
; # (val $Trace)
  %55 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 184) to i32*)
; # (inc (val $Trace))
  %56 = add i32 %55, 1
  store i32 %56, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 184) to i32*)
; # (trace (set $Trace (inc (val $Trace))) Y)
  call void @trace(i32 %56, i64 %48)
; # (outString ($ " :"))
  call void @outString(i8* bitcast ([3 x i8]* @$69 to i8*))
; # (while (pair Z) (space) (print (val (++ Z))))
  br label %$16
$16:
  %57 = phi i64 [%54, %$3], [%61, %$17] ; # X
  %58 = phi i64 [%52, %$3], [%66, %$17] ; # Z
; # (pair Z)
  %59 = and i64 %58, 15
  %60 = icmp eq i64 %59, 0
  br i1 %60, label %$17, label %$18
$17:
  %61 = phi i64 [%57, %$16] ; # X
  %62 = phi i64 [%58, %$16] ; # Z
; # (space)
  call void @space()
; # (++ Z)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  %65 = getelementptr i64, i64* %63, i32 1
  %66 = load i64, i64* %65
; # (val (++ Z))
  %67 = inttoptr i64 %64 to i64*
  %68 = load i64, i64* %67
; # (print (val (++ Z)))
  call void @print(i64 %68)
  br label %$16
$18:
  %69 = phi i64 [%57, %$16] ; # X
  %70 = phi i64 [%58, %$16] ; # Z
; # (cond ((== Z $At) (setq Z (val $Next)) (while (pair Z) (space) (p...
; # (== Z $At)
  %71 = icmp eq i64 %70, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %71, label %$21, label %$20
$21:
  %72 = phi i64 [%69, %$18] ; # X
  %73 = phi i64 [%70, %$18] ; # Z
; # (val $Next)
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %75 = load i64, i64* %74
; # (while (pair Z) (space) (print (cdr Z)) (setq Z (car Z)))
  br label %$22
$22:
  %76 = phi i64 [%72, %$21], [%80, %$23] ; # X
  %77 = phi i64 [%75, %$21], [%86, %$23] ; # Z
; # (pair Z)
  %78 = and i64 %77, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$23, label %$24
$23:
  %80 = phi i64 [%76, %$22] ; # X
  %81 = phi i64 [%77, %$22] ; # Z
; # (space)
  call void @space()
; # (cdr Z)
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (print (cdr Z))
  call void @print(i64 %84)
; # (car Z)
  %85 = inttoptr i64 %81 to i64*
  %86 = load i64, i64* %85
  br label %$22
$24:
  %87 = phi i64 [%76, %$22] ; # X
  %88 = phi i64 [%77, %$22] ; # Z
  br label %$19
$20:
  %89 = phi i64 [%69, %$18] ; # X
  %90 = phi i64 [%70, %$18] ; # Z
; # (nil? Z)
  %91 = icmp eq i64 %90, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? Z))
  %92 = icmp eq i1 %91, 0
  br i1 %92, label %$26, label %$25
$26:
  %93 = phi i64 [%89, %$20] ; # X
  %94 = phi i64 [%90, %$20] ; # Z
; # (space)
  call void @space()
; # (val Z)
  %95 = inttoptr i64 %94 to i64*
  %96 = load i64, i64* %95
; # (print (val Z))
  call void @print(i64 %96)
  br label %$19
$25:
  %97 = phi i64 [%89, %$20] ; # X
  %98 = phi i64 [%90, %$20] ; # Z
  br label %$19
$19:
  %99 = phi i64 [%87, %$24], [%93, %$26], [%97, %$25] ; # X
  %100 = phi i64 [%88, %$24], [%94, %$26], [%98, %$25] ; # Z
; # (newline)
  call void @newline()
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %101 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i8**
  store i8* %43, i8** %101
  store i8* %41, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (prog1 (run X) (set $OutFile (val 3 (val $OutFiles)) $Put (fun (v...
; # (run X)
  br label %$27
$27:
  %102 = phi i64 [%99, %$19], [%124, %$36] ; # Prg
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
  %105 = getelementptr i64, i64* %103, i32 1
  %106 = load i64, i64* %105
  %107 = and i64 %106, 15
  %108 = icmp ne i64 %107, 0
  br i1 %108, label %$30, label %$28
$30:
  %109 = phi i64 [%106, %$27] ; # Prg
  %110 = and i64 %104, 6
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$33, label %$32
$33:
  br label %$31
$32:
  %112 = and i64 %104, 8
  %113 = icmp ne i64 %112, 0
  br i1 %113, label %$35, label %$34
$35:
  %114 = inttoptr i64 %104 to i64*
  %115 = load i64, i64* %114
  br label %$31
$34:
  %116 = call i64 @evList(i64 %104)
  br label %$31
$31:
  %117 = phi i64 [%104, %$33], [%115, %$35], [%116, %$34] ; # ->
  br label %$29
$28:
  %118 = phi i64 [%106, %$27] ; # Prg
  %119 = and i64 %104, 15
  %120 = icmp eq i64 %119, 0
  br i1 %120, label %$37, label %$36
$37:
  %121 = phi i64 [%118, %$28] ; # Prg
  %122 = call i64 @evList(i64 %104)
  %123 = icmp ne i64 %122, 0
  br label %$36
$36:
  %124 = phi i64 [%118, %$28], [%121, %$37] ; # Prg
  %125 = phi i1 [0, %$28], [%123, %$37] ; # ->
  br label %$27
$29:
  %126 = phi i64 [%109, %$31] ; # Prg
  %127 = phi i64 [%117, %$31] ; # ->
; # (set $OutFile (val 3 (val $OutFiles)) $Put (fun (void i8) _putStd...
; # (val $OutFiles)
  %128 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %129 = getelementptr i8*, i8** %128, i32 2
  %130 = load i8*, i8** %129
  store i8* %130, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (fun (void i8) _putStdout)
  store void(i8)* @_putStdout, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
; # (let I (val $Trace) (trace I Y) (set $Trace (dec I)))
; # (val $Trace)
  %131 = load i32, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 184) to i32*)
; # (trace I Y)
  call void @trace(i32 %131, i64 %48)
; # (set $Trace (dec I))
; # (dec I)
  %132 = sub i32 %131, 1
  store i32 %132, i32* bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 184) to i32*)
; # (outString ($ " = "))
  call void @outString(i8* bitcast ([4 x i8]* @$70 to i8*))
; # (print @)
  call void @print(i64 %127)
; # (newline)
  call void @newline()
; # (set (i8** $Put) Put $OutFile Out)
; # (i8** $Put)
  %133 = bitcast void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**) to i8**
  store i8* %43, i8** %133
  store i8* %41, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
  br label %$4
$4:
  %134 = phi i64 [%7, %$7], [%99, %$29] ; # X
  %135 = phi i64 [%39, %$7], [%127, %$29] ; # ->
  ret i64 %135
}

define i64 @_exec(i64) {
$1:
; # (let (X (cdr Exe) Av (b8* (inc (length X))) Cmd (xName Exe (evSym...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (length X)
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%13, %$3] ; # X
  %5 = phi i64 [0, %$1], [%10, %$3] ; # N
  %6 = and i64 %4, 15
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %$3, label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
  %9 = phi i64 [%5, %$2] ; # N
  %10 = add i64 %9, 1
  %11 = inttoptr i64 %8 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  br label %$2
$4:
  %14 = phi i64 [%4, %$2] ; # X
  %15 = phi i64 [%5, %$2] ; # N
; # (inc (length X))
  %16 = add i64 %15, 1
; # (b8* (inc (length X)))
  %17 = alloca i8*, i64 %16
; # (evSym X)
  %18 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %19 = call i64 @xName(i64 %0, i64 %18)
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %20 = call i64 @pathSize(i64 %19)
; # (b8 (pathSize Cmd))
  %21 = alloca i8, i64 %20
; # (pathString Cmd (b8 (pathSize Cmd)))
  %22 = call i8* @pathString(i64 %19, i8* %21)
  store i8* %22, i8** %17
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (...
; # (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (set (inc '...
  br label %$5
$5:
  %23 = phi i64 [%3, %$4], [%30, %$6] ; # X
  %24 = phi i8** [%17, %$4], [%34, %$6] ; # A
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$6, label %$7
$6:
  %30 = phi i64 [%27, %$5] ; # X
  %31 = phi i8** [%24, %$5] ; # A
; # (let Nm (xName Exe (evSym X)) (set (inc 'A) (bufString Nm (b8 (bu...
; # (evSym X)
  %32 = call i64 @evSym(i64 %30)
; # (xName Exe (evSym X))
  %33 = call i64 @xName(i64 %0, i64 %32)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %34 = getelementptr i8*, i8** %31, i32 1
; # (bufSize Nm)
  %35 = call i64 @bufSize(i64 %33)
; # (b8 (bufSize Nm))
  %36 = alloca i8, i64 %35
; # (bufString Nm (b8 (bufSize Nm)))
  %37 = call i8* @bufString(i64 %33, i8* %36)
  store i8* %37, i8** %34
  br label %$5
$7:
  %38 = phi i64 [%27, %$5] ; # X
  %39 = phi i8** [%24, %$5] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %40 = getelementptr i8*, i8** %39, i32 1
  store i8* null, i8** %40
; # (flushAll)
  call void @flushAll()
; # (val Av)
  %41 = load i8*, i8** %17
; # (execvp (val Av) Av)
  %42 = call i32 @execvp(i8* %41, i8** %17)
; # (val Av)
  %43 = load i8*, i8** %17
; # (execErr (val Av))
  call void @execErr(i8* %43)
  unreachable
}

define i64 @_call(i64) {
$1:
; # (let (X (cdr Exe) Av (b8* (inc (length X))) Cmd (xName Exe (evSym...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (length X)
  br label %$2
$2:
  %4 = phi i64 [%3, %$1], [%13, %$3] ; # X
  %5 = phi i64 [0, %$1], [%10, %$3] ; # N
  %6 = and i64 %4, 15
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %$3, label %$4
$3:
  %8 = phi i64 [%4, %$2] ; # X
  %9 = phi i64 [%5, %$2] ; # N
  %10 = add i64 %9, 1
  %11 = inttoptr i64 %8 to i64*
  %12 = getelementptr i64, i64* %11, i32 1
  %13 = load i64, i64* %12
  br label %$2
$4:
  %14 = phi i64 [%4, %$2] ; # X
  %15 = phi i64 [%5, %$2] ; # N
; # (inc (length X))
  %16 = add i64 %15, 1
; # (b8* (inc (length X)))
  %17 = alloca i8*, i64 %16
; # (evSym X)
  %18 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %19 = call i64 @xName(i64 %0, i64 %18)
; # (set Av (pathString Cmd (b8 (pathSize Cmd))))
; # (pathSize Cmd)
  %20 = call i64 @pathSize(i64 %19)
; # (b8 (pathSize Cmd))
  %21 = alloca i8, i64 %20
; # (pathString Cmd (b8 (pathSize Cmd)))
  %22 = call i8* @pathString(i64 %19, i8* %21)
  store i8* %22, i8** %17
; # (let A Av (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (...
; # (while (pair (shift X)) (let Nm (xName Exe (evSym X)) (set (inc '...
  br label %$5
$5:
  %23 = phi i64 [%3, %$4], [%30, %$6] ; # X
  %24 = phi i8** [%17, %$4], [%34, %$6] ; # A
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$6, label %$7
$6:
  %30 = phi i64 [%27, %$5] ; # X
  %31 = phi i8** [%24, %$5] ; # A
; # (let Nm (xName Exe (evSym X)) (set (inc 'A) (bufString Nm (b8 (bu...
; # (evSym X)
  %32 = call i64 @evSym(i64 %30)
; # (xName Exe (evSym X))
  %33 = call i64 @xName(i64 %0, i64 %32)
; # (set (inc 'A) (bufString Nm (b8 (bufSize Nm))))
; # (inc 'A)
  %34 = getelementptr i8*, i8** %31, i32 1
; # (bufSize Nm)
  %35 = call i64 @bufSize(i64 %33)
; # (b8 (bufSize Nm))
  %36 = alloca i8, i64 %35
; # (bufString Nm (b8 (bufSize Nm)))
  %37 = call i8* @bufString(i64 %33, i8* %36)
  store i8* %37, i8** %34
  br label %$5
$7:
  %38 = phi i64 [%27, %$5] ; # X
  %39 = phi i8** [%24, %$5] ; # A
; # (set (inc 'A) null)
; # (inc 'A)
  %40 = getelementptr i8*, i8** %39, i32 1
  store i8* null, i8** %40
; # (flushAll)
  call void @flushAll()
; # (cond ((lt0 (fork)) (forkErr Exe)) ((=0 @) (setpgid 0 0) (execvp ...
; # (fork)
  %41 = call i32 @fork()
; # (lt0 (fork))
  %42 = icmp slt i32 %41, 0
  br i1 %42, label %$10, label %$9
$10:
  %43 = phi i64 [%38, %$7] ; # X
; # (forkErr Exe)
  call void @forkErr(i64 %0)
  unreachable
$9:
  %44 = phi i64 [%38, %$7] ; # X
; # (=0 @)
  %45 = icmp eq i32 %41, 0
  br i1 %45, label %$12, label %$11
$12:
  %46 = phi i64 [%44, %$9] ; # X
; # (setpgid 0 0)
  %47 = call i32 @setpgid(i32 0, i32 0)
; # (val Av)
  %48 = load i8*, i8** %17
; # (execvp (val Av) Av)
  %49 = call i32 @execvp(i8* %48, i8** %17)
; # (val Av)
  %50 = load i8*, i8** %17
; # (execErr (val Av))
  call void @execErr(i8* %50)
  unreachable
$11:
  %51 = phi i64 [%44, %$9] ; # X
  br label %$8
$8:
  %52 = phi i64 [%51, %$11] ; # X
  %53 = phi i64 [0, %$11] ; # ->
; # (let (Pid @ Res (b32 1)) (setpgid Pid 0) (when Termio (tcsetpgrp ...
; # (b32 1)
  %54 = alloca i32, i64 1
; # (setpgid Pid 0)
  %55 = call i32 @setpgid(i32 %41, i32 0)
; # (when Termio (tcsetpgrp 0 Pid))
  %56 = icmp ne i8** @Termio, null
  br i1 %56, label %$13, label %$14
$13:
  %57 = phi i64 [%52, %$8] ; # X
; # (tcsetpgrp 0 Pid)
  %58 = call i32 @tcsetpgrp(i32 0, i32 %41)
  br label %$14
$14:
  %59 = phi i64 [%52, %$8], [%57, %$13] ; # X
; # (loop (while (lt0 (waitWuntraced Pid Res)) (unless (== (gErrno) E...
  br label %$15
$15:
  %60 = phi i64 [%59, %$14], [%96, %$32] ; # X
; # (while (lt0 (waitWuntraced Pid Res)) (unless (== (gErrno) EINTR) ...
  br label %$16
$16:
  %61 = phi i64 [%60, %$15], [%68, %$22] ; # X
; # (waitWuntraced Pid Res)
  %62 = call i32 @waitWuntraced(i32 %41, i32* %54)
; # (lt0 (waitWuntraced Pid Res))
  %63 = icmp slt i32 %62, 0
  br i1 %63, label %$17, label %$18
$17:
  %64 = phi i64 [%61, %$16] ; # X
; # (unless (== (gErrno) EINTR) (err Exe 0 ($ "wait pid") null))
; # (gErrno)
  %65 = call i32 @gErrno()
; # (== (gErrno) EINTR)
  %66 = icmp eq i32 %65, 2
  br i1 %66, label %$20, label %$19
$19:
  %67 = phi i64 [%64, %$17] ; # X
; # (err Exe 0 ($ "wait pid") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([9 x i8]* @$71 to i8*), i8* null)
  unreachable
$20:
  %68 = phi i64 [%64, %$17] ; # X
; # (sigChk Exe)
  %69 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %70 = icmp ne i32 %69, 0
  br i1 %70, label %$21, label %$22
$21:
  call void @sighandler(i64 %0)
  br label %$22
$22:
  br label %$16
$18:
  %71 = phi i64 [%61, %$16] ; # X
; # (when Termio (tcsetpgrp 0 (getpgrp)))
  %72 = icmp ne i8** @Termio, null
  br i1 %72, label %$23, label %$24
$23:
  %73 = phi i64 [%71, %$18] ; # X
; # (getpgrp)
  %74 = call i32 @getpgrp()
; # (tcsetpgrp 0 (getpgrp))
  %75 = call i32 @tcsetpgrp(i32 0, i32 %74)
  br label %$24
$24:
  %76 = phi i64 [%71, %$18], [%73, %$23] ; # X
; # (? (=0 (wifStopped Res)) (set $At2 (cnt (i64 (val Res)))) (if (va...
; # (wifStopped Res)
  %77 = call i32 @wifStopped(i32* %54)
; # (=0 (wifStopped Res))
  %78 = icmp eq i32 %77, 0
  br i1 %78, label %$27, label %$25
$27:
  %79 = phi i64 [%76, %$24] ; # X
; # (set $At2 (cnt (i64 (val Res))))
; # (val Res)
  %80 = load i32, i32* %54
; # (i64 (val Res))
  %81 = sext i32 %80 to i64
; # (cnt (i64 (val Res)))
  %82 = shl i64 %81, 4
  %83 = or i64 %82, 2
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %83, i64* %84
; # (if (val Res) $Nil $T)
; # (val Res)
  %85 = load i32, i32* %54
  %86 = icmp ne i32 %85, 0
  br i1 %86, label %$28, label %$29
$28:
  %87 = phi i64 [%79, %$27] ; # X
  br label %$30
$29:
  %88 = phi i64 [%79, %$27] ; # X
  br label %$30
$30:
  %89 = phi i64 [%87, %$28], [%88, %$29] ; # X
  %90 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$28], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$29] ; # ->
  br label %$26
$25:
  %91 = phi i64 [%76, %$24] ; # X
; # (repl 0 ($ "+ ") $Nil)
  %92 = call i64 @repl(i64 0, i8* bitcast ([3 x i8]* @$72 to i8*), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (when Termio (tcsetpgrp 0 Pid))
  %93 = icmp ne i8** @Termio, null
  br i1 %93, label %$31, label %$32
$31:
  %94 = phi i64 [%91, %$25] ; # X
; # (tcsetpgrp 0 Pid)
  %95 = call i32 @tcsetpgrp(i32 0, i32 %41)
  br label %$32
$32:
  %96 = phi i64 [%91, %$25], [%94, %$31] ; # X
; # (val SIGCONT Sig)
  %97 = getelementptr i32, i32* @Sig, i32 8
  %98 = load i32, i32* %97
; # (kill Pid (val SIGCONT Sig))
  %99 = call i32 @kill(i32 %41, i32 %98)
  br label %$15
$26:
  %100 = phi i64 [%89, %$30] ; # X
  %101 = phi i64 [%90, %$30] ; # ->
  ret i64 %101
}

define i64 @_ipid(i64) {
$1:
; # (let Io: (ioFrame (val $InFrames)) (if (and (Io:) (> (Io: pid) 1)...
; # (val $InFrames)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 40) to i8**)
; # (if (and (Io:) (> (Io: pid) 1)) (cnt (i64 (Io: pid))) $Nil)
; # (and (Io:) (> (Io: pid) 1))
; # (Io:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (Io: pid)
  %3 = getelementptr i8, i8* %1, i32 12
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (> (Io: pid) 1)
  %6 = icmp sgt i32 %5, 1
  br label %$2
$2:
  %7 = phi i1 [0, %$1], [%6, %$3] ; # ->
  br i1 %7, label %$4, label %$5
$4:
; # (Io: pid)
  %8 = getelementptr i8, i8* %1, i32 12
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (i64 (Io: pid))
  %11 = sext i32 %10 to i64
; # (cnt (i64 (Io: pid)))
  %12 = shl i64 %11, 4
  %13 = or i64 %12, 2
  br label %$6
$5:
  br label %$6
$6:
  %14 = phi i64 [%13, %$4], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5] ; # ->
  ret i64 %14
}

define i64 @_opid(i64) {
$1:
; # (let Io: (ioFrame (val $OutFrames)) (if (and (Io:) (> (Io: pid) 1...
; # (val $OutFrames)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 48) to i8**)
; # (if (and (Io:) (> (Io: pid) 1)) (cnt (i64 (Io: pid))) $Nil)
; # (and (Io:) (> (Io: pid) 1))
; # (Io:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (Io: pid)
  %3 = getelementptr i8, i8* %1, i32 12
  %4 = bitcast i8* %3 to i32*
  %5 = load i32, i32* %4
; # (> (Io: pid) 1)
  %6 = icmp sgt i32 %5, 1
  br label %$2
$2:
  %7 = phi i1 [0, %$1], [%6, %$3] ; # ->
  br i1 %7, label %$4, label %$5
$4:
; # (Io: pid)
  %8 = getelementptr i8, i8* %1, i32 12
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (i64 (Io: pid))
  %11 = sext i32 %10 to i64
; # (cnt (i64 (Io: pid)))
  %12 = shl i64 %11, 4
  %13 = or i64 %12, 2
  br label %$6
$5:
  br label %$6
$6:
  %14 = phi i64 [%13, %$4], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5] ; # ->
  ret i64 %14
}

define i64 @_kill(i64) {
$1:
; # (let (X (cdr Exe) Pid (i32 (evCnt Exe X))) (if (kill Pid (if (ato...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (i32 (evCnt Exe X))
  %5 = trunc i64 %4 to i32
; # (if (kill Pid (if (atom (shift X)) (val SIGTERM Sig) (i32 (evCnt ...
; # (if (atom (shift X)) (val SIGTERM Sig) (i32 (evCnt Exe X)))
; # (shift X)
  %6 = inttoptr i64 %3 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
; # (atom (shift X))
  %9 = and i64 %8, 15
  %10 = icmp ne i64 %9, 0
  br i1 %10, label %$2, label %$3
$2:
  %11 = phi i64 [%8, %$1] ; # X
; # (val SIGTERM Sig)
  %12 = getelementptr i32, i32* @Sig, i32 6
  %13 = load i32, i32* %12
  br label %$4
$3:
  %14 = phi i64 [%8, %$1] ; # X
; # (evCnt Exe X)
  %15 = call i64 @evCnt(i64 %0, i64 %14)
; # (i32 (evCnt Exe X))
  %16 = trunc i64 %15 to i32
  br label %$4
$4:
  %17 = phi i64 [%11, %$2], [%14, %$3] ; # X
  %18 = phi i32 [%13, %$2], [%16, %$3] ; # ->
; # (kill Pid (if (atom (shift X)) (val SIGTERM Sig) (i32 (evCnt Exe ...
  %19 = call i32 @kill(i32 %5, i32 %18)
  %20 = icmp ne i32 %19, 0
  br i1 %20, label %$5, label %$6
$5:
  %21 = phi i64 [%17, %$4] ; # X
  br label %$7
$6:
  %22 = phi i64 [%17, %$4] ; # X
  br label %$7
$7:
  %23 = phi i64 [%21, %$5], [%22, %$6] ; # X
  %24 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$6] ; # ->
  ret i64 %24
}

define i64 @_fork(i64) {
$1:
; # (if (forkLisp Exe) (cnt (i64 @)) $Nil)
; # (forkLisp Exe)
  %1 = call i32 @forkLisp(i64 %0)
  %2 = icmp ne i32 %1, 0
  br i1 %2, label %$2, label %$3
$2:
; # (i64 @)
  %3 = sext i32 %1 to i64
; # (cnt (i64 @))
  %4 = shl i64 %3, 4
  %5 = or i64 %4, 2
  br label %$4
$3:
  br label %$4
$4:
  %6 = phi i64 [%5, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %6
}

define i64 @_detach(i64) {
$1:
; # (prog1 (val $PPid) (unless (nil? @) (set $PPid $Nil) (close (val ...
; # (val $PPid)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 360) to i64) to i64*
  %2 = load i64, i64* %1
; # (unless (nil? @) (set $PPid $Nil) (close (val $Tell)) (set $Tell ...
; # (nil? @)
  %3 = icmp eq i64 %2, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %3, label %$3, label %$2
$2:
; # (set $PPid $Nil)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 360) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %4
; # (val $Tell)
  %5 = load i32, i32* @$Tell
; # (close (val $Tell))
  %6 = call i32 @close(i32 %5)
; # (set $Tell 0)
  store i32 0, i32* @$Tell
; # (let H (val $Hear) (close H) (closeInFile H) (closeOutFile H))
; # (val $Hear)
  %7 = load i32, i32* @$Hear
; # (close H)
  %8 = call i32 @close(i32 %7)
; # (closeInFile H)
  call void @closeInFile(i32 %7)
; # (closeOutFile H)
  call void @closeOutFile(i32 %7)
; # (set $Hear 0)
  store i32 0, i32* @$Hear
; # (val $Mic)
  %9 = load i32, i32* @$Mic
; # (close (val $Mic))
  %10 = call i32 @close(i32 %9)
; # (set $Mic 0)
  store i32 0, i32* @$Mic
; # (set $Slot 0)
  store i64 0, i64* @$Slot
; # (setsid)
  %11 = call i32 @setsid()
  br label %$3
$3:
  ret i64 %2
}

define i64 @_bye(i64) {
$1:
; # (if (nil? (eval (cadr Exe))) 0 (i32 (xCnt Exe @)))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
; # (xCnt Exe @)
  %15 = call i64 @xCnt(i64 %0, i64 %13)
; # (i32 (xCnt Exe @))
  %16 = trunc i64 %15 to i32
  br label %$9
$9:
  %17 = phi i32 [0, %$7], [%16, %$8] ; # ->
; # (bye (if (nil? (eval (cadr Exe))) 0 (i32 (xCnt Exe @))))
  call void @bye(i32 %17)
  unreachable
}

define void @makeErr(i64) {
$1:
; # (err Exe 0 ($ "Not making") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([11 x i8]* @$73 to i8*), i8* null)
  unreachable
}

define i64 @_car(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
  ret i64 %17
}

define i64 @_cdr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  ret i64 %20
}

define i64 @_caar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
  ret i64 %21
}

define i64 @_cadr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
  ret i64 %24
}

define i64 @_cdar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  ret i64 %24
}

define i64 @_cddr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
  ret i64 %27
}

define i64 @_caaar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkA (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %21)
  unreachable
$12:
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
  ret i64 %25
}

define i64 @_caadr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkA (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
  ret i64 %28
}

define i64 @_cadar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkA (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
  ret i64 %28
}

define i64 @_caddr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkA (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %27)
  unreachable
$16:
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
  ret i64 %31
}

define i64 @_cdaar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkD (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$12:
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %25 = phi i1 [1, %$10], [%24, %$12] ; # ->
  br i1 %25, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %21)
  unreachable
$14:
  %26 = inttoptr i64 %21 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  ret i64 %28
}

define i64 @_cdadr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkD (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  ret i64 %31
}

define i64 @_cddar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkD (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
  ret i64 %31
}

define i64 @_cdddr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkD (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$15, label %$16
$16:
  %30 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %31 = phi i1 [1, %$14], [%30, %$16] ; # ->
  br i1 %31, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %27)
  unreachable
$18:
  %32 = inttoptr i64 %27 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
  ret i64 %34
}

define i64 @_caaaar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkA (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %21)
  unreachable
$12:
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
; # (chkA (chkA (chkA (chkA (eval (cadr Exe))))))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %25)
  unreachable
$14:
  %28 = inttoptr i64 %25 to i64*
  %29 = load i64, i64* %28
  ret i64 %29
}

define i64 @_caaadr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkA (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkA (chkA (chkA (chkD (eval (cadr Exe))))))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %28)
  unreachable
$16:
  %31 = inttoptr i64 %28 to i64*
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_caadar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkA (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkA (chkA (chkD (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %28)
  unreachable
$16:
  %31 = inttoptr i64 %28 to i64*
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_caaddr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkA (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %27)
  unreachable
$16:
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
; # (chkA (chkA (chkD (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$18
$17:
  call void @varErr(i64 %0, i64 %31)
  unreachable
$18:
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cadaar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkD (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$12:
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %25 = phi i1 [1, %$10], [%24, %$12] ; # ->
  br i1 %25, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %21)
  unreachable
$14:
  %26 = inttoptr i64 %21 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (chkA (chkD (chkA (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %28)
  unreachable
$16:
  %31 = inttoptr i64 %28 to i64*
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_cadadr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkD (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkA (chkD (chkA (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$18
$17:
  call void @varErr(i64 %0, i64 %31)
  unreachable
$18:
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_caddar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkD (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkA (chkD (chkD (chkA (eval (cadr Exe))))))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$17, label %$18
$17:
  call void @varErr(i64 %0, i64 %31)
  unreachable
$18:
  %34 = inttoptr i64 %31 to i64*
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cadddr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkD (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$15, label %$16
$16:
  %30 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %31 = phi i1 [1, %$14], [%30, %$16] ; # ->
  br i1 %31, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %27)
  unreachable
$18:
  %32 = inttoptr i64 %27 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (chkA (chkD (chkD (chkD (eval (cadr Exe))))))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$19, label %$20
$19:
  call void @varErr(i64 %0, i64 %34)
  unreachable
$20:
  %37 = inttoptr i64 %34 to i64*
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cdaaar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkA (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %21)
  unreachable
$12:
  %24 = inttoptr i64 %21 to i64*
  %25 = load i64, i64* %24
; # (chkD (chkA (chkA (chkA (eval (cadr Exe))))))
  %26 = and i64 %25, 15
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %$13, label %$14
$14:
  %28 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %29 = phi i1 [1, %$12], [%28, %$14] ; # ->
  br i1 %29, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %25)
  unreachable
$16:
  %30 = inttoptr i64 %25 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  ret i64 %32
}

define i64 @_cdaadr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkA (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkD (chkA (chkA (chkD (eval (cadr Exe))))))
  %29 = and i64 %28, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$15, label %$16
$16:
  %31 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %32 = phi i1 [1, %$14], [%31, %$16] ; # ->
  br i1 %32, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %28)
  unreachable
$18:
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cdadar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkA (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 6
  %26 = icmp ne i64 %25, 0
  br i1 %26, label %$13, label %$14
$13:
  call void @varErr(i64 %0, i64 %24)
  unreachable
$14:
  %27 = inttoptr i64 %24 to i64*
  %28 = load i64, i64* %27
; # (chkD (chkA (chkD (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$15, label %$16
$16:
  %31 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %32 = phi i1 [1, %$14], [%31, %$16] ; # ->
  br i1 %32, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %28)
  unreachable
$18:
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cdaddr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkA (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$15, label %$16
$15:
  call void @varErr(i64 %0, i64 %27)
  unreachable
$16:
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
; # (chkD (chkA (chkD (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$18
$18:
  %34 = icmp eq i64 %31, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$17
$17:
  %35 = phi i1 [1, %$16], [%34, %$18] ; # ->
  br i1 %35, label %$20, label %$19
$19:
  call void @lstErr(i64 %0, i64 %31)
  unreachable
$20:
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cddaar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkA (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  call void @varErr(i64 %0, i64 %17)
  unreachable
$10:
  %20 = inttoptr i64 %17 to i64*
  %21 = load i64, i64* %20
; # (chkD (chkA (chkA (eval (cadr Exe)))))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$12:
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %25 = phi i1 [1, %$10], [%24, %$12] ; # ->
  br i1 %25, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %21)
  unreachable
$14:
  %26 = inttoptr i64 %21 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (chkD (chkD (chkA (chkA (eval (cadr Exe))))))
  %29 = and i64 %28, 15
  %30 = icmp eq i64 %29, 0
  br i1 %30, label %$15, label %$16
$16:
  %31 = icmp eq i64 %28, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %32 = phi i1 [1, %$14], [%31, %$16] ; # ->
  br i1 %32, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %28)
  unreachable
$18:
  %33 = inttoptr i64 %28 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  %35 = load i64, i64* %34
  ret i64 %35
}

define i64 @_cddadr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkA (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 6
  %22 = icmp ne i64 %21, 0
  br i1 %22, label %$11, label %$12
$11:
  call void @varErr(i64 %0, i64 %20)
  unreachable
$12:
  %23 = inttoptr i64 %20 to i64*
  %24 = load i64, i64* %23
; # (chkD (chkA (chkD (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkD (chkD (chkA (chkD (eval (cadr Exe))))))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$18
$18:
  %34 = icmp eq i64 %31, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$17
$17:
  %35 = phi i1 [1, %$16], [%34, %$18] ; # ->
  br i1 %35, label %$20, label %$19
$19:
  call void @lstErr(i64 %0, i64 %31)
  unreachable
$20:
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cdddar(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkA (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  call void @varErr(i64 %0, i64 %13)
  unreachable
$8:
  %16 = inttoptr i64 %13 to i64*
  %17 = load i64, i64* %16
; # (chkD (chkA (eval (cadr Exe))))
  %18 = and i64 %17, 15
  %19 = icmp eq i64 %18, 0
  br i1 %19, label %$9, label %$10
$10:
  %20 = icmp eq i64 %17, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$9
$9:
  %21 = phi i1 [1, %$8], [%20, %$10] ; # ->
  br i1 %21, label %$12, label %$11
$11:
  call void @lstErr(i64 %0, i64 %17)
  unreachable
$12:
  %22 = inttoptr i64 %17 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (chkD (chkD (chkA (eval (cadr Exe)))))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$13, label %$14
$14:
  %27 = icmp eq i64 %24, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$13
$13:
  %28 = phi i1 [1, %$12], [%27, %$14] ; # ->
  br i1 %28, label %$16, label %$15
$15:
  call void @lstErr(i64 %0, i64 %24)
  unreachable
$16:
  %29 = inttoptr i64 %24 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (chkD (chkD (chkD (chkA (eval (cadr Exe))))))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$18
$18:
  %34 = icmp eq i64 %31, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$17
$17:
  %35 = phi i1 [1, %$16], [%34, %$18] ; # ->
  br i1 %35, label %$20, label %$19
$19:
  call void @lstErr(i64 %0, i64 %31)
  unreachable
$20:
  %36 = inttoptr i64 %31 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  ret i64 %38
}

define i64 @_cddddr(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (chkD (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$8:
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %17 = phi i1 [1, %$2], [%16, %$8] ; # ->
  br i1 %17, label %$10, label %$9
$9:
  call void @lstErr(i64 %0, i64 %13)
  unreachable
$10:
  %18 = inttoptr i64 %13 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
; # (chkD (chkD (eval (cadr Exe))))
  %21 = and i64 %20, 15
  %22 = icmp eq i64 %21, 0
  br i1 %22, label %$11, label %$12
$12:
  %23 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$11
$11:
  %24 = phi i1 [1, %$10], [%23, %$12] ; # ->
  br i1 %24, label %$14, label %$13
$13:
  call void @lstErr(i64 %0, i64 %20)
  unreachable
$14:
  %25 = inttoptr i64 %20 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (chkD (chkD (chkD (eval (cadr Exe)))))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$15, label %$16
$16:
  %30 = icmp eq i64 %27, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$15
$15:
  %31 = phi i1 [1, %$14], [%30, %$16] ; # ->
  br i1 %31, label %$18, label %$17
$17:
  call void @lstErr(i64 %0, i64 %27)
  unreachable
$18:
  %32 = inttoptr i64 %27 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (chkD (chkD (chkD (chkD (eval (cadr Exe))))))
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$19, label %$20
$20:
  %37 = icmp eq i64 %34, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$19
$19:
  %38 = phi i1 [1, %$18], [%37, %$20] ; # ->
  br i1 %38, label %$22, label %$21
$21:
  call void @lstErr(i64 %0, i64 %34)
  unreachable
$22:
  %39 = inttoptr i64 %34 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  %41 = load i64, i64* %40
  ret i64 %41
}

define i64 @_nth(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X)))) (loop (? (atom Y) Y) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (loop (? (atom Y) Y) (let C (evCnt Exe X) (? (lt0 (dec 'C)) $Nil)...
  br label %$7
$7:
  %24 = phi i64 [%7, %$2], [%62, %$16] ; # X
  %25 = phi i64 [%15, %$2], [%65, %$16] ; # Y
; # (? (atom Y) Y)
; # (atom Y)
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%24, %$7] ; # X
  %29 = phi i64 [%25, %$7] ; # Y
  br label %$9
$8:
  %30 = phi i64 [%24, %$7] ; # X
  %31 = phi i64 [%25, %$7] ; # Y
; # (let C (evCnt Exe X) (? (lt0 (dec 'C)) $Nil) (while (ge0 (dec 'C)...
; # (evCnt Exe X)
  %32 = call i64 @evCnt(i64 %0, i64 %30)
; # (? (lt0 (dec 'C)) $Nil)
; # (dec 'C)
  %33 = sub i64 %32, 1
; # (lt0 (dec 'C))
  %34 = icmp slt i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  %35 = phi i64 [%30, %$8] ; # X
  %36 = phi i64 [%31, %$8] ; # Y
  %37 = phi i64 [%33, %$8] ; # C
  br label %$9
$11:
  %38 = phi i64 [%30, %$8] ; # X
  %39 = phi i64 [%31, %$8] ; # Y
  %40 = phi i64 [%33, %$8] ; # C
; # (while (ge0 (dec 'C)) (shift Y))
  br label %$13
$13:
  %41 = phi i64 [%38, %$11], [%46, %$14] ; # X
  %42 = phi i64 [%39, %$11], [%51, %$14] ; # Y
  %43 = phi i64 [%40, %$11], [%48, %$14] ; # C
; # (dec 'C)
  %44 = sub i64 %43, 1
; # (ge0 (dec 'C))
  %45 = icmp sge i64 %44, 0
  br i1 %45, label %$14, label %$15
$14:
  %46 = phi i64 [%41, %$13] ; # X
  %47 = phi i64 [%42, %$13] ; # Y
  %48 = phi i64 [%44, %$13] ; # C
; # (shift Y)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  br label %$13
$15:
  %52 = phi i64 [%41, %$13] ; # X
  %53 = phi i64 [%42, %$13] ; # Y
  %54 = phi i64 [%44, %$13] ; # C
; # (? (atom (shift X)) Y)
; # (shift X)
  %55 = inttoptr i64 %52 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
; # (atom (shift X))
  %58 = and i64 %57, 15
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$17, label %$16
$17:
  %60 = phi i64 [%57, %$15] ; # X
  %61 = phi i64 [%53, %$15] ; # Y
  br label %$9
$16:
  %62 = phi i64 [%57, %$15] ; # X
  %63 = phi i64 [%53, %$15] ; # Y
; # (car Y)
  %64 = inttoptr i64 %63 to i64*
  %65 = load i64, i64* %64
  br label %$7
$9:
  %66 = phi i64 [%28, %$10], [%35, %$12], [%60, %$17] ; # X
  %67 = phi i64 [%29, %$10], [%36, %$12], [%61, %$17] ; # Y
  %68 = phi i64 [%29, %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%61, %$17] ; # ->
; # (drop *Safe)
  %69 = inttoptr i64 %17 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  %71 = load i64, i64* %70
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %72
  ret i64 %68
}

define i64 @_con(i64) {
$1:
; # (let X (cdr Exe) (set 2 (save (needPair Exe (eval (++ X)))) (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set 2 (save (needPair Exe (eval (++ X)))) (eval (car X)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needPair Exe (eval (++ X)))
  %16 = and i64 %15, 15
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$8
$7:
  call void @pairErr(i64 %0, i64 %15)
  unreachable
$8:
; # (save (needPair Exe (eval (++ X))))
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %15, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (car X)
  %26 = inttoptr i64 %7 to i64*
  %27 = load i64, i64* %26
; # (eval (car X))
  %28 = and i64 %27, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  br label %$9
$10:
  %30 = and i64 %27, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$13, label %$12
$13:
  %32 = inttoptr i64 %27 to i64*
  %33 = load i64, i64* %32
  br label %$9
$12:
  %34 = call i64 @evList(i64 %27)
  br label %$9
$9:
  %35 = phi i64 [%27, %$11], [%33, %$13], [%34, %$12] ; # ->
  %36 = inttoptr i64 %15 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  store i64 %35, i64* %37
; # (drop *Safe)
  %38 = inttoptr i64 %19 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  ret i64 %35
}

define i64 @_cons(i64) {
$1:
; # (let (X (cdr Exe) Y (cons (eval (car X)) $Nil) R (save Y)) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cons (eval (car X)) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %14, i64* %17
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = inttoptr i64 %16 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  store i64 %19, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %22
; # (while (pair (cdr (shift X))) (setq Y (set 2 Y (cons (eval (car X...
  br label %$7
$7:
  %23 = phi i64 [%3, %$2], [%33, %$10] ; # X
  %24 = phi i64 [%14, %$2], [%45, %$10] ; # Y
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (cdr (shift X))
  %28 = inttoptr i64 %27 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (pair (cdr (shift X)))
  %31 = and i64 %30, 15
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %$8, label %$9
$8:
  %33 = phi i64 [%27, %$7] ; # X
  %34 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (cons (eval (car X)) $Nil))
; # (car X)
  %35 = inttoptr i64 %33 to i64*
  %36 = load i64, i64* %35
; # (eval (car X))
  %37 = and i64 %36, 6
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$12, label %$11
$12:
  br label %$10
$11:
  %39 = and i64 %36, 8
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$14, label %$13
$14:
  %41 = inttoptr i64 %36 to i64*
  %42 = load i64, i64* %41
  br label %$10
$13:
  %43 = call i64 @evList(i64 %36)
  br label %$10
$10:
  %44 = phi i64 [%36, %$12], [%42, %$14], [%43, %$13] ; # ->
; # (cons (eval (car X)) $Nil)
  %45 = call i64 @cons(i64 %44, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %46 = inttoptr i64 %34 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  br label %$7
$9:
  %48 = phi i64 [%27, %$7] ; # X
  %49 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (eval (car X)))
; # (car X)
  %50 = inttoptr i64 %48 to i64*
  %51 = load i64, i64* %50
; # (eval (car X))
  %52 = and i64 %51, 6
  %53 = icmp ne i64 %52, 0
  br i1 %53, label %$17, label %$16
$17:
  br label %$15
$16:
  %54 = and i64 %51, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$19, label %$18
$19:
  %56 = inttoptr i64 %51 to i64*
  %57 = load i64, i64* %56
  br label %$15
$18:
  %58 = call i64 @evList(i64 %51)
  br label %$15
$15:
  %59 = phi i64 [%51, %$17], [%57, %$19], [%58, %$18] ; # ->
  %60 = inttoptr i64 %49 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %59, i64* %61
; # (drop *Safe)
  %62 = inttoptr i64 %16 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
  %65 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %64, i64* %65
  ret i64 %14
}

define i64 @_conc(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (car X)) R (save Y)) (while (pair (shif...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save Y)
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (while (pair (shift X)) (let Z (eval (car X)) (if (atom Y) (setq ...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%68, %$17] ; # X
  %23 = phi i64 [%13, %$2], [%69, %$17] ; # Y
  %24 = phi i64 [%13, %$2], [%70, %$17] ; # R
; # (shift X)
  %25 = inttoptr i64 %22 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%27, %$7] ; # X
  %31 = phi i64 [%23, %$7] ; # Y
  %32 = phi i64 [%24, %$7] ; # R
; # (let Z (eval (car X)) (if (atom Y) (setq Y (setq R (safe Z))) (wh...
; # (car X)
  %33 = inttoptr i64 %30 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$12, label %$11
$12:
  br label %$10
$11:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$14, label %$13
$14:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$10
$13:
  %41 = call i64 @evList(i64 %34)
  br label %$10
$10:
  %42 = phi i64 [%34, %$12], [%40, %$14], [%41, %$13] ; # ->
; # (if (atom Y) (setq Y (setq R (safe Z))) (while (pair (cdr Y)) (se...
; # (atom Y)
  %43 = and i64 %31, 15
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$16
$15:
  %45 = phi i64 [%30, %$10] ; # X
  %46 = phi i64 [%31, %$10] ; # Y
  %47 = phi i64 [%32, %$10] ; # R
; # (safe Z)
  %48 = inttoptr i64 %15 to i64*
  store i64 %42, i64* %48
  br label %$17
$16:
  %49 = phi i64 [%30, %$10] ; # X
  %50 = phi i64 [%31, %$10] ; # Y
  %51 = phi i64 [%32, %$10] ; # R
; # (while (pair (cdr Y)) (setq Y @))
  br label %$18
$18:
  %52 = phi i64 [%49, %$16], [%60, %$19] ; # X
  %53 = phi i64 [%50, %$16], [%57, %$19] ; # Y
  %54 = phi i64 [%51, %$16], [%62, %$19] ; # R
; # (cdr Y)
  %55 = inttoptr i64 %53 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  %57 = load i64, i64* %56
; # (pair (cdr Y))
  %58 = and i64 %57, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$19, label %$20
$19:
  %60 = phi i64 [%52, %$18] ; # X
  %61 = phi i64 [%53, %$18] ; # Y
  %62 = phi i64 [%54, %$18] ; # R
  br label %$18
$20:
  %63 = phi i64 [%52, %$18] ; # X
  %64 = phi i64 [%53, %$18] ; # Y
  %65 = phi i64 [%54, %$18] ; # R
; # (set 2 Y Z)
  %66 = inttoptr i64 %64 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %42, i64* %67
  br label %$17
$17:
  %68 = phi i64 [%45, %$15], [%63, %$20] ; # X
  %69 = phi i64 [%42, %$15], [%64, %$20] ; # Y
  %70 = phi i64 [%42, %$15], [%65, %$20] ; # R
  %71 = phi i64 [%42, %$15], [%42, %$20] ; # ->
  br label %$7
$9:
  %72 = phi i64 [%27, %$7] ; # X
  %73 = phi i64 [%23, %$7] ; # Y
  %74 = phi i64 [%24, %$7] ; # R
; # (drop *Safe)
  %75 = inttoptr i64 %15 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  %77 = load i64, i64* %76
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %77, i64* %78
  ret i64 %74
}

define i64 @_circ(i64) {
$1:
; # (let (X (cdr Exe) Y (cons (eval (car X)) $Nil) R (save Y)) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cons (eval (car X)) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %14, i64* %17
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = inttoptr i64 %16 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  store i64 %19, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %22
; # (while (pair (shift X)) (setq Y (set 2 Y (cons (eval (car X)) $Ni...
  br label %$7
$7:
  %23 = phi i64 [%3, %$2], [%30, %$10] ; # X
  %24 = phi i64 [%14, %$2], [%42, %$10] ; # Y
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%27, %$7] ; # X
  %31 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (cons (eval (car X)) $Nil))
; # (car X)
  %32 = inttoptr i64 %30 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %33)
  br label %$10
$10:
  %41 = phi i64 [%33, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (cons (eval (car X)) $Nil)
  %42 = call i64 @cons(i64 %41, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %43 = inttoptr i64 %31 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %42, i64* %44
  br label %$7
$9:
  %45 = phi i64 [%27, %$7] ; # X
  %46 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y R)
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %14, i64* %48
; # (drop *Safe)
  %49 = inttoptr i64 %16 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %52
  ret i64 %14
}

define i64 @_rot(i64) {
$1:
; # (let (X (cdr Exe) R (eval (car X))) (when (pair R) (let (Y R A (+...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (when (pair R) (let (Y R A (++ Y)) (if (pair (shift X)) (let N (s...
; # (pair R)
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%3, %$2] ; # X
; # (let (Y R A (++ Y)) (if (pair (shift X)) (let N (save R (evCnt Ex...
; # (++ Y)
  %17 = inttoptr i64 %13 to i64*
  %18 = load i64, i64* %17
  %19 = getelementptr i64, i64* %17, i32 1
  %20 = load i64, i64* %19
; # (if (pair (shift X)) (let N (save R (evCnt Exe X)) (while (and (p...
; # (shift X)
  %21 = inttoptr i64 %16 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  %23 = load i64, i64* %22
; # (pair (shift X))
  %24 = and i64 %23, 15
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %$9, label %$10
$9:
  %26 = phi i64 [%23, %$7] ; # X
  %27 = phi i64 [%20, %$7] ; # Y
  %28 = phi i64 [%18, %$7] ; # A
; # (let N (save R (evCnt Exe X)) (while (and (pair Y) (gt0 (dec 'N))...
; # (save R (evCnt Exe X))
  %29 = alloca i64, i64 2, align 16
  %30 = ptrtoint i64* %29 to i64
  %31 = inttoptr i64 %30 to i64*
  store i64 %13, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %30 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  store i64 %33, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %36
; # (evCnt Exe X)
  %37 = call i64 @evCnt(i64 %0, i64 %26)
  %38 = inttoptr i64 %30 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
; # (while (and (pair Y) (gt0 (dec 'N))) (let B (car Y) (set Y A) (se...
  br label %$12
$12:
  %42 = phi i64 [%26, %$9], [%70, %$17] ; # X
  %43 = phi i64 [%27, %$9], [%71, %$17] ; # Y
  %44 = phi i64 [%28, %$9], [%72, %$17] ; # A
  %45 = phi i64 [%37, %$9], [%73, %$17] ; # N
; # (and (pair Y) (gt0 (dec 'N)))
; # (pair Y)
  %46 = and i64 %43, 15
  %47 = icmp eq i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  %48 = phi i64 [%42, %$12] ; # X
  %49 = phi i64 [%43, %$12] ; # Y
  %50 = phi i64 [%44, %$12] ; # A
  %51 = phi i64 [%45, %$12] ; # N
; # (dec 'N)
  %52 = sub i64 %51, 1
; # (gt0 (dec 'N))
  %53 = icmp sgt i64 %52, 0
  br label %$13
$13:
  %54 = phi i64 [%42, %$12], [%48, %$14] ; # X
  %55 = phi i64 [%43, %$12], [%49, %$14] ; # Y
  %56 = phi i64 [%44, %$12], [%50, %$14] ; # A
  %57 = phi i64 [%45, %$12], [%52, %$14] ; # N
  %58 = phi i1 [0, %$12], [%53, %$14] ; # ->
  br i1 %58, label %$15, label %$16
$15:
  %59 = phi i64 [%54, %$13] ; # X
  %60 = phi i64 [%55, %$13] ; # Y
  %61 = phi i64 [%56, %$13] ; # A
  %62 = phi i64 [%57, %$13] ; # N
; # (let B (car Y) (set Y A) (setq A B))
; # (car Y)
  %63 = inttoptr i64 %60 to i64*
  %64 = load i64, i64* %63
; # (set Y A)
  %65 = inttoptr i64 %60 to i64*
  store i64 %61, i64* %65
; # (? (== R (shift Y)))
; # (shift Y)
  %66 = inttoptr i64 %60 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
; # (== R (shift Y))
  %69 = icmp eq i64 %13, %68
  br i1 %69, label %$16, label %$17
$17:
  %70 = phi i64 [%59, %$15] ; # X
  %71 = phi i64 [%68, %$15] ; # Y
  %72 = phi i64 [%64, %$15] ; # A
  %73 = phi i64 [%62, %$15] ; # N
  br label %$12
$16:
  %74 = phi i64 [%54, %$13], [%59, %$15] ; # X
  %75 = phi i64 [%55, %$13], [%68, %$15] ; # Y
  %76 = phi i64 [%56, %$13], [%64, %$15] ; # A
  %77 = phi i64 [%57, %$13], [%62, %$15] ; # N
; # (set R A)
  %78 = inttoptr i64 %13 to i64*
  store i64 %76, i64* %78
  br label %$11
$10:
  %79 = phi i64 [%23, %$7] ; # X
  %80 = phi i64 [%20, %$7] ; # Y
  %81 = phi i64 [%18, %$7] ; # A
; # (while (pair Y) (let B (car Y) (set Y A) (setq A B)) (? (== R (sh...
  br label %$18
$18:
  %82 = phi i64 [%79, %$10], [%97, %$21] ; # X
  %83 = phi i64 [%80, %$10], [%98, %$21] ; # Y
  %84 = phi i64 [%81, %$10], [%99, %$21] ; # A
; # (pair Y)
  %85 = and i64 %83, 15
  %86 = icmp eq i64 %85, 0
  br i1 %86, label %$19, label %$20
$19:
  %87 = phi i64 [%82, %$18] ; # X
  %88 = phi i64 [%83, %$18] ; # Y
  %89 = phi i64 [%84, %$18] ; # A
; # (let B (car Y) (set Y A) (setq A B))
; # (car Y)
  %90 = inttoptr i64 %88 to i64*
  %91 = load i64, i64* %90
; # (set Y A)
  %92 = inttoptr i64 %88 to i64*
  store i64 %89, i64* %92
; # (? (== R (shift Y)))
; # (shift Y)
  %93 = inttoptr i64 %88 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  %95 = load i64, i64* %94
; # (== R (shift Y))
  %96 = icmp eq i64 %13, %95
  br i1 %96, label %$20, label %$21
$21:
  %97 = phi i64 [%87, %$19] ; # X
  %98 = phi i64 [%95, %$19] ; # Y
  %99 = phi i64 [%91, %$19] ; # A
  br label %$18
$20:
  %100 = phi i64 [%82, %$18], [%87, %$19] ; # X
  %101 = phi i64 [%83, %$18], [%95, %$19] ; # Y
  %102 = phi i64 [%84, %$18], [%91, %$19] ; # A
; # (set R A)
  %103 = inttoptr i64 %13 to i64*
  store i64 %102, i64* %103
  br label %$11
$11:
  %104 = phi i64 [%74, %$16], [%100, %$20] ; # X
  %105 = phi i64 [%75, %$16], [%101, %$20] ; # Y
  %106 = phi i64 [%76, %$16], [%102, %$20] ; # A
  %107 = phi i64 [%76, %$16], [%102, %$20] ; # ->
  br label %$8
$8:
  %108 = phi i64 [%3, %$2], [%104, %$11] ; # X
  ret i64 %13
}

define i64 @_list(i64) {
$1:
; # (let (X (cdr Exe) Y (cons (eval (car X)) $Nil) R (save Y)) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cons (eval (car X)) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %14, i64* %17
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = inttoptr i64 %16 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  store i64 %19, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %22
; # (while (pair (shift X)) (setq Y (set 2 Y (cons (eval (car X)) $Ni...
  br label %$7
$7:
  %23 = phi i64 [%3, %$2], [%30, %$10] ; # X
  %24 = phi i64 [%14, %$2], [%42, %$10] ; # Y
; # (shift X)
  %25 = inttoptr i64 %23 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (pair (shift X))
  %28 = and i64 %27, 15
  %29 = icmp eq i64 %28, 0
  br i1 %29, label %$8, label %$9
$8:
  %30 = phi i64 [%27, %$7] ; # X
  %31 = phi i64 [%24, %$7] ; # Y
; # (set 2 Y (cons (eval (car X)) $Nil))
; # (car X)
  %32 = inttoptr i64 %30 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$12, label %$11
$12:
  br label %$10
$11:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$14, label %$13
$14:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$10
$13:
  %40 = call i64 @evList(i64 %33)
  br label %$10
$10:
  %41 = phi i64 [%33, %$12], [%39, %$14], [%40, %$13] ; # ->
; # (cons (eval (car X)) $Nil)
  %42 = call i64 @cons(i64 %41, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %43 = inttoptr i64 %31 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %42, i64* %44
  br label %$7
$9:
  %45 = phi i64 [%27, %$7] ; # X
  %46 = phi i64 [%24, %$7] ; # Y
; # (drop *Safe)
  %47 = inttoptr i64 %16 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %50
  ret i64 %14
}

define i64 @_need(i64) {
$1:
; # (let (X (cdr Exe) C (evCnt Exe X) R (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %17, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (if (or (pair R) (nil? R)) (eval (cadr X)) (prog1 R (setq R $Nil)...
; # (or (pair R) (nil? R))
; # (pair R)
  %26 = and i64 %17, 15
  %27 = icmp eq i64 %26, 0
  br i1 %27, label %$7, label %$8
$8:
  %28 = phi i64 [%4, %$2] ; # C
  %29 = phi i64 [%17, %$2] ; # R
; # (nil? R)
  %30 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$7
$7:
  %31 = phi i64 [%4, %$2], [%28, %$8] ; # C
  %32 = phi i64 [%17, %$2], [%29, %$8] ; # R
  %33 = phi i1 [1, %$2], [%30, %$8] ; # ->
  br i1 %33, label %$9, label %$10
$9:
  %34 = phi i64 [%31, %$7] ; # C
  %35 = phi i64 [%32, %$7] ; # R
; # (cadr X)
  %36 = inttoptr i64 %7 to i64*
  %37 = getelementptr i64, i64* %36, i32 1
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (eval (cadr X))
  %41 = and i64 %40, 6
  %42 = icmp ne i64 %41, 0
  br i1 %42, label %$14, label %$13
$14:
  br label %$12
$13:
  %43 = and i64 %40, 8
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$16, label %$15
$16:
  %45 = inttoptr i64 %40 to i64*
  %46 = load i64, i64* %45
  br label %$12
$15:
  %47 = call i64 @evList(i64 %40)
  br label %$12
$12:
  %48 = phi i64 [%40, %$14], [%46, %$16], [%47, %$15] ; # ->
  br label %$11
$10:
  %49 = phi i64 [%31, %$7] ; # C
  %50 = phi i64 [%32, %$7] ; # R
; # (prog1 R (setq R $Nil))
  br label %$11
$11:
  %51 = phi i64 [%34, %$12], [%49, %$10] ; # C
  %52 = phi i64 [%35, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # R
  %53 = phi i64 [%48, %$12], [%50, %$10] ; # ->
; # (save (if (or (pair R) (nil? R)) (eval (cadr X)) (prog1 R (setq R...
  %54 = alloca i64, i64 2, align 16
  %55 = ptrtoint i64* %54 to i64
  %56 = inttoptr i64 %55 to i64*
  store i64 %53, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %58 = load i64, i64* %57
  %59 = inttoptr i64 %55 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  store i64 %58, i64* %60
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %61
; # (when C (cond ((gt0 C) (while (pair Z) (dec 'C) (shift Z)) (while...
  %62 = icmp ne i64 %51, 0
  br i1 %62, label %$17, label %$18
$17:
  %63 = phi i64 [%51, %$11] ; # C
  %64 = phi i64 [%52, %$11] ; # R
  %65 = phi i64 [%52, %$11] ; # Z
; # (cond ((gt0 C) (while (pair Z) (dec 'C) (shift Z)) (while (ge0 (d...
; # (gt0 C)
  %66 = icmp sgt i64 %63, 0
  br i1 %66, label %$21, label %$20
$21:
  %67 = phi i64 [%63, %$17] ; # C
  %68 = phi i64 [%64, %$17] ; # R
  %69 = phi i64 [%65, %$17] ; # Z
; # (while (pair Z) (dec 'C) (shift Z))
  br label %$22
$22:
  %70 = phi i64 [%67, %$21], [%78, %$23] ; # C
  %71 = phi i64 [%68, %$21], [%76, %$23] ; # R
  %72 = phi i64 [%69, %$21], [%81, %$23] ; # Z
; # (pair Z)
  %73 = and i64 %72, 15
  %74 = icmp eq i64 %73, 0
  br i1 %74, label %$23, label %$24
$23:
  %75 = phi i64 [%70, %$22] ; # C
  %76 = phi i64 [%71, %$22] ; # R
  %77 = phi i64 [%72, %$22] ; # Z
; # (dec 'C)
  %78 = sub i64 %75, 1
; # (shift Z)
  %79 = inttoptr i64 %77 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  br label %$22
$24:
  %82 = phi i64 [%70, %$22] ; # C
  %83 = phi i64 [%71, %$22] ; # R
  %84 = phi i64 [%72, %$22] ; # Z
; # (while (ge0 (dec 'C)) (setq R (safe (cons Y R))))
  br label %$25
$25:
  %85 = phi i64 [%82, %$24], [%90, %$26] ; # C
  %86 = phi i64 [%83, %$24], [%93, %$26] ; # R
  %87 = phi i64 [%84, %$24], [%92, %$26] ; # Z
; # (dec 'C)
  %88 = sub i64 %85, 1
; # (ge0 (dec 'C))
  %89 = icmp sge i64 %88, 0
  br i1 %89, label %$26, label %$27
$26:
  %90 = phi i64 [%88, %$25] ; # C
  %91 = phi i64 [%86, %$25] ; # R
  %92 = phi i64 [%87, %$25] ; # Z
; # (cons Y R)
  %93 = call i64 @cons(i64 %53, i64 %91)
; # (safe (cons Y R))
  %94 = inttoptr i64 %19 to i64*
  store i64 %93, i64* %94
  br label %$25
$27:
  %95 = phi i64 [%88, %$25] ; # C
  %96 = phi i64 [%86, %$25] ; # R
  %97 = phi i64 [%87, %$25] ; # Z
  br label %$19
$20:
  %98 = phi i64 [%63, %$17] ; # C
  %99 = phi i64 [%64, %$17] ; # R
  %100 = phi i64 [%65, %$17] ; # Z
; # (if (atom R) (setq Z (setq R (safe (cons Y $Nil)))) (while (pair ...
; # (atom R)
  %101 = and i64 %99, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$28, label %$29
$28:
  %103 = phi i64 [%98, %$20] ; # C
  %104 = phi i64 [%99, %$20] ; # R
  %105 = phi i64 [%100, %$20] ; # Z
; # (cons Y $Nil)
  %106 = call i64 @cons(i64 %53, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (safe (cons Y $Nil))
  %107 = inttoptr i64 %19 to i64*
  store i64 %106, i64* %107
  br label %$30
$29:
  %108 = phi i64 [%98, %$20] ; # C
  %109 = phi i64 [%99, %$20] ; # R
  %110 = phi i64 [%100, %$20] ; # Z
; # (while (pair (cdr Z)) (inc 'C) (shift Z))
  br label %$31
$31:
  %111 = phi i64 [%108, %$29], [%122, %$32] ; # C
  %112 = phi i64 [%109, %$29], [%120, %$32] ; # R
  %113 = phi i64 [%110, %$29], [%125, %$32] ; # Z
; # (cdr Z)
  %114 = inttoptr i64 %113 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
; # (pair (cdr Z))
  %117 = and i64 %116, 15
  %118 = icmp eq i64 %117, 0
  br i1 %118, label %$32, label %$33
$32:
  %119 = phi i64 [%111, %$31] ; # C
  %120 = phi i64 [%112, %$31] ; # R
  %121 = phi i64 [%113, %$31] ; # Z
; # (inc 'C)
  %122 = add i64 %119, 1
; # (shift Z)
  %123 = inttoptr i64 %121 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  br label %$31
$33:
  %126 = phi i64 [%111, %$31] ; # C
  %127 = phi i64 [%112, %$31] ; # R
  %128 = phi i64 [%113, %$31] ; # Z
  br label %$30
$30:
  %129 = phi i64 [%103, %$28], [%126, %$33] ; # C
  %130 = phi i64 [%106, %$28], [%127, %$33] ; # R
  %131 = phi i64 [%106, %$28], [%128, %$33] ; # Z
; # (while (lt0 (inc 'C)) (setq Z (set 2 Z (cons Y $Nil))))
  br label %$34
$34:
  %132 = phi i64 [%129, %$30], [%137, %$35] ; # C
  %133 = phi i64 [%130, %$30], [%138, %$35] ; # R
  %134 = phi i64 [%131, %$30], [%140, %$35] ; # Z
; # (inc 'C)
  %135 = add i64 %132, 1
; # (lt0 (inc 'C))
  %136 = icmp slt i64 %135, 0
  br i1 %136, label %$35, label %$36
$35:
  %137 = phi i64 [%135, %$34] ; # C
  %138 = phi i64 [%133, %$34] ; # R
  %139 = phi i64 [%134, %$34] ; # Z
; # (set 2 Z (cons Y $Nil))
; # (cons Y $Nil)
  %140 = call i64 @cons(i64 %53, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %141 = inttoptr i64 %139 to i64*
  %142 = getelementptr i64, i64* %141, i32 1
  store i64 %140, i64* %142
  br label %$34
$36:
  %143 = phi i64 [%135, %$34] ; # C
  %144 = phi i64 [%133, %$34] ; # R
  %145 = phi i64 [%134, %$34] ; # Z
  br label %$19
$19:
  %146 = phi i64 [%95, %$27], [%143, %$36] ; # C
  %147 = phi i64 [%96, %$27], [%144, %$36] ; # R
  %148 = phi i64 [%97, %$27], [%145, %$36] ; # Z
  br label %$18
$18:
  %149 = phi i64 [%51, %$11], [%146, %$19] ; # C
  %150 = phi i64 [%52, %$11], [%147, %$19] ; # R
  %151 = phi i64 [%52, %$11], [%148, %$19] ; # Z
; # (drop *Safe)
  %152 = inttoptr i64 %19 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
  %155 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %154, i64* %155
  ret i64 %150
}

define i64 @_range(i64) {
$1:
; # (let (X (cdr Exe) N (needNum Exe (eval (++ X))) R (save (cons N $...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cons N $Nil)
  %18 = call i64 @cons(i64 %15, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons N $Nil))
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %18, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (++ X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
  %29 = getelementptr i64, i64* %27, i32 1
  %30 = load i64, i64* %29
; # (eval (++ X))
  %31 = and i64 %28, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$11, label %$10
$11:
  br label %$9
$10:
  %33 = and i64 %28, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$13, label %$12
$13:
  %35 = inttoptr i64 %28 to i64*
  %36 = load i64, i64* %35
  br label %$9
$12:
  %37 = call i64 @evList(i64 %28)
  br label %$9
$9:
  %38 = phi i64 [%28, %$11], [%36, %$13], [%37, %$12] ; # ->
; # (needNum Exe (eval (++ X)))
  %39 = and i64 %38, 6
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$15, label %$14
$14:
  call void @numErr(i64 %0, i64 %38)
  unreachable
$15:
; # (save (needNum Exe (eval (++ X))))
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %38, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %45 = load i64, i64* %44
  %46 = inttoptr i64 %42 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %48
; # (if (nil? (eval (car X))) ONE (save (needNum Exe @)))
; # (car X)
  %49 = inttoptr i64 %30 to i64*
  %50 = load i64, i64* %49
; # (eval (car X))
  %51 = and i64 %50, 6
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$18, label %$17
$18:
  br label %$16
$17:
  %53 = and i64 %50, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$20, label %$19
$20:
  %55 = inttoptr i64 %50 to i64*
  %56 = load i64, i64* %55
  br label %$16
$19:
  %57 = call i64 @evList(i64 %50)
  br label %$16
$16:
  %58 = phi i64 [%50, %$18], [%56, %$20], [%57, %$19] ; # ->
; # (nil? (eval (car X)))
  %59 = icmp eq i64 %58, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %59, label %$21, label %$22
$21:
  %60 = phi i64 [%15, %$16] ; # N
  br label %$23
$22:
  %61 = phi i64 [%15, %$16] ; # N
; # (needNum Exe @)
  %62 = and i64 %58, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$25, label %$24
$24:
  call void @numErr(i64 %0, i64 %58)
  unreachable
$25:
; # (save (needNum Exe @))
  %64 = alloca i64, i64 2, align 16
  %65 = ptrtoint i64* %64 to i64
  %66 = inttoptr i64 %65 to i64*
  store i64 %58, i64* %66
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %68 = load i64, i64* %67
  %69 = inttoptr i64 %65 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  store i64 %68, i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %71
  br label %$23
$23:
  %72 = phi i64 [%60, %$21], [%61, %$25] ; # N
  %73 = phi i64 [18, %$21], [%58, %$25] ; # ->
; # (when (or (== Inc ZERO) (sign? Inc)) (argErr Exe Inc))
; # (or (== Inc ZERO) (sign? Inc))
; # (== Inc ZERO)
  %74 = icmp eq i64 %73, 2
  br i1 %74, label %$26, label %$27
$27:
  %75 = phi i64 [%72, %$23] ; # N
; # (sign? Inc)
  %76 = and i64 %73, 8
  %77 = icmp ne i64 %76, 0
  br label %$26
$26:
  %78 = phi i64 [%72, %$23], [%75, %$27] ; # N
  %79 = phi i1 [1, %$23], [%77, %$27] ; # ->
  br i1 %79, label %$28, label %$29
$28:
  %80 = phi i64 [%78, %$26] ; # N
; # (argErr Exe Inc)
  call void @argErr(i64 %0, i64 %73)
  unreachable
$29:
  %81 = phi i64 [%78, %$26] ; # N
; # (let P R (if (le0 (cmpNum N Lim)) (while (le0 (cmpNum (setq N (ad...
; # (if (le0 (cmpNum N Lim)) (while (le0 (cmpNum (setq N (adds N Inc)...
; # (cmpNum N Lim)
  %82 = call i64 @cmpNum(i64 %81, i64 %38)
; # (le0 (cmpNum N Lim))
  %83 = icmp sle i64 %82, 0
  br i1 %83, label %$30, label %$31
$30:
  %84 = phi i64 [%81, %$29] ; # N
  %85 = phi i64 [%18, %$29] ; # P
; # (while (le0 (cmpNum (setq N (adds N Inc)) Lim)) (setq P (set 2 P ...
  br label %$33
$33:
  %86 = phi i64 [%84, %$30], [%91, %$34] ; # N
  %87 = phi i64 [%85, %$30], [%93, %$34] ; # P
; # (adds N Inc)
  %88 = call i64 @adds(i64 %86, i64 %73)
; # (cmpNum (setq N (adds N Inc)) Lim)
  %89 = call i64 @cmpNum(i64 %88, i64 %38)
; # (le0 (cmpNum (setq N (adds N Inc)) Lim))
  %90 = icmp sle i64 %89, 0
  br i1 %90, label %$34, label %$35
$34:
  %91 = phi i64 [%88, %$33] ; # N
  %92 = phi i64 [%87, %$33] ; # P
; # (set 2 P (cons N $Nil))
; # (cons N $Nil)
  %93 = call i64 @cons(i64 %91, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %94 = inttoptr i64 %92 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$33
$35:
  %96 = phi i64 [%88, %$33] ; # N
  %97 = phi i64 [%87, %$33] ; # P
  br label %$32
$31:
  %98 = phi i64 [%81, %$29] ; # N
  %99 = phi i64 [%18, %$29] ; # P
; # (while (ge0 (cmpNum (setq N (subs N Inc)) Lim)) (setq P (set 2 P ...
  br label %$36
$36:
  %100 = phi i64 [%98, %$31], [%105, %$37] ; # N
  %101 = phi i64 [%99, %$31], [%107, %$37] ; # P
; # (subs N Inc)
  %102 = call i64 @subs(i64 %100, i64 %73)
; # (cmpNum (setq N (subs N Inc)) Lim)
  %103 = call i64 @cmpNum(i64 %102, i64 %38)
; # (ge0 (cmpNum (setq N (subs N Inc)) Lim))
  %104 = icmp sge i64 %103, 0
  br i1 %104, label %$37, label %$38
$37:
  %105 = phi i64 [%102, %$36] ; # N
  %106 = phi i64 [%101, %$36] ; # P
; # (set 2 P (cons N $Nil))
; # (cons N $Nil)
  %107 = call i64 @cons(i64 %105, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %108 = inttoptr i64 %106 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  store i64 %107, i64* %109
  br label %$36
$38:
  %110 = phi i64 [%102, %$36] ; # N
  %111 = phi i64 [%101, %$36] ; # P
  br label %$32
$32:
  %112 = phi i64 [%96, %$35], [%110, %$38] ; # N
  %113 = phi i64 [%97, %$35], [%111, %$38] ; # P
; # (drop *Safe)
  %114 = inttoptr i64 %20 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %116, i64* %117
  ret i64 %18
}

define i64 @_full(i64) {
$1:
; # (let X (eval (cadr Exe)) (loop (? (atom X) $T) (? (nil? (car X)) ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (loop (? (atom X) $T) (? (nil? (car X)) $Nil) (shift X))
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%26, %$11] ; # X
; # (? (atom X) $T)
; # (atom X)
  %15 = and i64 %14, 15
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$8
$10:
  %17 = phi i64 [%14, %$7] ; # X
  br label %$9
$8:
  %18 = phi i64 [%14, %$7] ; # X
; # (? (nil? (car X)) $Nil)
; # (car X)
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
; # (nil? (car X))
  %21 = icmp eq i64 %20, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$12, label %$11
$12:
  %22 = phi i64 [%18, %$8] ; # X
  br label %$9
$11:
  %23 = phi i64 [%18, %$8] ; # X
; # (shift X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
  br label %$7
$9:
  %27 = phi i64 [%17, %$10], [%22, %$12] ; # X
  %28 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # ->
  ret i64 %28
}

define i64 @_make(i64) {
$1:
; # (let (Make (val $Make) Yoke (val $Yoke) R (link (push $Nil NIL)))...
; # (val $Make)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %2 = load i64, i64* %1
; # (val $Yoke)
  %3 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  %4 = load i64, i64* %3
; # (push $Nil NIL)
  %5 = alloca i64, i64 2, align 16
  %6 = ptrtoint i64* %5 to i64
  %7 = inttoptr i64 %6 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %7
; # (link (push $Nil NIL))
  %8 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %6 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  store i64 %9, i64* %11
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %6, i64* %12
; # (set $Make (set $Yoke R))
; # (set $Yoke R)
  %13 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  store i64 %6, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 %6, i64* %14
; # (cdr Exe)
  %15 = inttoptr i64 %0 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
; # (exec (cdr Exe))
  br label %$2
$2:
  %18 = phi i64 [%17, %$1], [%30, %$5] ; # Prg
  %19 = inttoptr i64 %18 to i64*
  %20 = load i64, i64* %19
  %21 = getelementptr i64, i64* %19, i32 1
  %22 = load i64, i64* %21
  %23 = and i64 %20, 15
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$3, label %$4
$3:
  %25 = phi i64 [%22, %$2] ; # Prg
  %26 = call i64 @evList(i64 %20)
  br label %$4
$4:
  %27 = phi i64 [%22, %$2], [%25, %$3] ; # Prg
  %28 = and i64 %27, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$6, label %$5
$5:
  %30 = phi i64 [%27, %$4] ; # Prg
  br label %$2
$6:
  %31 = phi i64 [%27, %$4] ; # Prg
  %32 = phi i64 [0, %$4] ; # ->
; # (set $Make Make $Yoke Yoke)
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 %2, i64* %33
  %34 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  store i64 %4, i64* %34
; # (pop R)
  %35 = inttoptr i64 %6 to i64*
  %36 = load i64, i64* %35
  %37 = inttoptr i64 %6 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %40
  ret i64 %36
}

define i64 @_made(i64) {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (when (pair X...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (when (pair X) (set (val $Yoke) (eval (++ X))) (let Y (eval (car ...
; # (pair X)
  %9 = and i64 %8, 15
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$4, label %$5
$4:
  %11 = phi i64 [%8, %$3] ; # X
; # (set (val $Yoke) (eval (++ X)))
; # (val $Yoke)
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  %13 = load i64, i64* %12
; # (++ X)
  %14 = inttoptr i64 %11 to i64*
  %15 = load i64, i64* %14
  %16 = getelementptr i64, i64* %14, i32 1
  %17 = load i64, i64* %16
; # (eval (++ X))
  %18 = and i64 %15, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$8, label %$7
$8:
  br label %$6
$7:
  %20 = and i64 %15, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$10, label %$9
$10:
  %22 = inttoptr i64 %15 to i64*
  %23 = load i64, i64* %22
  br label %$6
$9:
  %24 = call i64 @evList(i64 %15)
  br label %$6
$6:
  %25 = phi i64 [%15, %$8], [%23, %$10], [%24, %$9] ; # ->
  %26 = inttoptr i64 %13 to i64*
  store i64 %25, i64* %26
; # (let Y (eval (car X)) (when (atom Y) (setq Y (val (val $Yoke))) (...
; # (car X)
  %27 = inttoptr i64 %17 to i64*
  %28 = load i64, i64* %27
; # (eval (car X))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$13, label %$12
$13:
  br label %$11
$12:
  %31 = and i64 %28, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$15, label %$14
$15:
  %33 = inttoptr i64 %28 to i64*
  %34 = load i64, i64* %33
  br label %$11
$14:
  %35 = call i64 @evList(i64 %28)
  br label %$11
$11:
  %36 = phi i64 [%28, %$13], [%34, %$15], [%35, %$14] ; # ->
; # (when (atom Y) (setq Y (val (val $Yoke))) (while (pair (cdr Y)) (...
; # (atom Y)
  %37 = and i64 %36, 15
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%17, %$11] ; # X
  %40 = phi i64 [%36, %$11] ; # Y
; # (val $Yoke)
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  %42 = load i64, i64* %41
; # (val (val $Yoke))
  %43 = inttoptr i64 %42 to i64*
  %44 = load i64, i64* %43
; # (while (pair (cdr Y)) (setq Y @))
  br label %$18
$18:
  %45 = phi i64 [%39, %$16], [%52, %$19] ; # X
  %46 = phi i64 [%44, %$16], [%49, %$19] ; # Y
; # (cdr Y)
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
; # (pair (cdr Y))
  %50 = and i64 %49, 15
  %51 = icmp eq i64 %50, 0
  br i1 %51, label %$19, label %$20
$19:
  %52 = phi i64 [%45, %$18] ; # X
  %53 = phi i64 [%46, %$18] ; # Y
  br label %$18
$20:
  %54 = phi i64 [%45, %$18] ; # X
  %55 = phi i64 [%46, %$18] ; # Y
  br label %$17
$17:
  %56 = phi i64 [%17, %$11], [%54, %$20] ; # X
  %57 = phi i64 [%36, %$11], [%55, %$20] ; # Y
; # (set $Make (ofs Y 1))
; # (ofs Y 1)
  %58 = add i64 %57, 8
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 %58, i64* %59
  br label %$5
$5:
  %60 = phi i64 [%8, %$3], [%56, %$17] ; # X
; # (val $Yoke)
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  %62 = load i64, i64* %61
; # (val (val $Yoke))
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
  ret i64 %64
}

define i64 @_chain(i64) {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (loop (let Y ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (loop (let Y (set (val $Make) (eval (++ X))) (when (pair Y) (let ...
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%45, %$15] ; # X
; # (let Y (set (val $Make) (eval (++ X))) (when (pair Y) (let Z Y (w...
; # (set (val $Make) (eval (++ X)))
; # (val $Make)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %11 = load i64, i64* %10
; # (++ X)
  %12 = inttoptr i64 %9 to i64*
  %13 = load i64, i64* %12
  %14 = getelementptr i64, i64* %12, i32 1
  %15 = load i64, i64* %14
; # (eval (++ X))
  %16 = and i64 %13, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$7, label %$6
$7:
  br label %$5
$6:
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$8
$9:
  %20 = inttoptr i64 %13 to i64*
  %21 = load i64, i64* %20
  br label %$5
$8:
  %22 = call i64 @evList(i64 %13)
  br label %$5
$5:
  %23 = phi i64 [%13, %$7], [%21, %$9], [%22, %$8] ; # ->
  %24 = inttoptr i64 %11 to i64*
  store i64 %23, i64* %24
; # (when (pair Y) (let Z Y (while (pair (cdr Z)) (setq Z @)) (set $M...
; # (pair Y)
  %25 = and i64 %23, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$10, label %$11
$10:
  %27 = phi i64 [%15, %$5] ; # X
; # (let Z Y (while (pair (cdr Z)) (setq Z @)) (set $Make (ofs Z 1)))...
; # (while (pair (cdr Z)) (setq Z @))
  br label %$12
$12:
  %28 = phi i64 [%27, %$10], [%35, %$13] ; # X
  %29 = phi i64 [%23, %$10], [%32, %$13] ; # Z
; # (cdr Z)
  %30 = inttoptr i64 %29 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
; # (pair (cdr Z))
  %33 = and i64 %32, 15
  %34 = icmp eq i64 %33, 0
  br i1 %34, label %$13, label %$14
$13:
  %35 = phi i64 [%28, %$12] ; # X
  %36 = phi i64 [%29, %$12] ; # Z
  br label %$12
$14:
  %37 = phi i64 [%28, %$12] ; # X
  %38 = phi i64 [%29, %$12] ; # Z
; # (set $Make (ofs Z 1))
; # (ofs Z 1)
  %39 = add i64 %38, 8
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 %39, i64* %40
  br label %$11
$11:
  %41 = phi i64 [%15, %$5], [%37, %$14] ; # X
; # (? (atom X) Y)
; # (atom X)
  %42 = and i64 %41, 15
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$17, label %$15
$17:
  %44 = phi i64 [%41, %$11] ; # X
  br label %$16
$15:
  %45 = phi i64 [%41, %$11] ; # X
  br label %$4
$16:
  %46 = phi i64 [%44, %$17] ; # X
  %47 = phi i64 [%23, %$17] ; # ->
  ret i64 %47
}

define i64 @_link(i64) {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (loop (let Y ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (loop (let Y (eval (++ X)) (set $Make (ofs (set (val $Make) (cons...
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%31, %$10] ; # X
; # (let Y (eval (++ X)) (set $Make (ofs (set (val $Make) (cons Y $Ni...
; # (++ X)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (eval (++ X))
  %14 = and i64 %11, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  br label %$5
$6:
  %16 = and i64 %11, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = inttoptr i64 %11 to i64*
  %19 = load i64, i64* %18
  br label %$5
$8:
  %20 = call i64 @evList(i64 %11)
  br label %$5
$5:
  %21 = phi i64 [%11, %$7], [%19, %$9], [%20, %$8] ; # ->
; # (set $Make (ofs (set (val $Make) (cons Y $Nil)) 1))
; # (set (val $Make) (cons Y $Nil))
; # (val $Make)
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %23 = load i64, i64* %22
; # (cons Y $Nil)
  %24 = call i64 @cons(i64 %21, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %25 = inttoptr i64 %23 to i64*
  store i64 %24, i64* %25
; # (ofs (set (val $Make) (cons Y $Nil)) 1)
  %26 = add i64 %24, 8
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 %26, i64* %27
; # (? (atom X) Y)
; # (atom X)
  %28 = and i64 %13, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$10
$12:
  %30 = phi i64 [%13, %$5] ; # X
  br label %$11
$10:
  %31 = phi i64 [%13, %$5] ; # X
  br label %$4
$11:
  %32 = phi i64 [%30, %$12] ; # X
  %33 = phi i64 [%21, %$12] ; # ->
  ret i64 %33
}

define i64 @_yoke(i64) {
$1:
; # (let X (cdr Exe) (unless (val $Make) (makeErr Exe)) (loop (let Y ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (unless (val $Make) (makeErr Exe))
; # (val $Make)
  %4 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %5 = load i64, i64* %4
  %6 = icmp ne i64 %5, 0
  br i1 %6, label %$3, label %$2
$2:
  %7 = phi i64 [%3, %$1] ; # X
; # (makeErr Exe)
  call void @makeErr(i64 %0)
  unreachable
$3:
  %8 = phi i64 [%3, %$1] ; # X
; # (loop (let Y (eval (++ X)) (let P (val $Yoke) (set P (cons Y (val...
  br label %$4
$4:
  %9 = phi i64 [%8, %$3], [%45, %$10] ; # X
; # (let Y (eval (++ X)) (let P (val $Yoke) (set P (cons Y (val P))))...
; # (++ X)
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
  %12 = getelementptr i64, i64* %10, i32 1
  %13 = load i64, i64* %12
; # (eval (++ X))
  %14 = and i64 %11, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$6
$7:
  br label %$5
$6:
  %16 = and i64 %11, 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = inttoptr i64 %11 to i64*
  %19 = load i64, i64* %18
  br label %$5
$8:
  %20 = call i64 @evList(i64 %11)
  br label %$5
$5:
  %21 = phi i64 [%11, %$7], [%19, %$9], [%20, %$8] ; # ->
; # (let P (val $Yoke) (set P (cons Y (val P))))
; # (val $Yoke)
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 160) to i64) to i64*
  %23 = load i64, i64* %22
; # (set P (cons Y (val P)))
; # (val P)
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
; # (cons Y (val P))
  %26 = call i64 @cons(i64 %21, i64 %25)
  %27 = inttoptr i64 %23 to i64*
  store i64 %26, i64* %27
; # (? (atom X) (let Z (val $Make) (while (pair (val Z)) (setq Z (ofs...
; # (atom X)
  %28 = and i64 %13, 15
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$10
$12:
  %30 = phi i64 [%13, %$5] ; # X
; # (let Z (val $Make) (while (pair (val Z)) (setq Z (ofs @ 1))) (set...
; # (val $Make)
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  %32 = load i64, i64* %31
; # (while (pair (val Z)) (setq Z (ofs @ 1)))
  br label %$13
$13:
  %33 = phi i64 [%30, %$12], [%39, %$14] ; # X
  %34 = phi i64 [%32, %$12], [%41, %$14] ; # Z
; # (val Z)
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (pair (val Z))
  %37 = and i64 %36, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$14, label %$15
$14:
  %39 = phi i64 [%33, %$13] ; # X
  %40 = phi i64 [%34, %$13] ; # Z
; # (ofs @ 1)
  %41 = add i64 %36, 8
  br label %$13
$15:
  %42 = phi i64 [%33, %$13] ; # X
  %43 = phi i64 [%34, %$13] ; # Z
; # (set $Make Z)
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 152) to i64) to i64*
  store i64 %43, i64* %44
  br label %$11
$10:
  %45 = phi i64 [%13, %$5] ; # X
  br label %$4
$11:
  %46 = phi i64 [%42, %$15] ; # X
  %47 = phi i64 [%21, %$15] ; # ->
  ret i64 %47
}

define i64 @_copy(i64) {
$1:
; # (let X (cdr Exe) (if (atom (setq X (eval (car X)))) X (let (Y (co...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom (setq X (eval (car X)))) X (let (Y (cons (car X) (cdr X...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (atom (setq X (eval (car X))))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%13, %$2] ; # X
  br label %$9
$8:
  %17 = phi i64 [%13, %$2] ; # X
; # (let (Y (cons (car X) (cdr X)) R (save Y) Z X) (while (pair (setq...
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (cdr X)
  %20 = inttoptr i64 %17 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (cons (car X) (cdr X))
  %23 = call i64 @cons(i64 %19, i64 %22)
; # (save Y)
  %24 = alloca i64, i64 2, align 16
  %25 = ptrtoint i64* %24 to i64
  %26 = inttoptr i64 %25 to i64*
  store i64 %23, i64* %26
  %27 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %25 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  store i64 %28, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %31
; # (while (pair (setq X (cdr Y))) (? (== X Z) (set 2 Y R)) (setq Y (...
  br label %$10
$10:
  %32 = phi i64 [%17, %$8], [%46, %$13] ; # X
  %33 = phi i64 [%23, %$8], [%53, %$13] ; # Y
; # (cdr Y)
  %34 = inttoptr i64 %33 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  %36 = load i64, i64* %35
; # (pair (setq X (cdr Y)))
  %37 = and i64 %36, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$11, label %$12
$11:
  %39 = phi i64 [%36, %$10] ; # X
  %40 = phi i64 [%33, %$10] ; # Y
; # (? (== X Z) (set 2 Y R))
; # (== X Z)
  %41 = icmp eq i64 %39, %17
  br i1 %41, label %$14, label %$13
$14:
  %42 = phi i64 [%39, %$11] ; # X
  %43 = phi i64 [%40, %$11] ; # Y
; # (set 2 Y R)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  store i64 %23, i64* %45
  br label %$12
$13:
  %46 = phi i64 [%39, %$11] ; # X
  %47 = phi i64 [%40, %$11] ; # Y
; # (set 2 Y (cons (car X) (cdr X)))
; # (car X)
  %48 = inttoptr i64 %46 to i64*
  %49 = load i64, i64* %48
; # (cdr X)
  %50 = inttoptr i64 %46 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
; # (cons (car X) (cdr X))
  %53 = call i64 @cons(i64 %49, i64 %52)
  %54 = inttoptr i64 %47 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %53, i64* %55
  br label %$10
$12:
  %56 = phi i64 [%36, %$10], [%42, %$14] ; # X
  %57 = phi i64 [%33, %$10], [%43, %$14] ; # Y
; # (drop *Safe)
  %58 = inttoptr i64 %25 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  %61 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %60, i64* %61
  br label %$9
$9:
  %62 = phi i64 [%16, %$7], [%56, %$12] ; # X
  %63 = phi i64 [%16, %$7], [%23, %$12] ; # ->
  ret i64 %63
}

define i64 @_mix(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (nond ((or (pair Y) (nil? Y))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nond ((or (pair Y) (nil? Y)) Y) ((pair (shift X)) $Nil) (NIL (sa...
; # (or (pair Y) (nil? Y))
; # (pair Y)
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$8, label %$9
$9:
  %16 = phi i64 [%3, %$2] ; # X
; # (nil? Y)
  %17 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$8
$8:
  %18 = phi i64 [%3, %$2], [%16, %$9] ; # X
  %19 = phi i1 [1, %$2], [%17, %$9] ; # ->
  br i1 %19, label %$10, label %$11
$11:
  %20 = phi i64 [%18, %$8] ; # X
  br label %$7
$10:
  %21 = phi i64 [%18, %$8] ; # X
; # (shift X)
  %22 = inttoptr i64 %21 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
; # (pair (shift X))
  %25 = and i64 %24, 15
  %26 = icmp eq i64 %25, 0
  br i1 %26, label %$12, label %$13
$13:
  %27 = phi i64 [%24, %$10] ; # X
  br label %$7
$12:
  %28 = phi i64 [%24, %$10] ; # X
; # (save Y (let (Z (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil...
  %29 = alloca i64, i64 2, align 16
  %30 = ptrtoint i64* %29 to i64
  %31 = inttoptr i64 %30 to i64*
  store i64 %13, i64* %31
  %32 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %30 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  store i64 %33, i64* %35
  %36 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %30, i64* %36
; # (let (Z (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil) R (sav...
; # (if (cnt? (car X)) (nth @ Y) (eval @))
; # (car X)
  %37 = inttoptr i64 %28 to i64*
  %38 = load i64, i64* %37
; # (cnt? (car X))
  %39 = and i64 %38, 2
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$14, label %$15
$14:
  %41 = phi i64 [%28, %$12] ; # X
; # (nth @ Y)
  %42 = lshr i64 %38, 4
  br label %$17
$17:
  %43 = phi i64 [%13, %$14], [%51, %$18] ; # X
  %44 = phi i64 [%42, %$14], [%48, %$18] ; # C
  %45 = sub i64 %44, 1
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$18, label %$19
$18:
  %47 = phi i64 [%43, %$17] ; # X
  %48 = phi i64 [%45, %$17] ; # C
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
  br label %$17
$19:
  %52 = phi i64 [%43, %$17] ; # X
  %53 = phi i64 [%45, %$17] ; # C
  %54 = and i64 %38, 8
  %55 = icmp ne i64 %54, 0
  br i1 %55, label %$20, label %$21
$20:
  %56 = phi i64 [%52, %$19] ; # X
  %57 = phi i64 [%53, %$19] ; # C
  %58 = inttoptr i64 %56 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  br label %$22
$21:
  %61 = phi i64 [%52, %$19] ; # X
  %62 = phi i64 [%53, %$19] ; # C
  %63 = inttoptr i64 %61 to i64*
  %64 = load i64, i64* %63
  br label %$22
$22:
  %65 = phi i64 [%56, %$20], [%61, %$21] ; # X
  %66 = phi i64 [%57, %$20], [%62, %$21] ; # C
  %67 = phi i64 [%60, %$20], [%64, %$21] ; # ->
  br label %$16
$15:
  %68 = phi i64 [%28, %$12] ; # X
; # (eval @)
  %69 = and i64 %38, 6
  %70 = icmp ne i64 %69, 0
  br i1 %70, label %$25, label %$24
$25:
  br label %$23
$24:
  %71 = and i64 %38, 8
  %72 = icmp ne i64 %71, 0
  br i1 %72, label %$27, label %$26
$27:
  %73 = inttoptr i64 %38 to i64*
  %74 = load i64, i64* %73
  br label %$23
$26:
  %75 = call i64 @evList(i64 %38)
  br label %$23
$23:
  %76 = phi i64 [%38, %$25], [%74, %$27], [%75, %$26] ; # ->
  br label %$16
$16:
  %77 = phi i64 [%41, %$22], [%68, %$23] ; # X
  %78 = phi i64 [%67, %$22], [%76, %$23] ; # ->
; # (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil)
  %79 = call i64 @cons(i64 %78, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Z)
  %80 = alloca i64, i64 2, align 16
  %81 = ptrtoint i64* %80 to i64
  %82 = inttoptr i64 %81 to i64*
  store i64 %79, i64* %82
  %83 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %84 = load i64, i64* %83
  %85 = inttoptr i64 %81 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  store i64 %84, i64* %86
  %87 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %81, i64* %87
; # (while (pair (shift X)) (setq Z (set 2 Z (cons (if (cnt? (car X))...
  br label %$28
$28:
  %88 = phi i64 [%77, %$16], [%139, %$33] ; # X
  %89 = phi i64 [%79, %$16], [%142, %$33] ; # Z
; # (shift X)
  %90 = inttoptr i64 %88 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  %92 = load i64, i64* %91
; # (pair (shift X))
  %93 = and i64 %92, 15
  %94 = icmp eq i64 %93, 0
  br i1 %94, label %$29, label %$30
$29:
  %95 = phi i64 [%92, %$28] ; # X
  %96 = phi i64 [%89, %$28] ; # Z
; # (set 2 Z (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil))
; # (if (cnt? (car X)) (nth @ Y) (eval @))
; # (car X)
  %97 = inttoptr i64 %95 to i64*
  %98 = load i64, i64* %97
; # (cnt? (car X))
  %99 = and i64 %98, 2
  %100 = icmp ne i64 %99, 0
  br i1 %100, label %$31, label %$32
$31:
  %101 = phi i64 [%95, %$29] ; # X
  %102 = phi i64 [%96, %$29] ; # Z
; # (nth @ Y)
  %103 = lshr i64 %98, 4
  br label %$34
$34:
  %104 = phi i64 [%13, %$31], [%112, %$35] ; # X
  %105 = phi i64 [%103, %$31], [%109, %$35] ; # C
  %106 = sub i64 %105, 1
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$35, label %$36
$35:
  %108 = phi i64 [%104, %$34] ; # X
  %109 = phi i64 [%106, %$34] ; # C
  %110 = inttoptr i64 %108 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  %112 = load i64, i64* %111
  br label %$34
$36:
  %113 = phi i64 [%104, %$34] ; # X
  %114 = phi i64 [%106, %$34] ; # C
  %115 = and i64 %98, 8
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$37, label %$38
$37:
  %117 = phi i64 [%113, %$36] ; # X
  %118 = phi i64 [%114, %$36] ; # C
  %119 = inttoptr i64 %117 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  br label %$39
$38:
  %122 = phi i64 [%113, %$36] ; # X
  %123 = phi i64 [%114, %$36] ; # C
  %124 = inttoptr i64 %122 to i64*
  %125 = load i64, i64* %124
  br label %$39
$39:
  %126 = phi i64 [%117, %$37], [%122, %$38] ; # X
  %127 = phi i64 [%118, %$37], [%123, %$38] ; # C
  %128 = phi i64 [%121, %$37], [%125, %$38] ; # ->
  br label %$33
$32:
  %129 = phi i64 [%95, %$29] ; # X
  %130 = phi i64 [%96, %$29] ; # Z
; # (eval @)
  %131 = and i64 %98, 6
  %132 = icmp ne i64 %131, 0
  br i1 %132, label %$42, label %$41
$42:
  br label %$40
$41:
  %133 = and i64 %98, 8
  %134 = icmp ne i64 %133, 0
  br i1 %134, label %$44, label %$43
$44:
  %135 = inttoptr i64 %98 to i64*
  %136 = load i64, i64* %135
  br label %$40
$43:
  %137 = call i64 @evList(i64 %98)
  br label %$40
$40:
  %138 = phi i64 [%98, %$42], [%136, %$44], [%137, %$43] ; # ->
  br label %$33
$33:
  %139 = phi i64 [%101, %$39], [%129, %$40] ; # X
  %140 = phi i64 [%102, %$39], [%130, %$40] ; # Z
  %141 = phi i64 [%128, %$39], [%138, %$40] ; # ->
; # (cons (if (cnt? (car X)) (nth @ Y) (eval @)) $Nil)
  %142 = call i64 @cons(i64 %141, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %143 = inttoptr i64 %96 to i64*
  %144 = getelementptr i64, i64* %143, i32 1
  store i64 %142, i64* %144
  br label %$28
$30:
  %145 = phi i64 [%92, %$28] ; # X
  %146 = phi i64 [%89, %$28] ; # Z
  %147 = inttoptr i64 %30 to i64*
  %148 = getelementptr i64, i64* %147, i32 1
  %149 = load i64, i64* %148
  %150 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %149, i64* %150
  br label %$7
$7:
  %151 = phi i64 [%20, %$11], [%27, %$13], [%145, %$30] ; # X
  %152 = phi i64 [%13, %$11], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%79, %$30] ; # ->
  ret i64 %152
}

define i64 @_append(i64) {
$1:
; # (let X Exe (loop (? (atom (cdr (shift X))) (eval (car X))) (? (pa...
; # (loop (? (atom (cdr (shift X))) (eval (car X))) (? (pair (eval (c...
  br label %$2
$2:
  %1 = phi i64 [%0, %$1], [%138, %$16] ; # X
; # (? (atom (cdr (shift X))) (eval (car X)))
; # (shift X)
  %2 = inttoptr i64 %1 to i64*
  %3 = getelementptr i64, i64* %2, i32 1
  %4 = load i64, i64* %3
; # (cdr (shift X))
  %5 = inttoptr i64 %4 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (atom (cdr (shift X)))
  %8 = and i64 %7, 15
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$5, label %$3
$5:
  %10 = phi i64 [%4, %$2] ; # X
; # (car X)
  %11 = inttoptr i64 %10 to i64*
  %12 = load i64, i64* %11
; # (eval (car X))
  %13 = and i64 %12, 6
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %$8, label %$7
$8:
  br label %$6
$7:
  %15 = and i64 %12, 8
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$10, label %$9
$10:
  %17 = inttoptr i64 %12 to i64*
  %18 = load i64, i64* %17
  br label %$6
$9:
  %19 = call i64 @evList(i64 %12)
  br label %$6
$6:
  %20 = phi i64 [%12, %$8], [%18, %$10], [%19, %$9] ; # ->
  br label %$4
$3:
  %21 = phi i64 [%4, %$2] ; # X
; # (? (pair (eval (car X))) (let (Y @ R (save (cons (car Y) (cdr Y))...
; # (car X)
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
; # (eval (car X))
  %24 = and i64 %23, 6
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$13, label %$12
$13:
  br label %$11
$12:
  %26 = and i64 %23, 8
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$15, label %$14
$15:
  %28 = inttoptr i64 %23 to i64*
  %29 = load i64, i64* %28
  br label %$11
$14:
  %30 = call i64 @evList(i64 %23)
  br label %$11
$11:
  %31 = phi i64 [%23, %$13], [%29, %$15], [%30, %$14] ; # ->
; # (pair (eval (car X)))
  %32 = and i64 %31, 15
  %33 = icmp eq i64 %32, 0
  br i1 %33, label %$17, label %$16
$17:
  %34 = phi i64 [%21, %$11] ; # X
; # (let (Y @ R (save (cons (car Y) (cdr Y))) Z R) (while (pair (setq...
; # (car Y)
  %35 = inttoptr i64 %31 to i64*
  %36 = load i64, i64* %35
; # (cdr Y)
  %37 = inttoptr i64 %31 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
; # (cons (car Y) (cdr Y))
  %40 = call i64 @cons(i64 %36, i64 %39)
; # (save (cons (car Y) (cdr Y)))
  %41 = alloca i64, i64 2, align 16
  %42 = ptrtoint i64* %41 to i64
  %43 = inttoptr i64 %42 to i64*
  store i64 %40, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %45 = load i64, i64* %44
  %46 = inttoptr i64 %42 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  store i64 %45, i64* %47
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %42, i64* %48
; # (while (pair (setq Y (cdr Z))) (setq Z (set 2 Z (cons (car Y) (cd...
  br label %$18
$18:
  %49 = phi i64 [%34, %$17], [%57, %$19] ; # X
  %50 = phi i64 [%31, %$17], [%58, %$19] ; # Y
  %51 = phi i64 [%40, %$17], [%65, %$19] ; # Z
; # (cdr Z)
  %52 = inttoptr i64 %51 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (pair (setq Y (cdr Z)))
  %55 = and i64 %54, 15
  %56 = icmp eq i64 %55, 0
  br i1 %56, label %$19, label %$20
$19:
  %57 = phi i64 [%49, %$18] ; # X
  %58 = phi i64 [%54, %$18] ; # Y
  %59 = phi i64 [%51, %$18] ; # Z
; # (set 2 Z (cons (car Y) (cdr Y)))
; # (car Y)
  %60 = inttoptr i64 %58 to i64*
  %61 = load i64, i64* %60
; # (cdr Y)
  %62 = inttoptr i64 %58 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (cons (car Y) (cdr Y))
  %65 = call i64 @cons(i64 %61, i64 %64)
  %66 = inttoptr i64 %59 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  store i64 %65, i64* %67
  br label %$18
$20:
  %68 = phi i64 [%49, %$18] ; # X
  %69 = phi i64 [%54, %$18] ; # Y
  %70 = phi i64 [%51, %$18] ; # Z
; # (while (pair (cdr (shift X))) (setq Y (eval (car X))) (while (pai...
  br label %$21
$21:
  %71 = phi i64 [%68, %$20], [%114, %$31] ; # X
  %72 = phi i64 [%69, %$20], [%115, %$31] ; # Y
  %73 = phi i64 [%70, %$20], [%116, %$31] ; # Z
; # (shift X)
  %74 = inttoptr i64 %71 to i64*
  %75 = getelementptr i64, i64* %74, i32 1
  %76 = load i64, i64* %75
; # (cdr (shift X))
  %77 = inttoptr i64 %76 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  %79 = load i64, i64* %78
; # (pair (cdr (shift X)))
  %80 = and i64 %79, 15
  %81 = icmp eq i64 %80, 0
  br i1 %81, label %$22, label %$23
$22:
  %82 = phi i64 [%76, %$21] ; # X
  %83 = phi i64 [%72, %$21] ; # Y
  %84 = phi i64 [%73, %$21] ; # Z
; # (car X)
  %85 = inttoptr i64 %82 to i64*
  %86 = load i64, i64* %85
; # (eval (car X))
  %87 = and i64 %86, 6
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$26, label %$25
$26:
  br label %$24
$25:
  %89 = and i64 %86, 8
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$28, label %$27
$28:
  %91 = inttoptr i64 %86 to i64*
  %92 = load i64, i64* %91
  br label %$24
$27:
  %93 = call i64 @evList(i64 %86)
  br label %$24
$24:
  %94 = phi i64 [%86, %$26], [%92, %$28], [%93, %$27] ; # ->
; # (while (pair Y) (setq Z (set 2 Z (cons (car Y) (cdr Y)))) (shift ...
  br label %$29
$29:
  %95 = phi i64 [%82, %$24], [%100, %$30] ; # X
  %96 = phi i64 [%94, %$24], [%113, %$30] ; # Y
  %97 = phi i64 [%84, %$24], [%108, %$30] ; # Z
; # (pair Y)
  %98 = and i64 %96, 15
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %$30, label %$31
$30:
  %100 = phi i64 [%95, %$29] ; # X
  %101 = phi i64 [%96, %$29] ; # Y
  %102 = phi i64 [%97, %$29] ; # Z
; # (set 2 Z (cons (car Y) (cdr Y)))
; # (car Y)
  %103 = inttoptr i64 %101 to i64*
  %104 = load i64, i64* %103
; # (cdr Y)
  %105 = inttoptr i64 %101 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
; # (cons (car Y) (cdr Y))
  %108 = call i64 @cons(i64 %104, i64 %107)
  %109 = inttoptr i64 %102 to i64*
  %110 = getelementptr i64, i64* %109, i32 1
  store i64 %108, i64* %110
; # (shift Y)
  %111 = inttoptr i64 %101 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  %113 = load i64, i64* %112
  br label %$29
$31:
  %114 = phi i64 [%95, %$29] ; # X
  %115 = phi i64 [%96, %$29] ; # Y
  %116 = phi i64 [%97, %$29] ; # Z
; # (set 2 Z Y)
  %117 = inttoptr i64 %116 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  store i64 %115, i64* %118
  br label %$21
$23:
  %119 = phi i64 [%76, %$21] ; # X
  %120 = phi i64 [%72, %$21] ; # Y
  %121 = phi i64 [%73, %$21] ; # Z
; # (set 2 Z (eval (car X)))
; # (car X)
  %122 = inttoptr i64 %119 to i64*
  %123 = load i64, i64* %122
; # (eval (car X))
  %124 = and i64 %123, 6
  %125 = icmp ne i64 %124, 0
  br i1 %125, label %$34, label %$33
$34:
  br label %$32
$33:
  %126 = and i64 %123, 8
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$36, label %$35
$36:
  %128 = inttoptr i64 %123 to i64*
  %129 = load i64, i64* %128
  br label %$32
$35:
  %130 = call i64 @evList(i64 %123)
  br label %$32
$32:
  %131 = phi i64 [%123, %$34], [%129, %$36], [%130, %$35] ; # ->
  %132 = inttoptr i64 %121 to i64*
  %133 = getelementptr i64, i64* %132, i32 1
  store i64 %131, i64* %133
; # (drop *Safe)
  %134 = inttoptr i64 %42 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  %136 = load i64, i64* %135
  %137 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %136, i64* %137
  br label %$4
$16:
  %138 = phi i64 [%21, %$11] ; # X
  br label %$2
$4:
  %139 = phi i64 [%10, %$6], [%119, %$32] ; # X
  %140 = phi i64 [%20, %$6], [%40, %$32] ; # ->
  ret i64 %140
}

define i64 @_delete(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) L (save (eval (++ X))) F...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %35, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %43
; # (car X)
  %44 = inttoptr i64 %27 to i64*
  %45 = load i64, i64* %44
; # (eval (car X))
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  br label %$12
$13:
  %48 = and i64 %45, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$16, label %$15
$16:
  %50 = inttoptr i64 %45 to i64*
  %51 = load i64, i64* %50
  br label %$12
$15:
  %52 = call i64 @evList(i64 %45)
  br label %$12
$12:
  %53 = phi i64 [%45, %$14], [%51, %$16], [%52, %$15] ; # ->
; # (nil? (eval (car X)))
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (loop (? (atom L) L) (? (not (equal Y (car L))) (let R (save (set...
  br label %$17
$17:
  %55 = phi i64 [%27, %$12], [%126, %$32] ; # X
  %56 = phi i64 [%35, %$12], [%127, %$32] ; # L
; # (? (atom L) L)
; # (atom L)
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$20, label %$18
$20:
  %59 = phi i64 [%55, %$17] ; # X
  %60 = phi i64 [%56, %$17] ; # L
  br label %$19
$18:
  %61 = phi i64 [%55, %$17] ; # X
  %62 = phi i64 [%56, %$17] ; # L
; # (? (not (equal Y (car L))) (let R (save (setq X (cons (car L) $Ni...
; # (car L)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (equal Y (car L))
  %65 = call i1 @equal(i64 %15, i64 %64)
; # (not (equal Y (car L)))
  %66 = icmp eq i1 %65, 0
  br i1 %66, label %$22, label %$21
$22:
  %67 = phi i64 [%61, %$18] ; # X
  %68 = phi i64 [%62, %$18] ; # L
; # (let R (save (setq X (cons (car L) $Nil))) (loop (? (atom (shift ...
; # (car L)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (cons (car L) $Nil)
  %71 = call i64 @cons(i64 %70, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (setq X (cons (car L) $Nil)))
  %72 = alloca i64, i64 2, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = inttoptr i64 %73 to i64*
  store i64 %71, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %73 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %79
; # (loop (? (atom (shift L)) (set 2 X L)) (ifn (equal Y (car L)) (se...
  br label %$23
$23:
  %80 = phi i64 [%71, %$22], [%114, %$29] ; # X
  %81 = phi i64 [%68, %$22], [%115, %$29] ; # L
; # (? (atom (shift L)) (set 2 X L))
; # (shift L)
  %82 = inttoptr i64 %81 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  %84 = load i64, i64* %83
; # (atom (shift L))
  %85 = and i64 %84, 15
  %86 = icmp ne i64 %85, 0
  br i1 %86, label %$26, label %$24
$26:
  %87 = phi i64 [%80, %$23] ; # X
  %88 = phi i64 [%84, %$23] ; # L
; # (set 2 X L)
  %89 = inttoptr i64 %87 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  store i64 %88, i64* %90
  br label %$25
$24:
  %91 = phi i64 [%80, %$23] ; # X
  %92 = phi i64 [%84, %$23] ; # L
; # (ifn (equal Y (car L)) (setq X (set 2 X (cons (car L) $Nil))) (? ...
; # (car L)
  %93 = inttoptr i64 %92 to i64*
  %94 = load i64, i64* %93
; # (equal Y (car L))
  %95 = call i1 @equal(i64 %15, i64 %94)
  br i1 %95, label %$28, label %$27
$27:
  %96 = phi i64 [%91, %$24] ; # X
  %97 = phi i64 [%92, %$24] ; # L
; # (set 2 X (cons (car L) $Nil))
; # (car L)
  %98 = inttoptr i64 %97 to i64*
  %99 = load i64, i64* %98
; # (cons (car L) $Nil)
  %100 = call i64 @cons(i64 %99, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %101 = inttoptr i64 %96 to i64*
  %102 = getelementptr i64, i64* %101, i32 1
  store i64 %100, i64* %102
  br label %$29
$28:
  %103 = phi i64 [%91, %$24] ; # X
  %104 = phi i64 [%92, %$24] ; # L
; # (? F (set 2 X (cdr L)))
  br i1 %54, label %$31, label %$30
$31:
  %105 = phi i64 [%103, %$28] ; # X
  %106 = phi i64 [%104, %$28] ; # L
; # (set 2 X (cdr L))
; # (cdr L)
  %107 = inttoptr i64 %106 to i64*
  %108 = getelementptr i64, i64* %107, i32 1
  %109 = load i64, i64* %108
  %110 = inttoptr i64 %105 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$25
$30:
  %112 = phi i64 [%103, %$28] ; # X
  %113 = phi i64 [%104, %$28] ; # L
  br label %$29
$29:
  %114 = phi i64 [%100, %$27], [%112, %$30] ; # X
  %115 = phi i64 [%97, %$27], [%113, %$30] ; # L
  br label %$23
$25:
  %116 = phi i64 [%87, %$26], [%105, %$31] ; # X
  %117 = phi i64 [%88, %$26], [%106, %$31] ; # L
  %118 = phi i64 [%88, %$26], [%109, %$31] ; # ->
  br label %$19
$21:
  %119 = phi i64 [%61, %$18] ; # X
  %120 = phi i64 [%62, %$18] ; # L
; # (shift L)
  %121 = inttoptr i64 %120 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  %123 = load i64, i64* %122
; # (? F L)
  br i1 %54, label %$33, label %$32
$33:
  %124 = phi i64 [%119, %$21] ; # X
  %125 = phi i64 [%123, %$21] ; # L
  br label %$19
$32:
  %126 = phi i64 [%119, %$21] ; # X
  %127 = phi i64 [%123, %$21] ; # L
  br label %$17
$19:
  %128 = phi i64 [%59, %$20], [%116, %$25], [%124, %$33] ; # X
  %129 = phi i64 [%60, %$20], [%117, %$25], [%125, %$33] ; # L
  %130 = phi i64 [%60, %$20], [%71, %$25], [%125, %$33] ; # ->
; # (drop *Safe)
  %131 = inttoptr i64 %17 to i64*
  %132 = getelementptr i64, i64* %131, i32 1
  %133 = load i64, i64* %132
  %134 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %133, i64* %134
  ret i64 %130
}

define i64 @_delq(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) L (save (eval (++ X))) F...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %35, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %43
; # (car X)
  %44 = inttoptr i64 %27 to i64*
  %45 = load i64, i64* %44
; # (eval (car X))
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  br label %$12
$13:
  %48 = and i64 %45, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$16, label %$15
$16:
  %50 = inttoptr i64 %45 to i64*
  %51 = load i64, i64* %50
  br label %$12
$15:
  %52 = call i64 @evList(i64 %45)
  br label %$12
$12:
  %53 = phi i64 [%45, %$14], [%51, %$16], [%52, %$15] ; # ->
; # (nil? (eval (car X)))
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (loop (? (atom L) L) (? (<> Y (car L)) (let R (save (setq X (cons...
  br label %$17
$17:
  %55 = phi i64 [%27, %$12], [%125, %$32] ; # X
  %56 = phi i64 [%35, %$12], [%126, %$32] ; # L
; # (? (atom L) L)
; # (atom L)
  %57 = and i64 %56, 15
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$20, label %$18
$20:
  %59 = phi i64 [%55, %$17] ; # X
  %60 = phi i64 [%56, %$17] ; # L
  br label %$19
$18:
  %61 = phi i64 [%55, %$17] ; # X
  %62 = phi i64 [%56, %$17] ; # L
; # (? (<> Y (car L)) (let R (save (setq X (cons (car L) $Nil))) (loo...
; # (car L)
  %63 = inttoptr i64 %62 to i64*
  %64 = load i64, i64* %63
; # (<> Y (car L))
  %65 = icmp ne i64 %15, %64
  br i1 %65, label %$22, label %$21
$22:
  %66 = phi i64 [%61, %$18] ; # X
  %67 = phi i64 [%62, %$18] ; # L
; # (let R (save (setq X (cons (car L) $Nil))) (loop (? (atom (shift ...
; # (car L)
  %68 = inttoptr i64 %67 to i64*
  %69 = load i64, i64* %68
; # (cons (car L) $Nil)
  %70 = call i64 @cons(i64 %69, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (setq X (cons (car L) $Nil)))
  %71 = alloca i64, i64 2, align 16
  %72 = ptrtoint i64* %71 to i64
  %73 = inttoptr i64 %72 to i64*
  store i64 %70, i64* %73
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %75 = load i64, i64* %74
  %76 = inttoptr i64 %72 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  store i64 %75, i64* %77
  %78 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %72, i64* %78
; # (loop (? (atom (shift L)) (set 2 X L)) (if (<> Y (car L)) (setq X...
  br label %$23
$23:
  %79 = phi i64 [%70, %$22], [%113, %$29] ; # X
  %80 = phi i64 [%67, %$22], [%114, %$29] ; # L
; # (? (atom (shift L)) (set 2 X L))
; # (shift L)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (atom (shift L))
  %84 = and i64 %83, 15
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$26, label %$24
$26:
  %86 = phi i64 [%79, %$23] ; # X
  %87 = phi i64 [%83, %$23] ; # L
; # (set 2 X L)
  %88 = inttoptr i64 %86 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  store i64 %87, i64* %89
  br label %$25
$24:
  %90 = phi i64 [%79, %$23] ; # X
  %91 = phi i64 [%83, %$23] ; # L
; # (if (<> Y (car L)) (setq X (set 2 X (cons (car L) $Nil))) (? F (s...
; # (car L)
  %92 = inttoptr i64 %91 to i64*
  %93 = load i64, i64* %92
; # (<> Y (car L))
  %94 = icmp ne i64 %15, %93
  br i1 %94, label %$27, label %$28
$27:
  %95 = phi i64 [%90, %$24] ; # X
  %96 = phi i64 [%91, %$24] ; # L
; # (set 2 X (cons (car L) $Nil))
; # (car L)
  %97 = inttoptr i64 %96 to i64*
  %98 = load i64, i64* %97
; # (cons (car L) $Nil)
  %99 = call i64 @cons(i64 %98, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %100 = inttoptr i64 %95 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  store i64 %99, i64* %101
  br label %$29
$28:
  %102 = phi i64 [%90, %$24] ; # X
  %103 = phi i64 [%91, %$24] ; # L
; # (? F (set 2 X (cdr L)))
  br i1 %54, label %$31, label %$30
$31:
  %104 = phi i64 [%102, %$28] ; # X
  %105 = phi i64 [%103, %$28] ; # L
; # (set 2 X (cdr L))
; # (cdr L)
  %106 = inttoptr i64 %105 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
  %109 = inttoptr i64 %104 to i64*
  %110 = getelementptr i64, i64* %109, i32 1
  store i64 %108, i64* %110
  br label %$25
$30:
  %111 = phi i64 [%102, %$28] ; # X
  %112 = phi i64 [%103, %$28] ; # L
  br label %$29
$29:
  %113 = phi i64 [%99, %$27], [%111, %$30] ; # X
  %114 = phi i64 [%96, %$27], [%112, %$30] ; # L
  br label %$23
$25:
  %115 = phi i64 [%86, %$26], [%104, %$31] ; # X
  %116 = phi i64 [%87, %$26], [%105, %$31] ; # L
  %117 = phi i64 [%87, %$26], [%108, %$31] ; # ->
  br label %$19
$21:
  %118 = phi i64 [%61, %$18] ; # X
  %119 = phi i64 [%62, %$18] ; # L
; # (shift L)
  %120 = inttoptr i64 %119 to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  %122 = load i64, i64* %121
; # (? F L)
  br i1 %54, label %$33, label %$32
$33:
  %123 = phi i64 [%118, %$21] ; # X
  %124 = phi i64 [%122, %$21] ; # L
  br label %$19
$32:
  %125 = phi i64 [%118, %$21] ; # X
  %126 = phi i64 [%122, %$21] ; # L
  br label %$17
$19:
  %127 = phi i64 [%59, %$20], [%115, %$25], [%123, %$33] ; # X
  %128 = phi i64 [%60, %$20], [%116, %$25], [%124, %$33] ; # L
  %129 = phi i64 [%60, %$20], [%70, %$25], [%124, %$33] ; # ->
; # (drop *Safe)
  %130 = inttoptr i64 %17 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  %132 = load i64, i64* %131
  %133 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %132, i64* %133
  ret i64 %129
}

define i64 @_replace(i64) {
$1:
; # (let (X (cdr Exe) L (save (eval (car X)))) (if (atom L) @ (let (A...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (if (atom L) @ (let (A $Nil N 0 R (push NIL NIL)) (while (pair (s...
; # (atom L)
  %22 = and i64 %13, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$7, label %$8
$7:
  %24 = phi i64 [%3, %$2] ; # X
  %25 = phi i64 [%13, %$2] ; # L
  br label %$9
$8:
  %26 = phi i64 [%3, %$2] ; # X
  %27 = phi i64 [%13, %$2] ; # L
; # (let (A $Nil N 0 R (push NIL NIL)) (while (pair (shift X)) (link ...
; # (push NIL NIL)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
; # (while (pair (shift X)) (link (push (eval (++ X)) NIL)) (setq A (...
  br label %$10
$10:
  %30 = phi i64 [%26, %$8], [%46, %$18] ; # X
  %31 = phi i64 [%27, %$8], [%40, %$18] ; # L
  %32 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8], [%74, %$18] ; # A
  %33 = phi i64 [0, %$8], [%81, %$18] ; # N
; # (shift X)
  %34 = inttoptr i64 %30 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  %36 = load i64, i64* %35
; # (pair (shift X))
  %37 = and i64 %36, 15
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$11, label %$12
$11:
  %39 = phi i64 [%36, %$10] ; # X
  %40 = phi i64 [%31, %$10] ; # L
  %41 = phi i64 [%32, %$10] ; # A
  %42 = phi i64 [%33, %$10] ; # N
; # (++ X)
  %43 = inttoptr i64 %39 to i64*
  %44 = load i64, i64* %43
  %45 = getelementptr i64, i64* %43, i32 1
  %46 = load i64, i64* %45
; # (eval (++ X))
  %47 = and i64 %44, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$15, label %$14
$15:
  br label %$13
$14:
  %49 = and i64 %44, 8
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$17, label %$16
$17:
  %51 = inttoptr i64 %44 to i64*
  %52 = load i64, i64* %51
  br label %$13
$16:
  %53 = call i64 @evList(i64 %44)
  br label %$13
$13:
  %54 = phi i64 [%44, %$15], [%52, %$17], [%53, %$16] ; # ->
; # (push (eval (++ X)) NIL)
  %55 = alloca i64, i64 2, align 16
  %56 = ptrtoint i64* %55 to i64
  %57 = inttoptr i64 %56 to i64*
  store i64 %54, i64* %57
; # (link (push (eval (++ X)) NIL))
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %59 = load i64, i64* %58
  %60 = inttoptr i64 %56 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  store i64 %59, i64* %61
  %62 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %56, i64* %62
; # (car X)
  %63 = inttoptr i64 %46 to i64*
  %64 = load i64, i64* %63
; # (eval (car X))
  %65 = and i64 %64, 6
  %66 = icmp ne i64 %65, 0
  br i1 %66, label %$20, label %$19
$20:
  br label %$18
$19:
  %67 = and i64 %64, 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$22, label %$21
$22:
  %69 = inttoptr i64 %64 to i64*
  %70 = load i64, i64* %69
  br label %$18
$21:
  %71 = call i64 @evList(i64 %64)
  br label %$18
$18:
  %72 = phi i64 [%64, %$20], [%70, %$22], [%71, %$21] ; # ->
; # (push (eval (car X)) NIL)
  %73 = alloca i64, i64 2, align 16
  %74 = ptrtoint i64* %73 to i64
  %75 = inttoptr i64 %74 to i64*
  store i64 %72, i64* %75
; # (link (push (eval (car X)) NIL))
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %77 = load i64, i64* %76
  %78 = inttoptr i64 %74 to i64*
  %79 = getelementptr i64, i64* %78, i32 1
  store i64 %77, i64* %79
  %80 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %74, i64* %80
; # (inc 'N)
  %81 = add i64 %42, 1
  br label %$10
$12:
  %82 = phi i64 [%36, %$10] ; # X
  %83 = phi i64 [%31, %$10] ; # L
  %84 = phi i64 [%32, %$10] ; # A
  %85 = phi i64 [%33, %$10] ; # N
; # (let (Y (++ L) Z A I N) (until (lt0 (dec 'I)) (let (V (++ Z) K (+...
; # (++ L)
  %86 = inttoptr i64 %83 to i64*
  %87 = load i64, i64* %86
  %88 = getelementptr i64, i64* %86, i32 1
  %89 = load i64, i64* %88
; # (until (lt0 (dec 'I)) (let (V (++ Z) K (++ Z)) (? (equal Y K) (se...
  br label %$23
$23:
  %90 = phi i64 [%82, %$12], [%122, %$26] ; # X
  %91 = phi i64 [%89, %$12], [%123, %$26] ; # L
  %92 = phi i64 [%84, %$12], [%124, %$26] ; # A
  %93 = phi i64 [%85, %$12], [%125, %$26] ; # N
  %94 = phi i64 [%87, %$12], [%126, %$26] ; # Y
  %95 = phi i64 [%84, %$12], [%127, %$26] ; # Z
  %96 = phi i64 [%85, %$12], [%128, %$26] ; # I
; # (dec 'I)
  %97 = sub i64 %96, 1
; # (lt0 (dec 'I))
  %98 = icmp slt i64 %97, 0
  br i1 %98, label %$25, label %$24
$24:
  %99 = phi i64 [%90, %$23] ; # X
  %100 = phi i64 [%91, %$23] ; # L
  %101 = phi i64 [%92, %$23] ; # A
  %102 = phi i64 [%93, %$23] ; # N
  %103 = phi i64 [%94, %$23] ; # Y
  %104 = phi i64 [%95, %$23] ; # Z
  %105 = phi i64 [%97, %$23] ; # I
; # (let (V (++ Z) K (++ Z)) (? (equal Y K) (setq Y V)))
; # (++ Z)
  %106 = inttoptr i64 %104 to i64*
  %107 = load i64, i64* %106
  %108 = getelementptr i64, i64* %106, i32 1
  %109 = load i64, i64* %108
; # (++ Z)
  %110 = inttoptr i64 %109 to i64*
  %111 = load i64, i64* %110
  %112 = getelementptr i64, i64* %110, i32 1
  %113 = load i64, i64* %112
; # (? (equal Y K) (setq Y V))
; # (equal Y K)
  %114 = call i1 @equal(i64 %103, i64 %111)
  br i1 %114, label %$27, label %$26
$27:
  %115 = phi i64 [%99, %$24] ; # X
  %116 = phi i64 [%100, %$24] ; # L
  %117 = phi i64 [%101, %$24] ; # A
  %118 = phi i64 [%102, %$24] ; # N
  %119 = phi i64 [%103, %$24] ; # Y
  %120 = phi i64 [%113, %$24] ; # Z
  %121 = phi i64 [%105, %$24] ; # I
  br label %$25
$26:
  %122 = phi i64 [%99, %$24] ; # X
  %123 = phi i64 [%100, %$24] ; # L
  %124 = phi i64 [%101, %$24] ; # A
  %125 = phi i64 [%102, %$24] ; # N
  %126 = phi i64 [%103, %$24] ; # Y
  %127 = phi i64 [%113, %$24] ; # Z
  %128 = phi i64 [%105, %$24] ; # I
  br label %$23
$25:
  %129 = phi i64 [%90, %$23], [%115, %$27] ; # X
  %130 = phi i64 [%91, %$23], [%116, %$27] ; # L
  %131 = phi i64 [%92, %$23], [%117, %$27] ; # A
  %132 = phi i64 [%93, %$23], [%118, %$27] ; # N
  %133 = phi i64 [%94, %$23], [%107, %$27] ; # Y
  %134 = phi i64 [%95, %$23], [%120, %$27] ; # Z
  %135 = phi i64 [%97, %$23], [%121, %$27] ; # I
; # (let P (set (link R) (cons Y $Nil)) (while (pair L) (setq Y (++ L...
; # (set (link R) (cons Y $Nil))
; # (link R)
  %136 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %137 = load i64, i64* %136
  %138 = inttoptr i64 %29 to i64*
  %139 = getelementptr i64, i64* %138, i32 1
  store i64 %137, i64* %139
  %140 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %140
; # (cons Y $Nil)
  %141 = call i64 @cons(i64 %133, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %142 = inttoptr i64 %29 to i64*
  store i64 %141, i64* %142
; # (while (pair L) (setq Y (++ L) Z A I N) (until (lt0 (dec 'I)) (le...
  br label %$28
$28:
  %143 = phi i64 [%129, %$25], [%208, %$33] ; # X
  %144 = phi i64 [%130, %$25], [%209, %$33] ; # L
  %145 = phi i64 [%131, %$25], [%210, %$33] ; # A
  %146 = phi i64 [%132, %$25], [%211, %$33] ; # N
  %147 = phi i64 [%133, %$25], [%212, %$33] ; # Y
  %148 = phi i64 [%134, %$25], [%213, %$33] ; # Z
  %149 = phi i64 [%135, %$25], [%214, %$33] ; # I
  %150 = phi i64 [%141, %$25], [%216, %$33] ; # P
; # (pair L)
  %151 = and i64 %144, 15
  %152 = icmp eq i64 %151, 0
  br i1 %152, label %$29, label %$30
$29:
  %153 = phi i64 [%143, %$28] ; # X
  %154 = phi i64 [%144, %$28] ; # L
  %155 = phi i64 [%145, %$28] ; # A
  %156 = phi i64 [%146, %$28] ; # N
  %157 = phi i64 [%147, %$28] ; # Y
  %158 = phi i64 [%148, %$28] ; # Z
  %159 = phi i64 [%149, %$28] ; # I
  %160 = phi i64 [%150, %$28] ; # P
; # (++ L)
  %161 = inttoptr i64 %154 to i64*
  %162 = load i64, i64* %161
  %163 = getelementptr i64, i64* %161, i32 1
  %164 = load i64, i64* %163
; # (until (lt0 (dec 'I)) (let (V (++ Z) K (++ Z)) (? (equal Y K) (se...
  br label %$31
$31:
  %165 = phi i64 [%153, %$29], [%200, %$34] ; # X
  %166 = phi i64 [%164, %$29], [%201, %$34] ; # L
  %167 = phi i64 [%155, %$29], [%202, %$34] ; # A
  %168 = phi i64 [%156, %$29], [%203, %$34] ; # N
  %169 = phi i64 [%162, %$29], [%204, %$34] ; # Y
  %170 = phi i64 [%155, %$29], [%205, %$34] ; # Z
  %171 = phi i64 [%156, %$29], [%206, %$34] ; # I
  %172 = phi i64 [%160, %$29], [%207, %$34] ; # P
; # (dec 'I)
  %173 = sub i64 %171, 1
; # (lt0 (dec 'I))
  %174 = icmp slt i64 %173, 0
  br i1 %174, label %$33, label %$32
$32:
  %175 = phi i64 [%165, %$31] ; # X
  %176 = phi i64 [%166, %$31] ; # L
  %177 = phi i64 [%167, %$31] ; # A
  %178 = phi i64 [%168, %$31] ; # N
  %179 = phi i64 [%169, %$31] ; # Y
  %180 = phi i64 [%170, %$31] ; # Z
  %181 = phi i64 [%173, %$31] ; # I
  %182 = phi i64 [%172, %$31] ; # P
; # (let (V (++ Z) K (++ Z)) (? (equal Y K) (setq Y V)))
; # (++ Z)
  %183 = inttoptr i64 %180 to i64*
  %184 = load i64, i64* %183
  %185 = getelementptr i64, i64* %183, i32 1
  %186 = load i64, i64* %185
; # (++ Z)
  %187 = inttoptr i64 %186 to i64*
  %188 = load i64, i64* %187
  %189 = getelementptr i64, i64* %187, i32 1
  %190 = load i64, i64* %189
; # (? (equal Y K) (setq Y V))
; # (equal Y K)
  %191 = call i1 @equal(i64 %179, i64 %188)
  br i1 %191, label %$35, label %$34
$35:
  %192 = phi i64 [%175, %$32] ; # X
  %193 = phi i64 [%176, %$32] ; # L
  %194 = phi i64 [%177, %$32] ; # A
  %195 = phi i64 [%178, %$32] ; # N
  %196 = phi i64 [%179, %$32] ; # Y
  %197 = phi i64 [%190, %$32] ; # Z
  %198 = phi i64 [%181, %$32] ; # I
  %199 = phi i64 [%182, %$32] ; # P
  br label %$33
$34:
  %200 = phi i64 [%175, %$32] ; # X
  %201 = phi i64 [%176, %$32] ; # L
  %202 = phi i64 [%177, %$32] ; # A
  %203 = phi i64 [%178, %$32] ; # N
  %204 = phi i64 [%179, %$32] ; # Y
  %205 = phi i64 [%190, %$32] ; # Z
  %206 = phi i64 [%181, %$32] ; # I
  %207 = phi i64 [%182, %$32] ; # P
  br label %$31
$33:
  %208 = phi i64 [%165, %$31], [%192, %$35] ; # X
  %209 = phi i64 [%166, %$31], [%193, %$35] ; # L
  %210 = phi i64 [%167, %$31], [%194, %$35] ; # A
  %211 = phi i64 [%168, %$31], [%195, %$35] ; # N
  %212 = phi i64 [%169, %$31], [%184, %$35] ; # Y
  %213 = phi i64 [%170, %$31], [%197, %$35] ; # Z
  %214 = phi i64 [%173, %$31], [%198, %$35] ; # I
  %215 = phi i64 [%172, %$31], [%199, %$35] ; # P
; # (set 2 P (cons Y $Nil))
; # (cons Y $Nil)
  %216 = call i64 @cons(i64 %212, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %217 = inttoptr i64 %215 to i64*
  %218 = getelementptr i64, i64* %217, i32 1
  store i64 %216, i64* %218
  br label %$28
$30:
  %219 = phi i64 [%143, %$28] ; # X
  %220 = phi i64 [%144, %$28] ; # L
  %221 = phi i64 [%145, %$28] ; # A
  %222 = phi i64 [%146, %$28] ; # N
  %223 = phi i64 [%147, %$28] ; # Y
  %224 = phi i64 [%148, %$28] ; # Z
  %225 = phi i64 [%149, %$28] ; # I
  %226 = phi i64 [%150, %$28] ; # P
; # (val R)
  %227 = inttoptr i64 %29 to i64*
  %228 = load i64, i64* %227
  br label %$9
$9:
  %229 = phi i64 [%24, %$7], [%219, %$30] ; # X
  %230 = phi i64 [%25, %$7], [%220, %$30] ; # L
  %231 = phi i64 [%13, %$7], [%228, %$30] ; # ->
; # (drop *Safe)
  %232 = inttoptr i64 %15 to i64*
  %233 = getelementptr i64, i64* %232, i32 1
  %234 = load i64, i64* %233
  %235 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %234, i64* %235
  ret i64 %231
}

define i64 @_insert(i64) {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) L (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %17, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (shift X)
  %26 = inttoptr i64 %7 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (car (shift X))
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (eval (car (shift X)))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  br label %$7
$8:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$11, label %$10
$11:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$7
$10:
  %37 = call i64 @evList(i64 %30)
  br label %$7
$7:
  %38 = phi i64 [%30, %$9], [%36, %$11], [%37, %$10] ; # ->
; # (if (or (atom L) (le0 (dec 'N))) (cons X L) (let (Y (cons (car L)...
; # (or (atom L) (le0 (dec 'N)))
; # (atom L)
  %39 = and i64 %17, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$12, label %$13
$13:
  %41 = phi i64 [%38, %$7] ; # X
  %42 = phi i64 [%4, %$7] ; # N
  %43 = phi i64 [%17, %$7] ; # L
; # (dec 'N)
  %44 = sub i64 %42, 1
; # (le0 (dec 'N))
  %45 = icmp sle i64 %44, 0
  br label %$12
$12:
  %46 = phi i64 [%38, %$7], [%41, %$13] ; # X
  %47 = phi i64 [%4, %$7], [%44, %$13] ; # N
  %48 = phi i64 [%17, %$7], [%43, %$13] ; # L
  %49 = phi i1 [1, %$7], [%45, %$13] ; # ->
  br i1 %49, label %$14, label %$15
$14:
  %50 = phi i64 [%46, %$12] ; # X
  %51 = phi i64 [%47, %$12] ; # N
  %52 = phi i64 [%48, %$12] ; # L
; # (cons X L)
  %53 = call i64 @cons(i64 %50, i64 %52)
  br label %$16
$15:
  %54 = phi i64 [%46, %$12] ; # X
  %55 = phi i64 [%47, %$12] ; # N
  %56 = phi i64 [%48, %$12] ; # L
; # (let (Y (cons (car L) $Nil) R (save Y)) (while (and (pair (shift ...
; # (car L)
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
; # (cons (car L) $Nil)
  %59 = call i64 @cons(i64 %58, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %60 = alloca i64, i64 2, align 16
  %61 = ptrtoint i64* %60 to i64
  %62 = inttoptr i64 %61 to i64*
  store i64 %59, i64* %62
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %64 = load i64, i64* %63
  %65 = inttoptr i64 %61 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  store i64 %64, i64* %66
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %61, i64* %67
; # (while (and (pair (shift L)) (dec 'N)) (setq Y (set 2 Y (cons (ca...
  br label %$17
$17:
  %68 = phi i64 [%54, %$15], [%88, %$20] ; # X
  %69 = phi i64 [%55, %$15], [%89, %$20] ; # N
  %70 = phi i64 [%56, %$15], [%90, %$20] ; # L
  %71 = phi i64 [%59, %$15], [%94, %$20] ; # Y
; # (and (pair (shift L)) (dec 'N))
; # (shift L)
  %72 = inttoptr i64 %70 to i64*
  %73 = getelementptr i64, i64* %72, i32 1
  %74 = load i64, i64* %73
; # (pair (shift L))
  %75 = and i64 %74, 15
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %$19, label %$18
$19:
  %77 = phi i64 [%68, %$17] ; # X
  %78 = phi i64 [%69, %$17] ; # N
  %79 = phi i64 [%74, %$17] ; # L
  %80 = phi i64 [%71, %$17] ; # Y
; # (dec 'N)
  %81 = sub i64 %78, 1
  %82 = icmp ne i64 %81, 0
  br label %$18
$18:
  %83 = phi i64 [%68, %$17], [%77, %$19] ; # X
  %84 = phi i64 [%69, %$17], [%81, %$19] ; # N
  %85 = phi i64 [%74, %$17], [%79, %$19] ; # L
  %86 = phi i64 [%71, %$17], [%80, %$19] ; # Y
  %87 = phi i1 [0, %$17], [%82, %$19] ; # ->
  br i1 %87, label %$20, label %$21
$20:
  %88 = phi i64 [%83, %$18] ; # X
  %89 = phi i64 [%84, %$18] ; # N
  %90 = phi i64 [%85, %$18] ; # L
  %91 = phi i64 [%86, %$18] ; # Y
; # (set 2 Y (cons (car L) $Nil))
; # (car L)
  %92 = inttoptr i64 %90 to i64*
  %93 = load i64, i64* %92
; # (cons (car L) $Nil)
  %94 = call i64 @cons(i64 %93, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %95 = inttoptr i64 %91 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %94, i64* %96
  br label %$17
$21:
  %97 = phi i64 [%83, %$18] ; # X
  %98 = phi i64 [%84, %$18] ; # N
  %99 = phi i64 [%85, %$18] ; # L
  %100 = phi i64 [%86, %$18] ; # Y
; # (set 2 Y (cons X L))
; # (cons X L)
  %101 = call i64 @cons(i64 %97, i64 %99)
  %102 = inttoptr i64 %100 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  store i64 %101, i64* %103
  br label %$16
$16:
  %104 = phi i64 [%50, %$14], [%97, %$21] ; # X
  %105 = phi i64 [%51, %$14], [%98, %$21] ; # N
  %106 = phi i64 [%52, %$14], [%99, %$21] ; # L
  %107 = phi i64 [%53, %$14], [%59, %$21] ; # ->
; # (drop *Safe)
  %108 = inttoptr i64 %19 to i64*
  %109 = getelementptr i64, i64* %108, i32 1
  %110 = load i64, i64* %109
  %111 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %110, i64* %111
  ret i64 %107
}

define i64 @_remove(i64) {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) L (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %17, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (cond ((or (atom L) (lt0 (dec 'N))) L) ((=0 N) (cdr L)) (T (let (...
; # (or (atom L) (lt0 (dec 'N)))
; # (atom L)
  %26 = and i64 %17, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$8, label %$9
$9:
  %28 = phi i64 [%4, %$2] ; # N
  %29 = phi i64 [%17, %$2] ; # L
; # (dec 'N)
  %30 = sub i64 %28, 1
; # (lt0 (dec 'N))
  %31 = icmp slt i64 %30, 0
  br label %$8
$8:
  %32 = phi i64 [%4, %$2], [%30, %$9] ; # N
  %33 = phi i64 [%17, %$2], [%29, %$9] ; # L
  %34 = phi i1 [1, %$2], [%31, %$9] ; # ->
  br i1 %34, label %$11, label %$10
$11:
  %35 = phi i64 [%32, %$8] ; # N
  %36 = phi i64 [%33, %$8] ; # L
  br label %$7
$10:
  %37 = phi i64 [%32, %$8] ; # N
  %38 = phi i64 [%33, %$8] ; # L
; # (=0 N)
  %39 = icmp eq i64 %37, 0
  br i1 %39, label %$13, label %$12
$13:
  %40 = phi i64 [%37, %$10] ; # N
  %41 = phi i64 [%38, %$10] ; # L
; # (cdr L)
  %42 = inttoptr i64 %41 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
  br label %$7
$12:
  %45 = phi i64 [%37, %$10] ; # N
  %46 = phi i64 [%38, %$10] ; # L
; # (let (Y (cons (car L) $Nil) R (save Y)) (loop (? (atom (shift L))...
; # (car L)
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
; # (cons (car L) $Nil)
  %49 = call i64 @cons(i64 %48, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %50 = alloca i64, i64 2, align 16
  %51 = ptrtoint i64* %50 to i64
  %52 = inttoptr i64 %51 to i64*
  store i64 %49, i64* %52
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %54 = load i64, i64* %53
  %55 = inttoptr i64 %51 to i64*
  %56 = getelementptr i64, i64* %55, i32 1
  store i64 %54, i64* %56
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %51, i64* %57
; # (loop (? (atom (shift L)) (set 2 Y L)) (? (=0 (dec 'N)) (set 2 Y ...
  br label %$14
$14:
  %58 = phi i64 [%45, %$12], [%84, %$18] ; # N
  %59 = phi i64 [%46, %$12], [%85, %$18] ; # L
  %60 = phi i64 [%49, %$12], [%89, %$18] ; # Y
; # (? (atom (shift L)) (set 2 Y L))
; # (shift L)
  %61 = inttoptr i64 %59 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
; # (atom (shift L))
  %64 = and i64 %63, 15
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$17, label %$15
$17:
  %66 = phi i64 [%58, %$14] ; # N
  %67 = phi i64 [%63, %$14] ; # L
  %68 = phi i64 [%60, %$14] ; # Y
; # (set 2 Y L)
  %69 = inttoptr i64 %68 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  store i64 %67, i64* %70
  br label %$16
$15:
  %71 = phi i64 [%58, %$14] ; # N
  %72 = phi i64 [%63, %$14] ; # L
  %73 = phi i64 [%60, %$14] ; # Y
; # (? (=0 (dec 'N)) (set 2 Y (cdr L)))
; # (dec 'N)
  %74 = sub i64 %71, 1
; # (=0 (dec 'N))
  %75 = icmp eq i64 %74, 0
  br i1 %75, label %$19, label %$18
$19:
  %76 = phi i64 [%74, %$15] ; # N
  %77 = phi i64 [%72, %$15] ; # L
  %78 = phi i64 [%73, %$15] ; # Y
; # (set 2 Y (cdr L))
; # (cdr L)
  %79 = inttoptr i64 %77 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %78 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  store i64 %81, i64* %83
  br label %$16
$18:
  %84 = phi i64 [%74, %$15] ; # N
  %85 = phi i64 [%72, %$15] ; # L
  %86 = phi i64 [%73, %$15] ; # Y
; # (set 2 Y (cons (car L) $Nil))
; # (car L)
  %87 = inttoptr i64 %85 to i64*
  %88 = load i64, i64* %87
; # (cons (car L) $Nil)
  %89 = call i64 @cons(i64 %88, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %90 = inttoptr i64 %86 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %89, i64* %91
  br label %$14
$16:
  %92 = phi i64 [%66, %$17], [%76, %$19] ; # N
  %93 = phi i64 [%67, %$17], [%77, %$19] ; # L
  %94 = phi i64 [%68, %$17], [%78, %$19] ; # Y
  %95 = phi i64 [%67, %$17], [%81, %$19] ; # ->
  br label %$7
$7:
  %96 = phi i64 [%35, %$11], [%40, %$13], [%92, %$16] ; # N
  %97 = phi i64 [%36, %$11], [%41, %$13], [%93, %$16] ; # L
  %98 = phi i64 [%36, %$11], [%44, %$13], [%49, %$16] ; # ->
; # (drop *Safe)
  %99 = inttoptr i64 %19 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  %101 = load i64, i64* %100
  %102 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %101, i64* %102
  ret i64 %98
}

define i64 @_place(i64) {
$1:
; # (let (X (cdr Exe) N (evCnt Exe X) L (save (eval (car (shift X))))...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe X)
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (shift X)
  %5 = inttoptr i64 %3 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car (shift X))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (eval (car (shift X)))
  %10 = and i64 %9, 6
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$4, label %$3
$4:
  br label %$2
$3:
  %12 = and i64 %9, 8
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = inttoptr i64 %9 to i64*
  %15 = load i64, i64* %14
  br label %$2
$5:
  %16 = call i64 @evList(i64 %9)
  br label %$2
$2:
  %17 = phi i64 [%9, %$4], [%15, %$6], [%16, %$5] ; # ->
; # (save (eval (car (shift X))))
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %17, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (shift X)
  %26 = inttoptr i64 %7 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
; # (car (shift X))
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (eval (car (shift X)))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$9, label %$8
$9:
  br label %$7
$8:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$11, label %$10
$11:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$7
$10:
  %37 = call i64 @evList(i64 %30)
  br label %$7
$7:
  %38 = phi i64 [%30, %$9], [%36, %$11], [%37, %$10] ; # ->
; # (cond ((atom L) (eval (car X))) ((le0 (dec 'N)) (cons X (cdr L)))...
; # (atom L)
  %39 = and i64 %17, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$14, label %$13
$14:
  %41 = phi i64 [%38, %$7] ; # X
  %42 = phi i64 [%4, %$7] ; # N
  %43 = phi i64 [%17, %$7] ; # L
; # (car X)
  %44 = inttoptr i64 %41 to i64*
  %45 = load i64, i64* %44
; # (eval (car X))
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$17, label %$16
$17:
  br label %$15
$16:
  %48 = and i64 %45, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$19, label %$18
$19:
  %50 = inttoptr i64 %45 to i64*
  %51 = load i64, i64* %50
  br label %$15
$18:
  %52 = call i64 @evList(i64 %45)
  br label %$15
$15:
  %53 = phi i64 [%45, %$17], [%51, %$19], [%52, %$18] ; # ->
  br label %$12
$13:
  %54 = phi i64 [%38, %$7] ; # X
  %55 = phi i64 [%4, %$7] ; # N
  %56 = phi i64 [%17, %$7] ; # L
; # (dec 'N)
  %57 = sub i64 %55, 1
; # (le0 (dec 'N))
  %58 = icmp sle i64 %57, 0
  br i1 %58, label %$21, label %$20
$21:
  %59 = phi i64 [%54, %$13] ; # X
  %60 = phi i64 [%57, %$13] ; # N
  %61 = phi i64 [%56, %$13] ; # L
; # (cdr L)
  %62 = inttoptr i64 %61 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  %64 = load i64, i64* %63
; # (cons X (cdr L))
  %65 = call i64 @cons(i64 %59, i64 %64)
  br label %$12
$20:
  %66 = phi i64 [%54, %$13] ; # X
  %67 = phi i64 [%57, %$13] ; # N
  %68 = phi i64 [%56, %$13] ; # L
; # (let (Y (cons (car L) $Nil) R (save Y)) (loop (? (atom (shift L))...
; # (car L)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (cons (car L) $Nil)
  %71 = call i64 @cons(i64 %70, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %72 = alloca i64, i64 2, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = inttoptr i64 %73 to i64*
  store i64 %71, i64* %74
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %73 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %79
; # (loop (? (atom (shift L)) (set 2 Y (cons X L))) (? (=0 (dec 'N)) ...
  br label %$22
$22:
  %80 = phi i64 [%66, %$20], [%112, %$26] ; # X
  %81 = phi i64 [%67, %$20], [%113, %$26] ; # N
  %82 = phi i64 [%68, %$20], [%114, %$26] ; # L
  %83 = phi i64 [%71, %$20], [%118, %$26] ; # Y
; # (? (atom (shift L)) (set 2 Y (cons X L)))
; # (shift L)
  %84 = inttoptr i64 %82 to i64*
  %85 = getelementptr i64, i64* %84, i32 1
  %86 = load i64, i64* %85
; # (atom (shift L))
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$25, label %$23
$25:
  %89 = phi i64 [%80, %$22] ; # X
  %90 = phi i64 [%81, %$22] ; # N
  %91 = phi i64 [%86, %$22] ; # L
  %92 = phi i64 [%83, %$22] ; # Y
; # (set 2 Y (cons X L))
; # (cons X L)
  %93 = call i64 @cons(i64 %89, i64 %91)
  %94 = inttoptr i64 %92 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  store i64 %93, i64* %95
  br label %$24
$23:
  %96 = phi i64 [%80, %$22] ; # X
  %97 = phi i64 [%81, %$22] ; # N
  %98 = phi i64 [%86, %$22] ; # L
  %99 = phi i64 [%83, %$22] ; # Y
; # (? (=0 (dec 'N)) (set 2 Y (cons X (cdr L))))
; # (dec 'N)
  %100 = sub i64 %97, 1
; # (=0 (dec 'N))
  %101 = icmp eq i64 %100, 0
  br i1 %101, label %$27, label %$26
$27:
  %102 = phi i64 [%96, %$23] ; # X
  %103 = phi i64 [%100, %$23] ; # N
  %104 = phi i64 [%98, %$23] ; # L
  %105 = phi i64 [%99, %$23] ; # Y
; # (set 2 Y (cons X (cdr L)))
; # (cdr L)
  %106 = inttoptr i64 %104 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  %108 = load i64, i64* %107
; # (cons X (cdr L))
  %109 = call i64 @cons(i64 %102, i64 %108)
  %110 = inttoptr i64 %105 to i64*
  %111 = getelementptr i64, i64* %110, i32 1
  store i64 %109, i64* %111
  br label %$24
$26:
  %112 = phi i64 [%96, %$23] ; # X
  %113 = phi i64 [%100, %$23] ; # N
  %114 = phi i64 [%98, %$23] ; # L
  %115 = phi i64 [%99, %$23] ; # Y
; # (set 2 Y (cons (car L) $Nil))
; # (car L)
  %116 = inttoptr i64 %114 to i64*
  %117 = load i64, i64* %116
; # (cons (car L) $Nil)
  %118 = call i64 @cons(i64 %117, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %119 = inttoptr i64 %115 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  store i64 %118, i64* %120
  br label %$22
$24:
  %121 = phi i64 [%89, %$25], [%102, %$27] ; # X
  %122 = phi i64 [%90, %$25], [%103, %$27] ; # N
  %123 = phi i64 [%91, %$25], [%104, %$27] ; # L
  %124 = phi i64 [%92, %$25], [%105, %$27] ; # Y
  %125 = phi i64 [%93, %$25], [%109, %$27] ; # ->
  br label %$12
$12:
  %126 = phi i64 [%41, %$15], [%59, %$21], [%121, %$24] ; # X
  %127 = phi i64 [%42, %$15], [%60, %$21], [%122, %$24] ; # N
  %128 = phi i64 [%43, %$15], [%61, %$21], [%123, %$24] ; # L
  %129 = phi i64 [%53, %$15], [%65, %$21], [%71, %$24] ; # ->
; # (drop *Safe)
  %130 = inttoptr i64 %19 to i64*
  %131 = getelementptr i64, i64* %130, i32 1
  %132 = load i64, i64* %131
  %133 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %132, i64* %133
  ret i64 %129
}

define i64 @_strip(i64) {
$1:
; # (let X (eval (cadr Exe)) (while (and (pair X) (== $Quote (car X))...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (while (and (pair X) (== $Quote (car X))) (? (== (cdr X) X)) (set...
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%26, %$12] ; # X
; # (and (pair X) (== $Quote (car X)))
; # (pair X)
  %15 = and i64 %14, 15
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i64 [%14, %$7] ; # X
; # (car X)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (== $Quote (car X))
  %20 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 168) to i64), %19
  br label %$8
$8:
  %21 = phi i64 [%14, %$7], [%17, %$9] ; # X
  %22 = phi i1 [0, %$7], [%20, %$9] ; # ->
  br i1 %22, label %$10, label %$11
$10:
  %23 = phi i64 [%21, %$8] ; # X
; # (? (== (cdr X) X))
; # (cdr X)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (== (cdr X) X)
  %27 = icmp eq i64 %26, %23
  br i1 %27, label %$11, label %$12
$12:
  %28 = phi i64 [%23, %$10] ; # X
  br label %$7
$11:
  %29 = phi i64 [%21, %$8], [%23, %$10] ; # X
  ret i64 %29
}

define i64 @_split(i64) {
$1:
; # (let (X (cdr Exe) L (save (eval (car X)))) (if (atom L) @ (let (A...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (if (atom L) @ (let (A $Nil N 0) (while (pair (shift X)) (setq A ...
; # (atom L)
  %22 = and i64 %13, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$7, label %$8
$7:
  %24 = phi i64 [%3, %$2] ; # X
  %25 = phi i64 [%13, %$2] ; # L
  br label %$9
$8:
  %26 = phi i64 [%3, %$2] ; # X
  %27 = phi i64 [%13, %$2] ; # L
; # (let (A $Nil N 0) (while (pair (shift X)) (setq A (link (push (ev...
; # (while (pair (shift X)) (setq A (link (push (eval (car X)) NIL)))...
  br label %$10
$10:
  %28 = phi i64 [%26, %$8], [%37, %$13] ; # X
  %29 = phi i64 [%27, %$8], [%38, %$13] ; # L
  %30 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8], [%52, %$13] ; # A
  %31 = phi i64 [0, %$8], [%59, %$13] ; # N
; # (shift X)
  %32 = inttoptr i64 %28 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  %34 = load i64, i64* %33
; # (pair (shift X))
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$11, label %$12
$11:
  %37 = phi i64 [%34, %$10] ; # X
  %38 = phi i64 [%29, %$10] ; # L
  %39 = phi i64 [%30, %$10] ; # A
  %40 = phi i64 [%31, %$10] ; # N
; # (car X)
  %41 = inttoptr i64 %37 to i64*
  %42 = load i64, i64* %41
; # (eval (car X))
  %43 = and i64 %42, 6
  %44 = icmp ne i64 %43, 0
  br i1 %44, label %$15, label %$14
$15:
  br label %$13
$14:
  %45 = and i64 %42, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$17, label %$16
$17:
  %47 = inttoptr i64 %42 to i64*
  %48 = load i64, i64* %47
  br label %$13
$16:
  %49 = call i64 @evList(i64 %42)
  br label %$13
$13:
  %50 = phi i64 [%42, %$15], [%48, %$17], [%49, %$16] ; # ->
; # (push (eval (car X)) NIL)
  %51 = alloca i64, i64 2, align 16
  %52 = ptrtoint i64* %51 to i64
  %53 = inttoptr i64 %52 to i64*
  store i64 %50, i64* %53
; # (link (push (eval (car X)) NIL))
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = inttoptr i64 %52 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  store i64 %55, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %58
; # (inc 'N)
  %59 = add i64 %40, 1
  br label %$10
$12:
  %60 = phi i64 [%34, %$10] ; # X
  %61 = phi i64 [%29, %$10] ; # L
  %62 = phi i64 [%30, %$10] ; # A
  %63 = phi i64 [%31, %$10] ; # N
; # (let (P $Nil R (link (push P NIL)) Q $Nil S (link (push Q NIL))) ...
; # (push P NIL)
  %64 = alloca i64, i64 2, align 16
  %65 = ptrtoint i64* %64 to i64
  %66 = inttoptr i64 %65 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %66
; # (link (push P NIL))
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %68 = load i64, i64* %67
  %69 = inttoptr i64 %65 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  store i64 %68, i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %71
; # (push Q NIL)
  %72 = alloca i64, i64 2, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = inttoptr i64 %73 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %74
; # (link (push Q NIL))
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %73 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %79
; # (loop (let (Y (++ L) Z A I N) (loop (? (lt0 (dec 'I)) (let C (con...
  br label %$18
$18:
  %80 = phi i64 [%60, %$12], [%211, %$31] ; # X
  %81 = phi i64 [%61, %$12], [%212, %$31] ; # L
  %82 = phi i64 [%62, %$12], [%213, %$31] ; # A
  %83 = phi i64 [%63, %$12], [%214, %$31] ; # N
  %84 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%215, %$31] ; # P
  %85 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12], [%216, %$31] ; # Q
; # (let (Y (++ L) Z A I N) (loop (? (lt0 (dec 'I)) (let C (cons Y $N...
; # (++ L)
  %86 = inttoptr i64 %81 to i64*
  %87 = load i64, i64* %86
  %88 = getelementptr i64, i64* %86, i32 1
  %89 = load i64, i64* %88
; # (loop (? (lt0 (dec 'I)) (let C (cons Y $Nil) (setq Q (if (nil? Q)...
  br label %$19
$19:
  %90 = phi i64 [%80, %$18], [%192, %$26] ; # X
  %91 = phi i64 [%89, %$18], [%193, %$26] ; # L
  %92 = phi i64 [%82, %$18], [%194, %$26] ; # A
  %93 = phi i64 [%83, %$18], [%195, %$26] ; # N
  %94 = phi i64 [%84, %$18], [%196, %$26] ; # P
  %95 = phi i64 [%85, %$18], [%197, %$26] ; # Q
  %96 = phi i64 [%82, %$18], [%198, %$26] ; # Z
  %97 = phi i64 [%83, %$18], [%199, %$26] ; # I
; # (? (lt0 (dec 'I)) (let C (cons Y $Nil) (setq Q (if (nil? Q) (set ...
; # (dec 'I)
  %98 = sub i64 %97, 1
; # (lt0 (dec 'I))
  %99 = icmp slt i64 %98, 0
  br i1 %99, label %$22, label %$20
$22:
  %100 = phi i64 [%90, %$19] ; # X
  %101 = phi i64 [%91, %$19] ; # L
  %102 = phi i64 [%92, %$19] ; # A
  %103 = phi i64 [%93, %$19] ; # N
  %104 = phi i64 [%94, %$19] ; # P
  %105 = phi i64 [%95, %$19] ; # Q
  %106 = phi i64 [%96, %$19] ; # Z
  %107 = phi i64 [%98, %$19] ; # I
; # (let C (cons Y $Nil) (setq Q (if (nil? Q) (set S C) (set 2 Q C)))...
; # (cons Y $Nil)
  %108 = call i64 @cons(i64 %87, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if (nil? Q) (set S C) (set 2 Q C))
; # (nil? Q)
  %109 = icmp eq i64 %105, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %109, label %$23, label %$24
$23:
  %110 = phi i64 [%100, %$22] ; # X
  %111 = phi i64 [%101, %$22] ; # L
  %112 = phi i64 [%102, %$22] ; # A
  %113 = phi i64 [%103, %$22] ; # N
  %114 = phi i64 [%104, %$22] ; # P
  %115 = phi i64 [%105, %$22] ; # Q
  %116 = phi i64 [%106, %$22] ; # Z
  %117 = phi i64 [%107, %$22] ; # I
; # (set S C)
  %118 = inttoptr i64 %73 to i64*
  store i64 %108, i64* %118
  br label %$25
$24:
  %119 = phi i64 [%100, %$22] ; # X
  %120 = phi i64 [%101, %$22] ; # L
  %121 = phi i64 [%102, %$22] ; # A
  %122 = phi i64 [%103, %$22] ; # N
  %123 = phi i64 [%104, %$22] ; # P
  %124 = phi i64 [%105, %$22] ; # Q
  %125 = phi i64 [%106, %$22] ; # Z
  %126 = phi i64 [%107, %$22] ; # I
; # (set 2 Q C)
  %127 = inttoptr i64 %124 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  store i64 %108, i64* %128
  br label %$25
$25:
  %129 = phi i64 [%110, %$23], [%119, %$24] ; # X
  %130 = phi i64 [%111, %$23], [%120, %$24] ; # L
  %131 = phi i64 [%112, %$23], [%121, %$24] ; # A
  %132 = phi i64 [%113, %$23], [%122, %$24] ; # N
  %133 = phi i64 [%114, %$23], [%123, %$24] ; # P
  %134 = phi i64 [%115, %$23], [%124, %$24] ; # Q
  %135 = phi i64 [%116, %$23], [%125, %$24] ; # Z
  %136 = phi i64 [%117, %$23], [%126, %$24] ; # I
  %137 = phi i64 [%108, %$23], [%108, %$24] ; # ->
  br label %$21
$20:
  %138 = phi i64 [%90, %$19] ; # X
  %139 = phi i64 [%91, %$19] ; # L
  %140 = phi i64 [%92, %$19] ; # A
  %141 = phi i64 [%93, %$19] ; # N
  %142 = phi i64 [%94, %$19] ; # P
  %143 = phi i64 [%95, %$19] ; # Q
  %144 = phi i64 [%96, %$19] ; # Z
  %145 = phi i64 [%98, %$19] ; # I
; # (? (equal Y (++ Z)) (let C (cons (val S) $Nil) (setq P (if (nil? ...
; # (++ Z)
  %146 = inttoptr i64 %144 to i64*
  %147 = load i64, i64* %146
  %148 = getelementptr i64, i64* %146, i32 1
  %149 = load i64, i64* %148
; # (equal Y (++ Z))
  %150 = call i1 @equal(i64 %87, i64 %147)
  br i1 %150, label %$27, label %$26
$27:
  %151 = phi i64 [%138, %$20] ; # X
  %152 = phi i64 [%139, %$20] ; # L
  %153 = phi i64 [%140, %$20] ; # A
  %154 = phi i64 [%141, %$20] ; # N
  %155 = phi i64 [%142, %$20] ; # P
  %156 = phi i64 [%143, %$20] ; # Q
  %157 = phi i64 [%149, %$20] ; # Z
  %158 = phi i64 [%145, %$20] ; # I
; # (let C (cons (val S) $Nil) (setq P (if (nil? P) (set R C) (set 2 ...
; # (val S)
  %159 = inttoptr i64 %73 to i64*
  %160 = load i64, i64* %159
; # (cons (val S) $Nil)
  %161 = call i64 @cons(i64 %160, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if (nil? P) (set R C) (set 2 P C))
; # (nil? P)
  %162 = icmp eq i64 %155, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %162, label %$28, label %$29
$28:
  %163 = phi i64 [%151, %$27] ; # X
  %164 = phi i64 [%152, %$27] ; # L
  %165 = phi i64 [%153, %$27] ; # A
  %166 = phi i64 [%154, %$27] ; # N
  %167 = phi i64 [%155, %$27] ; # P
  %168 = phi i64 [%156, %$27] ; # Q
  %169 = phi i64 [%157, %$27] ; # Z
  %170 = phi i64 [%158, %$27] ; # I
; # (set R C)
  %171 = inttoptr i64 %65 to i64*
  store i64 %161, i64* %171
  br label %$30
$29:
  %172 = phi i64 [%151, %$27] ; # X
  %173 = phi i64 [%152, %$27] ; # L
  %174 = phi i64 [%153, %$27] ; # A
  %175 = phi i64 [%154, %$27] ; # N
  %176 = phi i64 [%155, %$27] ; # P
  %177 = phi i64 [%156, %$27] ; # Q
  %178 = phi i64 [%157, %$27] ; # Z
  %179 = phi i64 [%158, %$27] ; # I
; # (set 2 P C)
  %180 = inttoptr i64 %176 to i64*
  %181 = getelementptr i64, i64* %180, i32 1
  store i64 %161, i64* %181
  br label %$30
$30:
  %182 = phi i64 [%163, %$28], [%172, %$29] ; # X
  %183 = phi i64 [%164, %$28], [%173, %$29] ; # L
  %184 = phi i64 [%165, %$28], [%174, %$29] ; # A
  %185 = phi i64 [%166, %$28], [%175, %$29] ; # N
  %186 = phi i64 [%167, %$28], [%176, %$29] ; # P
  %187 = phi i64 [%168, %$28], [%177, %$29] ; # Q
  %188 = phi i64 [%169, %$28], [%178, %$29] ; # Z
  %189 = phi i64 [%170, %$28], [%179, %$29] ; # I
  %190 = phi i64 [%161, %$28], [%161, %$29] ; # ->
; # (set S $Nil)
  %191 = inttoptr i64 %73 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %191
  br label %$21
$26:
  %192 = phi i64 [%138, %$20] ; # X
  %193 = phi i64 [%139, %$20] ; # L
  %194 = phi i64 [%140, %$20] ; # A
  %195 = phi i64 [%141, %$20] ; # N
  %196 = phi i64 [%142, %$20] ; # P
  %197 = phi i64 [%143, %$20] ; # Q
  %198 = phi i64 [%149, %$20] ; # Z
  %199 = phi i64 [%145, %$20] ; # I
  br label %$19
$21:
  %200 = phi i64 [%129, %$25], [%182, %$30] ; # X
  %201 = phi i64 [%130, %$25], [%183, %$30] ; # L
  %202 = phi i64 [%131, %$25], [%184, %$30] ; # A
  %203 = phi i64 [%132, %$25], [%185, %$30] ; # N
  %204 = phi i64 [%133, %$25], [%190, %$30] ; # P
  %205 = phi i64 [%137, %$25], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$30] ; # Q
  %206 = phi i64 [%135, %$25], [%188, %$30] ; # Z
  %207 = phi i64 [%136, %$25], [%189, %$30] ; # I
  %208 = phi i64 [%137, %$25], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$30] ; # ->
; # (? (atom L))
; # (atom L)
  %209 = and i64 %201, 15
  %210 = icmp ne i64 %209, 0
  br i1 %210, label %$32, label %$31
$31:
  %211 = phi i64 [%200, %$21] ; # X
  %212 = phi i64 [%201, %$21] ; # L
  %213 = phi i64 [%202, %$21] ; # A
  %214 = phi i64 [%203, %$21] ; # N
  %215 = phi i64 [%204, %$21] ; # P
  %216 = phi i64 [%205, %$21] ; # Q
  br label %$18
$32:
  %217 = phi i64 [%200, %$21] ; # X
  %218 = phi i64 [%201, %$21] ; # L
  %219 = phi i64 [%202, %$21] ; # A
  %220 = phi i64 [%203, %$21] ; # N
  %221 = phi i64 [%204, %$21] ; # P
  %222 = phi i64 [%205, %$21] ; # Q
  %223 = phi i64 [0, %$21] ; # ->
; # (let C (cons (val S) $Nil) (if (nil? P) C (set 2 P C) (val R)))
; # (val S)
  %224 = inttoptr i64 %73 to i64*
  %225 = load i64, i64* %224
; # (cons (val S) $Nil)
  %226 = call i64 @cons(i64 %225, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if (nil? P) C (set 2 P C) (val R))
; # (nil? P)
  %227 = icmp eq i64 %221, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %227, label %$33, label %$34
$33:
  %228 = phi i64 [%217, %$32] ; # X
  %229 = phi i64 [%218, %$32] ; # L
  %230 = phi i64 [%219, %$32] ; # A
  %231 = phi i64 [%220, %$32] ; # N
  %232 = phi i64 [%221, %$32] ; # P
  %233 = phi i64 [%222, %$32] ; # Q
  br label %$35
$34:
  %234 = phi i64 [%217, %$32] ; # X
  %235 = phi i64 [%218, %$32] ; # L
  %236 = phi i64 [%219, %$32] ; # A
  %237 = phi i64 [%220, %$32] ; # N
  %238 = phi i64 [%221, %$32] ; # P
  %239 = phi i64 [%222, %$32] ; # Q
; # (set 2 P C)
  %240 = inttoptr i64 %238 to i64*
  %241 = getelementptr i64, i64* %240, i32 1
  store i64 %226, i64* %241
; # (val R)
  %242 = inttoptr i64 %65 to i64*
  %243 = load i64, i64* %242
  br label %$35
$35:
  %244 = phi i64 [%228, %$33], [%234, %$34] ; # X
  %245 = phi i64 [%229, %$33], [%235, %$34] ; # L
  %246 = phi i64 [%230, %$33], [%236, %$34] ; # A
  %247 = phi i64 [%231, %$33], [%237, %$34] ; # N
  %248 = phi i64 [%232, %$33], [%238, %$34] ; # P
  %249 = phi i64 [%233, %$33], [%239, %$34] ; # Q
  %250 = phi i64 [%226, %$33], [%243, %$34] ; # ->
  br label %$9
$9:
  %251 = phi i64 [%24, %$7], [%244, %$35] ; # X
  %252 = phi i64 [%25, %$7], [%245, %$35] ; # L
  %253 = phi i64 [%13, %$7], [%250, %$35] ; # ->
; # (drop *Safe)
  %254 = inttoptr i64 %15 to i64*
  %255 = getelementptr i64, i64* %254, i32 1
  %256 = load i64, i64* %255
  %257 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %256, i64* %257
  ret i64 %253
}

define i64 @_reverse(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X))) Z $Nil) (while (pair Y)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (while (pair Y) (setq Z (cons (++ Y) Z)))
  br label %$7
$7:
  %22 = phi i64 [%13, %$2], [%31, %$8] ; # Y
  %23 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%32, %$8] ; # Z
; # (pair Y)
  %24 = and i64 %22, 15
  %25 = icmp eq i64 %24, 0
  br i1 %25, label %$8, label %$9
$8:
  %26 = phi i64 [%22, %$7] ; # Y
  %27 = phi i64 [%23, %$7] ; # Z
; # (++ Y)
  %28 = inttoptr i64 %26 to i64*
  %29 = load i64, i64* %28
  %30 = getelementptr i64, i64* %28, i32 1
  %31 = load i64, i64* %30
; # (cons (++ Y) Z)
  %32 = call i64 @cons(i64 %29, i64 %27)
  br label %$7
$9:
  %33 = phi i64 [%22, %$7] ; # Y
  %34 = phi i64 [%23, %$7] ; # Z
; # (drop *Safe)
  %35 = inttoptr i64 %15 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %38
  ret i64 %34
}

define i64 @_flip(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (if (atom Y) Y (let Z (cdr Y)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (atom Y) Y (let Z (cdr Y) (cond ((atom Z) Y) ((atom (shift X)...
; # (atom Y)
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%3, %$2] ; # X
  %17 = phi i64 [%13, %$2] ; # Y
  br label %$9
$8:
  %18 = phi i64 [%3, %$2] ; # X
  %19 = phi i64 [%13, %$2] ; # Y
; # (let Z (cdr Y) (cond ((atom Z) Y) ((atom (shift X)) (set 2 Y $Nil...
; # (cdr Y)
  %20 = inttoptr i64 %19 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  %22 = load i64, i64* %21
; # (cond ((atom Z) Y) ((atom (shift X)) (set 2 Y $Nil) (loop (setq X...
; # (atom Z)
  %23 = and i64 %22, 15
  %24 = icmp ne i64 %23, 0
  br i1 %24, label %$12, label %$11
$12:
  %25 = phi i64 [%18, %$8] ; # X
  %26 = phi i64 [%19, %$8] ; # Y
  %27 = phi i64 [%22, %$8] ; # Z
  br label %$10
$11:
  %28 = phi i64 [%18, %$8] ; # X
  %29 = phi i64 [%19, %$8] ; # Y
  %30 = phi i64 [%22, %$8] ; # Z
; # (shift X)
  %31 = inttoptr i64 %28 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  %33 = load i64, i64* %32
; # (atom (shift X))
  %34 = and i64 %33, 15
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$14, label %$13
$14:
  %36 = phi i64 [%33, %$11] ; # X
  %37 = phi i64 [%29, %$11] ; # Y
  %38 = phi i64 [%30, %$11] ; # Z
; # (set 2 Y $Nil)
  %39 = inttoptr i64 %37 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %40
; # (loop (setq X (cdr Z)) (set 2 Z Y) (? (atom X) Z) (setq Y Z Z X))...
  br label %$15
$15:
  %41 = phi i64 [%36, %$14], [%54, %$16] ; # X
  %42 = phi i64 [%37, %$14], [%56, %$16] ; # Y
  %43 = phi i64 [%38, %$14], [%54, %$16] ; # Z
; # (cdr Z)
  %44 = inttoptr i64 %43 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (set 2 Z Y)
  %47 = inttoptr i64 %43 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %42, i64* %48
; # (? (atom X) Z)
; # (atom X)
  %49 = and i64 %46, 15
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$18, label %$16
$18:
  %51 = phi i64 [%46, %$15] ; # X
  %52 = phi i64 [%42, %$15] ; # Y
  %53 = phi i64 [%43, %$15] ; # Z
  br label %$17
$16:
  %54 = phi i64 [%46, %$15] ; # X
  %55 = phi i64 [%42, %$15] ; # Y
  %56 = phi i64 [%43, %$15] ; # Z
  br label %$15
$17:
  %57 = phi i64 [%51, %$18] ; # X
  %58 = phi i64 [%52, %$18] ; # Y
  %59 = phi i64 [%53, %$18] ; # Z
  %60 = phi i64 [%53, %$18] ; # ->
  br label %$10
$13:
  %61 = phi i64 [%33, %$11] ; # X
  %62 = phi i64 [%29, %$11] ; # Y
  %63 = phi i64 [%30, %$11] ; # Z
; # (let N (save Y (evCnt Exe X)) (if (le0 (dec 'N)) Y (set 2 Y (cdr ...
; # (save Y (evCnt Exe X))
  %64 = alloca i64, i64 2, align 16
  %65 = ptrtoint i64* %64 to i64
  %66 = inttoptr i64 %65 to i64*
  store i64 %62, i64* %66
  %67 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %68 = load i64, i64* %67
  %69 = inttoptr i64 %65 to i64*
  %70 = getelementptr i64, i64* %69, i32 1
  store i64 %68, i64* %70
  %71 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %71
; # (evCnt Exe X)
  %72 = call i64 @evCnt(i64 %0, i64 %61)
  %73 = inttoptr i64 %65 to i64*
  %74 = getelementptr i64, i64* %73, i32 1
  %75 = load i64, i64* %74
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %75, i64* %76
; # (if (le0 (dec 'N)) Y (set 2 Y (cdr Z) 2 Z Y) (until (or (=0 (dec ...
; # (dec 'N)
  %77 = sub i64 %72, 1
; # (le0 (dec 'N))
  %78 = icmp sle i64 %77, 0
  br i1 %78, label %$19, label %$20
$19:
  %79 = phi i64 [%61, %$13] ; # X
  %80 = phi i64 [%62, %$13] ; # Y
  %81 = phi i64 [%63, %$13] ; # Z
  %82 = phi i64 [%77, %$13] ; # N
  br label %$21
$20:
  %83 = phi i64 [%61, %$13] ; # X
  %84 = phi i64 [%62, %$13] ; # Y
  %85 = phi i64 [%63, %$13] ; # Z
  %86 = phi i64 [%77, %$13] ; # N
; # (set 2 Y (cdr Z) 2 Z Y)
; # (cdr Z)
  %87 = inttoptr i64 %85 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
  %90 = inttoptr i64 %84 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  store i64 %89, i64* %91
  %92 = inttoptr i64 %85 to i64*
  %93 = getelementptr i64, i64* %92, i32 1
  store i64 %84, i64* %93
; # (until (or (=0 (dec 'N)) (atom (setq X (cdr Y)))) (set 2 Y (cdr X...
  br label %$22
$22:
  %94 = phi i64 [%83, %$20], [%114, %$25] ; # X
  %95 = phi i64 [%84, %$20], [%115, %$25] ; # Y
  %96 = phi i64 [%85, %$20], [%114, %$25] ; # Z
  %97 = phi i64 [%86, %$20], [%117, %$25] ; # N
; # (or (=0 (dec 'N)) (atom (setq X (cdr Y))))
; # (dec 'N)
  %98 = sub i64 %97, 1
; # (=0 (dec 'N))
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %$23, label %$24
$24:
  %100 = phi i64 [%94, %$22] ; # X
  %101 = phi i64 [%95, %$22] ; # Y
  %102 = phi i64 [%96, %$22] ; # Z
  %103 = phi i64 [%98, %$22] ; # N
; # (cdr Y)
  %104 = inttoptr i64 %101 to i64*
  %105 = getelementptr i64, i64* %104, i32 1
  %106 = load i64, i64* %105
; # (atom (setq X (cdr Y)))
  %107 = and i64 %106, 15
  %108 = icmp ne i64 %107, 0
  br label %$23
$23:
  %109 = phi i64 [%94, %$22], [%106, %$24] ; # X
  %110 = phi i64 [%95, %$22], [%101, %$24] ; # Y
  %111 = phi i64 [%96, %$22], [%102, %$24] ; # Z
  %112 = phi i64 [%98, %$22], [%103, %$24] ; # N
  %113 = phi i1 [1, %$22], [%108, %$24] ; # ->
  br i1 %113, label %$26, label %$25
$25:
  %114 = phi i64 [%109, %$23] ; # X
  %115 = phi i64 [%110, %$23] ; # Y
  %116 = phi i64 [%111, %$23] ; # Z
  %117 = phi i64 [%112, %$23] ; # N
; # (set 2 Y (cdr X) 2 X Z)
; # (cdr X)
  %118 = inttoptr i64 %114 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
  %121 = inttoptr i64 %115 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  store i64 %120, i64* %122
  %123 = inttoptr i64 %114 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  store i64 %116, i64* %124
  br label %$22
$26:
  %125 = phi i64 [%109, %$23] ; # X
  %126 = phi i64 [%110, %$23] ; # Y
  %127 = phi i64 [%111, %$23] ; # Z
  %128 = phi i64 [%112, %$23] ; # N
  br label %$21
$21:
  %129 = phi i64 [%79, %$19], [%125, %$26] ; # X
  %130 = phi i64 [%80, %$19], [%126, %$26] ; # Y
  %131 = phi i64 [%81, %$19], [%127, %$26] ; # Z
  %132 = phi i64 [%82, %$19], [%128, %$26] ; # N
  %133 = phi i64 [%80, %$19], [%127, %$26] ; # ->
  br label %$10
$10:
  %134 = phi i64 [%25, %$12], [%57, %$17], [%129, %$21] ; # X
  %135 = phi i64 [%26, %$12], [%58, %$17], [%130, %$21] ; # Y
  %136 = phi i64 [%27, %$12], [%59, %$17], [%131, %$21] ; # Z
  %137 = phi i64 [%26, %$12], [%60, %$17], [%133, %$21] ; # ->
  br label %$9
$9:
  %138 = phi i64 [%16, %$7], [%134, %$10] ; # X
  %139 = phi i64 [%17, %$7], [%135, %$10] ; # Y
  %140 = phi i64 [%17, %$7], [%137, %$10] ; # ->
  ret i64 %140
}

define i64 @trim(i64) {
$1:
; # (if (atom X) X (stkChk 0) (let Y (trim (cdr X)) (if (and (nil? Y)...
; # (atom X)
  %1 = and i64 %0, 15
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$2, label %$3
$2:
  br label %$4
$3:
; # (stkChk 0)
  %3 = load i8*, i8** @$StkLimit
  %4 = call i8* @llvm.stacksave()
  %5 = icmp ugt i8* %3, %4
  br i1 %5, label %$5, label %$6
$5:
  call void @stkErr(i64 0)
  unreachable
$6:
; # (let Y (trim (cdr X)) (if (and (nil? Y) (isBlank (car X))) $Nil (...
; # (cdr X)
  %6 = inttoptr i64 %0 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
; # (trim (cdr X))
  %9 = call i64 @trim(i64 %8)
; # (if (and (nil? Y) (isBlank (car X))) $Nil (cons (car X) Y))
; # (and (nil? Y) (isBlank (car X)))
; # (nil? Y)
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %10, label %$8, label %$7
$8:
; # (car X)
  %11 = inttoptr i64 %0 to i64*
  %12 = load i64, i64* %11
; # (isBlank (car X))
  %13 = call i1 @isBlank(i64 %12)
  br label %$7
$7:
  %14 = phi i1 [0, %$6], [%13, %$8] ; # ->
  br i1 %14, label %$9, label %$10
$9:
  br label %$11
$10:
; # (car X)
  %15 = inttoptr i64 %0 to i64*
  %16 = load i64, i64* %15
; # (cons (car X) Y)
  %17 = call i64 @cons(i64 %16, i64 %9)
  br label %$11
$11:
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$9], [%17, %$10] ; # ->
  br label %$4
$4:
  %19 = phi i64 [%0, %$2], [%18, %$11] ; # ->
  ret i64 %19
}

define i64 @_trim(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (cadr Exe)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (trim (save (eval (cadr Exe))))
  %22 = call i64 @trim(i64 %13)
; # (drop *Safe)
  %23 = inttoptr i64 %15 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %25, i64* %26
  ret i64 %22
}

define i64 @_clip(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (car X))) (while (and (pair Y) (isBlank...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (while (and (pair Y) (isBlank (car Y))) (shift Y))
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%26, %$10] ; # Y
; # (and (pair Y) (isBlank (car Y)))
; # (pair Y)
  %15 = and i64 %14, 15
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$9, label %$8
$9:
  %17 = phi i64 [%14, %$7] ; # Y
; # (car Y)
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
; # (isBlank (car Y))
  %20 = call i1 @isBlank(i64 %19)
  br label %$8
$8:
  %21 = phi i64 [%14, %$7], [%17, %$9] ; # Y
  %22 = phi i1 [0, %$7], [%20, %$9] ; # ->
  br i1 %22, label %$10, label %$11
$10:
  %23 = phi i64 [%21, %$8] ; # Y
; # (shift Y)
  %24 = inttoptr i64 %23 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
  br label %$7
$11:
  %27 = phi i64 [%21, %$8] ; # Y
; # (save Y)
  %28 = alloca i64, i64 2, align 16
  %29 = ptrtoint i64* %28 to i64
  %30 = inttoptr i64 %29 to i64*
  store i64 %27, i64* %30
  %31 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %32 = load i64, i64* %31
  %33 = inttoptr i64 %29 to i64*
  %34 = getelementptr i64, i64* %33, i32 1
  store i64 %32, i64* %34
  %35 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %29, i64* %35
; # (trim (save Y))
  %36 = call i64 @trim(i64 %27)
; # (drop *Safe)
  %37 = inttoptr i64 %29 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %40
  ret i64 %36
}

define i64 @_head(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((nil? Y) Y) ((pair Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((nil? Y) Y) ((pair Y) (save Y (let (Z Y L (eval (car X))) ...
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  br label %$7
$8:
; # (pair Y)
  %17 = and i64 %15, 15
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (save Y (let (Z Y L (eval (car X))) (loop (? (or (atom L) (not (e...
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %15, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (let (Z Y L (eval (car X))) (loop (? (or (atom L) (not (equal (ca...
; # (car X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
; # (eval (car X))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  br label %$12
$13:
  %31 = and i64 %28, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$15
$16:
  %33 = inttoptr i64 %28 to i64*
  %34 = load i64, i64* %33
  br label %$12
$15:
  %35 = call i64 @evList(i64 %28)
  br label %$12
$12:
  %36 = phi i64 [%28, %$14], [%34, %$16], [%35, %$15] ; # ->
; # (loop (? (or (atom L) (not (equal (car Z) (car L)))) $Nil) (? (at...
  br label %$17
$17:
  %37 = phi i64 [%15, %$12], [%63, %$23] ; # Z
  %38 = phi i64 [%36, %$12], [%67, %$23] ; # L
; # (? (or (atom L) (not (equal (car Z) (car L)))) $Nil)
; # (or (atom L) (not (equal (car Z) (car L))))
; # (atom L)
  %39 = and i64 %38, 15
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$18, label %$19
$19:
  %41 = phi i64 [%37, %$17] ; # Z
  %42 = phi i64 [%38, %$17] ; # L
; # (car Z)
  %43 = inttoptr i64 %41 to i64*
  %44 = load i64, i64* %43
; # (car L)
  %45 = inttoptr i64 %42 to i64*
  %46 = load i64, i64* %45
; # (equal (car Z) (car L))
  %47 = call i1 @equal(i64 %44, i64 %46)
; # (not (equal (car Z) (car L)))
  %48 = icmp eq i1 %47, 0
  br label %$18
$18:
  %49 = phi i64 [%37, %$17], [%41, %$19] ; # Z
  %50 = phi i64 [%38, %$17], [%42, %$19] ; # L
  %51 = phi i1 [1, %$17], [%48, %$19] ; # ->
  br i1 %51, label %$22, label %$20
$22:
  %52 = phi i64 [%49, %$18] ; # Z
  %53 = phi i64 [%50, %$18] ; # L
  br label %$21
$20:
  %54 = phi i64 [%49, %$18] ; # Z
  %55 = phi i64 [%50, %$18] ; # L
; # (? (atom (shift Z)) Y)
; # (shift Z)
  %56 = inttoptr i64 %54 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
; # (atom (shift Z))
  %59 = and i64 %58, 15
  %60 = icmp ne i64 %59, 0
  br i1 %60, label %$24, label %$23
$24:
  %61 = phi i64 [%58, %$20] ; # Z
  %62 = phi i64 [%55, %$20] ; # L
  br label %$21
$23:
  %63 = phi i64 [%58, %$20] ; # Z
  %64 = phi i64 [%55, %$20] ; # L
; # (shift L)
  %65 = inttoptr i64 %64 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  br label %$17
$21:
  %68 = phi i64 [%52, %$22], [%61, %$24] ; # Z
  %69 = phi i64 [%53, %$22], [%62, %$24] ; # L
  %70 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$22], [%15, %$24] ; # ->
  %71 = inttoptr i64 %20 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %74
  br label %$7
$10:
; # (xCnt Exe Y)
  %75 = call i64 @xCnt(i64 %0, i64 %15)
; # (=0 (xCnt Exe Y))
  %76 = icmp eq i64 %75, 0
  br i1 %76, label %$26, label %$25
$26:
  br label %$7
$25:
; # (let (N @ L (eval (car X))) (cond ((atom L) L) ((and (lt0 N) (le0...
; # (car X)
  %77 = inttoptr i64 %7 to i64*
  %78 = load i64, i64* %77
; # (eval (car X))
  %79 = and i64 %78, 6
  %80 = icmp ne i64 %79, 0
  br i1 %80, label %$29, label %$28
$29:
  br label %$27
$28:
  %81 = and i64 %78, 8
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$31, label %$30
$31:
  %83 = inttoptr i64 %78 to i64*
  %84 = load i64, i64* %83
  br label %$27
$30:
  %85 = call i64 @evList(i64 %78)
  br label %$27
$27:
  %86 = phi i64 [%78, %$29], [%84, %$31], [%85, %$30] ; # ->
; # (cond ((atom L) L) ((and (lt0 N) (le0 (inc 'N (length L)))) $Nil)...
; # (atom L)
  %87 = and i64 %86, 15
  %88 = icmp ne i64 %87, 0
  br i1 %88, label %$34, label %$33
$34:
  %89 = phi i64 [%75, %$27] ; # N
  %90 = phi i64 [%86, %$27] ; # L
  br label %$32
$33:
  %91 = phi i64 [%75, %$27] ; # N
  %92 = phi i64 [%86, %$27] ; # L
; # (and (lt0 N) (le0 (inc 'N (length L))))
; # (lt0 N)
  %93 = icmp slt i64 %91, 0
  br i1 %93, label %$36, label %$35
$36:
  %94 = phi i64 [%91, %$33] ; # N
  %95 = phi i64 [%92, %$33] ; # L
; # (length L)
  br label %$37
$37:
  %96 = phi i64 [%95, %$36], [%105, %$38] ; # X
  %97 = phi i64 [0, %$36], [%102, %$38] ; # N
  %98 = and i64 %96, 15
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %$38, label %$39
$38:
  %100 = phi i64 [%96, %$37] ; # X
  %101 = phi i64 [%97, %$37] ; # N
  %102 = add i64 %101, 1
  %103 = inttoptr i64 %100 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
  br label %$37
$39:
  %106 = phi i64 [%96, %$37] ; # X
  %107 = phi i64 [%97, %$37] ; # N
; # (inc 'N (length L))
  %108 = add i64 %94, %107
; # (le0 (inc 'N (length L)))
  %109 = icmp sle i64 %108, 0
  br label %$35
$35:
  %110 = phi i64 [%91, %$33], [%108, %$39] ; # N
  %111 = phi i64 [%92, %$33], [%95, %$39] ; # L
  %112 = phi i1 [0, %$33], [%109, %$39] ; # ->
  br i1 %112, label %$41, label %$40
$41:
  %113 = phi i64 [%110, %$35] ; # N
  %114 = phi i64 [%111, %$35] ; # L
  br label %$32
$40:
  %115 = phi i64 [%110, %$35] ; # N
  %116 = phi i64 [%111, %$35] ; # L
; # (save L (let (Z (cons (car L) $Nil) R (save Z)) (while (and (dec ...
  %117 = alloca i64, i64 2, align 16
  %118 = ptrtoint i64* %117 to i64
  %119 = inttoptr i64 %118 to i64*
  store i64 %116, i64* %119
  %120 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %121 = load i64, i64* %120
  %122 = inttoptr i64 %118 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  store i64 %121, i64* %123
  %124 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %118, i64* %124
; # (let (Z (cons (car L) $Nil) R (save Z)) (while (and (dec 'N) (pai...
; # (car L)
  %125 = inttoptr i64 %116 to i64*
  %126 = load i64, i64* %125
; # (cons (car L) $Nil)
  %127 = call i64 @cons(i64 %126, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Z)
  %128 = alloca i64, i64 2, align 16
  %129 = ptrtoint i64* %128 to i64
  %130 = inttoptr i64 %129 to i64*
  store i64 %127, i64* %130
  %131 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %132 = load i64, i64* %131
  %133 = inttoptr i64 %129 to i64*
  %134 = getelementptr i64, i64* %133, i32 1
  store i64 %132, i64* %134
  %135 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %129, i64* %135
; # (while (and (dec 'N) (pair (shift L))) (setq Z (set 2 Z (cons (ca...
  br label %$42
$42:
  %136 = phi i64 [%115, %$40], [%153, %$45] ; # N
  %137 = phi i64 [%116, %$40], [%154, %$45] ; # L
  %138 = phi i64 [%127, %$40], [%158, %$45] ; # Z
; # (and (dec 'N) (pair (shift L)))
; # (dec 'N)
  %139 = sub i64 %136, 1
  %140 = icmp ne i64 %139, 0
  br i1 %140, label %$44, label %$43
$44:
  %141 = phi i64 [%139, %$42] ; # N
  %142 = phi i64 [%137, %$42] ; # L
  %143 = phi i64 [%138, %$42] ; # Z
; # (shift L)
  %144 = inttoptr i64 %142 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (pair (shift L))
  %147 = and i64 %146, 15
  %148 = icmp eq i64 %147, 0
  br label %$43
$43:
  %149 = phi i64 [%139, %$42], [%141, %$44] ; # N
  %150 = phi i64 [%137, %$42], [%146, %$44] ; # L
  %151 = phi i64 [%138, %$42], [%143, %$44] ; # Z
  %152 = phi i1 [0, %$42], [%148, %$44] ; # ->
  br i1 %152, label %$45, label %$46
$45:
  %153 = phi i64 [%149, %$43] ; # N
  %154 = phi i64 [%150, %$43] ; # L
  %155 = phi i64 [%151, %$43] ; # Z
; # (set 2 Z (cons (car L) $Nil))
; # (car L)
  %156 = inttoptr i64 %154 to i64*
  %157 = load i64, i64* %156
; # (cons (car L) $Nil)
  %158 = call i64 @cons(i64 %157, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %159 = inttoptr i64 %155 to i64*
  %160 = getelementptr i64, i64* %159, i32 1
  store i64 %158, i64* %160
  br label %$42
$46:
  %161 = phi i64 [%149, %$43] ; # N
  %162 = phi i64 [%150, %$43] ; # L
  %163 = phi i64 [%151, %$43] ; # Z
  %164 = inttoptr i64 %118 to i64*
  %165 = getelementptr i64, i64* %164, i32 1
  %166 = load i64, i64* %165
  %167 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %166, i64* %167
  br label %$32
$32:
  %168 = phi i64 [%89, %$34], [%113, %$41], [%161, %$46] ; # N
  %169 = phi i64 [%90, %$34], [%114, %$41], [%162, %$46] ; # L
  %170 = phi i64 [%90, %$34], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$41], [%127, %$46] ; # ->
  br label %$7
$7:
  %171 = phi i64 [%15, %$9], [%70, %$21], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$26], [%170, %$32] ; # ->
  ret i64 %171
}

define i64 @_tail(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((nil? Y) Y) ((pair Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((nil? Y) Y) ((pair Y) (save Y (let L (eval (car X)) (loop ...
; # (nil? Y)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %16, label %$9, label %$8
$9:
  br label %$7
$8:
; # (pair Y)
  %17 = and i64 %15, 15
  %18 = icmp eq i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (save Y (let L (eval (car X)) (loop (? (atom L) $Nil) (? (equal L...
  %19 = alloca i64, i64 2, align 16
  %20 = ptrtoint i64* %19 to i64
  %21 = inttoptr i64 %20 to i64*
  store i64 %15, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %23 = load i64, i64* %22
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  store i64 %23, i64* %25
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %20, i64* %26
; # (let L (eval (car X)) (loop (? (atom L) $Nil) (? (equal L Y) Y) (...
; # (car X)
  %27 = inttoptr i64 %7 to i64*
  %28 = load i64, i64* %27
; # (eval (car X))
  %29 = and i64 %28, 6
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$14, label %$13
$14:
  br label %$12
$13:
  %31 = and i64 %28, 8
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$16, label %$15
$16:
  %33 = inttoptr i64 %28 to i64*
  %34 = load i64, i64* %33
  br label %$12
$15:
  %35 = call i64 @evList(i64 %28)
  br label %$12
$12:
  %36 = phi i64 [%28, %$14], [%34, %$16], [%35, %$15] ; # ->
; # (loop (? (atom L) $Nil) (? (equal L Y) Y) (? (atom (shift L)) $Ni...
  br label %$17
$17:
  %37 = phi i64 [%36, %$12], [%51, %$23] ; # L
; # (? (atom L) $Nil)
; # (atom L)
  %38 = and i64 %37, 15
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$20, label %$18
$20:
  %40 = phi i64 [%37, %$17] ; # L
  br label %$19
$18:
  %41 = phi i64 [%37, %$17] ; # L
; # (? (equal L Y) Y)
; # (equal L Y)
  %42 = call i1 @equal(i64 %41, i64 %15)
  br i1 %42, label %$22, label %$21
$22:
  %43 = phi i64 [%41, %$18] ; # L
  br label %$19
$21:
  %44 = phi i64 [%41, %$18] ; # L
; # (? (atom (shift L)) $Nil)
; # (shift L)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (atom (shift L))
  %48 = and i64 %47, 15
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$24, label %$23
$24:
  %50 = phi i64 [%47, %$21] ; # L
  br label %$19
$23:
  %51 = phi i64 [%47, %$21] ; # L
  br label %$17
$19:
  %52 = phi i64 [%40, %$20], [%43, %$22], [%50, %$24] ; # L
  %53 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$20], [%15, %$22], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$24] ; # ->
  %54 = inttoptr i64 %20 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
  %57 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %56, i64* %57
  br label %$7
$10:
; # (xCnt Exe Y)
  %58 = call i64 @xCnt(i64 %0, i64 %15)
; # (=0 (xCnt Exe Y))
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$26, label %$25
$26:
  br label %$7
$25:
; # (let (N @ L (eval (car X))) (cond ((atom L) L) ((lt0 N) (loop (sh...
; # (car X)
  %60 = inttoptr i64 %7 to i64*
  %61 = load i64, i64* %60
; # (eval (car X))
  %62 = and i64 %61, 6
  %63 = icmp ne i64 %62, 0
  br i1 %63, label %$29, label %$28
$29:
  br label %$27
$28:
  %64 = and i64 %61, 8
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$31, label %$30
$31:
  %66 = inttoptr i64 %61 to i64*
  %67 = load i64, i64* %66
  br label %$27
$30:
  %68 = call i64 @evList(i64 %61)
  br label %$27
$27:
  %69 = phi i64 [%61, %$29], [%67, %$31], [%68, %$30] ; # ->
; # (cond ((atom L) L) ((lt0 N) (loop (shift L) (? (=0 (inc 'N)) L)))...
; # (atom L)
  %70 = and i64 %69, 15
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$34, label %$33
$34:
  %72 = phi i64 [%58, %$27] ; # N
  %73 = phi i64 [%69, %$27] ; # L
  br label %$32
$33:
  %74 = phi i64 [%58, %$27] ; # N
  %75 = phi i64 [%69, %$27] ; # L
; # (lt0 N)
  %76 = icmp slt i64 %74, 0
  br i1 %76, label %$36, label %$35
$36:
  %77 = phi i64 [%74, %$33] ; # N
  %78 = phi i64 [%75, %$33] ; # L
; # (loop (shift L) (? (=0 (inc 'N)) L))
  br label %$37
$37:
  %79 = phi i64 [%77, %$36], [%88, %$38] ; # N
  %80 = phi i64 [%78, %$36], [%89, %$38] ; # L
; # (shift L)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
; # (? (=0 (inc 'N)) L)
; # (inc 'N)
  %84 = add i64 %79, 1
; # (=0 (inc 'N))
  %85 = icmp eq i64 %84, 0
  br i1 %85, label %$40, label %$38
$40:
  %86 = phi i64 [%84, %$37] ; # N
  %87 = phi i64 [%83, %$37] ; # L
  br label %$39
$38:
  %88 = phi i64 [%84, %$37] ; # N
  %89 = phi i64 [%83, %$37] ; # L
  br label %$37
$39:
  %90 = phi i64 [%86, %$40] ; # N
  %91 = phi i64 [%87, %$40] ; # L
  %92 = phi i64 [%87, %$40] ; # ->
  br label %$32
$35:
  %93 = phi i64 [%74, %$33] ; # N
  %94 = phi i64 [%75, %$33] ; # L
; # (let Z L (loop (? (=0 (dec 'N))) (? (atom (shift Z)))) (while (pa...
; # (loop (? (=0 (dec 'N))) (? (atom (shift Z))))
  br label %$41
$41:
  %95 = phi i64 [%93, %$35], [%108, %$44] ; # N
  %96 = phi i64 [%94, %$35], [%109, %$44] ; # L
  %97 = phi i64 [%94, %$35], [%110, %$44] ; # Z
; # (? (=0 (dec 'N)))
; # (dec 'N)
  %98 = sub i64 %95, 1
; # (=0 (dec 'N))
  %99 = icmp eq i64 %98, 0
  br i1 %99, label %$43, label %$42
$42:
  %100 = phi i64 [%98, %$41] ; # N
  %101 = phi i64 [%96, %$41] ; # L
  %102 = phi i64 [%97, %$41] ; # Z
; # (? (atom (shift Z)))
; # (shift Z)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
; # (atom (shift Z))
  %106 = and i64 %105, 15
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$43, label %$44
$44:
  %108 = phi i64 [%100, %$42] ; # N
  %109 = phi i64 [%101, %$42] ; # L
  %110 = phi i64 [%105, %$42] ; # Z
  br label %$41
$43:
  %111 = phi i64 [%98, %$41], [%100, %$42] ; # N
  %112 = phi i64 [%96, %$41], [%101, %$42] ; # L
  %113 = phi i64 [%97, %$41], [%105, %$42] ; # Z
  %114 = phi i64 [0, %$41], [0, %$42] ; # ->
; # (while (pair (shift Z)) (shift L))
  br label %$45
$45:
  %115 = phi i64 [%111, %$43], [%123, %$46] ; # N
  %116 = phi i64 [%112, %$43], [%128, %$46] ; # L
  %117 = phi i64 [%113, %$43], [%125, %$46] ; # Z
; # (shift Z)
  %118 = inttoptr i64 %117 to i64*
  %119 = getelementptr i64, i64* %118, i32 1
  %120 = load i64, i64* %119
; # (pair (shift Z))
  %121 = and i64 %120, 15
  %122 = icmp eq i64 %121, 0
  br i1 %122, label %$46, label %$47
$46:
  %123 = phi i64 [%115, %$45] ; # N
  %124 = phi i64 [%116, %$45] ; # L
  %125 = phi i64 [%120, %$45] ; # Z
; # (shift L)
  %126 = inttoptr i64 %124 to i64*
  %127 = getelementptr i64, i64* %126, i32 1
  %128 = load i64, i64* %127
  br label %$45
$47:
  %129 = phi i64 [%115, %$45] ; # N
  %130 = phi i64 [%116, %$45] ; # L
  %131 = phi i64 [%120, %$45] ; # Z
  br label %$32
$32:
  %132 = phi i64 [%72, %$34], [%90, %$39], [%129, %$47] ; # N
  %133 = phi i64 [%73, %$34], [%91, %$39], [%130, %$47] ; # L
  %134 = phi i64 [%73, %$34], [%92, %$39], [%130, %$47] ; # ->
  br label %$7
$7:
  %135 = phi i64 [%15, %$9], [%53, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$26], [%134, %$32] ; # ->
  ret i64 %135
}

define i64 @_stem(i64) {
$1:
; # (let (X (cdr Exe) L (save (eval (++ X)))) (if (atom X) L (let (R ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (if (atom X) L (let (R L N 1 A) (loop (setq A (link (push (eval (...
; # (atom X)
  %24 = and i64 %7, 15
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$7, label %$8
$7:
  %26 = phi i64 [%7, %$2] ; # X
  %27 = phi i64 [%15, %$2] ; # L
  br label %$9
$8:
  %28 = phi i64 [%7, %$2] ; # X
  %29 = phi i64 [%15, %$2] ; # L
; # (let (R L N 1 A) (loop (setq A (link (push (eval (car X))))) (? (...
; # (loop (setq A (link (push (eval (car X))))) (? (atom (shift X))) ...
  br label %$10
$10:
  %30 = phi i64 [%28, %$8], [%57, %$16] ; # X
  %31 = phi i64 [%29, %$8], [%58, %$16] ; # L
  %32 = phi i64 [%29, %$8], [%59, %$16] ; # R
  %33 = phi i64 [1, %$8], [%62, %$16] ; # N
; # (car X)
  %34 = inttoptr i64 %30 to i64*
  %35 = load i64, i64* %34
; # (eval (car X))
  %36 = and i64 %35, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$13, label %$12
$13:
  br label %$11
$12:
  %38 = and i64 %35, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$15, label %$14
$15:
  %40 = inttoptr i64 %35 to i64*
  %41 = load i64, i64* %40
  br label %$11
$14:
  %42 = call i64 @evList(i64 %35)
  br label %$11
$11:
  %43 = phi i64 [%35, %$13], [%41, %$15], [%42, %$14] ; # ->
; # (push (eval (car X)))
  %44 = alloca i64, i64 1
  %45 = ptrtoint i64* %44 to i64
  %46 = inttoptr i64 %45 to i64*
  store i64 %43, i64* %46
; # (link (push (eval (car X))))
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %48 = load i64, i64* %47
  %49 = inttoptr i64 %45 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  store i64 %48, i64* %50
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %45, i64* %51
; # (? (atom (shift X)))
; # (shift X)
  %52 = inttoptr i64 %30 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (atom (shift X))
  %55 = and i64 %54, 15
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$17, label %$16
$16:
  %57 = phi i64 [%54, %$11] ; # X
  %58 = phi i64 [%31, %$11] ; # L
  %59 = phi i64 [%32, %$11] ; # R
  %60 = phi i64 [%33, %$11] ; # N
  %61 = phi i64 [%45, %$11] ; # A
; # (inc 'N)
  %62 = add i64 %60, 1
  br label %$10
$17:
  %63 = phi i64 [%54, %$11] ; # X
  %64 = phi i64 [%31, %$11] ; # L
  %65 = phi i64 [%32, %$11] ; # R
  %66 = phi i64 [%33, %$11] ; # N
  %67 = phi i64 [%45, %$11] ; # A
  %68 = phi i64 [0, %$11] ; # ->
; # (loop (let (P A I N) (loop (? (equal (car L) (car P)) (setq R (cd...
  br label %$18
$18:
  %69 = phi i64 [%63, %$17], [%128, %$24] ; # X
  %70 = phi i64 [%64, %$17], [%129, %$24] ; # L
  %71 = phi i64 [%65, %$17], [%130, %$24] ; # R
  %72 = phi i64 [%66, %$17], [%131, %$24] ; # N
  %73 = phi i64 [%67, %$17], [%132, %$24] ; # A
; # (let (P A I N) (loop (? (equal (car L) (car P)) (setq R (cdr L)))...
; # (loop (? (equal (car L) (car P)) (setq R (cdr L))) (? (=0 (dec 'I...
  br label %$19
$19:
  %74 = phi i64 [%69, %$18], [%105, %$23] ; # X
  %75 = phi i64 [%70, %$18], [%106, %$23] ; # L
  %76 = phi i64 [%71, %$18], [%107, %$23] ; # R
  %77 = phi i64 [%72, %$18], [%108, %$23] ; # N
  %78 = phi i64 [%73, %$18], [%109, %$23] ; # A
  %79 = phi i64 [%73, %$18], [%114, %$23] ; # P
  %80 = phi i64 [%72, %$18], [%111, %$23] ; # I
; # (? (equal (car L) (car P)) (setq R (cdr L)))
; # (car L)
  %81 = inttoptr i64 %75 to i64*
  %82 = load i64, i64* %81
; # (car P)
  %83 = inttoptr i64 %79 to i64*
  %84 = load i64, i64* %83
; # (equal (car L) (car P))
  %85 = call i1 @equal(i64 %82, i64 %84)
  br i1 %85, label %$22, label %$20
$22:
  %86 = phi i64 [%74, %$19] ; # X
  %87 = phi i64 [%75, %$19] ; # L
  %88 = phi i64 [%76, %$19] ; # R
  %89 = phi i64 [%77, %$19] ; # N
  %90 = phi i64 [%78, %$19] ; # A
  %91 = phi i64 [%79, %$19] ; # P
  %92 = phi i64 [%80, %$19] ; # I
; # (cdr L)
  %93 = inttoptr i64 %87 to i64*
  %94 = getelementptr i64, i64* %93, i32 1
  %95 = load i64, i64* %94
  br label %$21
$20:
  %96 = phi i64 [%74, %$19] ; # X
  %97 = phi i64 [%75, %$19] ; # L
  %98 = phi i64 [%76, %$19] ; # R
  %99 = phi i64 [%77, %$19] ; # N
  %100 = phi i64 [%78, %$19] ; # A
  %101 = phi i64 [%79, %$19] ; # P
  %102 = phi i64 [%80, %$19] ; # I
; # (? (=0 (dec 'I)))
; # (dec 'I)
  %103 = sub i64 %102, 1
; # (=0 (dec 'I))
  %104 = icmp eq i64 %103, 0
  br i1 %104, label %$21, label %$23
$23:
  %105 = phi i64 [%96, %$20] ; # X
  %106 = phi i64 [%97, %$20] ; # L
  %107 = phi i64 [%98, %$20] ; # R
  %108 = phi i64 [%99, %$20] ; # N
  %109 = phi i64 [%100, %$20] ; # A
  %110 = phi i64 [%101, %$20] ; # P
  %111 = phi i64 [%103, %$20] ; # I
; # (shift P)
  %112 = inttoptr i64 %110 to i64*
  %113 = getelementptr i64, i64* %112, i32 1
  %114 = load i64, i64* %113
  br label %$19
$21:
  %115 = phi i64 [%86, %$22], [%96, %$20] ; # X
  %116 = phi i64 [%87, %$22], [%97, %$20] ; # L
  %117 = phi i64 [%95, %$22], [%98, %$20] ; # R
  %118 = phi i64 [%89, %$22], [%99, %$20] ; # N
  %119 = phi i64 [%90, %$22], [%100, %$20] ; # A
  %120 = phi i64 [%91, %$22], [%101, %$20] ; # P
  %121 = phi i64 [%92, %$22], [%103, %$20] ; # I
  %122 = phi i64 [%95, %$22], [0, %$20] ; # ->
; # (? (atom (shift L)))
; # (shift L)
  %123 = inttoptr i64 %116 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
; # (atom (shift L))
  %126 = and i64 %125, 15
  %127 = icmp ne i64 %126, 0
  br i1 %127, label %$25, label %$24
$24:
  %128 = phi i64 [%115, %$21] ; # X
  %129 = phi i64 [%125, %$21] ; # L
  %130 = phi i64 [%117, %$21] ; # R
  %131 = phi i64 [%118, %$21] ; # N
  %132 = phi i64 [%119, %$21] ; # A
  br label %$18
$25:
  %133 = phi i64 [%115, %$21] ; # X
  %134 = phi i64 [%125, %$21] ; # L
  %135 = phi i64 [%117, %$21] ; # R
  %136 = phi i64 [%118, %$21] ; # N
  %137 = phi i64 [%119, %$21] ; # A
  %138 = phi i64 [0, %$21] ; # ->
  br label %$9
$9:
  %139 = phi i64 [%26, %$7], [%133, %$25] ; # X
  %140 = phi i64 [%27, %$7], [%134, %$25] ; # L
  %141 = phi i64 [%27, %$7], [%135, %$25] ; # ->
; # (drop *Safe)
  %142 = inttoptr i64 %17 to i64*
  %143 = getelementptr i64, i64* %142, i32 1
  %144 = load i64, i64* %143
  %145 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %144, i64* %145
  ret i64 %141
}

define i64 @_fin(i64) {
$1:
; # (let X (eval (cadr Exe)) (while (pair X) (shift X)) X)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (while (pair X) (shift X))
  br label %$7
$7:
  %14 = phi i64 [%13, %$2], [%20, %$8] ; # X
; # (pair X)
  %15 = and i64 %14, 15
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$8, label %$9
$8:
  %17 = phi i64 [%14, %$7] ; # X
; # (shift X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  br label %$7
$9:
  %21 = phi i64 [%14, %$7] ; # X
  ret i64 %21
}

define i64 @_last(i64) {
$1:
; # (let X (eval (cadr Exe)) (if (atom X) X (while (pair (cdr X)) (se...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (if (atom X) X (while (pair (cdr X)) (setq X @)) (car X))
; # (atom X)
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%13, %$2] ; # X
  br label %$9
$8:
  %17 = phi i64 [%13, %$2] ; # X
; # (while (pair (cdr X)) (setq X @))
  br label %$10
$10:
  %18 = phi i64 [%17, %$8], [%21, %$11] ; # X
; # (cdr X)
  %19 = inttoptr i64 %18 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  %21 = load i64, i64* %20
; # (pair (cdr X))
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$11, label %$12
$11:
  %24 = phi i64 [%18, %$10] ; # X
  br label %$10
$12:
  %25 = phi i64 [%18, %$10] ; # X
; # (car X)
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
  br label %$9
$9:
  %28 = phi i64 [%16, %$7], [%25, %$12] ; # X
  %29 = phi i64 [%16, %$7], [%27, %$12] ; # ->
  ret i64 %29
}

define i64 @_eq(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $T) (? (<> Y (eval (car X))) $Nil))
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%42, %$16] ; # X
; # (? (atom (shift X)) $T)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (<> Y (eval (car X))) $Nil)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (<> Y (eval (car X)))
  %40 = icmp ne i64 %13, %39
  br i1 %40, label %$17, label %$16
$17:
  %41 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %43 = phi i64 [%28, %$10], [%41, %$17] ; # X
  %44 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %45 = inttoptr i64 %15 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret i64 %44
}

define i64 @_neq(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $Nil) (? (<> Y (eval (car X))) $T))
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%42, %$16] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (<> Y (eval (car X))) $T)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (<> Y (eval (car X)))
  %40 = icmp ne i64 %13, %39
  br i1 %40, label %$17, label %$16
$17:
  %41 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %43 = phi i64 [%28, %$10], [%41, %$17] ; # X
  %44 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$17] ; # ->
; # (drop *Safe)
  %45 = inttoptr i64 %15 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret i64 %44
}

define i64 @_equal(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $T) (? (not (equal Y (eval (car X)))) $...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%43, %$16] ; # X
; # (? (atom (shift X)) $T)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (not (equal Y (eval (car X)))) $Nil)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (equal Y (eval (car X)))
  %40 = call i1 @equal(i64 %13, i64 %39)
; # (not (equal Y (eval (car X))))
  %41 = icmp eq i1 %40, 0
  br i1 %41, label %$17, label %$16
$17:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %43 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %44 = phi i64 [%28, %$10], [%42, %$17] ; # X
  %45 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %46 = inttoptr i64 %15 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %49
  ret i64 %45
}

define i64 @_nequal(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $Nil) (? (not (equal Y (eval (car X))))...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%43, %$16] ; # X
; # (? (atom (shift X)) $Nil)
; # (shift X)
  %23 = inttoptr i64 %22 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (atom (shift X))
  %26 = and i64 %25, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$10, label %$8
$10:
  %28 = phi i64 [%25, %$7] ; # X
  br label %$9
$8:
  %29 = phi i64 [%25, %$7] ; # X
; # (? (not (equal Y (eval (car X)))) $T)
; # (car X)
  %30 = inttoptr i64 %29 to i64*
  %31 = load i64, i64* %30
; # (eval (car X))
  %32 = and i64 %31, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  br label %$11
$12:
  %34 = and i64 %31, 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$15, label %$14
$15:
  %36 = inttoptr i64 %31 to i64*
  %37 = load i64, i64* %36
  br label %$11
$14:
  %38 = call i64 @evList(i64 %31)
  br label %$11
$11:
  %39 = phi i64 [%31, %$13], [%37, %$15], [%38, %$14] ; # ->
; # (equal Y (eval (car X)))
  %40 = call i1 @equal(i64 %13, i64 %39)
; # (not (equal Y (eval (car X))))
  %41 = icmp eq i1 %40, 0
  br i1 %41, label %$17, label %$16
$17:
  %42 = phi i64 [%29, %$11] ; # X
  br label %$9
$16:
  %43 = phi i64 [%29, %$11] ; # X
  br label %$7
$9:
  %44 = phi i64 [%28, %$10], [%42, %$17] ; # X
  %45 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$17] ; # ->
; # (drop *Safe)
  %46 = inttoptr i64 %15 to i64*
  %47 = getelementptr i64, i64* %46, i32 1
  %48 = load i64, i64* %47
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %48, i64* %49
  ret i64 %45
}

define i64 @_eq0(i64) {
$1:
; # (if (== (eval (cadr Exe)) ZERO) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) ZERO)
  %14 = icmp eq i64 %13, 2
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_eq1(i64) {
$1:
; # (if (== (eval (cadr Exe)) ONE) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) ONE)
  %14 = icmp eq i64 %13, 18
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_eqT(i64) {
$1:
; # (if (== (eval (cadr Exe)) $T) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) $T)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_neq0(i64) {
$1:
; # (if (== (eval (cadr Exe)) ZERO) $Nil $T)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) ZERO)
  %14 = icmp eq i64 %13, 2
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_neqT(i64) {
$1:
; # (if (== (eval (cadr Exe)) $T) $Nil $T)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (== (eval (cadr Exe)) $T)
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %14, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$8] ; # ->
  ret i64 %15
}

define i64 @_lt(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (ge0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (ge0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (ge0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (ge0 (compare Y Z))
  %44 = icmp sge i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %15 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %15 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_le(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (gt0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (gt0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (gt0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (gt0 (compare Y Z))
  %44 = icmp sgt i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %15 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %15 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_gt(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (le0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (le0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (le0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (le0 (compare Y Z))
  %44 = icmp sle i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %15 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %15 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_ge(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (car X)))) (loop (? (atom (shift ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (loop (? (atom (shift X)) $T) (let Z (eval (car X)) (? (lt0 (comp...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%47, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%42, %$16] ; # Y
; # (? (atom (shift X)) $T)
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$10, label %$8
$10:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # Y
  br label %$9
$8:
  %31 = phi i64 [%26, %$7] ; # X
  %32 = phi i64 [%23, %$7] ; # Y
; # (let Z (eval (car X)) (? (lt0 (compare Y Z)) $Nil) (setq Y (safe ...
; # (car X)
  %33 = inttoptr i64 %31 to i64*
  %34 = load i64, i64* %33
; # (eval (car X))
  %35 = and i64 %34, 6
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$13, label %$12
$13:
  br label %$11
$12:
  %37 = and i64 %34, 8
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$15, label %$14
$15:
  %39 = inttoptr i64 %34 to i64*
  %40 = load i64, i64* %39
  br label %$11
$14:
  %41 = call i64 @evList(i64 %34)
  br label %$11
$11:
  %42 = phi i64 [%34, %$13], [%40, %$15], [%41, %$14] ; # ->
; # (? (lt0 (compare Y Z)) $Nil)
; # (compare Y Z)
  %43 = call i64 @compare(i64 %32, i64 %42)
; # (lt0 (compare Y Z))
  %44 = icmp slt i64 %43, 0
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%31, %$11] ; # X
  %46 = phi i64 [%32, %$11] ; # Y
  br label %$9
$16:
  %47 = phi i64 [%31, %$11] ; # X
  %48 = phi i64 [%32, %$11] ; # Y
; # (safe Z)
  %49 = inttoptr i64 %15 to i64*
  store i64 %42, i64* %49
  br label %$7
$9:
  %50 = phi i64 [%29, %$10], [%45, %$17] ; # X
  %51 = phi i64 [%30, %$10], [%46, %$17] ; # Y
  %52 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$10], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
; # (drop *Safe)
  %53 = inttoptr i64 %15 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
}

define i64 @_max(i64) {
$1:
; # (let (X (cdr Exe) R (save (eval (car X)))) (while (pair (shift X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (while (pair (shift X)) (let Z (eval (car X)) (when (gt0 (compare...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%46, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%47, %$16] ; # R
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (pair (shift X))
  %27 = and i64 %26, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$9
$8:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # R
; # (let Z (eval (car X)) (when (gt0 (compare Z R)) (setq R (safe Z))...
; # (car X)
  %31 = inttoptr i64 %29 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  br label %$10
$11:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$14, label %$13
$14:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$10
$13:
  %39 = call i64 @evList(i64 %32)
  br label %$10
$10:
  %40 = phi i64 [%32, %$12], [%38, %$14], [%39, %$13] ; # ->
; # (when (gt0 (compare Z R)) (setq R (safe Z)))
; # (compare Z R)
  %41 = call i64 @compare(i64 %40, i64 %30)
; # (gt0 (compare Z R))
  %42 = icmp sgt i64 %41, 0
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%29, %$10] ; # X
  %44 = phi i64 [%30, %$10] ; # R
; # (safe Z)
  %45 = inttoptr i64 %15 to i64*
  store i64 %40, i64* %45
  br label %$16
$16:
  %46 = phi i64 [%29, %$10], [%43, %$15] ; # X
  %47 = phi i64 [%30, %$10], [%40, %$15] ; # R
  br label %$7
$9:
  %48 = phi i64 [%26, %$7] ; # X
  %49 = phi i64 [%23, %$7] ; # R
; # (drop *Safe)
  %50 = inttoptr i64 %15 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %49
}

define i64 @_min(i64) {
$1:
; # (let (X (cdr Exe) R (save (eval (car X)))) (while (pair (shift X)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (car X)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (while (pair (shift X)) (let Z (eval (car X)) (when (lt0 (compare...
  br label %$7
$7:
  %22 = phi i64 [%3, %$2], [%46, %$16] ; # X
  %23 = phi i64 [%13, %$2], [%47, %$16] ; # R
; # (shift X)
  %24 = inttoptr i64 %22 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (pair (shift X))
  %27 = and i64 %26, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$8, label %$9
$8:
  %29 = phi i64 [%26, %$7] ; # X
  %30 = phi i64 [%23, %$7] ; # R
; # (let Z (eval (car X)) (when (lt0 (compare Z R)) (setq R (safe Z))...
; # (car X)
  %31 = inttoptr i64 %29 to i64*
  %32 = load i64, i64* %31
; # (eval (car X))
  %33 = and i64 %32, 6
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$12, label %$11
$12:
  br label %$10
$11:
  %35 = and i64 %32, 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$14, label %$13
$14:
  %37 = inttoptr i64 %32 to i64*
  %38 = load i64, i64* %37
  br label %$10
$13:
  %39 = call i64 @evList(i64 %32)
  br label %$10
$10:
  %40 = phi i64 [%32, %$12], [%38, %$14], [%39, %$13] ; # ->
; # (when (lt0 (compare Z R)) (setq R (safe Z)))
; # (compare Z R)
  %41 = call i64 @compare(i64 %40, i64 %30)
; # (lt0 (compare Z R))
  %42 = icmp slt i64 %41, 0
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%29, %$10] ; # X
  %44 = phi i64 [%30, %$10] ; # R
; # (safe Z)
  %45 = inttoptr i64 %15 to i64*
  store i64 %40, i64* %45
  br label %$16
$16:
  %46 = phi i64 [%29, %$10], [%43, %$15] ; # X
  %47 = phi i64 [%30, %$10], [%40, %$15] ; # R
  br label %$7
$9:
  %48 = phi i64 [%26, %$7] ; # X
  %49 = phi i64 [%23, %$7] ; # R
; # (drop *Safe)
  %50 = inttoptr i64 %15 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %49
}

define i64 @_atom(i64) {
$1:
; # (if (atom (eval (cadr Exe))) $T $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (atom (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_pair(i64) {
$1:
; # (if (pair (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (pair (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_circQ(i64) {
$1:
; # (if (circ (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (circ (eval (cadr Exe)))
  %14 = call i64 @circ(i64 %13)
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_lstQ(i64) {
$1:
; # (if (or (pair (eval (cadr Exe))) (nil? @)) $T $Nil)
; # (or (pair (eval (cadr Exe))) (nil? @))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (pair (eval (cadr Exe)))
  %14 = and i64 %13, 15
  %15 = icmp eq i64 %14, 0
  br i1 %15, label %$2, label %$8
$8:
; # (nil? @)
  %16 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$2
$2:
  %17 = phi i1 [1, %$3], [%16, %$8] ; # ->
  br i1 %17, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %18 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %18
}

define i64 @_numQ(i64) {
$1:
; # (if (num? (eval (cadr Exe))) @ $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (num? (eval (cadr Exe)))
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %16 = phi i64 [%13, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %16
}

define i64 @_symQ(i64) {
$1:
; # (if (symb? (eval (cadr Exe))) $T $Nil)
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (symb? (eval (cadr Exe)))
  %14 = xor i64 %13, 8
  %15 = and i64 %14, 14
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %$7, label %$8
$7:
  br label %$9
$8:
  br label %$9
$9:
  %17 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  ret i64 %17
}

define i64 @_flgQ(i64) {
$1:
; # (if (or (t? (eval (cadr Exe))) (nil? @)) $T $Nil)
; # (or (t? (eval (cadr Exe))) (nil? @))
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (t? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %14, label %$2, label %$8
$8:
; # (nil? @)
  %15 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$2
$2:
  %16 = phi i1 [1, %$3], [%15, %$8] ; # ->
  br i1 %16, label %$9, label %$10
$9:
  br label %$11
$10:
  br label %$11
$11:
  %17 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$10] ; # ->
  ret i64 %17
}

define i64 @_member(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) (if (equal Y Z) Z $Nil)) (? (equal Y (car Z)) Z...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%54, %$21] ; # Z
; # (? (atom Z) (if (equal Y Z) Z $Nil))
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
; # (if (equal Y Z) Z $Nil)
; # (equal Y Z)
  %38 = call i1 @equal(i64 %15, i64 %37)
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%37, %$15] ; # Z
  br label %$18
$17:
  %40 = phi i64 [%37, %$15] ; # Z
  br label %$18
$18:
  %41 = phi i64 [%39, %$16], [%40, %$17] ; # Z
  %42 = phi i64 [%39, %$16], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
  br label %$14
$13:
  %43 = phi i64 [%34, %$12] ; # Z
; # (? (equal Y (car Z)) Z)
; # (car Z)
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
; # (equal Y (car Z))
  %46 = call i1 @equal(i64 %15, i64 %45)
  br i1 %46, label %$20, label %$19
$20:
  %47 = phi i64 [%43, %$13] ; # Z
  br label %$14
$19:
  %48 = phi i64 [%43, %$13] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (== H (shift Z))
  %52 = icmp eq i64 %33, %51
  br i1 %52, label %$22, label %$21
$22:
  %53 = phi i64 [%51, %$19] ; # Z
  br label %$14
$21:
  %54 = phi i64 [%51, %$19] ; # Z
  br label %$12
$14:
  %55 = phi i64 [%41, %$18], [%47, %$20], [%53, %$22] ; # Z
  %56 = phi i64 [%42, %$18], [%47, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
; # (drop *Safe)
  %57 = inttoptr i64 %17 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 %56
}

define i64 @_memq(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) H Z) (l...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) (if (== Y Z) Z $Nil)) (? (== Y (car Z)) Z) (? (...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%54, %$21] ; # Z
; # (? (atom Z) (if (== Y Z) Z $Nil))
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
; # (if (== Y Z) Z $Nil)
; # (== Y Z)
  %38 = icmp eq i64 %15, %37
  br i1 %38, label %$16, label %$17
$16:
  %39 = phi i64 [%37, %$15] ; # Z
  br label %$18
$17:
  %40 = phi i64 [%37, %$15] ; # Z
  br label %$18
$18:
  %41 = phi i64 [%39, %$16], [%40, %$17] ; # Z
  %42 = phi i64 [%39, %$16], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17] ; # ->
  br label %$14
$13:
  %43 = phi i64 [%34, %$12] ; # Z
; # (? (== Y (car Z)) Z)
; # (car Z)
  %44 = inttoptr i64 %43 to i64*
  %45 = load i64, i64* %44
; # (== Y (car Z))
  %46 = icmp eq i64 %15, %45
  br i1 %46, label %$20, label %$19
$20:
  %47 = phi i64 [%43, %$13] ; # Z
  br label %$14
$19:
  %48 = phi i64 [%43, %$13] ; # Z
; # (? (== H (shift Z)) $Nil)
; # (shift Z)
  %49 = inttoptr i64 %48 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (== H (shift Z))
  %52 = icmp eq i64 %33, %51
  br i1 %52, label %$22, label %$21
$22:
  %53 = phi i64 [%51, %$19] ; # Z
  br label %$14
$21:
  %54 = phi i64 [%51, %$19] ; # Z
  br label %$12
$14:
  %55 = phi i64 [%41, %$18], [%47, %$20], [%53, %$22] ; # Z
  %56 = phi i64 [%42, %$18], [%47, %$20], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$22] ; # ->
; # (drop *Safe)
  %57 = inttoptr i64 %17 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 %56
}

define i64 @_mmeq(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (while...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (while (pair Y) (let (U (++ Y) V Z) (while (pair V) (when (== U (...
  br label %$12
$12:
  %34 = phi i64 [%15, %$7], [%76, %$22] ; # Y
; # (pair Y)
  %35 = and i64 %34, 15
  %36 = icmp eq i64 %35, 0
  br i1 %36, label %$13, label %$14
$13:
  %37 = phi i64 [%34, %$12] ; # Y
; # (let (U (++ Y) V Z) (while (pair V) (when (== U (car V)) (ret V))...
; # (++ Y)
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
  %40 = getelementptr i64, i64* %38, i32 1
  %41 = load i64, i64* %40
; # (while (pair V) (when (== U (car V)) (ret V)) (when (== Z (shift ...
  br label %$15
$15:
  %42 = phi i64 [%41, %$13], [%69, %$21] ; # Y
  %43 = phi i64 [%33, %$13], [%70, %$21] ; # V
; # (pair V)
  %44 = and i64 %43, 15
  %45 = icmp eq i64 %44, 0
  br i1 %45, label %$16, label %$17
$16:
  %46 = phi i64 [%42, %$15] ; # Y
  %47 = phi i64 [%43, %$15] ; # V
; # (when (== U (car V)) (ret V))
; # (car V)
  %48 = inttoptr i64 %47 to i64*
  %49 = load i64, i64* %48
; # (== U (car V))
  %50 = icmp eq i64 %39, %49
  br i1 %50, label %$18, label %$19
$18:
  %51 = phi i64 [%46, %$16] ; # Y
  %52 = phi i64 [%47, %$16] ; # V
; # (ret V)
; # (drop *Safe)
  %53 = inttoptr i64 %17 to i64*
  %54 = getelementptr i64, i64* %53, i32 1
  %55 = load i64, i64* %54
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %55, i64* %56
  ret i64 %52
$19:
  %57 = phi i64 [%46, %$16] ; # Y
  %58 = phi i64 [%47, %$16] ; # V
; # (when (== Z (shift V)) (ret $Nil))
; # (shift V)
  %59 = inttoptr i64 %58 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
; # (== Z (shift V))
  %62 = icmp eq i64 %33, %61
  br i1 %62, label %$20, label %$21
$20:
  %63 = phi i64 [%57, %$19] ; # Y
  %64 = phi i64 [%61, %$19] ; # V
; # (ret $Nil)
; # (drop *Safe)
  %65 = inttoptr i64 %17 to i64*
  %66 = getelementptr i64, i64* %65, i32 1
  %67 = load i64, i64* %66
  %68 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %67, i64* %68
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$21:
  %69 = phi i64 [%57, %$19] ; # Y
  %70 = phi i64 [%61, %$19] ; # V
  br label %$15
$17:
  %71 = phi i64 [%42, %$15] ; # Y
  %72 = phi i64 [%43, %$15] ; # V
; # (? (== U V) V)
; # (== U V)
  %73 = icmp eq i64 %39, %72
  br i1 %73, label %$23, label %$22
$23:
  %74 = phi i64 [%71, %$17] ; # Y
  %75 = phi i64 [%72, %$17] ; # V
  br label %$14
$22:
  %76 = phi i64 [%71, %$17] ; # Y
  %77 = phi i64 [%72, %$17] ; # V
  br label %$12
$14:
  %78 = phi i64 [%34, %$12], [%74, %$23] ; # Y
; # (drop *Safe)
  %79 = inttoptr i64 %17 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  %82 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %81, i64* %82
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_sect(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (car X))) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = alloca i64, i64 2, align 16
  %35 = ptrtoint i64* %34 to i64
  %36 = inttoptr i64 %35 to i64*
  store i64 %33, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %35 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  store i64 %38, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %35, i64* %41
; # (push $Nil NIL)
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %44
; # (link (push $Nil NIL))
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %43 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %46, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %49
; # (while (pair Y) (let U (++ Y) (when (member U Z) (let V (cons U $...
  br label %$12
$12:
  %50 = phi i64 [%15, %$7], [%89, %$22] ; # Y
  %51 = phi i64 [0, %$7], [%90, %$22] ; # P
; # (pair Y)
  %52 = and i64 %50, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$13, label %$14
$13:
  %54 = phi i64 [%50, %$12] ; # Y
  %55 = phi i64 [%51, %$12] ; # P
; # (let U (++ Y) (when (member U Z) (let V (cons U $Nil) (setq P (if...
; # (++ Y)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
  %58 = getelementptr i64, i64* %56, i32 1
  %59 = load i64, i64* %58
; # (when (member U Z) (let V (cons U $Nil) (setq P (if P (set 2 P V)...
; # (member U Z)
  br label %$15
$15:
  %60 = phi i64 [%33, %$13], [%72, %$19] ; # L
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$18, label %$16
$18:
  %63 = phi i64 [%60, %$15] ; # L
  br label %$17
$16:
  %64 = phi i64 [%60, %$15] ; # L
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = call i1 @equal(i64 %57, i64 %66)
  br i1 %67, label %$20, label %$19
$20:
  %68 = phi i64 [%64, %$16] ; # L
  br label %$17
$19:
  %69 = phi i64 [%64, %$16] ; # L
  %70 = inttoptr i64 %69 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  br label %$15
$17:
  %73 = phi i64 [%63, %$18], [%68, %$20] ; # L
  %74 = phi i1 [0, %$18], [1, %$20] ; # ->
  br i1 %74, label %$21, label %$22
$21:
  %75 = phi i64 [%59, %$17] ; # Y
  %76 = phi i64 [%55, %$17] ; # P
; # (let V (cons U $Nil) (setq P (if P (set 2 P V) (set R V))))
; # (cons U $Nil)
  %77 = call i64 @cons(i64 %57, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if P (set 2 P V) (set R V))
  %78 = icmp ne i64 %76, 0
  br i1 %78, label %$23, label %$24
$23:
  %79 = phi i64 [%75, %$21] ; # Y
  %80 = phi i64 [%76, %$21] ; # P
; # (set 2 P V)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  store i64 %77, i64* %82
  br label %$25
$24:
  %83 = phi i64 [%75, %$21] ; # Y
  %84 = phi i64 [%76, %$21] ; # P
; # (set R V)
  %85 = inttoptr i64 %43 to i64*
  store i64 %77, i64* %85
  br label %$25
$25:
  %86 = phi i64 [%79, %$23], [%83, %$24] ; # Y
  %87 = phi i64 [%80, %$23], [%84, %$24] ; # P
  %88 = phi i64 [%77, %$23], [%77, %$24] ; # ->
  br label %$22
$22:
  %89 = phi i64 [%59, %$17], [%86, %$25] ; # Y
  %90 = phi i64 [%55, %$17], [%88, %$25] ; # P
  br label %$12
$14:
  %91 = phi i64 [%50, %$12] ; # Y
  %92 = phi i64 [%51, %$12] ; # P
; # (val R)
  %93 = inttoptr i64 %43 to i64*
  %94 = load i64, i64* %93
; # (drop *Safe)
  %95 = inttoptr i64 %17 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %97, i64* %98
  ret i64 %94
}

define i64 @_diff(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (car X))) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = alloca i64, i64 2, align 16
  %35 = ptrtoint i64* %34 to i64
  %36 = inttoptr i64 %35 to i64*
  store i64 %33, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %35 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  store i64 %38, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %35, i64* %41
; # (push $Nil NIL)
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %44
; # (link (push $Nil NIL))
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %43 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %46, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %49
; # (while (pair Y) (let U (++ Y) (unless (member U Z) (let V (cons U...
  br label %$12
$12:
  %50 = phi i64 [%15, %$7], [%89, %$22] ; # Y
  %51 = phi i64 [0, %$7], [%90, %$22] ; # P
; # (pair Y)
  %52 = and i64 %50, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$13, label %$14
$13:
  %54 = phi i64 [%50, %$12] ; # Y
  %55 = phi i64 [%51, %$12] ; # P
; # (let U (++ Y) (unless (member U Z) (let V (cons U $Nil) (setq P (...
; # (++ Y)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
  %58 = getelementptr i64, i64* %56, i32 1
  %59 = load i64, i64* %58
; # (unless (member U Z) (let V (cons U $Nil) (setq P (if P (set 2 P ...
; # (member U Z)
  br label %$15
$15:
  %60 = phi i64 [%33, %$13], [%72, %$19] ; # L
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$18, label %$16
$18:
  %63 = phi i64 [%60, %$15] ; # L
  br label %$17
$16:
  %64 = phi i64 [%60, %$15] ; # L
  %65 = inttoptr i64 %64 to i64*
  %66 = load i64, i64* %65
  %67 = call i1 @equal(i64 %57, i64 %66)
  br i1 %67, label %$20, label %$19
$20:
  %68 = phi i64 [%64, %$16] ; # L
  br label %$17
$19:
  %69 = phi i64 [%64, %$16] ; # L
  %70 = inttoptr i64 %69 to i64*
  %71 = getelementptr i64, i64* %70, i32 1
  %72 = load i64, i64* %71
  br label %$15
$17:
  %73 = phi i64 [%63, %$18], [%68, %$20] ; # L
  %74 = phi i1 [0, %$18], [1, %$20] ; # ->
  br i1 %74, label %$22, label %$21
$21:
  %75 = phi i64 [%59, %$17] ; # Y
  %76 = phi i64 [%55, %$17] ; # P
; # (let V (cons U $Nil) (setq P (if P (set 2 P V) (set R V))))
; # (cons U $Nil)
  %77 = call i64 @cons(i64 %57, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (if P (set 2 P V) (set R V))
  %78 = icmp ne i64 %76, 0
  br i1 %78, label %$23, label %$24
$23:
  %79 = phi i64 [%75, %$21] ; # Y
  %80 = phi i64 [%76, %$21] ; # P
; # (set 2 P V)
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  store i64 %77, i64* %82
  br label %$25
$24:
  %83 = phi i64 [%75, %$21] ; # Y
  %84 = phi i64 [%76, %$21] ; # P
; # (set R V)
  %85 = inttoptr i64 %43 to i64*
  store i64 %77, i64* %85
  br label %$25
$25:
  %86 = phi i64 [%79, %$23], [%83, %$24] ; # Y
  %87 = phi i64 [%80, %$23], [%84, %$24] ; # P
  %88 = phi i64 [%77, %$23], [%77, %$24] ; # ->
  br label %$22
$22:
  %89 = phi i64 [%59, %$17], [%86, %$25] ; # Y
  %90 = phi i64 [%55, %$17], [%88, %$25] ; # P
  br label %$12
$14:
  %91 = phi i64 [%50, %$12] ; # Y
  %92 = phi i64 [%51, %$12] ; # P
; # (val R)
  %93 = inttoptr i64 %43 to i64*
  %94 = load i64, i64* %93
; # (drop *Safe)
  %95 = inttoptr i64 %17 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  %97 = load i64, i64* %96
  %98 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %97, i64* %98
  ret i64 %94
}

define i64 @_index(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) Cnt 1 U...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (? (equal Y (car Z)) (cnt Cnt)) (inc 'Cnt...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%58, %$18] ; # Z
  %35 = phi i64 [1, %$7], [%59, %$18] ; # Cnt
; # (? (atom Z) $Nil)
; # (atom Z)
  %36 = and i64 %34, 15
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$15, label %$13
$15:
  %38 = phi i64 [%34, %$12] ; # Z
  %39 = phi i64 [%35, %$12] ; # Cnt
  br label %$14
$13:
  %40 = phi i64 [%34, %$12] ; # Z
  %41 = phi i64 [%35, %$12] ; # Cnt
; # (? (equal Y (car Z)) (cnt Cnt))
; # (car Z)
  %42 = inttoptr i64 %40 to i64*
  %43 = load i64, i64* %42
; # (equal Y (car Z))
  %44 = call i1 @equal(i64 %15, i64 %43)
  br i1 %44, label %$17, label %$16
$17:
  %45 = phi i64 [%40, %$13] ; # Z
  %46 = phi i64 [%41, %$13] ; # Cnt
; # (cnt Cnt)
  %47 = shl i64 %46, 4
  %48 = or i64 %47, 2
  br label %$14
$16:
  %49 = phi i64 [%40, %$13] ; # Z
  %50 = phi i64 [%41, %$13] ; # Cnt
; # (inc 'Cnt)
  %51 = add i64 %50, 1
; # (? (== U (shift Z)) $Nil)
; # (shift Z)
  %52 = inttoptr i64 %49 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
; # (== U (shift Z))
  %55 = icmp eq i64 %33, %54
  br i1 %55, label %$19, label %$18
$19:
  %56 = phi i64 [%54, %$16] ; # Z
  %57 = phi i64 [%51, %$16] ; # Cnt
  br label %$14
$18:
  %58 = phi i64 [%54, %$16] ; # Z
  %59 = phi i64 [%51, %$16] ; # Cnt
  br label %$12
$14:
  %60 = phi i64 [%38, %$15], [%45, %$17], [%56, %$19] ; # Z
  %61 = phi i64 [%39, %$15], [%46, %$17], [%57, %$19] ; # Cnt
  %62 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%48, %$17], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$19] ; # ->
; # (drop *Safe)
  %63 = inttoptr i64 %17 to i64*
  %64 = getelementptr i64, i64* %63, i32 1
  %65 = load i64, i64* %64
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %65, i64* %66
  ret i64 %62
}

define i64 @_offset(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X)) Cnt 1) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (? (equal Y Z) (cnt Cnt)) (inc 'Cnt) (shi...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%52, %$16] ; # Z
  %35 = phi i64 [1, %$7], [%49, %$16] ; # Cnt
; # (? (atom Z) $Nil)
; # (atom Z)
  %36 = and i64 %34, 15
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$15, label %$13
$15:
  %38 = phi i64 [%34, %$12] ; # Z
  %39 = phi i64 [%35, %$12] ; # Cnt
  br label %$14
$13:
  %40 = phi i64 [%34, %$12] ; # Z
  %41 = phi i64 [%35, %$12] ; # Cnt
; # (? (equal Y Z) (cnt Cnt))
; # (equal Y Z)
  %42 = call i1 @equal(i64 %15, i64 %40)
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%40, %$13] ; # Z
  %44 = phi i64 [%41, %$13] ; # Cnt
; # (cnt Cnt)
  %45 = shl i64 %44, 4
  %46 = or i64 %45, 2
  br label %$14
$16:
  %47 = phi i64 [%40, %$13] ; # Z
  %48 = phi i64 [%41, %$13] ; # Cnt
; # (inc 'Cnt)
  %49 = add i64 %48, 1
; # (shift Z)
  %50 = inttoptr i64 %47 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  br label %$12
$14:
  %53 = phi i64 [%38, %$15], [%43, %$17] ; # Z
  %54 = phi i64 [%39, %$15], [%44, %$17] ; # Cnt
  %55 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%46, %$17] ; # ->
; # (drop *Safe)
  %56 = inttoptr i64 %17 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %55
}

define i64 @_prior(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (when ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (when (and (pair Y) (<> Y Z)) (while (pair Z) (when (== (cdr Z) Y...
; # (and (pair Y) (<> Y Z))
; # (pair Y)
  %34 = and i64 %15, 15
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$13, label %$12
$13:
  %36 = phi i64 [%33, %$7] ; # Z
; # (<> Y Z)
  %37 = icmp ne i64 %15, %36
  br label %$12
$12:
  %38 = phi i64 [%33, %$7], [%36, %$13] ; # Z
  %39 = phi i1 [0, %$7], [%37, %$13] ; # ->
  br i1 %39, label %$14, label %$15
$14:
  %40 = phi i64 [%38, %$12] ; # Z
; # (while (pair Z) (when (== (cdr Z) Y) (ret Z)) (setq Z @))
  br label %$16
$16:
  %41 = phi i64 [%40, %$14], [%47, %$20] ; # Z
; # (pair Z)
  %42 = and i64 %41, 15
  %43 = icmp eq i64 %42, 0
  br i1 %43, label %$17, label %$18
$17:
  %44 = phi i64 [%41, %$16] ; # Z
; # (when (== (cdr Z) Y) (ret Z))
; # (cdr Z)
  %45 = inttoptr i64 %44 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
; # (== (cdr Z) Y)
  %48 = icmp eq i64 %47, %15
  br i1 %48, label %$19, label %$20
$19:
  %49 = phi i64 [%44, %$17] ; # Z
; # (ret Z)
; # (drop *Safe)
  %50 = inttoptr i64 %17 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  %53 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %53
  ret i64 %49
$20:
  %54 = phi i64 [%44, %$17] ; # Z
  br label %$16
$18:
  %55 = phi i64 [%41, %$16] ; # Z
  br label %$15
$15:
  %56 = phi i64 [%38, %$12], [%55, %$18] ; # Z
; # (drop *Safe)
  %57 = inttoptr i64 %17 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
}

define i64 @_length(i64) {
$1:
; # (let X (eval (cadr Exe)) (cond ((num? X) (fmtNum X -2 0 0 null)) ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((num? X) (fmtNum X -2 0 0 null)) ((pair X) (let (C ONE Y X...
; # (num? X)
  %14 = and i64 %13, 6
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%13, %$2] ; # X
; # (fmtNum X -2 0 0 null)
  %17 = call i64 @fmtNum(i64 %16, i64 -2, i8 0, i8 0, i64* null)
  br label %$7
$8:
  %18 = phi i64 [%13, %$2] ; # X
; # (pair X)
  %19 = and i64 %18, 15
  %20 = icmp eq i64 %19, 0
  br i1 %20, label %$11, label %$10
$11:
  %21 = phi i64 [%18, %$8] ; # X
; # (let (C ONE Y X) (loop (set X (| (car X) 1)) (? (atom (shift X)) ...
; # (loop (set X (| (car X) 1)) (? (atom (shift X)) (loop (set Y (& (...
  br label %$12
$12:
  %22 = phi i64 [%21, %$11], [%100, %$19] ; # X
  %23 = phi i64 [18, %$11], [%103, %$19] ; # C
  %24 = phi i64 [%21, %$11], [%102, %$19] ; # Y
; # (set X (| (car X) 1))
; # (car X)
  %25 = inttoptr i64 %22 to i64*
  %26 = load i64, i64* %25
; # (| (car X) 1)
  %27 = or i64 %26, 1
  %28 = inttoptr i64 %22 to i64*
  store i64 %27, i64* %28
; # (? (atom (shift X)) (loop (set Y (& (car Y) -2)) (? (== X (shift ...
; # (shift X)
  %29 = inttoptr i64 %22 to i64*
  %30 = getelementptr i64, i64* %29, i32 1
  %31 = load i64, i64* %30
; # (atom (shift X))
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$15, label %$13
$15:
  %34 = phi i64 [%31, %$12] ; # X
  %35 = phi i64 [%23, %$12] ; # C
  %36 = phi i64 [%24, %$12] ; # Y
; # (loop (set Y (& (car Y) -2)) (? (== X (shift Y))))
  br label %$16
$16:
  %37 = phi i64 [%34, %$15], [%48, %$17] ; # X
  %38 = phi i64 [%35, %$15], [%49, %$17] ; # C
  %39 = phi i64 [%36, %$15], [%50, %$17] ; # Y
; # (set Y (& (car Y) -2))
; # (car Y)
  %40 = inttoptr i64 %39 to i64*
  %41 = load i64, i64* %40
; # (& (car Y) -2)
  %42 = and i64 %41, -2
  %43 = inttoptr i64 %39 to i64*
  store i64 %42, i64* %43
; # (? (== X (shift Y)))
; # (shift Y)
  %44 = inttoptr i64 %39 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (== X (shift Y))
  %47 = icmp eq i64 %37, %46
  br i1 %47, label %$18, label %$17
$17:
  %48 = phi i64 [%37, %$16] ; # X
  %49 = phi i64 [%38, %$16] ; # C
  %50 = phi i64 [%46, %$16] ; # Y
  br label %$16
$18:
  %51 = phi i64 [%37, %$16] ; # X
  %52 = phi i64 [%38, %$16] ; # C
  %53 = phi i64 [%46, %$16] ; # Y
  %54 = phi i64 [0, %$16] ; # ->
  br label %$14
$13:
  %55 = phi i64 [%31, %$12] ; # X
  %56 = phi i64 [%23, %$12] ; # C
  %57 = phi i64 [%24, %$12] ; # Y
; # (? (& (car X) 1) (until (== X Y) (set Y (& (car Y) -2)) (shift Y)...
; # (car X)
  %58 = inttoptr i64 %55 to i64*
  %59 = load i64, i64* %58
; # (& (car X) 1)
  %60 = and i64 %59, 1
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$20, label %$19
$20:
  %62 = phi i64 [%55, %$13] ; # X
  %63 = phi i64 [%56, %$13] ; # C
  %64 = phi i64 [%57, %$13] ; # Y
; # (until (== X Y) (set Y (& (car Y) -2)) (shift Y))
  br label %$21
$21:
  %65 = phi i64 [%62, %$20], [%69, %$22] ; # X
  %66 = phi i64 [%63, %$20], [%70, %$22] ; # C
  %67 = phi i64 [%64, %$20], [%78, %$22] ; # Y
; # (== X Y)
  %68 = icmp eq i64 %65, %67
  br i1 %68, label %$23, label %$22
$22:
  %69 = phi i64 [%65, %$21] ; # X
  %70 = phi i64 [%66, %$21] ; # C
  %71 = phi i64 [%67, %$21] ; # Y
; # (set Y (& (car Y) -2))
; # (car Y)
  %72 = inttoptr i64 %71 to i64*
  %73 = load i64, i64* %72
; # (& (car Y) -2)
  %74 = and i64 %73, -2
  %75 = inttoptr i64 %71 to i64*
  store i64 %74, i64* %75
; # (shift Y)
  %76 = inttoptr i64 %71 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
  br label %$21
$23:
  %79 = phi i64 [%65, %$21] ; # X
  %80 = phi i64 [%66, %$21] ; # C
  %81 = phi i64 [%67, %$21] ; # Y
; # (loop (set Y (& (car Y) -2)) (? (== X (shift Y))))
  br label %$24
$24:
  %82 = phi i64 [%79, %$23], [%93, %$25] ; # X
  %83 = phi i64 [%80, %$23], [%94, %$25] ; # C
  %84 = phi i64 [%81, %$23], [%95, %$25] ; # Y
; # (set Y (& (car Y) -2))
; # (car Y)
  %85 = inttoptr i64 %84 to i64*
  %86 = load i64, i64* %85
; # (& (car Y) -2)
  %87 = and i64 %86, -2
  %88 = inttoptr i64 %84 to i64*
  store i64 %87, i64* %88
; # (? (== X (shift Y)))
; # (shift Y)
  %89 = inttoptr i64 %84 to i64*
  %90 = getelementptr i64, i64* %89, i32 1
  %91 = load i64, i64* %90
; # (== X (shift Y))
  %92 = icmp eq i64 %82, %91
  br i1 %92, label %$26, label %$25
$25:
  %93 = phi i64 [%82, %$24] ; # X
  %94 = phi i64 [%83, %$24] ; # C
  %95 = phi i64 [%91, %$24] ; # Y
  br label %$24
$26:
  %96 = phi i64 [%82, %$24] ; # X
  %97 = phi i64 [%83, %$24] ; # C
  %98 = phi i64 [%91, %$24] ; # Y
  %99 = phi i64 [0, %$24] ; # ->
  br label %$14
$19:
  %100 = phi i64 [%55, %$13] ; # X
  %101 = phi i64 [%56, %$13] ; # C
  %102 = phi i64 [%57, %$13] ; # Y
; # (inc 'C (hex "10"))
  %103 = add i64 %101, 16
  br label %$12
$14:
  %104 = phi i64 [%51, %$18], [%96, %$26] ; # X
  %105 = phi i64 [%52, %$18], [%97, %$26] ; # C
  %106 = phi i64 [%53, %$18], [%98, %$26] ; # Y
  %107 = phi i64 [%52, %$18], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$26] ; # ->
  br label %$7
$10:
  %108 = phi i64 [%18, %$8] ; # X
; # (nil? X)
  %109 = icmp eq i64 %108, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %109, label %$28, label %$27
$28:
  %110 = phi i64 [%108, %$10] ; # X
  br label %$7
$27:
  %111 = phi i64 [%108, %$10] ; # X
; # (tail X)
  %112 = add i64 %111, -8
; # (val (tail X))
  %113 = inttoptr i64 %112 to i64*
  %114 = load i64, i64* %113
; # (sym? (val (tail X)))
  %115 = and i64 %114, 8
  %116 = icmp ne i64 %115, 0
  br i1 %116, label %$30, label %$29
$30:
  %117 = phi i64 [%111, %$27] ; # X
  br label %$7
$29:
  %118 = phi i64 [%111, %$27] ; # X
; # (let (C ZERO P (push 0 (name @))) (while (symChar P) (inc 'C (hex...
; # (name @)
  br label %$31
$31:
  %119 = phi i64 [%114, %$29], [%125, %$32] ; # Tail
  %120 = and i64 %119, 6
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$33, label %$32
$32:
  %122 = phi i64 [%119, %$31] ; # Tail
  %123 = inttoptr i64 %122 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  %125 = load i64, i64* %124
  br label %$31
$33:
  %126 = phi i64 [%119, %$31] ; # Tail
; # (push 0 (name @))
  %127 = alloca i64, i64 2, align 16
  store i64 0, i64* %127
  %128 = getelementptr i64, i64* %127, i32 1
  store i64 %126, i64* %128
; # (while (symChar P) (inc 'C (hex "10")))
  br label %$34
$34:
  %129 = phi i64 [%118, %$33], [%133, %$35] ; # X
  %130 = phi i64 [2, %$33], [%135, %$35] ; # C
; # (symChar P)
  %131 = call i32 @symChar(i64* %127)
  %132 = icmp ne i32 %131, 0
  br i1 %132, label %$35, label %$36
$35:
  %133 = phi i64 [%129, %$34] ; # X
  %134 = phi i64 [%130, %$34] ; # C
; # (inc 'C (hex "10"))
  %135 = add i64 %134, 16
  br label %$34
$36:
  %136 = phi i64 [%129, %$34] ; # X
  %137 = phi i64 [%130, %$34] ; # C
  br label %$7
$7:
  %138 = phi i64 [%16, %$9], [%104, %$14], [%110, %$28], [%117, %$30], [%136, %$36] ; # X
  %139 = phi i64 [%17, %$9], [%107, %$14], [2, %$28], [2, %$30], [%137, %$36] ; # ->
  ret i64 %139
}

define i64 @size(i64) {
$1:
; # (let (C 1 X L Y (car X)) (loop (when (pair Y) (stkChk 0) (inc 'C ...
; # (car X)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (loop (when (pair Y) (stkChk 0) (inc 'C (size Y))) (set X (| Y 1)...
  br label %$2
$2:
  %3 = phi i64 [%0, %$1], [%107, %$13] ; # L
  %4 = phi i64 [1, %$1], [%111, %$13] ; # C
  %5 = phi i64 [%0, %$1], [%109, %$13] ; # X
  %6 = phi i64 [%2, %$1], [%110, %$13] ; # Y
; # (when (pair Y) (stkChk 0) (inc 'C (size Y)))
; # (pair Y)
  %7 = and i64 %6, 15
  %8 = icmp eq i64 %7, 0
  br i1 %8, label %$3, label %$4
$3:
  %9 = phi i64 [%3, %$2] ; # L
  %10 = phi i64 [%4, %$2] ; # C
  %11 = phi i64 [%5, %$2] ; # X
  %12 = phi i64 [%6, %$2] ; # Y
; # (stkChk 0)
  %13 = load i8*, i8** @$StkLimit
  %14 = call i8* @llvm.stacksave()
  %15 = icmp ugt i8* %13, %14
  br i1 %15, label %$5, label %$6
$5:
  call void @stkErr(i64 0)
  unreachable
$6:
; # (size Y)
  %16 = call i64 @size(i64 %12)
; # (inc 'C (size Y))
  %17 = add i64 %10, %16
  br label %$4
$4:
  %18 = phi i64 [%3, %$2], [%9, %$6] ; # L
  %19 = phi i64 [%4, %$2], [%17, %$6] ; # C
  %20 = phi i64 [%5, %$2], [%11, %$6] ; # X
  %21 = phi i64 [%6, %$2], [%12, %$6] ; # Y
; # (set X (| Y 1))
; # (| Y 1)
  %22 = or i64 %21, 1
  %23 = inttoptr i64 %20 to i64*
  store i64 %22, i64* %23
; # (? (atom (shift X)) (loop (set L (& (car L) -2)) (? (== X (shift ...
; # (shift X)
  %24 = inttoptr i64 %20 to i64*
  %25 = getelementptr i64, i64* %24, i32 1
  %26 = load i64, i64* %25
; # (atom (shift X))
  %27 = and i64 %26, 15
  %28 = icmp ne i64 %27, 0
  br i1 %28, label %$9, label %$7
$9:
  %29 = phi i64 [%18, %$4] ; # L
  %30 = phi i64 [%19, %$4] ; # C
  %31 = phi i64 [%26, %$4] ; # X
  %32 = phi i64 [%21, %$4] ; # Y
; # (loop (set L (& (car L) -2)) (? (== X (shift L))))
  br label %$10
$10:
  %33 = phi i64 [%29, %$9], [%45, %$11] ; # L
  %34 = phi i64 [%30, %$9], [%46, %$11] ; # C
  %35 = phi i64 [%31, %$9], [%47, %$11] ; # X
  %36 = phi i64 [%32, %$9], [%48, %$11] ; # Y
; # (set L (& (car L) -2))
; # (car L)
  %37 = inttoptr i64 %33 to i64*
  %38 = load i64, i64* %37
; # (& (car L) -2)
  %39 = and i64 %38, -2
  %40 = inttoptr i64 %33 to i64*
  store i64 %39, i64* %40
; # (? (== X (shift L)))
; # (shift L)
  %41 = inttoptr i64 %33 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (== X (shift L))
  %44 = icmp eq i64 %35, %43
  br i1 %44, label %$12, label %$11
$11:
  %45 = phi i64 [%43, %$10] ; # L
  %46 = phi i64 [%34, %$10] ; # C
  %47 = phi i64 [%35, %$10] ; # X
  %48 = phi i64 [%36, %$10] ; # Y
  br label %$10
$12:
  %49 = phi i64 [%43, %$10] ; # L
  %50 = phi i64 [%34, %$10] ; # C
  %51 = phi i64 [%35, %$10] ; # X
  %52 = phi i64 [%36, %$10] ; # Y
  %53 = phi i64 [0, %$10] ; # ->
  br label %$8
$7:
  %54 = phi i64 [%18, %$4] ; # L
  %55 = phi i64 [%19, %$4] ; # C
  %56 = phi i64 [%26, %$4] ; # X
  %57 = phi i64 [%21, %$4] ; # Y
; # (? (& (setq Y (car X)) 1) (until (== X L) (set L (& (car L) -2)) ...
; # (car X)
  %58 = inttoptr i64 %56 to i64*
  %59 = load i64, i64* %58
; # (& (setq Y (car X)) 1)
  %60 = and i64 %59, 1
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$14, label %$13
$14:
  %62 = phi i64 [%54, %$7] ; # L
  %63 = phi i64 [%55, %$7] ; # C
  %64 = phi i64 [%56, %$7] ; # X
  %65 = phi i64 [%59, %$7] ; # Y
; # (until (== X L) (set L (& (car L) -2)) (shift L))
  br label %$15
$15:
  %66 = phi i64 [%62, %$14], [%81, %$16] ; # L
  %67 = phi i64 [%63, %$14], [%72, %$16] ; # C
  %68 = phi i64 [%64, %$14], [%73, %$16] ; # X
  %69 = phi i64 [%65, %$14], [%74, %$16] ; # Y
; # (== X L)
  %70 = icmp eq i64 %68, %66
  br i1 %70, label %$17, label %$16
$16:
  %71 = phi i64 [%66, %$15] ; # L
  %72 = phi i64 [%67, %$15] ; # C
  %73 = phi i64 [%68, %$15] ; # X
  %74 = phi i64 [%69, %$15] ; # Y
; # (set L (& (car L) -2))
; # (car L)
  %75 = inttoptr i64 %71 to i64*
  %76 = load i64, i64* %75
; # (& (car L) -2)
  %77 = and i64 %76, -2
  %78 = inttoptr i64 %71 to i64*
  store i64 %77, i64* %78
; # (shift L)
  %79 = inttoptr i64 %71 to i64*
  %80 = getelementptr i64, i64* %79, i32 1
  %81 = load i64, i64* %80
  br label %$15
$17:
  %82 = phi i64 [%66, %$15] ; # L
  %83 = phi i64 [%67, %$15] ; # C
  %84 = phi i64 [%68, %$15] ; # X
  %85 = phi i64 [%69, %$15] ; # Y
; # (loop (set L (& (car L) -2)) (? (== X (shift L))))
  br label %$18
$18:
  %86 = phi i64 [%82, %$17], [%98, %$19] ; # L
  %87 = phi i64 [%83, %$17], [%99, %$19] ; # C
  %88 = phi i64 [%84, %$17], [%100, %$19] ; # X
  %89 = phi i64 [%85, %$17], [%101, %$19] ; # Y
; # (set L (& (car L) -2))
; # (car L)
  %90 = inttoptr i64 %86 to i64*
  %91 = load i64, i64* %90
; # (& (car L) -2)
  %92 = and i64 %91, -2
  %93 = inttoptr i64 %86 to i64*
  store i64 %92, i64* %93
; # (? (== X (shift L)))
; # (shift L)
  %94 = inttoptr i64 %86 to i64*
  %95 = getelementptr i64, i64* %94, i32 1
  %96 = load i64, i64* %95
; # (== X (shift L))
  %97 = icmp eq i64 %88, %96
  br i1 %97, label %$20, label %$19
$19:
  %98 = phi i64 [%96, %$18] ; # L
  %99 = phi i64 [%87, %$18] ; # C
  %100 = phi i64 [%88, %$18] ; # X
  %101 = phi i64 [%89, %$18] ; # Y
  br label %$18
$20:
  %102 = phi i64 [%96, %$18] ; # L
  %103 = phi i64 [%87, %$18] ; # C
  %104 = phi i64 [%88, %$18] ; # X
  %105 = phi i64 [%89, %$18] ; # Y
  %106 = phi i64 [0, %$18] ; # ->
  br label %$8
$13:
  %107 = phi i64 [%54, %$7] ; # L
  %108 = phi i64 [%55, %$7] ; # C
  %109 = phi i64 [%56, %$7] ; # X
  %110 = phi i64 [%59, %$7] ; # Y
; # (inc 'C)
  %111 = add i64 %108, 1
  br label %$2
$8:
  %112 = phi i64 [%49, %$12], [%102, %$20] ; # L
  %113 = phi i64 [%50, %$12], [%103, %$20] ; # C
  %114 = phi i64 [%51, %$12], [%104, %$20] ; # X
  %115 = phi i64 [%52, %$12], [%105, %$20] ; # Y
  %116 = phi i64 [%50, %$12], [%103, %$20] ; # ->
  ret i64 %116
}

define i64 @binSize(i64) {
$1:
; # (cond ((cnt? X) (setq X (shr X 3)) (: 1 (let C 2 (while (setq X (...
; # (cnt? X)
  %1 = and i64 %0, 2
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # X
; # (shr X 3)
  %4 = lshr i64 %3, 3
; # (: 1 (let C 2 (while (setq X (shr X 8)) (inc 'C)) C))
  br label %$-1
$-1:
  %5 = phi i64 [%4, %$4], [%98, %$32] ; # X
; # (let C 2 (while (setq X (shr X 8)) (inc 'C)) C)
; # (while (setq X (shr X 8)) (inc 'C))
  br label %$5
$5:
  %6 = phi i64 [%5, %$-1], [%10, %$6] ; # X
  %7 = phi i64 [2, %$-1], [%12, %$6] ; # C
; # (shr X 8)
  %8 = lshr i64 %6, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$7
$6:
  %10 = phi i64 [%8, %$5] ; # X
  %11 = phi i64 [%7, %$5] ; # C
; # (inc 'C)
  %12 = add i64 %11, 1
  br label %$5
$7:
  %13 = phi i64 [%8, %$5] ; # X
  %14 = phi i64 [%7, %$5] ; # C
  br label %$2
$3:
  %15 = phi i64 [%0, %$1] ; # X
; # (big? X)
  %16 = and i64 %15, 4
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = phi i64 [%15, %$3] ; # X
; # (pos X)
  %19 = and i64 %18, -9
; # (let C 9 (loop (setq D (val (dig X))) (? (cnt? (setq X (val (big ...
; # (loop (setq D (val (dig X))) (? (cnt? (setq X (val (big X))))) (i...
  br label %$10
$10:
  %20 = phi i64 [%19, %$9], [%30, %$11] ; # X
  %21 = phi i64 [9, %$9], [%32, %$11] ; # C
; # (dig X)
  %22 = add i64 %20, -4
; # (val (dig X))
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %25 = add i64 %20, 4
; # (val (big X))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (cnt? (setq X (val (big X))))
  %28 = and i64 %27, 2
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$12, label %$11
$11:
  %30 = phi i64 [%27, %$10] ; # X
  %31 = phi i64 [%21, %$10] ; # C
; # (inc 'C 8)
  %32 = add i64 %31, 8
  br label %$10
$12:
  %33 = phi i64 [%27, %$10] ; # X
  %34 = phi i64 [%21, %$10] ; # C
  %35 = phi i64 [0, %$10] ; # ->
; # (int X)
  %36 = lshr i64 %33, 4
; # (add D D)
  %37 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %24, i64 %24)
  %38 = extractvalue {i64, i1} %37, 1
  %39 = extractvalue {i64, i1} %37, 0
; # (+ X X @@)
  %40 = add i64 %36, %36
  %41 = zext i1 %38 to i64
  %42 = add i64 %40, %41
; # (: 2 (when X (loop (inc 'C) (? (=0 (setq X (shr X 8)))))) (if (>=...
  br label %$-2
$-2:
  %43 = phi i64 [%42, %$12], [%112, %$35] ; # X
  %44 = phi i64 [%34, %$12], [%111, %$35] ; # C
; # (when X (loop (inc 'C) (? (=0 (setq X (shr X 8))))))
  %45 = icmp ne i64 %43, 0
  br i1 %45, label %$13, label %$14
$13:
  %46 = phi i64 [%43, %$-2] ; # X
  %47 = phi i64 [%44, %$-2] ; # C
; # (loop (inc 'C) (? (=0 (setq X (shr X 8)))))
  br label %$15
$15:
  %48 = phi i64 [%46, %$13], [%53, %$16] ; # X
  %49 = phi i64 [%47, %$13], [%54, %$16] ; # C
; # (inc 'C)
  %50 = add i64 %49, 1
; # (? (=0 (setq X (shr X 8))))
; # (shr X 8)
  %51 = lshr i64 %48, 8
; # (=0 (setq X (shr X 8)))
  %52 = icmp eq i64 %51, 0
  br i1 %52, label %$17, label %$16
$16:
  %53 = phi i64 [%51, %$15] ; # X
  %54 = phi i64 [%50, %$15] ; # C
  br label %$15
$17:
  %55 = phi i64 [%51, %$15] ; # X
  %56 = phi i64 [%50, %$15] ; # C
  %57 = phi i64 [0, %$15] ; # ->
  br label %$14
$14:
  %58 = phi i64 [%43, %$-2], [%55, %$17] ; # X
  %59 = phi i64 [%44, %$-2], [%56, %$17] ; # C
; # (if (>= C (+ 63 1)) (+ C (/ (- C 64) 255) 1) C)
; # (+ 63 1)
; # (>= C (+ 63 1))
  %60 = icmp uge i64 %59, 64
  br i1 %60, label %$18, label %$19
$18:
  %61 = phi i64 [%58, %$14] ; # X
  %62 = phi i64 [%59, %$14] ; # C
; # (- C 64)
  %63 = sub i64 %62, 64
; # (/ (- C 64) 255)
  %64 = udiv i64 %63, 255
; # (+ C (/ (- C 64) 255) 1)
  %65 = add i64 %62, %64
  %66 = add i64 %65, 1
  br label %$20
$19:
  %67 = phi i64 [%58, %$14] ; # X
  %68 = phi i64 [%59, %$14] ; # C
  br label %$20
$20:
  %69 = phi i64 [%61, %$18], [%67, %$19] ; # X
  %70 = phi i64 [%62, %$18], [%68, %$19] ; # C
  %71 = phi i64 [%66, %$18], [%68, %$19] ; # ->
  br label %$2
$8:
  %72 = phi i64 [%15, %$3] ; # X
; # (sym? X)
  %73 = and i64 %72, 8
  %74 = icmp ne i64 %73, 0
  br i1 %74, label %$22, label %$21
$22:
  %75 = phi i64 [%72, %$8] ; # X
; # (cond ((nil? X) 1) ((== (name (& (val (tail X)) -9)) ZERO) 1) ((c...
; # (nil? X)
  %76 = icmp eq i64 %75, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %76, label %$25, label %$24
$25:
  %77 = phi i64 [%75, %$22] ; # X
  br label %$23
$24:
  %78 = phi i64 [%75, %$22] ; # X
; # (tail X)
  %79 = add i64 %78, -8
; # (val (tail X))
  %80 = inttoptr i64 %79 to i64*
  %81 = load i64, i64* %80
; # (& (val (tail X)) -9)
  %82 = and i64 %81, -9
; # (name (& (val (tail X)) -9))
  br label %$26
$26:
  %83 = phi i64 [%82, %$24], [%89, %$27] ; # Tail
  %84 = and i64 %83, 6
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$28, label %$27
$27:
  %86 = phi i64 [%83, %$26] ; # Tail
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  %89 = load i64, i64* %88
  br label %$26
$28:
  %90 = phi i64 [%83, %$26] ; # Tail
; # (== (name (& (val (tail X)) -9)) ZERO)
  %91 = icmp eq i64 %90, 2
  br i1 %91, label %$30, label %$29
$30:
  %92 = phi i64 [%78, %$28] ; # X
  br label %$23
$29:
  %93 = phi i64 [%78, %$28] ; # X
; # (cnt? @)
  %94 = and i64 %90, 2
  %95 = icmp ne i64 %94, 0
  br i1 %95, label %$32, label %$31
$32:
  %96 = phi i64 [%93, %$29] ; # X
; # (shl @ 2)
  %97 = shl i64 %90, 2
; # (shr (shl @ 2) 6)
  %98 = lshr i64 %97, 6
; # (goto 1)
  br label %$-1
$31:
  %99 = phi i64 [%93, %$29] ; # X
; # (let C 9 (until (cnt? (setq X (val (big X)))) (inc 'C 8)) (setq X...
; # (until (cnt? (setq X (val (big X)))) (inc 'C 8))
  br label %$33
$33:
  %100 = phi i64 [%99, %$31], [%107, %$34] ; # X
  %101 = phi i64 [9, %$31], [%109, %$34] ; # C
; # (big X)
  %102 = add i64 %100, 4
; # (val (big X))
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
; # (cnt? (setq X (val (big X))))
  %105 = and i64 %104, 2
  %106 = icmp ne i64 %105, 0
  br i1 %106, label %$35, label %$34
$34:
  %107 = phi i64 [%104, %$33] ; # X
  %108 = phi i64 [%101, %$33] ; # C
; # (inc 'C 8)
  %109 = add i64 %108, 8
  br label %$33
$35:
  %110 = phi i64 [%104, %$33] ; # X
  %111 = phi i64 [%101, %$33] ; # C
; # (int X)
  %112 = lshr i64 %110, 4
; # (goto 2)
  br label %$-2
$23:
  %113 = phi i64 [%77, %$25], [%92, %$30] ; # X
  %114 = phi i64 [1, %$25], [1, %$30] ; # ->
  br label %$2
$21:
  %115 = phi i64 [%72, %$8] ; # X
; # (let (C 2 Y X) (loop (inc 'C (binSize (++ X))) (? (nil? X) C) (? ...
; # (loop (inc 'C (binSize (++ X))) (? (nil? X) C) (? (== Y X) (inc C...
  br label %$36
$36:
  %116 = phi i64 [%115, %$21], [%141, %$42] ; # X
  %117 = phi i64 [2, %$21], [%142, %$42] ; # C
; # (++ X)
  %118 = inttoptr i64 %116 to i64*
  %119 = load i64, i64* %118
  %120 = getelementptr i64, i64* %118, i32 1
  %121 = load i64, i64* %120
; # (binSize (++ X))
  %122 = call i64 @binSize(i64 %119)
; # (inc 'C (binSize (++ X)))
  %123 = add i64 %117, %122
; # (? (nil? X) C)
; # (nil? X)
  %124 = icmp eq i64 %121, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %124, label %$39, label %$37
$39:
  %125 = phi i64 [%121, %$36] ; # X
  %126 = phi i64 [%123, %$36] ; # C
  br label %$38
$37:
  %127 = phi i64 [%121, %$36] ; # X
  %128 = phi i64 [%123, %$36] ; # C
; # (? (== Y X) (inc C))
; # (== Y X)
  %129 = icmp eq i64 %115, %127
  br i1 %129, label %$41, label %$40
$41:
  %130 = phi i64 [%127, %$37] ; # X
  %131 = phi i64 [%128, %$37] ; # C
; # (inc C)
  %132 = add i64 %131, 1
  br label %$38
$40:
  %133 = phi i64 [%127, %$37] ; # X
  %134 = phi i64 [%128, %$37] ; # C
; # (? (atom X) (+ C (binSize X)))
; # (atom X)
  %135 = and i64 %133, 15
  %136 = icmp ne i64 %135, 0
  br i1 %136, label %$43, label %$42
$43:
  %137 = phi i64 [%133, %$40] ; # X
  %138 = phi i64 [%134, %$40] ; # C
; # (binSize X)
  %139 = call i64 @binSize(i64 %137)
; # (+ C (binSize X))
  %140 = add i64 %138, %139
  br label %$38
$42:
  %141 = phi i64 [%133, %$40] ; # X
  %142 = phi i64 [%134, %$40] ; # C
  br label %$36
$38:
  %143 = phi i64 [%125, %$39], [%130, %$41], [%137, %$43] ; # X
  %144 = phi i64 [%126, %$39], [%131, %$41], [%138, %$43] ; # C
  %145 = phi i64 [%126, %$39], [%132, %$41], [%140, %$43] ; # ->
  br label %$2
$2:
  %146 = phi i64 [%13, %$7], [%69, %$20], [%113, %$23], [%143, %$38] ; # X
  %147 = phi i64 [%14, %$7], [%71, %$20], [%114, %$23], [%145, %$38] ; # ->
  ret i64 %147
}

define i64 @_size(i64) {
$1:
; # (let X (eval (cadr Exe)) (cond ((cnt? X) (setq X (shr X 3)) (let ...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((cnt? X) (setq X (shr X 3)) (let C ONE (while (setq X (shr...
; # (cnt? X)
  %14 = and i64 %13, 2
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
  %16 = phi i64 [%13, %$2] ; # X
; # (shr X 3)
  %17 = lshr i64 %16, 3
; # (let C ONE (while (setq X (shr X 8)) (inc 'C (hex "10"))) C)
; # (while (setq X (shr X 8)) (inc 'C (hex "10")))
  br label %$10
$10:
  %18 = phi i64 [%17, %$9], [%22, %$11] ; # X
  %19 = phi i64 [18, %$9], [%24, %$11] ; # C
; # (shr X 8)
  %20 = lshr i64 %18, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$11, label %$12
$11:
  %22 = phi i64 [%20, %$10] ; # X
  %23 = phi i64 [%19, %$10] ; # C
; # (inc 'C (hex "10"))
  %24 = add i64 %23, 16
  br label %$10
$12:
  %25 = phi i64 [%20, %$10] ; # X
  %26 = phi i64 [%19, %$10] ; # C
  br label %$7
$8:
  %27 = phi i64 [%13, %$2] ; # X
; # (big? X)
  %28 = and i64 %27, 4
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$14, label %$13
$14:
  %30 = phi i64 [%27, %$8] ; # X
; # (pos X)
  %31 = and i64 %30, -9
; # (let (C (hex "82") D T) (loop (setq D (val (dig X))) (? (cnt? (se...
; # (loop (setq D (val (dig X))) (? (cnt? (setq X (val (big X))))) (i...
  br label %$15
$15:
  %32 = phi i64 [%31, %$14], [%42, %$16] ; # X
  %33 = phi i64 [130, %$14], [%45, %$16] ; # C
; # (dig X)
  %34 = add i64 %32, -4
; # (val (dig X))
  %35 = inttoptr i64 %34 to i64*
  %36 = load i64, i64* %35
; # (? (cnt? (setq X (val (big X)))))
; # (big X)
  %37 = add i64 %32, 4
; # (val (big X))
  %38 = inttoptr i64 %37 to i64*
  %39 = load i64, i64* %38
; # (cnt? (setq X (val (big X))))
  %40 = and i64 %39, 2
  %41 = icmp ne i64 %40, 0
  br i1 %41, label %$17, label %$16
$16:
  %42 = phi i64 [%39, %$15] ; # X
  %43 = phi i64 [%33, %$15] ; # C
  %44 = phi i64 [%36, %$15] ; # D
; # (inc 'C (hex "80"))
  %45 = add i64 %43, 128
  br label %$15
$17:
  %46 = phi i64 [%39, %$15] ; # X
  %47 = phi i64 [%33, %$15] ; # C
  %48 = phi i64 [%36, %$15] ; # D
  %49 = phi i64 [0, %$15] ; # ->
; # (int X)
  %50 = lshr i64 %46, 4
; # (add D D)
  %51 = call {i64, i1} @llvm.uadd.with.overflow.i64(i64 %48, i64 %48)
  %52 = extractvalue {i64, i1} %51, 1
  %53 = extractvalue {i64, i1} %51, 0
; # (when (setq X (+ X X @@)) (loop (inc 'C (hex "10")) (? (=0 (setq ...
; # (+ X X @@)
  %54 = add i64 %50, %50
  %55 = zext i1 %52 to i64
  %56 = add i64 %54, %55
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %$18, label %$19
$18:
  %58 = phi i64 [%56, %$17] ; # X
  %59 = phi i64 [%47, %$17] ; # C
  %60 = phi i64 [%48, %$17] ; # D
; # (loop (inc 'C (hex "10")) (? (=0 (setq X (shr X 8)))))
  br label %$20
$20:
  %61 = phi i64 [%58, %$18], [%67, %$21] ; # X
  %62 = phi i64 [%59, %$18], [%68, %$21] ; # C
  %63 = phi i64 [%60, %$18], [%69, %$21] ; # D
; # (inc 'C (hex "10"))
  %64 = add i64 %62, 16
; # (? (=0 (setq X (shr X 8))))
; # (shr X 8)
  %65 = lshr i64 %61, 8
; # (=0 (setq X (shr X 8)))
  %66 = icmp eq i64 %65, 0
  br i1 %66, label %$22, label %$21
$21:
  %67 = phi i64 [%65, %$20] ; # X
  %68 = phi i64 [%64, %$20] ; # C
  %69 = phi i64 [%63, %$20] ; # D
  br label %$20
$22:
  %70 = phi i64 [%65, %$20] ; # X
  %71 = phi i64 [%64, %$20] ; # C
  %72 = phi i64 [%63, %$20] ; # D
  %73 = phi i64 [0, %$20] ; # ->
  br label %$19
$19:
  %74 = phi i64 [%56, %$17], [%70, %$22] ; # X
  %75 = phi i64 [%47, %$17], [%71, %$22] ; # C
  %76 = phi i64 [%48, %$17], [%72, %$22] ; # D
  br label %$7
$13:
  %77 = phi i64 [%27, %$8] ; # X
; # (pair X)
  %78 = and i64 %77, 15
  %79 = icmp eq i64 %78, 0
  br i1 %79, label %$24, label %$23
$24:
  %80 = phi i64 [%77, %$13] ; # X
; # (size X)
  %81 = call i64 @size(i64 %80)
; # (cnt (size X))
  %82 = shl i64 %81, 4
  %83 = or i64 %82, 2
  br label %$7
$23:
  %84 = phi i64 [%77, %$13] ; # X
; # (nil? X)
  %85 = icmp eq i64 %84, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %85, label %$26, label %$25
$26:
  %86 = phi i64 [%84, %$23] ; # X
  br label %$7
$25:
  %87 = phi i64 [%84, %$23] ; # X
; # (tail X)
  %88 = add i64 %87, -8
; # (val (tail X))
  %89 = inttoptr i64 %88 to i64*
  %90 = load i64, i64* %89
; # (sym? (val (tail X)))
  %91 = and i64 %90, 8
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$28, label %$27
$28:
  %93 = phi i64 [%87, %$25] ; # X
; # (let Y (& @ -9) (dbFetch Exe X) (let C (+ (binSize (val X)) (inc ...
; # (& @ -9)
  %94 = and i64 %90, -9
; # (dbFetch Exe X)
  call void @dbFetch(i64 %0, i64 %93)
; # (let C (+ (binSize (val X)) (inc BLK)) (while (pair Y) (let Z (++...
; # (val X)
  %95 = inttoptr i64 %93 to i64*
  %96 = load i64, i64* %95
; # (binSize (val X))
  %97 = call i64 @binSize(i64 %96)
; # (inc BLK)
; # (+ (binSize (val X)) (inc BLK))
  %98 = add i64 %97, 7
; # (while (pair Y) (let Z (++ Y) (setq C (+ C (if (atom Z) (+ (binSi...
  br label %$29
$29:
  %99 = phi i64 [%93, %$28], [%129, %$34] ; # X
  %100 = phi i64 [%94, %$28], [%130, %$34] ; # Y
  %101 = phi i64 [%98, %$28], [%133, %$34] ; # C
; # (pair Y)
  %102 = and i64 %100, 15
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %$30, label %$31
$30:
  %104 = phi i64 [%99, %$29] ; # X
  %105 = phi i64 [%100, %$29] ; # Y
  %106 = phi i64 [%101, %$29] ; # C
; # (let Z (++ Y) (setq C (+ C (if (atom Z) (+ (binSize Z) 2) (+ (bin...
; # (++ Y)
  %107 = inttoptr i64 %105 to i64*
  %108 = load i64, i64* %107
  %109 = getelementptr i64, i64* %107, i32 1
  %110 = load i64, i64* %109
; # (if (atom Z) (+ (binSize Z) 2) (+ (binSize (car Z)) (binSize (cdr...
; # (atom Z)
  %111 = and i64 %108, 15
  %112 = icmp ne i64 %111, 0
  br i1 %112, label %$32, label %$33
$32:
  %113 = phi i64 [%104, %$30] ; # X
  %114 = phi i64 [%110, %$30] ; # Y
  %115 = phi i64 [%106, %$30] ; # C
; # (binSize Z)
  %116 = call i64 @binSize(i64 %108)
; # (+ (binSize Z) 2)
  %117 = add i64 %116, 2
  br label %$34
$33:
  %118 = phi i64 [%104, %$30] ; # X
  %119 = phi i64 [%110, %$30] ; # Y
  %120 = phi i64 [%106, %$30] ; # C
; # (car Z)
  %121 = inttoptr i64 %108 to i64*
  %122 = load i64, i64* %121
; # (binSize (car Z))
  %123 = call i64 @binSize(i64 %122)
; # (cdr Z)
  %124 = inttoptr i64 %108 to i64*
  %125 = getelementptr i64, i64* %124, i32 1
  %126 = load i64, i64* %125
; # (binSize (cdr Z))
  %127 = call i64 @binSize(i64 %126)
; # (+ (binSize (car Z)) (binSize (cdr Z)))
  %128 = add i64 %123, %127
  br label %$34
$34:
  %129 = phi i64 [%113, %$32], [%118, %$33] ; # X
  %130 = phi i64 [%114, %$32], [%119, %$33] ; # Y
  %131 = phi i64 [%115, %$32], [%120, %$33] ; # C
  %132 = phi i64 [%117, %$32], [%128, %$33] ; # ->
; # (+ C (if (atom Z) (+ (binSize Z) 2) (+ (binSize (car Z)) (binSize...
  %133 = add i64 %106, %132
  br label %$29
$31:
  %134 = phi i64 [%99, %$29] ; # X
  %135 = phi i64 [%100, %$29] ; # Y
  %136 = phi i64 [%101, %$29] ; # C
; # (cnt C)
  %137 = shl i64 %136, 4
  %138 = or i64 %137, 2
  br label %$7
$27:
  %139 = phi i64 [%87, %$25] ; # X
; # (name @)
  br label %$35
$35:
  %140 = phi i64 [%90, %$27], [%146, %$36] ; # Tail
  %141 = and i64 %140, 6
  %142 = icmp ne i64 %141, 0
  br i1 %142, label %$37, label %$36
$36:
  %143 = phi i64 [%140, %$35] ; # Tail
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
  br label %$35
$37:
  %147 = phi i64 [%140, %$35] ; # Tail
; # (== (name @) ZERO)
  %148 = icmp eq i64 %147, 2
  br i1 %148, label %$39, label %$38
$39:
  %149 = phi i64 [%139, %$37] ; # X
  br label %$7
$38:
  %150 = phi i64 [%139, %$37] ; # X
; # (cnt? @)
  %151 = and i64 %147, 2
  %152 = icmp ne i64 %151, 0
  br i1 %152, label %$41, label %$40
$41:
  %153 = phi i64 [%150, %$38] ; # X
; # (let (C ONE Z (int @)) (while (setq Z (shr Z 8)) (inc 'C (hex "10...
; # (int @)
  %154 = lshr i64 %147, 4
; # (while (setq Z (shr Z 8)) (inc 'C (hex "10")))
  br label %$42
$42:
  %155 = phi i64 [%153, %$41], [%160, %$43] ; # X
  %156 = phi i64 [18, %$41], [%163, %$43] ; # C
  %157 = phi i64 [%154, %$41], [%162, %$43] ; # Z
; # (shr Z 8)
  %158 = lshr i64 %157, 8
  %159 = icmp ne i64 %158, 0
  br i1 %159, label %$43, label %$44
$43:
  %160 = phi i64 [%155, %$42] ; # X
  %161 = phi i64 [%156, %$42] ; # C
  %162 = phi i64 [%158, %$42] ; # Z
; # (inc 'C (hex "10"))
  %163 = add i64 %161, 16
  br label %$42
$44:
  %164 = phi i64 [%155, %$42] ; # X
  %165 = phi i64 [%156, %$42] ; # C
  %166 = phi i64 [%158, %$42] ; # Z
  br label %$7
$40:
  %167 = phi i64 [%150, %$38] ; # X
; # (let (C (hex "82") Z @) (until (cnt? (setq Z (val (big Z)))) (inc...
; # (until (cnt? (setq Z (val (big Z)))) (inc 'C (hex "80")))
  br label %$45
$45:
  %168 = phi i64 [%167, %$40], [%176, %$46] ; # X
  %169 = phi i64 [130, %$40], [%179, %$46] ; # C
  %170 = phi i64 [%147, %$40], [%178, %$46] ; # Z
; # (big Z)
  %171 = add i64 %170, 4
; # (val (big Z))
  %172 = inttoptr i64 %171 to i64*
  %173 = load i64, i64* %172
; # (cnt? (setq Z (val (big Z))))
  %174 = and i64 %173, 2
  %175 = icmp ne i64 %174, 0
  br i1 %175, label %$47, label %$46
$46:
  %176 = phi i64 [%168, %$45] ; # X
  %177 = phi i64 [%169, %$45] ; # C
  %178 = phi i64 [%173, %$45] ; # Z
; # (inc 'C (hex "80"))
  %179 = add i64 %177, 128
  br label %$45
$47:
  %180 = phi i64 [%168, %$45] ; # X
  %181 = phi i64 [%169, %$45] ; # C
  %182 = phi i64 [%173, %$45] ; # Z
; # (when (setq Z (int Z)) (loop (inc 'C (hex "10")) (? (=0 (setq Z (...
; # (int Z)
  %183 = lshr i64 %182, 4
  %184 = icmp ne i64 %183, 0
  br i1 %184, label %$48, label %$49
$48:
  %185 = phi i64 [%180, %$47] ; # X
  %186 = phi i64 [%181, %$47] ; # C
  %187 = phi i64 [%183, %$47] ; # Z
; # (loop (inc 'C (hex "10")) (? (=0 (setq Z (shr Z 8)))))
  br label %$50
$50:
  %188 = phi i64 [%185, %$48], [%194, %$51] ; # X
  %189 = phi i64 [%186, %$48], [%195, %$51] ; # C
  %190 = phi i64 [%187, %$48], [%196, %$51] ; # Z
; # (inc 'C (hex "10"))
  %191 = add i64 %189, 16
; # (? (=0 (setq Z (shr Z 8))))
; # (shr Z 8)
  %192 = lshr i64 %190, 8
; # (=0 (setq Z (shr Z 8)))
  %193 = icmp eq i64 %192, 0
  br i1 %193, label %$52, label %$51
$51:
  %194 = phi i64 [%188, %$50] ; # X
  %195 = phi i64 [%191, %$50] ; # C
  %196 = phi i64 [%192, %$50] ; # Z
  br label %$50
$52:
  %197 = phi i64 [%188, %$50] ; # X
  %198 = phi i64 [%191, %$50] ; # C
  %199 = phi i64 [%192, %$50] ; # Z
  %200 = phi i64 [0, %$50] ; # ->
  br label %$49
$49:
  %201 = phi i64 [%180, %$47], [%197, %$52] ; # X
  %202 = phi i64 [%181, %$47], [%198, %$52] ; # C
  %203 = phi i64 [%183, %$47], [%199, %$52] ; # Z
  br label %$7
$7:
  %204 = phi i64 [%25, %$12], [%74, %$19], [%80, %$24], [%86, %$26], [%134, %$31], [%149, %$39], [%164, %$44], [%201, %$49] ; # X
  %205 = phi i64 [%26, %$12], [%75, %$19], [%83, %$24], [2, %$26], [%138, %$31], [%147, %$39], [%165, %$44], [%202, %$49] ; # ->
  ret i64 %205
}

define i64 @_bytes(i64) {
$1:
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (binSize (eval (cadr Exe)))
  %14 = call i64 @binSize(i64 %13)
; # (cnt (binSize (eval (cadr Exe))))
  %15 = shl i64 %14, 4
  %16 = or i64 %15, 2
  ret i64 %16
}

define i64 @_assoc(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (loop ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (let C (car Z) (? (and (pair C) (equal Y ...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%53, %$18] ; # Z
; # (? (atom Z) $Nil)
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
  br label %$14
$13:
  %38 = phi i64 [%34, %$12] ; # Z
; # (let C (car Z) (? (and (pair C) (equal Y (car C))) C))
; # (car Z)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (? (and (pair C) (equal Y (car C))) C)
; # (and (pair C) (equal Y (car C)))
; # (pair C)
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%38, %$13] ; # Z
; # (car C)
  %44 = inttoptr i64 %40 to i64*
  %45 = load i64, i64* %44
; # (equal Y (car C))
  %46 = call i1 @equal(i64 %15, i64 %45)
  br label %$16
$16:
  %47 = phi i64 [%38, %$13], [%43, %$17] ; # Z
  %48 = phi i1 [0, %$13], [%46, %$17] ; # ->
  br i1 %48, label %$19, label %$18
$19:
  %49 = phi i64 [%47, %$16] ; # Z
  br label %$14
$18:
  %50 = phi i64 [%47, %$16] ; # Z
; # (shift Z)
  %51 = inttoptr i64 %50 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  br label %$12
$14:
  %54 = phi i64 [%37, %$15], [%49, %$19] ; # Z
  %55 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%40, %$19] ; # ->
; # (drop *Safe)
  %56 = inttoptr i64 %17 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %55
}

define i64 @_rassoc(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (loop ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (let C (car Z) (? (and (pair C) (equal Y ...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%54, %$18] ; # Z
; # (? (atom Z) $Nil)
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
  br label %$14
$13:
  %38 = phi i64 [%34, %$12] ; # Z
; # (let C (car Z) (? (and (pair C) (equal Y (cdr C))) C))
; # (car Z)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (? (and (pair C) (equal Y (cdr C))) C)
; # (and (pair C) (equal Y (cdr C)))
; # (pair C)
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%38, %$13] ; # Z
; # (cdr C)
  %44 = inttoptr i64 %40 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
; # (equal Y (cdr C))
  %47 = call i1 @equal(i64 %15, i64 %46)
  br label %$16
$16:
  %48 = phi i64 [%38, %$13], [%43, %$17] ; # Z
  %49 = phi i1 [0, %$13], [%47, %$17] ; # ->
  br i1 %49, label %$19, label %$18
$19:
  %50 = phi i64 [%48, %$16] ; # Z
  br label %$14
$18:
  %51 = phi i64 [%48, %$16] ; # Z
; # (shift Z)
  %52 = inttoptr i64 %51 to i64*
  %53 = getelementptr i64, i64* %52, i32 1
  %54 = load i64, i64* %53
  br label %$12
$14:
  %55 = phi i64 [%37, %$15], [%50, %$19] ; # Z
  %56 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%40, %$19] ; # ->
; # (drop *Safe)
  %57 = inttoptr i64 %17 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  %59 = load i64, i64* %58
  %60 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %59, i64* %60
  ret i64 %56
}

define i64 @_asoq(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (eval (car X))) (loop ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (loop (? (atom Z) $Nil) (let C (car Z) (? (and (pair C) (== Y (ca...
  br label %$12
$12:
  %34 = phi i64 [%33, %$7], [%53, %$18] ; # Z
; # (? (atom Z) $Nil)
; # (atom Z)
  %35 = and i64 %34, 15
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %$15, label %$13
$15:
  %37 = phi i64 [%34, %$12] ; # Z
  br label %$14
$13:
  %38 = phi i64 [%34, %$12] ; # Z
; # (let C (car Z) (? (and (pair C) (== Y (car C))) C))
; # (car Z)
  %39 = inttoptr i64 %38 to i64*
  %40 = load i64, i64* %39
; # (? (and (pair C) (== Y (car C))) C)
; # (and (pair C) (== Y (car C)))
; # (pair C)
  %41 = and i64 %40, 15
  %42 = icmp eq i64 %41, 0
  br i1 %42, label %$17, label %$16
$17:
  %43 = phi i64 [%38, %$13] ; # Z
; # (car C)
  %44 = inttoptr i64 %40 to i64*
  %45 = load i64, i64* %44
; # (== Y (car C))
  %46 = icmp eq i64 %15, %45
  br label %$16
$16:
  %47 = phi i64 [%38, %$13], [%43, %$17] ; # Z
  %48 = phi i1 [0, %$13], [%46, %$17] ; # ->
  br i1 %48, label %$19, label %$18
$19:
  %49 = phi i64 [%47, %$16] ; # Z
  br label %$14
$18:
  %50 = phi i64 [%47, %$16] ; # Z
; # (shift Z)
  %51 = inttoptr i64 %50 to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
  br label %$12
$14:
  %54 = phi i64 [%37, %$15], [%49, %$19] ; # Z
  %55 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%40, %$19] ; # ->
; # (drop *Safe)
  %56 = inttoptr i64 %17 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  %59 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %58, i64* %59
  ret i64 %55
}

define i64 @_rank(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X))) Z (save (eval (++ X))) R...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (save (eval (++ X)))
  %36 = alloca i64, i64 2, align 16
  %37 = ptrtoint i64* %36 to i64
  %38 = inttoptr i64 %37 to i64*
  store i64 %35, i64* %38
  %39 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %40 = load i64, i64* %39
  %41 = inttoptr i64 %37 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  store i64 %40, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %43
; # (if (nil? (eval (car X))) (until (gt0 (compare (caar Z) Y)) (setq...
; # (car X)
  %44 = inttoptr i64 %27 to i64*
  %45 = load i64, i64* %44
; # (eval (car X))
  %46 = and i64 %45, 6
  %47 = icmp ne i64 %46, 0
  br i1 %47, label %$14, label %$13
$14:
  br label %$12
$13:
  %48 = and i64 %45, 8
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$16, label %$15
$16:
  %50 = inttoptr i64 %45 to i64*
  %51 = load i64, i64* %50
  br label %$12
$15:
  %52 = call i64 @evList(i64 %45)
  br label %$12
$12:
  %53 = phi i64 [%45, %$14], [%51, %$16], [%52, %$15] ; # ->
; # (nil? (eval (car X)))
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %54, label %$17, label %$18
$17:
  %55 = phi i64 [%35, %$12] ; # Z
  %56 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # R
; # (until (gt0 (compare (caar Z) Y)) (setq R Z) (? (atom (shift Z)))...
  br label %$20
$20:
  %57 = phi i64 [%55, %$17], [%72, %$23] ; # Z
  %58 = phi i64 [%56, %$17], [%73, %$23] ; # R
; # (caar Z)
  %59 = inttoptr i64 %57 to i64*
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
; # (compare (caar Z) Y)
  %63 = call i64 @compare(i64 %62, i64 %15)
; # (gt0 (compare (caar Z) Y))
  %64 = icmp sgt i64 %63, 0
  br i1 %64, label %$22, label %$21
$21:
  %65 = phi i64 [%57, %$20] ; # Z
  %66 = phi i64 [%58, %$20] ; # R
; # (? (atom (shift Z)))
; # (shift Z)
  %67 = inttoptr i64 %65 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
; # (atom (shift Z))
  %70 = and i64 %69, 15
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$22, label %$23
$23:
  %72 = phi i64 [%69, %$21] ; # Z
  %73 = phi i64 [%65, %$21] ; # R
  br label %$20
$22:
  %74 = phi i64 [%57, %$20], [%69, %$21] ; # Z
  %75 = phi i64 [%58, %$20], [%65, %$21] ; # R
  br label %$19
$18:
  %76 = phi i64 [%35, %$12] ; # Z
  %77 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$12] ; # R
; # (until (lt0 (compare (caar Z) Y)) (setq R Z) (? (atom (shift Z)))...
  br label %$24
$24:
  %78 = phi i64 [%76, %$18], [%93, %$27] ; # Z
  %79 = phi i64 [%77, %$18], [%94, %$27] ; # R
; # (caar Z)
  %80 = inttoptr i64 %78 to i64*
  %81 = load i64, i64* %80
  %82 = inttoptr i64 %81 to i64*
  %83 = load i64, i64* %82
; # (compare (caar Z) Y)
  %84 = call i64 @compare(i64 %83, i64 %15)
; # (lt0 (compare (caar Z) Y))
  %85 = icmp slt i64 %84, 0
  br i1 %85, label %$26, label %$25
$25:
  %86 = phi i64 [%78, %$24] ; # Z
  %87 = phi i64 [%79, %$24] ; # R
; # (? (atom (shift Z)))
; # (shift Z)
  %88 = inttoptr i64 %86 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
; # (atom (shift Z))
  %91 = and i64 %90, 15
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$26, label %$27
$27:
  %93 = phi i64 [%90, %$25] ; # Z
  %94 = phi i64 [%86, %$25] ; # R
  br label %$24
$26:
  %95 = phi i64 [%78, %$24], [%90, %$25] ; # Z
  %96 = phi i64 [%79, %$24], [%86, %$25] ; # R
  br label %$19
$19:
  %97 = phi i64 [%74, %$22], [%95, %$26] ; # Z
  %98 = phi i64 [%75, %$22], [%96, %$26] ; # R
; # (car R)
  %99 = inttoptr i64 %98 to i64*
  %100 = load i64, i64* %99
; # (drop *Safe)
  %101 = inttoptr i64 %17 to i64*
  %102 = getelementptr i64, i64* %101, i32 1
  %103 = load i64, i64* %102
  %104 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %103, i64* %104
  ret i64 %100
}

define i1 @match(i64, i64) {
$1:
; # (loop (? (atom Pat) (if (or (num? Pat) (<> (firstByte Pat) (char ...
  br label %$2
$2:
  %2 = phi i64 [%0, %$1], [%118, %$29] ; # Pat
  %3 = phi i64 [%1, %$1], [%121, %$29] ; # Dat
; # (? (atom Pat) (if (or (num? Pat) (<> (firstByte Pat) (char "@")))...
; # (atom Pat)
  %4 = and i64 %2, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$5, label %$3
$5:
  %6 = phi i64 [%2, %$2] ; # Pat
  %7 = phi i64 [%3, %$2] ; # Dat
; # (if (or (num? Pat) (<> (firstByte Pat) (char "@"))) (equal Pat Da...
; # (or (num? Pat) (<> (firstByte Pat) (char "@")))
; # (num? Pat)
  %8 = and i64 %6, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$7
$7:
  %10 = phi i64 [%6, %$5] ; # Pat
  %11 = phi i64 [%7, %$5] ; # Dat
; # (firstByte Pat)
  %12 = call i8 @firstByte(i64 %10)
; # (<> (firstByte Pat) (char "@"))
  %13 = icmp ne i8 %12, 64
  br label %$6
$6:
  %14 = phi i64 [%6, %$5], [%10, %$7] ; # Pat
  %15 = phi i64 [%7, %$5], [%11, %$7] ; # Dat
  %16 = phi i1 [1, %$5], [%13, %$7] ; # ->
  br i1 %16, label %$8, label %$9
$8:
  %17 = phi i64 [%14, %$6] ; # Pat
  %18 = phi i64 [%15, %$6] ; # Dat
; # (equal Pat Dat)
  %19 = call i1 @equal(i64 %17, i64 %18)
  br label %$10
$9:
  %20 = phi i64 [%14, %$6] ; # Pat
  %21 = phi i64 [%15, %$6] ; # Dat
; # (set Pat Dat)
  %22 = inttoptr i64 %20 to i64*
  store i64 %21, i64* %22
  br label %$10
$10:
  %23 = phi i64 [%17, %$8], [%20, %$9] ; # Pat
  %24 = phi i64 [%18, %$8], [%21, %$9] ; # Dat
  %25 = phi i1 [%19, %$8], [1, %$9] ; # ->
  br label %$4
$3:
  %26 = phi i64 [%2, %$2] ; # Pat
  %27 = phi i64 [%3, %$2] ; # Dat
; # (stkChk 0)
  %28 = load i8*, i8** @$StkLimit
  %29 = call i8* @llvm.stacksave()
  %30 = icmp ugt i8* %28, %29
  br i1 %30, label %$11, label %$12
$11:
  call void @stkErr(i64 0)
  unreachable
$12:
; # (let X (car Pat) (when (and (symb? X) (== (firstByte X) (char "@"...
; # (car Pat)
  %31 = inttoptr i64 %26 to i64*
  %32 = load i64, i64* %31
; # (when (and (symb? X) (== (firstByte X) (char "@"))) (? (atom Dat)...
; # (and (symb? X) (== (firstByte X) (char "@")))
; # (symb? X)
  %33 = xor i64 %32, 8
  %34 = and i64 %33, 14
  %35 = icmp eq i64 %34, 0
  br i1 %35, label %$14, label %$13
$14:
  %36 = phi i64 [%26, %$12] ; # Pat
  %37 = phi i64 [%27, %$12] ; # Dat
; # (firstByte X)
  %38 = call i8 @firstByte(i64 %32)
; # (== (firstByte X) (char "@"))
  %39 = icmp eq i8 %38, 64
  br label %$13
$13:
  %40 = phi i64 [%26, %$12], [%36, %$14] ; # Pat
  %41 = phi i64 [%27, %$12], [%37, %$14] ; # Dat
  %42 = phi i1 [0, %$12], [%39, %$14] ; # ->
  br i1 %42, label %$15, label %$16
$15:
  %43 = phi i64 [%40, %$13] ; # Pat
  %44 = phi i64 [%41, %$13] ; # Dat
; # (? (atom Dat) (and (equal (cdr Pat) Dat) (prog (set X $Nil) YES))...
; # (atom Dat)
  %45 = and i64 %44, 15
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$18, label %$17
$18:
  %47 = phi i64 [%43, %$15] ; # Pat
  %48 = phi i64 [%44, %$15] ; # Dat
; # (and (equal (cdr Pat) Dat) (prog (set X $Nil) YES))
; # (cdr Pat)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (equal (cdr Pat) Dat)
  %52 = call i1 @equal(i64 %51, i64 %48)
  br i1 %52, label %$20, label %$19
$20:
  %53 = phi i64 [%47, %$18] ; # Pat
  %54 = phi i64 [%48, %$18] ; # Dat
; # (set X $Nil)
  %55 = inttoptr i64 %32 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %55
  br label %$19
$19:
  %56 = phi i64 [%47, %$18], [%53, %$20] ; # Pat
  %57 = phi i64 [%48, %$18], [%54, %$20] ; # Dat
  %58 = phi i1 [0, %$18], [1, %$20] ; # ->
  br label %$4
$17:
  %59 = phi i64 [%43, %$15] ; # Pat
  %60 = phi i64 [%44, %$15] ; # Dat
; # (? (match (cdr Pat) (cdr Dat)) (set X (cons (car Dat) $Nil)) YES)...
; # (cdr Pat)
  %61 = inttoptr i64 %59 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  %63 = load i64, i64* %62
; # (cdr Dat)
  %64 = inttoptr i64 %60 to i64*
  %65 = getelementptr i64, i64* %64, i32 1
  %66 = load i64, i64* %65
; # (match (cdr Pat) (cdr Dat))
  %67 = call i1 @match(i64 %63, i64 %66)
  br i1 %67, label %$22, label %$21
$22:
  %68 = phi i64 [%59, %$17] ; # Pat
  %69 = phi i64 [%60, %$17] ; # Dat
; # (set X (cons (car Dat) $Nil))
; # (car Dat)
  %70 = inttoptr i64 %69 to i64*
  %71 = load i64, i64* %70
; # (cons (car Dat) $Nil)
  %72 = call i64 @cons(i64 %71, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %73 = inttoptr i64 %32 to i64*
  store i64 %72, i64* %73
  br label %$4
$21:
  %74 = phi i64 [%59, %$17] ; # Pat
  %75 = phi i64 [%60, %$17] ; # Dat
; # (? (match (cdr Pat) Dat) (set X $Nil) YES)
; # (cdr Pat)
  %76 = inttoptr i64 %74 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (match (cdr Pat) Dat)
  %79 = call i1 @match(i64 %78, i64 %75)
  br i1 %79, label %$24, label %$23
$24:
  %80 = phi i64 [%74, %$21] ; # Pat
  %81 = phi i64 [%75, %$21] ; # Dat
; # (set X $Nil)
  %82 = inttoptr i64 %32 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %82
  br label %$4
$23:
  %83 = phi i64 [%74, %$21] ; # Pat
  %84 = phi i64 [%75, %$21] ; # Dat
; # (? (match Pat (cdr Dat)) (set X (cons (car Dat) (val X))) YES)
; # (cdr Dat)
  %85 = inttoptr i64 %84 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  %87 = load i64, i64* %86
; # (match Pat (cdr Dat))
  %88 = call i1 @match(i64 %83, i64 %87)
  br i1 %88, label %$26, label %$25
$26:
  %89 = phi i64 [%83, %$23] ; # Pat
  %90 = phi i64 [%84, %$23] ; # Dat
; # (set X (cons (car Dat) (val X)))
; # (car Dat)
  %91 = inttoptr i64 %90 to i64*
  %92 = load i64, i64* %91
; # (val X)
  %93 = inttoptr i64 %32 to i64*
  %94 = load i64, i64* %93
; # (cons (car Dat) (val X))
  %95 = call i64 @cons(i64 %92, i64 %94)
  %96 = inttoptr i64 %32 to i64*
  store i64 %95, i64* %96
  br label %$4
$25:
  %97 = phi i64 [%83, %$23] ; # Pat
  %98 = phi i64 [%84, %$23] ; # Dat
  br label %$16
$16:
  %99 = phi i64 [%40, %$13], [%97, %$25] ; # Pat
  %100 = phi i64 [%41, %$13], [%98, %$25] ; # Dat
; # (? (or (atom Dat) (not (match X (car Dat)))) NO)
; # (or (atom Dat) (not (match X (car Dat))))
; # (atom Dat)
  %101 = and i64 %100, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$27, label %$28
$28:
  %103 = phi i64 [%99, %$16] ; # Pat
  %104 = phi i64 [%100, %$16] ; # Dat
; # (car Dat)
  %105 = inttoptr i64 %104 to i64*
  %106 = load i64, i64* %105
; # (match X (car Dat))
  %107 = call i1 @match(i64 %32, i64 %106)
; # (not (match X (car Dat)))
  %108 = icmp eq i1 %107, 0
  br label %$27
$27:
  %109 = phi i64 [%99, %$16], [%103, %$28] ; # Pat
  %110 = phi i64 [%100, %$16], [%104, %$28] ; # Dat
  %111 = phi i1 [1, %$16], [%108, %$28] ; # ->
  br i1 %111, label %$30, label %$29
$30:
  %112 = phi i64 [%109, %$27] ; # Pat
  %113 = phi i64 [%110, %$27] ; # Dat
  br label %$4
$29:
  %114 = phi i64 [%109, %$27] ; # Pat
  %115 = phi i64 [%110, %$27] ; # Dat
; # (shift Pat)
  %116 = inttoptr i64 %114 to i64*
  %117 = getelementptr i64, i64* %116, i32 1
  %118 = load i64, i64* %117
; # (shift Dat)
  %119 = inttoptr i64 %115 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  %121 = load i64, i64* %120
  br label %$2
$4:
  %122 = phi i64 [%23, %$10], [%56, %$19], [%68, %$22], [%80, %$24], [%89, %$26], [%112, %$30] ; # Pat
  %123 = phi i64 [%24, %$10], [%57, %$19], [%69, %$22], [%81, %$24], [%90, %$26], [%113, %$30] ; # Dat
  %124 = phi i1 [%25, %$10], [%58, %$19], [1, %$22], [1, %$24], [1, %$26], [0, %$30] ; # ->
  ret i1 %124
}

define i64 @_match(i64) {
$1:
; # (let X (cdr Exe) (if (match (save (eval (++ X))) (save (eval (car...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (match (save (eval (++ X))) (save (eval (car X)))) $T $Nil)
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = alloca i64, i64 2, align 16
  %35 = ptrtoint i64* %34 to i64
  %36 = inttoptr i64 %35 to i64*
  store i64 %33, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %35 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  store i64 %38, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %35, i64* %41
; # (match (save (eval (++ X))) (save (eval (car X))))
  %42 = call i1 @match(i64 %15, i64 %33)
  br i1 %42, label %$12, label %$13
$12:
  %43 = phi i64 [%7, %$7] ; # X
  br label %$14
$13:
  %44 = phi i64 [%7, %$7] ; # X
  br label %$14
$14:
  %45 = phi i64 [%43, %$12], [%44, %$13] ; # X
  %46 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13] ; # ->
; # (drop *Safe)
  %47 = inttoptr i64 %17 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
  %50 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %49, i64* %50
  ret i64 %46
}

define i64 @fill(i64, i64) {
$1:
; # (cond ((num? X) 0) ((sym? X) (let V (val X) (cond ((== X V) 0) ((...
; # (num? X)
  %2 = and i64 %0, 6
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$4, label %$3
$4:
  %4 = phi i64 [%0, %$1] ; # X
  br label %$2
$3:
  %5 = phi i64 [%0, %$1] ; # X
; # (sym? X)
  %6 = and i64 %5, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$6, label %$5
$6:
  %8 = phi i64 [%5, %$3] ; # X
; # (let V (val X) (cond ((== X V) 0) ((nil? Y) (cond ((== X $At) 0) ...
; # (val X)
  %9 = inttoptr i64 %8 to i64*
  %10 = load i64, i64* %9
; # (cond ((== X V) 0) ((nil? Y) (cond ((== X $At) 0) ((== (firstByte...
; # (== X V)
  %11 = icmp eq i64 %8, %10
  br i1 %11, label %$9, label %$8
$9:
  %12 = phi i64 [%8, %$6] ; # X
  br label %$7
$8:
  %13 = phi i64 [%8, %$6] ; # X
; # (nil? Y)
  %14 = icmp eq i64 %1, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$11, label %$10
$11:
  %15 = phi i64 [%13, %$8] ; # X
; # (cond ((== X $At) 0) ((== (firstByte X) (char "@")) V) (T 0))
; # (== X $At)
  %16 = icmp eq i64 %15, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %16, label %$14, label %$13
$14:
  %17 = phi i64 [%15, %$11] ; # X
  br label %$12
$13:
  %18 = phi i64 [%15, %$11] ; # X
; # (firstByte X)
  %19 = call i8 @firstByte(i64 %18)
; # (== (firstByte X) (char "@"))
  %20 = icmp eq i8 %19, 64
  br i1 %20, label %$16, label %$15
$16:
  %21 = phi i64 [%18, %$13] ; # X
  br label %$12
$15:
  %22 = phi i64 [%18, %$13] ; # X
  br label %$12
$12:
  %23 = phi i64 [%17, %$14], [%21, %$16], [%22, %$15] ; # X
  %24 = phi i64 [0, %$14], [%10, %$16], [0, %$15] ; # ->
  br label %$7
$10:
  %25 = phi i64 [%13, %$8] ; # X
; # (or (== X Y) (memq X Y))
; # (== X Y)
  %26 = icmp eq i64 %25, %1
  br i1 %26, label %$17, label %$18
$18:
  %27 = phi i64 [%25, %$10] ; # X
; # (memq X Y)
  br label %$19
$19:
  %28 = phi i64 [%1, %$18], [%40, %$23] ; # L
  %29 = and i64 %28, 15
  %30 = icmp ne i64 %29, 0
  br i1 %30, label %$22, label %$20
$22:
  %31 = phi i64 [%28, %$19] ; # L
  br label %$21
$20:
  %32 = phi i64 [%28, %$19] ; # L
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
  %35 = icmp eq i64 %27, %34
  br i1 %35, label %$24, label %$23
$24:
  %36 = phi i64 [%32, %$20] ; # L
  br label %$21
$23:
  %37 = phi i64 [%32, %$20] ; # L
  %38 = inttoptr i64 %37 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  br label %$19
$21:
  %41 = phi i64 [%31, %$22], [%36, %$24] ; # L
  %42 = phi i1 [0, %$22], [1, %$24] ; # ->
  br label %$17
$17:
  %43 = phi i64 [%25, %$10], [%27, %$21] ; # X
  %44 = phi i1 [1, %$10], [%42, %$21] ; # ->
  br i1 %44, label %$26, label %$25
$26:
  %45 = phi i64 [%43, %$17] ; # X
  br label %$7
$25:
  %46 = phi i64 [%43, %$17] ; # X
  br label %$7
$7:
  %47 = phi i64 [%12, %$9], [%23, %$12], [%45, %$26], [%46, %$25] ; # X
  %48 = phi i64 [0, %$9], [%24, %$12], [%10, %$26], [0, %$25] ; # ->
  br label %$2
$5:
  %49 = phi i64 [%5, %$3] ; # X
; # (stkChk 0)
  %50 = load i8*, i8** @$StkLimit
  %51 = call i8* @llvm.stacksave()
  %52 = icmp ugt i8* %50, %51
  br i1 %52, label %$27, label %$28
$27:
  call void @stkErr(i64 0)
  unreachable
$28:
; # (let Z (++ X) (if (== Z $Up) (let V (eval (++ X)) (if (atom V) (i...
; # (++ X)
  %53 = inttoptr i64 %49 to i64*
  %54 = load i64, i64* %53
  %55 = getelementptr i64, i64* %53, i32 1
  %56 = load i64, i64* %55
; # (if (== Z $Up) (let V (eval (++ X)) (if (atom V) (if (fill X Y) @...
; # (== Z $Up)
  %57 = icmp eq i64 %54, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64)
  br i1 %57, label %$29, label %$30
$29:
  %58 = phi i64 [%56, %$28] ; # X
  %59 = phi i64 [%54, %$28] ; # Z
; # (let V (eval (++ X)) (if (atom V) (if (fill X Y) @ X) (save (setq...
; # (++ X)
  %60 = inttoptr i64 %58 to i64*
  %61 = load i64, i64* %60
  %62 = getelementptr i64, i64* %60, i32 1
  %63 = load i64, i64* %62
; # (eval (++ X))
  %64 = and i64 %61, 6
  %65 = icmp ne i64 %64, 0
  br i1 %65, label %$34, label %$33
$34:
  br label %$32
$33:
  %66 = and i64 %61, 8
  %67 = icmp ne i64 %66, 0
  br i1 %67, label %$36, label %$35
$36:
  %68 = inttoptr i64 %61 to i64*
  %69 = load i64, i64* %68
  br label %$32
$35:
  %70 = call i64 @evList(i64 %61)
  br label %$32
$32:
  %71 = phi i64 [%61, %$34], [%69, %$36], [%70, %$35] ; # ->
; # (if (atom V) (if (fill X Y) @ X) (save (setq Z V) (while (pair (c...
; # (atom V)
  %72 = and i64 %71, 15
  %73 = icmp ne i64 %72, 0
  br i1 %73, label %$37, label %$38
$37:
  %74 = phi i64 [%63, %$32] ; # X
  %75 = phi i64 [%59, %$32] ; # Z
  %76 = phi i64 [%71, %$32] ; # V
; # (if (fill X Y) @ X)
; # (fill X Y)
  %77 = call i64 @fill(i64 %74, i64 %1)
  %78 = icmp ne i64 %77, 0
  br i1 %78, label %$40, label %$41
$40:
  %79 = phi i64 [%74, %$37] ; # X
  %80 = phi i64 [%75, %$37] ; # Z
  %81 = phi i64 [%76, %$37] ; # V
  br label %$42
$41:
  %82 = phi i64 [%74, %$37] ; # X
  %83 = phi i64 [%75, %$37] ; # Z
  %84 = phi i64 [%76, %$37] ; # V
  br label %$42
$42:
  %85 = phi i64 [%79, %$40], [%82, %$41] ; # X
  %86 = phi i64 [%80, %$40], [%83, %$41] ; # Z
  %87 = phi i64 [%81, %$40], [%84, %$41] ; # V
  %88 = phi i64 [%77, %$40], [%82, %$41] ; # ->
  br label %$39
$38:
  %89 = phi i64 [%63, %$32] ; # X
  %90 = phi i64 [%59, %$32] ; # Z
  %91 = phi i64 [%71, %$32] ; # V
; # (save (setq Z V) (while (pair (cdr V)) (setq V @)) (set 2 V (if (...
  %92 = alloca i64, i64 2, align 16
  %93 = ptrtoint i64* %92 to i64
  %94 = inttoptr i64 %93 to i64*
  store i64 %91, i64* %94
  %95 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %96 = load i64, i64* %95
  %97 = inttoptr i64 %93 to i64*
  %98 = getelementptr i64, i64* %97, i32 1
  store i64 %96, i64* %98
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %93, i64* %99
; # (while (pair (cdr V)) (setq V @))
  br label %$43
$43:
  %100 = phi i64 [%89, %$38], [%108, %$44] ; # X
  %101 = phi i64 [%91, %$38], [%109, %$44] ; # Z
  %102 = phi i64 [%91, %$38], [%105, %$44] ; # V
; # (cdr V)
  %103 = inttoptr i64 %102 to i64*
  %104 = getelementptr i64, i64* %103, i32 1
  %105 = load i64, i64* %104
; # (pair (cdr V))
  %106 = and i64 %105, 15
  %107 = icmp eq i64 %106, 0
  br i1 %107, label %$44, label %$45
$44:
  %108 = phi i64 [%100, %$43] ; # X
  %109 = phi i64 [%101, %$43] ; # Z
  %110 = phi i64 [%102, %$43] ; # V
  br label %$43
$45:
  %111 = phi i64 [%100, %$43] ; # X
  %112 = phi i64 [%101, %$43] ; # Z
  %113 = phi i64 [%102, %$43] ; # V
; # (set 2 V (if (fill X Y) @ X))
; # (if (fill X Y) @ X)
; # (fill X Y)
  %114 = call i64 @fill(i64 %111, i64 %1)
  %115 = icmp ne i64 %114, 0
  br i1 %115, label %$46, label %$47
$46:
  %116 = phi i64 [%111, %$45] ; # X
  %117 = phi i64 [%112, %$45] ; # Z
  %118 = phi i64 [%113, %$45] ; # V
  br label %$48
$47:
  %119 = phi i64 [%111, %$45] ; # X
  %120 = phi i64 [%112, %$45] ; # Z
  %121 = phi i64 [%113, %$45] ; # V
  br label %$48
$48:
  %122 = phi i64 [%116, %$46], [%119, %$47] ; # X
  %123 = phi i64 [%117, %$46], [%120, %$47] ; # Z
  %124 = phi i64 [%118, %$46], [%121, %$47] ; # V
  %125 = phi i64 [%114, %$46], [%119, %$47] ; # ->
  %126 = inttoptr i64 %113 to i64*
  %127 = getelementptr i64, i64* %126, i32 1
  store i64 %125, i64* %127
  %128 = inttoptr i64 %93 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %130, i64* %131
  br label %$39
$39:
  %132 = phi i64 [%85, %$42], [%122, %$48] ; # X
  %133 = phi i64 [%86, %$42], [%123, %$48] ; # Z
  %134 = phi i64 [%87, %$42], [%124, %$48] ; # V
  %135 = phi i64 [%88, %$42], [%123, %$48] ; # ->
  br label %$31
$30:
  %136 = phi i64 [%56, %$28] ; # X
  %137 = phi i64 [%54, %$28] ; # Z
; # (let V (fill Z Y) (cond (V (save V (cons V (if (fill X Y) @ X))))...
; # (fill Z Y)
  %138 = call i64 @fill(i64 %137, i64 %1)
; # (cond (V (save V (cons V (if (fill X Y) @ X)))) ((fill X Y) (cons...
  %139 = icmp ne i64 %138, 0
  br i1 %139, label %$51, label %$50
$51:
  %140 = phi i64 [%136, %$30] ; # X
  %141 = phi i64 [%137, %$30] ; # Z
; # (save V (cons V (if (fill X Y) @ X)))
  %142 = alloca i64, i64 2, align 16
  %143 = ptrtoint i64* %142 to i64
  %144 = inttoptr i64 %143 to i64*
  store i64 %138, i64* %144
  %145 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %146 = load i64, i64* %145
  %147 = inttoptr i64 %143 to i64*
  %148 = getelementptr i64, i64* %147, i32 1
  store i64 %146, i64* %148
  %149 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %143, i64* %149
; # (if (fill X Y) @ X)
; # (fill X Y)
  %150 = call i64 @fill(i64 %140, i64 %1)
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$52, label %$53
$52:
  %152 = phi i64 [%140, %$51] ; # X
  %153 = phi i64 [%141, %$51] ; # Z
  br label %$54
$53:
  %154 = phi i64 [%140, %$51] ; # X
  %155 = phi i64 [%141, %$51] ; # Z
  br label %$54
$54:
  %156 = phi i64 [%152, %$52], [%154, %$53] ; # X
  %157 = phi i64 [%153, %$52], [%155, %$53] ; # Z
  %158 = phi i64 [%150, %$52], [%154, %$53] ; # ->
; # (cons V (if (fill X Y) @ X))
  %159 = call i64 @cons(i64 %138, i64 %158)
  %160 = inttoptr i64 %143 to i64*
  %161 = getelementptr i64, i64* %160, i32 1
  %162 = load i64, i64* %161
  %163 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %162, i64* %163
  br label %$49
$50:
  %164 = phi i64 [%136, %$30] ; # X
  %165 = phi i64 [%137, %$30] ; # Z
; # (fill X Y)
  %166 = call i64 @fill(i64 %164, i64 %1)
  %167 = icmp ne i64 %166, 0
  br i1 %167, label %$56, label %$55
$56:
  %168 = phi i64 [%164, %$50] ; # X
  %169 = phi i64 [%165, %$50] ; # Z
; # (cons Z @)
  %170 = call i64 @cons(i64 %169, i64 %166)
  br label %$49
$55:
  %171 = phi i64 [%164, %$50] ; # X
  %172 = phi i64 [%165, %$50] ; # Z
  br label %$49
$49:
  %173 = phi i64 [%156, %$54], [%168, %$56], [%171, %$55] ; # X
  %174 = phi i64 [%157, %$54], [%169, %$56], [%172, %$55] ; # Z
  %175 = phi i64 [%159, %$54], [%170, %$56], [0, %$55] ; # ->
  br label %$31
$31:
  %176 = phi i64 [%132, %$39], [%173, %$49] ; # X
  %177 = phi i64 [%133, %$39], [%174, %$49] ; # Z
  %178 = phi i64 [%135, %$39], [%175, %$49] ; # ->
  br label %$2
$2:
  %179 = phi i64 [%4, %$4], [%47, %$7], [%176, %$31] ; # X
  %180 = phi i64 [0, %$4], [%48, %$7], [%178, %$31] ; # ->
  ret i64 %180
}

define i64 @_fill(i64) {
$1:
; # (let (X (cdr Exe) Y (save (eval (++ X)))) (if (fill Y (save (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (if (fill Y (save (eval (car X)))) @ Y)
; # (car X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
; # (eval (car X))
  %26 = and i64 %25, 6
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$8
$9:
  br label %$7
$8:
  %28 = and i64 %25, 8
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$11, label %$10
$11:
  %30 = inttoptr i64 %25 to i64*
  %31 = load i64, i64* %30
  br label %$7
$10:
  %32 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %33 = phi i64 [%25, %$9], [%31, %$11], [%32, %$10] ; # ->
; # (save (eval (car X)))
  %34 = alloca i64, i64 2, align 16
  %35 = ptrtoint i64* %34 to i64
  %36 = inttoptr i64 %35 to i64*
  store i64 %33, i64* %36
  %37 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %38 = load i64, i64* %37
  %39 = inttoptr i64 %35 to i64*
  %40 = getelementptr i64, i64* %39, i32 1
  store i64 %38, i64* %40
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %35, i64* %41
; # (fill Y (save (eval (car X))))
  %42 = call i64 @fill(i64 %15, i64 %33)
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$12, label %$13
$12:
  br label %$14
$13:
  br label %$14
$14:
  %44 = phi i64 [%42, %$12], [%15, %$13] ; # ->
; # (drop *Safe)
  %45 = inttoptr i64 %17 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  %47 = load i64, i64* %46
  %48 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %47, i64* %48
  ret i64 %44
}
@$Penv = global i64 0
@$Pnl = global i64 0

define i1 @unify(i64, i64, i64, i64) {
$1:
; # (let Penv (val $Penv) (: 1 (when (and (symb? X1) (== (firstByte X...
; # (val $Penv)
  %4 = load i64, i64* @$Penv
; # (: 1 (when (and (symb? X1) (== (firstByte X1) (char "@"))) (let X...
  br label %$-1
$-1:
  %5 = phi i64 [%0, %$1], [%75, %$11] ; # N1
  %6 = phi i64 [%1, %$1], [%78, %$11] ; # X1
  %7 = phi i64 [%2, %$1], [%67, %$11] ; # N2
  %8 = phi i64 [%3, %$1], [%68, %$11] ; # X2
; # (when (and (symb? X1) (== (firstByte X1) (char "@"))) (let X (val...
; # (and (symb? X1) (== (firstByte X1) (char "@")))
; # (symb? X1)
  %9 = xor i64 %6, 8
  %10 = and i64 %9, 14
  %11 = icmp eq i64 %10, 0
  br i1 %11, label %$3, label %$2
$3:
  %12 = phi i64 [%5, %$-1] ; # N1
  %13 = phi i64 [%6, %$-1] ; # X1
  %14 = phi i64 [%7, %$-1] ; # N2
  %15 = phi i64 [%8, %$-1] ; # X2
; # (firstByte X1)
  %16 = call i8 @firstByte(i64 %13)
; # (== (firstByte X1) (char "@"))
  %17 = icmp eq i8 %16, 64
  br label %$2
$2:
  %18 = phi i64 [%5, %$-1], [%12, %$3] ; # N1
  %19 = phi i64 [%6, %$-1], [%13, %$3] ; # X1
  %20 = phi i64 [%7, %$-1], [%14, %$3] ; # N2
  %21 = phi i64 [%8, %$-1], [%15, %$3] ; # X2
  %22 = phi i1 [0, %$-1], [%17, %$3] ; # ->
  br i1 %22, label %$4, label %$5
$4:
  %23 = phi i64 [%18, %$2] ; # N1
  %24 = phi i64 [%19, %$2] ; # X1
  %25 = phi i64 [%20, %$2] ; # N2
  %26 = phi i64 [%21, %$2] ; # X2
; # (let X (val Penv) (while (pair (car X)) (let (Y @ Z (car Y)) (whe...
; # (val Penv)
  %27 = inttoptr i64 %4 to i64*
  %28 = load i64, i64* %27
; # (while (pair (car X)) (let (Y @ Z (car Y)) (when (and (== N1 (car...
  br label %$6
$6:
  %29 = phi i64 [%23, %$4], [%79, %$12] ; # N1
  %30 = phi i64 [%24, %$4], [%80, %$12] ; # X1
  %31 = phi i64 [%25, %$4], [%81, %$12] ; # N2
  %32 = phi i64 [%26, %$4], [%82, %$12] ; # X2
  %33 = phi i64 [%28, %$4], [%87, %$12] ; # X
; # (car X)
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (pair (car X))
  %36 = and i64 %35, 15
  %37 = icmp eq i64 %36, 0
  br i1 %37, label %$7, label %$8
$7:
  %38 = phi i64 [%29, %$6] ; # N1
  %39 = phi i64 [%30, %$6] ; # X1
  %40 = phi i64 [%31, %$6] ; # N2
  %41 = phi i64 [%32, %$6] ; # X2
  %42 = phi i64 [%33, %$6] ; # X
; # (let (Y @ Z (car Y)) (when (and (== N1 (car Z)) (== X1 (cdr Z))) ...
; # (car Y)
  %43 = inttoptr i64 %35 to i64*
  %44 = load i64, i64* %43
; # (when (and (== N1 (car Z)) (== X1 (cdr Z))) (setq Z (cdr Y) N1 (c...
; # (and (== N1 (car Z)) (== X1 (cdr Z)))
; # (car Z)
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (== N1 (car Z))
  %47 = icmp eq i64 %38, %46
  br i1 %47, label %$10, label %$9
$10:
  %48 = phi i64 [%38, %$7] ; # N1
  %49 = phi i64 [%39, %$7] ; # X1
  %50 = phi i64 [%40, %$7] ; # N2
  %51 = phi i64 [%41, %$7] ; # X2
  %52 = phi i64 [%42, %$7] ; # X
  %53 = phi i64 [%44, %$7] ; # Z
; # (cdr Z)
  %54 = inttoptr i64 %53 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
; # (== X1 (cdr Z))
  %57 = icmp eq i64 %49, %56
  br label %$9
$9:
  %58 = phi i64 [%38, %$7], [%48, %$10] ; # N1
  %59 = phi i64 [%39, %$7], [%49, %$10] ; # X1
  %60 = phi i64 [%40, %$7], [%50, %$10] ; # N2
  %61 = phi i64 [%41, %$7], [%51, %$10] ; # X2
  %62 = phi i64 [%42, %$7], [%52, %$10] ; # X
  %63 = phi i64 [%44, %$7], [%53, %$10] ; # Z
  %64 = phi i1 [0, %$7], [%57, %$10] ; # ->
  br i1 %64, label %$11, label %$12
$11:
  %65 = phi i64 [%58, %$9] ; # N1
  %66 = phi i64 [%59, %$9] ; # X1
  %67 = phi i64 [%60, %$9] ; # N2
  %68 = phi i64 [%61, %$9] ; # X2
  %69 = phi i64 [%62, %$9] ; # X
  %70 = phi i64 [%63, %$9] ; # Z
; # (cdr Y)
  %71 = inttoptr i64 %35 to i64*
  %72 = getelementptr i64, i64* %71, i32 1
  %73 = load i64, i64* %72
; # (car Z)
  %74 = inttoptr i64 %73 to i64*
  %75 = load i64, i64* %74
; # (cdr Z)
  %76 = inttoptr i64 %73 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (goto 1)
  br label %$-1
$12:
  %79 = phi i64 [%58, %$9] ; # N1
  %80 = phi i64 [%59, %$9] ; # X1
  %81 = phi i64 [%60, %$9] ; # N2
  %82 = phi i64 [%61, %$9] ; # X2
  %83 = phi i64 [%62, %$9] ; # X
  %84 = phi i64 [%63, %$9] ; # Z
; # (shift X)
  %85 = inttoptr i64 %83 to i64*
  %86 = getelementptr i64, i64* %85, i32 1
  %87 = load i64, i64* %86
  br label %$6
$8:
  %88 = phi i64 [%29, %$6] ; # N1
  %89 = phi i64 [%30, %$6] ; # X1
  %90 = phi i64 [%31, %$6] ; # N2
  %91 = phi i64 [%32, %$6] ; # X2
  %92 = phi i64 [%33, %$6] ; # X
  br label %$5
$5:
  %93 = phi i64 [%18, %$2], [%88, %$8] ; # N1
  %94 = phi i64 [%19, %$2], [%89, %$8] ; # X1
  %95 = phi i64 [%20, %$2], [%90, %$8] ; # N2
  %96 = phi i64 [%21, %$2], [%91, %$8] ; # X2
; # (: 2 (when (and (symb? X2) (== (firstByte X2) (char "@"))) (let X...
  br label %$-2
$-2:
  %97 = phi i64 [%93, %$5], [%157, %$22] ; # N1
  %98 = phi i64 [%94, %$5], [%158, %$22] ; # X1
  %99 = phi i64 [%95, %$5], [%167, %$22] ; # N2
  %100 = phi i64 [%96, %$5], [%170, %$22] ; # X2
; # (when (and (symb? X2) (== (firstByte X2) (char "@"))) (let X (val...
; # (and (symb? X2) (== (firstByte X2) (char "@")))
; # (symb? X2)
  %101 = xor i64 %100, 8
  %102 = and i64 %101, 14
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %$14, label %$13
$14:
  %104 = phi i64 [%97, %$-2] ; # N1
  %105 = phi i64 [%98, %$-2] ; # X1
  %106 = phi i64 [%99, %$-2] ; # N2
  %107 = phi i64 [%100, %$-2] ; # X2
; # (firstByte X2)
  %108 = call i8 @firstByte(i64 %107)
; # (== (firstByte X2) (char "@"))
  %109 = icmp eq i8 %108, 64
  br label %$13
$13:
  %110 = phi i64 [%97, %$-2], [%104, %$14] ; # N1
  %111 = phi i64 [%98, %$-2], [%105, %$14] ; # X1
  %112 = phi i64 [%99, %$-2], [%106, %$14] ; # N2
  %113 = phi i64 [%100, %$-2], [%107, %$14] ; # X2
  %114 = phi i1 [0, %$-2], [%109, %$14] ; # ->
  br i1 %114, label %$15, label %$16
$15:
  %115 = phi i64 [%110, %$13] ; # N1
  %116 = phi i64 [%111, %$13] ; # X1
  %117 = phi i64 [%112, %$13] ; # N2
  %118 = phi i64 [%113, %$13] ; # X2
; # (let X (val Penv) (while (pair (car X)) (let (Y @ Z (car Y)) (whe...
; # (val Penv)
  %119 = inttoptr i64 %4 to i64*
  %120 = load i64, i64* %119
; # (while (pair (car X)) (let (Y @ Z (car Y)) (when (and (== N2 (car...
  br label %$17
$17:
  %121 = phi i64 [%115, %$15], [%171, %$23] ; # N1
  %122 = phi i64 [%116, %$15], [%172, %$23] ; # X1
  %123 = phi i64 [%117, %$15], [%173, %$23] ; # N2
  %124 = phi i64 [%118, %$15], [%174, %$23] ; # X2
  %125 = phi i64 [%120, %$15], [%179, %$23] ; # X
; # (car X)
  %126 = inttoptr i64 %125 to i64*
  %127 = load i64, i64* %126
; # (pair (car X))
  %128 = and i64 %127, 15
  %129 = icmp eq i64 %128, 0
  br i1 %129, label %$18, label %$19
$18:
  %130 = phi i64 [%121, %$17] ; # N1
  %131 = phi i64 [%122, %$17] ; # X1
  %132 = phi i64 [%123, %$17] ; # N2
  %133 = phi i64 [%124, %$17] ; # X2
  %134 = phi i64 [%125, %$17] ; # X
; # (let (Y @ Z (car Y)) (when (and (== N2 (car Z)) (== X2 (cdr Z))) ...
; # (car Y)
  %135 = inttoptr i64 %127 to i64*
  %136 = load i64, i64* %135
; # (when (and (== N2 (car Z)) (== X2 (cdr Z))) (setq Z (cdr Y) N2 (c...
; # (and (== N2 (car Z)) (== X2 (cdr Z)))
; # (car Z)
  %137 = inttoptr i64 %136 to i64*
  %138 = load i64, i64* %137
; # (== N2 (car Z))
  %139 = icmp eq i64 %132, %138
  br i1 %139, label %$21, label %$20
$21:
  %140 = phi i64 [%130, %$18] ; # N1
  %141 = phi i64 [%131, %$18] ; # X1
  %142 = phi i64 [%132, %$18] ; # N2
  %143 = phi i64 [%133, %$18] ; # X2
  %144 = phi i64 [%134, %$18] ; # X
  %145 = phi i64 [%136, %$18] ; # Z
; # (cdr Z)
  %146 = inttoptr i64 %145 to i64*
  %147 = getelementptr i64, i64* %146, i32 1
  %148 = load i64, i64* %147
; # (== X2 (cdr Z))
  %149 = icmp eq i64 %143, %148
  br label %$20
$20:
  %150 = phi i64 [%130, %$18], [%140, %$21] ; # N1
  %151 = phi i64 [%131, %$18], [%141, %$21] ; # X1
  %152 = phi i64 [%132, %$18], [%142, %$21] ; # N2
  %153 = phi i64 [%133, %$18], [%143, %$21] ; # X2
  %154 = phi i64 [%134, %$18], [%144, %$21] ; # X
  %155 = phi i64 [%136, %$18], [%145, %$21] ; # Z
  %156 = phi i1 [0, %$18], [%149, %$21] ; # ->
  br i1 %156, label %$22, label %$23
$22:
  %157 = phi i64 [%150, %$20] ; # N1
  %158 = phi i64 [%151, %$20] ; # X1
  %159 = phi i64 [%152, %$20] ; # N2
  %160 = phi i64 [%153, %$20] ; # X2
  %161 = phi i64 [%154, %$20] ; # X
  %162 = phi i64 [%155, %$20] ; # Z
; # (cdr Y)
  %163 = inttoptr i64 %127 to i64*
  %164 = getelementptr i64, i64* %163, i32 1
  %165 = load i64, i64* %164
; # (car Z)
  %166 = inttoptr i64 %165 to i64*
  %167 = load i64, i64* %166
; # (cdr Z)
  %168 = inttoptr i64 %165 to i64*
  %169 = getelementptr i64, i64* %168, i32 1
  %170 = load i64, i64* %169
; # (goto 2)
  br label %$-2
$23:
  %171 = phi i64 [%150, %$20] ; # N1
  %172 = phi i64 [%151, %$20] ; # X1
  %173 = phi i64 [%152, %$20] ; # N2
  %174 = phi i64 [%153, %$20] ; # X2
  %175 = phi i64 [%154, %$20] ; # X
  %176 = phi i64 [%155, %$20] ; # Z
; # (shift X)
  %177 = inttoptr i64 %175 to i64*
  %178 = getelementptr i64, i64* %177, i32 1
  %179 = load i64, i64* %178
  br label %$17
$19:
  %180 = phi i64 [%121, %$17] ; # N1
  %181 = phi i64 [%122, %$17] ; # X1
  %182 = phi i64 [%123, %$17] ; # N2
  %183 = phi i64 [%124, %$17] ; # X2
  %184 = phi i64 [%125, %$17] ; # X
  br label %$16
$16:
  %185 = phi i64 [%110, %$13], [%180, %$19] ; # N1
  %186 = phi i64 [%111, %$13], [%181, %$19] ; # X1
  %187 = phi i64 [%112, %$13], [%182, %$19] ; # N2
  %188 = phi i64 [%113, %$13], [%183, %$19] ; # X2
; # (cond ((and (== N1 N2) (equal X1 X2)) YES) ((and (symb? X1) (== (...
; # (and (== N1 N2) (equal X1 X2))
; # (== N1 N2)
  %189 = icmp eq i64 %185, %187
  br i1 %189, label %$26, label %$25
$26:
  %190 = phi i64 [%185, %$16] ; # N1
  %191 = phi i64 [%186, %$16] ; # X1
  %192 = phi i64 [%187, %$16] ; # N2
  %193 = phi i64 [%188, %$16] ; # X2
; # (equal X1 X2)
  %194 = call i1 @equal(i64 %191, i64 %193)
  br label %$25
$25:
  %195 = phi i64 [%185, %$16], [%190, %$26] ; # N1
  %196 = phi i64 [%186, %$16], [%191, %$26] ; # X1
  %197 = phi i64 [%187, %$16], [%192, %$26] ; # N2
  %198 = phi i64 [%188, %$16], [%193, %$26] ; # X2
  %199 = phi i1 [0, %$16], [%194, %$26] ; # ->
  br i1 %199, label %$28, label %$27
$28:
  %200 = phi i64 [%195, %$25] ; # N1
  %201 = phi i64 [%196, %$25] ; # X1
  %202 = phi i64 [%197, %$25] ; # N2
  %203 = phi i64 [%198, %$25] ; # X2
  br label %$24
$27:
  %204 = phi i64 [%195, %$25] ; # N1
  %205 = phi i64 [%196, %$25] ; # X1
  %206 = phi i64 [%197, %$25] ; # N2
  %207 = phi i64 [%198, %$25] ; # X2
; # (and (symb? X1) (== (firstByte X1) (char "@")))
; # (symb? X1)
  %208 = xor i64 %205, 8
  %209 = and i64 %208, 14
  %210 = icmp eq i64 %209, 0
  br i1 %210, label %$30, label %$29
$30:
  %211 = phi i64 [%204, %$27] ; # N1
  %212 = phi i64 [%205, %$27] ; # X1
  %213 = phi i64 [%206, %$27] ; # N2
  %214 = phi i64 [%207, %$27] ; # X2
; # (firstByte X1)
  %215 = call i8 @firstByte(i64 %212)
; # (== (firstByte X1) (char "@"))
  %216 = icmp eq i8 %215, 64
  br label %$29
$29:
  %217 = phi i64 [%204, %$27], [%211, %$30] ; # N1
  %218 = phi i64 [%205, %$27], [%212, %$30] ; # X1
  %219 = phi i64 [%206, %$27], [%213, %$30] ; # N2
  %220 = phi i64 [%207, %$27], [%214, %$30] ; # X2
  %221 = phi i1 [0, %$27], [%216, %$30] ; # ->
  br i1 %221, label %$32, label %$31
$32:
  %222 = phi i64 [%217, %$29] ; # N1
  %223 = phi i64 [%218, %$29] ; # X1
  %224 = phi i64 [%219, %$29] ; # N2
  %225 = phi i64 [%220, %$29] ; # X2
; # (unless (== X1 $At) (set Penv (cons (cons3 N1 X1 N2 X2) (val Penv...
; # (== X1 $At)
  %226 = icmp eq i64 %223, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %226, label %$34, label %$33
$33:
  %227 = phi i64 [%222, %$32] ; # N1
  %228 = phi i64 [%223, %$32] ; # X1
  %229 = phi i64 [%224, %$32] ; # N2
  %230 = phi i64 [%225, %$32] ; # X2
; # (set Penv (cons (cons3 N1 X1 N2 X2) (val Penv)))
; # (cons3 N1 X1 N2 X2)
  %231 = call i64 @cons3(i64 %227, i64 %228, i64 %229, i64 %230)
; # (val Penv)
  %232 = inttoptr i64 %4 to i64*
  %233 = load i64, i64* %232
; # (cons (cons3 N1 X1 N2 X2) (val Penv))
  %234 = call i64 @cons(i64 %231, i64 %233)
  %235 = inttoptr i64 %4 to i64*
  store i64 %234, i64* %235
  br label %$34
$34:
  %236 = phi i64 [%222, %$32], [%227, %$33] ; # N1
  %237 = phi i64 [%223, %$32], [%228, %$33] ; # X1
  %238 = phi i64 [%224, %$32], [%229, %$33] ; # N2
  %239 = phi i64 [%225, %$32], [%230, %$33] ; # X2
  br label %$24
$31:
  %240 = phi i64 [%217, %$29] ; # N1
  %241 = phi i64 [%218, %$29] ; # X1
  %242 = phi i64 [%219, %$29] ; # N2
  %243 = phi i64 [%220, %$29] ; # X2
; # (and (symb? X2) (== (firstByte X2) (char "@")))
; # (symb? X2)
  %244 = xor i64 %243, 8
  %245 = and i64 %244, 14
  %246 = icmp eq i64 %245, 0
  br i1 %246, label %$36, label %$35
$36:
  %247 = phi i64 [%240, %$31] ; # N1
  %248 = phi i64 [%241, %$31] ; # X1
  %249 = phi i64 [%242, %$31] ; # N2
  %250 = phi i64 [%243, %$31] ; # X2
; # (firstByte X2)
  %251 = call i8 @firstByte(i64 %250)
; # (== (firstByte X2) (char "@"))
  %252 = icmp eq i8 %251, 64
  br label %$35
$35:
  %253 = phi i64 [%240, %$31], [%247, %$36] ; # N1
  %254 = phi i64 [%241, %$31], [%248, %$36] ; # X1
  %255 = phi i64 [%242, %$31], [%249, %$36] ; # N2
  %256 = phi i64 [%243, %$31], [%250, %$36] ; # X2
  %257 = phi i1 [0, %$31], [%252, %$36] ; # ->
  br i1 %257, label %$38, label %$37
$38:
  %258 = phi i64 [%253, %$35] ; # N1
  %259 = phi i64 [%254, %$35] ; # X1
  %260 = phi i64 [%255, %$35] ; # N2
  %261 = phi i64 [%256, %$35] ; # X2
; # (unless (== X2 $At) (set Penv (cons (cons3 N2 X2 N1 X1) (val Penv...
; # (== X2 $At)
  %262 = icmp eq i64 %261, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %262, label %$40, label %$39
$39:
  %263 = phi i64 [%258, %$38] ; # N1
  %264 = phi i64 [%259, %$38] ; # X1
  %265 = phi i64 [%260, %$38] ; # N2
  %266 = phi i64 [%261, %$38] ; # X2
; # (set Penv (cons (cons3 N2 X2 N1 X1) (val Penv)))
; # (cons3 N2 X2 N1 X1)
  %267 = call i64 @cons3(i64 %265, i64 %266, i64 %263, i64 %264)
; # (val Penv)
  %268 = inttoptr i64 %4 to i64*
  %269 = load i64, i64* %268
; # (cons (cons3 N2 X2 N1 X1) (val Penv))
  %270 = call i64 @cons(i64 %267, i64 %269)
  %271 = inttoptr i64 %4 to i64*
  store i64 %270, i64* %271
  br label %$40
$40:
  %272 = phi i64 [%258, %$38], [%263, %$39] ; # N1
  %273 = phi i64 [%259, %$38], [%264, %$39] ; # X1
  %274 = phi i64 [%260, %$38], [%265, %$39] ; # N2
  %275 = phi i64 [%261, %$38], [%266, %$39] ; # X2
  br label %$24
$37:
  %276 = phi i64 [%253, %$35] ; # N1
  %277 = phi i64 [%254, %$35] ; # X1
  %278 = phi i64 [%255, %$35] ; # N2
  %279 = phi i64 [%256, %$35] ; # X2
; # (or (atom X1) (atom X2))
; # (atom X1)
  %280 = and i64 %277, 15
  %281 = icmp ne i64 %280, 0
  br i1 %281, label %$41, label %$42
$42:
  %282 = phi i64 [%276, %$37] ; # N1
  %283 = phi i64 [%277, %$37] ; # X1
  %284 = phi i64 [%278, %$37] ; # N2
  %285 = phi i64 [%279, %$37] ; # X2
; # (atom X2)
  %286 = and i64 %285, 15
  %287 = icmp ne i64 %286, 0
  br label %$41
$41:
  %288 = phi i64 [%276, %$37], [%282, %$42] ; # N1
  %289 = phi i64 [%277, %$37], [%283, %$42] ; # X1
  %290 = phi i64 [%278, %$37], [%284, %$42] ; # N2
  %291 = phi i64 [%279, %$37], [%285, %$42] ; # X2
  %292 = phi i1 [1, %$37], [%287, %$42] ; # ->
  br i1 %292, label %$44, label %$43
$44:
  %293 = phi i64 [%288, %$41] ; # N1
  %294 = phi i64 [%289, %$41] ; # X1
  %295 = phi i64 [%290, %$41] ; # N2
  %296 = phi i64 [%291, %$41] ; # X2
; # (equal X1 X2)
  %297 = call i1 @equal(i64 %294, i64 %296)
  br label %$24
$43:
  %298 = phi i64 [%288, %$41] ; # N1
  %299 = phi i64 [%289, %$41] ; # X1
  %300 = phi i64 [%290, %$41] ; # N2
  %301 = phi i64 [%291, %$41] ; # X2
; # (stkChk 0)
  %302 = load i8*, i8** @$StkLimit
  %303 = call i8* @llvm.stacksave()
  %304 = icmp ugt i8* %302, %303
  br i1 %304, label %$45, label %$46
$45:
  call void @stkErr(i64 0)
  unreachable
$46:
; # (let Env (val Penv) (or (and (unify N1 (car X1) N2 (car X2)) (uni...
; # (val Penv)
  %305 = inttoptr i64 %4 to i64*
  %306 = load i64, i64* %305
; # (or (and (unify N1 (car X1) N2 (car X2)) (unify N1 (cdr X1) N2 (c...
; # (and (unify N1 (car X1) N2 (car X2)) (unify N1 (cdr X1) N2 (cdr X...
; # (car X1)
  %307 = inttoptr i64 %299 to i64*
  %308 = load i64, i64* %307
; # (car X2)
  %309 = inttoptr i64 %301 to i64*
  %310 = load i64, i64* %309
; # (unify N1 (car X1) N2 (car X2))
  %311 = call i1 @unify(i64 %298, i64 %308, i64 %300, i64 %310)
  br i1 %311, label %$49, label %$48
$49:
  %312 = phi i64 [%298, %$46] ; # N1
  %313 = phi i64 [%299, %$46] ; # X1
  %314 = phi i64 [%300, %$46] ; # N2
  %315 = phi i64 [%301, %$46] ; # X2
; # (cdr X1)
  %316 = inttoptr i64 %313 to i64*
  %317 = getelementptr i64, i64* %316, i32 1
  %318 = load i64, i64* %317
; # (cdr X2)
  %319 = inttoptr i64 %315 to i64*
  %320 = getelementptr i64, i64* %319, i32 1
  %321 = load i64, i64* %320
; # (unify N1 (cdr X1) N2 (cdr X2))
  %322 = call i1 @unify(i64 %312, i64 %318, i64 %314, i64 %321)
  br label %$48
$48:
  %323 = phi i64 [%298, %$46], [%312, %$49] ; # N1
  %324 = phi i64 [%299, %$46], [%313, %$49] ; # X1
  %325 = phi i64 [%300, %$46], [%314, %$49] ; # N2
  %326 = phi i64 [%301, %$46], [%315, %$49] ; # X2
  %327 = phi i1 [0, %$46], [%322, %$49] ; # ->
  br i1 %327, label %$47, label %$50
$50:
  %328 = phi i64 [%323, %$48] ; # N1
  %329 = phi i64 [%324, %$48] ; # X1
  %330 = phi i64 [%325, %$48] ; # N2
  %331 = phi i64 [%326, %$48] ; # X2
; # (set Penv Env)
  %332 = inttoptr i64 %4 to i64*
  store i64 %306, i64* %332
  br label %$47
$47:
  %333 = phi i64 [%323, %$48], [%328, %$50] ; # N1
  %334 = phi i64 [%324, %$48], [%329, %$50] ; # X1
  %335 = phi i64 [%325, %$48], [%330, %$50] ; # N2
  %336 = phi i64 [%326, %$48], [%331, %$50] ; # X2
  %337 = phi i1 [1, %$48], [0, %$50] ; # ->
  br label %$24
$24:
  %338 = phi i64 [%200, %$28], [%236, %$34], [%272, %$40], [%293, %$44], [%333, %$47] ; # N1
  %339 = phi i64 [%201, %$28], [%237, %$34], [%273, %$40], [%294, %$44], [%334, %$47] ; # X1
  %340 = phi i64 [%202, %$28], [%238, %$34], [%274, %$40], [%295, %$44], [%335, %$47] ; # N2
  %341 = phi i64 [%203, %$28], [%239, %$34], [%275, %$40], [%296, %$44], [%336, %$47] ; # X2
  %342 = phi i1 [1, %$28], [1, %$34], [1, %$40], [%297, %$44], [%337, %$47] ; # ->
  ret i1 %342
}

define i64 @lup(i64, i64) {
$1:
; # (stkChk 0)
  %2 = load i8*, i8** @$StkLimit
  %3 = call i8* @llvm.stacksave()
  %4 = icmp ugt i8* %2, %3
  br i1 %4, label %$2, label %$3
$2:
  call void @stkErr(i64 0)
  unreachable
$3:
; # (let Penv (val $Penv) (: 1 (when (and (symb? X) (== (firstByte X)...
; # (val $Penv)
  %5 = load i64, i64* @$Penv
; # (: 1 (when (and (symb? X) (== (firstByte X) (char "@"))) (let V (...
  br label %$-1
$-1:
  %6 = phi i64 [%0, %$3], [%58, %$13] ; # N
  %7 = phi i64 [%1, %$3], [%61, %$13] ; # X
; # (when (and (symb? X) (== (firstByte X) (char "@"))) (let V (val P...
; # (and (symb? X) (== (firstByte X) (char "@")))
; # (symb? X)
  %8 = xor i64 %7, 8
  %9 = and i64 %8, 14
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %$5, label %$4
$5:
  %11 = phi i64 [%6, %$-1] ; # N
  %12 = phi i64 [%7, %$-1] ; # X
; # (firstByte X)
  %13 = call i8 @firstByte(i64 %12)
; # (== (firstByte X) (char "@"))
  %14 = icmp eq i8 %13, 64
  br label %$4
$4:
  %15 = phi i64 [%6, %$-1], [%11, %$5] ; # N
  %16 = phi i64 [%7, %$-1], [%12, %$5] ; # X
  %17 = phi i1 [0, %$-1], [%14, %$5] ; # ->
  br i1 %17, label %$6, label %$7
$6:
  %18 = phi i64 [%15, %$4] ; # N
  %19 = phi i64 [%16, %$4] ; # X
; # (let V (val Penv) (while (pair (car V)) (let (Y @ Z (car Y)) (whe...
; # (val Penv)
  %20 = inttoptr i64 %5 to i64*
  %21 = load i64, i64* %20
; # (while (pair (car V)) (let (Y @ Z (car Y)) (when (and (== N (car ...
  br label %$8
$8:
  %22 = phi i64 [%18, %$6], [%62, %$14] ; # N
  %23 = phi i64 [%19, %$6], [%63, %$14] ; # X
  %24 = phi i64 [%21, %$6], [%68, %$14] ; # V
; # (car V)
  %25 = inttoptr i64 %24 to i64*
  %26 = load i64, i64* %25
; # (pair (car V))
  %27 = and i64 %26, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$9, label %$10
$9:
  %29 = phi i64 [%22, %$8] ; # N
  %30 = phi i64 [%23, %$8] ; # X
  %31 = phi i64 [%24, %$8] ; # V
; # (let (Y @ Z (car Y)) (when (and (== N (car Z)) (== X (cdr Z))) (s...
; # (car Y)
  %32 = inttoptr i64 %26 to i64*
  %33 = load i64, i64* %32
; # (when (and (== N (car Z)) (== X (cdr Z))) (setq Z (cdr Y) N (car ...
; # (and (== N (car Z)) (== X (cdr Z)))
; # (car Z)
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (== N (car Z))
  %36 = icmp eq i64 %29, %35
  br i1 %36, label %$12, label %$11
$12:
  %37 = phi i64 [%29, %$9] ; # N
  %38 = phi i64 [%30, %$9] ; # X
  %39 = phi i64 [%31, %$9] ; # V
  %40 = phi i64 [%33, %$9] ; # Z
; # (cdr Z)
  %41 = inttoptr i64 %40 to i64*
  %42 = getelementptr i64, i64* %41, i32 1
  %43 = load i64, i64* %42
; # (== X (cdr Z))
  %44 = icmp eq i64 %38, %43
  br label %$11
$11:
  %45 = phi i64 [%29, %$9], [%37, %$12] ; # N
  %46 = phi i64 [%30, %$9], [%38, %$12] ; # X
  %47 = phi i64 [%31, %$9], [%39, %$12] ; # V
  %48 = phi i64 [%33, %$9], [%40, %$12] ; # Z
  %49 = phi i1 [0, %$9], [%44, %$12] ; # ->
  br i1 %49, label %$13, label %$14
$13:
  %50 = phi i64 [%45, %$11] ; # N
  %51 = phi i64 [%46, %$11] ; # X
  %52 = phi i64 [%47, %$11] ; # V
  %53 = phi i64 [%48, %$11] ; # Z
; # (cdr Y)
  %54 = inttoptr i64 %26 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  %56 = load i64, i64* %55
; # (car Z)
  %57 = inttoptr i64 %56 to i64*
  %58 = load i64, i64* %57
; # (cdr Z)
  %59 = inttoptr i64 %56 to i64*
  %60 = getelementptr i64, i64* %59, i32 1
  %61 = load i64, i64* %60
; # (goto 1)
  br label %$-1
$14:
  %62 = phi i64 [%45, %$11] ; # N
  %63 = phi i64 [%46, %$11] ; # X
  %64 = phi i64 [%47, %$11] ; # V
  %65 = phi i64 [%48, %$11] ; # Z
; # (shift V)
  %66 = inttoptr i64 %64 to i64*
  %67 = getelementptr i64, i64* %66, i32 1
  %68 = load i64, i64* %67
  br label %$8
$10:
  %69 = phi i64 [%22, %$8] ; # N
  %70 = phi i64 [%23, %$8] ; # X
  %71 = phi i64 [%24, %$8] ; # V
  br label %$7
$7:
  %72 = phi i64 [%15, %$4], [%69, %$10] ; # N
  %73 = phi i64 [%16, %$4], [%70, %$10] ; # X
; # (if (atom X) X (let Z (save (lup N (car X))) (cons Z (lup N (cdr ...
; # (atom X)
  %74 = and i64 %73, 15
  %75 = icmp ne i64 %74, 0
  br i1 %75, label %$15, label %$16
$15:
  %76 = phi i64 [%72, %$7] ; # N
  %77 = phi i64 [%73, %$7] ; # X
  br label %$17
$16:
  %78 = phi i64 [%72, %$7] ; # N
  %79 = phi i64 [%73, %$7] ; # X
; # (let Z (save (lup N (car X))) (cons Z (lup N (cdr X))))
; # (car X)
  %80 = inttoptr i64 %79 to i64*
  %81 = load i64, i64* %80
; # (lup N (car X))
  %82 = call i64 @lup(i64 %78, i64 %81)
; # (save (lup N (car X)))
  %83 = alloca i64, i64 2, align 16
  %84 = ptrtoint i64* %83 to i64
  %85 = inttoptr i64 %84 to i64*
  store i64 %82, i64* %85
  %86 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %87 = load i64, i64* %86
  %88 = inttoptr i64 %84 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  store i64 %87, i64* %89
  %90 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %84, i64* %90
; # (cdr X)
  %91 = inttoptr i64 %79 to i64*
  %92 = getelementptr i64, i64* %91, i32 1
  %93 = load i64, i64* %92
; # (lup N (cdr X))
  %94 = call i64 @lup(i64 %78, i64 %93)
; # (cons Z (lup N (cdr X)))
  %95 = call i64 @cons(i64 %82, i64 %94)
; # (drop *Safe)
  %96 = inttoptr i64 %84 to i64*
  %97 = getelementptr i64, i64* %96, i32 1
  %98 = load i64, i64* %97
  %99 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %98, i64* %99
  br label %$17
$17:
  %100 = phi i64 [%76, %$15], [%78, %$16] ; # N
  %101 = phi i64 [%77, %$15], [%79, %$16] ; # X
  %102 = phi i64 [%77, %$15], [%95, %$16] ; # ->
  ret i64 %102
}

define i64 @lookup(i64, i64) {
$1:
; # (if (and (symb? (setq X (lup N X))) (== (firstByte X) (char "@"))...
; # (and (symb? (setq X (lup N X))) (== (firstByte X) (char "@")))
; # (lup N X)
  %2 = call i64 @lup(i64 %0, i64 %1)
; # (symb? (setq X (lup N X)))
  %3 = xor i64 %2, 8
  %4 = and i64 %3, 14
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %$3, label %$2
$3:
  %6 = phi i64 [%2, %$1] ; # X
; # (firstByte X)
  %7 = call i8 @firstByte(i64 %6)
; # (== (firstByte X) (char "@"))
  %8 = icmp eq i8 %7, 64
  br label %$2
$2:
  %9 = phi i64 [%2, %$1], [%6, %$3] ; # X
  %10 = phi i1 [0, %$1], [%8, %$3] ; # ->
  br i1 %10, label %$4, label %$5
$4:
  %11 = phi i64 [%9, %$2] ; # X
  br label %$6
$5:
  %12 = phi i64 [%9, %$2] ; # X
  br label %$6
$6:
  %13 = phi i64 [%11, %$4], [%12, %$5] ; # X
  %14 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%12, %$5] ; # ->
  ret i64 %14
}

define i64 @uniFill(i64) {
$1:
; # (cond ((num? X) X) ((sym? X) (lup (car (val (val $Pnl))) X)) (T (...
; # (num? X)
  %1 = and i64 %0, 6
  %2 = icmp ne i64 %1, 0
  br i1 %2, label %$4, label %$3
$4:
  br label %$2
$3:
; # (sym? X)
  %3 = and i64 %0, 8
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$6, label %$5
$6:
; # (val $Pnl)
  %5 = load i64, i64* @$Pnl
; # (val (val $Pnl))
  %6 = inttoptr i64 %5 to i64*
  %7 = load i64, i64* %6
; # (car (val (val $Pnl)))
  %8 = inttoptr i64 %7 to i64*
  %9 = load i64, i64* %8
; # (lup (car (val (val $Pnl))) X)
  %10 = call i64 @lup(i64 %9, i64 %0)
  br label %$2
$5:
; # (stkChk 0)
  %11 = load i8*, i8** @$StkLimit
  %12 = call i8* @llvm.stacksave()
  %13 = icmp ugt i8* %11, %12
  br i1 %13, label %$7, label %$8
$7:
  call void @stkErr(i64 0)
  unreachable
$8:
; # (let Y (save (uniFill (car X))) (cons Y (uniFill (cdr X))))
; # (car X)
  %14 = inttoptr i64 %0 to i64*
  %15 = load i64, i64* %14
; # (uniFill (car X))
  %16 = call i64 @uniFill(i64 %15)
; # (save (uniFill (car X)))
  %17 = alloca i64, i64 2, align 16
  %18 = ptrtoint i64* %17 to i64
  %19 = inttoptr i64 %18 to i64*
  store i64 %16, i64* %19
  %20 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %21 = load i64, i64* %20
  %22 = inttoptr i64 %18 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  store i64 %21, i64* %23
  %24 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %18, i64* %24
; # (cdr X)
  %25 = inttoptr i64 %0 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (uniFill (cdr X))
  %28 = call i64 @uniFill(i64 %27)
; # (cons Y (uniFill (cdr X)))
  %29 = call i64 @cons(i64 %16, i64 %28)
; # (drop *Safe)
  %30 = inttoptr i64 %18 to i64*
  %31 = getelementptr i64, i64* %30, i32 1
  %32 = load i64, i64* %31
  %33 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %32, i64* %33
  br label %$2
$2:
  %34 = phi i64 [%0, %$4], [%10, %$6], [%29, %$8] ; # ->
  ret i64 %34
}

define i64 @_prove(i64) {
$1:
; # (let X (cdr Exe) (if (atom (eval (car X))) $Nil (let (Q (save @) ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom (eval (car X))) $Nil (let (Q (save @) Dbg (if (nil? (ev...
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (car X))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (atom (eval (car X)))
  %14 = and i64 %13, 15
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$7, label %$8
$7:
  %16 = phi i64 [%3, %$2] ; # X
  br label %$9
$8:
  %17 = phi i64 [%3, %$2] ; # X
; # (let (Q (save @) Dbg (if (nil? (eval (cadr X))) 0 (save @)) P (pr...
; # (save @)
  %18 = alloca i64, i64 2, align 16
  %19 = ptrtoint i64* %18 to i64
  %20 = inttoptr i64 %19 to i64*
  store i64 %13, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %22 = load i64, i64* %21
  %23 = inttoptr i64 %19 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  store i64 %22, i64* %24
  %25 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %19, i64* %25
; # (if (nil? (eval (cadr X))) 0 (save @))
; # (cadr X)
  %26 = inttoptr i64 %17 to i64*
  %27 = getelementptr i64, i64* %26, i32 1
  %28 = load i64, i64* %27
  %29 = inttoptr i64 %28 to i64*
  %30 = load i64, i64* %29
; # (eval (cadr X))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$12, label %$11
$12:
  br label %$10
$11:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$14, label %$13
$14:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$10
$13:
  %37 = call i64 @evList(i64 %30)
  br label %$10
$10:
  %38 = phi i64 [%30, %$12], [%36, %$14], [%37, %$13] ; # ->
; # (nil? (eval (cadr X)))
  %39 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %39, label %$15, label %$16
$15:
  %40 = phi i64 [%17, %$10] ; # X
  br label %$17
$16:
  %41 = phi i64 [%17, %$10] ; # X
; # (save @)
  %42 = alloca i64, i64 2, align 16
  %43 = ptrtoint i64* %42 to i64
  %44 = inttoptr i64 %43 to i64*
  store i64 %38, i64* %44
  %45 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %43 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  store i64 %46, i64* %48
  %49 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %43, i64* %49
  br label %$17
$17:
  %50 = phi i64 [%40, %$15], [%41, %$16] ; # X
  %51 = phi i64 [0, %$15], [%38, %$16] ; # ->
; # (prog1 (caar Q) (set Q (cdar Q)))
; # (caar Q)
  %52 = inttoptr i64 %13 to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %53 to i64*
  %55 = load i64, i64* %54
; # (set Q (cdar Q))
; # (cdar Q)
  %56 = inttoptr i64 %13 to i64*
  %57 = load i64, i64* %56
  %58 = inttoptr i64 %57 to i64*
  %59 = getelementptr i64, i64* %58, i32 1
  %60 = load i64, i64* %59
  %61 = inttoptr i64 %13 to i64*
  store i64 %60, i64* %61
; # (++ P)
  %62 = inttoptr i64 %55 to i64*
  %63 = load i64, i64* %62
  %64 = getelementptr i64, i64* %62, i32 1
  %65 = load i64, i64* %64
; # (++ P)
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
  %68 = getelementptr i64, i64* %66, i32 1
  %69 = load i64, i64* %68
; # (push (++ P) NIL)
  %70 = alloca i64, i64 2, align 16
  %71 = ptrtoint i64* %70 to i64
  %72 = inttoptr i64 %71 to i64*
  store i64 %67, i64* %72
; # (link (push (++ P) NIL))
  %73 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %74 = load i64, i64* %73
  %75 = inttoptr i64 %71 to i64*
  %76 = getelementptr i64, i64* %75, i32 1
  store i64 %74, i64* %76
  %77 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %71, i64* %77
; # (++ P)
  %78 = inttoptr i64 %69 to i64*
  %79 = load i64, i64* %78
  %80 = getelementptr i64, i64* %78, i32 1
  %81 = load i64, i64* %80
; # (push (++ P) NIL)
  %82 = alloca i64, i64 2, align 16
  %83 = ptrtoint i64* %82 to i64
  %84 = inttoptr i64 %83 to i64*
  store i64 %79, i64* %84
; # (link (push (++ P) NIL))
  %85 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %86 = load i64, i64* %85
  %87 = inttoptr i64 %83 to i64*
  %88 = getelementptr i64, i64* %87, i32 1
  store i64 %86, i64* %88
  %89 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %89
; # (++ P)
  %90 = inttoptr i64 %81 to i64*
  %91 = load i64, i64* %90
  %92 = getelementptr i64, i64* %90, i32 1
  %93 = load i64, i64* %92
; # (push (++ P) NIL)
  %94 = alloca i64, i64 2, align 16
  %95 = ptrtoint i64* %94 to i64
  %96 = inttoptr i64 %95 to i64*
  store i64 %91, i64* %96
; # (link (push (++ P) NIL))
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %98 = load i64, i64* %97
  %99 = inttoptr i64 %95 to i64*
  %100 = getelementptr i64, i64* %99, i32 1
  store i64 %98, i64* %100
  %101 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %95, i64* %101
; # (++ P)
  %102 = inttoptr i64 %93 to i64*
  %103 = load i64, i64* %102
  %104 = getelementptr i64, i64* %102, i32 1
  %105 = load i64, i64* %104
; # (push (++ P) NIL)
  %106 = alloca i64, i64 2, align 16
  %107 = ptrtoint i64* %106 to i64
  %108 = inttoptr i64 %107 to i64*
  store i64 %103, i64* %108
; # (link (push (++ P) NIL))
  %109 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %110 = load i64, i64* %109
  %111 = inttoptr i64 %107 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  store i64 %110, i64* %112
  %113 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %107, i64* %113
; # (push P NIL)
  %114 = alloca i64, i64 2, align 16
  %115 = ptrtoint i64* %114 to i64
  %116 = inttoptr i64 %115 to i64*
  store i64 %105, i64* %116
; # (link (push P NIL))
  %117 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %118 = load i64, i64* %117
  %119 = inttoptr i64 %115 to i64*
  %120 = getelementptr i64, i64* %119, i32 1
  store i64 %118, i64* %120
  %121 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %115, i64* %121
; # (push $Nil NIL)
  %122 = alloca i64, i64 2, align 16
  %123 = ptrtoint i64* %122 to i64
  %124 = inttoptr i64 %123 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %124
; # (link (push $Nil NIL))
  %125 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %126 = load i64, i64* %125
  %127 = inttoptr i64 %123 to i64*
  %128 = getelementptr i64, i64* %127, i32 1
  store i64 %126, i64* %128
  %129 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %123, i64* %129
; # (val $At)
  %130 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %131 = load i64, i64* %130
; # (save (val $At))
  %132 = alloca i64, i64 2, align 16
  %133 = ptrtoint i64* %132 to i64
  %134 = inttoptr i64 %133 to i64*
  store i64 %131, i64* %134
  %135 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %136 = load i64, i64* %135
  %137 = inttoptr i64 %133 to i64*
  %138 = getelementptr i64, i64* %137, i32 1
  store i64 %136, i64* %138
  %139 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %133, i64* %139
; # (val $Penv)
  %140 = load i64, i64* @$Penv
; # (val $Pnl)
  %141 = load i64, i64* @$Pnl
; # (set $Penv Env $Pnl Nl)
  store i64 %115, i64* @$Penv
  store i64 %71, i64* @$Pnl
; # (while (or (pair (val Tp1)) (pair (val Tp2))) (cond ((pair (val A...
  br label %$18
$18:
  %142 = phi i64 [%50, %$17], [%696, %$23] ; # X
  %143 = phi i64 [%105, %$17], [%697, %$23] ; # P
  %144 = phi i64 [%63, %$17], [%698, %$23] ; # N
; # (or (pair (val Tp1)) (pair (val Tp2)))
; # (val Tp1)
  %145 = inttoptr i64 %95 to i64*
  %146 = load i64, i64* %145
; # (pair (val Tp1))
  %147 = and i64 %146, 15
  %148 = icmp eq i64 %147, 0
  br i1 %148, label %$19, label %$20
$20:
  %149 = phi i64 [%142, %$18] ; # X
  %150 = phi i64 [%143, %$18] ; # P
  %151 = phi i64 [%144, %$18] ; # N
; # (val Tp2)
  %152 = inttoptr i64 %107 to i64*
  %153 = load i64, i64* %152
; # (pair (val Tp2))
  %154 = and i64 %153, 15
  %155 = icmp eq i64 %154, 0
  br label %$19
$19:
  %156 = phi i64 [%142, %$18], [%149, %$20] ; # X
  %157 = phi i64 [%143, %$18], [%150, %$20] ; # P
  %158 = phi i64 [%144, %$18], [%151, %$20] ; # N
  %159 = phi i1 [1, %$18], [%155, %$20] ; # ->
  br i1 %159, label %$21, label %$22
$21:
  %160 = phi i64 [%156, %$19] ; # X
  %161 = phi i64 [%157, %$19] ; # P
  %162 = phi i64 [%158, %$19] ; # N
; # (cond ((pair (val Alt)) (set E (val Env)) (ifn (unify (car (val N...
; # (val Alt)
  %163 = inttoptr i64 %83 to i64*
  %164 = load i64, i64* %163
; # (pair (val Alt))
  %165 = and i64 %164, 15
  %166 = icmp eq i64 %165, 0
  br i1 %166, label %$25, label %$24
$25:
  %167 = phi i64 [%160, %$21] ; # X
  %168 = phi i64 [%161, %$21] ; # P
  %169 = phi i64 [%162, %$21] ; # N
; # (set E (val Env))
; # (val Env)
  %170 = inttoptr i64 %115 to i64*
  %171 = load i64, i64* %170
  %172 = inttoptr i64 %123 to i64*
  store i64 %171, i64* %172
; # (ifn (unify (car (val Nl)) (cdar (val Tp1)) N (caar (val Alt))) (...
; # (val Nl)
  %173 = inttoptr i64 %71 to i64*
  %174 = load i64, i64* %173
; # (car (val Nl))
  %175 = inttoptr i64 %174 to i64*
  %176 = load i64, i64* %175
; # (val Tp1)
  %177 = inttoptr i64 %95 to i64*
  %178 = load i64, i64* %177
; # (cdar (val Tp1))
  %179 = inttoptr i64 %178 to i64*
  %180 = load i64, i64* %179
  %181 = inttoptr i64 %180 to i64*
  %182 = getelementptr i64, i64* %181, i32 1
  %183 = load i64, i64* %182
; # (val Alt)
  %184 = inttoptr i64 %83 to i64*
  %185 = load i64, i64* %184
; # (caar (val Alt))
  %186 = inttoptr i64 %185 to i64*
  %187 = load i64, i64* %186
  %188 = inttoptr i64 %187 to i64*
  %189 = load i64, i64* %188
; # (unify (car (val Nl)) (cdar (val Tp1)) N (caar (val Alt)))
  %190 = call i1 @unify(i64 %176, i64 %183, i64 %169, i64 %189)
  br i1 %190, label %$27, label %$26
$26:
  %191 = phi i64 [%167, %$25] ; # X
  %192 = phi i64 [%168, %$25] ; # P
  %193 = phi i64 [%169, %$25] ; # N
; # (when (atom (set Alt (cdr (val Alt)))) (setq P (caar Q)) (set Q (...
; # (set Alt (cdr (val Alt)))
; # (val Alt)
  %194 = inttoptr i64 %83 to i64*
  %195 = load i64, i64* %194
; # (cdr (val Alt))
  %196 = inttoptr i64 %195 to i64*
  %197 = getelementptr i64, i64* %196, i32 1
  %198 = load i64, i64* %197
  %199 = inttoptr i64 %83 to i64*
  store i64 %198, i64* %199
; # (atom (set Alt (cdr (val Alt))))
  %200 = and i64 %198, 15
  %201 = icmp ne i64 %200, 0
  br i1 %201, label %$29, label %$30
$29:
  %202 = phi i64 [%191, %$26] ; # X
  %203 = phi i64 [%192, %$26] ; # P
  %204 = phi i64 [%193, %$26] ; # N
; # (caar Q)
  %205 = inttoptr i64 %13 to i64*
  %206 = load i64, i64* %205
  %207 = inttoptr i64 %206 to i64*
  %208 = load i64, i64* %207
; # (set Q (cdar Q))
; # (cdar Q)
  %209 = inttoptr i64 %13 to i64*
  %210 = load i64, i64* %209
  %211 = inttoptr i64 %210 to i64*
  %212 = getelementptr i64, i64* %211, i32 1
  %213 = load i64, i64* %212
  %214 = inttoptr i64 %13 to i64*
  store i64 %213, i64* %214
; # (++ P)
  %215 = inttoptr i64 %208 to i64*
  %216 = load i64, i64* %215
  %217 = getelementptr i64, i64* %215, i32 1
  %218 = load i64, i64* %217
; # (set Nl (++ P) Alt (++ P) Tp1 (++ P) Tp2 (++ P) Env P)
; # (++ P)
  %219 = inttoptr i64 %218 to i64*
  %220 = load i64, i64* %219
  %221 = getelementptr i64, i64* %219, i32 1
  %222 = load i64, i64* %221
  %223 = inttoptr i64 %71 to i64*
  store i64 %220, i64* %223
; # (++ P)
  %224 = inttoptr i64 %222 to i64*
  %225 = load i64, i64* %224
  %226 = getelementptr i64, i64* %224, i32 1
  %227 = load i64, i64* %226
  %228 = inttoptr i64 %83 to i64*
  store i64 %225, i64* %228
; # (++ P)
  %229 = inttoptr i64 %227 to i64*
  %230 = load i64, i64* %229
  %231 = getelementptr i64, i64* %229, i32 1
  %232 = load i64, i64* %231
  %233 = inttoptr i64 %95 to i64*
  store i64 %230, i64* %233
; # (++ P)
  %234 = inttoptr i64 %232 to i64*
  %235 = load i64, i64* %234
  %236 = getelementptr i64, i64* %234, i32 1
  %237 = load i64, i64* %236
  %238 = inttoptr i64 %107 to i64*
  store i64 %235, i64* %238
  %239 = inttoptr i64 %115 to i64*
  store i64 %237, i64* %239
  br label %$30
$30:
  %240 = phi i64 [%191, %$26], [%202, %$29] ; # X
  %241 = phi i64 [%192, %$26], [%237, %$29] ; # P
  %242 = phi i64 [%193, %$26], [%216, %$29] ; # N
  br label %$28
$27:
  %243 = phi i64 [%167, %$25] ; # X
  %244 = phi i64 [%168, %$25] ; # P
  %245 = phi i64 [%169, %$25] ; # N
; # (when Dbg (let Y (car (val Tp1)) (when (memq (car Y) Dbg) (let (L...
  %246 = icmp ne i64 %51, 0
  br i1 %246, label %$31, label %$32
$31:
  %247 = phi i64 [%243, %$27] ; # X
  %248 = phi i64 [%244, %$27] ; # P
  %249 = phi i64 [%245, %$27] ; # N
; # (let Y (car (val Tp1)) (when (memq (car Y) Dbg) (let (L (get (car...
; # (val Tp1)
  %250 = inttoptr i64 %95 to i64*
  %251 = load i64, i64* %250
; # (car (val Tp1))
  %252 = inttoptr i64 %251 to i64*
  %253 = load i64, i64* %252
; # (when (memq (car Y) Dbg) (let (L (get (car Y) $T) I 1) (until (eq...
; # (car Y)
  %254 = inttoptr i64 %253 to i64*
  %255 = load i64, i64* %254
; # (memq (car Y) Dbg)
  br label %$33
$33:
  %256 = phi i64 [%51, %$31], [%268, %$37] ; # L
  %257 = and i64 %256, 15
  %258 = icmp ne i64 %257, 0
  br i1 %258, label %$36, label %$34
$36:
  %259 = phi i64 [%256, %$33] ; # L
  br label %$35
$34:
  %260 = phi i64 [%256, %$33] ; # L
  %261 = inttoptr i64 %260 to i64*
  %262 = load i64, i64* %261
  %263 = icmp eq i64 %255, %262
  br i1 %263, label %$38, label %$37
$38:
  %264 = phi i64 [%260, %$34] ; # L
  br label %$35
$37:
  %265 = phi i64 [%260, %$34] ; # L
  %266 = inttoptr i64 %265 to i64*
  %267 = getelementptr i64, i64* %266, i32 1
  %268 = load i64, i64* %267
  br label %$33
$35:
  %269 = phi i64 [%259, %$36], [%264, %$38] ; # L
  %270 = phi i1 [0, %$36], [1, %$38] ; # ->
  br i1 %270, label %$39, label %$40
$39:
  %271 = phi i64 [%247, %$35] ; # X
  %272 = phi i64 [%248, %$35] ; # P
  %273 = phi i64 [%249, %$35] ; # N
; # (let (L (get (car Y) $T) I 1) (until (equal (car (val Alt)) (car ...
; # (car Y)
  %274 = inttoptr i64 %253 to i64*
  %275 = load i64, i64* %274
; # (get (car Y) $T)
  %276 = call i64 @get(i64 %275, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64))
; # (until (equal (car (val Alt)) (car L)) (inc 'I) (shift L))
  br label %$41
$41:
  %277 = phi i64 [%271, %$39], [%289, %$42] ; # X
  %278 = phi i64 [%272, %$39], [%290, %$42] ; # P
  %279 = phi i64 [%273, %$39], [%291, %$42] ; # N
  %280 = phi i64 [%276, %$39], [%297, %$42] ; # L
  %281 = phi i64 [1, %$39], [%294, %$42] ; # I
; # (val Alt)
  %282 = inttoptr i64 %83 to i64*
  %283 = load i64, i64* %282
; # (car (val Alt))
  %284 = inttoptr i64 %283 to i64*
  %285 = load i64, i64* %284
; # (car L)
  %286 = inttoptr i64 %280 to i64*
  %287 = load i64, i64* %286
; # (equal (car (val Alt)) (car L))
  %288 = call i1 @equal(i64 %285, i64 %287)
  br i1 %288, label %$43, label %$42
$42:
  %289 = phi i64 [%277, %$41] ; # X
  %290 = phi i64 [%278, %$41] ; # P
  %291 = phi i64 [%279, %$41] ; # N
  %292 = phi i64 [%280, %$41] ; # L
  %293 = phi i64 [%281, %$41] ; # I
; # (inc 'I)
  %294 = add i64 %293, 1
; # (shift L)
  %295 = inttoptr i64 %292 to i64*
  %296 = getelementptr i64, i64* %295, i32 1
  %297 = load i64, i64* %296
  br label %$41
$43:
  %298 = phi i64 [%277, %$41] ; # X
  %299 = phi i64 [%278, %$41] ; # P
  %300 = phi i64 [%279, %$41] ; # N
  %301 = phi i64 [%280, %$41] ; # L
  %302 = phi i64 [%281, %$41] ; # I
; # (outWord I)
  call void @outWord(i64 %302)
; # (space)
  call void @space()
; # (uniFill Y)
  %303 = call i64 @uniFill(i64 %253)
; # (print (uniFill Y))
  call void @print(i64 %303)
; # (newline)
  call void @newline()
  br label %$40
$40:
  %304 = phi i64 [%247, %$35], [%298, %$43] ; # X
  %305 = phi i64 [%248, %$35], [%299, %$43] ; # P
  %306 = phi i64 [%249, %$35], [%300, %$43] ; # N
  br label %$32
$32:
  %307 = phi i64 [%243, %$27], [%304, %$40] ; # X
  %308 = phi i64 [%244, %$27], [%305, %$40] ; # P
  %309 = phi i64 [%245, %$27], [%306, %$40] ; # N
; # (when (pair (cdr (val Alt))) (set Q (cons (cons N (cons (val Nl) ...
; # (val Alt)
  %310 = inttoptr i64 %83 to i64*
  %311 = load i64, i64* %310
; # (cdr (val Alt))
  %312 = inttoptr i64 %311 to i64*
  %313 = getelementptr i64, i64* %312, i32 1
  %314 = load i64, i64* %313
; # (pair (cdr (val Alt)))
  %315 = and i64 %314, 15
  %316 = icmp eq i64 %315, 0
  br i1 %316, label %$44, label %$45
$44:
  %317 = phi i64 [%307, %$32] ; # X
  %318 = phi i64 [%308, %$32] ; # P
  %319 = phi i64 [%309, %$32] ; # N
; # (set Q (cons (cons N (cons (val Nl) (cons @ (cons (val Tp1) (cons...
; # (val Nl)
  %320 = inttoptr i64 %71 to i64*
  %321 = load i64, i64* %320
; # (val Tp1)
  %322 = inttoptr i64 %95 to i64*
  %323 = load i64, i64* %322
; # (val Tp2)
  %324 = inttoptr i64 %107 to i64*
  %325 = load i64, i64* %324
; # (val E)
  %326 = inttoptr i64 %123 to i64*
  %327 = load i64, i64* %326
; # (cons (val Tp2) (val E))
  %328 = call i64 @cons(i64 %325, i64 %327)
; # (cons (val Tp1) (cons (val Tp2) (val E)))
  %329 = call i64 @cons(i64 %323, i64 %328)
; # (cons @ (cons (val Tp1) (cons (val Tp2) (val E))))
  %330 = call i64 @cons(i64 %314, i64 %329)
; # (cons (val Nl) (cons @ (cons (val Tp1) (cons (val Tp2) (val E))))...
  %331 = call i64 @cons(i64 %321, i64 %330)
; # (cons N (cons (val Nl) (cons @ (cons (val Tp1) (cons (val Tp2) (v...
  %332 = call i64 @cons(i64 %319, i64 %331)
; # (car Q)
  %333 = inttoptr i64 %13 to i64*
  %334 = load i64, i64* %333
; # (cons (cons N (cons (val Nl) (cons @ (cons (val Tp1) (cons (val T...
  %335 = call i64 @cons(i64 %332, i64 %334)
  %336 = inttoptr i64 %13 to i64*
  store i64 %335, i64* %336
  br label %$45
$45:
  %337 = phi i64 [%307, %$32], [%317, %$44] ; # X
  %338 = phi i64 [%308, %$32], [%318, %$44] ; # P
  %339 = phi i64 [%309, %$32], [%319, %$44] ; # N
; # (set Nl (cons N (val Nl)) Tp2 (cons (cdr (val Tp1)) (val Tp2)) Tp...
; # (val Nl)
  %340 = inttoptr i64 %71 to i64*
  %341 = load i64, i64* %340
; # (cons N (val Nl))
  %342 = call i64 @cons(i64 %339, i64 %341)
  %343 = inttoptr i64 %71 to i64*
  store i64 %342, i64* %343
; # (val Tp1)
  %344 = inttoptr i64 %95 to i64*
  %345 = load i64, i64* %344
; # (cdr (val Tp1))
  %346 = inttoptr i64 %345 to i64*
  %347 = getelementptr i64, i64* %346, i32 1
  %348 = load i64, i64* %347
; # (val Tp2)
  %349 = inttoptr i64 %107 to i64*
  %350 = load i64, i64* %349
; # (cons (cdr (val Tp1)) (val Tp2))
  %351 = call i64 @cons(i64 %348, i64 %350)
  %352 = inttoptr i64 %107 to i64*
  store i64 %351, i64* %352
; # (val Alt)
  %353 = inttoptr i64 %83 to i64*
  %354 = load i64, i64* %353
; # (cdar (val Alt))
  %355 = inttoptr i64 %354 to i64*
  %356 = load i64, i64* %355
  %357 = inttoptr i64 %356 to i64*
  %358 = getelementptr i64, i64* %357, i32 1
  %359 = load i64, i64* %358
  %360 = inttoptr i64 %95 to i64*
  store i64 %359, i64* %360
  %361 = inttoptr i64 %83 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %361
; # (inc 'N (hex "10"))
  %362 = add i64 %339, 16
  br label %$28
$28:
  %363 = phi i64 [%240, %$30], [%337, %$45] ; # X
  %364 = phi i64 [%241, %$30], [%338, %$45] ; # P
  %365 = phi i64 [%242, %$30], [%362, %$45] ; # N
  br label %$23
$24:
  %366 = phi i64 [%160, %$21] ; # X
  %367 = phi i64 [%161, %$21] ; # P
  %368 = phi i64 [%162, %$21] ; # N
; # (val Tp1)
  %369 = inttoptr i64 %95 to i64*
  %370 = load i64, i64* %369
; # (atom (setq X (val Tp1)))
  %371 = and i64 %370, 15
  %372 = icmp ne i64 %371, 0
  br i1 %372, label %$47, label %$46
$47:
  %373 = phi i64 [%370, %$24] ; # X
  %374 = phi i64 [%367, %$24] ; # P
  %375 = phi i64 [%368, %$24] ; # N
; # (set Tp1 (car (val Tp2)) Tp2 (cdr (val Tp2)) Nl (cdr (val Nl)))
; # (val Tp2)
  %376 = inttoptr i64 %107 to i64*
  %377 = load i64, i64* %376
; # (car (val Tp2))
  %378 = inttoptr i64 %377 to i64*
  %379 = load i64, i64* %378
  %380 = inttoptr i64 %95 to i64*
  store i64 %379, i64* %380
; # (val Tp2)
  %381 = inttoptr i64 %107 to i64*
  %382 = load i64, i64* %381
; # (cdr (val Tp2))
  %383 = inttoptr i64 %382 to i64*
  %384 = getelementptr i64, i64* %383, i32 1
  %385 = load i64, i64* %384
  %386 = inttoptr i64 %107 to i64*
  store i64 %385, i64* %386
; # (val Nl)
  %387 = inttoptr i64 %71 to i64*
  %388 = load i64, i64* %387
; # (cdr (val Nl))
  %389 = inttoptr i64 %388 to i64*
  %390 = getelementptr i64, i64* %389, i32 1
  %391 = load i64, i64* %390
  %392 = inttoptr i64 %71 to i64*
  store i64 %391, i64* %392
  br label %$23
$46:
  %393 = phi i64 [%370, %$24] ; # X
  %394 = phi i64 [%367, %$24] ; # P
  %395 = phi i64 [%368, %$24] ; # N
; # (car X)
  %396 = inttoptr i64 %393 to i64*
  %397 = load i64, i64* %396
; # (t? (car X))
  %398 = icmp eq i64 %397, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %398, label %$49, label %$48
$49:
  %399 = phi i64 [%393, %$46] ; # X
  %400 = phi i64 [%394, %$46] ; # P
  %401 = phi i64 [%395, %$46] ; # N
; # (while (and (pair (car Q)) (>= (caar @) (car (val Nl)))) (set Q (...
  br label %$50
$50:
  %402 = phi i64 [%399, %$49], [%425, %$53] ; # X
  %403 = phi i64 [%400, %$49], [%426, %$53] ; # P
  %404 = phi i64 [%401, %$49], [%427, %$53] ; # N
; # (and (pair (car Q)) (>= (caar @) (car (val Nl))))
; # (car Q)
  %405 = inttoptr i64 %13 to i64*
  %406 = load i64, i64* %405
; # (pair (car Q))
  %407 = and i64 %406, 15
  %408 = icmp eq i64 %407, 0
  br i1 %408, label %$52, label %$51
$52:
  %409 = phi i64 [%402, %$50] ; # X
  %410 = phi i64 [%403, %$50] ; # P
  %411 = phi i64 [%404, %$50] ; # N
; # (caar @)
  %412 = inttoptr i64 %406 to i64*
  %413 = load i64, i64* %412
  %414 = inttoptr i64 %413 to i64*
  %415 = load i64, i64* %414
; # (val Nl)
  %416 = inttoptr i64 %71 to i64*
  %417 = load i64, i64* %416
; # (car (val Nl))
  %418 = inttoptr i64 %417 to i64*
  %419 = load i64, i64* %418
; # (>= (caar @) (car (val Nl)))
  %420 = icmp uge i64 %415, %419
  br label %$51
$51:
  %421 = phi i64 [%402, %$50], [%409, %$52] ; # X
  %422 = phi i64 [%403, %$50], [%410, %$52] ; # P
  %423 = phi i64 [%404, %$50], [%411, %$52] ; # N
  %424 = phi i1 [0, %$50], [%420, %$52] ; # ->
  br i1 %424, label %$53, label %$54
$53:
  %425 = phi i64 [%421, %$51] ; # X
  %426 = phi i64 [%422, %$51] ; # P
  %427 = phi i64 [%423, %$51] ; # N
; # (set Q (cdar Q))
; # (cdar Q)
  %428 = inttoptr i64 %13 to i64*
  %429 = load i64, i64* %428
  %430 = inttoptr i64 %429 to i64*
  %431 = getelementptr i64, i64* %430, i32 1
  %432 = load i64, i64* %431
  %433 = inttoptr i64 %13 to i64*
  store i64 %432, i64* %433
  br label %$50
$54:
  %434 = phi i64 [%421, %$51] ; # X
  %435 = phi i64 [%422, %$51] ; # P
  %436 = phi i64 [%423, %$51] ; # N
; # (set Tp1 (cdr X))
; # (cdr X)
  %437 = inttoptr i64 %434 to i64*
  %438 = getelementptr i64, i64* %437, i32 1
  %439 = load i64, i64* %438
  %440 = inttoptr i64 %95 to i64*
  store i64 %439, i64* %440
  br label %$23
$48:
  %441 = phi i64 [%393, %$46] ; # X
  %442 = phi i64 [%394, %$46] ; # P
  %443 = phi i64 [%395, %$46] ; # N
; # (car @)
  %444 = inttoptr i64 %397 to i64*
  %445 = load i64, i64* %444
; # (cnt? (car @))
  %446 = and i64 %445, 2
  %447 = icmp ne i64 %446, 0
  br i1 %447, label %$56, label %$55
$56:
  %448 = phi i64 [%441, %$48] ; # X
  %449 = phi i64 [%442, %$48] ; # P
  %450 = phi i64 [%443, %$48] ; # N
; # (set E (run (cdar X)))
; # (cdar X)
  %451 = inttoptr i64 %448 to i64*
  %452 = load i64, i64* %451
  %453 = inttoptr i64 %452 to i64*
  %454 = getelementptr i64, i64* %453, i32 1
  %455 = load i64, i64* %454
; # (run (cdar X))
  br label %$57
$57:
  %456 = phi i64 [%455, %$56], [%478, %$66] ; # Prg
  %457 = inttoptr i64 %456 to i64*
  %458 = load i64, i64* %457
  %459 = getelementptr i64, i64* %457, i32 1
  %460 = load i64, i64* %459
  %461 = and i64 %460, 15
  %462 = icmp ne i64 %461, 0
  br i1 %462, label %$60, label %$58
$60:
  %463 = phi i64 [%460, %$57] ; # Prg
  %464 = and i64 %458, 6
  %465 = icmp ne i64 %464, 0
  br i1 %465, label %$63, label %$62
$63:
  br label %$61
$62:
  %466 = and i64 %458, 8
  %467 = icmp ne i64 %466, 0
  br i1 %467, label %$65, label %$64
$65:
  %468 = inttoptr i64 %458 to i64*
  %469 = load i64, i64* %468
  br label %$61
$64:
  %470 = call i64 @evList(i64 %458)
  br label %$61
$61:
  %471 = phi i64 [%458, %$63], [%469, %$65], [%470, %$64] ; # ->
  br label %$59
$58:
  %472 = phi i64 [%460, %$57] ; # Prg
  %473 = and i64 %458, 15
  %474 = icmp eq i64 %473, 0
  br i1 %474, label %$67, label %$66
$67:
  %475 = phi i64 [%472, %$58] ; # Prg
  %476 = call i64 @evList(i64 %458)
  %477 = icmp ne i64 %476, 0
  br label %$66
$66:
  %478 = phi i64 [%472, %$58], [%475, %$67] ; # Prg
  %479 = phi i1 [0, %$58], [%477, %$67] ; # ->
  br label %$57
$59:
  %480 = phi i64 [%463, %$61] ; # Prg
  %481 = phi i64 [%471, %$61] ; # ->
  %482 = inttoptr i64 %123 to i64*
  store i64 %481, i64* %482
; # (let (I (int (caar X)) Y (val Nl)) (while (gt0 (dec 'I)) (shift Y...
; # (caar X)
  %483 = inttoptr i64 %448 to i64*
  %484 = load i64, i64* %483
  %485 = inttoptr i64 %484 to i64*
  %486 = load i64, i64* %485
; # (int (caar X))
  %487 = lshr i64 %486, 4
; # (val Nl)
  %488 = inttoptr i64 %71 to i64*
  %489 = load i64, i64* %488
; # (while (gt0 (dec 'I)) (shift Y))
  br label %$68
$68:
  %490 = phi i64 [%448, %$59], [%497, %$69] ; # X
  %491 = phi i64 [%449, %$59], [%498, %$69] ; # P
  %492 = phi i64 [%450, %$59], [%499, %$69] ; # N
  %493 = phi i64 [%487, %$59], [%500, %$69] ; # I
  %494 = phi i64 [%489, %$59], [%504, %$69] ; # Y
; # (dec 'I)
  %495 = sub i64 %493, 1
; # (gt0 (dec 'I))
  %496 = icmp sgt i64 %495, 0
  br i1 %496, label %$69, label %$70
$69:
  %497 = phi i64 [%490, %$68] ; # X
  %498 = phi i64 [%491, %$68] ; # P
  %499 = phi i64 [%492, %$68] ; # N
  %500 = phi i64 [%495, %$68] ; # I
  %501 = phi i64 [%494, %$68] ; # Y
; # (shift Y)
  %502 = inttoptr i64 %501 to i64*
  %503 = getelementptr i64, i64* %502, i32 1
  %504 = load i64, i64* %503
  br label %$68
$70:
  %505 = phi i64 [%490, %$68] ; # X
  %506 = phi i64 [%491, %$68] ; # P
  %507 = phi i64 [%492, %$68] ; # N
  %508 = phi i64 [%495, %$68] ; # I
  %509 = phi i64 [%494, %$68] ; # Y
; # (set Nl (cons (car Y) (val Nl)) Tp2 (cons (cdr X) (val Tp2)) Tp1 ...
; # (car Y)
  %510 = inttoptr i64 %509 to i64*
  %511 = load i64, i64* %510
; # (val Nl)
  %512 = inttoptr i64 %71 to i64*
  %513 = load i64, i64* %512
; # (cons (car Y) (val Nl))
  %514 = call i64 @cons(i64 %511, i64 %513)
  %515 = inttoptr i64 %71 to i64*
  store i64 %514, i64* %515
; # (cdr X)
  %516 = inttoptr i64 %505 to i64*
  %517 = getelementptr i64, i64* %516, i32 1
  %518 = load i64, i64* %517
; # (val Tp2)
  %519 = inttoptr i64 %107 to i64*
  %520 = load i64, i64* %519
; # (cons (cdr X) (val Tp2))
  %521 = call i64 @cons(i64 %518, i64 %520)
  %522 = inttoptr i64 %107 to i64*
  store i64 %521, i64* %522
; # (val E)
  %523 = inttoptr i64 %123 to i64*
  %524 = load i64, i64* %523
  %525 = inttoptr i64 %95 to i64*
  store i64 %524, i64* %525
  br label %$23
$55:
  %526 = phi i64 [%441, %$48] ; # X
  %527 = phi i64 [%442, %$48] ; # P
  %528 = phi i64 [%443, %$48] ; # N
; # (== @ $Up)
  %529 = icmp eq i64 %445, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 648) to i64)
  br i1 %529, label %$72, label %$71
$72:
  %530 = phi i64 [%526, %$55] ; # X
  %531 = phi i64 [%527, %$55] ; # P
  %532 = phi i64 [%528, %$55] ; # N
; # (if (and (not (nil? (set E (run (cddr (car X)))))) (unify (car (v...
; # (and (not (nil? (set E (run (cddr (car X)))))) (unify (car (val N...
; # (set E (run (cddr (car X))))
; # (car X)
  %533 = inttoptr i64 %530 to i64*
  %534 = load i64, i64* %533
; # (cddr (car X))
  %535 = inttoptr i64 %534 to i64*
  %536 = getelementptr i64, i64* %535, i32 1
  %537 = load i64, i64* %536
  %538 = inttoptr i64 %537 to i64*
  %539 = getelementptr i64, i64* %538, i32 1
  %540 = load i64, i64* %539
; # (run (cddr (car X)))
  br label %$74
$74:
  %541 = phi i64 [%540, %$72], [%563, %$83] ; # Prg
  %542 = inttoptr i64 %541 to i64*
  %543 = load i64, i64* %542
  %544 = getelementptr i64, i64* %542, i32 1
  %545 = load i64, i64* %544
  %546 = and i64 %545, 15
  %547 = icmp ne i64 %546, 0
  br i1 %547, label %$77, label %$75
$77:
  %548 = phi i64 [%545, %$74] ; # Prg
  %549 = and i64 %543, 6
  %550 = icmp ne i64 %549, 0
  br i1 %550, label %$80, label %$79
$80:
  br label %$78
$79:
  %551 = and i64 %543, 8
  %552 = icmp ne i64 %551, 0
  br i1 %552, label %$82, label %$81
$82:
  %553 = inttoptr i64 %543 to i64*
  %554 = load i64, i64* %553
  br label %$78
$81:
  %555 = call i64 @evList(i64 %543)
  br label %$78
$78:
  %556 = phi i64 [%543, %$80], [%554, %$82], [%555, %$81] ; # ->
  br label %$76
$75:
  %557 = phi i64 [%545, %$74] ; # Prg
  %558 = and i64 %543, 15
  %559 = icmp eq i64 %558, 0
  br i1 %559, label %$84, label %$83
$84:
  %560 = phi i64 [%557, %$75] ; # Prg
  %561 = call i64 @evList(i64 %543)
  %562 = icmp ne i64 %561, 0
  br label %$83
$83:
  %563 = phi i64 [%557, %$75], [%560, %$84] ; # Prg
  %564 = phi i1 [0, %$75], [%562, %$84] ; # ->
  br label %$74
$76:
  %565 = phi i64 [%548, %$78] ; # Prg
  %566 = phi i64 [%556, %$78] ; # ->
  %567 = inttoptr i64 %123 to i64*
  store i64 %566, i64* %567
; # (nil? (set E (run (cddr (car X)))))
  %568 = icmp eq i64 %566, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (set E (run (cddr (car X))))))
  %569 = icmp eq i1 %568, 0
  br i1 %569, label %$85, label %$73
$85:
  %570 = phi i64 [%530, %$76] ; # X
  %571 = phi i64 [%531, %$76] ; # P
  %572 = phi i64 [%532, %$76] ; # N
; # (val Nl)
  %573 = inttoptr i64 %71 to i64*
  %574 = load i64, i64* %573
; # (car (val Nl))
  %575 = inttoptr i64 %574 to i64*
  %576 = load i64, i64* %575
; # (car X)
  %577 = inttoptr i64 %570 to i64*
  %578 = load i64, i64* %577
; # (cadr (car X))
  %579 = inttoptr i64 %578 to i64*
  %580 = getelementptr i64, i64* %579, i32 1
  %581 = load i64, i64* %580
  %582 = inttoptr i64 %581 to i64*
  %583 = load i64, i64* %582
; # (val Nl)
  %584 = inttoptr i64 %71 to i64*
  %585 = load i64, i64* %584
; # (car (val Nl))
  %586 = inttoptr i64 %585 to i64*
  %587 = load i64, i64* %586
; # (val E)
  %588 = inttoptr i64 %123 to i64*
  %589 = load i64, i64* %588
; # (unify (car (val Nl)) (cadr (car X)) (car (val Nl)) (val E))
  %590 = call i1 @unify(i64 %576, i64 %583, i64 %587, i64 %589)
  br label %$73
$73:
  %591 = phi i64 [%530, %$76], [%570, %$85] ; # X
  %592 = phi i64 [%531, %$76], [%571, %$85] ; # P
  %593 = phi i64 [%532, %$76], [%572, %$85] ; # N
  %594 = phi i1 [0, %$76], [%590, %$85] ; # ->
  br i1 %594, label %$86, label %$87
$86:
  %595 = phi i64 [%591, %$73] ; # X
  %596 = phi i64 [%592, %$73] ; # P
  %597 = phi i64 [%593, %$73] ; # N
; # (set Tp1 (cdr X))
; # (cdr X)
  %598 = inttoptr i64 %595 to i64*
  %599 = getelementptr i64, i64* %598, i32 1
  %600 = load i64, i64* %599
  %601 = inttoptr i64 %95 to i64*
  store i64 %600, i64* %601
  br label %$88
$87:
  %602 = phi i64 [%591, %$73] ; # X
  %603 = phi i64 [%592, %$73] ; # P
  %604 = phi i64 [%593, %$73] ; # N
; # (caar Q)
  %605 = inttoptr i64 %13 to i64*
  %606 = load i64, i64* %605
  %607 = inttoptr i64 %606 to i64*
  %608 = load i64, i64* %607
; # (set Q (cdar Q))
; # (cdar Q)
  %609 = inttoptr i64 %13 to i64*
  %610 = load i64, i64* %609
  %611 = inttoptr i64 %610 to i64*
  %612 = getelementptr i64, i64* %611, i32 1
  %613 = load i64, i64* %612
  %614 = inttoptr i64 %13 to i64*
  store i64 %613, i64* %614
; # (++ P)
  %615 = inttoptr i64 %608 to i64*
  %616 = load i64, i64* %615
  %617 = getelementptr i64, i64* %615, i32 1
  %618 = load i64, i64* %617
; # (set Nl (++ P) Alt (++ P) Tp1 (++ P) Tp2 (++ P) Env P)
; # (++ P)
  %619 = inttoptr i64 %618 to i64*
  %620 = load i64, i64* %619
  %621 = getelementptr i64, i64* %619, i32 1
  %622 = load i64, i64* %621
  %623 = inttoptr i64 %71 to i64*
  store i64 %620, i64* %623
; # (++ P)
  %624 = inttoptr i64 %622 to i64*
  %625 = load i64, i64* %624
  %626 = getelementptr i64, i64* %624, i32 1
  %627 = load i64, i64* %626
  %628 = inttoptr i64 %83 to i64*
  store i64 %625, i64* %628
; # (++ P)
  %629 = inttoptr i64 %627 to i64*
  %630 = load i64, i64* %629
  %631 = getelementptr i64, i64* %629, i32 1
  %632 = load i64, i64* %631
  %633 = inttoptr i64 %95 to i64*
  store i64 %630, i64* %633
; # (++ P)
  %634 = inttoptr i64 %632 to i64*
  %635 = load i64, i64* %634
  %636 = getelementptr i64, i64* %634, i32 1
  %637 = load i64, i64* %636
  %638 = inttoptr i64 %107 to i64*
  store i64 %635, i64* %638
  %639 = inttoptr i64 %115 to i64*
  store i64 %637, i64* %639
  br label %$88
$88:
  %640 = phi i64 [%595, %$86], [%602, %$87] ; # X
  %641 = phi i64 [%596, %$86], [%637, %$87] ; # P
  %642 = phi i64 [%597, %$86], [%616, %$87] ; # N
  %643 = phi i64 [%600, %$86], [%637, %$87] ; # ->
  br label %$23
$71:
  %644 = phi i64 [%526, %$55] ; # X
  %645 = phi i64 [%527, %$55] ; # P
  %646 = phi i64 [%528, %$55] ; # N
; # (set Alt (get (caar X) $T))
; # (caar X)
  %647 = inttoptr i64 %644 to i64*
  %648 = load i64, i64* %647
  %649 = inttoptr i64 %648 to i64*
  %650 = load i64, i64* %649
; # (get (caar X) $T)
  %651 = call i64 @get(i64 %650, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64))
  %652 = inttoptr i64 %83 to i64*
  store i64 %651, i64* %652
; # (atom (set Alt (get (caar X) $T)))
  %653 = and i64 %651, 15
  %654 = icmp ne i64 %653, 0
  br i1 %654, label %$90, label %$89
$90:
  %655 = phi i64 [%644, %$71] ; # X
  %656 = phi i64 [%645, %$71] ; # P
  %657 = phi i64 [%646, %$71] ; # N
; # (caar Q)
  %658 = inttoptr i64 %13 to i64*
  %659 = load i64, i64* %658
  %660 = inttoptr i64 %659 to i64*
  %661 = load i64, i64* %660
; # (set Q (cdar Q))
; # (cdar Q)
  %662 = inttoptr i64 %13 to i64*
  %663 = load i64, i64* %662
  %664 = inttoptr i64 %663 to i64*
  %665 = getelementptr i64, i64* %664, i32 1
  %666 = load i64, i64* %665
  %667 = inttoptr i64 %13 to i64*
  store i64 %666, i64* %667
; # (++ P)
  %668 = inttoptr i64 %661 to i64*
  %669 = load i64, i64* %668
  %670 = getelementptr i64, i64* %668, i32 1
  %671 = load i64, i64* %670
; # (set Nl (++ P) Alt (++ P) Tp1 (++ P) Tp2 (++ P) Env P)
; # (++ P)
  %672 = inttoptr i64 %671 to i64*
  %673 = load i64, i64* %672
  %674 = getelementptr i64, i64* %672, i32 1
  %675 = load i64, i64* %674
  %676 = inttoptr i64 %71 to i64*
  store i64 %673, i64* %676
; # (++ P)
  %677 = inttoptr i64 %675 to i64*
  %678 = load i64, i64* %677
  %679 = getelementptr i64, i64* %677, i32 1
  %680 = load i64, i64* %679
  %681 = inttoptr i64 %83 to i64*
  store i64 %678, i64* %681
; # (++ P)
  %682 = inttoptr i64 %680 to i64*
  %683 = load i64, i64* %682
  %684 = getelementptr i64, i64* %682, i32 1
  %685 = load i64, i64* %684
  %686 = inttoptr i64 %95 to i64*
  store i64 %683, i64* %686
; # (++ P)
  %687 = inttoptr i64 %685 to i64*
  %688 = load i64, i64* %687
  %689 = getelementptr i64, i64* %687, i32 1
  %690 = load i64, i64* %689
  %691 = inttoptr i64 %107 to i64*
  store i64 %688, i64* %691
  %692 = inttoptr i64 %115 to i64*
  store i64 %690, i64* %692
  br label %$23
$89:
  %693 = phi i64 [%644, %$71] ; # X
  %694 = phi i64 [%645, %$71] ; # P
  %695 = phi i64 [%646, %$71] ; # N
  br label %$23
$23:
  %696 = phi i64 [%363, %$28], [%373, %$47], [%434, %$54], [%505, %$70], [%640, %$88], [%655, %$90], [%693, %$89] ; # X
  %697 = phi i64 [%364, %$28], [%374, %$47], [%435, %$54], [%506, %$70], [%641, %$88], [%690, %$90], [%694, %$89] ; # P
  %698 = phi i64 [%365, %$28], [%375, %$47], [%436, %$54], [%507, %$70], [%642, %$88], [%669, %$90], [%695, %$89] ; # N
  br label %$18
$22:
  %699 = phi i64 [%156, %$19] ; # X
  %700 = phi i64 [%157, %$19] ; # P
  %701 = phi i64 [%158, %$19] ; # N
; # (set E $Nil)
  %702 = inttoptr i64 %123 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %702
; # (let Y (val Env) (while (pair (cdr Y)) (let Z (caar Y) (when (== ...
; # (val Env)
  %703 = inttoptr i64 %115 to i64*
  %704 = load i64, i64* %703
; # (while (pair (cdr Y)) (let Z (caar Y) (when (== (car Z) ZERO) (se...
  br label %$91
$91:
  %705 = phi i64 [%699, %$22], [%739, %$95] ; # X
  %706 = phi i64 [%700, %$22], [%740, %$95] ; # P
  %707 = phi i64 [%701, %$22], [%741, %$95] ; # N
  %708 = phi i64 [%704, %$22], [%746, %$95] ; # Y
; # (cdr Y)
  %709 = inttoptr i64 %708 to i64*
  %710 = getelementptr i64, i64* %709, i32 1
  %711 = load i64, i64* %710
; # (pair (cdr Y))
  %712 = and i64 %711, 15
  %713 = icmp eq i64 %712, 0
  br i1 %713, label %$92, label %$93
$92:
  %714 = phi i64 [%705, %$91] ; # X
  %715 = phi i64 [%706, %$91] ; # P
  %716 = phi i64 [%707, %$91] ; # N
  %717 = phi i64 [%708, %$91] ; # Y
; # (let Z (caar Y) (when (== (car Z) ZERO) (set E (cons (cons (shift...
; # (caar Y)
  %718 = inttoptr i64 %717 to i64*
  %719 = load i64, i64* %718
  %720 = inttoptr i64 %719 to i64*
  %721 = load i64, i64* %720
; # (when (== (car Z) ZERO) (set E (cons (cons (shift Z) (lookup ZERO...
; # (car Z)
  %722 = inttoptr i64 %721 to i64*
  %723 = load i64, i64* %722
; # (== (car Z) ZERO)
  %724 = icmp eq i64 %723, 2
  br i1 %724, label %$94, label %$95
$94:
  %725 = phi i64 [%714, %$92] ; # X
  %726 = phi i64 [%715, %$92] ; # P
  %727 = phi i64 [%716, %$92] ; # N
  %728 = phi i64 [%717, %$92] ; # Y
  %729 = phi i64 [%721, %$92] ; # Z
; # (set E (cons (cons (shift Z) (lookup ZERO Z)) (val E)))
; # (shift Z)
  %730 = inttoptr i64 %729 to i64*
  %731 = getelementptr i64, i64* %730, i32 1
  %732 = load i64, i64* %731
; # (lookup ZERO Z)
  %733 = call i64 @lookup(i64 2, i64 %732)
; # (cons (shift Z) (lookup ZERO Z))
  %734 = call i64 @cons(i64 %732, i64 %733)
; # (val E)
  %735 = inttoptr i64 %123 to i64*
  %736 = load i64, i64* %735
; # (cons (cons (shift Z) (lookup ZERO Z)) (val E))
  %737 = call i64 @cons(i64 %734, i64 %736)
  %738 = inttoptr i64 %123 to i64*
  store i64 %737, i64* %738
  br label %$95
$95:
  %739 = phi i64 [%714, %$92], [%725, %$94] ; # X
  %740 = phi i64 [%715, %$92], [%726, %$94] ; # P
  %741 = phi i64 [%716, %$92], [%727, %$94] ; # N
  %742 = phi i64 [%717, %$92], [%728, %$94] ; # Y
  %743 = phi i64 [%721, %$92], [%732, %$94] ; # Z
; # (shift Y)
  %744 = inttoptr i64 %742 to i64*
  %745 = getelementptr i64, i64* %744, i32 1
  %746 = load i64, i64* %745
  br label %$91
$93:
  %747 = phi i64 [%705, %$91] ; # X
  %748 = phi i64 [%706, %$91] ; # P
  %749 = phi i64 [%707, %$91] ; # N
  %750 = phi i64 [%708, %$91] ; # Y
; # (set $Pnl Pnl $Penv Penv $At At)
  store i64 %141, i64* @$Pnl
  store i64 %140, i64* @$Penv
  %751 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  store i64 %131, i64* %751
; # (cond ((pair (val E)) @) ((pair (val Env)) $T) (T $Nil))
; # (val E)
  %752 = inttoptr i64 %123 to i64*
  %753 = load i64, i64* %752
; # (pair (val E))
  %754 = and i64 %753, 15
  %755 = icmp eq i64 %754, 0
  br i1 %755, label %$98, label %$97
$98:
  %756 = phi i64 [%747, %$93] ; # X
  %757 = phi i64 [%748, %$93] ; # P
  %758 = phi i64 [%749, %$93] ; # N
  br label %$96
$97:
  %759 = phi i64 [%747, %$93] ; # X
  %760 = phi i64 [%748, %$93] ; # P
  %761 = phi i64 [%749, %$93] ; # N
; # (val Env)
  %762 = inttoptr i64 %115 to i64*
  %763 = load i64, i64* %762
; # (pair (val Env))
  %764 = and i64 %763, 15
  %765 = icmp eq i64 %764, 0
  br i1 %765, label %$100, label %$99
$100:
  %766 = phi i64 [%759, %$97] ; # X
  %767 = phi i64 [%760, %$97] ; # P
  %768 = phi i64 [%761, %$97] ; # N
  br label %$96
$99:
  %769 = phi i64 [%759, %$97] ; # X
  %770 = phi i64 [%760, %$97] ; # P
  %771 = phi i64 [%761, %$97] ; # N
  br label %$96
$96:
  %772 = phi i64 [%756, %$98], [%766, %$100], [%769, %$99] ; # X
  %773 = phi i64 [%757, %$98], [%767, %$100], [%770, %$99] ; # P
  %774 = phi i64 [%758, %$98], [%768, %$100], [%771, %$99] ; # N
  %775 = phi i64 [%753, %$98], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$100], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$99] ; # ->
; # (drop *Safe)
  %776 = inttoptr i64 %19 to i64*
  %777 = getelementptr i64, i64* %776, i32 1
  %778 = load i64, i64* %777
  %779 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %778, i64* %779
  br label %$9
$9:
  %780 = phi i64 [%16, %$7], [%772, %$96] ; # X
  %781 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%775, %$96] ; # ->
  ret i64 %781
}

define i64 @_arrow(i64) {
$1:
; # (let (X (cdr Exe) L (val (val $Pnl))) (when (cnt? (cadr X)) (let ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $Pnl)
  %4 = load i64, i64* @$Pnl
; # (val (val $Pnl))
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5
; # (when (cnt? (cadr X)) (let I (int @) (while (gt0 (dec 'I)) (shift...
; # (cadr X)
  %7 = inttoptr i64 %3 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
  %10 = inttoptr i64 %9 to i64*
  %11 = load i64, i64* %10
; # (cnt? (cadr X))
  %12 = and i64 %11, 2
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%6, %$1] ; # L
; # (let I (int @) (while (gt0 (dec 'I)) (shift L)))
; # (int @)
  %15 = lshr i64 %11, 4
; # (while (gt0 (dec 'I)) (shift L))
  br label %$4
$4:
  %16 = phi i64 [%14, %$2], [%24, %$5] ; # L
  %17 = phi i64 [%15, %$2], [%21, %$5] ; # I
; # (dec 'I)
  %18 = sub i64 %17, 1
; # (gt0 (dec 'I))
  %19 = icmp sgt i64 %18, 0
  br i1 %19, label %$5, label %$6
$5:
  %20 = phi i64 [%16, %$4] ; # L
  %21 = phi i64 [%18, %$4] ; # I
; # (shift L)
  %22 = inttoptr i64 %20 to i64*
  %23 = getelementptr i64, i64* %22, i32 1
  %24 = load i64, i64* %23
  br label %$4
$6:
  %25 = phi i64 [%16, %$4] ; # L
  %26 = phi i64 [%18, %$4] ; # I
  br label %$3
$3:
  %27 = phi i64 [%6, %$1], [%25, %$6] ; # L
; # (car L)
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (car X)
  %30 = inttoptr i64 %3 to i64*
  %31 = load i64, i64* %30
; # (lookup (car L) (car X))
  %32 = call i64 @lookup(i64 %29, i64 %31)
  ret i64 %32
}

define i64 @_unify(i64) {
$1:
; # (let (X (save (eval (cadr Exe))) L (val (val $Pnl))) (if (unify (...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (cadr Exe)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (val $Pnl)
  %22 = load i64, i64* @$Pnl
; # (val (val $Pnl))
  %23 = inttoptr i64 %22 to i64*
  %24 = load i64, i64* %23
; # (if (unify (cadr L) X (car L) X) (val (val $Penv)) $Nil)
; # (cadr L)
  %25 = inttoptr i64 %24 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %27 to i64*
  %29 = load i64, i64* %28
; # (car L)
  %30 = inttoptr i64 %24 to i64*
  %31 = load i64, i64* %30
; # (unify (cadr L) X (car L) X)
  %32 = call i1 @unify(i64 %29, i64 %13, i64 %31, i64 %13)
  br i1 %32, label %$7, label %$8
$7:
; # (val $Penv)
  %33 = load i64, i64* @$Penv
; # (val (val $Penv))
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
  br label %$9
$8:
  br label %$9
$9:
  %36 = phi i64 [%35, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
; # (drop *Safe)
  %37 = inttoptr i64 %15 to i64*
  %38 = getelementptr i64, i64* %37, i32 1
  %39 = load i64, i64* %38
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %39, i64* %40
  ret i64 %36
}

define i64 @_group(i64) {
$1:
; # (let X (save (eval (cadr Exe))) (if (atom X) $Nil (let Y (cons (c...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (save (eval (cadr Exe)))
  %14 = alloca i64, i64 2, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %13, i64* %16
  %17 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %18 = load i64, i64* %17
  %19 = inttoptr i64 %15 to i64*
  %20 = getelementptr i64, i64* %19, i32 1
  store i64 %18, i64* %20
  %21 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %15, i64* %21
; # (if (atom X) $Nil (let Y (cons (cdar X) $Nil) (setq Y (cons (cons...
; # (atom X)
  %22 = and i64 %13, 15
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$7, label %$8
$7:
  %24 = phi i64 [%13, %$2] ; # X
  br label %$9
$8:
  %25 = phi i64 [%13, %$2] ; # X
; # (let Y (cons (cdar X) $Nil) (setq Y (cons (cons (caar X) (cons Y ...
; # (cdar X)
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
  %28 = inttoptr i64 %27 to i64*
  %29 = getelementptr i64, i64* %28, i32 1
  %30 = load i64, i64* %29
; # (cons (cdar X) $Nil)
  %31 = call i64 @cons(i64 %30, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (caar X)
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  %34 = inttoptr i64 %33 to i64*
  %35 = load i64, i64* %34
; # (cons Y Y)
  %36 = call i64 @cons(i64 %31, i64 %31)
; # (cons (caar X) (cons Y Y))
  %37 = call i64 @cons(i64 %35, i64 %36)
; # (cons (cons (caar X) (cons Y Y)) $Nil)
  %38 = call i64 @cons(i64 %37, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (let R (save Y) (while (pair (shift X)) (let (L (car X) K (car L)...
; # (save Y)
  %39 = alloca i64, i64 2, align 16
  %40 = ptrtoint i64* %39 to i64
  %41 = inttoptr i64 %40 to i64*
  store i64 %38, i64* %41
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %43 = load i64, i64* %42
  %44 = inttoptr i64 %40 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  store i64 %43, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %46
; # (while (pair (shift X)) (let (L (car X) K (car L)) (setq Y (cons ...
  br label %$10
$10:
  %47 = phi i64 [%25, %$8], [%106, %$15] ; # X
  %48 = phi i64 [%38, %$8], [%107, %$15] ; # Y
; # (shift X)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (pair (shift X))
  %52 = and i64 %51, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$11, label %$12
$11:
  %54 = phi i64 [%51, %$10] ; # X
  %55 = phi i64 [%48, %$10] ; # Y
; # (let (L (car X) K (car L)) (setq Y (cons (cdr L) $Nil)) (let Z R ...
; # (car X)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
; # (car L)
  %58 = inttoptr i64 %57 to i64*
  %59 = load i64, i64* %58
; # (cdr L)
  %60 = inttoptr i64 %57 to i64*
  %61 = getelementptr i64, i64* %60, i32 1
  %62 = load i64, i64* %61
; # (cons (cdr L) $Nil)
  %63 = call i64 @cons(i64 %62, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (let Z R (loop (let V (car Z) (? (equal K (car V)) (set (shift V)...
; # (loop (let V (car Z) (? (equal K (car V)) (set (shift V) (set 2 (...
  br label %$13
$13:
  %64 = phi i64 [%54, %$11], [%102, %$17] ; # X
  %65 = phi i64 [%63, %$11], [%103, %$17] ; # Y
  %66 = phi i64 [%38, %$11], [%90, %$17] ; # Z
; # (let V (car Z) (? (equal K (car V)) (set (shift V) (set 2 (car V)...
; # (car Z)
  %67 = inttoptr i64 %66 to i64*
  %68 = load i64, i64* %67
; # (? (equal K (car V)) (set (shift V) (set 2 (car V) Y)))
; # (car V)
  %69 = inttoptr i64 %68 to i64*
  %70 = load i64, i64* %69
; # (equal K (car V))
  %71 = call i1 @equal(i64 %59, i64 %70)
  br i1 %71, label %$16, label %$14
$16:
  %72 = phi i64 [%64, %$13] ; # X
  %73 = phi i64 [%65, %$13] ; # Y
  %74 = phi i64 [%66, %$13] ; # Z
  %75 = phi i64 [%68, %$13] ; # V
; # (set (shift V) (set 2 (car V) Y))
; # (shift V)
  %76 = inttoptr i64 %75 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  %78 = load i64, i64* %77
; # (set 2 (car V) Y)
; # (car V)
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
  %81 = inttoptr i64 %80 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  store i64 %73, i64* %82
  %83 = inttoptr i64 %78 to i64*
  store i64 %73, i64* %83
  br label %$15
$14:
  %84 = phi i64 [%64, %$13] ; # X
  %85 = phi i64 [%65, %$13] ; # Y
  %86 = phi i64 [%66, %$13] ; # Z
  %87 = phi i64 [%68, %$13] ; # V
; # (? (atom (cdr Z)) (set 2 Z (cons (cons K (cons Y Y)) $Nil)))
; # (cdr Z)
  %88 = inttoptr i64 %86 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
; # (atom (cdr Z))
  %91 = and i64 %90, 15
  %92 = icmp ne i64 %91, 0
  br i1 %92, label %$18, label %$17
$18:
  %93 = phi i64 [%84, %$14] ; # X
  %94 = phi i64 [%85, %$14] ; # Y
  %95 = phi i64 [%86, %$14] ; # Z
  %96 = phi i64 [%87, %$14] ; # V
; # (set 2 Z (cons (cons K (cons Y Y)) $Nil))
; # (cons Y Y)
  %97 = call i64 @cons(i64 %94, i64 %94)
; # (cons K (cons Y Y))
  %98 = call i64 @cons(i64 %59, i64 %97)
; # (cons (cons K (cons Y Y)) $Nil)
  %99 = call i64 @cons(i64 %98, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %100 = inttoptr i64 %95 to i64*
  %101 = getelementptr i64, i64* %100, i32 1
  store i64 %99, i64* %101
  br label %$15
$17:
  %102 = phi i64 [%84, %$14] ; # X
  %103 = phi i64 [%85, %$14] ; # Y
  %104 = phi i64 [%86, %$14] ; # Z
  %105 = phi i64 [%87, %$14] ; # V
  br label %$13
$15:
  %106 = phi i64 [%72, %$16], [%93, %$18] ; # X
  %107 = phi i64 [%73, %$16], [%94, %$18] ; # Y
  %108 = phi i64 [%74, %$16], [%95, %$18] ; # Z
  %109 = phi i64 [%73, %$16], [%99, %$18] ; # ->
  br label %$10
$12:
  %110 = phi i64 [%51, %$10] ; # X
  %111 = phi i64 [%48, %$10] ; # Y
; # (let Z R (loop (let V (car Z) (set 2 V (cddr V))) (? (atom (shift...
; # (loop (let V (car Z) (set 2 V (cddr V))) (? (atom (shift Z))))
  br label %$19
$19:
  %112 = phi i64 [%110, %$12], [%130, %$20] ; # X
  %113 = phi i64 [%111, %$12], [%131, %$20] ; # Y
  %114 = phi i64 [%38, %$12], [%132, %$20] ; # Z
; # (let V (car Z) (set 2 V (cddr V)))
; # (car Z)
  %115 = inttoptr i64 %114 to i64*
  %116 = load i64, i64* %115
; # (set 2 V (cddr V))
; # (cddr V)
  %117 = inttoptr i64 %116 to i64*
  %118 = getelementptr i64, i64* %117, i32 1
  %119 = load i64, i64* %118
  %120 = inttoptr i64 %119 to i64*
  %121 = getelementptr i64, i64* %120, i32 1
  %122 = load i64, i64* %121
  %123 = inttoptr i64 %116 to i64*
  %124 = getelementptr i64, i64* %123, i32 1
  store i64 %122, i64* %124
; # (? (atom (shift Z)))
; # (shift Z)
  %125 = inttoptr i64 %114 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
; # (atom (shift Z))
  %128 = and i64 %127, 15
  %129 = icmp ne i64 %128, 0
  br i1 %129, label %$21, label %$20
$20:
  %130 = phi i64 [%112, %$19] ; # X
  %131 = phi i64 [%113, %$19] ; # Y
  %132 = phi i64 [%127, %$19] ; # Z
  br label %$19
$21:
  %133 = phi i64 [%112, %$19] ; # X
  %134 = phi i64 [%113, %$19] ; # Y
  %135 = phi i64 [%127, %$19] ; # Z
  %136 = phi i64 [0, %$19] ; # ->
  br label %$9
$9:
  %137 = phi i64 [%24, %$7], [%133, %$21] ; # X
  %138 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%38, %$21] ; # ->
; # (drop *Safe)
  %139 = inttoptr i64 %15 to i64*
  %140 = getelementptr i64, i64* %139, i32 1
  %141 = load i64, i64* %140
  %142 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %141, i64* %142
  ret i64 %138
}

define i64 @_sort(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X))) (cond ((atom Y) @) ((atom X) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((atom Y) @) ((atom X) (let (Out0 Y Out1 $Nil) (loop (let (...
; # (atom Y)
  %16 = and i64 %15, 15
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  br label %$7
$8:
; # (atom X)
  %18 = and i64 %7, 15
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$11, label %$10
$11:
; # (let (Out0 Y Out1 $Nil) (loop (let (In0 Out0 In1 Out1 P) (if (and...
; # (loop (let (In0 Out0 In1 Out1 P) (if (and (pair In1) (ge0 (compar...
  br label %$12
$12:
  %20 = phi i64 [%15, %$11], [%375, %$47] ; # Out0
  %21 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11], [%376, %$47] ; # Out1
; # (let (In0 Out0 In1 Out1 P) (if (and (pair In1) (ge0 (compare (car...
; # (if (and (pair In1) (ge0 (compare (car In0) (car In1)))) (setq In...
; # (and (pair In1) (ge0 (compare (car In0) (car In1))))
; # (pair In1)
  %22 = and i64 %21, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = phi i64 [%20, %$12] ; # Out0
  %25 = phi i64 [%21, %$12] ; # Out1
  %26 = phi i64 [%20, %$12] ; # In0
  %27 = phi i64 [%21, %$12] ; # In1
; # (car In0)
  %28 = inttoptr i64 %26 to i64*
  %29 = load i64, i64* %28
; # (car In1)
  %30 = inttoptr i64 %27 to i64*
  %31 = load i64, i64* %30
; # (compare (car In0) (car In1))
  %32 = call i64 @compare(i64 %29, i64 %31)
; # (ge0 (compare (car In0) (car In1)))
  %33 = icmp sge i64 %32, 0
  br label %$13
$13:
  %34 = phi i64 [%20, %$12], [%24, %$14] ; # Out0
  %35 = phi i64 [%21, %$12], [%25, %$14] ; # Out1
  %36 = phi i64 [%20, %$12], [%26, %$14] ; # In0
  %37 = phi i64 [%21, %$12], [%27, %$14] ; # In1
  %38 = phi i1 [0, %$12], [%33, %$14] ; # ->
  br i1 %38, label %$15, label %$16
$15:
  %39 = phi i64 [%34, %$13] ; # Out0
  %40 = phi i64 [%35, %$13] ; # Out1
  %41 = phi i64 [%36, %$13] ; # In0
  %42 = phi i64 [%37, %$13] ; # In1
; # (cdr (setq P In1))
  %43 = inttoptr i64 %42 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  %45 = load i64, i64* %44
  br label %$17
$16:
  %46 = phi i64 [%34, %$13] ; # Out0
  %47 = phi i64 [%35, %$13] ; # Out1
  %48 = phi i64 [%36, %$13] ; # In0
  %49 = phi i64 [%37, %$13] ; # In1
; # (cdr (setq P In0))
  %50 = inttoptr i64 %48 to i64*
  %51 = getelementptr i64, i64* %50, i32 1
  %52 = load i64, i64* %51
  br label %$17
$17:
  %53 = phi i64 [%39, %$15], [%46, %$16] ; # Out0
  %54 = phi i64 [%40, %$15], [%47, %$16] ; # Out1
  %55 = phi i64 [%41, %$15], [%52, %$16] ; # In0
  %56 = phi i64 [%45, %$15], [%49, %$16] ; # In1
  %57 = phi i64 [%42, %$15], [%48, %$16] ; # P
  %58 = phi i64 [%45, %$15], [%52, %$16] ; # ->
; # (let (Tail0 (ofs P 1) Tail1 0 Last (car P)) (setq Out0 P Out1 $Ni...
; # (ofs P 1)
  %59 = add i64 %57, 8
; # (car P)
  %60 = inttoptr i64 %57 to i64*
  %61 = load i64, i64* %60
; # (set 2 P $Nil)
  %62 = inttoptr i64 %57 to i64*
  %63 = getelementptr i64, i64* %62, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %63
; # (while (or (pair In0) (pair In1)) (cond ((atom In1) (setq In0 (cd...
  br label %$18
$18:
  %64 = phi i64 [%57, %$17], [%349, %$46] ; # Out0
  %65 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$17], [%350, %$46] ; # Out1
  %66 = phi i64 [%55, %$17], [%351, %$46] ; # In0
  %67 = phi i64 [%56, %$17], [%352, %$46] ; # In1
  %68 = phi i64 [%57, %$17], [%353, %$46] ; # P
  %69 = phi i64 [%59, %$17], [%358, %$46] ; # Tail0
  %70 = phi i64 [0, %$17], [%355, %$46] ; # Tail1
  %71 = phi i64 [%61, %$17], [%362, %$46] ; # Last
; # (or (pair In0) (pair In1))
; # (pair In0)
  %72 = and i64 %66, 15
  %73 = icmp eq i64 %72, 0
  br i1 %73, label %$19, label %$20
$20:
  %74 = phi i64 [%64, %$18] ; # Out0
  %75 = phi i64 [%65, %$18] ; # Out1
  %76 = phi i64 [%66, %$18] ; # In0
  %77 = phi i64 [%67, %$18] ; # In1
  %78 = phi i64 [%68, %$18] ; # P
  %79 = phi i64 [%69, %$18] ; # Tail0
  %80 = phi i64 [%70, %$18] ; # Tail1
  %81 = phi i64 [%71, %$18] ; # Last
; # (pair In1)
  %82 = and i64 %77, 15
  %83 = icmp eq i64 %82, 0
  br label %$19
$19:
  %84 = phi i64 [%64, %$18], [%74, %$20] ; # Out0
  %85 = phi i64 [%65, %$18], [%75, %$20] ; # Out1
  %86 = phi i64 [%66, %$18], [%76, %$20] ; # In0
  %87 = phi i64 [%67, %$18], [%77, %$20] ; # In1
  %88 = phi i64 [%68, %$18], [%78, %$20] ; # P
  %89 = phi i64 [%69, %$18], [%79, %$20] ; # Tail0
  %90 = phi i64 [%70, %$18], [%80, %$20] ; # Tail1
  %91 = phi i64 [%71, %$18], [%81, %$20] ; # Last
  %92 = phi i1 [1, %$18], [%83, %$20] ; # ->
  br i1 %92, label %$21, label %$22
$21:
  %93 = phi i64 [%84, %$19] ; # Out0
  %94 = phi i64 [%85, %$19] ; # Out1
  %95 = phi i64 [%86, %$19] ; # In0
  %96 = phi i64 [%87, %$19] ; # In1
  %97 = phi i64 [%88, %$19] ; # P
  %98 = phi i64 [%89, %$19] ; # Tail0
  %99 = phi i64 [%90, %$19] ; # Tail1
  %100 = phi i64 [%91, %$19] ; # Last
; # (cond ((atom In1) (setq In0 (cdr (setq P In0))) (when (lt0 (compa...
; # (atom In1)
  %101 = and i64 %96, 15
  %102 = icmp ne i64 %101, 0
  br i1 %102, label %$25, label %$24
$25:
  %103 = phi i64 [%93, %$21] ; # Out0
  %104 = phi i64 [%94, %$21] ; # Out1
  %105 = phi i64 [%95, %$21] ; # In0
  %106 = phi i64 [%96, %$21] ; # In1
  %107 = phi i64 [%97, %$21] ; # P
  %108 = phi i64 [%98, %$21] ; # Tail0
  %109 = phi i64 [%99, %$21] ; # Tail1
  %110 = phi i64 [%100, %$21] ; # Last
; # (cdr (setq P In0))
  %111 = inttoptr i64 %105 to i64*
  %112 = getelementptr i64, i64* %111, i32 1
  %113 = load i64, i64* %112
; # (when (lt0 (compare (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %114 = inttoptr i64 %105 to i64*
  %115 = load i64, i64* %114
; # (compare (car P) Last)
  %116 = call i64 @compare(i64 %115, i64 %110)
; # (lt0 (compare (car P) Last))
  %117 = icmp slt i64 %116, 0
  br i1 %117, label %$26, label %$27
$26:
  %118 = phi i64 [%103, %$25] ; # Out0
  %119 = phi i64 [%104, %$25] ; # Out1
  %120 = phi i64 [%113, %$25] ; # In0
  %121 = phi i64 [%106, %$25] ; # In1
  %122 = phi i64 [%105, %$25] ; # P
  %123 = phi i64 [%108, %$25] ; # Tail0
  %124 = phi i64 [%109, %$25] ; # Tail1
  %125 = phi i64 [%110, %$25] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$27
$27:
  %126 = phi i64 [%103, %$25], [%118, %$26] ; # Out0
  %127 = phi i64 [%104, %$25], [%119, %$26] ; # Out1
  %128 = phi i64 [%113, %$25], [%120, %$26] ; # In0
  %129 = phi i64 [%106, %$25], [%121, %$26] ; # In1
  %130 = phi i64 [%105, %$25], [%122, %$26] ; # P
  %131 = phi i64 [%108, %$25], [%124, %$26] ; # Tail0
  %132 = phi i64 [%109, %$25], [%123, %$26] ; # Tail1
  %133 = phi i64 [%110, %$25], [%125, %$26] ; # Last
  br label %$23
$24:
  %134 = phi i64 [%93, %$21] ; # Out0
  %135 = phi i64 [%94, %$21] ; # Out1
  %136 = phi i64 [%95, %$21] ; # In0
  %137 = phi i64 [%96, %$21] ; # In1
  %138 = phi i64 [%97, %$21] ; # P
  %139 = phi i64 [%98, %$21] ; # Tail0
  %140 = phi i64 [%99, %$21] ; # Tail1
  %141 = phi i64 [%100, %$21] ; # Last
; # (atom In0)
  %142 = and i64 %136, 15
  %143 = icmp ne i64 %142, 0
  br i1 %143, label %$29, label %$28
$29:
  %144 = phi i64 [%134, %$24] ; # Out0
  %145 = phi i64 [%135, %$24] ; # Out1
  %146 = phi i64 [%136, %$24] ; # In0
  %147 = phi i64 [%137, %$24] ; # In1
  %148 = phi i64 [%138, %$24] ; # P
  %149 = phi i64 [%139, %$24] ; # Tail0
  %150 = phi i64 [%140, %$24] ; # Tail1
  %151 = phi i64 [%141, %$24] ; # Last
; # (cdr (setq P In1))
  %152 = inttoptr i64 %147 to i64*
  %153 = getelementptr i64, i64* %152, i32 1
  %154 = load i64, i64* %153
; # (when (lt0 (compare (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %155 = inttoptr i64 %147 to i64*
  %156 = load i64, i64* %155
; # (compare (car P) Last)
  %157 = call i64 @compare(i64 %156, i64 %151)
; # (lt0 (compare (car P) Last))
  %158 = icmp slt i64 %157, 0
  br i1 %158, label %$30, label %$31
$30:
  %159 = phi i64 [%144, %$29] ; # Out0
  %160 = phi i64 [%145, %$29] ; # Out1
  %161 = phi i64 [%146, %$29] ; # In0
  %162 = phi i64 [%154, %$29] ; # In1
  %163 = phi i64 [%147, %$29] ; # P
  %164 = phi i64 [%149, %$29] ; # Tail0
  %165 = phi i64 [%150, %$29] ; # Tail1
  %166 = phi i64 [%151, %$29] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$31
$31:
  %167 = phi i64 [%144, %$29], [%159, %$30] ; # Out0
  %168 = phi i64 [%145, %$29], [%160, %$30] ; # Out1
  %169 = phi i64 [%146, %$29], [%161, %$30] ; # In0
  %170 = phi i64 [%154, %$29], [%162, %$30] ; # In1
  %171 = phi i64 [%147, %$29], [%163, %$30] ; # P
  %172 = phi i64 [%149, %$29], [%165, %$30] ; # Tail0
  %173 = phi i64 [%150, %$29], [%164, %$30] ; # Tail1
  %174 = phi i64 [%151, %$29], [%166, %$30] ; # Last
  br label %$23
$28:
  %175 = phi i64 [%134, %$24] ; # Out0
  %176 = phi i64 [%135, %$24] ; # Out1
  %177 = phi i64 [%136, %$24] ; # In0
  %178 = phi i64 [%137, %$24] ; # In1
  %179 = phi i64 [%138, %$24] ; # P
  %180 = phi i64 [%139, %$24] ; # Tail0
  %181 = phi i64 [%140, %$24] ; # Tail1
  %182 = phi i64 [%141, %$24] ; # Last
; # (car In0)
  %183 = inttoptr i64 %177 to i64*
  %184 = load i64, i64* %183
; # (compare (car In0) Last)
  %185 = call i64 @compare(i64 %184, i64 %182)
; # (lt0 (compare (car In0) Last))
  %186 = icmp slt i64 %185, 0
  br i1 %186, label %$33, label %$32
$33:
  %187 = phi i64 [%175, %$28] ; # Out0
  %188 = phi i64 [%176, %$28] ; # Out1
  %189 = phi i64 [%177, %$28] ; # In0
  %190 = phi i64 [%178, %$28] ; # In1
  %191 = phi i64 [%179, %$28] ; # P
  %192 = phi i64 [%180, %$28] ; # Tail0
  %193 = phi i64 [%181, %$28] ; # Tail1
  %194 = phi i64 [%182, %$28] ; # Last
; # (if (ge0 (compare (car In1) Last)) (setq In1 (cdr (setq P In1))) ...
; # (car In1)
  %195 = inttoptr i64 %190 to i64*
  %196 = load i64, i64* %195
; # (compare (car In1) Last)
  %197 = call i64 @compare(i64 %196, i64 %194)
; # (ge0 (compare (car In1) Last))
  %198 = icmp sge i64 %197, 0
  br i1 %198, label %$34, label %$35
$34:
  %199 = phi i64 [%187, %$33] ; # Out0
  %200 = phi i64 [%188, %$33] ; # Out1
  %201 = phi i64 [%189, %$33] ; # In0
  %202 = phi i64 [%190, %$33] ; # In1
  %203 = phi i64 [%191, %$33] ; # P
  %204 = phi i64 [%192, %$33] ; # Tail0
  %205 = phi i64 [%193, %$33] ; # Tail1
  %206 = phi i64 [%194, %$33] ; # Last
; # (cdr (setq P In1))
  %207 = inttoptr i64 %202 to i64*
  %208 = getelementptr i64, i64* %207, i32 1
  %209 = load i64, i64* %208
  br label %$36
$35:
  %210 = phi i64 [%187, %$33] ; # Out0
  %211 = phi i64 [%188, %$33] ; # Out1
  %212 = phi i64 [%189, %$33] ; # In0
  %213 = phi i64 [%190, %$33] ; # In1
  %214 = phi i64 [%191, %$33] ; # P
  %215 = phi i64 [%192, %$33] ; # Tail0
  %216 = phi i64 [%193, %$33] ; # Tail1
  %217 = phi i64 [%194, %$33] ; # Last
; # (if (lt0 (compare (car In0) (car In1))) (setq In0 (cdr (setq P In...
; # (car In0)
  %218 = inttoptr i64 %212 to i64*
  %219 = load i64, i64* %218
; # (car In1)
  %220 = inttoptr i64 %213 to i64*
  %221 = load i64, i64* %220
; # (compare (car In0) (car In1))
  %222 = call i64 @compare(i64 %219, i64 %221)
; # (lt0 (compare (car In0) (car In1)))
  %223 = icmp slt i64 %222, 0
  br i1 %223, label %$37, label %$38
$37:
  %224 = phi i64 [%210, %$35] ; # Out0
  %225 = phi i64 [%211, %$35] ; # Out1
  %226 = phi i64 [%212, %$35] ; # In0
  %227 = phi i64 [%213, %$35] ; # In1
  %228 = phi i64 [%214, %$35] ; # P
  %229 = phi i64 [%215, %$35] ; # Tail0
  %230 = phi i64 [%216, %$35] ; # Tail1
  %231 = phi i64 [%217, %$35] ; # Last
; # (cdr (setq P In0))
  %232 = inttoptr i64 %226 to i64*
  %233 = getelementptr i64, i64* %232, i32 1
  %234 = load i64, i64* %233
  br label %$39
$38:
  %235 = phi i64 [%210, %$35] ; # Out0
  %236 = phi i64 [%211, %$35] ; # Out1
  %237 = phi i64 [%212, %$35] ; # In0
  %238 = phi i64 [%213, %$35] ; # In1
  %239 = phi i64 [%214, %$35] ; # P
  %240 = phi i64 [%215, %$35] ; # Tail0
  %241 = phi i64 [%216, %$35] ; # Tail1
  %242 = phi i64 [%217, %$35] ; # Last
; # (cdr (setq P In1))
  %243 = inttoptr i64 %238 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  %245 = load i64, i64* %244
  br label %$39
$39:
  %246 = phi i64 [%224, %$37], [%235, %$38] ; # Out0
  %247 = phi i64 [%225, %$37], [%236, %$38] ; # Out1
  %248 = phi i64 [%234, %$37], [%237, %$38] ; # In0
  %249 = phi i64 [%227, %$37], [%245, %$38] ; # In1
  %250 = phi i64 [%226, %$37], [%238, %$38] ; # P
  %251 = phi i64 [%229, %$37], [%240, %$38] ; # Tail0
  %252 = phi i64 [%230, %$37], [%241, %$38] ; # Tail1
  %253 = phi i64 [%231, %$37], [%242, %$38] ; # Last
  %254 = phi i64 [%234, %$37], [%245, %$38] ; # ->
; # (xchg 'Tail0 'Tail1)
  br label %$36
$36:
  %255 = phi i64 [%199, %$34], [%246, %$39] ; # Out0
  %256 = phi i64 [%200, %$34], [%247, %$39] ; # Out1
  %257 = phi i64 [%201, %$34], [%248, %$39] ; # In0
  %258 = phi i64 [%209, %$34], [%249, %$39] ; # In1
  %259 = phi i64 [%202, %$34], [%250, %$39] ; # P
  %260 = phi i64 [%204, %$34], [%252, %$39] ; # Tail0
  %261 = phi i64 [%205, %$34], [%251, %$39] ; # Tail1
  %262 = phi i64 [%206, %$34], [%253, %$39] ; # Last
  %263 = phi i64 [%209, %$34], [%251, %$39] ; # ->
  br label %$23
$32:
  %264 = phi i64 [%175, %$28] ; # Out0
  %265 = phi i64 [%176, %$28] ; # Out1
  %266 = phi i64 [%177, %$28] ; # In0
  %267 = phi i64 [%178, %$28] ; # In1
  %268 = phi i64 [%179, %$28] ; # P
  %269 = phi i64 [%180, %$28] ; # Tail0
  %270 = phi i64 [%181, %$28] ; # Tail1
  %271 = phi i64 [%182, %$28] ; # Last
; # (car In1)
  %272 = inttoptr i64 %267 to i64*
  %273 = load i64, i64* %272
; # (compare (car In1) Last)
  %274 = call i64 @compare(i64 %273, i64 %271)
; # (lt0 (compare (car In1) Last))
  %275 = icmp slt i64 %274, 0
  br i1 %275, label %$41, label %$40
$41:
  %276 = phi i64 [%264, %$32] ; # Out0
  %277 = phi i64 [%265, %$32] ; # Out1
  %278 = phi i64 [%266, %$32] ; # In0
  %279 = phi i64 [%267, %$32] ; # In1
  %280 = phi i64 [%268, %$32] ; # P
  %281 = phi i64 [%269, %$32] ; # Tail0
  %282 = phi i64 [%270, %$32] ; # Tail1
  %283 = phi i64 [%271, %$32] ; # Last
; # (cdr (setq P In0))
  %284 = inttoptr i64 %278 to i64*
  %285 = getelementptr i64, i64* %284, i32 1
  %286 = load i64, i64* %285
  br label %$23
$40:
  %287 = phi i64 [%264, %$32] ; # Out0
  %288 = phi i64 [%265, %$32] ; # Out1
  %289 = phi i64 [%266, %$32] ; # In0
  %290 = phi i64 [%267, %$32] ; # In1
  %291 = phi i64 [%268, %$32] ; # P
  %292 = phi i64 [%269, %$32] ; # Tail0
  %293 = phi i64 [%270, %$32] ; # Tail1
  %294 = phi i64 [%271, %$32] ; # Last
; # (car In0)
  %295 = inttoptr i64 %289 to i64*
  %296 = load i64, i64* %295
; # (car In1)
  %297 = inttoptr i64 %290 to i64*
  %298 = load i64, i64* %297
; # (compare (car In0) (car In1))
  %299 = call i64 @compare(i64 %296, i64 %298)
; # (lt0 (compare (car In0) (car In1)))
  %300 = icmp slt i64 %299, 0
  br i1 %300, label %$43, label %$42
$43:
  %301 = phi i64 [%287, %$40] ; # Out0
  %302 = phi i64 [%288, %$40] ; # Out1
  %303 = phi i64 [%289, %$40] ; # In0
  %304 = phi i64 [%290, %$40] ; # In1
  %305 = phi i64 [%291, %$40] ; # P
  %306 = phi i64 [%292, %$40] ; # Tail0
  %307 = phi i64 [%293, %$40] ; # Tail1
  %308 = phi i64 [%294, %$40] ; # Last
; # (cdr (setq P In0))
  %309 = inttoptr i64 %303 to i64*
  %310 = getelementptr i64, i64* %309, i32 1
  %311 = load i64, i64* %310
  br label %$23
$42:
  %312 = phi i64 [%287, %$40] ; # Out0
  %313 = phi i64 [%288, %$40] ; # Out1
  %314 = phi i64 [%289, %$40] ; # In0
  %315 = phi i64 [%290, %$40] ; # In1
  %316 = phi i64 [%291, %$40] ; # P
  %317 = phi i64 [%292, %$40] ; # Tail0
  %318 = phi i64 [%293, %$40] ; # Tail1
  %319 = phi i64 [%294, %$40] ; # Last
; # (cdr (setq P In1))
  %320 = inttoptr i64 %315 to i64*
  %321 = getelementptr i64, i64* %320, i32 1
  %322 = load i64, i64* %321
  br label %$23
$23:
  %323 = phi i64 [%126, %$27], [%167, %$31], [%255, %$36], [%276, %$41], [%301, %$43], [%312, %$42] ; # Out0
  %324 = phi i64 [%127, %$27], [%168, %$31], [%256, %$36], [%277, %$41], [%302, %$43], [%313, %$42] ; # Out1
  %325 = phi i64 [%128, %$27], [%169, %$31], [%257, %$36], [%286, %$41], [%311, %$43], [%314, %$42] ; # In0
  %326 = phi i64 [%129, %$27], [%170, %$31], [%258, %$36], [%279, %$41], [%304, %$43], [%322, %$42] ; # In1
  %327 = phi i64 [%130, %$27], [%171, %$31], [%259, %$36], [%278, %$41], [%303, %$43], [%315, %$42] ; # P
  %328 = phi i64 [%131, %$27], [%172, %$31], [%260, %$36], [%281, %$41], [%306, %$43], [%317, %$42] ; # Tail0
  %329 = phi i64 [%132, %$27], [%173, %$31], [%261, %$36], [%282, %$41], [%307, %$43], [%318, %$42] ; # Tail1
  %330 = phi i64 [%133, %$27], [%174, %$31], [%262, %$36], [%283, %$41], [%308, %$43], [%319, %$42] ; # Last
; # (if Tail0 (set Tail0 P) (setq Out1 P))
  %331 = icmp ne i64 %328, 0
  br i1 %331, label %$44, label %$45
$44:
  %332 = phi i64 [%323, %$23] ; # Out0
  %333 = phi i64 [%324, %$23] ; # Out1
  %334 = phi i64 [%325, %$23] ; # In0
  %335 = phi i64 [%326, %$23] ; # In1
  %336 = phi i64 [%327, %$23] ; # P
  %337 = phi i64 [%328, %$23] ; # Tail0
  %338 = phi i64 [%329, %$23] ; # Tail1
  %339 = phi i64 [%330, %$23] ; # Last
; # (set Tail0 P)
  %340 = inttoptr i64 %337 to i64*
  store i64 %336, i64* %340
  br label %$46
$45:
  %341 = phi i64 [%323, %$23] ; # Out0
  %342 = phi i64 [%324, %$23] ; # Out1
  %343 = phi i64 [%325, %$23] ; # In0
  %344 = phi i64 [%326, %$23] ; # In1
  %345 = phi i64 [%327, %$23] ; # P
  %346 = phi i64 [%328, %$23] ; # Tail0
  %347 = phi i64 [%329, %$23] ; # Tail1
  %348 = phi i64 [%330, %$23] ; # Last
  br label %$46
$46:
  %349 = phi i64 [%332, %$44], [%341, %$45] ; # Out0
  %350 = phi i64 [%333, %$44], [%345, %$45] ; # Out1
  %351 = phi i64 [%334, %$44], [%343, %$45] ; # In0
  %352 = phi i64 [%335, %$44], [%344, %$45] ; # In1
  %353 = phi i64 [%336, %$44], [%345, %$45] ; # P
  %354 = phi i64 [%337, %$44], [%346, %$45] ; # Tail0
  %355 = phi i64 [%338, %$44], [%347, %$45] ; # Tail1
  %356 = phi i64 [%339, %$44], [%348, %$45] ; # Last
  %357 = phi i64 [%336, %$44], [%345, %$45] ; # ->
; # (ofs (if Tail0 (set Tail0 P) (setq Out1 P)) 1)
  %358 = add i64 %357, 8
; # (set 2 P $Nil)
  %359 = inttoptr i64 %353 to i64*
  %360 = getelementptr i64, i64* %359, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %360
; # (car P)
  %361 = inttoptr i64 %353 to i64*
  %362 = load i64, i64* %361
  br label %$18
$22:
  %363 = phi i64 [%84, %$19] ; # Out0
  %364 = phi i64 [%85, %$19] ; # Out1
  %365 = phi i64 [%86, %$19] ; # In0
  %366 = phi i64 [%87, %$19] ; # In1
  %367 = phi i64 [%88, %$19] ; # P
  %368 = phi i64 [%89, %$19] ; # Tail0
  %369 = phi i64 [%90, %$19] ; # Tail1
  %370 = phi i64 [%91, %$19] ; # Last
; # (? (atom Out1) Out0)
; # (atom Out1)
  %371 = and i64 %364, 15
  %372 = icmp ne i64 %371, 0
  br i1 %372, label %$49, label %$47
$49:
  %373 = phi i64 [%363, %$22] ; # Out0
  %374 = phi i64 [%364, %$22] ; # Out1
  br label %$48
$47:
  %375 = phi i64 [%363, %$22] ; # Out0
  %376 = phi i64 [%364, %$22] ; # Out1
  br label %$12
$48:
  %377 = phi i64 [%373, %$49] ; # Out0
  %378 = phi i64 [%374, %$49] ; # Out1
  %379 = phi i64 [%373, %$49] ; # ->
  br label %$7
$10:
; # (let (Out0 (link (push Y NIL) T) Out1 (link (push $Nil NIL)) In0 ...
; # (push Y NIL)
  %380 = alloca i64, i64 2, align 16
  %381 = ptrtoint i64* %380 to i64
  %382 = inttoptr i64 %381 to i64*
  store i64 %15, i64* %382
; # (link (push Y NIL) T)
  %383 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %384 = load i64, i64* %383
  %385 = inttoptr i64 %381 to i64*
  %386 = getelementptr i64, i64* %385, i32 1
  store i64 %384, i64* %386
  %387 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %381, i64* %387
; # (push $Nil NIL)
  %388 = alloca i64, i64 2, align 16
  %389 = ptrtoint i64* %388 to i64
  %390 = inttoptr i64 %389 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %390
; # (link (push $Nil NIL))
  %391 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %392 = load i64, i64* %391
  %393 = inttoptr i64 %389 to i64*
  %394 = getelementptr i64, i64* %393, i32 1
  store i64 %392, i64* %394
  %395 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %389, i64* %395
; # (push -ZERO NIL)
  %396 = alloca i64, i64 2, align 16
  %397 = ptrtoint i64* %396 to i64
  %398 = inttoptr i64 %397 to i64*
  store i64 10, i64* %398
; # (link (push -ZERO NIL))
  %399 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %400 = load i64, i64* %399
  %401 = inttoptr i64 %397 to i64*
  %402 = getelementptr i64, i64* %401, i32 1
  store i64 %400, i64* %402
  %403 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %397, i64* %403
; # (push -ZERO NIL)
  %404 = alloca i64, i64 2, align 16
  %405 = ptrtoint i64* %404 to i64
  %406 = inttoptr i64 %405 to i64*
  store i64 10, i64* %406
; # (link (push -ZERO NIL))
  %407 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %408 = load i64, i64* %407
  %409 = inttoptr i64 %405 to i64*
  %410 = getelementptr i64, i64* %409, i32 1
  store i64 %408, i64* %410
  %411 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %405, i64* %411
; # (push NIL $Nil ZERO NIL)
  %412 = alloca i64, i64 4, align 16
  %413 = ptrtoint i64* %412 to i64
  %414 = add i64 %413, 8
  %415 = inttoptr i64 %414 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %415
  %416 = add i64 %413, 16
  %417 = inttoptr i64 %416 to i64*
  store i64 2, i64* %417
; # (push NIL B ZERO NIL)
  %418 = alloca i64, i64 4, align 16
  %419 = ptrtoint i64* %418 to i64
  %420 = add i64 %419, 8
  %421 = inttoptr i64 %420 to i64*
  store i64 %413, i64* %421
  %422 = add i64 %419, 16
  %423 = inttoptr i64 %422 to i64*
  store i64 2, i64* %423
; # (car X)
  %424 = inttoptr i64 %7 to i64*
  %425 = load i64, i64* %424
; # (eval (car X))
  %426 = and i64 %425, 6
  %427 = icmp ne i64 %426, 0
  br i1 %427, label %$52, label %$51
$52:
  br label %$50
$51:
  %428 = and i64 %425, 8
  %429 = icmp ne i64 %428, 0
  br i1 %429, label %$54, label %$53
$54:
  %430 = inttoptr i64 %425 to i64*
  %431 = load i64, i64* %430
  br label %$50
$53:
  %432 = call i64 @evList(i64 %425)
  br label %$50
$50:
  %433 = phi i64 [%425, %$52], [%431, %$54], [%432, %$53] ; # ->
; # (push NIL A ZERO (eval (car X)) NIL)
  %434 = alloca i64, i64 5, align 16
  %435 = ptrtoint i64* %434 to i64
  %436 = add i64 %435, 8
  %437 = inttoptr i64 %436 to i64*
  store i64 %419, i64* %437
  %438 = add i64 %435, 16
  %439 = inttoptr i64 %438 to i64*
  store i64 2, i64* %439
  %440 = add i64 %435, 24
  %441 = inttoptr i64 %440 to i64*
  store i64 %433, i64* %441
; # (set B (ofs B 3) A (ofs A 3) E (link (ofs E 3)))
; # (ofs B 3)
  %442 = add i64 %413, 24
  %443 = inttoptr i64 %413 to i64*
  store i64 %442, i64* %443
; # (ofs A 3)
  %444 = add i64 %419, 24
  %445 = inttoptr i64 %419 to i64*
  store i64 %444, i64* %445
; # (ofs E 3)
  %446 = add i64 %435, 24
; # (link (ofs E 3))
  %447 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %448 = load i64, i64* %447
  %449 = inttoptr i64 %446 to i64*
  %450 = getelementptr i64, i64* %449, i32 1
  store i64 %448, i64* %450
  %451 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %446, i64* %451
  %452 = inttoptr i64 %435 to i64*
  store i64 %446, i64* %452
; # (loop (set In0 (val Out0) In1 (val Out1)) (if (and (pair (val In1...
  br label %$55
$55:
  %453 = phi i64 [%413, %$50], [%896, %$114] ; # B
  %454 = phi i64 [%419, %$50], [%897, %$114] ; # A
  %455 = phi i64 [%435, %$50], [%898, %$114] ; # E
; # (set In0 (val Out0) In1 (val Out1))
; # (val Out0)
  %456 = inttoptr i64 %381 to i64*
  %457 = load i64, i64* %456
  %458 = inttoptr i64 %397 to i64*
  store i64 %457, i64* %458
; # (val Out1)
  %459 = inttoptr i64 %389 to i64*
  %460 = load i64, i64* %459
  %461 = inttoptr i64 %405 to i64*
  store i64 %460, i64* %461
; # (if (and (pair (val In1)) (ge0 (cmpSort (caar In0) (caar In1)))) ...
; # (and (pair (val In1)) (ge0 (cmpSort (caar In0) (caar In1))))
; # (val In1)
  %462 = inttoptr i64 %405 to i64*
  %463 = load i64, i64* %462
; # (pair (val In1))
  %464 = and i64 %463, 15
  %465 = icmp eq i64 %464, 0
  br i1 %465, label %$57, label %$56
$57:
  %466 = phi i64 [%453, %$55] ; # B
  %467 = phi i64 [%454, %$55] ; # A
  %468 = phi i64 [%455, %$55] ; # E
; # (caar In0)
  %469 = inttoptr i64 %397 to i64*
  %470 = load i64, i64* %469
  %471 = inttoptr i64 %470 to i64*
  %472 = load i64, i64* %471
; # (caar In1)
  %473 = inttoptr i64 %405 to i64*
  %474 = load i64, i64* %473
  %475 = inttoptr i64 %474 to i64*
  %476 = load i64, i64* %475
; # (cmpSort (caar In0) (caar In1))
  %477 = inttoptr i64 %467 to i64*
  %478 = getelementptr i64, i64* %477, i32 3
  store i64 %472, i64* %478
  %479 = inttoptr i64 %466 to i64*
  %480 = getelementptr i64, i64* %479, i32 3
  store i64 %476, i64* %480
  %481 = call i64 @evList(i64 %468)
  %482 = icmp eq i64 %481, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %482, label %$58, label %$59
$58:
  br label %$60
$59:
  br label %$60
$60:
  %483 = phi i64 [0, %$58], [-1, %$59] ; # ->
; # (ge0 (cmpSort (caar In0) (caar In1)))
  %484 = icmp sge i64 %483, 0
  br label %$56
$56:
  %485 = phi i64 [%453, %$55], [%466, %$60] ; # B
  %486 = phi i64 [%454, %$55], [%467, %$60] ; # A
  %487 = phi i64 [%455, %$55], [%468, %$60] ; # E
  %488 = phi i1 [0, %$55], [%484, %$60] ; # ->
  br i1 %488, label %$61, label %$62
$61:
  %489 = phi i64 [%485, %$56] ; # B
  %490 = phi i64 [%486, %$56] ; # A
  %491 = phi i64 [%487, %$56] ; # E
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %492 = inttoptr i64 %405 to i64*
  %493 = load i64, i64* %492
; # (cdr (setq P (val In1)))
  %494 = inttoptr i64 %493 to i64*
  %495 = getelementptr i64, i64* %494, i32 1
  %496 = load i64, i64* %495
  %497 = inttoptr i64 %405 to i64*
  store i64 %496, i64* %497
  br label %$63
$62:
  %498 = phi i64 [%485, %$56] ; # B
  %499 = phi i64 [%486, %$56] ; # A
  %500 = phi i64 [%487, %$56] ; # E
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %501 = inttoptr i64 %397 to i64*
  %502 = load i64, i64* %501
; # (cdr (setq P (val In0)))
  %503 = inttoptr i64 %502 to i64*
  %504 = getelementptr i64, i64* %503, i32 1
  %505 = load i64, i64* %504
  %506 = inttoptr i64 %397 to i64*
  store i64 %505, i64* %506
  br label %$63
$63:
  %507 = phi i64 [%489, %$61], [%498, %$62] ; # B
  %508 = phi i64 [%490, %$61], [%499, %$62] ; # A
  %509 = phi i64 [%491, %$61], [%500, %$62] ; # E
  %510 = phi i64 [%493, %$61], [%502, %$62] ; # P
  %511 = phi i64 [%496, %$61], [%505, %$62] ; # ->
; # (let (Tail0 (ofs P 1) Tail1 0 Last (car P)) (set Out0 P Out1 $Nil...
; # (ofs P 1)
  %512 = add i64 %510, 8
; # (car P)
  %513 = inttoptr i64 %510 to i64*
  %514 = load i64, i64* %513
; # (set Out0 P Out1 $Nil)
  %515 = inttoptr i64 %381 to i64*
  store i64 %510, i64* %515
  %516 = inttoptr i64 %389 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %516
; # (set 2 P $Nil)
  %517 = inttoptr i64 %510 to i64*
  %518 = getelementptr i64, i64* %517, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %518
; # (while (or (pair (val In0)) (pair (val In1))) (cond ((atom (val I...
  br label %$64
$64:
  %519 = phi i64 [%507, %$63], [%866, %$113] ; # B
  %520 = phi i64 [%508, %$63], [%867, %$113] ; # A
  %521 = phi i64 [%509, %$63], [%868, %$113] ; # E
  %522 = phi i64 [%510, %$63], [%869, %$113] ; # P
  %523 = phi i64 [%512, %$63], [%874, %$113] ; # Tail0
  %524 = phi i64 [0, %$63], [%871, %$113] ; # Tail1
  %525 = phi i64 [%514, %$63], [%878, %$113] ; # Last
; # (or (pair (val In0)) (pair (val In1)))
; # (val In0)
  %526 = inttoptr i64 %397 to i64*
  %527 = load i64, i64* %526
; # (pair (val In0))
  %528 = and i64 %527, 15
  %529 = icmp eq i64 %528, 0
  br i1 %529, label %$65, label %$66
$66:
  %530 = phi i64 [%519, %$64] ; # B
  %531 = phi i64 [%520, %$64] ; # A
  %532 = phi i64 [%521, %$64] ; # E
  %533 = phi i64 [%522, %$64] ; # P
  %534 = phi i64 [%523, %$64] ; # Tail0
  %535 = phi i64 [%524, %$64] ; # Tail1
  %536 = phi i64 [%525, %$64] ; # Last
; # (val In1)
  %537 = inttoptr i64 %405 to i64*
  %538 = load i64, i64* %537
; # (pair (val In1))
  %539 = and i64 %538, 15
  %540 = icmp eq i64 %539, 0
  br label %$65
$65:
  %541 = phi i64 [%519, %$64], [%530, %$66] ; # B
  %542 = phi i64 [%520, %$64], [%531, %$66] ; # A
  %543 = phi i64 [%521, %$64], [%532, %$66] ; # E
  %544 = phi i64 [%522, %$64], [%533, %$66] ; # P
  %545 = phi i64 [%523, %$64], [%534, %$66] ; # Tail0
  %546 = phi i64 [%524, %$64], [%535, %$66] ; # Tail1
  %547 = phi i64 [%525, %$64], [%536, %$66] ; # Last
  %548 = phi i1 [1, %$64], [%540, %$66] ; # ->
  br i1 %548, label %$67, label %$68
$67:
  %549 = phi i64 [%541, %$65] ; # B
  %550 = phi i64 [%542, %$65] ; # A
  %551 = phi i64 [%543, %$65] ; # E
  %552 = phi i64 [%544, %$65] ; # P
  %553 = phi i64 [%545, %$65] ; # Tail0
  %554 = phi i64 [%546, %$65] ; # Tail1
  %555 = phi i64 [%547, %$65] ; # Last
; # (cond ((atom (val In1)) (set In0 (cdr (setq P (val In0)))) (when ...
; # (val In1)
  %556 = inttoptr i64 %405 to i64*
  %557 = load i64, i64* %556
; # (atom (val In1))
  %558 = and i64 %557, 15
  %559 = icmp ne i64 %558, 0
  br i1 %559, label %$71, label %$70
$71:
  %560 = phi i64 [%549, %$67] ; # B
  %561 = phi i64 [%550, %$67] ; # A
  %562 = phi i64 [%551, %$67] ; # E
  %563 = phi i64 [%552, %$67] ; # P
  %564 = phi i64 [%553, %$67] ; # Tail0
  %565 = phi i64 [%554, %$67] ; # Tail1
  %566 = phi i64 [%555, %$67] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %567 = inttoptr i64 %397 to i64*
  %568 = load i64, i64* %567
; # (cdr (setq P (val In0)))
  %569 = inttoptr i64 %568 to i64*
  %570 = getelementptr i64, i64* %569, i32 1
  %571 = load i64, i64* %570
  %572 = inttoptr i64 %397 to i64*
  store i64 %571, i64* %572
; # (when (lt0 (cmpSort (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %573 = inttoptr i64 %568 to i64*
  %574 = load i64, i64* %573
; # (cmpSort (car P) Last)
  %575 = inttoptr i64 %561 to i64*
  %576 = getelementptr i64, i64* %575, i32 3
  store i64 %574, i64* %576
  %577 = inttoptr i64 %560 to i64*
  %578 = getelementptr i64, i64* %577, i32 3
  store i64 %566, i64* %578
  %579 = call i64 @evList(i64 %562)
  %580 = icmp eq i64 %579, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %580, label %$72, label %$73
$72:
  br label %$74
$73:
  br label %$74
$74:
  %581 = phi i64 [0, %$72], [-1, %$73] ; # ->
; # (lt0 (cmpSort (car P) Last))
  %582 = icmp slt i64 %581, 0
  br i1 %582, label %$75, label %$76
$75:
  %583 = phi i64 [%560, %$74] ; # B
  %584 = phi i64 [%561, %$74] ; # A
  %585 = phi i64 [%562, %$74] ; # E
  %586 = phi i64 [%568, %$74] ; # P
  %587 = phi i64 [%564, %$74] ; # Tail0
  %588 = phi i64 [%565, %$74] ; # Tail1
  %589 = phi i64 [%566, %$74] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$76
$76:
  %590 = phi i64 [%560, %$74], [%583, %$75] ; # B
  %591 = phi i64 [%561, %$74], [%584, %$75] ; # A
  %592 = phi i64 [%562, %$74], [%585, %$75] ; # E
  %593 = phi i64 [%568, %$74], [%586, %$75] ; # P
  %594 = phi i64 [%564, %$74], [%588, %$75] ; # Tail0
  %595 = phi i64 [%565, %$74], [%587, %$75] ; # Tail1
  %596 = phi i64 [%566, %$74], [%589, %$75] ; # Last
  br label %$69
$70:
  %597 = phi i64 [%549, %$67] ; # B
  %598 = phi i64 [%550, %$67] ; # A
  %599 = phi i64 [%551, %$67] ; # E
  %600 = phi i64 [%552, %$67] ; # P
  %601 = phi i64 [%553, %$67] ; # Tail0
  %602 = phi i64 [%554, %$67] ; # Tail1
  %603 = phi i64 [%555, %$67] ; # Last
; # (val In0)
  %604 = inttoptr i64 %397 to i64*
  %605 = load i64, i64* %604
; # (atom (val In0))
  %606 = and i64 %605, 15
  %607 = icmp ne i64 %606, 0
  br i1 %607, label %$78, label %$77
$78:
  %608 = phi i64 [%597, %$70] ; # B
  %609 = phi i64 [%598, %$70] ; # A
  %610 = phi i64 [%599, %$70] ; # E
  %611 = phi i64 [%600, %$70] ; # P
  %612 = phi i64 [%601, %$70] ; # Tail0
  %613 = phi i64 [%602, %$70] ; # Tail1
  %614 = phi i64 [%603, %$70] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %615 = inttoptr i64 %405 to i64*
  %616 = load i64, i64* %615
; # (cdr (setq P (val In1)))
  %617 = inttoptr i64 %616 to i64*
  %618 = getelementptr i64, i64* %617, i32 1
  %619 = load i64, i64* %618
  %620 = inttoptr i64 %405 to i64*
  store i64 %619, i64* %620
; # (when (lt0 (cmpSort (car P) Last)) (xchg 'Tail0 'Tail1))
; # (car P)
  %621 = inttoptr i64 %616 to i64*
  %622 = load i64, i64* %621
; # (cmpSort (car P) Last)
  %623 = inttoptr i64 %609 to i64*
  %624 = getelementptr i64, i64* %623, i32 3
  store i64 %622, i64* %624
  %625 = inttoptr i64 %608 to i64*
  %626 = getelementptr i64, i64* %625, i32 3
  store i64 %614, i64* %626
  %627 = call i64 @evList(i64 %610)
  %628 = icmp eq i64 %627, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %628, label %$79, label %$80
$79:
  br label %$81
$80:
  br label %$81
$81:
  %629 = phi i64 [0, %$79], [-1, %$80] ; # ->
; # (lt0 (cmpSort (car P) Last))
  %630 = icmp slt i64 %629, 0
  br i1 %630, label %$82, label %$83
$82:
  %631 = phi i64 [%608, %$81] ; # B
  %632 = phi i64 [%609, %$81] ; # A
  %633 = phi i64 [%610, %$81] ; # E
  %634 = phi i64 [%616, %$81] ; # P
  %635 = phi i64 [%612, %$81] ; # Tail0
  %636 = phi i64 [%613, %$81] ; # Tail1
  %637 = phi i64 [%614, %$81] ; # Last
; # (xchg 'Tail0 'Tail1)
  br label %$83
$83:
  %638 = phi i64 [%608, %$81], [%631, %$82] ; # B
  %639 = phi i64 [%609, %$81], [%632, %$82] ; # A
  %640 = phi i64 [%610, %$81], [%633, %$82] ; # E
  %641 = phi i64 [%616, %$81], [%634, %$82] ; # P
  %642 = phi i64 [%612, %$81], [%636, %$82] ; # Tail0
  %643 = phi i64 [%613, %$81], [%635, %$82] ; # Tail1
  %644 = phi i64 [%614, %$81], [%637, %$82] ; # Last
  br label %$69
$77:
  %645 = phi i64 [%597, %$70] ; # B
  %646 = phi i64 [%598, %$70] ; # A
  %647 = phi i64 [%599, %$70] ; # E
  %648 = phi i64 [%600, %$70] ; # P
  %649 = phi i64 [%601, %$70] ; # Tail0
  %650 = phi i64 [%602, %$70] ; # Tail1
  %651 = phi i64 [%603, %$70] ; # Last
; # (caar In0)
  %652 = inttoptr i64 %397 to i64*
  %653 = load i64, i64* %652
  %654 = inttoptr i64 %653 to i64*
  %655 = load i64, i64* %654
; # (cmpSort (caar In0) Last)
  %656 = inttoptr i64 %646 to i64*
  %657 = getelementptr i64, i64* %656, i32 3
  store i64 %655, i64* %657
  %658 = inttoptr i64 %645 to i64*
  %659 = getelementptr i64, i64* %658, i32 3
  store i64 %651, i64* %659
  %660 = call i64 @evList(i64 %647)
  %661 = icmp eq i64 %660, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %661, label %$84, label %$85
$84:
  br label %$86
$85:
  br label %$86
$86:
  %662 = phi i64 [0, %$84], [-1, %$85] ; # ->
; # (lt0 (cmpSort (caar In0) Last))
  %663 = icmp slt i64 %662, 0
  br i1 %663, label %$88, label %$87
$88:
  %664 = phi i64 [%645, %$86] ; # B
  %665 = phi i64 [%646, %$86] ; # A
  %666 = phi i64 [%647, %$86] ; # E
  %667 = phi i64 [%648, %$86] ; # P
  %668 = phi i64 [%649, %$86] ; # Tail0
  %669 = phi i64 [%650, %$86] ; # Tail1
  %670 = phi i64 [%651, %$86] ; # Last
; # (if (ge0 (cmpSort (caar In1) Last)) (set In1 (cdr (setq P (val In...
; # (caar In1)
  %671 = inttoptr i64 %405 to i64*
  %672 = load i64, i64* %671
  %673 = inttoptr i64 %672 to i64*
  %674 = load i64, i64* %673
; # (cmpSort (caar In1) Last)
  %675 = inttoptr i64 %665 to i64*
  %676 = getelementptr i64, i64* %675, i32 3
  store i64 %674, i64* %676
  %677 = inttoptr i64 %664 to i64*
  %678 = getelementptr i64, i64* %677, i32 3
  store i64 %670, i64* %678
  %679 = call i64 @evList(i64 %666)
  %680 = icmp eq i64 %679, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %680, label %$89, label %$90
$89:
  br label %$91
$90:
  br label %$91
$91:
  %681 = phi i64 [0, %$89], [-1, %$90] ; # ->
; # (ge0 (cmpSort (caar In1) Last))
  %682 = icmp sge i64 %681, 0
  br i1 %682, label %$92, label %$93
$92:
  %683 = phi i64 [%664, %$91] ; # B
  %684 = phi i64 [%665, %$91] ; # A
  %685 = phi i64 [%666, %$91] ; # E
  %686 = phi i64 [%667, %$91] ; # P
  %687 = phi i64 [%668, %$91] ; # Tail0
  %688 = phi i64 [%669, %$91] ; # Tail1
  %689 = phi i64 [%670, %$91] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %690 = inttoptr i64 %405 to i64*
  %691 = load i64, i64* %690
; # (cdr (setq P (val In1)))
  %692 = inttoptr i64 %691 to i64*
  %693 = getelementptr i64, i64* %692, i32 1
  %694 = load i64, i64* %693
  %695 = inttoptr i64 %405 to i64*
  store i64 %694, i64* %695
  br label %$94
$93:
  %696 = phi i64 [%664, %$91] ; # B
  %697 = phi i64 [%665, %$91] ; # A
  %698 = phi i64 [%666, %$91] ; # E
  %699 = phi i64 [%667, %$91] ; # P
  %700 = phi i64 [%668, %$91] ; # Tail0
  %701 = phi i64 [%669, %$91] ; # Tail1
  %702 = phi i64 [%670, %$91] ; # Last
; # (if (lt0 (cmpSort (caar In0) (caar In1))) (set In0 (cdr (setq P (...
; # (caar In0)
  %703 = inttoptr i64 %397 to i64*
  %704 = load i64, i64* %703
  %705 = inttoptr i64 %704 to i64*
  %706 = load i64, i64* %705
; # (caar In1)
  %707 = inttoptr i64 %405 to i64*
  %708 = load i64, i64* %707
  %709 = inttoptr i64 %708 to i64*
  %710 = load i64, i64* %709
; # (cmpSort (caar In0) (caar In1))
  %711 = inttoptr i64 %697 to i64*
  %712 = getelementptr i64, i64* %711, i32 3
  store i64 %706, i64* %712
  %713 = inttoptr i64 %696 to i64*
  %714 = getelementptr i64, i64* %713, i32 3
  store i64 %710, i64* %714
  %715 = call i64 @evList(i64 %698)
  %716 = icmp eq i64 %715, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %716, label %$95, label %$96
$95:
  br label %$97
$96:
  br label %$97
$97:
  %717 = phi i64 [0, %$95], [-1, %$96] ; # ->
; # (lt0 (cmpSort (caar In0) (caar In1)))
  %718 = icmp slt i64 %717, 0
  br i1 %718, label %$98, label %$99
$98:
  %719 = phi i64 [%696, %$97] ; # B
  %720 = phi i64 [%697, %$97] ; # A
  %721 = phi i64 [%698, %$97] ; # E
  %722 = phi i64 [%699, %$97] ; # P
  %723 = phi i64 [%700, %$97] ; # Tail0
  %724 = phi i64 [%701, %$97] ; # Tail1
  %725 = phi i64 [%702, %$97] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %726 = inttoptr i64 %397 to i64*
  %727 = load i64, i64* %726
; # (cdr (setq P (val In0)))
  %728 = inttoptr i64 %727 to i64*
  %729 = getelementptr i64, i64* %728, i32 1
  %730 = load i64, i64* %729
  %731 = inttoptr i64 %397 to i64*
  store i64 %730, i64* %731
  br label %$100
$99:
  %732 = phi i64 [%696, %$97] ; # B
  %733 = phi i64 [%697, %$97] ; # A
  %734 = phi i64 [%698, %$97] ; # E
  %735 = phi i64 [%699, %$97] ; # P
  %736 = phi i64 [%700, %$97] ; # Tail0
  %737 = phi i64 [%701, %$97] ; # Tail1
  %738 = phi i64 [%702, %$97] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %739 = inttoptr i64 %405 to i64*
  %740 = load i64, i64* %739
; # (cdr (setq P (val In1)))
  %741 = inttoptr i64 %740 to i64*
  %742 = getelementptr i64, i64* %741, i32 1
  %743 = load i64, i64* %742
  %744 = inttoptr i64 %405 to i64*
  store i64 %743, i64* %744
  br label %$100
$100:
  %745 = phi i64 [%719, %$98], [%732, %$99] ; # B
  %746 = phi i64 [%720, %$98], [%733, %$99] ; # A
  %747 = phi i64 [%721, %$98], [%734, %$99] ; # E
  %748 = phi i64 [%727, %$98], [%740, %$99] ; # P
  %749 = phi i64 [%723, %$98], [%736, %$99] ; # Tail0
  %750 = phi i64 [%724, %$98], [%737, %$99] ; # Tail1
  %751 = phi i64 [%725, %$98], [%738, %$99] ; # Last
  %752 = phi i64 [%730, %$98], [%743, %$99] ; # ->
; # (xchg 'Tail0 'Tail1)
  br label %$94
$94:
  %753 = phi i64 [%683, %$92], [%745, %$100] ; # B
  %754 = phi i64 [%684, %$92], [%746, %$100] ; # A
  %755 = phi i64 [%685, %$92], [%747, %$100] ; # E
  %756 = phi i64 [%691, %$92], [%748, %$100] ; # P
  %757 = phi i64 [%687, %$92], [%750, %$100] ; # Tail0
  %758 = phi i64 [%688, %$92], [%749, %$100] ; # Tail1
  %759 = phi i64 [%689, %$92], [%751, %$100] ; # Last
  %760 = phi i64 [%694, %$92], [%749, %$100] ; # ->
  br label %$69
$87:
  %761 = phi i64 [%645, %$86] ; # B
  %762 = phi i64 [%646, %$86] ; # A
  %763 = phi i64 [%647, %$86] ; # E
  %764 = phi i64 [%648, %$86] ; # P
  %765 = phi i64 [%649, %$86] ; # Tail0
  %766 = phi i64 [%650, %$86] ; # Tail1
  %767 = phi i64 [%651, %$86] ; # Last
; # (caar In1)
  %768 = inttoptr i64 %405 to i64*
  %769 = load i64, i64* %768
  %770 = inttoptr i64 %769 to i64*
  %771 = load i64, i64* %770
; # (cmpSort (caar In1) Last)
  %772 = inttoptr i64 %762 to i64*
  %773 = getelementptr i64, i64* %772, i32 3
  store i64 %771, i64* %773
  %774 = inttoptr i64 %761 to i64*
  %775 = getelementptr i64, i64* %774, i32 3
  store i64 %767, i64* %775
  %776 = call i64 @evList(i64 %763)
  %777 = icmp eq i64 %776, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %777, label %$101, label %$102
$101:
  br label %$103
$102:
  br label %$103
$103:
  %778 = phi i64 [0, %$101], [-1, %$102] ; # ->
; # (lt0 (cmpSort (caar In1) Last))
  %779 = icmp slt i64 %778, 0
  br i1 %779, label %$105, label %$104
$105:
  %780 = phi i64 [%761, %$103] ; # B
  %781 = phi i64 [%762, %$103] ; # A
  %782 = phi i64 [%763, %$103] ; # E
  %783 = phi i64 [%764, %$103] ; # P
  %784 = phi i64 [%765, %$103] ; # Tail0
  %785 = phi i64 [%766, %$103] ; # Tail1
  %786 = phi i64 [%767, %$103] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %787 = inttoptr i64 %397 to i64*
  %788 = load i64, i64* %787
; # (cdr (setq P (val In0)))
  %789 = inttoptr i64 %788 to i64*
  %790 = getelementptr i64, i64* %789, i32 1
  %791 = load i64, i64* %790
  %792 = inttoptr i64 %397 to i64*
  store i64 %791, i64* %792
  br label %$69
$104:
  %793 = phi i64 [%761, %$103] ; # B
  %794 = phi i64 [%762, %$103] ; # A
  %795 = phi i64 [%763, %$103] ; # E
  %796 = phi i64 [%764, %$103] ; # P
  %797 = phi i64 [%765, %$103] ; # Tail0
  %798 = phi i64 [%766, %$103] ; # Tail1
  %799 = phi i64 [%767, %$103] ; # Last
; # (caar In0)
  %800 = inttoptr i64 %397 to i64*
  %801 = load i64, i64* %800
  %802 = inttoptr i64 %801 to i64*
  %803 = load i64, i64* %802
; # (caar In1)
  %804 = inttoptr i64 %405 to i64*
  %805 = load i64, i64* %804
  %806 = inttoptr i64 %805 to i64*
  %807 = load i64, i64* %806
; # (cmpSort (caar In0) (caar In1))
  %808 = inttoptr i64 %794 to i64*
  %809 = getelementptr i64, i64* %808, i32 3
  store i64 %803, i64* %809
  %810 = inttoptr i64 %793 to i64*
  %811 = getelementptr i64, i64* %810, i32 3
  store i64 %807, i64* %811
  %812 = call i64 @evList(i64 %795)
  %813 = icmp eq i64 %812, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %813, label %$106, label %$107
$106:
  br label %$108
$107:
  br label %$108
$108:
  %814 = phi i64 [0, %$106], [-1, %$107] ; # ->
; # (lt0 (cmpSort (caar In0) (caar In1)))
  %815 = icmp slt i64 %814, 0
  br i1 %815, label %$110, label %$109
$110:
  %816 = phi i64 [%793, %$108] ; # B
  %817 = phi i64 [%794, %$108] ; # A
  %818 = phi i64 [%795, %$108] ; # E
  %819 = phi i64 [%796, %$108] ; # P
  %820 = phi i64 [%797, %$108] ; # Tail0
  %821 = phi i64 [%798, %$108] ; # Tail1
  %822 = phi i64 [%799, %$108] ; # Last
; # (set In0 (cdr (setq P (val In0))))
; # (val In0)
  %823 = inttoptr i64 %397 to i64*
  %824 = load i64, i64* %823
; # (cdr (setq P (val In0)))
  %825 = inttoptr i64 %824 to i64*
  %826 = getelementptr i64, i64* %825, i32 1
  %827 = load i64, i64* %826
  %828 = inttoptr i64 %397 to i64*
  store i64 %827, i64* %828
  br label %$69
$109:
  %829 = phi i64 [%793, %$108] ; # B
  %830 = phi i64 [%794, %$108] ; # A
  %831 = phi i64 [%795, %$108] ; # E
  %832 = phi i64 [%796, %$108] ; # P
  %833 = phi i64 [%797, %$108] ; # Tail0
  %834 = phi i64 [%798, %$108] ; # Tail1
  %835 = phi i64 [%799, %$108] ; # Last
; # (set In1 (cdr (setq P (val In1))))
; # (val In1)
  %836 = inttoptr i64 %405 to i64*
  %837 = load i64, i64* %836
; # (cdr (setq P (val In1)))
  %838 = inttoptr i64 %837 to i64*
  %839 = getelementptr i64, i64* %838, i32 1
  %840 = load i64, i64* %839
  %841 = inttoptr i64 %405 to i64*
  store i64 %840, i64* %841
  br label %$69
$69:
  %842 = phi i64 [%590, %$76], [%638, %$83], [%753, %$94], [%780, %$105], [%816, %$110], [%829, %$109] ; # B
  %843 = phi i64 [%591, %$76], [%639, %$83], [%754, %$94], [%781, %$105], [%817, %$110], [%830, %$109] ; # A
  %844 = phi i64 [%592, %$76], [%640, %$83], [%755, %$94], [%782, %$105], [%818, %$110], [%831, %$109] ; # E
  %845 = phi i64 [%593, %$76], [%641, %$83], [%756, %$94], [%788, %$105], [%824, %$110], [%837, %$109] ; # P
  %846 = phi i64 [%594, %$76], [%642, %$83], [%757, %$94], [%784, %$105], [%820, %$110], [%833, %$109] ; # Tail0
  %847 = phi i64 [%595, %$76], [%643, %$83], [%758, %$94], [%785, %$105], [%821, %$110], [%834, %$109] ; # Tail1
  %848 = phi i64 [%596, %$76], [%644, %$83], [%759, %$94], [%786, %$105], [%822, %$110], [%835, %$109] ; # Last
; # (if Tail0 (set Tail0 P) (set Out1 P))
  %849 = icmp ne i64 %846, 0
  br i1 %849, label %$111, label %$112
$111:
  %850 = phi i64 [%842, %$69] ; # B
  %851 = phi i64 [%843, %$69] ; # A
  %852 = phi i64 [%844, %$69] ; # E
  %853 = phi i64 [%845, %$69] ; # P
  %854 = phi i64 [%846, %$69] ; # Tail0
  %855 = phi i64 [%847, %$69] ; # Tail1
  %856 = phi i64 [%848, %$69] ; # Last
; # (set Tail0 P)
  %857 = inttoptr i64 %854 to i64*
  store i64 %853, i64* %857
  br label %$113
$112:
  %858 = phi i64 [%842, %$69] ; # B
  %859 = phi i64 [%843, %$69] ; # A
  %860 = phi i64 [%844, %$69] ; # E
  %861 = phi i64 [%845, %$69] ; # P
  %862 = phi i64 [%846, %$69] ; # Tail0
  %863 = phi i64 [%847, %$69] ; # Tail1
  %864 = phi i64 [%848, %$69] ; # Last
; # (set Out1 P)
  %865 = inttoptr i64 %389 to i64*
  store i64 %861, i64* %865
  br label %$113
$113:
  %866 = phi i64 [%850, %$111], [%858, %$112] ; # B
  %867 = phi i64 [%851, %$111], [%859, %$112] ; # A
  %868 = phi i64 [%852, %$111], [%860, %$112] ; # E
  %869 = phi i64 [%853, %$111], [%861, %$112] ; # P
  %870 = phi i64 [%854, %$111], [%862, %$112] ; # Tail0
  %871 = phi i64 [%855, %$111], [%863, %$112] ; # Tail1
  %872 = phi i64 [%856, %$111], [%864, %$112] ; # Last
  %873 = phi i64 [%853, %$111], [%861, %$112] ; # ->
; # (ofs (if Tail0 (set Tail0 P) (set Out1 P)) 1)
  %874 = add i64 %873, 8
; # (set 2 P $Nil)
  %875 = inttoptr i64 %869 to i64*
  %876 = getelementptr i64, i64* %875, i32 1
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %876
; # (car P)
  %877 = inttoptr i64 %869 to i64*
  %878 = load i64, i64* %877
  br label %$64
$68:
  %879 = phi i64 [%541, %$65] ; # B
  %880 = phi i64 [%542, %$65] ; # A
  %881 = phi i64 [%543, %$65] ; # E
  %882 = phi i64 [%544, %$65] ; # P
  %883 = phi i64 [%545, %$65] ; # Tail0
  %884 = phi i64 [%546, %$65] ; # Tail1
  %885 = phi i64 [%547, %$65] ; # Last
; # (? (atom (val Out1)) (val Out0))
; # (val Out1)
  %886 = inttoptr i64 %389 to i64*
  %887 = load i64, i64* %886
; # (atom (val Out1))
  %888 = and i64 %887, 15
  %889 = icmp ne i64 %888, 0
  br i1 %889, label %$116, label %$114
$116:
  %890 = phi i64 [%879, %$68] ; # B
  %891 = phi i64 [%880, %$68] ; # A
  %892 = phi i64 [%881, %$68] ; # E
  %893 = phi i64 [%882, %$68] ; # P
; # (val Out0)
  %894 = inttoptr i64 %381 to i64*
  %895 = load i64, i64* %894
  br label %$115
$114:
  %896 = phi i64 [%879, %$68] ; # B
  %897 = phi i64 [%880, %$68] ; # A
  %898 = phi i64 [%881, %$68] ; # E
  %899 = phi i64 [%882, %$68] ; # P
  br label %$55
$115:
  %900 = phi i64 [%890, %$116] ; # B
  %901 = phi i64 [%891, %$116] ; # A
  %902 = phi i64 [%892, %$116] ; # E
  %903 = phi i64 [%893, %$116] ; # P
  %904 = phi i64 [%895, %$116] ; # ->
; # (drop *Safe)
  %905 = inttoptr i64 %381 to i64*
  %906 = getelementptr i64, i64* %905, i32 1
  %907 = load i64, i64* %906
  %908 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %907, i64* %908
  br label %$7
$7:
  %909 = phi i64 [%15, %$9], [%379, %$48], [%904, %$115] ; # ->
  ret i64 %909
}

define void @undefined(i64, i64) {
$1:
; # (err Exe Fun ($ "Undefined") null)
  call void @err(i64 %1, i64 %0, i8* bitcast ([10 x i8]* @$74 to i8*), i8* null)
  unreachable
}

define i64 @evExpr(i64, i64) {
$1:
; # (stkChk Exe)
  %2 = load i8*, i8** @$StkLimit
  %3 = call i8* @llvm.stacksave()
  %4 = icmp ugt i8* %2, %3
  br i1 %4, label %$2, label %$3
$2:
  call void @stkErr(i64 %0)
  unreachable
$3:
; # (let (X (cdr Lst) Y (car Exe) P (set $Bind (push (val $At) $At (v...
; # (cdr Lst)
  %5 = inttoptr i64 %1 to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (car Exe)
  %8 = inttoptr i64 %0 to i64*
  %9 = load i64, i64* %8
; # (set $Bind (push (val $At) $At (val $Bind) Lst))
; # (val $At)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64) to i64*
  %11 = load i64, i64* %10
; # (val $Bind)
  %12 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %13 = load i64, i64* %12
; # (push (val $At) $At (val $Bind) Lst)
  %14 = alloca i64, i64 4, align 16
  %15 = ptrtoint i64* %14 to i64
  %16 = inttoptr i64 %15 to i64*
  store i64 %11, i64* %16
  %17 = add i64 %15, 8
  %18 = inttoptr i64 %17 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), i64* %18
  %19 = add i64 %15, 16
  %20 = inttoptr i64 %19 to i64*
  store i64 %13, i64* %20
  %21 = add i64 %15, 24
  %22 = inttoptr i64 %21 to i64*
  store i64 %1, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %15, i64* %23
; # (while (pair Y) (set $Bind (setq P (push (eval (++ X)) (++ Y) P))...
  br label %$4
$4:
  %24 = phi i64 [%7, %$3], [%35, %$7] ; # X
  %25 = phi i64 [%9, %$3], [%47, %$7] ; # Y
  %26 = phi i64 [%15, %$3], [%49, %$7] ; # P
; # (pair Y)
  %27 = and i64 %25, 15
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %$5, label %$6
$5:
  %29 = phi i64 [%24, %$4] ; # X
  %30 = phi i64 [%25, %$4] ; # Y
  %31 = phi i64 [%26, %$4] ; # P
; # (set $Bind (setq P (push (eval (++ X)) (++ Y) P)))
; # (++ X)
  %32 = inttoptr i64 %29 to i64*
  %33 = load i64, i64* %32
  %34 = getelementptr i64, i64* %32, i32 1
  %35 = load i64, i64* %34
; # (eval (++ X))
  %36 = and i64 %33, 6
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$9, label %$8
$9:
  br label %$7
$8:
  %38 = and i64 %33, 8
  %39 = icmp ne i64 %38, 0
  br i1 %39, label %$11, label %$10
$11:
  %40 = inttoptr i64 %33 to i64*
  %41 = load i64, i64* %40
  br label %$7
$10:
  %42 = call i64 @evList(i64 %33)
  br label %$7
$7:
  %43 = phi i64 [%33, %$9], [%41, %$11], [%42, %$10] ; # ->
; # (++ Y)
  %44 = inttoptr i64 %30 to i64*
  %45 = load i64, i64* %44
  %46 = getelementptr i64, i64* %44, i32 1
  %47 = load i64, i64* %46
; # (push (eval (++ X)) (++ Y) P)
  %48 = alloca i64, i64 3, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = inttoptr i64 %49 to i64*
  store i64 %43, i64* %50
  %51 = add i64 %49, 8
  %52 = inttoptr i64 %51 to i64*
  store i64 %45, i64* %52
  %53 = add i64 %49, 16
  %54 = inttoptr i64 %53 to i64*
  store i64 %31, i64* %54
  %55 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %49, i64* %55
  br label %$4
$6:
  %56 = phi i64 [%24, %$4] ; # X
  %57 = phi i64 [%25, %$4] ; # Y
  %58 = phi i64 [%26, %$4] ; # P
; # (prog1 (if (== Y $At) (let (Link (val $Link) Next (val $Next)) (i...
; # (if (== Y $At) (let (Link (val $Link) Next (val $Next)) (if (atom...
; # (== Y $At)
  %59 = icmp eq i64 %57, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %59, label %$12, label %$13
$12:
  %60 = phi i64 [%56, %$6] ; # X
  %61 = phi i64 [%57, %$6] ; # Y
  %62 = phi i64 [%58, %$6] ; # P
; # (let (Link (val $Link) Next (val $Next)) (if (atom X) (set $Next ...
; # (val $Link)
  %63 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %64 = load i64, i64* %63
; # (val $Next)
  %65 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %66 = load i64, i64* %65
; # (if (atom X) (set $Next $Nil) (let (L (push NIL (eval (++ X)) NIL...
; # (atom X)
  %67 = and i64 %60, 15
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %$15, label %$16
$15:
  %69 = phi i64 [%60, %$12] ; # X
  %70 = phi i64 [%61, %$12] ; # Y
  %71 = phi i64 [%62, %$12] ; # P
; # (set $Next $Nil)
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %72
  br label %$17
$16:
  %73 = phi i64 [%60, %$12] ; # X
  %74 = phi i64 [%61, %$12] ; # Y
  %75 = phi i64 [%62, %$12] ; # P
; # (let (L (push NIL (eval (++ X)) NIL) Q L) (link (ofs L 1)) (while...
; # (++ X)
  %76 = inttoptr i64 %73 to i64*
  %77 = load i64, i64* %76
  %78 = getelementptr i64, i64* %76, i32 1
  %79 = load i64, i64* %78
; # (eval (++ X))
  %80 = and i64 %77, 6
  %81 = icmp ne i64 %80, 0
  br i1 %81, label %$20, label %$19
$20:
  br label %$18
$19:
  %82 = and i64 %77, 8
  %83 = icmp ne i64 %82, 0
  br i1 %83, label %$22, label %$21
$22:
  %84 = inttoptr i64 %77 to i64*
  %85 = load i64, i64* %84
  br label %$18
$21:
  %86 = call i64 @evList(i64 %77)
  br label %$18
$18:
  %87 = phi i64 [%77, %$20], [%85, %$22], [%86, %$21] ; # ->
; # (push NIL (eval (++ X)) NIL)
  %88 = alloca i64, i64 3, align 16
  %89 = ptrtoint i64* %88 to i64
  %90 = add i64 %89, 8
  %91 = inttoptr i64 %90 to i64*
  store i64 %87, i64* %91
; # (ofs L 1)
  %92 = add i64 %89, 8
; # (link (ofs L 1))
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %94 = load i64, i64* %93
  %95 = inttoptr i64 %92 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %94, i64* %96
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %92, i64* %97
; # (while (pair X) (setq L (set L (push NIL (eval (++ X)) NIL))) (li...
  br label %$23
$23:
  %98 = phi i64 [%79, %$18], [%111, %$26] ; # X
  %99 = phi i64 [%74, %$18], [%105, %$26] ; # Y
  %100 = phi i64 [%75, %$18], [%106, %$26] ; # P
  %101 = phi i64 [%89, %$18], [%121, %$26] ; # L
; # (pair X)
  %102 = and i64 %98, 15
  %103 = icmp eq i64 %102, 0
  br i1 %103, label %$24, label %$25
$24:
  %104 = phi i64 [%98, %$23] ; # X
  %105 = phi i64 [%99, %$23] ; # Y
  %106 = phi i64 [%100, %$23] ; # P
  %107 = phi i64 [%101, %$23] ; # L
; # (set L (push NIL (eval (++ X)) NIL))
; # (++ X)
  %108 = inttoptr i64 %104 to i64*
  %109 = load i64, i64* %108
  %110 = getelementptr i64, i64* %108, i32 1
  %111 = load i64, i64* %110
; # (eval (++ X))
  %112 = and i64 %109, 6
  %113 = icmp ne i64 %112, 0
  br i1 %113, label %$28, label %$27
$28:
  br label %$26
$27:
  %114 = and i64 %109, 8
  %115 = icmp ne i64 %114, 0
  br i1 %115, label %$30, label %$29
$30:
  %116 = inttoptr i64 %109 to i64*
  %117 = load i64, i64* %116
  br label %$26
$29:
  %118 = call i64 @evList(i64 %109)
  br label %$26
$26:
  %119 = phi i64 [%109, %$28], [%117, %$30], [%118, %$29] ; # ->
; # (push NIL (eval (++ X)) NIL)
  %120 = alloca i64, i64 3, align 16
  %121 = ptrtoint i64* %120 to i64
  %122 = add i64 %121, 8
  %123 = inttoptr i64 %122 to i64*
  store i64 %119, i64* %123
  %124 = inttoptr i64 %107 to i64*
  store i64 %121, i64* %124
; # (ofs L 1)
  %125 = add i64 %121, 8
; # (link (ofs L 1))
  %126 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %127 = load i64, i64* %126
  %128 = inttoptr i64 %125 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  store i64 %127, i64* %129
  %130 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %125, i64* %130
  br label %$23
$25:
  %131 = phi i64 [%98, %$23] ; # X
  %132 = phi i64 [%99, %$23] ; # Y
  %133 = phi i64 [%100, %$23] ; # P
  %134 = phi i64 [%101, %$23] ; # L
; # (set L $Nil $Next Q)
  %135 = inttoptr i64 %134 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %135
  %136 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 %89, i64* %136
  br label %$17
$17:
  %137 = phi i64 [%69, %$15], [%131, %$25] ; # X
  %138 = phi i64 [%70, %$15], [%132, %$25] ; # Y
  %139 = phi i64 [%71, %$15], [%133, %$25] ; # P
  %140 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$15], [%89, %$25] ; # ->
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$31
$31:
  %141 = phi i64 [%137, %$17], [%152, %$32] ; # X
  %142 = phi i64 [%138, %$17], [%153, %$32] ; # Y
  %143 = phi i64 [%139, %$17], [%157, %$32] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %144 = inttoptr i64 %143 to i64*
  %145 = getelementptr i64, i64* %144, i32 1
  %146 = load i64, i64* %145
; # (xchg Sym P)
  %147 = inttoptr i64 %146 to i64*
  %148 = load i64, i64* %147
  %149 = inttoptr i64 %143 to i64*
  %150 = load i64, i64* %149
  store i64 %150, i64* %147
  store i64 %148, i64* %149
; # (? (== $At Sym))
; # (== $At Sym)
  %151 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %146
  br i1 %151, label %$33, label %$32
$32:
  %152 = phi i64 [%141, %$31] ; # X
  %153 = phi i64 [%142, %$31] ; # Y
  %154 = phi i64 [%143, %$31] ; # P
; # (val 3 P)
  %155 = inttoptr i64 %154 to i64*
  %156 = getelementptr i64, i64* %155, i32 2
  %157 = load i64, i64* %156
  br label %$31
$33:
  %158 = phi i64 [%141, %$31] ; # X
  %159 = phi i64 [%142, %$31] ; # Y
  %160 = phi i64 [%143, %$31] ; # P
  %161 = phi i64 [0, %$31] ; # ->
; # (prog1 (run (cdr Exe)) (set $Next Next $Link Link))
; # (cdr Exe)
  %162 = inttoptr i64 %0 to i64*
  %163 = getelementptr i64, i64* %162, i32 1
  %164 = load i64, i64* %163
; # (run (cdr Exe))
  br label %$34
$34:
  %165 = phi i64 [%164, %$33], [%187, %$43] ; # Prg
  %166 = inttoptr i64 %165 to i64*
  %167 = load i64, i64* %166
  %168 = getelementptr i64, i64* %166, i32 1
  %169 = load i64, i64* %168
  %170 = and i64 %169, 15
  %171 = icmp ne i64 %170, 0
  br i1 %171, label %$37, label %$35
$37:
  %172 = phi i64 [%169, %$34] ; # Prg
  %173 = and i64 %167, 6
  %174 = icmp ne i64 %173, 0
  br i1 %174, label %$40, label %$39
$40:
  br label %$38
$39:
  %175 = and i64 %167, 8
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$42, label %$41
$42:
  %177 = inttoptr i64 %167 to i64*
  %178 = load i64, i64* %177
  br label %$38
$41:
  %179 = call i64 @evList(i64 %167)
  br label %$38
$38:
  %180 = phi i64 [%167, %$40], [%178, %$42], [%179, %$41] ; # ->
  br label %$36
$35:
  %181 = phi i64 [%169, %$34] ; # Prg
  %182 = and i64 %167, 15
  %183 = icmp eq i64 %182, 0
  br i1 %183, label %$44, label %$43
$44:
  %184 = phi i64 [%181, %$35] ; # Prg
  %185 = call i64 @evList(i64 %167)
  %186 = icmp ne i64 %185, 0
  br label %$43
$43:
  %187 = phi i64 [%181, %$35], [%184, %$44] ; # Prg
  %188 = phi i1 [0, %$35], [%186, %$44] ; # ->
  br label %$34
$36:
  %189 = phi i64 [%172, %$38] ; # Prg
  %190 = phi i64 [%180, %$38] ; # ->
; # (set $Next Next $Link Link)
  %191 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 %66, i64* %191
  %192 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %64, i64* %192
  br label %$14
$13:
  %193 = phi i64 [%56, %$6] ; # X
  %194 = phi i64 [%57, %$6] ; # Y
  %195 = phi i64 [%58, %$6] ; # P
; # (unless (== Y $Nil) (set $Bind (push (val Y) Y P) Y X))
; # (== Y $Nil)
  %196 = icmp eq i64 %194, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %196, label %$46, label %$45
$45:
  %197 = phi i64 [%193, %$13] ; # X
  %198 = phi i64 [%194, %$13] ; # Y
  %199 = phi i64 [%195, %$13] ; # P
; # (set $Bind (push (val Y) Y P) Y X)
; # (val Y)
  %200 = inttoptr i64 %198 to i64*
  %201 = load i64, i64* %200
; # (push (val Y) Y P)
  %202 = alloca i64, i64 3, align 16
  %203 = ptrtoint i64* %202 to i64
  %204 = inttoptr i64 %203 to i64*
  store i64 %201, i64* %204
  %205 = add i64 %203, 8
  %206 = inttoptr i64 %205 to i64*
  store i64 %198, i64* %206
  %207 = add i64 %203, 16
  %208 = inttoptr i64 %207 to i64*
  store i64 %199, i64* %208
  %209 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %203, i64* %209
  %210 = inttoptr i64 %198 to i64*
  store i64 %197, i64* %210
  br label %$46
$46:
  %211 = phi i64 [%193, %$13], [%197, %$45] ; # X
  %212 = phi i64 [%194, %$13], [%198, %$45] ; # Y
  %213 = phi i64 [%195, %$13], [%199, %$45] ; # P
; # (loop (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (v...
  br label %$47
$47:
  %214 = phi i64 [%211, %$46], [%225, %$48] ; # X
  %215 = phi i64 [%212, %$46], [%226, %$48] ; # Y
  %216 = phi i64 [%213, %$46], [%230, %$48] ; # P
; # (let Sym (val 2 P) (xchg Sym P) (? (== $At Sym)) (setq P (val 3 P...
; # (val 2 P)
  %217 = inttoptr i64 %216 to i64*
  %218 = getelementptr i64, i64* %217, i32 1
  %219 = load i64, i64* %218
; # (xchg Sym P)
  %220 = inttoptr i64 %219 to i64*
  %221 = load i64, i64* %220
  %222 = inttoptr i64 %216 to i64*
  %223 = load i64, i64* %222
  store i64 %223, i64* %220
  store i64 %221, i64* %222
; # (? (== $At Sym))
; # (== $At Sym)
  %224 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %219
  br i1 %224, label %$49, label %$48
$48:
  %225 = phi i64 [%214, %$47] ; # X
  %226 = phi i64 [%215, %$47] ; # Y
  %227 = phi i64 [%216, %$47] ; # P
; # (val 3 P)
  %228 = inttoptr i64 %227 to i64*
  %229 = getelementptr i64, i64* %228, i32 2
  %230 = load i64, i64* %229
  br label %$47
$49:
  %231 = phi i64 [%214, %$47] ; # X
  %232 = phi i64 [%215, %$47] ; # Y
  %233 = phi i64 [%216, %$47] ; # P
  %234 = phi i64 [0, %$47] ; # ->
; # (cdr Exe)
  %235 = inttoptr i64 %0 to i64*
  %236 = getelementptr i64, i64* %235, i32 1
  %237 = load i64, i64* %236
; # (run (cdr Exe))
  br label %$50
$50:
  %238 = phi i64 [%237, %$49], [%260, %$59] ; # Prg
  %239 = inttoptr i64 %238 to i64*
  %240 = load i64, i64* %239
  %241 = getelementptr i64, i64* %239, i32 1
  %242 = load i64, i64* %241
  %243 = and i64 %242, 15
  %244 = icmp ne i64 %243, 0
  br i1 %244, label %$53, label %$51
$53:
  %245 = phi i64 [%242, %$50] ; # Prg
  %246 = and i64 %240, 6
  %247 = icmp ne i64 %246, 0
  br i1 %247, label %$56, label %$55
$56:
  br label %$54
$55:
  %248 = and i64 %240, 8
  %249 = icmp ne i64 %248, 0
  br i1 %249, label %$58, label %$57
$58:
  %250 = inttoptr i64 %240 to i64*
  %251 = load i64, i64* %250
  br label %$54
$57:
  %252 = call i64 @evList(i64 %240)
  br label %$54
$54:
  %253 = phi i64 [%240, %$56], [%251, %$58], [%252, %$57] ; # ->
  br label %$52
$51:
  %254 = phi i64 [%242, %$50] ; # Prg
  %255 = and i64 %240, 15
  %256 = icmp eq i64 %255, 0
  br i1 %256, label %$60, label %$59
$60:
  %257 = phi i64 [%254, %$51] ; # Prg
  %258 = call i64 @evList(i64 %240)
  %259 = icmp ne i64 %258, 0
  br label %$59
$59:
  %260 = phi i64 [%254, %$51], [%257, %$60] ; # Prg
  %261 = phi i1 [0, %$51], [%259, %$60] ; # ->
  br label %$50
$52:
  %262 = phi i64 [%245, %$54] ; # Prg
  %263 = phi i64 [%253, %$54] ; # ->
  br label %$14
$14:
  %264 = phi i64 [%158, %$36], [%231, %$52] ; # X
  %265 = phi i64 [%159, %$36], [%232, %$52] ; # Y
  %266 = phi i64 [%160, %$36], [%233, %$52] ; # P
  %267 = phi i64 [%190, %$36], [%263, %$52] ; # ->
; # (val $Bind)
  %268 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %269 = load i64, i64* %268
; # (loop (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq...
  br label %$61
$61:
  %270 = phi i64 [%264, %$14], [%280, %$62] ; # X
  %271 = phi i64 [%265, %$14], [%281, %$62] ; # Y
  %272 = phi i64 [%269, %$14], [%285, %$62] ; # P
; # (let Sym (val 2 P) (set Sym (val P)) (? (== $At Sym)) (setq P (va...
; # (val 2 P)
  %273 = inttoptr i64 %272 to i64*
  %274 = getelementptr i64, i64* %273, i32 1
  %275 = load i64, i64* %274
; # (set Sym (val P))
; # (val P)
  %276 = inttoptr i64 %272 to i64*
  %277 = load i64, i64* %276
  %278 = inttoptr i64 %275 to i64*
  store i64 %277, i64* %278
; # (? (== $At Sym))
; # (== $At Sym)
  %279 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %275
  br i1 %279, label %$63, label %$62
$62:
  %280 = phi i64 [%270, %$61] ; # X
  %281 = phi i64 [%271, %$61] ; # Y
  %282 = phi i64 [%272, %$61] ; # P
; # (val 3 P)
  %283 = inttoptr i64 %282 to i64*
  %284 = getelementptr i64, i64* %283, i32 2
  %285 = load i64, i64* %284
  br label %$61
$63:
  %286 = phi i64 [%270, %$61] ; # X
  %287 = phi i64 [%271, %$61] ; # Y
  %288 = phi i64 [%272, %$61] ; # P
  %289 = phi i64 [0, %$61] ; # ->
; # (set $Bind (val 3 P))
; # (val 3 P)
  %290 = inttoptr i64 %288 to i64*
  %291 = getelementptr i64, i64* %290, i32 2
  %292 = load i64, i64* %291
  %293 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  store i64 %292, i64* %293
  ret i64 %267
}

define i64 @evList(i64) {
$1:
; # (let Fun (car Exe) (cond ((num? Fun) Exe) ((sym? Fun) (loop (sigC...
; # (car Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = load i64, i64* %1
; # (cond ((num? Fun) Exe) ((sym? Fun) (loop (sigChk Exe) (let V (val...
; # (num? Fun)
  %3 = and i64 %2, 6
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$4, label %$3
$4:
  %5 = phi i64 [%2, %$1] ; # Fun
  br label %$2
$3:
  %6 = phi i64 [%2, %$1] ; # Fun
; # (sym? Fun)
  %7 = and i64 %6, 8
  %8 = icmp ne i64 %7, 0
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i64 [%6, %$3] ; # Fun
; # (loop (sigChk Exe) (let V (val Fun) (? (num? V) (subr V Exe)) (? ...
  br label %$7
$7:
  %10 = phi i64 [%9, %$6], [%14, %$15] ; # Fun
; # (sigChk Exe)
  %11 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %$8, label %$9
$8:
  call void @sighandler(i64 %0)
  br label %$9
$9:
; # (let V (val Fun) (? (num? V) (subr V Exe)) (? (pair V) (evExpr V ...
; # (val Fun)
  %13 = inttoptr i64 %10 to i64*
  %14 = load i64, i64* %13
; # (? (num? V) (subr V Exe))
; # (num? V)
  %15 = and i64 %14, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$12, label %$10
$12:
  %17 = phi i64 [%10, %$9] ; # Fun
; # (subr V Exe)
  %18 = and i64 %14, -3
  %19 = inttoptr i64 %18 to i64(i64)*
  %20 = call i64 %19(i64 %0)
  br label %$11
$10:
  %21 = phi i64 [%10, %$9] ; # Fun
; # (? (pair V) (evExpr V Exe))
; # (pair V)
  %22 = and i64 %14, 15
  %23 = icmp eq i64 %22, 0
  br i1 %23, label %$14, label %$13
$14:
  %24 = phi i64 [%21, %$10] ; # Fun
; # (evExpr V Exe)
  %25 = call i64 @evExpr(i64 %14, i64 %0)
  br label %$11
$13:
  %26 = phi i64 [%21, %$10] ; # Fun
; # (? (== V (val V)) (if (sharedLib Fun) (subr (val Fun) Exe) (undef...
; # (val V)
  %27 = inttoptr i64 %14 to i64*
  %28 = load i64, i64* %27
; # (== V (val V))
  %29 = icmp eq i64 %14, %28
  br i1 %29, label %$16, label %$15
$16:
  %30 = phi i64 [%26, %$13] ; # Fun
; # (if (sharedLib Fun) (subr (val Fun) Exe) (undefined Fun Exe))
; # (sharedLib Fun)
  %31 = call i1 @sharedLib(i64 %30)
  br i1 %31, label %$17, label %$18
$17:
  %32 = phi i64 [%30, %$16] ; # Fun
; # (val Fun)
  %33 = inttoptr i64 %32 to i64*
  %34 = load i64, i64* %33
; # (subr (val Fun) Exe)
  %35 = and i64 %34, -3
  %36 = inttoptr i64 %35 to i64(i64)*
  %37 = call i64 %36(i64 %0)
  br label %$19
$18:
  %38 = phi i64 [%30, %$16] ; # Fun
; # (undefined Fun Exe)
  call void @undefined(i64 %38, i64 %0)
  unreachable
$19:
  %39 = phi i64 [%32, %$17] ; # Fun
  %40 = phi i64 [%37, %$17] ; # ->
  br label %$11
$15:
  %41 = phi i64 [%26, %$13] ; # Fun
  br label %$7
$11:
  %42 = phi i64 [%17, %$12], [%24, %$14], [%39, %$19] ; # Fun
  %43 = phi i64 [%20, %$12], [%25, %$14], [%40, %$19] ; # ->
  br label %$2
$5:
  %44 = phi i64 [%6, %$3] ; # Fun
; # (stkChk Exe)
  %45 = load i8*, i8** @$StkLimit
  %46 = call i8* @llvm.stacksave()
  %47 = icmp ugt i8* %45, %46
  br i1 %47, label %$20, label %$21
$20:
  call void @stkErr(i64 %0)
  unreachable
$21:
; # (let F (save (evList Fun)) (loop (sigChk Exe) (? (num? F) (subr F...
; # (evList Fun)
  %48 = call i64 @evList(i64 %44)
; # (save (evList Fun))
  %49 = alloca i64, i64 2, align 16
  %50 = ptrtoint i64* %49 to i64
  %51 = inttoptr i64 %50 to i64*
  store i64 %48, i64* %51
  %52 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %53 = load i64, i64* %52
  %54 = inttoptr i64 %50 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %53, i64* %55
  %56 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %50, i64* %56
; # (loop (sigChk Exe) (? (num? F) (subr F Exe)) (? (pair F) (evExpr ...
  br label %$22
$22:
  %57 = phi i64 [%44, %$21], [%97, %$30] ; # Fun
  %58 = phi i64 [%48, %$21], [%78, %$30] ; # F
; # (sigChk Exe)
  %59 = load i32, i32* bitcast ([15 x i32]* @$Signal to i32*)
  %60 = icmp ne i32 %59, 0
  br i1 %60, label %$23, label %$24
$23:
  call void @sighandler(i64 %0)
  br label %$24
$24:
; # (? (num? F) (subr F Exe))
; # (num? F)
  %61 = and i64 %58, 6
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$27, label %$25
$27:
  %63 = phi i64 [%57, %$24] ; # Fun
  %64 = phi i64 [%58, %$24] ; # F
; # (subr F Exe)
  %65 = and i64 %64, -3
  %66 = inttoptr i64 %65 to i64(i64)*
  %67 = call i64 %66(i64 %0)
  br label %$26
$25:
  %68 = phi i64 [%57, %$24] ; # Fun
  %69 = phi i64 [%58, %$24] ; # F
; # (? (pair F) (evExpr F Exe))
; # (pair F)
  %70 = and i64 %69, 15
  %71 = icmp eq i64 %70, 0
  br i1 %71, label %$29, label %$28
$29:
  %72 = phi i64 [%68, %$25] ; # Fun
  %73 = phi i64 [%69, %$25] ; # F
; # (evExpr F Exe)
  %74 = call i64 @evExpr(i64 %73, i64 %0)
  br label %$26
$28:
  %75 = phi i64 [%68, %$25] ; # Fun
  %76 = phi i64 [%69, %$25] ; # F
; # (let V (val F) (? (== V (val V)) (if (sharedLib F) (subr (val F) ...
; # (val F)
  %77 = inttoptr i64 %76 to i64*
  %78 = load i64, i64* %77
; # (? (== V (val V)) (if (sharedLib F) (subr (val F) Exe) (undefined...
; # (val V)
  %79 = inttoptr i64 %78 to i64*
  %80 = load i64, i64* %79
; # (== V (val V))
  %81 = icmp eq i64 %78, %80
  br i1 %81, label %$31, label %$30
$31:
  %82 = phi i64 [%75, %$28] ; # Fun
  %83 = phi i64 [%76, %$28] ; # F
; # (if (sharedLib F) (subr (val F) Exe) (undefined F Exe))
; # (sharedLib F)
  %84 = call i1 @sharedLib(i64 %83)
  br i1 %84, label %$32, label %$33
$32:
  %85 = phi i64 [%82, %$31] ; # Fun
  %86 = phi i64 [%83, %$31] ; # F
; # (val F)
  %87 = inttoptr i64 %86 to i64*
  %88 = load i64, i64* %87
; # (subr (val F) Exe)
  %89 = and i64 %88, -3
  %90 = inttoptr i64 %89 to i64(i64)*
  %91 = call i64 %90(i64 %0)
  br label %$34
$33:
  %92 = phi i64 [%82, %$31] ; # Fun
  %93 = phi i64 [%83, %$31] ; # F
; # (undefined F Exe)
  call void @undefined(i64 %93, i64 %0)
  unreachable
$34:
  %94 = phi i64 [%85, %$32] ; # Fun
  %95 = phi i64 [%86, %$32] ; # F
  %96 = phi i64 [%91, %$32] ; # ->
  br label %$26
$30:
  %97 = phi i64 [%75, %$28] ; # Fun
  %98 = phi i64 [%76, %$28] ; # F
  br label %$22
$26:
  %99 = phi i64 [%63, %$27], [%72, %$29], [%94, %$34] ; # Fun
  %100 = phi i64 [%64, %$27], [%73, %$29], [%95, %$34] ; # F
  %101 = phi i64 [%67, %$27], [%74, %$29], [%96, %$34] ; # ->
; # (drop *Safe)
  %102 = inttoptr i64 %50 to i64*
  %103 = getelementptr i64, i64* %102, i32 1
  %104 = load i64, i64* %103
  %105 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %104, i64* %105
  br label %$2
$2:
  %106 = phi i64 [%5, %$4], [%42, %$11], [%99, %$26] ; # Fun
  %107 = phi i64 [%0, %$4], [%43, %$11], [%101, %$26] ; # ->
  ret i64 %107
}

define i64 @_quit(i64) {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) Msg (bufString Nm (b8 ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (bufSize Nm)
  %6 = call i64 @bufSize(i64 %5)
; # (b8 (bufSize Nm))
  %7 = alloca i8, i64 %6
; # (bufString Nm (b8 (bufSize Nm)))
  %8 = call i8* @bufString(i64 %5, i8* %7)
; # (if (atom (shift X)) 0 (eval (car X)))
; # (shift X)
  %9 = inttoptr i64 %3 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (atom (shift X))
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%11, %$1] ; # X
  br label %$4
$3:
  %15 = phi i64 [%11, %$1] ; # X
; # (car X)
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (eval (car X))
  %18 = and i64 %17, 6
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$7, label %$6
$7:
  br label %$5
$6:
  %20 = and i64 %17, 8
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$9, label %$8
$9:
  %22 = inttoptr i64 %17 to i64*
  %23 = load i64, i64* %22
  br label %$5
$8:
  %24 = call i64 @evList(i64 %17)
  br label %$5
$5:
  %25 = phi i64 [%17, %$7], [%23, %$9], [%24, %$8] ; # ->
  br label %$4
$4:
  %26 = phi i64 [%14, %$2], [%15, %$5] ; # X
  %27 = phi i64 [0, %$2], [%25, %$5] ; # ->
; # (err 0 (if (atom (shift X)) 0 (eval (car X))) ($ "%s") Msg)
  call void @err(i64 0, i64 %27, i8* bitcast ([3 x i8]* @$75 to i8*), i8* %8)
  unreachable
}

define i64 @_sys(i64) {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (evSym X)) S (bufString Nm (b8 (b...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym X))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (bufSize Nm)
  %6 = call i64 @bufSize(i64 %5)
; # (b8 (bufSize Nm))
  %7 = alloca i8, i64 %6
; # (bufString Nm (b8 (bufSize Nm)))
  %8 = call i8* @bufString(i64 %5, i8* %7)
; # (if (atom (shift X)) (mkStr (getenv S)) (let (Y (evSym X) Nm2 (xN...
; # (shift X)
  %9 = inttoptr i64 %3 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  %11 = load i64, i64* %10
; # (atom (shift X))
  %12 = and i64 %11, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%11, %$1] ; # X
; # (getenv S)
  %15 = call i8* @getenv(i8* %8)
; # (mkStr (getenv S))
  %16 = call i64 @mkStr(i8* %15)
  br label %$4
$3:
  %17 = phi i64 [%11, %$1] ; # X
; # (let (Y (evSym X) Nm2 (xName Exe Y)) (if (setenv S (bufString Nm2...
; # (evSym X)
  %18 = call i64 @evSym(i64 %17)
; # (xName Exe Y)
  %19 = call i64 @xName(i64 %0, i64 %18)
; # (if (setenv S (bufString Nm2 (b8 (bufSize Nm2))) 1) $Nil Y)
; # (bufSize Nm2)
  %20 = call i64 @bufSize(i64 %19)
; # (b8 (bufSize Nm2))
  %21 = alloca i8, i64 %20
; # (bufString Nm2 (b8 (bufSize Nm2)))
  %22 = call i8* @bufString(i64 %19, i8* %21)
; # (setenv S (bufString Nm2 (b8 (bufSize Nm2))) 1)
  %23 = call i32 @setenv(i8* %8, i8* %22, i32 1)
  %24 = icmp ne i32 %23, 0
  br i1 %24, label %$5, label %$6
$5:
  %25 = phi i64 [%17, %$3] ; # X
  br label %$7
$6:
  %26 = phi i64 [%17, %$3] ; # X
  br label %$7
$7:
  %27 = phi i64 [%25, %$5], [%26, %$6] ; # X
  %28 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%18, %$6] ; # ->
  br label %$4
$4:
  %29 = phi i64 [%14, %$2], [%27, %$7] ; # X
  %30 = phi i64 [%16, %$2], [%28, %$7] ; # ->
  ret i64 %30
}

define i64 @_pwd(i64) {
$1:
; # (let P (getcwd null 0) (if P (prog1 (mkStr P) (free P)) $Nil))
; # (getcwd null 0)
  %1 = call i8* @getcwd(i8* null, i64 0)
; # (if P (prog1 (mkStr P) (free P)) $Nil)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$2, label %$3
$2:
; # (prog1 (mkStr P) (free P))
; # (mkStr P)
  %3 = call i64 @mkStr(i8* %1)
; # (free P)
  call void @free(i8* %1)
  br label %$4
$3:
  br label %$4
$4:
  %4 = phi i64 [%3, %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %4
}

define i64 @_cd(i64) {
$1:
; # (let (Nm (xName Exe (evSym (cdr Exe))) P (getcwd null 0)) (if P (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (xName Exe (evSym (cdr Exe)))
  %5 = call i64 @xName(i64 %0, i64 %4)
; # (getcwd null 0)
  %6 = call i8* @getcwd(i8* null, i64 0)
; # (if P (prog1 (if (lt0 (chdir (pathString Nm (b8 (pathSize Nm)))))...
  %7 = icmp ne i8* %6, null
  br i1 %7, label %$2, label %$3
$2:
; # (prog1 (if (lt0 (chdir (pathString Nm (b8 (pathSize Nm))))) $Nil ...
; # (if (lt0 (chdir (pathString Nm (b8 (pathSize Nm))))) $Nil (mkStr ...
; # (pathSize Nm)
  %8 = call i64 @pathSize(i64 %5)
; # (b8 (pathSize Nm))
  %9 = alloca i8, i64 %8
; # (pathString Nm (b8 (pathSize Nm)))
  %10 = call i8* @pathString(i64 %5, i8* %9)
; # (chdir (pathString Nm (b8 (pathSize Nm))))
  %11 = call i32 @chdir(i8* %10)
; # (lt0 (chdir (pathString Nm (b8 (pathSize Nm)))))
  %12 = icmp slt i32 %11, 0
  br i1 %12, label %$5, label %$6
$5:
  br label %$7
$6:
; # (mkStr P)
  %13 = call i64 @mkStr(i8* %6)
  br label %$7
$7:
  %14 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$5], [%13, %$6] ; # ->
; # (free P)
  call void @free(i8* %6)
  br label %$4
$3:
  br label %$4
$4:
  %15 = phi i64 [%14, %$7], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %15
}

define i64 @_ctty(i64) {
$1:
; # (let X (eval (cadr Exe)) (cond ((cnt? X) (set $TtyPid (i32 (int @...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (cond ((cnt? X) (set $TtyPid (i32 (int @))) $T) ((not (sym? X)) (...
; # (cnt? X)
  %14 = and i64 %13, 2
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
; # (set $TtyPid (i32 (int @)))
; # (int @)
  %16 = lshr i64 %13, 4
; # (i32 (int @))
  %17 = trunc i64 %16 to i32
  store i32 %17, i32* @$TtyPid
  br label %$7
$8:
; # (sym? X)
  %18 = and i64 %13, 8
  %19 = icmp ne i64 %18, 0
; # (not (sym? X))
  %20 = icmp eq i1 %19, 0
  br i1 %20, label %$11, label %$10
$11:
; # (argErr Exe X)
  call void @argErr(i64 %0, i64 %13)
  unreachable
$10:
; # (nil? X)
  %21 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %21, label %$13, label %$12
$13:
  br label %$7
$12:
; # (let (Nm (xName Exe X) In: (inFile (val (val $InFiles))) Out: (ou...
; # (xName Exe X)
  %22 = call i64 @xName(i64 %0, i64 %13)
; # (val $InFiles)
  %23 = load i8**, i8*** @$InFiles
; # (val (val $InFiles))
  %24 = load i8*, i8** %23
; # (val $OutFiles)
  %25 = load i8**, i8*** @$OutFiles
; # (val 2 (val $OutFiles))
  %26 = getelementptr i8*, i8** %25, i32 1
  %27 = load i8*, i8** %26
; # (ifn (reopenTty (bufString Nm (b8 (bufSize Nm)))) $Nil (In: ix (I...
; # (bufSize Nm)
  %28 = call i64 @bufSize(i64 %22)
; # (b8 (bufSize Nm))
  %29 = alloca i8, i64 %28
; # (bufString Nm (b8 (bufSize Nm)))
  %30 = call i8* @bufString(i64 %22, i8* %29)
; # (reopenTty (bufString Nm (b8 (bufSize Nm))))
  %31 = call i1 @reopenTty(i8* %30)
  br i1 %31, label %$15, label %$14
$14:
  br label %$16
$15:
; # (In: ix (In: cnt 0))
  %32 = bitcast i8* %24 to i64*
  %33 = getelementptr i8, i8* %24, i32 8
  %34 = bitcast i8* %33 to i64*
  store i64 0, i64* %34
  store i64 0, i64* %32
; # (In: next 0)
  %35 = getelementptr i8, i8* %24, i32 20
  %36 = bitcast i8* %35 to i32*
  store i32 0, i32* %36
; # (set Tio (=0 (tcgetattr 0 OrgTermio)))
; # (tcgetattr 0 OrgTermio)
  %37 = call i32 @tcgetattr(i32 0, i8* @OrgTermio)
; # (=0 (tcgetattr 0 OrgTermio))
  %38 = icmp eq i32 %37, 0
  store i1 %38, i1* @Tio
; # (Out: ix 0)
  %39 = bitcast i8* %27 to i64*
  store i64 0, i64* %39
; # (Out: tty YES)
  %40 = getelementptr i8, i8* %27, i32 4108
  %41 = bitcast i8* %40 to i1*
  store i1 1, i1* %41
; # (val $OutFiles)
  %42 = load i8**, i8*** @$OutFiles
; # (val 3 (val $OutFiles))
  %43 = getelementptr i8*, i8** %42, i32 2
  %44 = load i8*, i8** %43
; # ((outFile (val 3 (val $OutFiles))) tty YES)
  %45 = getelementptr i8, i8* %44, i32 4108
  %46 = bitcast i8* %45 to i1*
  store i1 1, i1* %46
  br label %$16
$16:
  %47 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$14], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$15] ; # ->
  br label %$7
$7:
  %48 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$9], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$13], [%47, %$16] ; # ->
  ret i64 %48
}

define i64 @_cmd(i64) {
$1:
; # (if (nil? (evSym (cdr Exe))) (mkStr (val $AV0)) (bufString (xName...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym (cdr Exe))
  %4 = call i64 @evSym(i64 %3)
; # (nil? (evSym (cdr Exe)))
  %5 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$2, label %$3
$2:
; # (val $AV0)
  %6 = load i8*, i8** @$AV0
; # (mkStr (val $AV0))
  %7 = call i64 @mkStr(i8* %6)
  br label %$4
$3:
; # (xName Exe @)
  %8 = call i64 @xName(i64 %0, i64 %4)
; # (val $AV0)
  %9 = load i8*, i8** @$AV0
; # (bufString (xName Exe @) (val $AV0))
  %10 = call i8* @bufString(i64 %8, i8* %9)
  br label %$4
$4:
  %11 = phi i64 [%7, %$2], [%4, %$3] ; # ->
  ret i64 %11
}

define i64 @_dir(i64) {
$1:
; # (let X (cdr Exe) (if (getDir (if (nil? (evSym X)) ($ ".") (let Nm...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (getDir (if (nil? (evSym X)) ($ ".") (let Nm (xName Exe @) (p...
; # (if (nil? (evSym X)) ($ ".") (let Nm (xName Exe @) (pathString Nm...
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (nil? (evSym X))
  %5 = icmp eq i64 %4, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %5, label %$2, label %$3
$2:
  %6 = phi i64 [%3, %$1] ; # X
  br label %$4
$3:
  %7 = phi i64 [%3, %$1] ; # X
; # (let Nm (xName Exe @) (pathString Nm (b8 (pathSize Nm))))
; # (xName Exe @)
  %8 = call i64 @xName(i64 %0, i64 %4)
; # (pathSize Nm)
  %9 = call i64 @pathSize(i64 %8)
; # (b8 (pathSize Nm))
  %10 = alloca i8, i64 %9
; # (pathString Nm (b8 (pathSize Nm)))
  %11 = call i8* @pathString(i64 %8, i8* %10)
  br label %$4
$4:
  %12 = phi i64 [%6, %$2], [%7, %$3] ; # X
  %13 = phi i8* [bitcast ([2 x i8]* @$76 to i8*), %$2], [%11, %$3] ; # ->
; # (getDir (if (nil? (evSym X)) ($ ".") (let Nm (xName Exe @) (pathS...
  %14 = call i8* @getDir(i8* %13)
  %15 = icmp ne i8* %14, null
  br i1 %15, label %$5, label %$6
$5:
  %16 = phi i64 [%12, %$4] ; # X
; # (let (P @ F (eval (car (shift X)))) (when (nil? F) (while (== (va...
; # (shift X)
  %17 = inttoptr i64 %16 to i64*
  %18 = getelementptr i64, i64* %17, i32 1
  %19 = load i64, i64* %18
; # (car (shift X))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
; # (eval (car (shift X)))
  %22 = and i64 %21, 6
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$10, label %$9
$10:
  br label %$8
$9:
  %24 = and i64 %21, 8
  %25 = icmp ne i64 %24, 0
  br i1 %25, label %$12, label %$11
$12:
  %26 = inttoptr i64 %21 to i64*
  %27 = load i64, i64* %26
  br label %$8
$11:
  %28 = call i64 @evList(i64 %21)
  br label %$8
$8:
  %29 = phi i64 [%21, %$10], [%27, %$12], [%28, %$11] ; # ->
; # (when (nil? F) (while (== (val P) (char ".")) (unless (setq P (ge...
; # (nil? F)
  %30 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %30, label %$13, label %$14
$13:
  %31 = phi i64 [%19, %$8] ; # X
  %32 = phi i8* [%14, %$8] ; # P
; # (while (== (val P) (char ".")) (unless (setq P (getDir null)) (re...
  br label %$15
$15:
  %33 = phi i64 [%31, %$13], [%43, %$19] ; # X
  %34 = phi i8* [%32, %$13], [%44, %$19] ; # P
; # (val P)
  %35 = load i8, i8* %34
; # (== (val P) (char "."))
  %36 = icmp eq i8 %35, 46
  br i1 %36, label %$16, label %$17
$16:
  %37 = phi i64 [%33, %$15] ; # X
  %38 = phi i8* [%34, %$15] ; # P
; # (unless (setq P (getDir null)) (ret $Nil))
; # (getDir null)
  %39 = call i8* @getDir(i8* null)
  %40 = icmp ne i8* %39, null
  br i1 %40, label %$19, label %$18
$18:
  %41 = phi i64 [%37, %$16] ; # X
  %42 = phi i8* [%39, %$16] ; # P
; # (ret $Nil)
  ret i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
$19:
  %43 = phi i64 [%37, %$16] ; # X
  %44 = phi i8* [%39, %$16] ; # P
  br label %$15
$17:
  %45 = phi i64 [%33, %$15] ; # X
  %46 = phi i8* [%34, %$15] ; # P
  br label %$14
$14:
  %47 = phi i64 [%19, %$8], [%45, %$17] ; # X
  %48 = phi i8* [%14, %$8], [%46, %$17] ; # P
; # (let (Y (cons (mkStr P) $Nil) R (save Y)) (while (setq P (getDir ...
; # (mkStr P)
  %49 = call i64 @mkStr(i8* %48)
; # (cons (mkStr P) $Nil)
  %50 = call i64 @cons(i64 %49, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %51 = alloca i64, i64 2, align 16
  %52 = ptrtoint i64* %51 to i64
  %53 = inttoptr i64 %52 to i64*
  store i64 %50, i64* %53
  %54 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %55 = load i64, i64* %54
  %56 = inttoptr i64 %52 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  store i64 %55, i64* %57
  %58 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %52, i64* %58
; # (while (setq P (getDir null)) (unless (and (nil? F) (== (val P) (...
  br label %$20
$20:
  %59 = phi i64 [%47, %$14], [%84, %$26] ; # X
  %60 = phi i8* [%48, %$14], [%85, %$26] ; # P
  %61 = phi i64 [%50, %$14], [%86, %$26] ; # Y
; # (getDir null)
  %62 = call i8* @getDir(i8* null)
  %63 = icmp ne i8* %62, null
  br i1 %63, label %$21, label %$22
$21:
  %64 = phi i64 [%59, %$20] ; # X
  %65 = phi i8* [%62, %$20] ; # P
  %66 = phi i64 [%61, %$20] ; # Y
; # (unless (and (nil? F) (== (val P) (char "."))) (setq Y (set 2 Y (...
; # (and (nil? F) (== (val P) (char ".")))
; # (nil? F)
  %67 = icmp eq i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %67, label %$24, label %$23
$24:
  %68 = phi i64 [%64, %$21] ; # X
  %69 = phi i8* [%65, %$21] ; # P
  %70 = phi i64 [%66, %$21] ; # Y
; # (val P)
  %71 = load i8, i8* %69
; # (== (val P) (char "."))
  %72 = icmp eq i8 %71, 46
  br label %$23
$23:
  %73 = phi i64 [%64, %$21], [%68, %$24] ; # X
  %74 = phi i8* [%65, %$21], [%69, %$24] ; # P
  %75 = phi i64 [%66, %$21], [%70, %$24] ; # Y
  %76 = phi i1 [0, %$21], [%72, %$24] ; # ->
  br i1 %76, label %$26, label %$25
$25:
  %77 = phi i64 [%73, %$23] ; # X
  %78 = phi i8* [%74, %$23] ; # P
  %79 = phi i64 [%75, %$23] ; # Y
; # (set 2 Y (cons (mkStr P) $Nil))
; # (mkStr P)
  %80 = call i64 @mkStr(i8* %78)
; # (cons (mkStr P) $Nil)
  %81 = call i64 @cons(i64 %80, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %82 = inttoptr i64 %79 to i64*
  %83 = getelementptr i64, i64* %82, i32 1
  store i64 %81, i64* %83
  br label %$26
$26:
  %84 = phi i64 [%73, %$23], [%77, %$25] ; # X
  %85 = phi i8* [%74, %$23], [%78, %$25] ; # P
  %86 = phi i64 [%75, %$23], [%81, %$25] ; # Y
  br label %$20
$22:
  %87 = phi i64 [%59, %$20] ; # X
  %88 = phi i8* [%62, %$20] ; # P
  %89 = phi i64 [%61, %$20] ; # Y
; # (drop *Safe)
  %90 = inttoptr i64 %52 to i64*
  %91 = getelementptr i64, i64* %90, i32 1
  %92 = load i64, i64* %91
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %92, i64* %93
  br label %$7
$6:
  %94 = phi i64 [%12, %$4] ; # X
  br label %$7
$7:
  %95 = phi i64 [%87, %$22], [%94, %$6] ; # X
  %96 = phi i64 [%50, %$22], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$6] ; # ->
  ret i64 %96
}

define i64 @_info(i64) {
$1:
; # (let (X (cdr Exe) Nm (xName Exe (set $At2 (evSym X))) Size (i64* ...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (set $At2 (evSym X))
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 408) to i64) to i64*
  store i64 %4, i64* %5
; # (xName Exe (set $At2 (evSym X)))
  %6 = call i64 @xName(i64 %0, i64 %4)
; # (push NIL)
  %7 = alloca i64, i64 1
  %8 = ptrtoint i64* %7 to i64
; # (i64* (push NIL))
  %9 = inttoptr i64 %8 to i64*
; # (if (lt0 (fileInfo (nil? (eval (car (shift X)))) (pathString Nm (...
; # (shift X)
  %10 = inttoptr i64 %3 to i64*
  %11 = getelementptr i64, i64* %10, i32 1
  %12 = load i64, i64* %11
; # (car (shift X))
  %13 = inttoptr i64 %12 to i64*
  %14 = load i64, i64* %13
; # (eval (car (shift X)))
  %15 = and i64 %14, 6
  %16 = icmp ne i64 %15, 0
  br i1 %16, label %$4, label %$3
$4:
  br label %$2
$3:
  %17 = and i64 %14, 8
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$6, label %$5
$6:
  %19 = inttoptr i64 %14 to i64*
  %20 = load i64, i64* %19
  br label %$2
$5:
  %21 = call i64 @evList(i64 %14)
  br label %$2
$2:
  %22 = phi i64 [%14, %$4], [%20, %$6], [%21, %$5] ; # ->
; # (nil? (eval (car (shift X))))
  %23 = icmp eq i64 %22, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (pathSize Nm)
  %24 = call i64 @pathSize(i64 %6)
; # (b8 (pathSize Nm))
  %25 = alloca i8, i64 %24
; # (pathString Nm (b8 (pathSize Nm)))
  %26 = call i8* @pathString(i64 %6, i8* %25)
; # (fileInfo (nil? (eval (car (shift X)))) (pathString Nm (b8 (pathS...
  %27 = call i64 @fileInfo(i1 %23, i8* %26, i64* %9)
; # (lt0 (fileInfo (nil? (eval (car (shift X)))) (pathString Nm (b8 (...
  %28 = icmp slt i64 %27, 0
  br i1 %28, label %$7, label %$8
$7:
  %29 = phi i64 [%12, %$2] ; # X
  br label %$9
$8:
  %30 = phi i64 [%12, %$2] ; # X
; # (let N @ (cons (case (& N 3) (1 $T) (2 $Nil) (T (box64 (val Size)...
; # (case (& N 3) (1 $T) (2 $Nil) (T (box64 (val Size))))
; # (& N 3)
  %31 = and i64 %27, 3
  switch i64 %31, label %$10 [
    i64 1, label %$12
    i64 2, label %$13
  ]
$12:
  %32 = phi i64 [%30, %$8] ; # X
  %33 = phi i64 [%27, %$8] ; # N
  br label %$11
$13:
  %34 = phi i64 [%30, %$8] ; # X
  %35 = phi i64 [%27, %$8] ; # N
  br label %$11
$10:
  %36 = phi i64 [%30, %$8] ; # X
  %37 = phi i64 [%27, %$8] ; # N
; # (val Size)
  %38 = load i64, i64* %9
; # (box64 (val Size))
  %39 = and i64 %38, 17293822569102704640
  %40 = icmp ne i64 %39, 0
  br i1 %40, label %$14, label %$15
$14:
  %41 = call i64 @boxNum(i64 %38)
  br label %$16
$15:
  %42 = shl i64 %38, 4
  %43 = or i64 %42, 2
  br label %$16
$16:
  %44 = phi i64 [%41, %$14], [%43, %$15] ; # ->
  br label %$11
$11:
  %45 = phi i64 [%32, %$12], [%34, %$13], [%36, %$16] ; # X
  %46 = phi i64 [%33, %$12], [%35, %$13], [%37, %$16] ; # N
  %47 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%44, %$16] ; # ->
; # (shr N 2)
  %48 = lshr i64 %46, 2
; # (& (setq N (shr N 2)) (hex "FFFF"))
  %49 = and i64 %48, 65535
; # (shr N 16)
  %50 = lshr i64 %48, 16
; # (& (setq N (shr N 16)) (hex "FF"))
  %51 = and i64 %50, 255
; # (shr N 8)
  %52 = lshr i64 %50, 8
; # (& (setq N (shr N 8)) (hex "FF"))
  %53 = and i64 %52, 255
; # (tmDate (& (setq N (shr N 2)) (hex "FFFF")) (& (setq N (shr N 16)...
  %54 = call i64 @tmDate(i64 %49, i64 %51, i64 %53)
; # (shr N 8)
  %55 = lshr i64 %52, 8
; # (cnt (shr N 8))
  %56 = shl i64 %55, 4
  %57 = or i64 %56, 2
; # (cons (tmDate (& (setq N (shr N 2)) (hex "FFFF")) (& (setq N (shr...
  %58 = call i64 @cons(i64 %54, i64 %57)
; # (cons (case (& N 3) (1 $T) (2 $Nil) (T (box64 (val Size)))) (cons...
  %59 = call i64 @cons(i64 %47, i64 %58)
  br label %$9
$9:
  %60 = phi i64 [%29, %$7], [%45, %$11] ; # X
  %61 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%59, %$11] ; # ->
  ret i64 %61
}

define i64 @_file(i64) {
$1:
; # (let In: (inFile (val $InFile)) (ifn (and (In:) (In: name)) $Nil ...
; # (val $InFile)
  %1 = load i8*, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (ifn (and (In:) (In: name)) $Nil (let (N (cnt (i64 (In: src))) S ...
; # (and (In:) (In: name))
; # (In:)
  %2 = icmp ne i8* %1, null
  br i1 %2, label %$3, label %$2
$3:
; # (In: name)
  %3 = getelementptr i8, i8* %1, i32 24
  %4 = bitcast i8* %3 to i8**
  %5 = load i8*, i8** %4
  %6 = icmp ne i8* %5, null
  br label %$2
$2:
  %7 = phi i1 [0, %$1], [%6, %$3] ; # ->
  br i1 %7, label %$5, label %$4
$4:
  br label %$6
$5:
; # (let (N (cnt (i64 (In: src))) S (In: name) P (strrchr S (char "/"...
; # (In: src)
  %8 = getelementptr i8, i8* %1, i32 36
  %9 = bitcast i8* %8 to i32*
  %10 = load i32, i32* %9
; # (i64 (In: src))
  %11 = sext i32 %10 to i64
; # (cnt (i64 (In: src)))
  %12 = shl i64 %11, 4
  %13 = or i64 %12, 2
; # (In: name)
  %14 = getelementptr i8, i8* %1, i32 24
  %15 = bitcast i8* %14 to i8**
  %16 = load i8*, i8** %15
; # (strrchr S (char "/"))
  %17 = call i8* @strrchr(i8* %16, i32 47)
; # (if P (cons (mkStrE S (inc 'P)) (cons (mkStr P) N)) (cons (consSy...
  %18 = icmp ne i8* %17, null
  br i1 %18, label %$7, label %$8
$7:
  %19 = phi i8* [%17, %$5] ; # P
; # (inc 'P)
  %20 = getelementptr i8, i8* %19, i32 1
; # (mkStrE S (inc 'P))
  %21 = call i64 @mkStrE(i8* %16, i8* %20)
; # (mkStr P)
  %22 = call i64 @mkStr(i8* %20)
; # (cons (mkStr P) N)
  %23 = call i64 @cons(i64 %22, i64 %13)
; # (cons (mkStrE S (inc 'P)) (cons (mkStr P) N))
  %24 = call i64 @cons(i64 %21, i64 %23)
  br label %$9
$8:
  %25 = phi i8* [%17, %$5] ; # P
; # (consSym (hex "2F2E2") 0)
  %26 = call i64 @consSym(i64 193250, i64 0)
; # (mkStr S)
  %27 = call i64 @mkStr(i8* %16)
; # (cons (mkStr S) N)
  %28 = call i64 @cons(i64 %27, i64 %13)
; # (cons (consSym (hex "2F2E2") 0) (cons (mkStr S) N))
  %29 = call i64 @cons(i64 %26, i64 %28)
  br label %$9
$9:
  %30 = phi i8* [%20, %$7], [%25, %$8] ; # P
  %31 = phi i64 [%24, %$7], [%29, %$8] ; # ->
  br label %$6
$6:
  %32 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$4], [%31, %$9] ; # ->
  ret i64 %32
}

define i64 @_argv(i64) {
$1:
; # (let (X (cdr Exe) A (val $AV) P (val A)) (when (and P (== (val P)...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (val $AV)
  %4 = load i8**, i8*** @$AV
; # (val A)
  %5 = load i8*, i8** %4
; # (when (and P (== (val P) (char "-")) (=0 (val 2 P))) (inc 'A))
; # (and P (== (val P) (char "-")) (=0 (val 2 P)))
  %6 = icmp ne i8* %5, null
  br i1 %6, label %$3, label %$2
$3:
  %7 = phi i64 [%3, %$1] ; # X
  %8 = phi i8** [%4, %$1] ; # A
  %9 = phi i8* [%5, %$1] ; # P
; # (val P)
  %10 = load i8, i8* %9
; # (== (val P) (char "-"))
  %11 = icmp eq i8 %10, 45
  br i1 %11, label %$4, label %$2
$4:
  %12 = phi i64 [%7, %$3] ; # X
  %13 = phi i8** [%8, %$3] ; # A
  %14 = phi i8* [%9, %$3] ; # P
; # (val 2 P)
  %15 = getelementptr i8, i8* %14, i32 1
  %16 = load i8, i8* %15
; # (=0 (val 2 P))
  %17 = icmp eq i8 %16, 0
  br label %$2
$2:
  %18 = phi i64 [%3, %$1], [%7, %$3], [%12, %$4] ; # X
  %19 = phi i8** [%4, %$1], [%8, %$3], [%13, %$4] ; # A
  %20 = phi i8* [%5, %$1], [%9, %$3], [%14, %$4] ; # P
  %21 = phi i1 [0, %$1], [0, %$3], [%17, %$4] ; # ->
  br i1 %21, label %$5, label %$6
$5:
  %22 = phi i64 [%18, %$2] ; # X
  %23 = phi i8** [%19, %$2] ; # A
  %24 = phi i8* [%20, %$2] ; # P
; # (inc 'A)
  %25 = getelementptr i8*, i8** %23, i32 1
  br label %$6
$6:
  %26 = phi i64 [%18, %$2], [%22, %$5] ; # X
  %27 = phi i8** [%19, %$2], [%25, %$5] ; # A
  %28 = phi i8* [%20, %$2], [%24, %$5] ; # P
; # (if (nil? X) (if (setq P (val A)) (let (Y (cons (mkStr P) $Nil) R...
; # (nil? X)
  %29 = icmp eq i64 %26, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %29, label %$7, label %$8
$7:
  %30 = phi i64 [%26, %$6] ; # X
  %31 = phi i8** [%27, %$6] ; # A
  %32 = phi i8* [%28, %$6] ; # P
; # (if (setq P (val A)) (let (Y (cons (mkStr P) $Nil) R (save Y)) (w...
; # (val A)
  %33 = load i8*, i8** %31
  %34 = icmp ne i8* %33, null
  br i1 %34, label %$10, label %$11
$10:
  %35 = phi i64 [%30, %$7] ; # X
  %36 = phi i8** [%31, %$7] ; # A
  %37 = phi i8* [%33, %$7] ; # P
; # (let (Y (cons (mkStr P) $Nil) R (save Y)) (while (setq P (val (in...
; # (mkStr P)
  %38 = call i64 @mkStr(i8* %37)
; # (cons (mkStr P) $Nil)
  %39 = call i64 @cons(i64 %38, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %40 = alloca i64, i64 2, align 16
  %41 = ptrtoint i64* %40 to i64
  %42 = inttoptr i64 %41 to i64*
  store i64 %39, i64* %42
  %43 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %44 = load i64, i64* %43
  %45 = inttoptr i64 %41 to i64*
  %46 = getelementptr i64, i64* %45, i32 1
  store i64 %44, i64* %46
  %47 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %41, i64* %47
; # (while (setq P (val (inc 'A))) (setq Y (set 2 Y (cons (mkStr P) $...
  br label %$13
$13:
  %48 = phi i64 [%35, %$10], [%55, %$14] ; # X
  %49 = phi i8** [%36, %$10], [%56, %$14] ; # A
  %50 = phi i8* [%37, %$10], [%57, %$14] ; # P
  %51 = phi i64 [%39, %$10], [%60, %$14] ; # Y
; # (inc 'A)
  %52 = getelementptr i8*, i8** %49, i32 1
; # (val (inc 'A))
  %53 = load i8*, i8** %52
  %54 = icmp ne i8* %53, null
  br i1 %54, label %$14, label %$15
$14:
  %55 = phi i64 [%48, %$13] ; # X
  %56 = phi i8** [%52, %$13] ; # A
  %57 = phi i8* [%53, %$13] ; # P
  %58 = phi i64 [%51, %$13] ; # Y
; # (set 2 Y (cons (mkStr P) $Nil))
; # (mkStr P)
  %59 = call i64 @mkStr(i8* %57)
; # (cons (mkStr P) $Nil)
  %60 = call i64 @cons(i64 %59, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %61 = inttoptr i64 %58 to i64*
  %62 = getelementptr i64, i64* %61, i32 1
  store i64 %60, i64* %62
  br label %$13
$15:
  %63 = phi i64 [%48, %$13] ; # X
  %64 = phi i8** [%52, %$13] ; # A
  %65 = phi i8* [%53, %$13] ; # P
  %66 = phi i64 [%51, %$13] ; # Y
; # (drop *Safe)
  %67 = inttoptr i64 %41 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  %69 = load i64, i64* %68
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %69, i64* %70
  br label %$12
$11:
  %71 = phi i64 [%30, %$7] ; # X
  %72 = phi i8** [%31, %$7] ; # A
  %73 = phi i8* [%33, %$7] ; # P
  br label %$12
$12:
  %74 = phi i64 [%63, %$15], [%71, %$11] ; # X
  %75 = phi i8** [%64, %$15], [%72, %$11] ; # A
  %76 = phi i8* [%65, %$15], [%73, %$11] ; # P
  %77 = phi i64 [%39, %$15], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$11] ; # ->
  br label %$9
$8:
  %78 = phi i64 [%26, %$6] ; # X
  %79 = phi i8** [%27, %$6] ; # A
  %80 = phi i8* [%28, %$6] ; # P
; # (loop (? (atom X) (set (needChkVar Exe X) (if (setq P (val A)) (l...
  br label %$16
$16:
  %81 = phi i64 [%78, %$8], [%171, %$41] ; # X
  %82 = phi i8** [%79, %$8], [%172, %$41] ; # A
  %83 = phi i8* [%80, %$8], [%173, %$41] ; # P
; # (? (atom X) (set (needChkVar Exe X) (if (setq P (val A)) (let (Y ...
; # (atom X)
  %84 = and i64 %81, 15
  %85 = icmp ne i64 %84, 0
  br i1 %85, label %$19, label %$17
$19:
  %86 = phi i64 [%81, %$16] ; # X
  %87 = phi i8** [%82, %$16] ; # A
  %88 = phi i8* [%83, %$16] ; # P
; # (set (needChkVar Exe X) (if (setq P (val A)) (let (Y (cons (mkStr...
; # (needChkVar Exe X)
  %89 = and i64 %86, 6
  %90 = icmp ne i64 %89, 0
  br i1 %90, label %$20, label %$21
$20:
  call void @varErr(i64 %0, i64 %86)
  unreachable
$21:
  %91 = icmp uge i64 %86, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %91, label %$23, label %$22
$23:
  %92 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %86
  br label %$22
$22:
  %93 = phi i1 [0, %$21], [%92, %$23] ; # ->
  br i1 %93, label %$24, label %$25
$24:
  call void @protErr(i64 %0, i64 %86)
  unreachable
$25:
; # (if (setq P (val A)) (let (Y (cons (mkStr P) $Nil) R Y) (save R (...
; # (val A)
  %94 = load i8*, i8** %87
  %95 = icmp ne i8* %94, null
  br i1 %95, label %$26, label %$27
$26:
  %96 = phi i64 [%86, %$25] ; # X
  %97 = phi i8** [%87, %$25] ; # A
  %98 = phi i8* [%94, %$25] ; # P
; # (let (Y (cons (mkStr P) $Nil) R Y) (save R (while (setq P (val (i...
; # (mkStr P)
  %99 = call i64 @mkStr(i8* %98)
; # (cons (mkStr P) $Nil)
  %100 = call i64 @cons(i64 %99, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save R (while (setq P (val (inc 'A))) (setq Y (set 2 Y (cons (mk...
  %101 = alloca i64, i64 2, align 16
  %102 = ptrtoint i64* %101 to i64
  %103 = inttoptr i64 %102 to i64*
  store i64 %100, i64* %103
  %104 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %105 = load i64, i64* %104
  %106 = inttoptr i64 %102 to i64*
  %107 = getelementptr i64, i64* %106, i32 1
  store i64 %105, i64* %107
  %108 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %102, i64* %108
; # (while (setq P (val (inc 'A))) (setq Y (set 2 Y (cons (mkStr P) $...
  br label %$29
$29:
  %109 = phi i64 [%96, %$26], [%116, %$30] ; # X
  %110 = phi i8** [%97, %$26], [%117, %$30] ; # A
  %111 = phi i8* [%98, %$26], [%118, %$30] ; # P
  %112 = phi i64 [%100, %$26], [%121, %$30] ; # Y
; # (inc 'A)
  %113 = getelementptr i8*, i8** %110, i32 1
; # (val (inc 'A))
  %114 = load i8*, i8** %113
  %115 = icmp ne i8* %114, null
  br i1 %115, label %$30, label %$31
$30:
  %116 = phi i64 [%109, %$29] ; # X
  %117 = phi i8** [%113, %$29] ; # A
  %118 = phi i8* [%114, %$29] ; # P
  %119 = phi i64 [%112, %$29] ; # Y
; # (set 2 Y (cons (mkStr P) $Nil))
; # (mkStr P)
  %120 = call i64 @mkStr(i8* %118)
; # (cons (mkStr P) $Nil)
  %121 = call i64 @cons(i64 %120, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %122 = inttoptr i64 %119 to i64*
  %123 = getelementptr i64, i64* %122, i32 1
  store i64 %121, i64* %123
  br label %$29
$31:
  %124 = phi i64 [%109, %$29] ; # X
  %125 = phi i8** [%113, %$29] ; # A
  %126 = phi i8* [%114, %$29] ; # P
  %127 = phi i64 [%112, %$29] ; # Y
  %128 = inttoptr i64 %102 to i64*
  %129 = getelementptr i64, i64* %128, i32 1
  %130 = load i64, i64* %129
  %131 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %130, i64* %131
  br label %$28
$27:
  %132 = phi i64 [%86, %$25] ; # X
  %133 = phi i8** [%87, %$25] ; # A
  %134 = phi i8* [%94, %$25] ; # P
  br label %$28
$28:
  %135 = phi i64 [%124, %$31], [%132, %$27] ; # X
  %136 = phi i8** [%125, %$31], [%133, %$27] ; # A
  %137 = phi i8* [%126, %$31], [%134, %$27] ; # P
  %138 = phi i64 [%100, %$31], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$27] ; # ->
  %139 = inttoptr i64 %86 to i64*
  store i64 %138, i64* %139
  br label %$18
$17:
  %140 = phi i64 [%81, %$16] ; # X
  %141 = phi i8** [%82, %$16] ; # A
  %142 = phi i8* [%83, %$16] ; # P
; # (let Y (ifn (setq P (val A)) $Nil (inc 'A) (mkStr P)) (set (needC...
; # (ifn (setq P (val A)) $Nil (inc 'A) (mkStr P))
; # (val A)
  %143 = load i8*, i8** %141
  %144 = icmp ne i8* %143, null
  br i1 %144, label %$33, label %$32
$32:
  %145 = phi i64 [%140, %$17] ; # X
  %146 = phi i8** [%141, %$17] ; # A
  %147 = phi i8* [%143, %$17] ; # P
  br label %$34
$33:
  %148 = phi i64 [%140, %$17] ; # X
  %149 = phi i8** [%141, %$17] ; # A
  %150 = phi i8* [%143, %$17] ; # P
; # (inc 'A)
  %151 = getelementptr i8*, i8** %149, i32 1
; # (mkStr P)
  %152 = call i64 @mkStr(i8* %150)
  br label %$34
$34:
  %153 = phi i64 [%145, %$32], [%148, %$33] ; # X
  %154 = phi i8** [%146, %$32], [%151, %$33] ; # A
  %155 = phi i8* [%147, %$32], [%150, %$33] ; # P
  %156 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$32], [%152, %$33] ; # ->
; # (set (needChkVar Exe (++ X)) Y)
; # (++ X)
  %157 = inttoptr i64 %153 to i64*
  %158 = load i64, i64* %157
  %159 = getelementptr i64, i64* %157, i32 1
  %160 = load i64, i64* %159
; # (needChkVar Exe (++ X))
  %161 = and i64 %158, 6
  %162 = icmp ne i64 %161, 0
  br i1 %162, label %$35, label %$36
$35:
  call void @varErr(i64 %0, i64 %158)
  unreachable
$36:
  %163 = icmp uge i64 %158, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %163, label %$38, label %$37
$38:
  %164 = icmp uge i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %158
  br label %$37
$37:
  %165 = phi i1 [0, %$36], [%164, %$38] ; # ->
  br i1 %165, label %$39, label %$40
$39:
  call void @protErr(i64 %0, i64 %158)
  unreachable
$40:
  %166 = inttoptr i64 %158 to i64*
  store i64 %156, i64* %166
; # (? (nil? X) Y)
; # (nil? X)
  %167 = icmp eq i64 %160, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %167, label %$42, label %$41
$42:
  %168 = phi i64 [%160, %$40] ; # X
  %169 = phi i8** [%154, %$40] ; # A
  %170 = phi i8* [%155, %$40] ; # P
  br label %$18
$41:
  %171 = phi i64 [%160, %$40] ; # X
  %172 = phi i8** [%154, %$40] ; # A
  %173 = phi i8* [%155, %$40] ; # P
  br label %$16
$18:
  %174 = phi i64 [%135, %$28], [%168, %$42] ; # X
  %175 = phi i8** [%136, %$28], [%169, %$42] ; # A
  %176 = phi i8* [%137, %$28], [%170, %$42] ; # P
  %177 = phi i64 [%138, %$28], [%156, %$42] ; # ->
  br label %$9
$9:
  %178 = phi i64 [%74, %$12], [%174, %$18] ; # X
  %179 = phi i8** [%75, %$12], [%175, %$18] ; # A
  %180 = phi i8* [%76, %$12], [%176, %$18] ; # P
  %181 = phi i64 [%77, %$12], [%177, %$18] ; # ->
  ret i64 %181
}

define i64 @_opt(i64) {
$1:
; # (let (A (val $AV) P (val A)) (if (or (=0 P) (and (== (val P) (cha...
; # (val $AV)
  %1 = load i8**, i8*** @$AV
; # (val A)
  %2 = load i8*, i8** %1
; # (if (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P)))) $Nil...
; # (or (=0 P) (and (== (val P) (char "-")) (=0 (val 2 P))))
; # (=0 P)
  %3 = icmp eq i8* %2, null
  br i1 %3, label %$2, label %$3
$3:
; # (and (== (val P) (char "-")) (=0 (val 2 P)))
; # (val P)
  %4 = load i8, i8* %2
; # (== (val P) (char "-"))
  %5 = icmp eq i8 %4, 45
  br i1 %5, label %$5, label %$4
$5:
; # (val 2 P)
  %6 = getelementptr i8, i8* %2, i32 1
  %7 = load i8, i8* %6
; # (=0 (val 2 P))
  %8 = icmp eq i8 %7, 0
  br label %$4
$4:
  %9 = phi i1 [0, %$3], [%8, %$5] ; # ->
  br label %$2
$2:
  %10 = phi i1 [1, %$1], [%9, %$4] ; # ->
  br i1 %10, label %$6, label %$7
$6:
  br label %$8
$7:
; # (set $AV (inc A))
; # (inc A)
  %11 = getelementptr i8*, i8** %1, i32 1
  store i8** %11, i8*** @$AV
; # (mkStr P)
  %12 = call i64 @mkStr(i8* %2)
  br label %$8
$8:
  %13 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$6], [%12, %$7] ; # ->
  ret i64 %13
}

define i64 @_errno(i64) {
$1:
; # (nErrno)
  %1 = call i32 @nErrno()
; # (i64 (nErrno))
  %2 = sext i32 %1 to i64
; # (cnt (i64 (nErrno)))
  %3 = shl i64 %2, 4
  %4 = or i64 %3, 2
  ret i64 %4
}

define i32 @fetchChar(i8**) {
$1:
; # (let (P (val Ptr) C (i32 (val P))) (prog2 (inc 'P) (cond ((>= 127...
; # (val Ptr)
  %1 = load i8*, i8** %0
; # (val P)
  %2 = load i8, i8* %1
; # (i32 (val P))
  %3 = zext i8 %2 to i32
; # (prog2 (inc 'P) (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)...
; # (inc 'P)
  %4 = getelementptr i8, i8* %1, i32 1
; # (cond ((>= 127 C) C) ((== C (hex "FF")) (i32 TOP)) (T (| (shl (if...
; # (>= 127 C)
  %5 = icmp sge i32 127, %3
  br i1 %5, label %$4, label %$3
$4:
  %6 = phi i8* [%4, %$1] ; # P
  br label %$2
$3:
  %7 = phi i8* [%4, %$1] ; # P
; # (== C (hex "FF"))
  %8 = icmp eq i32 %3, 255
  br i1 %8, label %$6, label %$5
$6:
  %9 = phi i8* [%7, %$3] ; # P
; # (i32 TOP)
  br label %$2
$5:
  %10 = phi i8* [%7, %$3] ; # P
; # (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (hex "10...
; # (& C (hex "20"))
  %11 = and i32 %3, 32
  %12 = icmp ne i32 %11, 0
  br i1 %12, label %$8, label %$7
$7:
  %13 = phi i8* [%10, %$5] ; # P
; # (& C (hex "1F"))
  %14 = and i32 %3, 31
  br label %$9
$8:
  %15 = phi i8* [%10, %$5] ; # P
; # (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7")) 6)...
; # (& C (hex "10"))
  %16 = and i32 %3, 16
  %17 = icmp ne i32 %16, 0
  br i1 %17, label %$11, label %$10
$10:
  %18 = phi i8* [%15, %$8] ; # P
; # (& C (hex "0F"))
  %19 = and i32 %3, 15
  br label %$12
$11:
  %20 = phi i8* [%15, %$8] ; # P
; # (& C (hex "7"))
  %21 = and i32 %3, 7
; # (shl (& C (hex "7")) 6)
  %22 = shl i32 %21, 6
; # (prog1 (val P) (inc 'P))
; # (val P)
  %23 = load i8, i8* %20
; # (inc 'P)
  %24 = getelementptr i8, i8* %20, i32 1
; # (i32 (prog1 (val P) (inc 'P)))
  %25 = zext i8 %23 to i32
; # (& (i32 (prog1 (val P) (inc 'P))) (hex "3F"))
  %26 = and i32 %25, 63
; # (| (shl (& C (hex "7")) 6) (& (i32 (prog1 (val P) (inc 'P))) (hex...
  %27 = or i32 %22, %26
  br label %$12
$12:
  %28 = phi i8* [%18, %$10], [%24, %$11] ; # P
  %29 = phi i32 [%19, %$10], [%27, %$11] ; # ->
; # (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex "7"...
  %30 = shl i32 %29, 6
; # (prog1 (val P) (inc 'P))
; # (val P)
  %31 = load i8, i8* %28
; # (inc 'P)
  %32 = getelementptr i8, i8* %28, i32 1
; # (i32 (prog1 (val P) (inc 'P)))
  %33 = zext i8 %31 to i32
; # (& (i32 (prog1 (val P) (inc 'P))) (hex "3F"))
  %34 = and i32 %33, 63
; # (| (shl (ifn (& C (hex "10")) (& C (hex "0F")) (| (shl (& C (hex ...
  %35 = or i32 %30, %34
  br label %$9
$9:
  %36 = phi i8* [%13, %$7], [%32, %$12] ; # P
  %37 = phi i32 [%14, %$7], [%35, %$12] ; # ->
; # (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C (he...
  %38 = shl i32 %37, 6
; # (prog1 (val P) (inc 'P))
; # (val P)
  %39 = load i8, i8* %36
; # (inc 'P)
  %40 = getelementptr i8, i8* %36, i32 1
; # (i32 (prog1 (val P) (inc 'P)))
  %41 = zext i8 %39 to i32
; # (& (i32 (prog1 (val P) (inc 'P))) (hex "3F"))
  %42 = and i32 %41, 63
; # (| (shl (ifn (& C (hex "20")) (& C (hex "1F")) (| (shl (ifn (& C ...
  %43 = or i32 %38, %42
  br label %$2
$2:
  %44 = phi i8* [%6, %$4], [%9, %$6], [%40, %$9] ; # P
  %45 = phi i32 [%3, %$4], [1114112, %$6], [%43, %$9] ; # ->
; # (set Ptr P)
  store i8* %44, i8** %0
  ret i32 %45
}

define i64 @natBuf(i64, i8*) {
$1:
; # (if (atom Val) (if (sign? Val) (let P (i32* Ptr) (set P (i32 (int...
; # (atom Val)
  %2 = and i64 %0, 15
  %3 = icmp ne i64 %2, 0
  br i1 %3, label %$2, label %$3
$2:
  %4 = phi i64 [%0, %$1] ; # Val
  %5 = phi i8* [%1, %$1] ; # Ptr
; # (if (sign? Val) (let P (i32* Ptr) (set P (i32 (int Val))) 4) (set...
; # (sign? Val)
  %6 = and i64 %4, 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$6
$5:
  %8 = phi i64 [%4, %$2] ; # Val
  %9 = phi i8* [%5, %$2] ; # Ptr
; # (let P (i32* Ptr) (set P (i32 (int Val))) 4)
; # (i32* Ptr)
  %10 = bitcast i8* %9 to i32*
; # (set P (i32 (int Val)))
; # (int Val)
  %11 = lshr i64 %8, 4
; # (i32 (int Val))
  %12 = trunc i64 %11 to i32
  store i32 %12, i32* %10
  br label %$7
$6:
  %13 = phi i64 [%4, %$2] ; # Val
  %14 = phi i8* [%5, %$2] ; # Ptr
; # (set Ptr (i8 (int Val)))
; # (int Val)
  %15 = lshr i64 %13, 4
; # (i8 (int Val))
  %16 = trunc i64 %15 to i8
  store i8 %16, i8* %14
  br label %$7
$7:
  %17 = phi i64 [%8, %$5], [%13, %$6] ; # Val
  %18 = phi i8* [%9, %$5], [%14, %$6] ; # Ptr
  %19 = phi i64 [4, %$5], [1, %$6] ; # ->
  br label %$4
$3:
  %20 = phi i64 [%0, %$1] ; # Val
  %21 = phi i8* [%1, %$1] ; # Ptr
; # (let X (++ Val) (if (cnt? Val) (let Siz (int Val) (cond ((num? X)...
; # (++ Val)
  %22 = inttoptr i64 %20 to i64*
  %23 = load i64, i64* %22
  %24 = getelementptr i64, i64* %22, i32 1
  %25 = load i64, i64* %24
; # (if (cnt? Val) (let Siz (int Val) (cond ((num? X) (let N (if (cnt...
; # (cnt? Val)
  %26 = and i64 %25, 2
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$8, label %$9
$8:
  %28 = phi i64 [%25, %$3] ; # Val
  %29 = phi i8* [%21, %$3] ; # Ptr
  %30 = phi i64 [%23, %$3] ; # X
; # (let Siz (int Val) (cond ((num? X) (let N (if (cnt? X) (int @) (v...
; # (int Val)
  %31 = lshr i64 %28, 4
; # (cond ((num? X) (let N (if (cnt? X) (int @) (val (dig @))) (when ...
; # (num? X)
  %32 = and i64 %30, 6
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$13, label %$12
$13:
  %34 = phi i64 [%28, %$8] ; # Val
  %35 = phi i8* [%29, %$8] ; # Ptr
  %36 = phi i64 [%30, %$8] ; # X
; # (let N (if (cnt? X) (int @) (val (dig @))) (when (sign? X) (setq ...
; # (if (cnt? X) (int @) (val (dig @)))
; # (cnt? X)
  %37 = and i64 %36, 2
  %38 = icmp ne i64 %37, 0
  br i1 %38, label %$14, label %$15
$14:
  %39 = phi i64 [%34, %$13] ; # Val
  %40 = phi i8* [%35, %$13] ; # Ptr
  %41 = phi i64 [%36, %$13] ; # X
; # (int @)
  %42 = lshr i64 %36, 4
  br label %$16
$15:
  %43 = phi i64 [%34, %$13] ; # Val
  %44 = phi i8* [%35, %$13] ; # Ptr
  %45 = phi i64 [%36, %$13] ; # X
; # (dig @)
  %46 = add i64 %36, -4
; # (val (dig @))
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
  br label %$16
$16:
  %49 = phi i64 [%39, %$14], [%43, %$15] ; # Val
  %50 = phi i8* [%40, %$14], [%44, %$15] ; # Ptr
  %51 = phi i64 [%41, %$14], [%45, %$15] ; # X
  %52 = phi i64 [%42, %$14], [%48, %$15] ; # ->
; # (when (sign? X) (setq N (- N)))
; # (sign? X)
  %53 = and i64 %51, 8
  %54 = icmp ne i64 %53, 0
  br i1 %54, label %$17, label %$18
$17:
  %55 = phi i64 [%49, %$16] ; # Val
  %56 = phi i8* [%50, %$16] ; # Ptr
  %57 = phi i64 [%51, %$16] ; # X
  %58 = phi i64 [%52, %$16] ; # N
; # (- N)
  %59 = sub i64 0, %58
  br label %$18
$18:
  %60 = phi i64 [%49, %$16], [%55, %$17] ; # Val
  %61 = phi i8* [%50, %$16], [%56, %$17] ; # Ptr
  %62 = phi i64 [%51, %$16], [%57, %$17] ; # X
  %63 = phi i64 [%52, %$16], [%59, %$17] ; # N
; # (case Siz (1 (set Ptr (i8 N))) (2 (set (i16* Ptr) (i16 N))) (4 (s...
  switch i64 %31, label %$19 [
    i64 1, label %$21
    i64 2, label %$22
    i64 4, label %$23
  ]
$21:
  %64 = phi i64 [%60, %$18] ; # Val
  %65 = phi i8* [%61, %$18] ; # Ptr
  %66 = phi i64 [%62, %$18] ; # X
  %67 = phi i64 [%63, %$18] ; # N
; # (set Ptr (i8 N))
; # (i8 N)
  %68 = trunc i64 %67 to i8
  store i8 %68, i8* %65
  br label %$20
$22:
  %69 = phi i64 [%60, %$18] ; # Val
  %70 = phi i8* [%61, %$18] ; # Ptr
  %71 = phi i64 [%62, %$18] ; # X
  %72 = phi i64 [%63, %$18] ; # N
; # (set (i16* Ptr) (i16 N))
; # (i16* Ptr)
  %73 = bitcast i8* %70 to i16*
; # (i16 N)
  %74 = trunc i64 %72 to i16
  store i16 %74, i16* %73
  br label %$20
$23:
  %75 = phi i64 [%60, %$18] ; # Val
  %76 = phi i8* [%61, %$18] ; # Ptr
  %77 = phi i64 [%62, %$18] ; # X
  %78 = phi i64 [%63, %$18] ; # N
; # (set (i32* Ptr) (i32 N))
; # (i32* Ptr)
  %79 = bitcast i8* %76 to i32*
; # (i32 N)
  %80 = trunc i64 %78 to i32
  store i32 %80, i32* %79
  br label %$20
$19:
  %81 = phi i64 [%60, %$18] ; # Val
  %82 = phi i8* [%61, %$18] ; # Ptr
  %83 = phi i64 [%62, %$18] ; # X
  %84 = phi i64 [%63, %$18] ; # N
; # (set (i64* Ptr) N)
; # (i64* Ptr)
  %85 = bitcast i8* %82 to i64*
  store i64 %84, i64* %85
  br label %$20
$20:
  %86 = phi i64 [%64, %$21], [%69, %$22], [%75, %$23], [%81, %$19] ; # Val
  %87 = phi i8* [%65, %$21], [%70, %$22], [%76, %$23], [%82, %$19] ; # Ptr
  %88 = phi i64 [%66, %$21], [%71, %$22], [%77, %$23], [%83, %$19] ; # X
  %89 = phi i64 [%67, %$21], [%72, %$22], [%78, %$23], [%84, %$19] ; # N
  br label %$11
$12:
  %90 = phi i64 [%28, %$8] ; # Val
  %91 = phi i8* [%29, %$8] ; # Ptr
  %92 = phi i64 [%30, %$8] ; # X
; # (sym? X)
  %93 = and i64 %92, 8
  %94 = icmp ne i64 %93, 0
  br i1 %94, label %$25, label %$24
$25:
  %95 = phi i64 [%90, %$12] ; # Val
  %96 = phi i8* [%91, %$12] ; # Ptr
  %97 = phi i64 [%92, %$12] ; # X
; # (tail X)
  %98 = add i64 %97, -8
; # (val (tail X))
  %99 = inttoptr i64 %98 to i64*
  %100 = load i64, i64* %99
; # (name (val (tail X)))
  br label %$26
$26:
  %101 = phi i64 [%100, %$25], [%107, %$27] ; # Tail
  %102 = and i64 %101, 6
  %103 = icmp ne i64 %102, 0
  br i1 %103, label %$28, label %$27
$27:
  %104 = phi i64 [%101, %$26] ; # Tail
  %105 = inttoptr i64 %104 to i64*
  %106 = getelementptr i64, i64* %105, i32 1
  %107 = load i64, i64* %106
  br label %$26
$28:
  %108 = phi i64 [%101, %$26] ; # Tail
; # (bufString X Ptr)
  %109 = call i8* @bufString(i64 %108, i8* %96)
  br label %$11
$24:
  %110 = phi i64 [%90, %$12] ; # Val
  %111 = phi i8* [%91, %$12] ; # Ptr
  %112 = phi i64 [%92, %$12] ; # X
  br label %$11
$11:
  %113 = phi i64 [%86, %$20], [%95, %$28], [%110, %$24] ; # Val
  %114 = phi i8* [%87, %$20], [%96, %$28], [%111, %$24] ; # Ptr
  %115 = phi i64 [%88, %$20], [%108, %$28], [%112, %$24] ; # X
  br label %$10
$9:
  %116 = phi i64 [%25, %$3] ; # Val
  %117 = phi i8* [%21, %$3] ; # Ptr
  %118 = phi i64 [%23, %$3] ; # X
; # (let (N 0 Scl (int X)) (if (sign? X) (while (pair Val) (bufFloat ...
; # (int X)
  %119 = lshr i64 %118, 4
; # (if (sign? X) (while (pair Val) (bufFloat (++ Val) Scl Ptr) (inc ...
; # (sign? X)
  %120 = and i64 %118, 8
  %121 = icmp ne i64 %120, 0
  br i1 %121, label %$29, label %$30
$29:
  %122 = phi i64 [%116, %$9] ; # Val
  %123 = phi i8* [%117, %$9] ; # Ptr
  %124 = phi i64 [%118, %$9] ; # X
  %125 = phi i64 [0, %$9] ; # N
; # (while (pair Val) (bufFloat (++ Val) Scl Ptr) (inc 'N 4) (setq Pt...
  br label %$32
$32:
  %126 = phi i64 [%122, %$29], [%139, %$33] ; # Val
  %127 = phi i8* [%123, %$29], [%141, %$33] ; # Ptr
  %128 = phi i64 [%124, %$29], [%134, %$33] ; # X
  %129 = phi i64 [%125, %$29], [%140, %$33] ; # N
; # (pair Val)
  %130 = and i64 %126, 15
  %131 = icmp eq i64 %130, 0
  br i1 %131, label %$33, label %$34
$33:
  %132 = phi i64 [%126, %$32] ; # Val
  %133 = phi i8* [%127, %$32] ; # Ptr
  %134 = phi i64 [%128, %$32] ; # X
  %135 = phi i64 [%129, %$32] ; # N
; # (++ Val)
  %136 = inttoptr i64 %132 to i64*
  %137 = load i64, i64* %136
  %138 = getelementptr i64, i64* %136, i32 1
  %139 = load i64, i64* %138
; # (bufFloat (++ Val) Scl Ptr)
  call void @bufFloat(i64 %137, i64 %119, i8* %133)
; # (inc 'N 4)
  %140 = add i64 %135, 4
; # (ofs Ptr 4)
  %141 = getelementptr i8, i8* %133, i32 4
  br label %$32
$34:
  %142 = phi i64 [%126, %$32] ; # Val
  %143 = phi i8* [%127, %$32] ; # Ptr
  %144 = phi i64 [%128, %$32] ; # X
  %145 = phi i64 [%129, %$32] ; # N
  br label %$31
$30:
  %146 = phi i64 [%116, %$9] ; # Val
  %147 = phi i8* [%117, %$9] ; # Ptr
  %148 = phi i64 [%118, %$9] ; # X
  %149 = phi i64 [0, %$9] ; # N
; # (while (pair Val) (bufDouble (++ Val) Scl Ptr) (inc 'N 8) (setq P...
  br label %$35
$35:
  %150 = phi i64 [%146, %$30], [%163, %$36] ; # Val
  %151 = phi i8* [%147, %$30], [%165, %$36] ; # Ptr
  %152 = phi i64 [%148, %$30], [%158, %$36] ; # X
  %153 = phi i64 [%149, %$30], [%164, %$36] ; # N
; # (pair Val)
  %154 = and i64 %150, 15
  %155 = icmp eq i64 %154, 0
  br i1 %155, label %$36, label %$37
$36:
  %156 = phi i64 [%150, %$35] ; # Val
  %157 = phi i8* [%151, %$35] ; # Ptr
  %158 = phi i64 [%152, %$35] ; # X
  %159 = phi i64 [%153, %$35] ; # N
; # (++ Val)
  %160 = inttoptr i64 %156 to i64*
  %161 = load i64, i64* %160
  %162 = getelementptr i64, i64* %160, i32 1
  %163 = load i64, i64* %162
; # (bufDouble (++ Val) Scl Ptr)
  call void @bufDouble(i64 %161, i64 %119, i8* %157)
; # (inc 'N 8)
  %164 = add i64 %159, 8
; # (ofs Ptr 8)
  %165 = getelementptr i8, i8* %157, i32 8
  br label %$35
$37:
  %166 = phi i64 [%150, %$35] ; # Val
  %167 = phi i8* [%151, %$35] ; # Ptr
  %168 = phi i64 [%152, %$35] ; # X
  %169 = phi i64 [%153, %$35] ; # N
  br label %$31
$31:
  %170 = phi i64 [%142, %$34], [%166, %$37] ; # Val
  %171 = phi i8* [%143, %$34], [%167, %$37] ; # Ptr
  %172 = phi i64 [%144, %$34], [%168, %$37] ; # X
  %173 = phi i64 [%145, %$34], [%169, %$37] ; # N
  br label %$10
$10:
  %174 = phi i64 [%113, %$11], [%170, %$31] ; # Val
  %175 = phi i8* [%114, %$11], [%171, %$31] ; # Ptr
  %176 = phi i64 [%115, %$11], [%172, %$31] ; # X
  %177 = phi i64 [%31, %$11], [%173, %$31] ; # ->
  br label %$4
$4:
  %178 = phi i64 [%17, %$7], [%174, %$10] ; # Val
  %179 = phi i8* [%18, %$7], [%175, %$10] ; # Ptr
  %180 = phi i64 [%19, %$7], [%177, %$10] ; # ->
  ret i64 %180
}

define void @natErr(i64) {
$1:
; # (err 0 Spec ($ "Bad result spec") null)
  call void @err(i64 0, i64 %0, i8* bitcast ([16 x i8]* @$77 to i8*), i8* null)
  unreachable
}

define i64 @natRetBuf(i64, i8**) {
$1:
; # (cond ((== Spec $T) (let P (i64* (val Ptr)) (set Ptr (i8* (inc P)...
; # (== Spec $T)
  %2 = icmp eq i64 %0, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %2, label %$4, label %$3
$4:
  %3 = phi i64 [%0, %$1] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %4 = load i8*, i8** %1
; # (i64* (val Ptr))
  %5 = bitcast i8* %4 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %6 = getelementptr i64, i64* %5, i32 1
; # (i8* (inc P))
  %7 = bitcast i64* %6 to i8*
  store i8* %7, i8** %1
; # (val P)
  %8 = load i64, i64* %5
  br label %$2
$3:
  %9 = phi i64 [%0, %$1] ; # Spec
; # (== Spec $N)
  %10 = icmp eq i64 %9, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 200) to i64)
  br i1 %10, label %$6, label %$5
$6:
  %11 = phi i64 [%9, %$3] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (box (val P)))
; # (val Ptr)
  %12 = load i8*, i8** %1
; # (i64* (val Ptr))
  %13 = bitcast i8* %12 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %14 = getelementptr i64, i64* %13, i32 1
; # (i8* (inc P))
  %15 = bitcast i64* %14 to i8*
  store i8* %15, i8** %1
; # (val P)
  %16 = load i64, i64* %13
; # (box (val P))
  %17 = call i64 @box(i64 %16)
  br label %$2
$5:
  %18 = phi i64 [%9, %$3] ; # Spec
; # (== Spec $P)
  %19 = icmp eq i64 %18, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %19, label %$8, label %$7
$8:
  %20 = phi i64 [%18, %$5] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (box64 (val P)))
; # (val Ptr)
  %21 = load i8*, i8** %1
; # (i64* (val Ptr))
  %22 = bitcast i8* %21 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %23 = getelementptr i64, i64* %22, i32 1
; # (i8* (inc P))
  %24 = bitcast i64* %23 to i8*
  store i8* %24, i8** %1
; # (val P)
  %25 = load i64, i64* %22
; # (box64 (val P))
  %26 = and i64 %25, 17293822569102704640
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$9, label %$10
$9:
  %28 = call i64 @boxNum(i64 %25)
  br label %$11
$10:
  %29 = shl i64 %25, 4
  %30 = or i64 %29, 2
  br label %$11
$11:
  %31 = phi i64 [%28, %$9], [%30, %$10] ; # ->
  br label %$2
$7:
  %32 = phi i64 [%18, %$5] ; # Spec
; # (== Spec $I)
  %33 = icmp eq i64 %32, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 264) to i64)
  br i1 %33, label %$13, label %$12
$13:
  %34 = phi i64 [%32, %$7] ; # Spec
; # (if (ge0 (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P))...
; # (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %35 = load i8*, i8** %1
; # (i32* (val Ptr))
  %36 = bitcast i8* %35 to i32*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %37 = getelementptr i32, i32* %36, i32 1
; # (i8* (inc P))
  %38 = bitcast i32* %37 to i8*
  store i8* %38, i8** %1
; # (val P)
  %39 = load i32, i32* %36
; # (ge0 (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P)))
  %40 = icmp sge i32 %39, 0
  br i1 %40, label %$14, label %$15
$14:
  %41 = phi i64 [%34, %$13] ; # Spec
; # (i64 @)
  %42 = sext i32 %39 to i64
; # (cnt (i64 @))
  %43 = shl i64 %42, 4
  %44 = or i64 %43, 2
  br label %$16
$15:
  %45 = phi i64 [%34, %$13] ; # Spec
; # (- @)
  %46 = sub i32 0, %39
; # (i64 (- @))
  %47 = sext i32 %46 to i64
; # (cnt (i64 (- @)))
  %48 = shl i64 %47, 4
  %49 = or i64 %48, 2
; # (sign (cnt (i64 (- @))))
  %50 = or i64 %49, 8
  br label %$16
$16:
  %51 = phi i64 [%41, %$14], [%45, %$15] ; # Spec
  %52 = phi i64 [%44, %$14], [%50, %$15] ; # ->
  br label %$2
$12:
  %53 = phi i64 [%32, %$7] ; # Spec
; # (== Spec $C)
  %54 = icmp eq i64 %53, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br i1 %54, label %$18, label %$17
$18:
  %55 = phi i64 [%53, %$12] ; # Spec
; # (if (fetchChar Ptr) (mkChar @) $Nil)
; # (fetchChar Ptr)
  %56 = call i32 @fetchChar(i8** %1)
  %57 = icmp ne i32 %56, 0
  br i1 %57, label %$19, label %$20
$19:
  %58 = phi i64 [%55, %$18] ; # Spec
; # (mkChar @)
  %59 = call i64 @mkChar(i32 %56)
  br label %$21
$20:
  %60 = phi i64 [%55, %$18] ; # Spec
  br label %$21
$21:
  %61 = phi i64 [%58, %$19], [%60, %$20] ; # Spec
  %62 = phi i64 [%59, %$19], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$20] ; # ->
  br label %$2
$17:
  %63 = phi i64 [%53, %$12] ; # Spec
; # (== Spec $W)
  %64 = icmp eq i64 %63, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 296) to i64)
  br i1 %64, label %$23, label %$22
$23:
  %65 = phi i64 [%63, %$17] ; # Spec
; # (if (ge0 (let P (i16* (val Ptr)) (set Ptr (i8* (inc P))) (val P))...
; # (let P (i16* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %66 = load i8*, i8** %1
; # (i16* (val Ptr))
  %67 = bitcast i8* %66 to i16*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %68 = getelementptr i16, i16* %67, i32 1
; # (i8* (inc P))
  %69 = bitcast i16* %68 to i8*
  store i8* %69, i8** %1
; # (val P)
  %70 = load i16, i16* %67
; # (ge0 (let P (i16* (val Ptr)) (set Ptr (i8* (inc P))) (val P)))
  %71 = icmp sge i16 %70, 0
  br i1 %71, label %$24, label %$25
$24:
  %72 = phi i64 [%65, %$23] ; # Spec
; # (i64 @)
  %73 = sext i16 %70 to i64
; # (cnt (i64 @))
  %74 = shl i64 %73, 4
  %75 = or i64 %74, 2
  br label %$26
$25:
  %76 = phi i64 [%65, %$23] ; # Spec
; # (- @)
  %77 = sub i16 0, %70
; # (i64 (- @))
  %78 = sext i16 %77 to i64
; # (cnt (i64 (- @)))
  %79 = shl i64 %78, 4
  %80 = or i64 %79, 2
; # (sign (cnt (i64 (- @))))
  %81 = or i64 %80, 8
  br label %$26
$26:
  %82 = phi i64 [%72, %$24], [%76, %$25] ; # Spec
  %83 = phi i64 [%75, %$24], [%81, %$25] ; # ->
  br label %$2
$22:
  %84 = phi i64 [%63, %$17] ; # Spec
; # (== Spec $B)
  %85 = icmp eq i64 %84, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 248) to i64)
  br i1 %85, label %$28, label %$27
$28:
  %86 = phi i64 [%84, %$22] ; # Spec
; # (let P (val Ptr) (set Ptr (inc P)) (cnt (i64 (val P))))
; # (val Ptr)
  %87 = load i8*, i8** %1
; # (set Ptr (inc P))
; # (inc P)
  %88 = getelementptr i8, i8* %87, i32 1
  store i8* %88, i8** %1
; # (val P)
  %89 = load i8, i8* %87
; # (i64 (val P))
  %90 = zext i8 %89 to i64
; # (cnt (i64 (val P)))
  %91 = shl i64 %90, 4
  %92 = or i64 %91, 2
  br label %$2
$27:
  %93 = phi i64 [%84, %$22] ; # Spec
; # (== Spec $S)
  %94 = icmp eq i64 %93, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 232) to i64)
  br i1 %94, label %$30, label %$29
$30:
  %95 = phi i64 [%93, %$27] ; # Spec
; # (let P (i8** (val Ptr)) (set Ptr (i8* (inc P))) (mkStr (val P)))
; # (val Ptr)
  %96 = load i8*, i8** %1
; # (i8** (val Ptr))
  %97 = bitcast i8* %96 to i8**
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %98 = getelementptr i8*, i8** %97, i32 1
; # (i8* (inc P))
  %99 = bitcast i8** %98 to i8*
  store i8* %99, i8** %1
; # (val P)
  %100 = load i8*, i8** %97
; # (mkStr (val P))
  %101 = call i64 @mkStr(i8* %100)
  br label %$2
$29:
  %102 = phi i64 [%93, %$27] ; # Spec
; # (cnt? Spec)
  %103 = and i64 %102, 2
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %$32, label %$31
$32:
  %105 = phi i64 [%102, %$29] ; # Spec
; # (if (sign? Spec) (boxFloat (let P (i32* (val Ptr)) (set Ptr (i8* ...
; # (sign? Spec)
  %106 = and i64 %105, 8
  %107 = icmp ne i64 %106, 0
  br i1 %107, label %$33, label %$34
$33:
  %108 = phi i64 [%105, %$32] ; # Spec
; # (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %109 = load i8*, i8** %1
; # (i32* (val Ptr))
  %110 = bitcast i8* %109 to i32*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %111 = getelementptr i32, i32* %110, i32 1
; # (i8* (inc P))
  %112 = bitcast i32* %111 to i8*
  store i8* %112, i8** %1
; # (val P)
  %113 = load i32, i32* %110
; # (int Spec)
  %114 = lshr i64 %108, 4
; # (boxFloat (let P (i32* (val Ptr)) (set Ptr (i8* (inc P))) (val P)...
  %115 = call i64 @boxFloat(i32 %113, i64 %114)
  br label %$35
$34:
  %116 = phi i64 [%105, %$32] ; # Spec
; # (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (val P))
; # (val Ptr)
  %117 = load i8*, i8** %1
; # (i64* (val Ptr))
  %118 = bitcast i8* %117 to i64*
; # (set Ptr (i8* (inc P)))
; # (inc P)
  %119 = getelementptr i64, i64* %118, i32 1
; # (i8* (inc P))
  %120 = bitcast i64* %119 to i8*
  store i8* %120, i8** %1
; # (val P)
  %121 = load i64, i64* %118
; # (int Spec)
  %122 = lshr i64 %116, 4
; # (boxDouble (let P (i64* (val Ptr)) (set Ptr (i8* (inc P))) (val P...
  %123 = call i64 @boxDouble(i64 %121, i64 %122)
  br label %$35
$35:
  %124 = phi i64 [%108, %$33], [%116, %$34] ; # Spec
  %125 = phi i64 [%115, %$33], [%123, %$34] ; # ->
  br label %$2
$31:
  %126 = phi i64 [%102, %$29] ; # Spec
; # (pair Spec)
  %127 = and i64 %126, 15
  %128 = icmp eq i64 %127, 0
  br i1 %128, label %$37, label %$36
$37:
  %129 = phi i64 [%126, %$31] ; # Spec
; # (let (S (++ Spec) R (natRetBuf S Ptr)) (unless (and (nil? R) (== ...
; # (++ Spec)
  %130 = inttoptr i64 %129 to i64*
  %131 = load i64, i64* %130
  %132 = getelementptr i64, i64* %130, i32 1
  %133 = load i64, i64* %132
; # (natRetBuf S Ptr)
  %134 = call i64 @natRetBuf(i64 %131, i8** %1)
; # (unless (and (nil? R) (== S $C)) (let X (setq R (save (cons R $Ni...
; # (and (nil? R) (== S $C))
; # (nil? R)
  %135 = icmp eq i64 %134, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %135, label %$39, label %$38
$39:
  %136 = phi i64 [%133, %$37] ; # Spec
  %137 = phi i64 [%131, %$37] ; # S
  %138 = phi i64 [%134, %$37] ; # R
; # (== S $C)
  %139 = icmp eq i64 %137, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br label %$38
$38:
  %140 = phi i64 [%133, %$37], [%136, %$39] ; # Spec
  %141 = phi i64 [%131, %$37], [%137, %$39] ; # S
  %142 = phi i64 [%134, %$37], [%138, %$39] ; # R
  %143 = phi i1 [0, %$37], [%139, %$39] ; # ->
  br i1 %143, label %$41, label %$40
$40:
  %144 = phi i64 [%140, %$38] ; # Spec
  %145 = phi i64 [%141, %$38] ; # S
  %146 = phi i64 [%142, %$38] ; # R
; # (let X (setq R (save (cons R $Nil))) (loop (? (cnt? Spec) (let C ...
; # (cons R $Nil)
  %147 = call i64 @cons(i64 %146, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons R $Nil))
  %148 = alloca i64, i64 2, align 16
  %149 = ptrtoint i64* %148 to i64
  %150 = inttoptr i64 %149 to i64*
  store i64 %147, i64* %150
  %151 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %152 = load i64, i64* %151
  %153 = inttoptr i64 %149 to i64*
  %154 = getelementptr i64, i64* %153, i32 1
  store i64 %152, i64* %154
  %155 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %149, i64* %155
; # (loop (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (na...
  br label %$42
$42:
  %156 = phi i64 [%144, %$40], [%232, %$55] ; # Spec
  %157 = phi i64 [%145, %$40], [%233, %$55] ; # S
  %158 = phi i64 [%147, %$40], [%234, %$55] ; # R
  %159 = phi i64 [%147, %$40], [%236, %$55] ; # X
; # (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (natRetBu...
; # (cnt? Spec)
  %160 = and i64 %156, 2
  %161 = icmp ne i64 %160, 0
  br i1 %161, label %$45, label %$43
$45:
  %162 = phi i64 [%156, %$42] ; # Spec
  %163 = phi i64 [%157, %$42] ; # S
  %164 = phi i64 [%158, %$42] ; # R
  %165 = phi i64 [%159, %$42] ; # X
; # (let C (int Spec) (while (dec 'C) (let Y (natRetBuf S Ptr) (? (an...
; # (int Spec)
  %166 = lshr i64 %162, 4
; # (while (dec 'C) (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $...
  br label %$46
$46:
  %167 = phi i64 [%162, %$45], [%193, %$51] ; # Spec
  %168 = phi i64 [%163, %$45], [%194, %$51] ; # S
  %169 = phi i64 [%164, %$45], [%195, %$51] ; # R
  %170 = phi i64 [%165, %$45], [%198, %$51] ; # X
  %171 = phi i64 [%166, %$45], [%197, %$51] ; # C
; # (dec 'C)
  %172 = sub i64 %171, 1
  %173 = icmp ne i64 %172, 0
  br i1 %173, label %$47, label %$48
$47:
  %174 = phi i64 [%167, %$46] ; # Spec
  %175 = phi i64 [%168, %$46] ; # S
  %176 = phi i64 [%169, %$46] ; # R
  %177 = phi i64 [%170, %$46] ; # X
  %178 = phi i64 [%172, %$46] ; # C
; # (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $C))) (setq X (se...
; # (natRetBuf S Ptr)
  %179 = call i64 @natRetBuf(i64 %175, i8** %1)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %180 = icmp eq i64 %179, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %180, label %$50, label %$49
$50:
  %181 = phi i64 [%174, %$47] ; # Spec
  %182 = phi i64 [%175, %$47] ; # S
  %183 = phi i64 [%176, %$47] ; # R
  %184 = phi i64 [%177, %$47] ; # X
  %185 = phi i64 [%178, %$47] ; # C
; # (== S $C)
  %186 = icmp eq i64 %182, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br label %$49
$49:
  %187 = phi i64 [%174, %$47], [%181, %$50] ; # Spec
  %188 = phi i64 [%175, %$47], [%182, %$50] ; # S
  %189 = phi i64 [%176, %$47], [%183, %$50] ; # R
  %190 = phi i64 [%177, %$47], [%184, %$50] ; # X
  %191 = phi i64 [%178, %$47], [%185, %$50] ; # C
  %192 = phi i1 [0, %$47], [%186, %$50] ; # ->
  br i1 %192, label %$48, label %$51
$51:
  %193 = phi i64 [%187, %$49] ; # Spec
  %194 = phi i64 [%188, %$49] ; # S
  %195 = phi i64 [%189, %$49] ; # R
  %196 = phi i64 [%190, %$49] ; # X
  %197 = phi i64 [%191, %$49] ; # C
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %198 = call i64 @cons(i64 %179, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %199 = inttoptr i64 %196 to i64*
  %200 = getelementptr i64, i64* %199, i32 1
  store i64 %198, i64* %200
  br label %$46
$48:
  %201 = phi i64 [%167, %$46], [%187, %$49] ; # Spec
  %202 = phi i64 [%168, %$46], [%188, %$49] ; # S
  %203 = phi i64 [%169, %$46], [%189, %$49] ; # R
  %204 = phi i64 [%170, %$46], [%190, %$49] ; # X
  %205 = phi i64 [%172, %$46], [%191, %$49] ; # C
  br label %$44
$43:
  %206 = phi i64 [%156, %$42] ; # Spec
  %207 = phi i64 [%157, %$42] ; # S
  %208 = phi i64 [%158, %$42] ; # R
  %209 = phi i64 [%159, %$42] ; # X
; # (? (atom Spec))
; # (atom Spec)
  %210 = and i64 %206, 15
  %211 = icmp ne i64 %210, 0
  br i1 %211, label %$44, label %$52
$52:
  %212 = phi i64 [%206, %$43] ; # Spec
  %213 = phi i64 [%207, %$43] ; # S
  %214 = phi i64 [%208, %$43] ; # R
  %215 = phi i64 [%209, %$43] ; # X
; # (let Y (natRetBuf (setq S (++ Spec)) Ptr) (? (and (nil? Y) (== S ...
; # (++ Spec)
  %216 = inttoptr i64 %212 to i64*
  %217 = load i64, i64* %216
  %218 = getelementptr i64, i64* %216, i32 1
  %219 = load i64, i64* %218
; # (natRetBuf (setq S (++ Spec)) Ptr)
  %220 = call i64 @natRetBuf(i64 %217, i8** %1)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %221 = icmp eq i64 %220, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %221, label %$54, label %$53
$54:
  %222 = phi i64 [%219, %$52] ; # Spec
  %223 = phi i64 [%217, %$52] ; # S
  %224 = phi i64 [%214, %$52] ; # R
  %225 = phi i64 [%215, %$52] ; # X
; # (== S $C)
  %226 = icmp eq i64 %223, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br label %$53
$53:
  %227 = phi i64 [%219, %$52], [%222, %$54] ; # Spec
  %228 = phi i64 [%217, %$52], [%223, %$54] ; # S
  %229 = phi i64 [%214, %$52], [%224, %$54] ; # R
  %230 = phi i64 [%215, %$52], [%225, %$54] ; # X
  %231 = phi i1 [0, %$52], [%226, %$54] ; # ->
  br i1 %231, label %$44, label %$55
$55:
  %232 = phi i64 [%227, %$53] ; # Spec
  %233 = phi i64 [%228, %$53] ; # S
  %234 = phi i64 [%229, %$53] ; # R
  %235 = phi i64 [%230, %$53] ; # X
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %236 = call i64 @cons(i64 %220, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %237 = inttoptr i64 %235 to i64*
  %238 = getelementptr i64, i64* %237, i32 1
  store i64 %236, i64* %238
  br label %$42
$44:
  %239 = phi i64 [%201, %$48], [%206, %$43], [%227, %$53] ; # Spec
  %240 = phi i64 [%202, %$48], [%207, %$43], [%228, %$53] ; # S
  %241 = phi i64 [%203, %$48], [%208, %$43], [%229, %$53] ; # R
  %242 = phi i64 [%204, %$48], [%209, %$43], [%230, %$53] ; # X
; # (drop *Safe)
  %243 = inttoptr i64 %149 to i64*
  %244 = getelementptr i64, i64* %243, i32 1
  %245 = load i64, i64* %244
  %246 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %245, i64* %246
  br label %$41
$41:
  %247 = phi i64 [%140, %$38], [%239, %$44] ; # Spec
  %248 = phi i64 [%141, %$38], [%240, %$44] ; # S
  %249 = phi i64 [%142, %$38], [%241, %$44] ; # R
  br label %$2
$36:
  %250 = phi i64 [%126, %$31] ; # Spec
; # (natErr Spec)
  call void @natErr(i64 %250)
  unreachable
$2:
  %251 = phi i64 [%3, %$4], [%11, %$6], [%20, %$11], [%51, %$16], [%61, %$21], [%82, %$26], [%86, %$28], [%95, %$30], [%124, %$35], [%247, %$41] ; # Spec
  %252 = phi i64 [%8, %$4], [%17, %$6], [%31, %$11], [%52, %$16], [%62, %$21], [%83, %$26], [%92, %$28], [%101, %$30], [%125, %$35], [%249, %$41] ; # ->
  ret i64 %252
}

define i64 @ffi(i64, i8*, i64, i64) {
$1:
; # (let (Spec (car Args) Val (ffiCall (cond ((cnt? Fun) (i8* (int Fu...
; # (car Args)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (cond ((cnt? Fun) (i8* (int Fun))) ((big? Fun) (i8* (val (dig Fun...
; # (cnt? Fun)
  %6 = and i64 %2, 2
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  %8 = phi i64 [%5, %$1] ; # Spec
; # (int Fun)
  %9 = lshr i64 %2, 4
; # (i8* (int Fun))
  %10 = inttoptr i64 %9 to i8*
  br label %$2
$3:
  %11 = phi i64 [%5, %$1] ; # Spec
; # (big? Fun)
  %12 = and i64 %2, 4
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$6, label %$5
$6:
  %14 = phi i64 [%11, %$3] ; # Spec
; # (dig Fun)
  %15 = add i64 %2, -4
; # (val (dig Fun))
  %16 = inttoptr i64 %15 to i64*
  %17 = load i64, i64* %16
; # (i8* (val (dig Fun)))
  %18 = inttoptr i64 %17 to i8*
  br label %$2
$5:
  %19 = phi i64 [%11, %$3] ; # Spec
; # (pair Fun)
  %20 = and i64 %2, 15
  %21 = icmp eq i64 %20, 0
  br i1 %21, label %$8, label %$7
$8:
  %22 = phi i64 [%19, %$5] ; # Spec
; # (argErr Exe Fun)
  call void @argErr(i64 %0, i64 %2)
  unreachable
$7:
  %23 = phi i64 [%19, %$5] ; # Spec
; # (let Nm (xName Exe Fun) (unless (ffiPrep Lib (bufString Nm (b8 (b...
; # (xName Exe Fun)
  %24 = call i64 @xName(i64 %0, i64 %2)
; # (unless (ffiPrep Lib (bufString Nm (b8 (bufSize Nm))) Args) (err ...
; # (bufSize Nm)
  %25 = call i64 @bufSize(i64 %24)
; # (b8 (bufSize Nm))
  %26 = alloca i8, i64 %25
; # (bufString Nm (b8 (bufSize Nm)))
  %27 = call i8* @bufString(i64 %24, i8* %26)
; # (ffiPrep Lib (bufString Nm (b8 (bufSize Nm))) Args)
  %28 = call i8* @ffiPrep(i8* %1, i8* %27, i64 %3)
  %29 = icmp ne i8* %28, null
  br i1 %29, label %$10, label %$9
$9:
  %30 = phi i64 [%23, %$7] ; # Spec
; # (err Exe 0 ($ "Bad ffi") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([8 x i8]* @$78 to i8*), i8* null)
  unreachable
$10:
  %31 = phi i64 [%23, %$7] ; # Spec
; # (set Fun (box64 (i64 @)))
; # (i64 @)
  %32 = ptrtoint i8* %28 to i64
; # (box64 (i64 @))
  %33 = and i64 %32, 17293822569102704640
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$11, label %$12
$11:
  %35 = call i64 @boxNum(i64 %32)
  br label %$13
$12:
  %36 = shl i64 %32, 4
  %37 = or i64 %36, 2
  br label %$13
$13:
  %38 = phi i64 [%35, %$11], [%37, %$12] ; # ->
  %39 = inttoptr i64 %2 to i64*
  store i64 %38, i64* %39
  br label %$2
$2:
  %40 = phi i64 [%8, %$4], [%14, %$6], [%31, %$13] ; # Spec
  %41 = phi i8* [%10, %$4], [%18, %$6], [%28, %$13] ; # ->
; # (cdr Args)
  %42 = inttoptr i64 %3 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  %44 = load i64, i64* %43
; # (ffiCall (cond ((cnt? Fun) (i8* (int Fun))) ((big? Fun) (i8* (val...
  %45 = call i64 @ffiCall(i8* %41, i64 %44)
; # (cond ((nil? Spec) $Nil) ((== Spec $T) Val) ((== Spec $N) (box Va...
; # (nil? Spec)
  %46 = icmp eq i64 %40, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %46, label %$16, label %$15
$16:
  %47 = phi i64 [%40, %$2] ; # Spec
  br label %$14
$15:
  %48 = phi i64 [%40, %$2] ; # Spec
; # (== Spec $T)
  %49 = icmp eq i64 %48, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64)
  br i1 %49, label %$18, label %$17
$18:
  %50 = phi i64 [%48, %$15] ; # Spec
  br label %$14
$17:
  %51 = phi i64 [%48, %$15] ; # Spec
; # (== Spec $N)
  %52 = icmp eq i64 %51, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 200) to i64)
  br i1 %52, label %$20, label %$19
$20:
  %53 = phi i64 [%51, %$17] ; # Spec
; # (box Val)
  %54 = call i64 @box(i64 %45)
  br label %$14
$19:
  %55 = phi i64 [%51, %$17] ; # Spec
; # (== Spec $P)
  %56 = icmp eq i64 %55, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 280) to i64)
  br i1 %56, label %$22, label %$21
$22:
  %57 = phi i64 [%55, %$19] ; # Spec
; # (box64 Val)
  %58 = and i64 %45, 17293822569102704640
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$23, label %$24
$23:
  %60 = call i64 @boxNum(i64 %45)
  br label %$25
$24:
  %61 = shl i64 %45, 4
  %62 = or i64 %61, 2
  br label %$25
$25:
  %63 = phi i64 [%60, %$23], [%62, %$24] ; # ->
  br label %$14
$21:
  %64 = phi i64 [%55, %$19] ; # Spec
; # (== Spec $I)
  %65 = icmp eq i64 %64, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 264) to i64)
  br i1 %65, label %$27, label %$26
$27:
  %66 = phi i64 [%64, %$21] ; # Spec
; # (if (ge0 (i32 Val)) (cnt (i64 @)) (sign (cnt (i64 (- @)))))
; # (i32 Val)
  %67 = trunc i64 %45 to i32
; # (ge0 (i32 Val))
  %68 = icmp sge i32 %67, 0
  br i1 %68, label %$28, label %$29
$28:
  %69 = phi i64 [%66, %$27] ; # Spec
; # (i64 @)
  %70 = sext i32 %67 to i64
; # (cnt (i64 @))
  %71 = shl i64 %70, 4
  %72 = or i64 %71, 2
  br label %$30
$29:
  %73 = phi i64 [%66, %$27] ; # Spec
; # (- @)
  %74 = sub i32 0, %67
; # (i64 (- @))
  %75 = sext i32 %74 to i64
; # (cnt (i64 (- @)))
  %76 = shl i64 %75, 4
  %77 = or i64 %76, 2
; # (sign (cnt (i64 (- @))))
  %78 = or i64 %77, 8
  br label %$30
$30:
  %79 = phi i64 [%69, %$28], [%73, %$29] ; # Spec
  %80 = phi i64 [%72, %$28], [%78, %$29] ; # ->
  br label %$14
$26:
  %81 = phi i64 [%64, %$21] ; # Spec
; # (== Spec $C)
  %82 = icmp eq i64 %81, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br i1 %82, label %$32, label %$31
$32:
  %83 = phi i64 [%81, %$26] ; # Spec
; # (if (i32 Val) (mkChar @) $Nil)
; # (i32 Val)
  %84 = trunc i64 %45 to i32
  %85 = icmp ne i32 %84, 0
  br i1 %85, label %$33, label %$34
$33:
  %86 = phi i64 [%83, %$32] ; # Spec
; # (mkChar @)
  %87 = call i64 @mkChar(i32 %84)
  br label %$35
$34:
  %88 = phi i64 [%83, %$32] ; # Spec
  br label %$35
$35:
  %89 = phi i64 [%86, %$33], [%88, %$34] ; # Spec
  %90 = phi i64 [%87, %$33], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$34] ; # ->
  br label %$14
$31:
  %91 = phi i64 [%81, %$26] ; # Spec
; # (== Spec $W)
  %92 = icmp eq i64 %91, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 296) to i64)
  br i1 %92, label %$37, label %$36
$37:
  %93 = phi i64 [%91, %$31] ; # Spec
; # (if (ge0 (i16 Val)) (cnt (i64 @)) (sign (cnt (i64 (- @)))))
; # (i16 Val)
  %94 = trunc i64 %45 to i16
; # (ge0 (i16 Val))
  %95 = icmp sge i16 %94, 0
  br i1 %95, label %$38, label %$39
$38:
  %96 = phi i64 [%93, %$37] ; # Spec
; # (i64 @)
  %97 = sext i16 %94 to i64
; # (cnt (i64 @))
  %98 = shl i64 %97, 4
  %99 = or i64 %98, 2
  br label %$40
$39:
  %100 = phi i64 [%93, %$37] ; # Spec
; # (- @)
  %101 = sub i16 0, %94
; # (i64 (- @))
  %102 = sext i16 %101 to i64
; # (cnt (i64 (- @)))
  %103 = shl i64 %102, 4
  %104 = or i64 %103, 2
; # (sign (cnt (i64 (- @))))
  %105 = or i64 %104, 8
  br label %$40
$40:
  %106 = phi i64 [%96, %$38], [%100, %$39] ; # Spec
  %107 = phi i64 [%99, %$38], [%105, %$39] ; # ->
  br label %$14
$36:
  %108 = phi i64 [%91, %$31] ; # Spec
; # (== Spec $B)
  %109 = icmp eq i64 %108, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 248) to i64)
  br i1 %109, label %$42, label %$41
$42:
  %110 = phi i64 [%108, %$36] ; # Spec
; # (i8 Val)
  %111 = trunc i64 %45 to i8
; # (i64 (i8 Val))
  %112 = zext i8 %111 to i64
; # (cnt (i64 (i8 Val)))
  %113 = shl i64 %112, 4
  %114 = or i64 %113, 2
  br label %$14
$41:
  %115 = phi i64 [%108, %$36] ; # Spec
; # (== Spec $S)
  %116 = icmp eq i64 %115, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 232) to i64)
  br i1 %116, label %$44, label %$43
$44:
  %117 = phi i64 [%115, %$41] ; # Spec
; # (i8* Val)
  %118 = inttoptr i64 %45 to i8*
; # (mkStr (i8* Val))
  %119 = call i64 @mkStr(i8* %118)
  br label %$14
$43:
  %120 = phi i64 [%115, %$41] ; # Spec
; # (cnt? Spec)
  %121 = and i64 %120, 2
  %122 = icmp ne i64 %121, 0
  br i1 %122, label %$46, label %$45
$46:
  %123 = phi i64 [%120, %$43] ; # Spec
; # (if (sign? Spec) (boxFloat (i32 Val) (int Spec)) (boxDouble Val (...
; # (sign? Spec)
  %124 = and i64 %123, 8
  %125 = icmp ne i64 %124, 0
  br i1 %125, label %$47, label %$48
$47:
  %126 = phi i64 [%123, %$46] ; # Spec
; # (i32 Val)
  %127 = trunc i64 %45 to i32
; # (int Spec)
  %128 = lshr i64 %126, 4
; # (boxFloat (i32 Val) (int Spec))
  %129 = call i64 @boxFloat(i32 %127, i64 %128)
  br label %$49
$48:
  %130 = phi i64 [%123, %$46] ; # Spec
; # (int Spec)
  %131 = lshr i64 %130, 4
; # (boxDouble Val (int Spec))
  %132 = call i64 @boxDouble(i64 %45, i64 %131)
  br label %$49
$49:
  %133 = phi i64 [%126, %$47], [%130, %$48] ; # Spec
  %134 = phi i64 [%129, %$47], [%132, %$48] ; # ->
  br label %$14
$45:
  %135 = phi i64 [%120, %$43] ; # Spec
; # (and (pair Spec) Val)
; # (pair Spec)
  %136 = and i64 %135, 15
  %137 = icmp eq i64 %136, 0
  br i1 %137, label %$51, label %$50
$51:
  %138 = phi i64 [%135, %$45] ; # Spec
  %139 = icmp ne i64 %45, 0
  br label %$50
$50:
  %140 = phi i64 [%135, %$45], [%138, %$51] ; # Spec
  %141 = phi i1 [0, %$45], [%139, %$51] ; # ->
  br i1 %141, label %$53, label %$52
$53:
  %142 = phi i64 [%140, %$50] ; # Spec
; # (let (Ptr (i8** (push Val)) S (++ Spec) R (natRetBuf S Ptr)) (unl...
; # (push Val)
  %143 = alloca i64, i64 1
  store i64 %45, i64* %143
; # (i8** (push Val))
  %144 = bitcast i64* %143 to i8**
; # (++ Spec)
  %145 = inttoptr i64 %142 to i64*
  %146 = load i64, i64* %145
  %147 = getelementptr i64, i64* %145, i32 1
  %148 = load i64, i64* %147
; # (natRetBuf S Ptr)
  %149 = call i64 @natRetBuf(i64 %146, i8** %144)
; # (unless (and (nil? R) (== S $C)) (let X (setq R (save (cons R $Ni...
; # (and (nil? R) (== S $C))
; # (nil? R)
  %150 = icmp eq i64 %149, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %150, label %$55, label %$54
$55:
  %151 = phi i64 [%148, %$53] ; # Spec
  %152 = phi i64 [%146, %$53] ; # S
  %153 = phi i64 [%149, %$53] ; # R
; # (== S $C)
  %154 = icmp eq i64 %152, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br label %$54
$54:
  %155 = phi i64 [%148, %$53], [%151, %$55] ; # Spec
  %156 = phi i64 [%146, %$53], [%152, %$55] ; # S
  %157 = phi i64 [%149, %$53], [%153, %$55] ; # R
  %158 = phi i1 [0, %$53], [%154, %$55] ; # ->
  br i1 %158, label %$57, label %$56
$56:
  %159 = phi i64 [%155, %$54] ; # Spec
  %160 = phi i64 [%156, %$54] ; # S
  %161 = phi i64 [%157, %$54] ; # R
; # (let X (setq R (save (cons R $Nil))) (loop (? (cnt? Spec) (let C ...
; # (cons R $Nil)
  %162 = call i64 @cons(i64 %161, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons R $Nil))
  %163 = alloca i64, i64 2, align 16
  %164 = ptrtoint i64* %163 to i64
  %165 = inttoptr i64 %164 to i64*
  store i64 %162, i64* %165
  %166 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %167 = load i64, i64* %166
  %168 = inttoptr i64 %164 to i64*
  %169 = getelementptr i64, i64* %168, i32 1
  store i64 %167, i64* %169
  %170 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %164, i64* %170
; # (loop (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (na...
  br label %$58
$58:
  %171 = phi i64 [%159, %$56], [%247, %$71] ; # Spec
  %172 = phi i64 [%160, %$56], [%248, %$71] ; # S
  %173 = phi i64 [%162, %$56], [%249, %$71] ; # R
  %174 = phi i64 [%162, %$56], [%251, %$71] ; # X
; # (? (cnt? Spec) (let C (int Spec) (while (dec 'C) (let Y (natRetBu...
; # (cnt? Spec)
  %175 = and i64 %171, 2
  %176 = icmp ne i64 %175, 0
  br i1 %176, label %$61, label %$59
$61:
  %177 = phi i64 [%171, %$58] ; # Spec
  %178 = phi i64 [%172, %$58] ; # S
  %179 = phi i64 [%173, %$58] ; # R
  %180 = phi i64 [%174, %$58] ; # X
; # (let C (int Spec) (while (dec 'C) (let Y (natRetBuf S Ptr) (? (an...
; # (int Spec)
  %181 = lshr i64 %177, 4
; # (while (dec 'C) (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $...
  br label %$62
$62:
  %182 = phi i64 [%177, %$61], [%208, %$67] ; # Spec
  %183 = phi i64 [%178, %$61], [%209, %$67] ; # S
  %184 = phi i64 [%179, %$61], [%210, %$67] ; # R
  %185 = phi i64 [%180, %$61], [%213, %$67] ; # X
  %186 = phi i64 [%181, %$61], [%212, %$67] ; # C
; # (dec 'C)
  %187 = sub i64 %186, 1
  %188 = icmp ne i64 %187, 0
  br i1 %188, label %$63, label %$64
$63:
  %189 = phi i64 [%182, %$62] ; # Spec
  %190 = phi i64 [%183, %$62] ; # S
  %191 = phi i64 [%184, %$62] ; # R
  %192 = phi i64 [%185, %$62] ; # X
  %193 = phi i64 [%187, %$62] ; # C
; # (let Y (natRetBuf S Ptr) (? (and (nil? Y) (== S $C))) (setq X (se...
; # (natRetBuf S Ptr)
  %194 = call i64 @natRetBuf(i64 %190, i8** %144)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %195 = icmp eq i64 %194, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %195, label %$66, label %$65
$66:
  %196 = phi i64 [%189, %$63] ; # Spec
  %197 = phi i64 [%190, %$63] ; # S
  %198 = phi i64 [%191, %$63] ; # R
  %199 = phi i64 [%192, %$63] ; # X
  %200 = phi i64 [%193, %$63] ; # C
; # (== S $C)
  %201 = icmp eq i64 %197, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br label %$65
$65:
  %202 = phi i64 [%189, %$63], [%196, %$66] ; # Spec
  %203 = phi i64 [%190, %$63], [%197, %$66] ; # S
  %204 = phi i64 [%191, %$63], [%198, %$66] ; # R
  %205 = phi i64 [%192, %$63], [%199, %$66] ; # X
  %206 = phi i64 [%193, %$63], [%200, %$66] ; # C
  %207 = phi i1 [0, %$63], [%201, %$66] ; # ->
  br i1 %207, label %$64, label %$67
$67:
  %208 = phi i64 [%202, %$65] ; # Spec
  %209 = phi i64 [%203, %$65] ; # S
  %210 = phi i64 [%204, %$65] ; # R
  %211 = phi i64 [%205, %$65] ; # X
  %212 = phi i64 [%206, %$65] ; # C
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %213 = call i64 @cons(i64 %194, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %214 = inttoptr i64 %211 to i64*
  %215 = getelementptr i64, i64* %214, i32 1
  store i64 %213, i64* %215
  br label %$62
$64:
  %216 = phi i64 [%182, %$62], [%202, %$65] ; # Spec
  %217 = phi i64 [%183, %$62], [%203, %$65] ; # S
  %218 = phi i64 [%184, %$62], [%204, %$65] ; # R
  %219 = phi i64 [%185, %$62], [%205, %$65] ; # X
  %220 = phi i64 [%187, %$62], [%206, %$65] ; # C
  br label %$60
$59:
  %221 = phi i64 [%171, %$58] ; # Spec
  %222 = phi i64 [%172, %$58] ; # S
  %223 = phi i64 [%173, %$58] ; # R
  %224 = phi i64 [%174, %$58] ; # X
; # (? (atom Spec))
; # (atom Spec)
  %225 = and i64 %221, 15
  %226 = icmp ne i64 %225, 0
  br i1 %226, label %$60, label %$68
$68:
  %227 = phi i64 [%221, %$59] ; # Spec
  %228 = phi i64 [%222, %$59] ; # S
  %229 = phi i64 [%223, %$59] ; # R
  %230 = phi i64 [%224, %$59] ; # X
; # (let Y (natRetBuf (setq S (++ Spec)) Ptr) (? (and (nil? Y) (== S ...
; # (++ Spec)
  %231 = inttoptr i64 %227 to i64*
  %232 = load i64, i64* %231
  %233 = getelementptr i64, i64* %231, i32 1
  %234 = load i64, i64* %233
; # (natRetBuf (setq S (++ Spec)) Ptr)
  %235 = call i64 @natRetBuf(i64 %232, i8** %144)
; # (? (and (nil? Y) (== S $C)))
; # (and (nil? Y) (== S $C))
; # (nil? Y)
  %236 = icmp eq i64 %235, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %236, label %$70, label %$69
$70:
  %237 = phi i64 [%234, %$68] ; # Spec
  %238 = phi i64 [%232, %$68] ; # S
  %239 = phi i64 [%229, %$68] ; # R
  %240 = phi i64 [%230, %$68] ; # X
; # (== S $C)
  %241 = icmp eq i64 %238, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 216) to i64)
  br label %$69
$69:
  %242 = phi i64 [%234, %$68], [%237, %$70] ; # Spec
  %243 = phi i64 [%232, %$68], [%238, %$70] ; # S
  %244 = phi i64 [%229, %$68], [%239, %$70] ; # R
  %245 = phi i64 [%230, %$68], [%240, %$70] ; # X
  %246 = phi i1 [0, %$68], [%241, %$70] ; # ->
  br i1 %246, label %$60, label %$71
$71:
  %247 = phi i64 [%242, %$69] ; # Spec
  %248 = phi i64 [%243, %$69] ; # S
  %249 = phi i64 [%244, %$69] ; # R
  %250 = phi i64 [%245, %$69] ; # X
; # (set 2 X (cons Y $Nil))
; # (cons Y $Nil)
  %251 = call i64 @cons(i64 %235, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %252 = inttoptr i64 %250 to i64*
  %253 = getelementptr i64, i64* %252, i32 1
  store i64 %251, i64* %253
  br label %$58
$60:
  %254 = phi i64 [%216, %$64], [%221, %$59], [%242, %$69] ; # Spec
  %255 = phi i64 [%217, %$64], [%222, %$59], [%243, %$69] ; # S
  %256 = phi i64 [%218, %$64], [%223, %$59], [%244, %$69] ; # R
  %257 = phi i64 [%219, %$64], [%224, %$59], [%245, %$69] ; # X
; # (drop *Safe)
  %258 = inttoptr i64 %164 to i64*
  %259 = getelementptr i64, i64* %258, i32 1
  %260 = load i64, i64* %259
  %261 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %260, i64* %261
  br label %$57
$57:
  %262 = phi i64 [%155, %$54], [%254, %$60] ; # Spec
  %263 = phi i64 [%156, %$54], [%255, %$60] ; # S
  %264 = phi i64 [%157, %$54], [%256, %$60] ; # R
  br label %$14
$52:
  %265 = phi i64 [%140, %$50] ; # Spec
; # (natErr Spec)
  call void @natErr(i64 %265)
  unreachable
$14:
  %266 = phi i64 [%47, %$16], [%50, %$18], [%53, %$20], [%57, %$25], [%79, %$30], [%89, %$35], [%106, %$40], [%110, %$42], [%117, %$44], [%133, %$49], [%262, %$57] ; # Spec
  %267 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$16], [%45, %$18], [%54, %$20], [%63, %$25], [%80, %$30], [%90, %$35], [%107, %$40], [%114, %$42], [%119, %$44], [%134, %$49], [%264, %$57] ; # ->
  ret i64 %267
}

define i64 @_nat(i64) {
$1:
; # (let (X (cdr Exe) Fun (save (eval (++ X))) Args (save (cons (eval...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (save (eval (++ X)))
  %16 = alloca i64, i64 2, align 16
  %17 = ptrtoint i64* %16 to i64
  %18 = inttoptr i64 %17 to i64*
  store i64 %15, i64* %18
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %20 = load i64, i64* %19
  %21 = inttoptr i64 %17 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %20, i64* %22
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %17, i64* %23
; # (++ X)
  %24 = inttoptr i64 %7 to i64*
  %25 = load i64, i64* %24
  %26 = getelementptr i64, i64* %24, i32 1
  %27 = load i64, i64* %26
; # (eval (++ X))
  %28 = and i64 %25, 6
  %29 = icmp ne i64 %28, 0
  br i1 %29, label %$9, label %$8
$9:
  br label %$7
$8:
  %30 = and i64 %25, 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %$11, label %$10
$11:
  %32 = inttoptr i64 %25 to i64*
  %33 = load i64, i64* %32
  br label %$7
$10:
  %34 = call i64 @evList(i64 %25)
  br label %$7
$7:
  %35 = phi i64 [%25, %$9], [%33, %$11], [%34, %$10] ; # ->
; # (cons (eval (++ X)) $Nil)
  %36 = call i64 @cons(i64 %35, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons (eval (++ X)) $Nil))
  %37 = alloca i64, i64 2, align 16
  %38 = ptrtoint i64* %37 to i64
  %39 = inttoptr i64 %38 to i64*
  store i64 %36, i64* %39
  %40 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %41 = load i64, i64* %40
  %42 = inttoptr i64 %38 to i64*
  %43 = getelementptr i64, i64* %42, i32 1
  store i64 %41, i64* %43
  %44 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %38, i64* %44
; # (while (pair X) (let Z (push (save (eval (++ X))) $Nil) (set 2 L ...
  br label %$12
$12:
  %45 = phi i64 [%27, %$7], [%54, %$15] ; # X
  %46 = phi i64 [%36, %$7], [%72, %$15] ; # L
; # (pair X)
  %47 = and i64 %45, 15
  %48 = icmp eq i64 %47, 0
  br i1 %48, label %$13, label %$14
$13:
  %49 = phi i64 [%45, %$12] ; # X
  %50 = phi i64 [%46, %$12] ; # L
; # (let Z (push (save (eval (++ X))) $Nil) (set 2 L Z) (setq L Z))
; # (++ X)
  %51 = inttoptr i64 %49 to i64*
  %52 = load i64, i64* %51
  %53 = getelementptr i64, i64* %51, i32 1
  %54 = load i64, i64* %53
; # (eval (++ X))
  %55 = and i64 %52, 6
  %56 = icmp ne i64 %55, 0
  br i1 %56, label %$17, label %$16
$17:
  br label %$15
$16:
  %57 = and i64 %52, 8
  %58 = icmp ne i64 %57, 0
  br i1 %58, label %$19, label %$18
$19:
  %59 = inttoptr i64 %52 to i64*
  %60 = load i64, i64* %59
  br label %$15
$18:
  %61 = call i64 @evList(i64 %52)
  br label %$15
$15:
  %62 = phi i64 [%52, %$17], [%60, %$19], [%61, %$18] ; # ->
; # (save (eval (++ X)))
  %63 = alloca i64, i64 2, align 16
  %64 = ptrtoint i64* %63 to i64
  %65 = inttoptr i64 %64 to i64*
  store i64 %62, i64* %65
  %66 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %67 = load i64, i64* %66
  %68 = inttoptr i64 %64 to i64*
  %69 = getelementptr i64, i64* %68, i32 1
  store i64 %67, i64* %69
  %70 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %64, i64* %70
; # (push (save (eval (++ X))) $Nil)
  %71 = alloca i64, i64 2, align 16
  %72 = ptrtoint i64* %71 to i64
  %73 = inttoptr i64 %72 to i64*
  store i64 %62, i64* %73
  %74 = add i64 %72, 8
  %75 = inttoptr i64 %74 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %75
; # (set 2 L Z)
  %76 = inttoptr i64 %50 to i64*
  %77 = getelementptr i64, i64* %76, i32 1
  store i64 %72, i64* %77
  br label %$12
$14:
  %78 = phi i64 [%45, %$12] ; # X
  %79 = phi i64 [%46, %$12] ; # L
; # (ffi Exe null Fun Args)
  %80 = tail call i64 @ffi(i64 %0, i8* null, i64 %15, i64 %36)
; # (drop *Safe)
  %81 = inttoptr i64 %17 to i64*
  %82 = getelementptr i64, i64* %81, i32 1
  %83 = load i64, i64* %82
  %84 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %83, i64* %84
  ret i64 %80
}

define i64 @_native(i64) {
$1:
; # (let (X (cdr Exe) Y (eval (++ X)) Lib (cond ((cnt? Y) (i8* (int Y...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (cond ((cnt? Y) (i8* (int Y))) ((big? Y) (i8* (val (dig Y)))) ((p...
; # (cnt? Y)
  %16 = and i64 %15, 2
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$9, label %$8
$9:
  %18 = phi i64 [%7, %$2] ; # X
; # (int Y)
  %19 = lshr i64 %15, 4
; # (i8* (int Y))
  %20 = inttoptr i64 %19 to i8*
  br label %$7
$8:
  %21 = phi i64 [%7, %$2] ; # X
; # (big? Y)
  %22 = and i64 %15, 4
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$11, label %$10
$11:
  %24 = phi i64 [%21, %$8] ; # X
; # (dig Y)
  %25 = add i64 %15, -4
; # (val (dig Y))
  %26 = inttoptr i64 %25 to i64*
  %27 = load i64, i64* %26
; # (i8* (val (dig Y)))
  %28 = inttoptr i64 %27 to i8*
  br label %$7
$10:
  %29 = phi i64 [%21, %$8] ; # X
; # (pair Y)
  %30 = and i64 %15, 15
  %31 = icmp eq i64 %30, 0
  br i1 %31, label %$13, label %$12
$13:
  %32 = phi i64 [%29, %$10] ; # X
; # (argErr Exe Y)
  call void @argErr(i64 %0, i64 %15)
  unreachable
$12:
  %33 = phi i64 [%29, %$10] ; # X
; # (xName Exe Y)
  %34 = call i64 @xName(i64 %0, i64 %15)
; # (| 2 (>> -4 (char "@")))
; # (== (xName Exe Y) (| 2 (>> -4 (char "@"))))
  %35 = icmp eq i64 %34, 1026
  br i1 %35, label %$15, label %$14
$15:
  %36 = phi i64 [%33, %$12] ; # X
; # (set Y ZERO)
  %37 = inttoptr i64 %15 to i64*
  store i64 2, i64* %37
  br label %$7
$14:
  %38 = phi i64 [%33, %$12] ; # X
; # (unless (dlOpen (pathString @ (b8 (pathSize @)))) (err Exe Y ($ "...
; # (pathSize @)
  %39 = call i64 @pathSize(i64 %34)
; # (b8 (pathSize @))
  %40 = alloca i8, i64 %39
; # (pathString @ (b8 (pathSize @)))
  %41 = call i8* @pathString(i64 %34, i8* %40)
; # (dlOpen (pathString @ (b8 (pathSize @))))
  %42 = call i8* @dlOpen(i8* %41)
  %43 = icmp ne i8* %42, null
  br i1 %43, label %$17, label %$16
$16:
  %44 = phi i64 [%38, %$14] ; # X
; # (dlerror)
  %45 = call i8* @dlerror()
; # (err Exe Y ($ "[DLL] %s") (dlerror))
  call void @err(i64 %0, i64 %15, i8* bitcast ([9 x i8]* @$79 to i8*), i8* %45)
  unreachable
$17:
  %46 = phi i64 [%38, %$14] ; # X
; # (set Y (box64 (i64 @)))
; # (i64 @)
  %47 = ptrtoint i8* %42 to i64
; # (box64 (i64 @))
  %48 = and i64 %47, 17293822569102704640
  %49 = icmp ne i64 %48, 0
  br i1 %49, label %$18, label %$19
$18:
  %50 = call i64 @boxNum(i64 %47)
  br label %$20
$19:
  %51 = shl i64 %47, 4
  %52 = or i64 %51, 2
  br label %$20
$20:
  %53 = phi i64 [%50, %$18], [%52, %$19] ; # ->
  %54 = inttoptr i64 %15 to i64*
  store i64 %53, i64* %54
  br label %$7
$7:
  %55 = phi i64 [%18, %$9], [%24, %$11], [%36, %$15], [%46, %$20] ; # X
  %56 = phi i8* [%20, %$9], [%28, %$11], [null, %$15], [%42, %$20] ; # ->
; # (++ X)
  %57 = inttoptr i64 %55 to i64*
  %58 = load i64, i64* %57
  %59 = getelementptr i64, i64* %57, i32 1
  %60 = load i64, i64* %59
; # (eval (++ X))
  %61 = and i64 %58, 6
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$23, label %$22
$23:
  br label %$21
$22:
  %63 = and i64 %58, 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %$25, label %$24
$25:
  %65 = inttoptr i64 %58 to i64*
  %66 = load i64, i64* %65
  br label %$21
$24:
  %67 = call i64 @evList(i64 %58)
  br label %$21
$21:
  %68 = phi i64 [%58, %$23], [%66, %$25], [%67, %$24] ; # ->
; # (save (eval (++ X)))
  %69 = alloca i64, i64 2, align 16
  %70 = ptrtoint i64* %69 to i64
  %71 = inttoptr i64 %70 to i64*
  store i64 %68, i64* %71
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %73 = load i64, i64* %72
  %74 = inttoptr i64 %70 to i64*
  %75 = getelementptr i64, i64* %74, i32 1
  store i64 %73, i64* %75
  %76 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %70, i64* %76
; # (++ X)
  %77 = inttoptr i64 %60 to i64*
  %78 = load i64, i64* %77
  %79 = getelementptr i64, i64* %77, i32 1
  %80 = load i64, i64* %79
; # (eval (++ X))
  %81 = and i64 %78, 6
  %82 = icmp ne i64 %81, 0
  br i1 %82, label %$28, label %$27
$28:
  br label %$26
$27:
  %83 = and i64 %78, 8
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %$30, label %$29
$30:
  %85 = inttoptr i64 %78 to i64*
  %86 = load i64, i64* %85
  br label %$26
$29:
  %87 = call i64 @evList(i64 %78)
  br label %$26
$26:
  %88 = phi i64 [%78, %$28], [%86, %$30], [%87, %$29] ; # ->
; # (cons (eval (++ X)) $Nil)
  %89 = call i64 @cons(i64 %88, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save (cons (eval (++ X)) $Nil))
  %90 = alloca i64, i64 2, align 16
  %91 = ptrtoint i64* %90 to i64
  %92 = inttoptr i64 %91 to i64*
  store i64 %89, i64* %92
  %93 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %94 = load i64, i64* %93
  %95 = inttoptr i64 %91 to i64*
  %96 = getelementptr i64, i64* %95, i32 1
  store i64 %94, i64* %96
  %97 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %91, i64* %97
; # (while (pair X) (let Z (push (save (eval (++ X))) $Nil) (set 2 L ...
  br label %$31
$31:
  %98 = phi i64 [%80, %$26], [%107, %$34] ; # X
  %99 = phi i64 [%89, %$26], [%125, %$34] ; # L
; # (pair X)
  %100 = and i64 %98, 15
  %101 = icmp eq i64 %100, 0
  br i1 %101, label %$32, label %$33
$32:
  %102 = phi i64 [%98, %$31] ; # X
  %103 = phi i64 [%99, %$31] ; # L
; # (let Z (push (save (eval (++ X))) $Nil) (set 2 L Z) (setq L Z))
; # (++ X)
  %104 = inttoptr i64 %102 to i64*
  %105 = load i64, i64* %104
  %106 = getelementptr i64, i64* %104, i32 1
  %107 = load i64, i64* %106
; # (eval (++ X))
  %108 = and i64 %105, 6
  %109 = icmp ne i64 %108, 0
  br i1 %109, label %$36, label %$35
$36:
  br label %$34
$35:
  %110 = and i64 %105, 8
  %111 = icmp ne i64 %110, 0
  br i1 %111, label %$38, label %$37
$38:
  %112 = inttoptr i64 %105 to i64*
  %113 = load i64, i64* %112
  br label %$34
$37:
  %114 = call i64 @evList(i64 %105)
  br label %$34
$34:
  %115 = phi i64 [%105, %$36], [%113, %$38], [%114, %$37] ; # ->
; # (save (eval (++ X)))
  %116 = alloca i64, i64 2, align 16
  %117 = ptrtoint i64* %116 to i64
  %118 = inttoptr i64 %117 to i64*
  store i64 %115, i64* %118
  %119 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %120 = load i64, i64* %119
  %121 = inttoptr i64 %117 to i64*
  %122 = getelementptr i64, i64* %121, i32 1
  store i64 %120, i64* %122
  %123 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %117, i64* %123
; # (push (save (eval (++ X))) $Nil)
  %124 = alloca i64, i64 2, align 16
  %125 = ptrtoint i64* %124 to i64
  %126 = inttoptr i64 %125 to i64*
  store i64 %115, i64* %126
  %127 = add i64 %125, 8
  %128 = inttoptr i64 %127 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %128
; # (set 2 L Z)
  %129 = inttoptr i64 %103 to i64*
  %130 = getelementptr i64, i64* %129, i32 1
  store i64 %125, i64* %130
  br label %$31
$33:
  %131 = phi i64 [%98, %$31] ; # X
  %132 = phi i64 [%99, %$31] ; # L
; # (ffi Exe Lib Fun Args)
  %133 = tail call i64 @ffi(i64 %0, i8* %56, i64 %68, i64 %89)
; # (drop *Safe)
  %134 = inttoptr i64 %70 to i64*
  %135 = getelementptr i64, i64* %134, i32 1
  %136 = load i64, i64* %135
  %137 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %136, i64* %137
  ret i64 %133
}

define i64 @_struct(i64) {
$1:
; # (let (X (cdr Exe) N (if (cnt? (needNum Exe (eval (++ X)))) (int @...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cnt? (needNum Exe (eval (++ X))))
  %18 = and i64 %15, 2
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
  %20 = phi i64 [%7, %$8] ; # X
; # (int @)
  %21 = lshr i64 %15, 4
  br label %$11
$10:
  %22 = phi i64 [%7, %$8] ; # X
; # (dig @)
  %23 = add i64 %15, -4
; # (val (dig @))
  %24 = inttoptr i64 %23 to i64*
  %25 = load i64, i64* %24
  br label %$11
$11:
  %26 = phi i64 [%20, %$9], [%22, %$10] ; # X
  %27 = phi i64 [%21, %$9], [%25, %$10] ; # ->
; # (i8* N)
  %28 = inttoptr i64 %27 to i8*
; # (car X)
  %29 = inttoptr i64 %26 to i64*
  %30 = load i64, i64* %29
; # (eval (car X))
  %31 = and i64 %30, 6
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$14, label %$13
$14:
  br label %$12
$13:
  %33 = and i64 %30, 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %$16, label %$15
$16:
  %35 = inttoptr i64 %30 to i64*
  %36 = load i64, i64* %35
  br label %$12
$15:
  %37 = call i64 @evList(i64 %30)
  br label %$12
$12:
  %38 = phi i64 [%30, %$14], [%36, %$16], [%37, %$15] ; # ->
; # (save (eval (car X)))
  %39 = alloca i64, i64 2, align 16
  %40 = ptrtoint i64* %39 to i64
  %41 = inttoptr i64 %40 to i64*
  store i64 %38, i64* %41
  %42 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %43 = load i64, i64* %42
  %44 = inttoptr i64 %40 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  store i64 %43, i64* %45
  %46 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %46
; # (while (pair (shift X)) (setq P (ofs P (natBuf (eval (car X)) P))...
  br label %$17
$17:
  %47 = phi i64 [%26, %$12], [%54, %$20] ; # X
  %48 = phi i8* [%28, %$12], [%67, %$20] ; # P
; # (shift X)
  %49 = inttoptr i64 %47 to i64*
  %50 = getelementptr i64, i64* %49, i32 1
  %51 = load i64, i64* %50
; # (pair (shift X))
  %52 = and i64 %51, 15
  %53 = icmp eq i64 %52, 0
  br i1 %53, label %$18, label %$19
$18:
  %54 = phi i64 [%51, %$17] ; # X
  %55 = phi i8* [%48, %$17] ; # P
; # (car X)
  %56 = inttoptr i64 %54 to i64*
  %57 = load i64, i64* %56
; # (eval (car X))
  %58 = and i64 %57, 6
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$22, label %$21
$22:
  br label %$20
$21:
  %60 = and i64 %57, 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %$24, label %$23
$24:
  %62 = inttoptr i64 %57 to i64*
  %63 = load i64, i64* %62
  br label %$20
$23:
  %64 = call i64 @evList(i64 %57)
  br label %$20
$20:
  %65 = phi i64 [%57, %$22], [%63, %$24], [%64, %$23] ; # ->
; # (natBuf (eval (car X)) P)
  %66 = call i64 @natBuf(i64 %65, i8* %55)
; # (ofs P (natBuf (eval (car X)) P))
  %67 = getelementptr i8, i8* %55, i64 %66
  br label %$17
$19:
  %68 = phi i64 [%51, %$17] ; # X
  %69 = phi i8* [%48, %$17] ; # P
; # (cond ((nil? Y) @) ((== Y $S) (mkStr (i8* N))) (T (natRetBuf Y (i...
; # (nil? Y)
  %70 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %70, label %$27, label %$26
$27:
  %71 = phi i64 [%68, %$19] ; # X
  %72 = phi i8* [%69, %$19] ; # P
  br label %$25
$26:
  %73 = phi i64 [%68, %$19] ; # X
  %74 = phi i8* [%69, %$19] ; # P
; # (== Y $S)
  %75 = icmp eq i64 %38, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 232) to i64)
  br i1 %75, label %$29, label %$28
$29:
  %76 = phi i64 [%73, %$26] ; # X
  %77 = phi i8* [%74, %$26] ; # P
; # (i8* N)
  %78 = inttoptr i64 %27 to i8*
; # (mkStr (i8* N))
  %79 = call i64 @mkStr(i8* %78)
  br label %$25
$28:
  %80 = phi i64 [%73, %$26] ; # X
  %81 = phi i8* [%74, %$26] ; # P
; # (push N)
  %82 = alloca i64, i64 1
  store i64 %27, i64* %82
; # (i8** (push N))
  %83 = bitcast i64* %82 to i8**
; # (natRetBuf Y (i8** (push N)))
  %84 = call i64 @natRetBuf(i64 %38, i8** %83)
  br label %$25
$25:
  %85 = phi i64 [%71, %$27], [%76, %$29], [%80, %$28] ; # X
  %86 = phi i8* [%72, %$27], [%77, %$29], [%81, %$28] ; # P
  %87 = phi i64 [%38, %$27], [%79, %$29], [%84, %$28] ; # ->
; # (drop *Safe)
  %88 = inttoptr i64 %40 to i64*
  %89 = getelementptr i64, i64* %88, i32 1
  %90 = load i64, i64* %89
  %91 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %90, i64* %91
  ret i64 %87
}

define i64 @cbl(i64, i64, i64, i64, i64, i64) {
$1:
; # (let Exe (push NIL NIL ZERO Fun) (set Exe (ofs Exe 3)) (let P (se...
; # (push NIL NIL ZERO Fun)
  %6 = alloca i64, i64 4, align 16
  %7 = ptrtoint i64* %6 to i64
  %8 = add i64 %7, 16
  %9 = inttoptr i64 %8 to i64*
  store i64 2, i64* %9
  %10 = add i64 %7, 24
  %11 = inttoptr i64 %10 to i64*
  store i64 %0, i64* %11
; # (set Exe (ofs Exe 3))
; # (ofs Exe 3)
  %12 = add i64 %7, 24
  %13 = inttoptr i64 %7 to i64*
  store i64 %12, i64* %13
; # (let P (set 2 Exe (push NIL NIL ZERO (box A))) (set P (ofs P 3)) ...
; # (set 2 Exe (push NIL NIL ZERO (box A)))
; # (box A)
  %14 = call i64 @box(i64 %1)
; # (push NIL NIL ZERO (box A))
  %15 = alloca i64, i64 4, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = add i64 %16, 16
  %18 = inttoptr i64 %17 to i64*
  store i64 2, i64* %18
  %19 = add i64 %16, 24
  %20 = inttoptr i64 %19 to i64*
  store i64 %14, i64* %20
  %21 = inttoptr i64 %7 to i64*
  %22 = getelementptr i64, i64* %21, i32 1
  store i64 %16, i64* %22
; # (set P (ofs P 3))
; # (ofs P 3)
  %23 = add i64 %16, 24
  %24 = inttoptr i64 %16 to i64*
  store i64 %23, i64* %24
; # (set 2 P (push NIL NIL ZERO (box B)))
; # (box B)
  %25 = call i64 @box(i64 %2)
; # (push NIL NIL ZERO (box B))
  %26 = alloca i64, i64 4, align 16
  %27 = ptrtoint i64* %26 to i64
  %28 = add i64 %27, 16
  %29 = inttoptr i64 %28 to i64*
  store i64 2, i64* %29
  %30 = add i64 %27, 24
  %31 = inttoptr i64 %30 to i64*
  store i64 %25, i64* %31
  %32 = inttoptr i64 %16 to i64*
  %33 = getelementptr i64, i64* %32, i32 1
  store i64 %27, i64* %33
; # (set P (ofs P 3))
; # (ofs P 3)
  %34 = add i64 %27, 24
  %35 = inttoptr i64 %27 to i64*
  store i64 %34, i64* %35
; # (set 2 P (push NIL NIL ZERO (box C)))
; # (box C)
  %36 = call i64 @box(i64 %3)
; # (push NIL NIL ZERO (box C))
  %37 = alloca i64, i64 4, align 16
  %38 = ptrtoint i64* %37 to i64
  %39 = add i64 %38, 16
  %40 = inttoptr i64 %39 to i64*
  store i64 2, i64* %40
  %41 = add i64 %38, 24
  %42 = inttoptr i64 %41 to i64*
  store i64 %36, i64* %42
  %43 = inttoptr i64 %27 to i64*
  %44 = getelementptr i64, i64* %43, i32 1
  store i64 %38, i64* %44
; # (set P (ofs P 3))
; # (ofs P 3)
  %45 = add i64 %38, 24
  %46 = inttoptr i64 %38 to i64*
  store i64 %45, i64* %46
; # (set 2 P (push NIL NIL ZERO (box D)))
; # (box D)
  %47 = call i64 @box(i64 %4)
; # (push NIL NIL ZERO (box D))
  %48 = alloca i64, i64 4, align 16
  %49 = ptrtoint i64* %48 to i64
  %50 = add i64 %49, 16
  %51 = inttoptr i64 %50 to i64*
  store i64 2, i64* %51
  %52 = add i64 %49, 24
  %53 = inttoptr i64 %52 to i64*
  store i64 %47, i64* %53
  %54 = inttoptr i64 %38 to i64*
  %55 = getelementptr i64, i64* %54, i32 1
  store i64 %49, i64* %55
; # (set P (ofs P 3))
; # (ofs P 3)
  %56 = add i64 %49, 24
  %57 = inttoptr i64 %49 to i64*
  store i64 %56, i64* %57
; # (set 2 P (push NIL $Nil ZERO (box E)))
; # (box E)
  %58 = call i64 @box(i64 %5)
; # (push NIL $Nil ZERO (box E))
  %59 = alloca i64, i64 4, align 16
  %60 = ptrtoint i64* %59 to i64
  %61 = add i64 %60, 8
  %62 = inttoptr i64 %61 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %62
  %63 = add i64 %60, 16
  %64 = inttoptr i64 %63 to i64*
  store i64 2, i64* %64
  %65 = add i64 %60, 24
  %66 = inttoptr i64 %65 to i64*
  store i64 %58, i64* %66
  %67 = inttoptr i64 %49 to i64*
  %68 = getelementptr i64, i64* %67, i32 1
  store i64 %60, i64* %68
; # (set P (ofs P 3))
; # (ofs P 3)
  %69 = add i64 %60, 24
  %70 = inttoptr i64 %60 to i64*
  store i64 %69, i64* %70
; # (evList Exe)
  %71 = call i64 @evList(i64 %7)
; # (xCnt 0 (evList Exe))
  %72 = call i64 @xCnt(i64 0, i64 %71)
  ret i64 %72
}

define i64 @_cb1(i64, i64, i64, i64, i64) {
$1:
; # (val 2 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 1
  %7 = load i64, i64* %6
; # (cbl (val 2 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb2(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb3(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb4(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb5(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb6(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb7(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb8(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb9(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb10(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb11(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb12(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb13(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb14(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb15(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb16(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb17(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb18(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb19(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb20(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb21(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb22(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb23(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_cb24(i64, i64, i64, i64, i64) {
$1:
; # (val 4 $Lisp)
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64) to i64*
  %6 = getelementptr i64, i64* %5, i32 3
  %7 = load i64, i64* %6
; # (cbl (val 4 $Lisp) A B C D E)
  %8 = call i64 @cbl(i64 %7, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4)
  ret i64 %8
}

define i64 @_lisp(i64) {
$1:
; # (let (X (cdr Exe) Y (evSym X)) (let (P $Lisp Q (i8** (cbFuns))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evSym X)
  %4 = call i64 @evSym(i64 %3)
; # (let (P $Lisp Q (i8** (cbFuns))) (loop (? (== Y (val P))) (setq P...
; # (i8* $Cb)
  %5 = bitcast i64(i64,i64,i64,i64,i64)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @cbFuns to i8*), i32 0) to i64(i64,i64,i64,i64,i64)**) to i8*
; # (i8** (cbFuns))
  %6 = bitcast i8* %5 to i8**
; # (loop (? (== Y (val P))) (setq P (ofs P 2) Q (ofs Q 1)) (? (> P $...
  br label %$2
$2:
  %7 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64), %$1], [%39, %$5] ; # P
  %8 = phi i8** [%6, %$1], [%40, %$5] ; # Q
; # (? (== Y (val P)))
; # (val P)
  %9 = inttoptr i64 %7 to i64*
  %10 = load i64, i64* %9
; # (== Y (val P))
  %11 = icmp eq i64 %4, %10
  br i1 %11, label %$4, label %$3
$3:
  %12 = phi i64 [%7, %$2] ; # P
  %13 = phi i8** [%8, %$2] ; # Q
; # (ofs P 2)
  %14 = add i64 %12, 16
; # (ofs Q 1)
  %15 = getelementptr i8*, i8** %13, i32 1
; # (? (> P $LispEnd) (setq P $Lisp Q (i8** (cbFuns))) (until (nil? (...
; # (> P $LispEnd)
  %16 = icmp ugt i64 %14, ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 408) to i64)
  br i1 %16, label %$6, label %$5
$6:
  %17 = phi i64 [%14, %$3] ; # P
  %18 = phi i8** [%15, %$3] ; # Q
; # (i8* $Cb)
  %19 = bitcast i64(i64,i64,i64,i64,i64)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @cbFuns to i8*), i32 0) to i64(i64,i64,i64,i64,i64)**) to i8*
; # (i8** (cbFuns))
  %20 = bitcast i8* %19 to i8**
; # (until (nil? (val 2 P)) (setq P (ofs P 2) Q (ofs Q 1)) (when (> P...
  br label %$7
$7:
  %21 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 32) to i64), %$6], [%34, %$11] ; # P
  %22 = phi i8** [%20, %$6], [%35, %$11] ; # Q
; # (val 2 P)
  %23 = inttoptr i64 %21 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (nil? (val 2 P))
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %26, label %$9, label %$8
$8:
  %27 = phi i64 [%21, %$7] ; # P
  %28 = phi i8** [%22, %$7] ; # Q
; # (ofs P 2)
  %29 = add i64 %27, 16
; # (ofs Q 1)
  %30 = getelementptr i8*, i8** %28, i32 1
; # (when (> P $LispEnd) (err Exe 0 ($ "Too many callbacks") null))
; # (> P $LispEnd)
  %31 = icmp ugt i64 %29, ptrtoint (i8* getelementptr (i8, i8* bitcast ([52 x i64]* @gcData to i8*), i32 408) to i64)
  br i1 %31, label %$10, label %$11
$10:
  %32 = phi i64 [%29, %$8] ; # P
  %33 = phi i8** [%30, %$8] ; # Q
; # (err Exe 0 ($ "Too many callbacks") null)
  call void @err(i64 %0, i64 0, i8* bitcast ([19 x i8]* @$80 to i8*), i8* null)
  unreachable
$11:
  %34 = phi i64 [%29, %$8] ; # P
  %35 = phi i8** [%30, %$8] ; # Q
  br label %$7
$9:
  %36 = phi i64 [%21, %$7] ; # P
  %37 = phi i8** [%22, %$7] ; # Q
; # (set P Y)
  %38 = inttoptr i64 %36 to i64*
  store i64 %4, i64* %38
  br label %$4
$5:
  %39 = phi i64 [%14, %$3] ; # P
  %40 = phi i8** [%15, %$3] ; # Q
  br label %$2
$4:
  %41 = phi i64 [%7, %$2], [%36, %$9] ; # P
  %42 = phi i8** [%8, %$2], [%37, %$9] ; # Q
  %43 = phi i64 [0, %$2], [%4, %$9] ; # ->
; # (set 2 P (eval (cadr X)))
; # (cadr X)
  %44 = inttoptr i64 %3 to i64*
  %45 = getelementptr i64, i64* %44, i32 1
  %46 = load i64, i64* %45
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
; # (eval (cadr X))
  %49 = and i64 %48, 6
  %50 = icmp ne i64 %49, 0
  br i1 %50, label %$14, label %$13
$14:
  br label %$12
$13:
  %51 = and i64 %48, 8
  %52 = icmp ne i64 %51, 0
  br i1 %52, label %$16, label %$15
$16:
  %53 = inttoptr i64 %48 to i64*
  %54 = load i64, i64* %53
  br label %$12
$15:
  %55 = call i64 @evList(i64 %48)
  br label %$12
$12:
  %56 = phi i64 [%48, %$14], [%54, %$16], [%55, %$15] ; # ->
  %57 = inttoptr i64 %41 to i64*
  %58 = getelementptr i64, i64* %57, i32 1
  store i64 %56, i64* %58
; # (val Q)
  %59 = load i8*, i8** %42
; # (i64 (val Q))
  %60 = ptrtoint i8* %59 to i64
; # (box64 (i64 (val Q)))
  %61 = and i64 %60, 17293822569102704640
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$17, label %$18
$17:
  %63 = call i64 @boxNum(i64 %60)
  br label %$19
$18:
  %64 = shl i64 %60, 4
  %65 = or i64 %64, 2
  br label %$19
$19:
  %66 = phi i64 [%63, %$17], [%65, %$18] ; # ->
  ret i64 %66
}

define i64 @_args(i64) {
$1:
; # (if (pair (val $Next)) $T $Nil)
; # (val $Next)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %2 = load i64, i64* %1
; # (pair (val $Next))
  %3 = and i64 %2, 15
  %4 = icmp eq i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  br label %$4
$3:
  br label %$4
$4:
  %5 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), %$2], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$3] ; # ->
  ret i64 %5
}

define i64 @_next(i64) {
$1:
; # (let X (val $Next) (set $Next (car X)) (cdr X))
; # (val $Next)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %2 = load i64, i64* %1
; # (set $Next (car X))
; # (car X)
  %3 = inttoptr i64 %2 to i64*
  %4 = load i64, i64* %3
  %5 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  store i64 %4, i64* %5
; # (cdr X)
  %6 = inttoptr i64 %2 to i64*
  %7 = getelementptr i64, i64* %6, i32 1
  %8 = load i64, i64* %7
  ret i64 %8
}

define i64 @_arg(i64) {
$1:
; # (if (le0 (evCnt Exe (cdr Exe))) $Nil (let (N @ X (val $Next)) (wh...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (evCnt Exe (cdr Exe))
  %4 = call i64 @evCnt(i64 %0, i64 %3)
; # (le0 (evCnt Exe (cdr Exe)))
  %5 = icmp sle i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
  br label %$4
$3:
; # (let (N @ X (val $Next)) (while (gt0 (dec 'N)) (setq X (car X))) ...
; # (val $Next)
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %7 = load i64, i64* %6
; # (while (gt0 (dec 'N)) (setq X (car X)))
  br label %$5
$5:
  %8 = phi i64 [%4, %$3], [%12, %$6] ; # N
  %9 = phi i64 [%7, %$3], [%15, %$6] ; # X
; # (dec 'N)
  %10 = sub i64 %8, 1
; # (gt0 (dec 'N))
  %11 = icmp sgt i64 %10, 0
  br i1 %11, label %$6, label %$7
$6:
  %12 = phi i64 [%10, %$5] ; # N
  %13 = phi i64 [%9, %$5] ; # X
; # (car X)
  %14 = inttoptr i64 %13 to i64*
  %15 = load i64, i64* %14
  br label %$5
$7:
  %16 = phi i64 [%10, %$5] ; # N
  %17 = phi i64 [%9, %$5] ; # X
; # (cdr X)
  %18 = inttoptr i64 %17 to i64*
  %19 = getelementptr i64, i64* %18, i32 1
  %20 = load i64, i64* %19
  br label %$4
$4:
  %21 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%20, %$7] ; # ->
  ret i64 %21
}

define i64 @_rest(i64) {
$1:
; # (let X (val $Next) (if (atom X) X (let (Y (cons (cdr X) $Nil) R (...
; # (val $Next)
  %1 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 128) to i64) to i64*
  %2 = load i64, i64* %1
; # (if (atom X) X (let (Y (cons (cdr X) $Nil) R (save Y)) (while (pa...
; # (atom X)
  %3 = and i64 %2, 15
  %4 = icmp ne i64 %3, 0
  br i1 %4, label %$2, label %$3
$2:
  %5 = phi i64 [%2, %$1] ; # X
  br label %$4
$3:
  %6 = phi i64 [%2, %$1] ; # X
; # (let (Y (cons (cdr X) $Nil) R (save Y)) (while (pair (setq X (car...
; # (cdr X)
  %7 = inttoptr i64 %6 to i64*
  %8 = getelementptr i64, i64* %7, i32 1
  %9 = load i64, i64* %8
; # (cons (cdr X) $Nil)
  %10 = call i64 @cons(i64 %9, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %11 = alloca i64, i64 2, align 16
  %12 = ptrtoint i64* %11 to i64
  %13 = inttoptr i64 %12 to i64*
  store i64 %10, i64* %13
  %14 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %15 = load i64, i64* %14
  %16 = inttoptr i64 %12 to i64*
  %17 = getelementptr i64, i64* %16, i32 1
  store i64 %15, i64* %17
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %12, i64* %18
; # (while (pair (setq X (car X))) (setq Y (set 2 Y (cons (cdr X) $Ni...
  br label %$5
$5:
  %19 = phi i64 [%6, %$3], [%25, %$6] ; # X
  %20 = phi i64 [%10, %$3], [%30, %$6] ; # Y
; # (car X)
  %21 = inttoptr i64 %19 to i64*
  %22 = load i64, i64* %21
; # (pair (setq X (car X)))
  %23 = and i64 %22, 15
  %24 = icmp eq i64 %23, 0
  br i1 %24, label %$6, label %$7
$6:
  %25 = phi i64 [%22, %$5] ; # X
  %26 = phi i64 [%20, %$5] ; # Y
; # (set 2 Y (cons (cdr X) $Nil))
; # (cdr X)
  %27 = inttoptr i64 %25 to i64*
  %28 = getelementptr i64, i64* %27, i32 1
  %29 = load i64, i64* %28
; # (cons (cdr X) $Nil)
  %30 = call i64 @cons(i64 %29, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %31 = inttoptr i64 %26 to i64*
  %32 = getelementptr i64, i64* %31, i32 1
  store i64 %30, i64* %32
  br label %$5
$7:
  %33 = phi i64 [%22, %$5] ; # X
  %34 = phi i64 [%20, %$5] ; # Y
; # (drop *Safe)
  %35 = inttoptr i64 %12 to i64*
  %36 = getelementptr i64, i64* %35, i32 1
  %37 = load i64, i64* %36
  %38 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %37, i64* %38
  br label %$4
$4:
  %39 = phi i64 [%5, %$2], [%33, %$7] ; # X
  %40 = phi i64 [%5, %$2], [%10, %$7] ; # ->
  ret i64 %40
}

define i64 @_adr(i64) {
$1:
; # (cond ((cnt? (eval (cadr Exe))) (int @)) ((big? @) (val (dig @)))...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$5, label %$4
$5:
  br label %$3
$4:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$7, label %$6
$7:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$3
$6:
  %12 = call i64 @evList(i64 %5)
  br label %$3
$3:
  %13 = phi i64 [%5, %$5], [%11, %$7], [%12, %$6] ; # ->
; # (cnt? (eval (cadr Exe)))
  %14 = and i64 %13, 2
  %15 = icmp ne i64 %14, 0
  br i1 %15, label %$9, label %$8
$9:
; # (int @)
  %16 = lshr i64 %13, 4
  br label %$2
$8:
; # (big? @)
  %17 = and i64 %13, 4
  %18 = icmp ne i64 %17, 0
  br i1 %18, label %$11, label %$10
$11:
; # (dig @)
  %19 = add i64 %13, -4
; # (val (dig @))
  %20 = inttoptr i64 %19 to i64*
  %21 = load i64, i64* %20
  br label %$2
$10:
; # (box64 @)
  %22 = and i64 %13, 17293822569102704640
  %23 = icmp ne i64 %22, 0
  br i1 %23, label %$12, label %$13
$12:
  %24 = call i64 @boxNum(i64 %13)
  br label %$14
$13:
  %25 = shl i64 %13, 4
  %26 = or i64 %25, 2
  br label %$14
$14:
  %27 = phi i64 [%24, %$12], [%26, %$13] ; # ->
  br label %$2
$2:
  %28 = phi i64 [%16, %$9], [%21, %$11], [%27, %$14] ; # ->
  ret i64 %28
}

define i64 @_byte(i64) {
$1:
; # (let (X (cdr Exe) P (i8* (if (cnt? (needNum Exe (eval (++ X)))) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @)))
; # (++ X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
  %6 = getelementptr i64, i64* %4, i32 1
  %7 = load i64, i64* %6
; # (eval (++ X))
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$4, label %$3
$4:
  br label %$2
$3:
  %10 = and i64 %5, 8
  %11 = icmp ne i64 %10, 0
  br i1 %11, label %$6, label %$5
$6:
  %12 = inttoptr i64 %5 to i64*
  %13 = load i64, i64* %12
  br label %$2
$5:
  %14 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %15 = phi i64 [%5, %$4], [%13, %$6], [%14, %$5] ; # ->
; # (needNum Exe (eval (++ X)))
  %16 = and i64 %15, 6
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %$8, label %$7
$7:
  call void @numErr(i64 %0, i64 %15)
  unreachable
$8:
; # (cnt? (needNum Exe (eval (++ X))))
  %18 = and i64 %15, 2
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %$9, label %$10
$9:
; # (int @)
  %20 = lshr i64 %15, 4
  br label %$11
$10:
; # (dig @)
  %21 = add i64 %15, -4
; # (val (dig @))
  %22 = inttoptr i64 %21 to i64*
  %23 = load i64, i64* %22
  br label %$11
$11:
  %24 = phi i64 [%20, %$9], [%23, %$10] ; # ->
; # (i8* (if (cnt? (needNum Exe (eval (++ X)))) (int @) (val (dig @))...
  %25 = inttoptr i64 %24 to i8*
; # (if (atom X) (cnt (i64 (val P))) (let (Y (needCnt Exe (eval (car ...
; # (atom X)
  %26 = and i64 %7, 15
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %$12, label %$13
$12:
; # (val P)
  %28 = load i8, i8* %25
; # (i64 (val P))
  %29 = zext i8 %28 to i64
; # (cnt (i64 (val P)))
  %30 = shl i64 %29, 4
  %31 = or i64 %30, 2
  br label %$14
$13:
; # (let (Y (needCnt Exe (eval (car X))) N (int @)) (set P (i8 (if (s...
; # (car X)
  %32 = inttoptr i64 %7 to i64*
  %33 = load i64, i64* %32
; # (eval (car X))
  %34 = and i64 %33, 6
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %$17, label %$16
$17:
  br label %$15
$16:
  %36 = and i64 %33, 8
  %37 = icmp ne i64 %36, 0
  br i1 %37, label %$19, label %$18
$19:
  %38 = inttoptr i64 %33 to i64*
  %39 = load i64, i64* %38
  br label %$15
$18:
  %40 = call i64 @evList(i64 %33)
  br label %$15
$15:
  %41 = phi i64 [%33, %$17], [%39, %$19], [%40, %$18] ; # ->
; # (needCnt Exe (eval (car X)))
  %42 = and i64 %41, 2
  %43 = icmp ne i64 %42, 0
  br i1 %43, label %$21, label %$20
$20:
  call void @cntErr(i64 %0, i64 %41)
  unreachable
$21:
; # (int @)
  %44 = lshr i64 %41, 4
; # (set P (i8 (if (sign? Y) (- N) N)))
; # (if (sign? Y) (- N) N)
; # (sign? Y)
  %45 = and i64 %41, 8
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$22, label %$23
$22:
; # (- N)
  %47 = sub i64 0, %44
  br label %$24
$23:
  br label %$24
$24:
  %48 = phi i64 [%47, %$22], [%44, %$23] ; # ->
; # (i8 (if (sign? Y) (- N) N))
  %49 = trunc i64 %48 to i8
  store i8 %49, i8* %25
  br label %$14
$14:
  %50 = phi i64 [%31, %$12], [%41, %$24] ; # ->
  ret i64 %50
}

define i64 @_env(i64) {
$1:
; # (let (X (cdr Exe) R (save $Nil)) (if (atom X) (let Bnd (val $Bind...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (save $Nil)
  %4 = alloca i64, i64 2, align 16
  %5 = ptrtoint i64* %4 to i64
  %6 = inttoptr i64 %5 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %6
  %7 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %8 = load i64, i64* %7
  %9 = inttoptr i64 %5 to i64*
  %10 = getelementptr i64, i64* %9, i32 1
  store i64 %8, i64* %10
  %11 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %5, i64* %11
; # (if (atom X) (let Bnd (val $Bind) (while Bnd (let (S (val 2 Bnd) ...
; # (atom X)
  %12 = and i64 %3, 15
  %13 = icmp ne i64 %12, 0
  br i1 %13, label %$2, label %$3
$2:
  %14 = phi i64 [%3, %$1] ; # X
  %15 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (let Bnd (val $Bind) (while Bnd (let (S (val 2 Bnd) Y R) (loop (?...
; # (val $Bind)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %17 = load i64, i64* %16
; # (while Bnd (let (S (val 2 Bnd) Y R) (loop (? (atom Y) (setq R (sa...
  br label %$5
$5:
  %18 = phi i64 [%14, %$2], [%59, %$10] ; # X
  %19 = phi i64 [%15, %$2], [%60, %$10] ; # R
  %20 = phi i64 [%17, %$2], [%66, %$10] ; # Bnd
  %21 = icmp ne i64 %20, 0
  br i1 %21, label %$6, label %$7
$6:
  %22 = phi i64 [%18, %$5] ; # X
  %23 = phi i64 [%19, %$5] ; # R
  %24 = phi i64 [%20, %$5] ; # Bnd
; # (let (S (val 2 Bnd) Y R) (loop (? (atom Y) (setq R (safe (cons (c...
; # (val 2 Bnd)
  %25 = inttoptr i64 %24 to i64*
  %26 = getelementptr i64, i64* %25, i32 1
  %27 = load i64, i64* %26
; # (loop (? (atom Y) (setq R (safe (cons (cons S (val S)) R)))) (? (...
  br label %$8
$8:
  %28 = phi i64 [%22, %$6], [%52, %$12] ; # X
  %29 = phi i64 [%23, %$6], [%53, %$12] ; # R
  %30 = phi i64 [%24, %$6], [%54, %$12] ; # Bnd
  %31 = phi i64 [%23, %$6], [%58, %$12] ; # Y
; # (? (atom Y) (setq R (safe (cons (cons S (val S)) R))))
; # (atom Y)
  %32 = and i64 %31, 15
  %33 = icmp ne i64 %32, 0
  br i1 %33, label %$11, label %$9
$11:
  %34 = phi i64 [%28, %$8] ; # X
  %35 = phi i64 [%29, %$8] ; # R
  %36 = phi i64 [%30, %$8] ; # Bnd
  %37 = phi i64 [%31, %$8] ; # Y
; # (val S)
  %38 = inttoptr i64 %27 to i64*
  %39 = load i64, i64* %38
; # (cons S (val S))
  %40 = call i64 @cons(i64 %27, i64 %39)
; # (cons (cons S (val S)) R)
  %41 = call i64 @cons(i64 %40, i64 %35)
; # (safe (cons (cons S (val S)) R))
  %42 = inttoptr i64 %5 to i64*
  store i64 %41, i64* %42
  br label %$10
$9:
  %43 = phi i64 [%28, %$8] ; # X
  %44 = phi i64 [%29, %$8] ; # R
  %45 = phi i64 [%30, %$8] ; # Bnd
  %46 = phi i64 [%31, %$8] ; # Y
; # (? (== S (caar Y)))
; # (caar Y)
  %47 = inttoptr i64 %46 to i64*
  %48 = load i64, i64* %47
  %49 = inttoptr i64 %48 to i64*
  %50 = load i64, i64* %49
; # (== S (caar Y))
  %51 = icmp eq i64 %27, %50
  br i1 %51, label %$10, label %$12
$12:
  %52 = phi i64 [%43, %$9] ; # X
  %53 = phi i64 [%44, %$9] ; # R
  %54 = phi i64 [%45, %$9] ; # Bnd
  %55 = phi i64 [%46, %$9] ; # Y
; # (shift Y)
  %56 = inttoptr i64 %55 to i64*
  %57 = getelementptr i64, i64* %56, i32 1
  %58 = load i64, i64* %57
  br label %$8
$10:
  %59 = phi i64 [%34, %$11], [%43, %$9] ; # X
  %60 = phi i64 [%41, %$11], [%44, %$9] ; # R
  %61 = phi i64 [%36, %$11], [%45, %$9] ; # Bnd
  %62 = phi i64 [%37, %$11], [%46, %$9] ; # Y
  %63 = phi i64 [%41, %$11], [0, %$9] ; # ->
; # (val 3 Bnd)
  %64 = inttoptr i64 %61 to i64*
  %65 = getelementptr i64, i64* %64, i32 2
  %66 = load i64, i64* %65
  br label %$5
$7:
  %67 = phi i64 [%18, %$5] ; # X
  %68 = phi i64 [%19, %$5] ; # R
  %69 = phi i64 [%20, %$5] ; # Bnd
  br label %$4
$3:
  %70 = phi i64 [%3, %$1] ; # X
  %71 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$1] ; # R
; # (let Y (link (push $Nil NIL)) (loop (let Z (set Y (eval (++ X))) ...
; # (push $Nil NIL)
  %72 = alloca i64, i64 2, align 16
  %73 = ptrtoint i64* %72 to i64
  %74 = inttoptr i64 %73 to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), i64* %74
; # (link (push $Nil NIL))
  %75 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %76 = load i64, i64* %75
  %77 = inttoptr i64 %73 to i64*
  %78 = getelementptr i64, i64* %77, i32 1
  store i64 %76, i64* %78
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %73, i64* %79
; # (loop (let Z (set Y (eval (++ X))) (nond ((atom Z) (loop (let V (...
  br label %$13
$13:
  %80 = phi i64 [%70, %$3], [%170, %$35] ; # X
  %81 = phi i64 [%71, %$3], [%171, %$35] ; # R
; # (let Z (set Y (eval (++ X))) (nond ((atom Z) (loop (let V (++ Z) ...
; # (set Y (eval (++ X)))
; # (++ X)
  %82 = inttoptr i64 %80 to i64*
  %83 = load i64, i64* %82
  %84 = getelementptr i64, i64* %82, i32 1
  %85 = load i64, i64* %84
; # (eval (++ X))
  %86 = and i64 %83, 6
  %87 = icmp ne i64 %86, 0
  br i1 %87, label %$16, label %$15
$16:
  br label %$14
$15:
  %88 = and i64 %83, 8
  %89 = icmp ne i64 %88, 0
  br i1 %89, label %$18, label %$17
$18:
  %90 = inttoptr i64 %83 to i64*
  %91 = load i64, i64* %90
  br label %$14
$17:
  %92 = call i64 @evList(i64 %83)
  br label %$14
$14:
  %93 = phi i64 [%83, %$16], [%91, %$18], [%92, %$17] ; # ->
  %94 = inttoptr i64 %73 to i64*
  store i64 %93, i64* %94
; # (nond ((atom Z) (loop (let V (++ Z) (setq R (safe (cons (if (pair...
; # (atom Z)
  %95 = and i64 %93, 15
  %96 = icmp ne i64 %95, 0
  br i1 %96, label %$20, label %$21
$21:
  %97 = phi i64 [%85, %$14] ; # X
  %98 = phi i64 [%81, %$14] ; # R
  %99 = phi i64 [%93, %$14] ; # Z
; # (loop (let V (++ Z) (setq R (safe (cons (if (pair V) (cons (car V...
  br label %$22
$22:
  %100 = phi i64 [%97, %$21], [%132, %$26] ; # X
  %101 = phi i64 [%98, %$21], [%133, %$26] ; # R
  %102 = phi i64 [%99, %$21], [%134, %$26] ; # Z
; # (let V (++ Z) (setq R (safe (cons (if (pair V) (cons (car V) (cdr...
; # (++ Z)
  %103 = inttoptr i64 %102 to i64*
  %104 = load i64, i64* %103
  %105 = getelementptr i64, i64* %103, i32 1
  %106 = load i64, i64* %105
; # (if (pair V) (cons (car V) (cdr V)) (cons V (val V)))
; # (pair V)
  %107 = and i64 %104, 15
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %$23, label %$24
$23:
  %109 = phi i64 [%100, %$22] ; # X
  %110 = phi i64 [%101, %$22] ; # R
  %111 = phi i64 [%106, %$22] ; # Z
; # (car V)
  %112 = inttoptr i64 %104 to i64*
  %113 = load i64, i64* %112
; # (cdr V)
  %114 = inttoptr i64 %104 to i64*
  %115 = getelementptr i64, i64* %114, i32 1
  %116 = load i64, i64* %115
; # (cons (car V) (cdr V))
  %117 = call i64 @cons(i64 %113, i64 %116)
  br label %$25
$24:
  %118 = phi i64 [%100, %$22] ; # X
  %119 = phi i64 [%101, %$22] ; # R
  %120 = phi i64 [%106, %$22] ; # Z
; # (val V)
  %121 = inttoptr i64 %104 to i64*
  %122 = load i64, i64* %121
; # (cons V (val V))
  %123 = call i64 @cons(i64 %104, i64 %122)
  br label %$25
$25:
  %124 = phi i64 [%109, %$23], [%118, %$24] ; # X
  %125 = phi i64 [%110, %$23], [%119, %$24] ; # R
  %126 = phi i64 [%111, %$23], [%120, %$24] ; # Z
  %127 = phi i64 [%117, %$23], [%123, %$24] ; # ->
; # (cons (if (pair V) (cons (car V) (cdr V)) (cons V (val V))) R)
  %128 = call i64 @cons(i64 %127, i64 %125)
; # (safe (cons (if (pair V) (cons (car V) (cdr V)) (cons V (val V)))...
  %129 = inttoptr i64 %5 to i64*
  store i64 %128, i64* %129
; # (? (atom Z))
; # (atom Z)
  %130 = and i64 %126, 15
  %131 = icmp ne i64 %130, 0
  br i1 %131, label %$27, label %$26
$26:
  %132 = phi i64 [%124, %$25] ; # X
  %133 = phi i64 [%128, %$25] ; # R
  %134 = phi i64 [%126, %$25] ; # Z
  br label %$22
$27:
  %135 = phi i64 [%124, %$25] ; # X
  %136 = phi i64 [%128, %$25] ; # R
  %137 = phi i64 [%126, %$25] ; # Z
  %138 = phi i64 [0, %$25] ; # ->
  br label %$19
$20:
  %139 = phi i64 [%85, %$14] ; # X
  %140 = phi i64 [%81, %$14] ; # R
  %141 = phi i64 [%93, %$14] ; # Z
; # (nil? Z)
  %142 = icmp eq i64 %141, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %142, label %$28, label %$29
$29:
  %143 = phi i64 [%139, %$20] ; # X
  %144 = phi i64 [%140, %$20] ; # R
  %145 = phi i64 [%141, %$20] ; # Z
; # (++ X)
  %146 = inttoptr i64 %143 to i64*
  %147 = load i64, i64* %146
  %148 = getelementptr i64, i64* %146, i32 1
  %149 = load i64, i64* %148
; # (eval (++ X))
  %150 = and i64 %147, 6
  %151 = icmp ne i64 %150, 0
  br i1 %151, label %$32, label %$31
$32:
  br label %$30
$31:
  %152 = and i64 %147, 8
  %153 = icmp ne i64 %152, 0
  br i1 %153, label %$34, label %$33
$34:
  %154 = inttoptr i64 %147 to i64*
  %155 = load i64, i64* %154
  br label %$30
$33:
  %156 = call i64 @evList(i64 %147)
  br label %$30
$30:
  %157 = phi i64 [%147, %$32], [%155, %$34], [%156, %$33] ; # ->
; # (cons Z (eval (++ X)))
  %158 = call i64 @cons(i64 %145, i64 %157)
; # (cons (cons Z (eval (++ X))) R)
  %159 = call i64 @cons(i64 %158, i64 %144)
; # (safe (cons (cons Z (eval (++ X))) R))
  %160 = inttoptr i64 %5 to i64*
  store i64 %159, i64* %160
  br label %$19
$28:
  %161 = phi i64 [%139, %$20] ; # X
  %162 = phi i64 [%140, %$20] ; # R
  %163 = phi i64 [%141, %$20] ; # Z
  br label %$19
$19:
  %164 = phi i64 [%135, %$27], [%149, %$30], [%161, %$28] ; # X
  %165 = phi i64 [%136, %$27], [%159, %$30], [%162, %$28] ; # R
  %166 = phi i64 [%137, %$27], [%145, %$30], [%163, %$28] ; # Z
  %167 = phi i64 [%138, %$27], [%159, %$30], [0, %$28] ; # ->
; # (? (atom X))
; # (atom X)
  %168 = and i64 %164, 15
  %169 = icmp ne i64 %168, 0
  br i1 %169, label %$36, label %$35
$35:
  %170 = phi i64 [%164, %$19] ; # X
  %171 = phi i64 [%165, %$19] ; # R
  br label %$13
$36:
  %172 = phi i64 [%164, %$19] ; # X
  %173 = phi i64 [%165, %$19] ; # R
  %174 = phi i64 [0, %$19] ; # ->
  br label %$4
$4:
  %175 = phi i64 [%67, %$7], [%172, %$36] ; # X
  %176 = phi i64 [%68, %$7], [%173, %$36] ; # R
; # (drop *Safe)
  %177 = inttoptr i64 %5 to i64*
  %178 = getelementptr i64, i64* %177, i32 1
  %179 = load i64, i64* %178
  %180 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %179, i64* %180
  ret i64 %176
}

define i64 @_trail(i64) {
$1:
; # (let (F (not (nil? (eval (cadr Exe)))) Bnd (val $Bind) R $Nil) (w...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
; # (not (nil? (eval (cadr Exe))))
  %15 = icmp eq i1 %14, 0
; # (val $Bind)
  %16 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %17 = load i64, i64* %16
; # (while Bnd (let S (val 2 Bnd) (cond ((== S $At) (when (val 4 Bnd)...
  br label %$7
$7:
  %18 = phi i64 [%17, %$2], [%55, %$10] ; # Bnd
  %19 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$2], [%52, %$10] ; # R
  %20 = icmp ne i64 %18, 0
  br i1 %20, label %$8, label %$9
$8:
  %21 = phi i64 [%18, %$7] ; # Bnd
  %22 = phi i64 [%19, %$7] ; # R
; # (let S (val 2 Bnd) (cond ((== S $At) (when (val 4 Bnd) (setq R (c...
; # (val 2 Bnd)
  %23 = inttoptr i64 %21 to i64*
  %24 = getelementptr i64, i64* %23, i32 1
  %25 = load i64, i64* %24
; # (cond ((== S $At) (when (val 4 Bnd) (setq R (cons @ R)))) (F (set...
; # (== S $At)
  %26 = icmp eq i64 %25, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64)
  br i1 %26, label %$12, label %$11
$12:
  %27 = phi i64 [%21, %$8] ; # Bnd
  %28 = phi i64 [%22, %$8] ; # R
; # (when (val 4 Bnd) (setq R (cons @ R)))
; # (val 4 Bnd)
  %29 = inttoptr i64 %27 to i64*
  %30 = getelementptr i64, i64* %29, i32 3
  %31 = load i64, i64* %30
  %32 = icmp ne i64 %31, 0
  br i1 %32, label %$13, label %$14
$13:
  %33 = phi i64 [%27, %$12] ; # Bnd
  %34 = phi i64 [%28, %$12] ; # R
; # (cons @ R)
  %35 = call i64 @cons(i64 %31, i64 %34)
  br label %$14
$14:
  %36 = phi i64 [%27, %$12], [%33, %$13] ; # Bnd
  %37 = phi i64 [%28, %$12], [%35, %$13] ; # R
  br label %$10
$11:
  %38 = phi i64 [%21, %$8] ; # Bnd
  %39 = phi i64 [%22, %$8] ; # R
  br i1 %15, label %$16, label %$15
$16:
  %40 = phi i64 [%38, %$11] ; # Bnd
  %41 = phi i64 [%39, %$11] ; # R
; # (val S)
  %42 = inttoptr i64 %25 to i64*
  %43 = load i64, i64* %42
; # (cons (val S) R)
  %44 = call i64 @cons(i64 %43, i64 %41)
; # (cons S (cons (val S) R))
  %45 = call i64 @cons(i64 %25, i64 %44)
; # (set S (val Bnd))
; # (val Bnd)
  %46 = inttoptr i64 %40 to i64*
  %47 = load i64, i64* %46
  %48 = inttoptr i64 %25 to i64*
  store i64 %47, i64* %48
  br label %$10
$15:
  %49 = phi i64 [%38, %$11] ; # Bnd
  %50 = phi i64 [%39, %$11] ; # R
  br label %$10
$10:
  %51 = phi i64 [%36, %$14], [%40, %$16], [%49, %$15] ; # Bnd
  %52 = phi i64 [%37, %$14], [%45, %$16], [%50, %$15] ; # R
; # (val 3 Bnd)
  %53 = inttoptr i64 %51 to i64*
  %54 = getelementptr i64, i64* %53, i32 2
  %55 = load i64, i64* %54
  br label %$7
$9:
  %56 = phi i64 [%18, %$7] ; # Bnd
  %57 = phi i64 [%19, %$7] ; # R
; # (let X R (until (atom X) (when (atom (++ X)) (set @ (++ X)))))
; # (until (atom X) (when (atom (++ X)) (set @ (++ X))))
  br label %$17
$17:
  %58 = phi i64 [%56, %$9], [%80, %$21] ; # Bnd
  %59 = phi i64 [%57, %$9], [%81, %$21] ; # R
  %60 = phi i64 [%57, %$9], [%82, %$21] ; # X
; # (atom X)
  %61 = and i64 %60, 15
  %62 = icmp ne i64 %61, 0
  br i1 %62, label %$19, label %$18
$18:
  %63 = phi i64 [%58, %$17] ; # Bnd
  %64 = phi i64 [%59, %$17] ; # R
  %65 = phi i64 [%60, %$17] ; # X
; # (when (atom (++ X)) (set @ (++ X)))
; # (++ X)
  %66 = inttoptr i64 %65 to i64*
  %67 = load i64, i64* %66
  %68 = getelementptr i64, i64* %66, i32 1
  %69 = load i64, i64* %68
; # (atom (++ X))
  %70 = and i64 %67, 15
  %71 = icmp ne i64 %70, 0
  br i1 %71, label %$20, label %$21
$20:
  %72 = phi i64 [%63, %$18] ; # Bnd
  %73 = phi i64 [%64, %$18] ; # R
  %74 = phi i64 [%69, %$18] ; # X
; # (set @ (++ X))
; # (++ X)
  %75 = inttoptr i64 %74 to i64*
  %76 = load i64, i64* %75
  %77 = getelementptr i64, i64* %75, i32 1
  %78 = load i64, i64* %77
  %79 = inttoptr i64 %67 to i64*
  store i64 %76, i64* %79
  br label %$21
$21:
  %80 = phi i64 [%63, %$18], [%72, %$20] ; # Bnd
  %81 = phi i64 [%64, %$18], [%73, %$20] ; # R
  %82 = phi i64 [%69, %$18], [%78, %$20] ; # X
  br label %$17
$19:
  %83 = phi i64 [%58, %$17] ; # Bnd
  %84 = phi i64 [%59, %$17] ; # R
  %85 = phi i64 [%60, %$17] ; # X
  ret i64 %84
}

define i64 @_up(i64) {
$1:
; # (let (X (cdr Exe) Y (car X) N 1 Bnd (val $Bind)) (when (num? Y) (...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (car X)
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (val $Bind)
  %6 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 8) to i64) to i64*
  %7 = load i64, i64* %6
; # (when (num? Y) (setq N (int Y) Y (car (shift X))))
; # (num? Y)
  %8 = and i64 %5, 6
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$2, label %$3
$2:
  %10 = phi i64 [%3, %$1] ; # X
  %11 = phi i64 [%5, %$1] ; # Y
  %12 = phi i64 [1, %$1] ; # N
  %13 = phi i64 [%7, %$1] ; # Bnd
; # (int Y)
  %14 = lshr i64 %11, 4
; # (shift X)
  %15 = inttoptr i64 %10 to i64*
  %16 = getelementptr i64, i64* %15, i32 1
  %17 = load i64, i64* %16
; # (car (shift X))
  %18 = inttoptr i64 %17 to i64*
  %19 = load i64, i64* %18
  br label %$3
$3:
  %20 = phi i64 [%3, %$1], [%17, %$2] ; # X
  %21 = phi i64 [%5, %$1], [%19, %$2] ; # Y
  %22 = phi i64 [1, %$1], [%14, %$2] ; # N
  %23 = phi i64 [%7, %$1], [%13, %$2] ; # Bnd
; # (if (nil? Y) (if N (loop (? (=0 Bnd) $Nil) (? (and (== $At (val 2...
; # (nil? Y)
  %24 = icmp eq i64 %21, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %24, label %$4, label %$5
$4:
  %25 = phi i64 [%20, %$3] ; # X
  %26 = phi i64 [%21, %$3] ; # Y
  %27 = phi i64 [%22, %$3] ; # N
  %28 = phi i64 [%23, %$3] ; # Bnd
; # (if N (loop (? (=0 Bnd) $Nil) (? (and (== $At (val 2 Bnd)) (=0 (d...
  %29 = icmp ne i64 %27, 0
  br i1 %29, label %$7, label %$8
$7:
  %30 = phi i64 [%25, %$4] ; # X
  %31 = phi i64 [%26, %$4] ; # Y
  %32 = phi i64 [%27, %$4] ; # N
  %33 = phi i64 [%28, %$4] ; # Bnd
; # (loop (? (=0 Bnd) $Nil) (? (and (== $At (val 2 Bnd)) (=0 (dec 'N)...
  br label %$10
$10:
  %34 = phi i64 [%30, %$7], [%83, %$16] ; # X
  %35 = phi i64 [%31, %$7], [%84, %$16] ; # Y
  %36 = phi i64 [%32, %$7], [%85, %$16] ; # N
  %37 = phi i64 [%33, %$7], [%89, %$16] ; # Bnd
; # (? (=0 Bnd) $Nil)
; # (=0 Bnd)
  %38 = icmp eq i64 %37, 0
  br i1 %38, label %$13, label %$11
$13:
  %39 = phi i64 [%34, %$10] ; # X
  %40 = phi i64 [%35, %$10] ; # Y
  %41 = phi i64 [%36, %$10] ; # N
  %42 = phi i64 [%37, %$10] ; # Bnd
  br label %$12
$11:
  %43 = phi i64 [%34, %$10] ; # X
  %44 = phi i64 [%35, %$10] ; # Y
  %45 = phi i64 [%36, %$10] ; # N
  %46 = phi i64 [%37, %$10] ; # Bnd
; # (? (and (== $At (val 2 Bnd)) (=0 (dec 'N))) (if (val 4 Bnd) @ $Ni...
; # (and (== $At (val 2 Bnd)) (=0 (dec 'N)))
; # (val 2 Bnd)
  %47 = inttoptr i64 %46 to i64*
  %48 = getelementptr i64, i64* %47, i32 1
  %49 = load i64, i64* %48
; # (== $At (val 2 Bnd))
  %50 = icmp eq i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 392) to i64), %49
  br i1 %50, label %$15, label %$14
$15:
  %51 = phi i64 [%43, %$11] ; # X
  %52 = phi i64 [%44, %$11] ; # Y
  %53 = phi i64 [%45, %$11] ; # N
  %54 = phi i64 [%46, %$11] ; # Bnd
; # (dec 'N)
  %55 = sub i64 %53, 1
; # (=0 (dec 'N))
  %56 = icmp eq i64 %55, 0
  br label %$14
$14:
  %57 = phi i64 [%43, %$11], [%51, %$15] ; # X
  %58 = phi i64 [%44, %$11], [%52, %$15] ; # Y
  %59 = phi i64 [%45, %$11], [%55, %$15] ; # N
  %60 = phi i64 [%46, %$11], [%54, %$15] ; # Bnd
  %61 = phi i1 [0, %$11], [%56, %$15] ; # ->
  br i1 %61, label %$17, label %$16
$17:
  %62 = phi i64 [%57, %$14] ; # X
  %63 = phi i64 [%58, %$14] ; # Y
  %64 = phi i64 [%59, %$14] ; # N
  %65 = phi i64 [%60, %$14] ; # Bnd
; # (if (val 4 Bnd) @ $Nil)
; # (val 4 Bnd)
  %66 = inttoptr i64 %65 to i64*
  %67 = getelementptr i64, i64* %66, i32 3
  %68 = load i64, i64* %67
  %69 = icmp ne i64 %68, 0
  br i1 %69, label %$18, label %$19
$18:
  %70 = phi i64 [%62, %$17] ; # X
  %71 = phi i64 [%63, %$17] ; # Y
  %72 = phi i64 [%64, %$17] ; # N
  %73 = phi i64 [%65, %$17] ; # Bnd
  br label %$20
$19:
  %74 = phi i64 [%62, %$17] ; # X
  %75 = phi i64 [%63, %$17] ; # Y
  %76 = phi i64 [%64, %$17] ; # N
  %77 = phi i64 [%65, %$17] ; # Bnd
  br label %$20
$20:
  %78 = phi i64 [%70, %$18], [%74, %$19] ; # X
  %79 = phi i64 [%71, %$18], [%75, %$19] ; # Y
  %80 = phi i64 [%72, %$18], [%76, %$19] ; # N
  %81 = phi i64 [%73, %$18], [%77, %$19] ; # Bnd
  %82 = phi i64 [%68, %$18], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$19] ; # ->
  br label %$12
$16:
  %83 = phi i64 [%57, %$14] ; # X
  %84 = phi i64 [%58, %$14] ; # Y
  %85 = phi i64 [%59, %$14] ; # N
  %86 = phi i64 [%60, %$14] ; # Bnd
; # (val 3 Bnd)
  %87 = inttoptr i64 %86 to i64*
  %88 = getelementptr i64, i64* %87, i32 2
  %89 = load i64, i64* %88
  br label %$10
$12:
  %90 = phi i64 [%39, %$13], [%78, %$20] ; # X
  %91 = phi i64 [%40, %$13], [%79, %$20] ; # Y
  %92 = phi i64 [%41, %$13], [%80, %$20] ; # N
  %93 = phi i64 [%42, %$13], [%81, %$20] ; # Bnd
  %94 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$13], [%82, %$20] ; # ->
  br label %$9
$8:
  %95 = phi i64 [%25, %$4] ; # X
  %96 = phi i64 [%26, %$4] ; # Y
  %97 = phi i64 [%27, %$4] ; # N
  %98 = phi i64 [%28, %$4] ; # Bnd
  br label %$9
$9:
  %99 = phi i64 [%90, %$12], [%95, %$8] ; # X
  %100 = phi i64 [%91, %$12], [%96, %$8] ; # Y
  %101 = phi i64 [%92, %$12], [%97, %$8] ; # N
  %102 = phi i64 [%93, %$12], [%98, %$8] ; # Bnd
  %103 = phi i64 [%94, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  br label %$6
$5:
  %104 = phi i64 [%20, %$3] ; # X
  %105 = phi i64 [%21, %$3] ; # Y
  %106 = phi i64 [%22, %$3] ; # N
  %107 = phi i64 [%23, %$3] ; # Bnd
; # (let Z Y (when N (loop (? (=0 Bnd)) (? (and (== Y (val 2 Bnd)) (p...
; # (when N (loop (? (=0 Bnd)) (? (and (== Y (val 2 Bnd)) (prog (setq...
  %108 = icmp ne i64 %106, 0
  br i1 %108, label %$21, label %$22
$21:
  %109 = phi i64 [%104, %$5] ; # X
  %110 = phi i64 [%105, %$5] ; # Y
  %111 = phi i64 [%106, %$5] ; # N
  %112 = phi i64 [%107, %$5] ; # Bnd
  %113 = phi i64 [%105, %$5] ; # Z
; # (loop (? (=0 Bnd)) (? (and (== Y (val 2 Bnd)) (prog (setq Z Bnd) ...
  br label %$23
$23:
  %114 = phi i64 [%109, %$21], [%142, %$28] ; # X
  %115 = phi i64 [%110, %$21], [%143, %$28] ; # Y
  %116 = phi i64 [%111, %$21], [%144, %$28] ; # N
  %117 = phi i64 [%112, %$21], [%149, %$28] ; # Bnd
  %118 = phi i64 [%113, %$21], [%146, %$28] ; # Z
; # (? (=0 Bnd))
; # (=0 Bnd)
  %119 = icmp eq i64 %117, 0
  br i1 %119, label %$25, label %$24
$24:
  %120 = phi i64 [%114, %$23] ; # X
  %121 = phi i64 [%115, %$23] ; # Y
  %122 = phi i64 [%116, %$23] ; # N
  %123 = phi i64 [%117, %$23] ; # Bnd
  %124 = phi i64 [%118, %$23] ; # Z
; # (? (and (== Y (val 2 Bnd)) (prog (setq Z Bnd) (=0 (dec 'N)))))
; # (and (== Y (val 2 Bnd)) (prog (setq Z Bnd) (=0 (dec 'N))))
; # (val 2 Bnd)
  %125 = inttoptr i64 %123 to i64*
  %126 = getelementptr i64, i64* %125, i32 1
  %127 = load i64, i64* %126
; # (== Y (val 2 Bnd))
  %128 = icmp eq i64 %121, %127
  br i1 %128, label %$27, label %$26
$27:
  %129 = phi i64 [%120, %$24] ; # X
  %130 = phi i64 [%121, %$24] ; # Y
  %131 = phi i64 [%122, %$24] ; # N
  %132 = phi i64 [%123, %$24] ; # Bnd
  %133 = phi i64 [%124, %$24] ; # Z
; # (dec 'N)
  %134 = sub i64 %131, 1
; # (=0 (dec 'N))
  %135 = icmp eq i64 %134, 0
  br label %$26
$26:
  %136 = phi i64 [%120, %$24], [%129, %$27] ; # X
  %137 = phi i64 [%121, %$24], [%130, %$27] ; # Y
  %138 = phi i64 [%122, %$24], [%134, %$27] ; # N
  %139 = phi i64 [%123, %$24], [%132, %$27] ; # Bnd
  %140 = phi i64 [%124, %$24], [%132, %$27] ; # Z
  %141 = phi i1 [0, %$24], [%135, %$27] ; # ->
  br i1 %141, label %$25, label %$28
$28:
  %142 = phi i64 [%136, %$26] ; # X
  %143 = phi i64 [%137, %$26] ; # Y
  %144 = phi i64 [%138, %$26] ; # N
  %145 = phi i64 [%139, %$26] ; # Bnd
  %146 = phi i64 [%140, %$26] ; # Z
; # (val 3 Bnd)
  %147 = inttoptr i64 %145 to i64*
  %148 = getelementptr i64, i64* %147, i32 2
  %149 = load i64, i64* %148
  br label %$23
$25:
  %150 = phi i64 [%114, %$23], [%136, %$26] ; # X
  %151 = phi i64 [%115, %$23], [%137, %$26] ; # Y
  %152 = phi i64 [%116, %$23], [%138, %$26] ; # N
  %153 = phi i64 [%117, %$23], [%139, %$26] ; # Bnd
  %154 = phi i64 [%118, %$23], [%140, %$26] ; # Z
  %155 = phi i64 [0, %$23], [0, %$26] ; # ->
  br label %$22
$22:
  %156 = phi i64 [%104, %$5], [%150, %$25] ; # X
  %157 = phi i64 [%105, %$5], [%151, %$25] ; # Y
  %158 = phi i64 [%106, %$5], [%152, %$25] ; # N
  %159 = phi i64 [%107, %$5], [%153, %$25] ; # Bnd
  %160 = phi i64 [%105, %$5], [%154, %$25] ; # Z
; # (if (atom (shift X)) (val Z) (set Z (eval (car X))))
; # (shift X)
  %161 = inttoptr i64 %156 to i64*
  %162 = getelementptr i64, i64* %161, i32 1
  %163 = load i64, i64* %162
; # (atom (shift X))
  %164 = and i64 %163, 15
  %165 = icmp ne i64 %164, 0
  br i1 %165, label %$29, label %$30
$29:
  %166 = phi i64 [%163, %$22] ; # X
  %167 = phi i64 [%157, %$22] ; # Y
  %168 = phi i64 [%158, %$22] ; # N
  %169 = phi i64 [%159, %$22] ; # Bnd
  %170 = phi i64 [%160, %$22] ; # Z
; # (val Z)
  %171 = inttoptr i64 %170 to i64*
  %172 = load i64, i64* %171
  br label %$31
$30:
  %173 = phi i64 [%163, %$22] ; # X
  %174 = phi i64 [%157, %$22] ; # Y
  %175 = phi i64 [%158, %$22] ; # N
  %176 = phi i64 [%159, %$22] ; # Bnd
  %177 = phi i64 [%160, %$22] ; # Z
; # (set Z (eval (car X)))
; # (car X)
  %178 = inttoptr i64 %173 to i64*
  %179 = load i64, i64* %178
; # (eval (car X))
  %180 = and i64 %179, 6
  %181 = icmp ne i64 %180, 0
  br i1 %181, label %$34, label %$33
$34:
  br label %$32
$33:
  %182 = and i64 %179, 8
  %183 = icmp ne i64 %182, 0
  br i1 %183, label %$36, label %$35
$36:
  %184 = inttoptr i64 %179 to i64*
  %185 = load i64, i64* %184
  br label %$32
$35:
  %186 = call i64 @evList(i64 %179)
  br label %$32
$32:
  %187 = phi i64 [%179, %$34], [%185, %$36], [%186, %$35] ; # ->
  %188 = inttoptr i64 %177 to i64*
  store i64 %187, i64* %188
  br label %$31
$31:
  %189 = phi i64 [%166, %$29], [%173, %$32] ; # X
  %190 = phi i64 [%167, %$29], [%174, %$32] ; # Y
  %191 = phi i64 [%168, %$29], [%175, %$32] ; # N
  %192 = phi i64 [%169, %$29], [%176, %$32] ; # Bnd
  %193 = phi i64 [%170, %$29], [%177, %$32] ; # Z
  %194 = phi i64 [%172, %$29], [%187, %$32] ; # ->
  br label %$6
$6:
  %195 = phi i64 [%99, %$9], [%189, %$31] ; # X
  %196 = phi i64 [%100, %$9], [%190, %$31] ; # Y
  %197 = phi i64 [%101, %$9], [%191, %$31] ; # N
  %198 = phi i64 [%102, %$9], [%192, %$31] ; # Bnd
  %199 = phi i64 [%103, %$9], [%194, %$31] ; # ->
  ret i64 %199
}

define i64 @_history(i64) {
$1:
; # (let X (cdr Exe) (if (atom X) (let P (history_list) (if (and P (v...
; # (cdr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
; # (if (atom X) (let P (history_list) (if (and P (val P)) (let (Y (c...
; # (atom X)
  %4 = and i64 %3, 15
  %5 = icmp ne i64 %4, 0
  br i1 %5, label %$2, label %$3
$2:
; # (let P (history_list) (if (and P (val P)) (let (Y (cons (mkStr (v...
; # (history_list)
  %6 = call i8*** @history_list()
; # (if (and P (val P)) (let (Y (cons (mkStr (val (val P))) $Nil) R (...
; # (and P (val P))
  %7 = icmp ne i8*** %6, null
  br i1 %7, label %$6, label %$5
$6:
; # (val P)
  %8 = load i8**, i8*** %6
  %9 = icmp ne i8** %8, null
  br label %$5
$5:
  %10 = phi i1 [0, %$2], [%9, %$6] ; # ->
  br i1 %10, label %$7, label %$8
$7:
; # (let (Y (cons (mkStr (val (val P))) $Nil) R (save Y) I 0) (while ...
; # (val P)
  %11 = load i8**, i8*** %6
; # (val (val P))
  %12 = load i8*, i8** %11
; # (mkStr (val (val P)))
  %13 = call i64 @mkStr(i8* %12)
; # (cons (mkStr (val (val P))) $Nil)
  %14 = call i64 @cons(i64 %13, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (save Y)
  %15 = alloca i64, i64 2, align 16
  %16 = ptrtoint i64* %15 to i64
  %17 = inttoptr i64 %16 to i64*
  store i64 %14, i64* %17
  %18 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  %19 = load i64, i64* %18
  %20 = inttoptr i64 %16 to i64*
  %21 = getelementptr i64, i64* %20, i32 1
  store i64 %19, i64* %21
  %22 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %16, i64* %22
; # (while (val (ofs P (inc 'I))) (setq Y (set 2 Y (cons (mkStr (val ...
  br label %$10
$10:
  %23 = phi i64 [%14, %$7], [%33, %$11] ; # Y
  %24 = phi i64 [0, %$7], [%30, %$11] ; # I
; # (inc 'I)
  %25 = add i64 %24, 1
; # (ofs P (inc 'I))
  %26 = getelementptr i8**, i8*** %6, i64 %25
; # (val (ofs P (inc 'I)))
  %27 = load i8**, i8*** %26
  %28 = icmp ne i8** %27, null
  br i1 %28, label %$11, label %$12
$11:
  %29 = phi i64 [%23, %$10] ; # Y
  %30 = phi i64 [%25, %$10] ; # I
; # (set 2 Y (cons (mkStr (val @)) $Nil))
; # (val @)
  %31 = load i8*, i8** %27
; # (mkStr (val @))
  %32 = call i64 @mkStr(i8* %31)
; # (cons (mkStr (val @)) $Nil)
  %33 = call i64 @cons(i64 %32, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  %34 = inttoptr i64 %29 to i64*
  %35 = getelementptr i64, i64* %34, i32 1
  store i64 %33, i64* %35
  br label %$10
$12:
  %36 = phi i64 [%23, %$10] ; # Y
  %37 = phi i64 [%25, %$10] ; # I
; # (drop *Safe)
  %38 = inttoptr i64 %16 to i64*
  %39 = getelementptr i64, i64* %38, i32 1
  %40 = load i64, i64* %39
  %41 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 0) to i64) to i64*
  store i64 %40, i64* %41
  br label %$9
$8:
  br label %$9
$9:
  %42 = phi i64 [%14, %$12], [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$8] ; # ->
  br label %$4
$3:
; # (clear_history)
  call void @clear_history()
; # (let (Y (needLst Exe (eval (car X))) Z Y) (while (pair Z) (let (N...
; # (car X)
  %43 = inttoptr i64 %3 to i64*
  %44 = load i64, i64* %43
; # (eval (car X))
  %45 = and i64 %44, 6
  %46 = icmp ne i64 %45, 0
  br i1 %46, label %$15, label %$14
$15:
  br label %$13
$14:
  %47 = and i64 %44, 8
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$17, label %$16
$17:
  %49 = inttoptr i64 %44 to i64*
  %50 = load i64, i64* %49
  br label %$13
$16:
  %51 = call i64 @evList(i64 %44)
  br label %$13
$13:
  %52 = phi i64 [%44, %$15], [%50, %$17], [%51, %$16] ; # ->
; # (needLst Exe (eval (car X)))
  %53 = and i64 %52, 15
  %54 = icmp eq i64 %53, 0
  br i1 %54, label %$18, label %$19
$19:
  %55 = icmp eq i64 %52, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br label %$18
$18:
  %56 = phi i1 [1, %$13], [%55, %$19] ; # ->
  br i1 %56, label %$21, label %$20
$20:
  call void @lstErr(i64 %0, i64 %52)
  unreachable
$21:
; # (while (pair Z) (let (Nm (xName Exe (xSym (++ Z))) Stk (stack)) (...
  br label %$22
$22:
  %57 = phi i64 [%52, %$21], [%64, %$23] ; # Z
; # (pair Z)
  %58 = and i64 %57, 15
  %59 = icmp eq i64 %58, 0
  br i1 %59, label %$23, label %$24
$23:
  %60 = phi i64 [%57, %$22] ; # Z
; # (let (Nm (xName Exe (xSym (++ Z))) Stk (stack)) (add_history (buf...
; # (++ Z)
  %61 = inttoptr i64 %60 to i64*
  %62 = load i64, i64* %61
  %63 = getelementptr i64, i64* %61, i32 1
  %64 = load i64, i64* %63
; # (xSym (++ Z))
  %65 = call i64 @xSym(i64 %62)
; # (xName Exe (xSym (++ Z)))
  %66 = call i64 @xName(i64 %0, i64 %65)
; # (stack)
  %67 = call i8* @llvm.stacksave()
; # (bufSize Nm)
  %68 = call i64 @bufSize(i64 %66)
; # (b8 (bufSize Nm))
  %69 = alloca i8, i64 %68
; # (bufString Nm (b8 (bufSize Nm)))
  %70 = call i8* @bufString(i64 %66, i8* %69)
; # (add_history (bufString Nm (b8 (bufSize Nm))))
  call void @add_history(i8* %70)
; # (stack Stk)
  call void @llvm.stackrestore(i8* %67)
  br label %$22
$24:
  %71 = phi i64 [%57, %$22] ; # Z
  br label %$4
$4:
  %72 = phi i64 [%42, %$9], [%52, %$24] ; # ->
  ret i64 %72
}

define i64 @_version(i64) {
$1:
; # (when (nil? (eval (cadr Exe))) (outWord (int (val $Y))) (call $Pu...
; # (cadr Exe)
  %1 = inttoptr i64 %0 to i64*
  %2 = getelementptr i64, i64* %1, i32 1
  %3 = load i64, i64* %2
  %4 = inttoptr i64 %3 to i64*
  %5 = load i64, i64* %4
; # (eval (cadr Exe))
  %6 = and i64 %5, 6
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %$4, label %$3
$4:
  br label %$2
$3:
  %8 = and i64 %5, 8
  %9 = icmp ne i64 %8, 0
  br i1 %9, label %$6, label %$5
$6:
  %10 = inttoptr i64 %5 to i64*
  %11 = load i64, i64* %10
  br label %$2
$5:
  %12 = call i64 @evList(i64 %5)
  br label %$2
$2:
  %13 = phi i64 [%5, %$4], [%11, %$6], [%12, %$5] ; # ->
; # (nil? (eval (cadr Exe)))
  %14 = icmp eq i64 %13, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64)
  br i1 %14, label %$7, label %$8
$7:
; # (val $Y)
  %15 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 0) to i64) to i64*
  %16 = load i64, i64* %15
; # (int (val $Y))
  %17 = lshr i64 %16, 4
; # (outWord (int (val $Y)))
  call void @outWord(i64 %17)
; # (call $Put (char "."))
  %18 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %18(i8 46)
; # (val $M)
  %19 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 8) to i64) to i64*
  %20 = load i64, i64* %19
; # (int (val $M))
  %21 = lshr i64 %20, 4
; # (outWord (int (val $M)))
  call void @outWord(i64 %21)
; # (call $Put (char "."))
  %22 = load void(i8)*, void(i8)** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 80) to void(i8)**)
  call void %22(i8 46)
; # (val $D)
  %23 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 16) to i64) to i64*
  %24 = load i64, i64* %23
; # (int (val $D))
  %25 = lshr i64 %24, 4
; # (outWord (int (val $D)))
  call void @outWord(i64 %25)
; # (newline)
  call void @newline()
  br label %$8
$8:
; # (val $Y)
  %26 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 0) to i64) to i64*
  %27 = load i64, i64* %26
; # (val $M)
  %28 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 8) to i64) to i64*
  %29 = load i64, i64* %28
; # (val $D)
  %30 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([3 x i64]* @$Version to i8*), i32 16) to i64) to i64*
  %31 = load i64, i64* %30
; # (cons (val $D) $Nil)
  %32 = call i64 @cons(i64 %31, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (cons (val $M) (cons (val $D) $Nil))
  %33 = call i64 @cons(i64 %29, i64 %32)
; # (cons (val $Y) (cons (val $M) (cons (val $D) $Nil)))
  %34 = call i64 @cons(i64 %27, i64 %33)
  ret i64 %34
}

define i32 @main(i32, i8**) {
$1:
; # (set $AV0 (val Av))
; # (val Av)
  %2 = load i8*, i8** %1
  store i8* %2, i8** @$AV0
; # (set $AV (setq Av (ofs Av 1)))
; # (ofs Av 1)
  %3 = getelementptr i8*, i8** %1, i32 1
  store i8** %3, i8*** @$AV
; # (let P (ofs Av (- Ac 2)) (unless (strcmp (val P) ($ "+")) (set $D...
; # (- Ac 2)
  %4 = sub i32 %0, 2
; # (ofs Av (- Ac 2))
  %5 = getelementptr i8*, i8** %3, i32 %4
; # (unless (strcmp (val P) ($ "+")) (set $Dbg $T P null))
; # (val P)
  %6 = load i8*, i8** %5
; # (strcmp (val P) ($ "+"))
  %7 = call i32 @strcmp(i8* %6, i8* bitcast ([2 x i8]* @$81 to i8*))
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %$3, label %$2
$2:
  %9 = phi i8** [%3, %$1] ; # Av
; # (set $Dbg $T P null)
  %10 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 744) to i64) to i64*
  store i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 184) to i64), i64* %10
  store i8* null, i8** %5
  br label %$3
$3:
  %11 = phi i8** [%3, %$1], [%9, %$2] ; # Av
; # (let P (val Av) (when (and P (<> (val P) (char "-"))) (let Q (str...
; # (val Av)
  %12 = load i8*, i8** %11
; # (when (and P (<> (val P) (char "-"))) (let Q (strrchr P (char "/"...
; # (and P (<> (val P) (char "-")))
  %13 = icmp ne i8* %12, null
  br i1 %13, label %$5, label %$4
$5:
  %14 = phi i8** [%11, %$3] ; # Av
; # (val P)
  %15 = load i8, i8* %12
; # (<> (val P) (char "-"))
  %16 = icmp ne i8 %15, 45
  br label %$4
$4:
  %17 = phi i8** [%11, %$3], [%14, %$5] ; # Av
  %18 = phi i1 [0, %$3], [%16, %$5] ; # ->
  br i1 %18, label %$6, label %$7
$6:
  %19 = phi i8** [%17, %$4] ; # Av
; # (let Q (strrchr P (char "/")) (unless (or (=0 Q) (and (== Q (+ P ...
; # (strrchr P (char "/"))
  %20 = call i8* @strrchr(i8* %12, i32 47)
; # (unless (or (=0 Q) (and (== Q (+ P 1)) (== (val P) (char ".")))) ...
; # (or (=0 Q) (and (== Q (+ P 1)) (== (val P) (char "."))))
; # (=0 Q)
  %21 = icmp eq i8* %20, null
  br i1 %21, label %$8, label %$9
$9:
  %22 = phi i8** [%19, %$6] ; # Av
; # (and (== Q (+ P 1)) (== (val P) (char ".")))
; # (+ P 1)
  %23 = getelementptr i8, i8* %12, i32 1
; # (== Q (+ P 1))
  %24 = icmp eq i8* %20, %23
  br i1 %24, label %$11, label %$10
$11:
  %25 = phi i8** [%22, %$9] ; # Av
; # (val P)
  %26 = load i8, i8* %12
; # (== (val P) (char "."))
  %27 = icmp eq i8 %26, 46
  br label %$10
$10:
  %28 = phi i8** [%22, %$9], [%25, %$11] ; # Av
  %29 = phi i1 [0, %$9], [%27, %$11] ; # ->
  br label %$8
$8:
  %30 = phi i8** [%19, %$6], [%28, %$10] ; # Av
  %31 = phi i1 [1, %$6], [%29, %$10] ; # ->
  br i1 %31, label %$13, label %$12
$12:
  %32 = phi i8** [%30, %$8] ; # Av
; # (let (N (+ (- Q P) 1) H (malloc (+ N 1))) (set $Home H $HomeLen N...
; # (- Q P)
  %33 = ptrtoint i8* %20 to i64
  %34 = ptrtoint i8* %12 to i64
  %35 = sub i64 %33, %34
; # (+ (- Q P) 1)
  %36 = add i64 %35, 1
; # (+ N 1)
  %37 = add i64 %36, 1
; # (malloc (+ N 1))
  %38 = call i8* @malloc(i64 %37)
; # (set $Home H $HomeLen N)
  store i8* %38, i8** @$Home
  store i64 %36, i64* @$HomeLen
; # (memcpy H P N)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %38, i8* %12, i64 %36, i1 0)
; # (set (ofs H N) 0)
; # (ofs H N)
  %39 = getelementptr i8, i8* %38, i64 %36
  store i8 0, i8* %39
  br label %$13
$13:
  %40 = phi i8** [%30, %$8], [%32, %$12] ; # Av
  br label %$7
$7:
  %41 = phi i8** [%17, %$4], [%40, %$13] ; # Av
; # (heapAlloc)
  call void @heapAlloc()
; # (let P $Nil (loop (let Nm (val (tail P)) (when (num? Nm) (intern ...
; # (loop (let Nm (val (tail P)) (when (num? Nm) (intern P 0 @ (cdr $...
  br label %$14
$14:
  %42 = phi i8** [%41, %$7], [%65, %$16] ; # Av
  %43 = phi i64 [ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64), %$7], [%67, %$16] ; # P
; # (let Nm (val (tail P)) (when (num? Nm) (intern P 0 @ (cdr $Pico) ...
; # (tail P)
  %44 = add i64 %43, -8
; # (val (tail P))
  %45 = inttoptr i64 %44 to i64*
  %46 = load i64, i64* %45
; # (when (num? Nm) (intern P 0 @ (cdr $Pico) $Nil) (? (== P $LastSym...
; # (num? Nm)
  %47 = and i64 %46, 6
  %48 = icmp ne i64 %47, 0
  br i1 %48, label %$15, label %$16
$15:
  %49 = phi i8** [%42, %$14] ; # Av
  %50 = phi i64 [%43, %$14] ; # P
; # (cdr $Pico)
  %51 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 80) to i64) to i64*
  %52 = getelementptr i64, i64* %51, i32 1
  %53 = load i64, i64* %52
; # (intern P 0 @ (cdr $Pico) $Nil)
  %54 = call i64 @intern(i64 %50, i64 0, i64 %46, i64 %53, i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
; # (? (== P $LastSym))
; # (== P $LastSym)
  %55 = icmp eq i64 %50, ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 6712) to i64)
  br i1 %55, label %$18, label %$17
$17:
  %56 = phi i8** [%49, %$15] ; # Av
  %57 = phi i64 [%50, %$15] ; # P
; # (when (big? Nm) (setq P (ofs P 2)))
; # (big? Nm)
  %58 = and i64 %46, 4
  %59 = icmp ne i64 %58, 0
  br i1 %59, label %$19, label %$20
$19:
  %60 = phi i8** [%56, %$17] ; # Av
  %61 = phi i64 [%57, %$17] ; # P
; # (ofs P 2)
  %62 = add i64 %61, 16
  br label %$20
$20:
  %63 = phi i8** [%56, %$17], [%60, %$19] ; # Av
  %64 = phi i64 [%57, %$17], [%62, %$19] ; # P
  br label %$16
$16:
  %65 = phi i8** [%42, %$14], [%63, %$20] ; # Av
  %66 = phi i64 [%43, %$14], [%64, %$20] ; # P
; # (ofs P 2)
  %67 = add i64 %66, 16
  br label %$14
$18:
  %68 = phi i8** [%49, %$15] ; # Av
  %69 = phi i64 [%50, %$15] ; # P
  %70 = phi i64 [0, %$15] ; # ->
; # (set $OS (mkStr TgOS) $CPU (mkStr TgCPU) $Pid (cnt (i64 (getpid))...
; # (mkStr TgOS)
  %71 = call i64 @mkStr(i8* @TgOS)
  %72 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 312) to i64) to i64*
  store i64 %71, i64* %72
; # (mkStr TgCPU)
  %73 = call i64 @mkStr(i8* @TgCPU)
  %74 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 328) to i64) to i64*
  store i64 %73, i64* %74
; # (getpid)
  %75 = call i32 @getpid()
; # (i64 (getpid))
  %76 = sext i32 %75 to i64
; # (cnt (i64 (getpid)))
  %77 = shl i64 %76, 4
  %78 = or i64 %77, 2
  %79 = inttoptr i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 344) to i64) to i64*
  store i64 %78, i64* %79
; # (tail $Db1)
  %80 = add i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 40) to i64), -8
  %81 = inttoptr i64 %80 to i64*
  store i64 26, i64* %81
; # (cons $Db1 $Nil)
  %82 = call i64 @cons(i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 40) to i64), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  store i64 %82, i64* @$Extern
; # (initOutFile 2)
  %83 = call i8* @initOutFile(i32 2)
; # (set $OutFile (initOutFile 1))
; # (initOutFile 1)
  %84 = call i8* @initOutFile(i32 1)
  store i8* %84, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 104) to i8**)
; # (set $InFile (initInFile 0 null))
; # (initInFile 0 null)
  %85 = call i8* @initInFile(i32 0, i8* null)
  store i8* %85, i8** bitcast (i8* getelementptr (i8, i8* bitcast ([24 x i64]* @env to i8*), i32 96) to i8**)
; # (set Tio (=0 (tcgetattr 0 OrgTermio)))
; # (tcgetattr 0 OrgTermio)
  %86 = call i32 @tcgetattr(i32 0, i8* @OrgTermio)
; # (=0 (tcgetattr 0 OrgTermio))
  %87 = icmp eq i32 %86, 0
  store i1 %87, i1* @Tio
; # (sigUnblock 0)
  call void @sigUnblock(i32 0)
; # (val SIGHUP Sig)
  %88 = getelementptr i32, i32* @Sig, i32 0
  %89 = load i32, i32* %88
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %90 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGHUP Sig) (fun sig))
  call void @iSignal(i32 %89, i8* %90)
; # (val SIGUSR1 Sig)
  %91 = getelementptr i32, i32* @Sig, i32 2
  %92 = load i32, i32* %91
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %93 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGUSR1 Sig) (fun sig))
  call void @iSignal(i32 %92, i8* %93)
; # (val SIGUSR2 Sig)
  %94 = getelementptr i32, i32* @Sig, i32 3
  %95 = load i32, i32* %94
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %96 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGUSR2 Sig) (fun sig))
  call void @iSignal(i32 %95, i8* %96)
; # (val SIGALRM Sig)
  %97 = getelementptr i32, i32* @Sig, i32 5
  %98 = load i32, i32* %97
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %99 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGALRM Sig) (fun sig))
  call void @iSignal(i32 %98, i8* %99)
; # (val SIGTERM Sig)
  %100 = getelementptr i32, i32* @Sig, i32 6
  %101 = load i32, i32* %100
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %102 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGTERM Sig) (fun sig))
  call void @iSignal(i32 %101, i8* %102)
; # (val SIGIO Sig)
  %103 = getelementptr i32, i32* @Sig, i32 13
  %104 = load i32, i32* %103
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %105 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGIO Sig) (fun sig))
  call void @iSignal(i32 %104, i8* %105)
; # (when (== (signal (val SIGTSTP Sig) (val SigIgn)) (val SigDfl)) (...
; # (val SIGTSTP Sig)
  %106 = getelementptr i32, i32* @Sig, i32 10
  %107 = load i32, i32* %106
; # (val SigIgn)
  %108 = load i8*, i8** @SigIgn
; # (signal (val SIGTSTP Sig) (val SigIgn))
  %109 = call i8* @signal(i32 %107, i8* %108)
; # (val SigDfl)
  %110 = load i8*, i8** @SigDfl
; # (== (signal (val SIGTSTP Sig) (val SigIgn)) (val SigDfl))
  %111 = icmp eq i8* %109, %110
  br i1 %111, label %$21, label %$22
$21:
  %112 = phi i8** [%68, %$18] ; # Av
; # (val SIGTSTP Sig)
  %113 = getelementptr i32, i32* @Sig, i32 10
  %114 = load i32, i32* %113
; # (fun sig)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %115 = bitcast void(i32)* @sig to i8*
; # (iSignal (val SIGTSTP Sig) (fun sig))
  call void @iSignal(i32 %114, i8* %115)
  br label %$22
$22:
  %116 = phi i8** [%68, %$18], [%112, %$21] ; # Av
; # (val SIGINT Sig)
  %117 = getelementptr i32, i32* @Sig, i32 1
  %118 = load i32, i32* %117
; # (fun sigTerm)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %119 = bitcast void(i32)* @sigTerm to i8*
; # (iSignal (val SIGINT Sig) (fun sigTerm))
  call void @iSignal(i32 %118, i8* %119)
; # (val SIGCHLD Sig)
  %120 = getelementptr i32, i32* @Sig, i32 7
  %121 = load i32, i32* %120
; # (fun sigChld)
; # (i8* (def (pico~pack "@" (pico~car priv~Args)) (func (; priv~Args...
  %122 = bitcast void(i32)* @sigChld to i8*
; # (signal (val SIGCHLD Sig) (fun sigChld))
  %123 = call i8* @signal(i32 %121, i8* %122)
; # (val SIGPIPE Sig)
  %124 = getelementptr i32, i32* @Sig, i32 4
  %125 = load i32, i32* %124
; # (val SigIgn)
  %126 = load i8*, i8** @SigIgn
; # (signal (val SIGPIPE Sig) (val SigIgn))
  %127 = call i8* @signal(i32 %125, i8* %126)
; # (val SIGTTIN Sig)
  %128 = getelementptr i32, i32* @Sig, i32 11
  %129 = load i32, i32* %128
; # (val SigIgn)
  %130 = load i8*, i8** @SigIgn
; # (signal (val SIGTTIN Sig) (val SigIgn))
  %131 = call i8* @signal(i32 %129, i8* %130)
; # (val SIGTTOU Sig)
  %132 = getelementptr i32, i32* @Sig, i32 12
  %133 = load i32, i32* %132
; # (val SigIgn)
  %134 = load i8*, i8** @SigIgn
; # (signal (val SIGTTOU Sig) (val SigIgn))
  %135 = call i8* @signal(i32 %133, i8* %134)
; # (set $USec (getUsec YES))
; # (getUsec YES)
  %136 = call i64 @getUsec(i1 1)
  store i64 %136, i64* @$USec
; # (unless (setjmp QuitRst) (loadAll 0))
; # (setjmp QuitRst)
  %137 = call i32 @setjmp(i8* @QuitRst)
  %138 = icmp ne i32 %137, 0
  br i1 %138, label %$24, label %$23
$23:
  %139 = phi i8** [%116, %$22] ; # Av
; # (loadAll 0)
  %140 = call i64 @loadAll(i64 0)
  br label %$24
$24:
  %141 = phi i8** [%116, %$22], [%139, %$23] ; # Av
; # (loop (repl 0 ($ ": ") $Nil))
  br label %$25
$25:
  %142 = phi i8** [%141, %$24], [%142, %$25] ; # Av
; # (repl 0 ($ ": ") $Nil)
  %143 = call i64 @repl(i64 0, i8* bitcast ([3 x i8]* @$82 to i8*), i64 ptrtoint (i8* getelementptr (i8, i8* bitcast ([840 x i64]* @SymTab to i8*), i32 8) to i64))
  br label %$25
}

@$82 = private constant [3 x i8] c": \00"
@$81 = private constant [2 x i8] c"+\00"
@$80 = private constant [19 x i8] c"Too many callbacks\00"
@$79 = private constant [9 x i8] c"[DLL] %s\00"
@$78 = private constant [8 x i8] c"Bad ffi\00"
@$77 = private constant [16 x i8] c"Bad result spec\00"
@$76 = private constant [2 x i8] c".\00"
@$75 = private constant [3 x i8] c"%s\00"
@$74 = private constant [10 x i8] c"Undefined\00"
@$73 = private constant [11 x i8] c"Not making\00"
@$72 = private constant [3 x i8] c"+ \00"
@$71 = private constant [9 x i8] c"wait pid\00"
@$70 = private constant [4 x i8] c" = \00"
@$69 = private constant [3 x i8] c" :\00"
@$68 = private constant [9 x i8] c"No Break\00"
@$67 = private constant [3 x i8] c"! \00"
@$66 = private constant [20 x i8] c"Coroutine not found\00"
@$65 = private constant [13 x i8] c"Tag expected\00"
@$64 = private constant [14 x i8] c"No coroutines\00"
@$63 = private constant [20 x i8] c"Reentrant coroutine\00"
@$62 = private constant [14 x i8] c"Tag not found\00"
@$61 = private constant [12 x i8] c" redefined\0A\00"
@$60 = private constant [3 x i8] c"# \00"
@$59 = private constant [28 x i8] c"Transaction fsync error: %s\00"
@$58 = private constant [7 x i8] c"Bad ID\00"
@$57 = private constant [3 x i8] c"a+\00"
@$56 = private constant [2 x i8] c"a\00"
@$55 = private constant [23 x i8] c"Log truncate error: %s\00"
@$54 = private constant [42 x i8] c"Last transaction not completed: Rollback\0A\00"
@$53 = private constant [35 x i8] c"Discarding incomplete transaction\0A\00"
@$52 = private constant [12 x i8] c"DB Oversize\00"
@$51 = private constant [14 x i8] c"Log write: %s\00"
@$50 = private constant [18 x i8] c"Journal write: %s\00"
@$49 = private constant [19 x i8] c"DB fsync error: %s\00"
@$48 = private constant [12 x i8] c"Bad Journal\00"
@$47 = private constant [13 x i8] c"DB write: %s\00"
@$46 = private constant [12 x i8] c"DB read: %s\00"
@$45 = private constant [12 x i8] c"Bad DB file\00"
@$44 = private constant [3 x i8] c"> \00"
@$43 = private constant [4 x i8] c"-> \00"
@$42 = private constant [14 x i8] c"Size overflow\00"
@$41 = private constant [4 x i8] c" . \00"
@$40 = private constant [27 x i8] c"Super parentheses mismatch\00"
@$39 = private constant [16 x i8] c"Bad dotted pair\00"
@$38 = private constant [15 x i8] c"sync write: %s\00"
@$37 = private constant [14 x i8] c"No current fd\00"
@$36 = private constant [14 x i8] c"Tell PIPE_BUF\00"
@$35 = private constant [16 x i8] c"child write: %s\00"
@$34 = private constant [16 x i8] c"bytes write: %s\00"
@$33 = private constant [9 x i8] c"SETFD %s\00"
@$32 = private constant [17 x i8] c"Select error: %s\00"
@$31 = private constant [7 x i8] c"Bad FD\00"
@$30 = private constant [15 x i8] c"Bad input '%s'\00"
@$29 = private constant [12 x i8] c"EOF Overrun\00"
@$28 = private constant [15 x i8] c"Pipe error: %s\00"
@$27 = private constant [16 x i8] c"Close error: %s\00"
@$26 = private constant [15 x i8] c"Open error: %s\00"
@$25 = private constant [6 x i8] c"Div/0\00"
@$24 = private constant [4 x i8] c".so\00"
@$23 = private constant [5 x i8] c"lib/\00"
@$22 = private constant [21 x i8] c"Bad symbol namespace\00"
@$21 = private constant [11 x i8] c"Can't fork\00"
@$20 = private constant [14 x i8] c"File lock: %s\00"
@$19 = private constant [17 x i8] c"Protected symbol\00"
@$18 = private constant [15 x i8] c"Item not found\00"
@$17 = private constant [18 x i8] c"Variable expected\00"
@$16 = private constant [14 x i8] c"List expected\00"
@$15 = private constant [19 x i8] c"Cons pair expected\00"
@$14 = private constant [14 x i8] c"Atom expected\00"
@$13 = private constant [14 x i8] c"Name expected\00"
@$12 = private constant [25 x i8] c"External symbol expected\00"
@$11 = private constant [16 x i8] c"Symbol expected\00"
@$10 = private constant [16 x i8] c"Number expected\00"
@$9 = private constant [22 x i8] c"Small number expected\00"
@$8 = private constant [13 x i8] c"Bad argument\00"
@$7 = private constant [15 x i8] c"Stack overflow\00"
@$6 = private constant [3 x i8] c"? \00"
@$5 = private constant [5 x i8] c" -- \00"
@$4 = private constant [4 x i8] c"!? \00"
@$3 = private constant [10 x i8] c"No memory\00"
@$2 = private constant [16 x i8] c"%s: Can't exec\0A\00"
@$1 = private constant [2 x i8] c"\0A\00"
